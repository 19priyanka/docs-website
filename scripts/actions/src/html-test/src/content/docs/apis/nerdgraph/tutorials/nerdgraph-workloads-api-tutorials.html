
<p>New Relic allows you to group entities together in groupings called <a href="/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-one-workloads-isolate-resolve-incidents-faster">workloads</a>. This enables better monitoring of the full stack used by a team or project.</p>
<p>Here we show you how to use our <a href="/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph">NerdGraph API</a> to do some workloads-related tasks:</p>
<ul>
  <li><a href="#get_workloads">Get the workloads of an account</a></li>
  <li><a href="#get_entities_list">Get the list of entities in a workload</a></li>
  <li><a href="#get_status">Get the status of a workload</a></li>
  <li><a href="#create-workload">Create a workload</a></li>
  <li><a href="#modify">Modify a workload</a></li>
  <li><a href="#static">Set a static status for a workload</a></li>
  <li><a href="#automatic">Modify the automatic status rules for a workload</a></li>
  <li><a href="#duplicate">Duplicate a workload</a></li>
  <li><a href="#delete">Delete a workload</a></li>
</ul>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJpbXBvcnRhbnQifV0=">
  <p>You can also use the <a href="http://developer.newrelic.com/build-tools/new-relic-one-applications/cli">CLI</a> and <a href="https://www.terraform.io/docs/providers/newrelic/r/workload.html">Terraform resource</a> to automate these tasks.</p>
</div>
<h2>Get the workloads of an account [#get_workloads]</h2>
<p>To get all workloads of an account, use the following <a href="https://api.newrelic.com/graphiql">GraphQL query</a> and pass the account ID via the <code>id</code> field. In this example, we retrieve three basic fields:</p>
<ul>
  <li><code>guid</code>: the workload GUID.</li>
  <li><code>name</code>: the workload name.</li>
  <li><code>permalink</code>: the permanent URLs on the New Relic One UI.</li>
</ul>
<pre><code>{
  actor {
    account(id: YOUR_ACCOUNT_ID) {
      workload {
        collections {
          guid
          name
          permalink
        }
      }
    }
  }
}
</code></pre>
<p>The response includes this type of data for each workload:</p>
<pre><code>{
  "data": {
    "actor": {
      "account": {
        "workload": {
          "collections": [
            ...,
            {
              "guid": "MTY...NTY",
              "name": "Acme Telco - Fulfillment Chain",
              "permalink": "https://one.newrelic.com/redirect/entity/MTY...NTY"
            },
            ...
          ]
        }
      }
    }
  },
  "extensions": { ... }
}
</code></pre>
<h2>Get the list of entities in a workload [#get_entities_list]</h2>
<p>You can get the entities that belong to a workload with the following query, just by passing the workload GUID (<code>guid</code>) as an argument. In this example we also retrieve some workload metadata:</p>
<ul>
  <li><code>accountId</code>: the workload account.</li>
  <li><code>name</code>: the workload name.</li>
  <li><code>permalink</code>: the workload permanent URL on the New Relic One UI.</li>
  <li><code>alertSeverity</code>: the status of the workload. This value can have up to 10 minutes of delay; if you want to force the calculation of the workload status in query time, please use the <a href="#get_status">Get the status of a workload</a> example.</li>
  <li>The nested <code>collection</code>, <code>members</code> and <code>results</code> objects, which contain the actual list of entities:
    <ul>
      <li>The <code>name</code> argument in the <code>collection</code> object takes the value <code>WORKLOAD</code>.</li>
      <li><code>count</code>: Number of entities in the workload.</li>
    </ul>
  </li>
</ul>
<pre><code>{
  actor {
    entity(guid: "YOUR_WORKLOAD_GUID") {
      accountId
      name
      permalink
      ... on AlertableEntity {
        alertSeverity
      }
      ... on CollectionEntity {
        collection(name: "WORKLOAD") {
          members {
            count
            results {
              entities {
                accountId
                entityType
                name
                guid
                ... on AlertableEntityOutline {
                  alertSeverity
                }
              }
            }
          }
        }
      }
    }
  }
}
</code></pre>
<p>The query returns a list of entities that looks like this:</p>
<pre><code>{
  "data": {
    "actor": {
      "entity": {
        "accountId": 1606862,
        "name": "Acme Telco - Ecommerce",
        "permalink": "https://one.newrelic.com/redirect/entity/MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ",
        "alertSeverity": "CRITICAL",
        "collection": {
          "members": {
            "count": 201,
            "results": {
              "entities": [
                {
                  "accountId": 1606862,
                  "alertSeverity": "CRITICAL",
                  "entityType": "APM_APPLICATION_ENTITY",
                  "guid": "MTYwNjg2MnxBUE18QVBQTElDQVRJT058NDMxOTIwNTg",
                  "name": "Fulfillment Service"
                },
                {
                  "accountId": 1606862,
                  "alertSeverity": "NOT_ALERTING",
                  "entityType": "INFRASTRUCTURE_HOST_ENTITY",
                  "guid": "MTYwNjg2MnxJTkZSQXxOQXw3MDQzMzA2NzIyMjk2NDg4Mzc",
                  "name": "ip-172-31-16-222"
                },
                {
                  "accountId": 1606862,
                  "alertSeverity": "NOT_ALERTING",
                  "entityType": "INFRASTRUCTURE_AWS_LAMBDA_FUNCTION_ENTITY",
                  "guid": "MTYwNjg2MnxJTkZSQXxOQXw1MjMyNzM2ODgzNjAwNjYyMjE1",
                  "name": "TelcoDT-purchase-log-lambda"
                },
                ...   
              ]
            }
          }
        }
      }
    }
  }
}
</code></pre>
<h2>Get the status of a workload [#get_status]</h2>
<p>If you want to force the calculation of the status of a workload, you can use the following query, passing the account id (<code>id</code>) as the argument for the <code>account</code> field, and the workload GUID (<code>guid</code>) as the argument for the <code>collection</code> field.</p>
<pre><code>{
  actor {
    account(id: YOUR_ACCOUNT_ID) {
      workload {
        collection(guid: "YOUR_WORKLOAD_GUID") {
          guid
          status {
            value
          }
        }
      }
    }
  }
}
</code></pre>
<p>And this is what you'll get in the response:</p>
<pre><code>{
  "data": {
    "actor": {
      "account": {
        "workload": {
          "collection": {
            "guid": "MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ",
            "status": {
              "value": "OPERATIONAL"
            }
          }
        }
      }
    }
  }
}
</code></pre>
<p>Note that the <code>DISRUPTED</code> status value is a synonym for <code>CRITICAL</code> status.</p>
<h2>Create a workload [#create-workload]</h2>
<p>The following is an example NerdGraph call that creates a workload using the <code>workloadCreate</code> <a href="/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph#terminology">mutation</a> query:</p>
<pre><code>mutation {
  workloadCreate(
    accountId: NEW_WORKLOAD_ACCOUNT_ID, 
    workload: {
      name: "NAME_OF_WORKLOAD", 
      entityGuids: ["ENTITY_GUID_1", "ENTITY_GUID_2", ...], 
      entitySearchQueries: [
        {      
          query: "(type = 'SERVICE') and tags.label.environment = 'production'"
        },    
        ...
      ], 
      scopeAccounts: {
        accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...]
      }
    }
  ) 
  {
    guid
  }
}
</code></pre>
<p>Some details on parts of this query:</p>
<ul>
  <li>
    <p><code>account</code>: The <a href="/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-one-workloads-isolate-resolve-incidents-faster#workload-account">workload account ID</a>. Workloads can't be moved between accounts, so it's not possible to change this value later.</p>
  </li>
  <li>
    <p><code>name</code>: A string with a user-friendly name for the workload.</p>
  </li>
  <li>
    <p><code>scopeAccounts</code>: <a href="/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-one-workloads-isolate-resolve-incidents-faster#scope-accounts">Scope accounts</a> are the accounts where the entity data is fetched from. Scope accounts must belong to a group under the same master account or enterprise partnership as the workload account.</p>
  </li>
  <li>
    <p>To define the entities in the workload, you can use one or both of these options:</p>
    <ul>
      <li>
        <p><code>entitySearchQueries</code>: This allows you to <a href="/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-one-workloads-isolate-resolve-incidents-faster#dynamic">dynamically generate an array of entities</a>. A name for each query is not needed. Here's an example dynamic query:</p>
        <pre><code>(domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'production'
</code></pre>
      </li>
      <li>
        <p><code>entityGuids</code>: This is for choosing specific entity GUIDs for inclusion in the workload.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><code>guid</code>: This returns the workload <code>guid</code>. Because NerdGraph provides schema stitching, you can get other details about the workload, like the <code>permalink</code>.</p>
  </li>
</ul>
<h2>Modify a workload [#modify]</h2>
<p>To modify a workload, use the <code>workloadUpdate</code> mutation. You must know the workload's <code>guid</code>.</p>
<p>The workload account can't be changed.</p>
<p>For the fields you can modify, see <a href="#create-workload-fields">Create workloads</a>. These additional rules apply:</p>
<ul>
  <li><code>entitySearchQueries</code>: This field must contain all the queries as you expect them to be stored. If you want to add a new query, include it in the <code>query</code> field and don't provide any query <code>id</code>. If you want to modify an existing query, include it in the <code>query</code> field and provide its existing <code>id</code>. If you want to delete an existing query, just don't add any query with that <code>id</code> anymore.</li>
</ul>
<p>Here's an example of the <code>workloadUpdate</code> query:</p>
<pre><code>mutation {
  workloadUpdate(
    guid: "YOUR_WORKLOAD_GUID", 
    workload: {
      name: "A new name for the workload", 
      entityGuids: ["ENTITY_GUID_1", "ENTITY_GUID_2", ...], 
      entitySearchQueries: [  
        {      
          query: "(domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'staging'"
        },  
        { 
          id: AN_EXISTING_QUERY_ID,      
          query: "(type = 'SERVICE') and tags.label.environment = 'staging'"
        }, 
        ...
      ], 
      scopeAccounts: {
        accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...]
      }
    }
  ) 
  {
    guid
  }
}
</code></pre>
<h2>Set a static status for a workload [#static]</h2>
<p>You can set up a static status for a workload, which overrides any automatic status calculation.</p>
<p>To set a static status, you must know the workload's <code>guid</code> and use the following fields:</p>
<ul>
  <li><code>enabled</code>: Remember to set this field to <code>true</code> to propagate the status value.</li>
  <li><code>status</code>: The status value you want to set for this workload. Supported values are <code>OPERATIONAL</code>, <code>DEGRADED</code> or <code>DISRUPTED</code>.</li>
  <li><code>description</code>: A text field to provide additional details.</li>
</ul>
<pre><code>mutation {
  workloadUpdate(
    guid: "YOUR_WORKLOAD_GUID", 
    workload: {
      statusConfig: {
        static: {
          enabled: true,
          status: DEGRADED,
          description: "Game day. Expect some turbulence today between 8 and 9am PST."
        }
      }
    }
  ) 
  {
    guid
    updatedAt 
    status {
      value
    }
  }
}
</code></pre>
<h2>Modify the automatic status rules for a workload [#automatic]</h2>
<p>When you create a workload, you can use the <code>statusConfig</code> object to define which automatic rules you want to use to calculate the status of the workload. If you leave the <code>rules</code> array empty, no rules will be set up for your workload.</p>
<p>However, if you just don't use the <code>statusConfig</code> object when you create a workload, the following rules will be added by default:</p>
<pre><code>"statusConfig": {
  "automatic": {
    "enabled": true,
    "rules": [ 
      {
        "entitySearchQueries": [{"query": "(domain = 'APM' and type = 'APPLICATION')"}],
        "rollup": {
          "strategy": "WORST_STATUS_WINS",
          "thresholdType": null,
          "thresholdValue": null
        }
      },
      {
        "entitySearchQueries": [{"query": "(domain = 'MOBILE' and type = 'APPLICATION')"}],
        "rollup": {
          "strategy": "WORST_STATUS_WINS",
          "thresholdType": null,
          "thresholdValue": null
        }
      },
      {
        "entitySearchQueries": [{"query": "(domain = 'BROWSER' and type = 'APPLICATION')"}],
        "rollup": {
          "strategy": "WORST_STATUS_WINS",
          "thresholdType": null,
          "thresholdValue": null
        }
      },
      {
        "entitySearchQueries": [{"query": "(domain = 'SYNTH' and type = 'MONITOR')"}],
        "rollup": {
          "strategy": "WORST_STATUS_WINS",
          "thresholdType": null,
          "thresholdValue": null
        }
      }
    ],
    "remainingEntitiesRule": { 
      "rollup": { 
        "groupBy": "ENTITY_TYPE", 
        "strategy": "BEST_STATUS_WINS", 
        "thresholdType": null, 
        "thresholdValue": null 
      } 
    }
  }
}
</code></pre>
<p>This is how you read the configuration:</p>
<ul>
  <li><code>enabled</code>: The automatic status calculation is enabled when this field is set to <code>true</code>.</li>
  <li><code>rules</code>: An array of rules. In the default configuration, four rules are set for those entity types that are closer to the digital experience (that is, Synthetic monitors, Browser applications, Mobile applications, and Services). For each of these groups, the status of the unhealthiest rolls up.</li>
  <li><code>remainingEntitiesRule</code>: This is the rule that will apply to all entities that haven't been evaluated in any other rule. In the default configuration, the remaining entities are grouped by entity type, and we make the status of each group to match that of its healthiest entity.</li>
</ul>
<p>If you want to modify these rules, you must use the <code>workloadUpdate</code> mutation, and send the complete new <code>statusConfig</code> object that you want to use.</p>
<p>You can disable the automatic status calculation while keeping the configuration, by setting the <code>statucConfig.automatic.enabled</code> to <code>false</code>.</p>
<p>Alternatively, you can delete all automatic regular rules by sending an empty array. And you can delete the rule for the remaining entities by just not adding the <code>remainingEntitiesRule</code> object.</p>
<h2>Duplicate a workload [#duplicate]</h2>
<p>To duplicate a workload you first need to know its <code>guid</code>. In the <code>workloadDuplicate</code> mutation, you must pass as parameters:</p>
<ul>
  <li><code>accountId</code>: The account where you want to create the new workload.</li>
  <li><code>sourceGuid</code>: the <code>guid</code> of the workload you want to duplicate.</li>
  <li><code>workload.name</code>: Optional. You can specify a name for the new workload. If you don't specify one, the new workload will get the name of the original workload appended with <code>- Copy</code>.</li>
</ul>
<p>After duplicating a workload, you can <a href="#modify">modify it</a>.</p>
<pre><code>mutation {
  workloadDuplicate(
    accountId: NEW_WORKLOAD_ACCOUNT_ID, 
    sourceGuid: "ORIGINAL_WORKLOAD_GUID", 
    workload: {
      name: "New workload"
    }
  ) {
     guid
  }
}
</code></pre>
<h2>Delete a workload [#delete]</h2>
<p>To delete a workload, use the <code>workloadDelete</code> mutation and specify the workload GUID.</p>
<p>When you delete a workload, all history and metadata is also deleted.</p>
