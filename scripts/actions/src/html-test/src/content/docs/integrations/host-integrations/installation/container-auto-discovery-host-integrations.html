
<p>Our container auto-discovery feature allows you to configure an integration to automatically monitor services that run in multiple containers. In an integration's configuration file, you can set containers' matching criteria, and the agent executes the integration for each local container matching the criteria.</p>
<p>An integration will be executed as many times as it finds discovery elements. If discovery doesn't find any containers, the integration won't be executed.</p>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJ0aXAifV0=">
  <p>Currently, the <a href="/docs/infrastructure/install-configure-manage-infrastructure">infrastructure agent</a> can discover local Docker containers.</p>
</div>
<h2>Add placeholders to your configuration [#example]</h2>
<p>In your integration configuration, you must create <code>${discovery.&#x3C;property>}</code> placeholders. These will then be automatically replaced by specific container information.</p>
<p>These examples (for Docker-only environments and for Kubernetes) show how to configure an <a href="/docs/integrations/host-integrations/host-integrations-list/apache-monitoring-integration">NGINX integration</a> to monitor all local containers that have an image name containing <code>nginx</code>, and that are labeled as <code>env=production</code>. Each service will be available through different IPs and ports, so they must be variables.</p>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiZG9ja2VyLWV4YW1wbGUifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6IkRvY2tlciBleGFtcGxlIChub24tb3JjaGVzdHJhdGVkKSJ9XQ==">
    <div data-prop-text="title">Docker example (non-orchestrated)</div>
    <p>This config applies to non-orchestrated scenarios, where Docker is used without Kubernetes or other orchestration environments.</p>
    <pre><code>discovery:
  docker:
    match:
      image: /nginx/
      label.env: production
integrations:
  - name: nginx-server-metrics
    command: metrics
    env:
      STATUS_URL: http://${discovery.ip}:${discovery.port}/status
      STATUS_MODULE: discover
      REMOTE_MONITORING: true
    labels:
      env: ${discovery.label.env}
      role: ${discovery.label.role}

</code></pre>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoia3ViZXJuZXRlcy1leGFtcGxlIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJLdWJlcm5ldGVzIGV4YW1wbGUifV0=">
    <div data-prop-text="title">Kubernetes example</div>
    <p>If you use Kubernetes and our <a href="/docs/integrations/kubernetes-integration/get-started/introduction-kubernetes-integration">Kubernetes integration</a>, this is how the ConfigMap for the integration would look like. Notice that <code>nri-discovery-kubernetes</code> will automatically detect the configuration. However, if some customization is required, the tool accepts several optional arguments:</p>
    <ul>
      <li>
        <p><code>--namespaces</code>: Comma separated list of namespaces</p>
      </li>
      <li>
        <p><code>--tls</code>: Use secure (TLS) connection</p>
      </li>
      <li>
        <p><code>--port</code>: The port used to connect to the kubelet.</p>
      </li>
      <li>
        <p><code>--host</code>: The host used to connect to the kubelet.</p>
        <pre><code>---
apiVersion: v1
kind: ConfigMap
metadata:
  name: nri-integration-cfg
  namespace: default
data:
  nginx-config.yaml: |
    ---
    discovery:
      command:
        # Run discovery for Kubernetes. Use the following optional arguments:
        # --namespaces: Comma separated list of namespaces to discover pods on
        # --tls: Use secure (TLS) connection
        # --port: Port used to connect to the kubelet.
        # --host: Host used to connect to the kubelet.
        exec: /var/db/newrelic-infra/nri-discovery-kubernetes
        match:
          image: /nginx/
          label.env: production
    integrations:
      - name: nri-nginx
        env:
          # Use the discovered IP as the host address
          STATUS_URL: http://${discovery.ip}/server-status?auto
          METRICS: 1
</code></pre>
      </li>
    </ul>
  </div>
</div>
<h2>Add discovery properties [#define-discover]</h2>
<p>To configure discovery, set up a <code>discovery</code> entry in your integration configuration YAML using the following properties. A container will be matched when <strong>all</strong> the properties match the defined values.</p>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJ0aXAifV0=">
  <p>Properties values will be matched with an <strong>exact string</strong>, unless the value to match is set between <code>/.../</code>. The contents within the slashes will be matched as <a href="https://en.wikipedia.org/wiki/Regular_expression">regular expressions</a>.</p>
</div>
<div data-component="Table" data-prop="W10=">
  <div>
    <div>
      <div>
        <p>Discovery key name</p>
      </div>
      <div>
        <p>Description</p>
      </div>
    </div>
  </div>
  <div>
    <div>
      <div>
        <p><code>ttl</code></p>
        <p>Type: String</p>
      </div>
      <div>
        <p>Time-To-Live of the cached discovery results, used to minimize the number of discovery processes. Define as a number followed by a time unit (<code>s</code>, <code>m</code> or <code>h</code>).</p>
        <p>Examples: <code>30s</code>, <code>10m</code>, <code>1h</code>, <code>0</code></p>
        <p>Default: 1m</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>docker</code></p>
        <p>Type: YAML properties</p>
      </div>
      <div>
        <p>Docker containers matching definition. This consists of a <code>match</code> property containing a map where:</p>
        <ul>
          <li>
            <p>Each key is any of the following properties.</p>
          </li>
          <li>
            <p>The value is the expected value of the given property for the returned containers.</p>
          </li>
          <li>
            <p>A container matches if all the properties match (AND operation).</p>
            <p>Available YAML keys include:</p>
          </li>
          <li>
            <p><code>ip</code>: Container external IP address, if any</p>
          </li>
          <li>
            <p><code>private.ip</code>: Container private IP address</p>
          </li>
          <li>
            <p><code>port</code>: Container external port number</p>
          </li>
          <li>
            <p><code>private.port</code>: Container private port number</p>
          </li>
          <li>
            <p><code>image</code>: Image name</p>
          </li>
          <li>
            <p><code>name</code>: Container name</p>
          </li>
          <li>
            <p><code>label.&#x3C;label name></code>: Any container label, accessible by its name</p>
          </li>
        </ul>
      </div>
    </div>
  </div>
</div>
<h3>Discovery example [#example]</h3>
<p>The following example matches all Docker containers whose image starts with <code>httpd:</code> (provided as a regular expression) and are labeled as <code>scrapable=yes</code>. The results are cached with a Time-To-Live of 5 minutes.</p>
<pre><code>discovery:
  ttl: 5m
  docker:
    match:
      image: /^httpd:/
      label.scrapable: yes
</code></pre>
<h2>Available container information [#container-information]</h2>
<p>Our discovery feature currently emits the following variables, which can be used to configure your integrations. The infrastructure agent replaces them with the corresponding values of the discovered containers.</p>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJpbXBvcnRhbnQifV0=">
  <p>Be sure to add the <code>discovery.</code> prefix.</p>
</div>
<div data-component="Table" data-prop="W10=">
  <div>
    <div>
      <div>
        <p>Variable</p>
      </div>
      <div>
        <p>Description</p>
      </div>
    </div>
  </div>
  <div>
    <div>
      <div>
        <p><code>${discovery.ip}</code></p>
      </div>
      <div>
        <p>Container public IP address, if any</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>${discovery.private.ip}</code></p>
      </div>
      <div>
        <p>Container private IP address</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>${discovery.port}</code></p>
      </div>
      <div>
        <p>Container public port number</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>${discovery.private.port}</code></p>
      </div>
      <div>
        <p>Container private port number</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>${discovery.image}</code></p>
      </div>
      <div>
        <p>Image name</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>${discovery.name}</code></p>
      </div>
      <div>
        <p>Container name</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>${discovery.label.&#x3C;label name>}</code></p>
      </div>
      <div>
        <p>Any container label, accessible by its name</p>
      </div>
    </div>
  </div>
</div>
<h3>Mapping multiple ports</h3>
<p>When a container exposes many private or public ports, they can be accessed via <code>discovery.private.ports.</code> or <code>discovery.ports.</code> followed by an index starting in 0. The ports are indexed from the lower to higher private port value.</p>
<p>For example, a container that exposes the 80 and 443 private ports via the public ports 2345 and 1111, respectively, would provide the following variables with their respective values:</p>
<div data-component="Table" data-prop="W10=">
  <div>
    <div>
      <div>
        <p>Variable</p>
      </div>
      <div>
        <p>Value</p>
      </div>
    </div>
  </div>
  <div>
    <div>
      <div>
        <p><code>${discovery.private.ports.0}</code></p>
      </div>
      <div>
        <p><code>80</code> (the lowest private port)</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>${discovery.private.ports.1}</code></p>
      </div>
      <div>
        <p><code>443</code> (the highest private port)</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>${discovery.ports.0}</code></p>
      </div>
      <div>
        <p><code>2345</code> (the public port mapping to private port 0)</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>${discovery.ports.1}</code></p>
      </div>
      <div>
        <p><code>1111</code> (the public port mapping to private port 1)</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>${discovery.private.port}</code></p>
      </div>
      <div>
        <p><code>80</code> (same as <code>${discovery.private.ports.0}</code>)</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>${discovery.port}</code></p>
      </div>
      <div>
        <p><code>2345</code> (same as <code>${discovery.ports.0}</code>)</p>
      </div>
    </div>
  </div>
</div>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJpbXBvcnRhbnQifV0=">
  <p>Notice that the <code>port</code> word is singular in the non-indexed variables and plural in the indexed variables.</p>
</div>
<h3>Mapping ports by protocol name</h3>
<p>In addition to the indexing from the previous section, ports can be also referred by its protocol name (e.g. <code>tcp</code>, <code>udp</code>, ...). For example, <code>${discovery.ports.tcp}</code> , <code>${discovery.ports.udp}</code>, etc...</p>
<p>If multiple ports match to the same protocol, they can also be indexed by the rules in the previous section: <code>${discovery.ports.tcp.0}</code>, <code>${discovery.ports.tcp.1}</code>, and so on.</p>
