
<p>New Relic Query Language (NRQL) supports basic math functions within a <code>SELECT</code> clause. You can apply addition, subtraction, multiplication, and division on both individual attributes as well as the results of aggregator functions.</p>
<h2>Use math operators with SELECT [#math]</h2>
<p>To use basic math functions in NRQL, include operators within the <code>SELECT</code> clause:</p>
<ul>
  <li>Addition: <code>+</code></li>
  <li>Subtraction: <code>-</code></li>
  <li>Multiplication: <code>*</code></li>
  <li>Division: <code>/</code></li>
</ul>
<p>Here are some examples:</p>
<pre><code>SELECT duration-databaseDuration FROM Transaction
</code></pre>
<pre><code>SELECT count(*)/uniqueCount(session) FROM PageView
</code></pre>
<pre><code>SELECT average(duration-databaseDuration) FROM Transaction
</code></pre>
<h2>Results with STRING or FLOAT [#strings]</h2>
<p>Here is how NRQL handles strings present in math calculations:</p>
<p>Examples:</p>
<ul>
  <li><code>sum(1+STRING)</code> = 0</li>
  <li><code>sum(1+MIXED)</code> = skips records where MIXED is a string</li>
  <li><code>average(1+STRING)</code> = 0</li>
  <li><code>average(1+MIXED)</code> = skips records where MIXED is a string</li>
</ul>
<p>NULL and zero both appear as 0 in the dashboard.</p>
<p>To override NULL values with another numeric value, use the syntax:</p>
<pre><code>SELECT average(purchasePrice OR 0)
</code></pre>
<p>This will replace NULL values with 0 or any number specified.</p>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJ0aXAifV0=">
  <p>This can also be used to test whether something returns NULL or zero. <code>(zero) OR 1</code> returns 0. <code>(NULL) OR 1</code> returns 1.</p>
</div>
<h2>Advanced math functions</h2>
<p>NRQL includes advanced mathematical functions that can be used for complex calculations and for processing data to display more effectively in the UI.</p>
<h3><code>abs</code></h3>
<p><code>abs(n)</code> returns the absolute value of <em>n</em>. For non-negative <em>n</em> it returns <em>n</em>, and for negative <em>n</em> it returns the positive number -<em>n</em>. For example <code>abs(2) = 2</code>, and <code>abs(-4) = 4</code>.</p>
<h3><code>round</code>, <code>floor</code>, <code>ceil</code>(ing)</h3>
<p>These three functions force decimal numbers to one of the neighboring integers.</p>
<ul>
  <li><code>floor(n)</code> returns the closest integer less than or equal to <em>n</em>.</li>
  <li><code>ceil(n)</code> returns the closest integer greater than or equal to <em>n</em>.</li>
  <li><code>round(n)</code> returns the closest integer to <em>n</em> in either direction.</li>
</ul>
<p>
  <img src="./images/floor-round-ceil.png" alt="floor-round-ceil.png" title="floor-round-ceil.png">
</p>
<p>Sample graph showing raw data, with floor, round, and ceiling functions applied.</p>
<h3><code>clamp_max</code>, <code>clamp_min</code></h3>
<p>The clamping functions impose an upper or lower bound on values.</p>
<p>For example, <code>clamp_max(duration, 10)</code> returns the duration, unless it exceeds 10, in which case 10 is returned.</p>
<p>Similarly <code>clamp_min(duration, 1)</code> will not return any value lower than 1. The following chart shows the result of clamping both min and max to keep the value in the range 70-90.</p>
<p>
  <img src="./images/clamp.png" alt="clamp.png" title="clamp.png">
</p>
<p>Sample graph showing raw data with clamp function applied.</p>
<h3><code>pow</code></h3>
<p><code>pow(n, m)</code> computes <em>n</em> raised to the power <em>m</em>. (I.e. <code>n * n * ... * n,</code> with <em>m</em> copies of <em>n</em>)</p>
<h3><code>sqrt</code></h3>
<p><code>sqrt(n)</code> returns the square root of <em>n</em>, that is, the number such that <code>sqrt(n) * sqrt(n) = n.</code></p>
<h3><code>exp</code></h3>
<p>Computes the natural exponential function of the argument: <code>exp(n) = pow(e, n)</code>.</p>
<h3><code>ln, log2, log10, log</code></h3>
<p>These functions compute the logarithm of the argument for various bases.</p>
<ul>
  <li><code>ln(n)</code> computes the natural logarithm: the logarithm base e.</li>
  <li><code>log2(n)</code> computes the logarithm base 2.</li>
  <li><code>log10(n)</code> computes the logarithm base 10.</li>
  <li><code>log(n, b)</code> allows logarithms to be computed with an arbitrary base b.</li>
  <li>All logarithms satisfy the identity: <code>log(pow(b, n), b) = n.</code></li>
</ul>
<p>Note that <code>log(0</code>) is undefined, for all bases. Be aware that if you take the logarithm of something that might be zero, you may end up getting "No Value" back from your query.</p>
<h2>For more help [#more_help]</h2>
