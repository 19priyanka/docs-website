
<p>Loss of signal occurs when New Relic stops receiving data for a while; technically, we detect loss of signal after a significant amount of time has elapsed since data was last received in a time series. Loss of signal can be used to trigger or resolve a violation, which you can use to set up alerts.</p>
<p>Gap filling can help you solve issues caused by lost data points. When gaps are detected between valid data points, we automatically fill those gaps with replacement values, such as the last known values or a static value. Gap filling can prevent alerts from triggering or resolving when they shouldn't.</p>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJ0aXAifV0=">
  <p>To learn more about signal loss, gap filling, and how to request access to these features, see <a href="https://discuss.newrelic.com/t/announcing-new-relic-one-streaming-alerts-for-nrql-conditions/115361">this announcement</a>.</p>
</div>
<p>You can customize loss of signal detection and gap filling using <a href="/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph">NerdGraph</a>. For example, you can configure how long to wait before considering the signal lost, or what value should be used for filling gaps in the time series. Here are some queries and examples you can use in our <a href="https://api.newrelic.com/graphiql">NerdGraph API explorer</a>.</p>
<p>In this guide we cover the following:</p>
<ul>
  <li><a href="#loss-of-signal">Customize loss of signal detection</a></li>
  <li><a href="#customize">Customize gap filling</a></li>
</ul>
<h2>Customize your loss of signal detection [#loss-of-signal]</h2>
<p>Loss of signal detection opens or closes violations if no data is received after a certain amount of time. For example, if you set the duration of the expiration period to 60 seconds and an integration doesn't seem to send data for more than a minute, a loss of signal violation would be triggered.</p>
<p>You can configure the duration of the signal loss and whether to open a violation or close it by using these three fields in NerdGraph:</p>
<ul>
  <li><code>expiration.expirationDuration</code>: How long to wait, in seconds, after the last data point is received by our platform before considering the signal as lost. This is based on the time when data arrives at our platform and not on data timestamps. The default is to leave this null, and therefore this wouldn't enable Loss of Signal Detection.</li>
  <li><code>expiration.openViolationOnExpiration</code>: If <code>true</code>, a new violation is opened when a signal is lost. Default is <code>false</code>. To use this field, a duration must be specified.</li>
  <li><code>expiration.closeViolationsOnExpiration</code>: If <code>true</code>, open violations related to the signal are closed on expiration. Default is <code>false</code>. To use this field, a duration must be specified.</li>
</ul>
<h3>View loss of signal settings for an existing condition</h3>
<p>Existing NRQL conditions may have their loss of signal settings already configured. To view the existing condition settings, select the fields under <code>nrqlCondition</code> > <code>expiration</code>:</p>
<pre><code>{
  actor {
    account(id: YOUR_ACCOUNT_ID) {
      alerts {
        nrqlCondition(id: NRQL_CONDITION_ID) {
          ... on AlertsNrqlStaticCondition {
            id
            name
            nrql {
              query
            }
            expiration {
              closeViolationsOnExpiration
              expirationDuration
              openViolationOnExpiration
            }
          }
        }
      }
    }
  }
}
</code></pre>
<p>You should see a result like this:</p>
<pre><code>{
  "data": {
    "actor": {
      "account": {
        "alerts": {
          "nrqlCondition": {
            "expiration": {
              "closeViolationsOnExpiration": false,
              "expirationDuration": 300,
              "openViolationOnExpiration": true
            },
            "id": "YOUR_ACCOUNT_ID",
            "name": "Any less than - Extrapolation",
            "nrql": {
              "query": "SELECT average(value) FROM AlertsSmokeTestSignals WHERE wave_type IN ('min-max', 'single-gap') FACET wave_type"
            }
          }
        }
      }
    }
  }, ...
</code></pre>
<h3>Create a new condition with loss of signal settings</h3>
<p>Let's say that you want to create a new <a href="/docs/alerts/alerts-nerdgraph/nerdgraph-examples/nerdgraph-api-nrql-condition-alerts#static-condition">create a NRQL static condition</a> that triggers a loss of signal violation after no data is received for two minutes. You would set <code>expirationDuration</code> to 120 seconds and set <code>openViolationOnExpiration</code> to <code>true</code>, like in the example below.</p>
<pre><code>mutation {
  alertsNrqlConditionStaticCreate(
    accountId: YOUR_ACCOUNT_ID
    policyId: YOUR_POLICY_ID
    condition: {
      name: "Low Host Count - Catastrophic"
      enabled: true
      nrql: {
        query: "SELECT uniqueCount(host) from Transaction where appName='my-app-name'"
      }
      signal {
        aggregationWindow: 60
        evaluationOffset: 3
      }
      terms: [{
        threshold: 2
        thresholdOccurrences: AT_LEAST_ONCE
        thresholdDuration: 600
        operator: BELOW
        priority: CRITICAL
      }]
      valueFunction: SINGLE_VALUE
      violationTimeLimitSeconds: 86400
      expiration: {
        expirationDuration: 120
        openViolationOnExpiration: true
      }
    }
  ) {
    id
    name
  }
}
</code></pre>
<h3>Update the loss of signal settings of a condition</h3>
<p>What if you want to update loss of signal parameters for an alert condition? The following mutation allows you to <a href="/docs/alerts/alerts-nerdgraph/nerdgraph-examples/nerdgraph-api-nrql-condition-alerts#static-condition">update a NRQL static condition</a> with new <code>expiration</code> values.</p>
<pre><code>mutation {
  alertsNrqlConditionStaticUpdate(
    accountId: YOUR_ACCOUNT_ID
    id: YOUR_STATIC_CONDITION_ID
    condition: {
      expiration: {
        closeViolationsOnExpiration: BOOLEAN
        expirationDuration: DURATION_IN_SECONDS
        openViolationOnExpiration: BOOLEAN
      }
    }
  ) {
    id
    expiration {
      closeViolationsOnExpiration
      expirationDuration
      openViolationOnExpiration
    }
  }
}
</code></pre>
<h2>Customize gap filling [#customize]</h2>
<p>Gap filling replaces gap values in a time series with either the last value found or a static, arbitrary value of your choice. We fill gaps only after another data point has been received after the gaps in signal (after data reception has been restored).</p>
<p>You can configure both the type of filling and the value, if the type is set to static:</p>
<ul>
  <li><code>signal.fillOption</code>: Type of replacement value for lost data points. Values can be:
    <ul>
      <li><code>NONE</code>: Gap filling is disabled.</li>
      <li><code>LAST_VALUE</code>: The last value seen in the time series.</li>
      <li><code>STATIC</code>: An arbitrary value, defined in <code>fillValue</code>.</li>
    </ul>
  </li>
  <li><code>signal.fillValue</code>: Value to use for replacing lost data points when <code>fillOption</code> is set to <code>STATIC</code>.</li>
</ul>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJpbXBvcnRhbnQifV0=">
  <p>Gap filling is also affected by <code>expiration.expirationDuration</code>. When a gap is longer than the expiration duration, the signal is considered expired and the gap will no longer be filled.</p>
</div>
<p>For example, here's how to create a static NRQL condition with gap filling configured:</p>
<pre><code>mutation {
  alertsNrqlConditionStaticCreate(
    accountId: YOUR_ACCOUNT_ID
    policyId: YOUR_POLICY_ID
    condition: {
      enabled: true
      name: "Example Gap Filling Condition"
      nrql: { query: "select count(*) from Transaction" }
      terms: {
        operator: ABOVE
        priority: CRITICAL
        threshold: 1000
        thresholdDuration: 300
        thresholdOccurrences: ALL
      }
      valueFunction: SINGLE_VALUE
      violationTimeLimitSeconds: 28800
      signal: {
        aggregationWindow: 60,
        evaluationOffset: 3, 
        fillOption: STATIC,
        fillValue: 1
      }
    }
  ) {
    id
  }
}
</code></pre>
