
<h2>Problem [#problems]</h2>
<p>Your New Relic's synthetic <a href="/docs/synthetics/new-relic-synthetics/using-monitors/add-edit-monitors#monitor-type-ping">Simple, Scripted, or Scripted API (non-ping) monitor</a> reported an error, but the application appears to have loaded correctly. For ping and simple monitor errors, see <a href="/docs/synthetics/new-relic-synthetics/troubleshooting/non-scripted-monitor-errors">non-scripted monitor errors</a>.</p>
<h2>Solutions</h2>
<p>Below are some of the most common non-ping monitor error messages.</p>
<h3>Simple or scripted browser errors [#simple-browser-errors]</h3>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiZWxlbWVudC1ub3QtY2xpY2thYmxlIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJFbGVtZW50IEEgaXMgbm90IGNsaWNrYWJsZSBhdCBwb2ludCAoWCwgWSkuIE90aGVyIGVsZW1lbnQgd291bGQgcmVjZWl2ZSB0aGUgY2xpY2s6IEVsZW1lbnQgQiJ9XQ==">
    <div data-prop-text="title">Element A is not clickable at point (X, Y). Other element would receive the click: Element B</div>
    <h3>Problem</h3>
    <p>The synthetic script is attempting to <code>.click()</code> an element (Element A) at point (X,Y), but another element (Element B) is obscuring the target element.</p>
    <h3>Solution</h3>
    <p>Set a custom wait time, allowing time for a specific condition to be met. In this case, until the loading animation is no longer visible:</p>
    <pre><code>.then(function() {
    return $browser.wait($driver.until.elementIsNotVisible($browser.findElement($driver.By.id('LOADING'))), 10000);
})

</code></pre>Alternatively, you can set a custom [sleep delay](/docs/synthetics/new-relic-synthetics/scripting-monitors/synthetics-scripted-browser-reference-monitor-versions-04x-or-lower#browser-sleep) using `$browser.sleep(sleeptime_ms)`, stalling script execution for a specified amount of time. As this is a fixed amount of wait-time, which does not account for increased network latency or degraded site performance, we recommend using the `.wait()` function instead.
    &#x3C;Callout variant="tip">
    This will not correct `.click()` issues caused by sticky headers or footers. In these instances, you may need to scroll manually to bring the target into view.
    &#x3C;/Callout>
    ### Cause
    This happens if the target element, at the time of the `.click()` function, is obscured by:
    * A loading overlay, modal, or pop-up
    * An animation that reveals the target element
    * A sticky header or footer
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiZWxlbWVudC1ub3QtdmlzYWJsZSJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ0aXRsZSIsInZhbHVlIjoiRXJyb3I6IGVsZW1lbnQgbm90IHZpc2libGUifV0=">
    <div data-prop-text="title">Error: element not visible</div>
    <h3>Problem</h3>
    <p>The targeted element is not visible to the Selenium WebDriver.</p>
    <h3>Solution</h3>
    <p>Verify that the targeted element does not have the CSS properties of <code>display: none</code> or <code>visibility: hidden</code> applied.</p>
    <h3>Cause</h3>
    <p>Any element that has a CSS property of <code>display: none</code> or <code>visibility: hidden</code> will not be found by the Selenium WebDriver, as the script will only look for elements that are actually visible to a user.</p>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoibm8tc3VjaC1lbGVtZW50In0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJFcnJvcjogbm8gc3VjaCBlbGVtZW50OiBVbmFibGUgdG8gbG9jYXRlIGVsZW1lbnQ6IDxMT0NBVE9SPiJ9XQ==">
    <div data-prop-text="title">Error: no such element: Unable to locate element: &#x3C;LOCATOR></div>
    <h3>Problem</h3>
    <p>The Selenium WebDriver was unable to find this element in the visible DOM.</p>
    <h3>Solution</h3>
    <p>To resolve this problem:</p>
    <ul>
      <li>
        <p>Confirm that the element locator being used for the target element is accurate. Avoid using <code>By.XPath</code> where possible as it is rigidly tied to the page’s DOM structure, and can easily become out-of-date when there are updates on the page.</p>
      </li>
      <li>
        <p>If element is in an iframe, use <code>$browser.switchTo().frame(&#x3C;index or element reference></code>.</p>
        <div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJ0aXAifV0=">
          <p>See the Selenium documentation for more information on <a href="https://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/lib/webdriver_exports_WebDriver.html#switchTo"><code>switchTo()</code></a> and <a href="https://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/lib/webdriver_exports_TargetLocator.html"><code>TargetLocator()</code></a> functions.</p>
        </div>
        <h3>Cause</h3>
        <p>Common reasons for this error include:</p>
      </li>
      <li>
        <p>The targeted element is unable to be <a href="/docs/synthetics/new-relic-synthetics/scripting-monitors/synthetics-scripted-browser-reference-monitor-versions-050#locators">located</a> by functions such as:</p>
        <ul>
          <li><code>$browser.findElement(locator: $driver.Locator)</code> or</li>
          <li>$browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number</li>
        </ul>
        <p>This may be due to a timing issue. For example, the WebDriver is attempting to locate the element before the page has been loaded.</p>
      </li>
      <li>
        <p>Element is in an iframe, which is a separate document context.</p>
      </li>
    </ul>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiam9iLXRpbWVkLW91dCJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ0aXRsZSIsInZhbHVlIjoiSm9iVGltZW91dEVycm9yOiBKb2IgdGltZWQtb3V0IGFmdGVyIDE4MHMifV0=">
    <div data-prop-text="title">JobTimeoutError: Job timed-out after 180s</div>
    <h3>Problem</h3>
    <p>The scripted monitor run reached the 180 second non-configurable timeout threshold, and the run was terminated.</p>
    <h3>Solution</h3>
    <p>If this is a frequent error, consider breaking up the scripted tasks into a separate scripted monitors.</p>
    <p>If it appears that a specific task is causing the job to wait an unacceptable amount of time, consider changing the method by which you’re accomplishing that task. For example, changing <code>$browser.findElement(locator: $driver.Locator)</code> to <code>$browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number)</code> would assign the task its own configurable timeout.</p>
    <p>If you have multiple steps where the <code>$browser.waitForAndFindElement(locator, timeout)</code> function is called, ensure that the the sum of the provided timeouts to these steps does not exceed 180 seconds. If you’re finding it difficult to accomplish this, then that is a sign that the monitor should probably be broken up into separate monitor scripts.</p>
    <h3>Cause</h3>
    <p>All synthetic scripted monitors have a non-configurable maximum global 180s timeout for running a script.</p>
    <p>If a script has not completed after 180 seconds, the job is terminated. If this happens consistently it could be a sign of a script that is taking too long to complete, or that the job is waiting an extended period of time while attempting to perform a scripted task.</p>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoibmV0d29yay1lcnJvci1icm93c2VyIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJOZXR3b3JrRXJyb3I6IE1vbml0b3IgcHJvZHVjZWQgbm8gdHJhZmZpYyJ9XQ==">
    <div data-prop-text="title">NetworkError: Monitor produced no traffic</div>
    <h3>Problem</h3>
    <p>The API test or scripted browser monitor appears to be running but is returning this error.</p>
    <h3>Solution</h3>
    <p>Ensure that <code>$http.get()</code> or <code>$browser.get()</code> are being called appropriately and are generating traffic.</p>
    <p>For Scripted API monitors, if you are using a <a href="https://github.com/request/request#requestoptions-callback">request option</a> to spin up an un-instrumented HTTP agent under the hood, specify one of our instrumented HTTP agents using either of the agent request options below:</p>
    <ul>
      <li>
        <p><code>$globalAgents.http</code></p>
      </li>
      <li>
        <p><code>$globalAgents.https</code></p>
        <p>Example:</p>
        <pre><code>var options = {
    uri: 'https://www.newrelic.com',
    agent: $globalAgents.https,
    agentOptions: {
        'rejectUnauthorized': false
    },
    strictSSL: false
};

function callback(err, res, body) { ...
};

$http.get(options, callback);
</code></pre>
        <h3>Cause</h3>
        <p>This occurs in scripted monitor runs when the HTTP client ($http in Scripted API monitors) or Chrome browser ($browser in Scripted Browser monitors) is not used to generate HTTP traffic.</p>
        <p>In some cases, certain <a href="https://github.com/request/request#requestoptions-callback">request options</a> in API monitors may force a new HTTP agent, one that is not instrumented by synthetic monitoring, to be used to collect HTTP traffic.</p>
      </li>
    </ul>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoibmV0d29yay1ub3QtZGVmaW5lZCJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ0aXRsZSIsInZhbHVlIjoiUmVmZXJlbmNlRXJyb3I6ICRuZXR3b3JrIGlzIG5vdCBkZWZpbmVkIn1d">
    <div data-prop-text="title">ReferenceError: $network is not defined</div>
    <h3>Problem</h3>
    <p>The <code>$network</code> object used for setting <a href="/docs/synthetics/new-relic-synthetics/scripting-monitors/set-proxy-settings-scripted-monitors">monitor</a> proxies is not available for that monitor’s <a href="/docs/synthetics/new-relic-synthetics/scripting-monitors/scripted-monitor-runtime-environment#runtime-table">runtime</a>.</p>
    <h3>Solution</h3>
    <p>If your monitor was created before the 0.4.0 runtime release, create a new monitor to take advantage of the latest runtime. Your monitor’s current runtime version is shown at the top of the monitor's settings.</p>
    <p>For more information, see <a href="/docs/synthetics/new-relic-synthetics/scripting-monitors/scripted-monitor-version-runtime-environments">Scripted monitor version runtime environments</a>.</p>
    <h3>Cause</h3>
    <p>This error occurs when attempting to use <code>$network</code> on a monitor with a runtime at or below 0.2.2. Proxying monitor traffic was introduced in monitor runtime version 0.4.0, causing this method to be evaluated as undefined on earlier monitor runtimes.</p>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoic2NyaXB0LXRpbWVvdXQtZXJyb3ItYnJvd3NlciJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ0aXRsZSIsInZhbHVlIjoiU2NyaXB0VGltZW91dEVycm9yIn1d">
    <div data-prop-text="title">ScriptTimeoutError</div>
    <h3>Problem</h3>
    <p>This error indicates that the job has reached the Docker container timeout threshold, and the script was terminated.</p>
    <h3>Solution</h3>
    <p>If this is a frequent error, consider breaking up the scripted tasks into a separate scripted monitors.</p>
    <p>If it appears that a specific task is causing the job to wait an unacceptable amount of time, consider changing the method by which you’re accomplishing that task. For example, changing <code>$browser.findElement(locator: $driver.Locator)</code> to <code>$browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number)</code> would assigned the task its own configurable timeout.</p>
    <p>If you have multiple steps where the <code>$browser.waitForAndFindElement(locator, timeout)</code> function is called, ensure that the the sum of the provided timeouts to these steps does not exceed 180 seconds. If you’re finding it difficult to accomplish this, then that is a sign that the monitor should probably be broken up into separate monitor scripts.</p>
    <h3>Cause</h3>
    <p>All synthetic scripted monitors have a non-configurable maximum global 180s timeout for running a script.</p>
    <p>If a script has not completed after 180 seconds, the job is terminated. If this happens consistently it could be a sign of a script that is taking too long to complete, or that the job is waiting an extended period of time while attempting to perform a scripted task.</p>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoic3RhbGUtZWxlbWVudC1yZWZlcmVuY2UifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6IlN0YWxlRWxlbWVudFJlZmVyZW5jZUVycm9yOiBlbGVtZW50IGlzIG5vdCBhdHRhY2hlZCB0byB0aGUgcGFnZSBkb2N1bWVudCJ9XQ==">
    <div data-prop-text="title">StaleElementReferenceError: element is not attached to the page document</div>
    <h3>Problem</h3>
    <p>The target page has loaded, but there was a change to an element between the execution of an element locator and an action being executed on the element.</p>
    <h3>Solution</h3>
    <p>Set your scripted browser to wait until the page is settled before performing a <code>findElement()</code> action. This can be accomplished by setting a custom <a href="/docs/synthetics/new-relic-synthetics/scripting-monitors/synthetics-scripted-browser-reference-monitor-versions-04x-or-lower#browser-wait">wait time</a>, using the <code>$browser.wait(fn, timeout)</code> function prior to the findElement call, to wait for a condition that indicates a settled page state. This will make it less likely for DOM manipulation to cause a reference to go stale.</p>
    <p>Alternatively, you can set a custom <a href="/docs/synthetics/new-relic-synthetics/scripting-monitors/synthetics-scripted-browser-reference-monitor-versions-04x-or-lower#browser-sleep">sleep delay</a> using <code>$browser.sleep(sleeptime_ms)</code>, stalling script execution for a specified amount of time. As this is a fixed amount of wait-time, which does not account for increased network latency or degraded site performance, we recommend using the <code>.wait()</code> function instead.</p>
    <h3>Cause</h3>
    <p>This error typically happens when the script attempts to <code>.click()</code> an element after using either the <code>findElement()</code> or <code>waitForAndFindElement()</code> function.</p>
    <p>If the DOM has changed between when the element locator was generated and the action was executed against the element, this error will occur because the actual element has changed.</p>
    <p>For example: the <code>findElement()</code> function is used to generate an element reference while the page’s script is actively manipulating the DOM. The DOM is then changed, causing the previously generated reference to become stale. The now out-of-date reference is used in an attempt to perform a <code>.click()</code> action, resulting in this monitor failure.</p>
    <div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJ0aXAifV0=">
      <p>For more information, see the Selenium documentation on <a href="https://www.seleniumhq.org/exceptions/stale_element_reference.jsp">Stale Element Reference Exceptions</a>.</p>
    </div>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoidGFzay10aW1lZC1vdXQifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6IlRhc2tUaW1lZE91dDogdGFzayB0aW1lZC1vdXQgd2FpdGluZyBmb3IgZWxlbWVudCB0byBiZSBsb2NhdGVkIHVzaW5nOiA8TE9DQVRPUj4ifV0=">
    <div data-prop-text="title">TaskTimedOut: task timed-out waiting for element to be located using: &#x3C;LOCATOR></div>
    <h3>Problem</h3>
    <p>The <code>waitForAndFindElement(&#x3C;locator>, &#x3C;timeout>)</code> function failed to locate an element within the provided timeout.</p>
    <h3>Solution</h3>
    <p>Confirm that the element locator being used for the target element is accurate. Avoid using <code>By.XPath()</code> where possible, as it is rigidly tied to the page’s DOM structure and can easily become out-of-date when there are updates on the page.</p>
    <h3>Cause</h3>
    <p>The target element did not exist on the page when the <code>waitForAndFindElement(&#x3C;locator>, &#x3C;timeout>)</code> function was called. This may be caused by the target page not being in the expected state.</p>
    <p>Common reasons for this error include:</p>
    <ul>
      <li>There is a legitimate issue with the target site.</li>
      <li>The element locator being used is incorrect.</li>
      <li>The target site has changed, requiring the revision of the Synthetics script.</li>
      <li>The previous action in the script did not successfully complete, causing the page to be in an unexpected state when the subsequent waitForAndFindElement() call was initiated.</li>
    </ul>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoidGltZW91dGVycm9yLXBhZ2UtbG9hZCJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ0aXRsZSIsInZhbHVlIjoiVGltZW91dEVycm9yOiBwYWdlIGxvYWQgdGltZWQtb3V0In1d">
    <div data-prop-text="title">TimeoutError: page load timed-out</div>
    <h3>Problem</h3>
    <p>The target page loaded successfully, but returned the error:</p>
    <p>TimeoutError: Page load timed-out (unable to finish all network requests on time)</p>
    <h3>Solution</h3>
    <p>If the failures began suddenly, investigate any requests that could be blocking or delaying the page load event. If you are unsure which request is causing the error, use the <a href="/docs/synthetics/new-relic-synthetics/using-monitors/view-monitor-results#understanding">timeline view</a> to identify any long running HTTP requests.</p>
    <p>If the page is frequently unable to fully load within the current timeout, set a custom <a href="/docs/synthetics/new-relic-synthetics/scripting-monitors/synthetics-scripted-browser-reference-monitor-versions-04x-or-lower#options">page load timeout</a> using the <code>$browser.manage().timeouts().pageLoadTimeout(ms: number)</code> function.</p>
    <h3>Cause</h3>
    <p>The target page loaded successfully, but the page load event was not fired within the page load timeout set in the <code>.pageLoadTimeout()</code> function.</p>
    <p>There are a number of reasons you could see this error message, including:</p>
    <ul>
      <li>A blocked resource request on the page held up the page load.</li>
      <li>A resource request processed slower than normal due to an underlying network issue.</li>
      <li>A dependent resource on the page blocked the iframe load event.</li>
    </ul>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiaXMtZWxlbWVudC1wcmVzZW50In0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJUeXBlRXJyb3I6ICRicm93c2VyLmlzRWxlbWVudFByZXNlbnQgaXMgbm90IGEgZnVuY3Rpb24ifV0=">
    <div data-prop-text="title">TypeError: $browser.isElementPresent is not a function</div>
    <h3>Problem</h3>
    <p>The function <code>isElementPresent()</code>, used by Synthetics monitors with a runtime >= 0.5.0, has been deprecated in Selenium 3.</p>
    <h3>Solution</h3>
    <p>To continue to use this function after depreciation you will need to create a custom version of this function, such as:</p>
    <pre><code>return $browser.findElements(ele).then(function(found) {
    return found.length > 0;
});
}

</code></pre>### Cause
    This can occur when attempting to use a Synthetics Scripted Browser monitor script from an older monitor ( &#x26;lt;= 0.4.1 runtime) with a newer Synthetics monitor ( >= 0.5.0) runtime.
    <pre><code>
$browser
    .get("https://www.newrelic.com")
    .then(function() {
        return isElementPresent($driver.By.id("nav_signup"));
    })
    .then(function(found) {
        return console.log(found);
    });

</code></pre>Example usage, which would return true:
  </div>
</div>
<h3>Scripted API monitor errors [#scripted-api-browser-errors]</h3>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiam9iLXRpbWVkLW91dC1hcGkifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6IkpvYlRpbWVvdXRFcnJvcjogSm9iIHRpbWVkLW91dCBhZnRlciAxODBzIn1d">
    <div data-prop-text="title">JobTimeoutError: Job timed-out after 180s</div>
    <h3>Problem</h3>
    <p>The scripted monitor run reached the 180 second non-configurable timeout threshold, and the run was terminated.</p>
    <h3>Solution</h3>
    <p>If this is a frequent error, consider breaking up the scripted tasks into a separate scripted monitors.</p>
    <p>If it appears that a specific task is causing the job to wait an unacceptable amount of time, consider changing the method by which you’re accomplishing that task. For example, changing <code>$browser.findElement(locator: $driver.Locator)</code> to <code>$browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number)</code> would assign the task its own configurable timeout.</p>
    <p>If you have multiple steps where the <code>$browser.waitForAndFindElement(locator, timeout)</code> function is called, ensure that the the sum of the provided timeouts to these steps does not exceed 180 seconds. If you’re finding it difficult to accomplish this, then that is a sign that the monitor should probably be broken up into separate monitor scripts.</p>
    <h3>Cause</h3>
    <p>All synthetic scripted monitors have a non-configurable maximum global 180s timeout for running a script.</p>
    <p>If a script has not completed after 180 seconds, the job is terminated. If this happens consistently it could be a sign of a script that is taking too long to complete, or that the job is waiting an extended period of time while attempting to perform a scripted task.</p>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoibmV0d29yay1lcnJvci1hcGkifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6Ik5ldHdvcmtFcnJvcjogTW9uaXRvciBwcm9kdWNlZCBubyB0cmFmZmljIn1d">
    <div data-prop-text="title">NetworkError: Monitor produced no traffic</div>
    <h3>Problem</h3>
    <p>The API test or scripted browser monitor appears to be running but is returning this error.</p>
    <h3>Solution</h3>
    <p>Ensure that <code>$http.get()</code> or <code>$browser.get()</code> are being called appropriately and are generating traffic.</p>
    <p>For Scripted API monitors, if you are using a <a href="https://github.com/request/request#requestoptions-callback">request option</a> to spin up an un-instrumented HTTP agent under the hood, specify one of our instrumented HTTP agents using either of the agent request options below:</p>
    <ul>
      <li>
        <p><code>$globalAgents.http</code></p>
      </li>
      <li>
        <p><code>$globalAgents.https</code></p>
        <p>Example:</p>
        <pre><code>var options = {
    uri: 'https://www.newrelic.com',
    agent: $globalAgents.https,
    agentOptions: {
        'rejectUnauthorized': false
    },
    strictSSL: false
};

function callback(err, res, body) { ...
};

$http.get(options, callback);
</code></pre>
        <h3>Cause</h3>
        <p>This occurs in scripted monitor runs when the HTTP client ($http in Scripted API monitors) or Chrome browser ($browser in Scripted Browser monitors) is not used to generate HTTP traffic.</p>
        <p>In some cases, certain <a href="https://github.com/request/request#requestoptions-callback">request options</a> in API monitors may force a new HTTP agent, one that is not instrumented by Synthetics, to be used to collect HTTP traffic.</p>
      </li>
    </ul>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoibmV0d29yay11bmRlZmluZWQtYXBpIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJSZWZlcmVuY2VFcnJvcjogJG5ldHdvcmsgaXMgbm90IGRlZmluZWQifV0=">
    <div data-prop-text="title">ReferenceError: $network is not defined</div>
    <h3>Problem</h3>
    <p>The <code>$network</code> object used for setting <a href="/docs/synthetics/new-relic-synthetics/scripting-monitors/set-proxy-settings-scripted-monitors">monitor</a> proxies is not available for that monitor’s <a href="/docs/synthetics/new-relic-synthetics/scripting-monitors/scripted-monitor-runtime-environment#runtime-table">runtime</a>.</p>
    <h3>Solution</h3>
    <p>If your monitor was created before the 0.4.0 runtime release, create a new monitor to take advantage of the latest runtime. Your monitor’s current runtime version is shown at the top of the Monitor Settings page.</p>
    <p>For more information, see Scripted monitor version runtime environments.</p>
    <h3>Cause</h3>
    <p>This error occurs when attempting to use <code>$network</code> on a monitor with a runtime at or below 0.2.2. Proxying monitor traffic was introduced in monitor runtime version 0.4.0, causing this method to be evaluated as undefined on earlier monitor runtimes.</p>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoic2NyaXB0LXRpbWVvdXQtZXJyb3ItYXBpIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJTY3JpcHRUaW1lb3V0RXJyb3IifV0=">
    <div data-prop-text="title">ScriptTimeoutError</div>
    <h3>Problem</h3>
    <p>This error indicates that the job has reached the Docker container timeout threshold, and the script was terminated.</p>
    <h3>Solution</h3>
    <p>If this is a frequent error, consider breaking up the scripted tasks into a separate scripted monitors.</p>
    <p>If it appears that a specific task is causing the job to wait an unacceptable amount of time, consider changing the method by which you’re accomplishing that task. For example, changing <code>$browser.findElement(locator: $driver.Locator)</code> to <code>$browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number)</code> would assigned the task its own configurable timeout.</p>
    <p>If you have multiple steps where the <code>$browser.waitForAndFindElement(locator, timeout)</code> function is called, ensure that the the sum of the provided timeouts to these steps does not exceed 180 seconds. If you’re finding it difficult to accomplish this, then that is a sign that the monitor should probably be broken up into separate monitor scripts.</p>
    <h3>Cause</h3>
    <p>All synthetic scripted monitors have a non-configurable maximum global 180s timeout for running a script.</p>
    <p>If a script has not completed after 180 seconds, the job is terminated. If this happens consistently it could be a sign of a script that is taking too long to complete, or that the job is waiting an extended period of time while attempting to perform a scripted task.</p>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoidW5leHBlY3RlZC10b2tlbi1hcnJvdyJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ0aXRsZSIsInZhbHVlIjoiU3ludGF4RXJyb3I6IFVuZXhwZWN0ZWQgdG9rZW4gPCJ9XQ==">
    <div data-prop-text="title">SyntaxError: Unexpected token &#x3C;</div>
    <h3>Problem</h3>
    <p><code>JSON.parse()</code> was passed a string that begins with the &#x3C; character and is likely HTML, instead of JSON.</p>
    <h3>Solution</h3>
    <p>Ensure the target endpoint is returning the expected response body. You can do this by logging the response body in the callback, before attempting to parse.</p>
    <p>Example:</p>
    <pre><code>$http.get('http://www.newrelic.com', function(error, response, body) {
  if (error) {
      throw new Error(error);
  }

  console.log(body);    // Log HTML response body, don't parse as JSON

});

</code></pre>Depending on the target API endpoint, you may need to include specific request headers to ensure that JSON is returned.
    ### Cause
    The script is attempting to use `JSON.parse()` on a response body after a request is made and is expecting the endpoint to return JSON, but HTML was returned instead.
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoidW5leHBlY3RlZC10b2tlbi11LWFwaSJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ0aXRsZSIsInZhbHVlIjoiU3ludGF4RXJyb3I6IFVuZXhwZWN0ZWQgdG9rZW4gdSBpbiBKU09OIGF0IHBvc2l0aW9uIDAifV0=">
    <div data-prop-text="title">SyntaxError: Unexpected token u in JSON at position 0</div>
    <h3>Problem</h3>
    <p><code>JSON.parse()</code> was passed an undefined parameter, but expected a JSON string.</p>
    <h3>Solution</h3>
    <p>Troubleshoot the cause of the request error. Details on what is causing request errors can be found in the error object passed to the request callback function.</p>
    <p>Example:</p>
    <pre><code>$http.get('http://www.newrelic.com', function(error, response, body) {
  if (error) {
      throw new Error(error);
  }

  var bodyJson = JSON.parse(body);
  console.log(bodyJson);           // Log response body

});

</code></pre>### Cause
    This can occur in Scripted API monitors when a performing an API request, then attempting to parse the request response within the callback function. The response body is passed to `JSON.parse()` without checking if the response body is undefined first.
    An undefined response body is often caused by a request error. If there is no error handling to prevent code that parses the response body, this monitor failure will occur.
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiY2Fubm90LXJlYWQtcHJvcGVydHkifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6IlR5cGVFcnJvcjogQ2Fubm90IHJlYWQgcHJvcGVydHkgJ3N0YXR1c0NvZGUnIG9mIHVuZGVmaW5lZCJ9XQ==">
    <div data-prop-text="title">TypeError: Cannot read property 'statusCode' of undefined</div>
    <h3>Problem</h3>
    <p>The response object (and thus response.statusCode) in an API request callback is undefined.</p>
    <h3>Solution</h3>
    <p>Troubleshoot the cause of the request error. Details on what is causing request errors can be found in the error object passed to the request callback function.</p>
    <p>Example:</p>
    <pre><code>$http.get('http://www.newrelic.com', function(error, response, body) {
    if (error) {
        throw new Error(error);
    }
    console.log(response.statusCode);
});

</code></pre>### Cause
    This error occurs when there was an error completing the API request (for example, unable to reach server, unable to resolve DNS). In these instances, the request was not completed so the response object in the callback function arguments is undefined.
    If there is no error handling to prevent code that checks response status code, this monitor failure will occur.
  </div>
</div>
