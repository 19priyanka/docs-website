
<p>When using synthetic monitoring's <a href="/docs/synthetics/new-relic-synthetics/private-locations/private-locations-overview-monitor-internal-sites-add-new-locations">private locations</a> with New Relic's alerts, you can be notified if a location is under-provisioned, mis-configured, or generally misbehaving.</p>
<p>This guide will help you answer the following basic questions regarding private location health by using <a href="/docs/insights">New Relic dashboards</a> and <a href="https://docs.newrelic.com/docs/alerts/new-relic-alerts/defining-conditions/create-alert-conditions-nrql-queries">NRQL alerts</a>:</p>
<ul>
  <li><a href="#are_my_minions_online">Are my private minions online?</a></li>
  <li><a href="#create_an_alerts_policy">Does my private location need more minions?</a></li>
  <li><a href="#minion-status">Can I check the status of a specific minion directly?</a></li>
</ul>
<h2>Prerequisites</h2>
<p>Before following the instructions in this guide, ensure you have:</p>
<ul>
  <li>A <a href="/docs/synthetics/new-relic-synthetics/private-locations/private-locations-overview-monitor-internal-sites-add-new-locations">synthetic private location</a></li>
  <li>At least one <a href="/docs/synthetics/new-relic-synthetics/private-locations/install-containerized-private-minions-cpms#install-update">private minion</a> installed at that location</li>
  <li>Checks scheduled to run at that location</li>
  <li>An <a href="/docs/alerts/new-relic-alerts/configuring-alert-policies">alert policy</a> for the private location, with a configured <a href="/docs/alerts/new-relic-alerts/managing-notification-channels/notification-channels-control-where-send-alerts#slack">notification channel</a> to notify your team when a violation occurs</li>
</ul>
<p>The Private Minion dashboard example can be imported to your account using the <a href="https://docs.newrelic.com/docs/insights/insights-api/manage-dashboards/insights-dashboard-api">Dashboard API</a> with the following JSON:</p>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJQcml2YXRlIE1pbmlvbiBkYXNoYm9hcmQgSlNPTiJ9XQ==">
    <div data-prop-text="title">Private Minion dashboard JSON</div>
    <pre><code>{
"dashboard": {
"title": "Synthetics Private Minions",
"description": "Synthetics Private Minions Dashboard",
"icon": "bar-chart",
"visibility": "all",
"editable": "editable_by_all",
"metadata": {
"version": 1
},
"widgets": [
{
"visualization": "billboard",
"layout": {
"width": 1,
"height": 1,
"row": 1,
"column": 1
},
"data": [
{
"nrql": "SELECT latest(minionLocation) as 'Location' from SyntheticsPrivateMinion since 30 minutes ago"
}
],
"presentation": {
"title": "Location",
"notes": null,
"threshold": {}
}
},
{
"visualization": "uniques_list",
"layout": {
"width": 1,
"height": 1,
"row": 1,
"column": 2
},
"data": [
{
"nrql": "SELECT uniques(minionId) from SyntheticsPrivateMinion since 30 minutes ago limit 500"
}
],
"presentation": {
"title": "Minions reporting",
"notes": null
}
},
{
"visualization": "facet_table",
"layout": {
"width": 1,
"height": 1,
"row": 1,
"column": 3
},
"data": [
{
"nrql": "SELECT latest(minionStartTimestamp) as 'Birthday' from SyntheticsPrivateMinion since 30 minutes ago facet minionId limit 200"
}
],
"presentation": {
"title": "Alive since",
"notes": null,
"drilldown_dashboard_id": null
}
},
{
"visualization": "faceted_line_chart",
"layout": {
"width": 1,
"height": 1,
"row": 2,
"column": 1
},
"data": [
{
"nrql": "SELECT max(minionProcessorsUsagePercentage) as 'CPU load %' from SyntheticsPrivateMinion since 30 minutes ago timeseries 1 minute facet minionId"
}
],
"presentation": {
"title": "CPU load %",
"notes": null
}
},
{
"visualization": "faceted_line_chart",
"layout": {
"width": 1,
"height": 1,
"row": 2,
"column": 2
},
"data": [
{
"nrql": "SELECT max(minionPhysicalMemoryUsedPercentage) as 'Used memory %' from SyntheticsPrivateMinion since 30 minutes ago timeseries 1 minute facet minionId"
}
],
"presentation": {
"title": "Used memory %",
"notes": null
}
},
{
"visualization": "faceted_line_chart",
"layout": {
"width": 1,
"height": 1,
"row": 2,
"column": 3
},
"data": [
{
"nrql": "SELECT max(minionPhysicalMemoryFreeBytes / 1e9) from SyntheticsPrivateMinion since 30 minutes ago timeseries 1 minute facet minionId"
}
],
"presentation": {
"title": "Free memory GB",
"notes": null
}
}
],
"filter": {
"event_types": [
"SyntheticsPrivateMinion"
],
"attributes": []
}
}
}

</code></pre>
  </div>
</div>
<h2>Are my private minions online? [#are_my_minions_online]</h2>
<p>To answer this question, you can rely on attributes from the <code>SyntheticsPrivateMinion</code>event. Private minions send this event to New Relic every 30 seconds. A simple way to check if your minions are online is to compare the unique count of minion IDs with the number of minions you expect to be online.</p>
<p>To understand how many minions are reporting, run this example <a href="/docs/query-data/nrql-new-relic-query-language/query-tools/chart-builder-create-query-visualizations">NRQL query</a>:</p>
<pre><code>SELECT uniqueCount(minionId)
  FROM SyntheticsPrivateMinion
  WHERE minionLocation = '1-acme_okc_dc-309'
</code></pre>
<p>Using this query, you can create an alert condition to notify your team when fewer minions are reporting than expected. This condition is configured with a static threshold of <code>2 units</code>, which means you will receive an alert if any of your minions are offline.</p>
<p>You can verify that the alert policy works as expected by manually stopping one of your minions. Then, when the alert violation occurs, you will be notified by any notification channels that have been set up. Once the minion is restarted and it comes back online, the alert will recover.</p>
<p>There are more robust ways to check whether minions are functioning correctly, but this query and condition simply and successfully handle the case where a machine fails, is accidentally decommissioned, or the minion process crashes. It also ensures that the minion can communicate with New Relic.</p>
<h2>Does my private location need more minions? [#more-minions]</h2>
<p>To answer this question, you can use the <code>checksPending</code> attribute of the <code>SyntheticsPrivateLocationStatus</code> event. The <code>checksPending</code> attribute reflects the number of monitor checks that are scheduled (or "queued") but have yet to be accepted by a minion in the designated location. For a location with scheduled checks and no minions, this graph would grow linearly up and to the right.</p>
<p>This metric is more complicated to monitor than <code>uniqueCount(minionId)</code> because a high value does not necessarily mean the location is in a bad state. As long as the metric is not growing linearly up and to the right (and checks are being run on schedule), the location is in a good state.</p>
<p>This use case is perfect for <a href="/docs/alerts/new-relic-alerts/defining-conditions/create-baseline-alert-conditions">baseline NRQL alert conditions</a>, which allow you to monitor the deviation of a metric rather than its static value. For example:</p>
<pre><code>SELECT average(checksPending)
  FROM SyntheticsPrivateLocationStatus
  WHERE name = '1-acme_tokyo_dc-512'
</code></pre>
<p>To test this alert condition, schedule one-minute, browser-based monitors to run from your location. Browser-based jobs consume more resources than ping jobs, which is why they are a better fit for load simulation. New Relic will quickly notify you of a growing number of pending checks.</p>
<p>After doubling the number of minions to handle the load, the alert recovers. For example, using the <strong>Synthetics private location</strong> dashboard example, notice the growth and decline of pending checks over the course of the incident and recovery. By using the NRQL condition, New Relic will notify you if and when the location needs more minion capacity.</p>
<h2>Can I check the status of a specific minion directly? [#minion-status]</h2>
<p>You can also check how a minion is operating by contacting it directly. You can use a set of HTTP endpoints exposed by the minion to determine what the application is doing. In order to access these endpoints, bind ports <code>8080</code> and <code>8180</code> to ports on the host. For example, for Docker, use <code>docker run -p 80:8080 -p 81:8180 ...</code>):</p>
<ul>
  <li><code>:8080/status/check</code>: Details about internal health-checks the minion performs; HTTP 200 means "healthy."</li>
  <li><code>:8080/status</code>: Details about a minion's status; the same data is then <a href="https://docs.newrelic.com/docs/insights/insights-data-sources/default-events-attributes/synthetics-default-events-attributes-insights#syntheticprivateminion-table">published to Insights as a <code>SyntheticsPrivateMinion</code> event</a>.</li>
  <li><code>:8180/</code>: JVM application admin endpoints; an advanced view of a minion's internal state.</li>
</ul>
<p>This approach is not as automated or flexible as the <a href="#more-minions"><code>checksPending</code> example</a>. However, if you have total network connectivity failure, this manual approach can help troubleshoot the situation.</p>
