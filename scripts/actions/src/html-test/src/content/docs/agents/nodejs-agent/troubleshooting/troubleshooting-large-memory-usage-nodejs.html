
<h2>Problem</h2>
<p>You installed the New Relic Node.js agent, and your Node.js application's memory usage increased.</p>
<h2>Solution</h2>
<p>There are several possible causes for this memory increase and potential solutions for each.</p>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoic3NsIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJJbmNyZWFzZSBjYXVzZWQgYnkgU1NML1RMUyJ9XQ==">
    <div data-prop-text="title">Increase caused by SSL/TLS</div>
    <p>To reduce memory leaks caused by TLS in Node.js Core, <a href="/docs/agents/nodejs-agent/installation-configuration/nodejs-agent-configuration#ssl">disable SSL</a>.</p>
    <p>If you disable SSL, manually set the <a href="/docs/agents/nodejs-agent/installation-configuration/nodejs-agent-configuration#port">port</a> to <code>80</code>.</p>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoic2xhYiJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ0aXRsZSIsInZhbHVlIjoiSW5jcmVhc2UgY2F1c2VkIGJ5IFRMUyBtZW1vcnkgYnVmZmVyIGFsbG9jYXRpb24ifV0=">
    <div data-prop-text="title">Increase caused by TLS memory buffer allocation</div>
    <p>The first time a Node.js application uses any form of encryption, including SSL and HTTPS, a <a href="http://en.wikipedia.org/wiki/Slab_allocation">slab buffer</a> is created. The default size for this buffer is 10 MB.</p>
    <p>Applications running in environments where SSL termination on inbound requests occurs in a separate router layer do not normally incur this overhead. Cloud services like Heroku and AWS often operate this way. However, the Node.js agent sends outbound data to New Relic services over HTTPS, and this triggers the allocation of a slab buffer.</p>
    <p><strong>Solution:</strong></p>
    <p>In some cases, you can reduce the slab buffer below its 10 MB default.</p>
    <p>To set the slab buffer size, use <a href="http://nodejs.org/api/tls.html#tls_tls_slab_buffer_size">tls.SLAB_BUFFER_SIZE</a>.</p>
    <div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJjYXV0aW9uIn1d">
      <p>When using the New Relic agent, do not set the slab buffer size below 128 KB. The slab buffer allocation should not be reduced for apps that communicate with services or clients using SSL, HTTPS, or any other form of cryptography.</p>
    </div>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiY2x1c3RlciJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ0aXRsZSIsInZhbHVlIjoiSW5jcmVhc2UgY2F1c2VkIGJ5IGNsdXN0ZXIgd29ya2VyIHNsYWIgYWxsb2NhdGlvbnMifV0=">
    <div data-prop-text="title">Increase caused by cluster worker slab allocations</div>
    <p>Node.js provides the <a href="http://nodejs.org/api/cluster.html">Cluster module</a>. This allows for handling requests in parallel by using all processor cores available on a host. However, each cluster worker allocates its own slab buffer for SSL transactions, and keeps its own copy of Node.js agent data. This multiplies the memory overhead by the number of cluster workers used.</p>
    <p>The is also true if a host runs multiple Node.js applications at the same time.</p>
    <p><strong>Solution:</strong></p>
    <p>Some cloud service providers use environments that state a higher number of processor cores than can actually be used at any given time. Reducing the number of cluster workers or running without Cluster support may decrease memory usage without impacting performance.</p>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoibG9nIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJJbmNyZWFzZSBjYXVzZWQgYnkgbG9nIG1lc3NhZ2VzIHN0b3JlZCB0byBkaXNrIn1d">
    <div data-prop-text="title">Increase caused by log messages stored to disk</div>
    <p>Log messages are logged to disk by default. Due to how message data is handled, message objects may be moved into <strong>Old-pointer-space</strong> for garbage collection. This means the objects stay in memory for a while, even after all references to them are gone. This leads to a larger amount of memory consumed by a process at any given time. Additional processing time is also used for garbage collection.</p>
    <p><strong>Solution:</strong></p>
    <p>Depending on your version of the Node.js, the agent may default to the <strong>trace</strong> or <strong>info</strong> log levels. Decrease logging verbosity to <strong>info</strong> or <strong>warn</strong> levels to noticeably decrease memory usage and time spent in garbage collection.</p>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoibW9uZ28ifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6IkluY3JlYXNlIGNhdXNlZCBieSBsZWFrZWQgTW9uZ29EQiBjdXJzb3JzIn1d">
    <div data-prop-text="title">Increase caused by leaked MongoDB cursors</div>
    <p>Many database drivers use an abstraction called a <strong>cursor</strong>. Cursors provide the ability to iterate through the results of queries. For example, the <strong>mongodb</strong> driver provides cursors when executing <strong>find</strong> queries.</p>
    <p>Cursors live both as objects in the Node.js runtime and as entities in the MongoDB server. When an application has finished using a cursor, it should close it to free up resources in both the server and the client application.</p>
    <p>In Node.js, it is possible for a cursor to be garbage collected, freeing resources in the application, without closing the cursor in the server. This may be go unnoticed in the application. However, the New Relic Node.js agent keeps track of open cursors to measure the time spent iterating through results. If your application does not close all the cursors it uses, the agent will continue to track stale cursors and leak memory.</p>
    <p><strong>Solution:</strong></p>
    <p>Ensure every cursor created in your application is closed by calling cursor.close() after the application finishes processing the results of the query.</p>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiYWdlbnQifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6IkluY3JlYXNlIGNhdXNlZCBieSBhZ2VudCBkYXRhIHN0b3JhZ2UifV0=">
    <div data-prop-text="title">Increase caused by agent data storage</div>
    <p>The Node.js agent records data for each transaction your app handles. Data is generally grouped by transaction name. The memory used by the agent increases with the number of different transactions recorded in each minute-long harvest cycle.</p>
    <p>In addition, a larger amount of data is kept during each transaction, but is eventually discarded when the transaction completes. Memory used by the agent increases with the number of concurrent transactions handled by the application.</p>
    <p><strong>Solution:</strong></p>
    <p>If agent data storage is identified as the cause of a memory usage increase, this can best be addressed by adding additional memory to your host, or by switching to a larger cloud instance.</p>
  </div>
</div>
