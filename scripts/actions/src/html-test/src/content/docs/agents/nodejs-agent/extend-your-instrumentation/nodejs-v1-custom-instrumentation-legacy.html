
<p>New Relic for Node.js automatically instruments most standard web requests, but sometimes you want expanded instrumentation. With custom instrumentation, you can instrument <a href="#web-txn">web sockets</a>, <a href="#background-txn">background jobs</a>, and <a href="#expanding-instrumentation">unsupported databases</a>. Custom instrumentation can also <a href="#expanding-instrumentation">target specific sections of your code for deeper insight</a>.</p>
<p>Custom instrumentation is available in versions 1.10.0 or higher of the Node.js agent. To take advantage of the latest Node.js agent features, <a href="/docs/agents/nodejs-agent/installation-configuration/upgrade-nodejs-agent">upgrade your agent</a>.</p>
<h2>Instrumenting web transactions [#web-txn]</h2>
<p>To instrument web transactions, such as websocket requests, create a custom transaction. Creating a custom transaction gives you the same type of visibility into that custom transaction that you would get from a transaction that the agent automatically instruments.</p>
<ol>
  <li>Wrap the handler you want to instrument with <a href="/docs/agents/nodejs-agent/supported-features/nodejs-agent-api#createWebTransaction"><code>createWebTransaction()</code></a>.</li>
  <li>Ensure you call <a href="/docs/agents/nodejs-agent/supported-features/nodejs-agent-api#endTransaction"><code>endTransaction()</code></a> at the end of the transaction.</li>
</ol>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJpbXBvcnRhbnQifV0=">
  <p>Do not use brackets <code>[suffix]</code> at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses <code>(suffix)</code> or other symbols if needed.</p>
</div>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiaW5zdHJ1bWVudC1pbi1zb2NrZXQtaW8ifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6IkV4YW1wbGU6IEluc3RydW1lbnQgdHdvIHRyYW5zYWN0aW9ucyBpbiBzb2NrZXQuaW8ifV0=">
    <div data-prop-text="title">Example: Instrument two transactions in socket.io</div>
    <p>This example instruments a <code>/websocket/ping</code> transaction and a <code>/websocket/new-message</code> transaction within <strong>socket.io</strong>. The <code>/ping</code> example is synchronous, while the <code>/new-message</code> example is asynchronous.</p>
    <pre><code>var nr = require('newrelic')
var app = require('http').createServer()
var io = require('socket.io')(app)

io.on('connection', function (socket) {
  socket.on('ping', nr.createWebTransaction('/websocket/ping', function (data) {
    socket.emit('pong')
    nr.endTransaction()
  }))
  socket.on('new-message', nr.createWebTransaction('/websocket/new-message', function (data) {
    addMessageToChat(data, function () {
      socket.emit('message-received')
      nr.endTransaction()
    })
  }))
})

</code></pre>&#x3C;Callout variant="tip">
    Ensure you call [`endTransaction()`](/docs/agents/nodejs-agent/supported-features/nodejs-agent-api#endTransaction) at the end of the transaction.
    &#x3C;/Callout>
  </div>
</div>
<h2>Instrumenting background transactions [#background-txn]</h2>
<p>You can also use custom transactions to instrument background tasks, such as periodic jobs within your app or work that continues after a request completes. To instrument background tasks, wrap the handler you want to instrument with <a href="/docs/agents/nodejs-agent/supported-features/nodejs-agent-api#createBackgroundTransaction"><code>createBackgroundTransaction()</code></a>. Ensure you call <a href="/docs/agents/nodejs-agent/supported-features/nodejs-agent-api#endTransaction"><code>endTransaction()</code></a> at the end of the transaction.</p>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiZXhhbXBsZS1pbnN0cnVtZW50LXVwZGF0ZSJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ0aXRsZSIsInZhbHVlIjoiRXhhbXBsZTogSW5zdHJ1bWVudCB3aXRoaW4gc2V0SW50ZXJ2YWwifV0=">
    <div data-prop-text="title">Example: Instrument within setInterval</div>
    <p>This example instruments <code>update:cache</code> within <code>setInterval</code>:</p>
    <pre><code>var nr = require('newrelic')
var redis = require('redis').createClient()

setInterval(nr.createBackgroundTransaction('update:cache', function () {
  var newValue = someDataGenerator()

  redis.set('some:cache:key', newValue, function () {
    nr.endTransaction() // End the transaction once redis is done
  })
}), 30000) // Every 30s

</code></pre>&#x3C;Callout variant="tip">
    Ensure you call [`endTransaction()`](/docs/agents/nodejs-agent/supported-features/nodejs-agent-api#endTransaction) at the end of the transaction.
    &#x3C;/Callout>
  </div>
</div>
<h2>Expanding instrumentation within transactions [#expanding-instrumentation]</h2>
<p>You can also use custom instrumentation to provide more visibility into web transactions that are already instrumented, or to gain insight into databases and other in-transaction work that is not automatically instrumented. To do this, wrap your callbacks in custom tracers. Custom tracers create and collect specific metrics for an additional segment within an existing transaction, such as a particular function or a database call.</p>
<p>To instrument callbacks, wrap the callback with <a href="/docs/agents/nodejs-agent/supported-features/nodejs-agent-api#createTracer"><code>createTracer()</code></a>. If you want to instrument a function that is called inside an asynchronous function, you need to wrap both the target function and its parent asynchronous function with <a href="/docs/agents/nodejs-agent/supported-features/nodejs-agent-api#createTracer"><code>createTracer()</code></a>.</p>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJ0aXAifV0=">
  <p>You must place these examples inside an already instrumented transaction. The transaction can be automatically instrumented, or via a custom transaction.</p>
</div>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoid3JhcC1zaW5nbGUtY2FsbGJhY2sifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6IkV4YW1wbGU6IEluc3RydW1lbnQgYSBjYWxsYmFjayJ9XQ==">
    <div data-prop-text="title">Example: Instrument a callback</div>
    <p>This examples wraps a single callback:</p>
    <pre><code>// Wrap the callback in a segment
db.createObject(nr.createTracer('db:createObject', function (err, result) {
  // Some error handler that will end the response for us
  if (util.handleError(err, res)) {
    return
  }
  res.write(JSON.stringify(result.rows[0].id))
  res.write('\n')
  res.end()
}))

</code></pre>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoid3JhcC10d28tY2FsbGJhY2tzIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJFeGFtcGxlOiBJbnN0cnVtZW50IGFuIGFzeW5jIGZ1bmN0aW9uIn1d">
    <div data-prop-text="title">Example: Instrument an async function</div>
    <p>This example wraps both <code>pg.connect</code> and <code>client.query</code>. This is because <code>client.query</code> is called by an asynchronous parent function (<code>pg.connect</code>). Otherwise, we would not get any data from <code>client.query</code>. This allows <code>createTracer()</code> to propagate the active transaction across those asynchronous boundaries.</p>
    <pre><code>pg.connect(config.db_string, nr.createTracer('pg:connect', function (err, client, done) {
  if (util.handleError(err, '500', res)) {
    return done()
  }
  client.query('SELECT count(*) FROM test_count', nr.createTracer('pg:query', function (err, result) {
    if (util.handleError(err, '500', res)) {
      return done()
    }

    res.write(result.rows[0].count)
    res.write('\n')
  }))
}))

</code></pre>
  </div>
</div>
