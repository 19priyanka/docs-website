
<p>This document is aimed at the developers or maintainers of PHP frameworks. It suggests ways to extend your framework by adding support for New Relic.</p>
<p>The PHP agent supports frameworks by figuring out where in the framework code web transactions can be appropriately named, and naming web transactions based on information found in the class, function call, etc. This solution is fragile and subject to the developers altering their code. New Relic encourages framework developers to put in the few calls needed to improve the out-of-box user experience with the framework they maintain.</p>
<h2>Help your users [#frameworks]</h2>
<p>New Relic can identify the web transaction name and where to insert JavaScript headers and footers for New Relic's browser monitoring. However, to improve end users' experience, increase performance, and make code maintenance easier, framework developers should do this work themselves.</p>
<p>It is up to the developers of the various frameworks to decide if they want to help their users by adding native support for New Relic. In almost all cases adding support for New Relic involves inserting three API calls somewhere in the framework code.</p>
<h2>Terminology</h2>
<p>In order to understand how to best add support for New Relic, it is useful to understand some of the key points of interaction.</p>
<div data-component="Table" data-prop="W10=">
  <div>
    <div>
      <div>
        <p><strong>Term</strong></p>
      </div>
      <div>
        <p><strong>Definition</strong></p>
      </div>
    </div>
  </div>
  <div>
    <div>
      <div>
        <p><strong>Web transactions</strong></p>
      </div>
      <div>
        <p><strong>Web transactions</strong> are asset requests (or user hits) to your site. With frameworks, this is often handled by an MVC dispatching mechanism.</p>
      </div>
    </div>
    <div>
      <div>
        <p><strong>Metrics</strong></p>
      </div>
      <div>
        <p><strong>Metrics</strong> are named entities that report timing information. New Relic uses these metrics to generate charts and pages, such as the <a href="/docs/apm/applications-menu/monitoring/apm-overview-page">APM <strong>Summary</strong> page</a>. For example, New Relic instruments calls to MySQL and generate metrics called <code>Database/select</code> or <code>Database/update</code> whenever a user selects or updates data.</p>
        <p>Metrics only contain timing data.</p>
      </div>
    </div>
    <div>
      <div>
        <p><strong>Transaction traces</strong></p>
      </div>
      <div>
        <p>During every harvest period, New Relic records the slowest web transaction that falls below a user-defined threshold. This is a <strong>transaction trace</strong>.</p>
        <p>It has more detail than simple metrics. If enabled, it will include a detailed call graph of exactly what functions were called and how long they took. For slow query statements, it obfuscates all data in the call.</p>
      </div>
    </div>
  </div>
</div>
<h2>Name transactions [#dev]</h2>
<p>How you name your web transactions will affect the quality of the user experience.</p>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJpbXBvcnRhbnQifV0=">
  <p>Do not use brackets <code>[suffix]</code> at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses <code>(suffix)</code> or other symbols if needed.</p>
</div>
<p><strong>Examples:</strong></p>
<p>If you have a blog-style framework, you would name the various transactions based on the user activity: <code>display</code>, <code>edit</code>, <code>login</code>, etc.</p>
<p>If you use an MVC architecture, then an appropriate naming convention is <code>controller/action</code>. Do <strong>not</strong> include any request-specific data in the transaction name. For example, using the actual request URL leads to <a href="/docs/features/metric-grouping-issues">metric grouping issues</a>.</p>
<div data-component="Table" data-prop="W10=">
  <div>
    <div>
      <div>
        <p><strong>Platform</strong></p>
      </div>
      <div>
        <p><strong>Transaction naming example</strong></p>
      </div>
    </div>
  </div>
  <div>
    <div>
      <div>
        <p><strong>Drupal 7</strong></p>
      </div>
      <div>
        <p>The dispatching is done in <code>menu_execute_active_handler()</code>. This calls <code>call_user_func_array()</code>, with the first argument being the name of the action. That is what to set as the web transaction name.</p>
      </div>
    </div>
    <div>
      <div>
        <p><strong>CakePHP 1.3</strong></p>
      </div>
      <div>
        <p>CakePHP has a <code>Dispatcher</code> class with an <code>_invoke</code> method. This calls the appropriate controller class with a given action, and the transaction is named <code>controller/action</code> where <code>controller</code> is the name of the controller class.</p>
      </div>
    </div>
  </div>
</div>
<p>At the point where you want to route code to a specific controller and action (if you are using MVC) or to an action (if you are not using MVC), insert code similar to this:</p>
<p><strong>Controller and action</strong> (when using MVC):</p>
<pre><code>if (extension_loaded ('newrelic')) {
  newrelic_name_transaction ($controller . '/' . $action);
}
</code></pre>
<p><strong>Action only</strong> (not using MVC):</p>
<pre><code>if (extension_loaded ('newrelic')) {
  newrelic_name_transaction ($action);
}
</code></pre>
<h2>Insert the JavaScript header and footer [#page-load-timing]</h2>
<p>For page load timing (sometimes referred to as real user monitoring or RUM), insert the JavaScript header and footer. This allows you to monitor the end users' experience of the generated page.</p>
<ul>
  <li><strong>Recommendation:</strong> If your framework has a central function that generates all page headers and footers, install the JavaScript code here.</li>
  <li>For frameworks that are template-driven, insert these in your header and footer templates.</li>
</ul>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoicGFnZS1nZW5lcmF0b3IifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6Ikluc2VydCBpbiBhIHBhZ2UgZ2VuZXJhdG9yIGZ1bmN0aW9uIn1d">
    <div data-prop-text="title">Insert in a page generator function</div>
    <p>The header <strong>must</strong> be inserted as close to the top of the generated page as possible. Immediately after the <code>&#x3C;meta http-equiv....></code> tag is the ideal place. It should precede <strong>any</strong> JavaScript, CSS stylesheets or other linked or embedded content.</p>
    <pre><code>if (extension_loaded ('newrelic')) {
  echo newrelic_get_browser_timing_header();
}

</code></pre>`newrelic_get_browser_timing_footer()` takes an optional `bool` that defaults to **true**. It indicates whether or not the returned string should be enclosed by script tags.
    <pre><code>
if (extension_loaded ('newrelic')) {
    echo newrelic_get_browser_timing_footer();
}

</code></pre>`newrelic_get_browser_timing_header()` takes an optional `bool` argument that defaults to **true**. It indicates whether or not the returned string should be enclosed by script tags.
    **Recommendation:** Insert the footer immediately before the `&#x3C;/body>` page close tag as the very last thing on the generated page.
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoidGVtcGxhdGUifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6Ikluc2VydCBpbiB0ZW1wbGF0ZXMifV0=">
    <div data-prop-text="title">Insert in templates</div>
    <p>Use this header template as an example:</p>
    <pre><code>&#x3C;?php if (extension_loaded ('newrelic')) {
  echo newrelic_get_browser_timing_header();
} ?>

</code></pre>
    <pre><code>
&#x3C;?php if (extension_loaded ('newrelic')) {
  echo newrelic_get_browser_timing_footer();
} ?>

</code></pre>Use this footer template as an example:
  </div>
</div>
