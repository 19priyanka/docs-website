
<p>The New Relic Ruby agent automatically collects many metrics. It also includes an API you can use to collect additional metrics about your application. If you see large <strong>Application Code</strong> segments in transaction trace details, custom instrumentation can give a more complete picture of what is going on in your application.</p>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJ0aXAifV0=">
  <p>Collecting too many metrics can impact the performance of your application and New Relic. To avoid data problems, keep the total number of unique metrics introduced by custom instrumentation under 2000.</p>
</div>
<h2>Method tracers [#method_tracers]</h2>
<p>The easiest way to capture custom instrumentation is by tracing calls to a particular method. Tracing a method as described below will insert an additional node in your transaction traces for each invocation of that method, providing greater detail about where time is going in your transactions.</p>
<p>Method tracers are software probes you can put on a method of any class. The probes use alias method chaining to insert themselves when the target methods execute and gather custom instrumentation on their performance.</p>
<h2>Tracing in class definitions [#tracing-classes]</h2>
<p>Method tracers can be used within normal class definitions, as long as the target method has been defined first:</p>
<pre><code>require 'new_relic/agent/method_tracer'
class Foo
  include ::NewRelic::Agent::MethodTracer

  def generate_image
    ...
  end

  add_method_tracer :generate_image, 'Custom/generate_image'
end
</code></pre>
<p>To instrument a class method, add the method tracer in the class singleton:</p>
<pre><code>require 'new_relic/agent/method_tracer'
class Foo
  def self.generate_image
     ...
  end

  class &#x3C;&#x3C; self
    include ::NewRelic::Agent::MethodTracer

    add_method_tracer :generate_image, 'Custom/generate_image'
  end
end
</code></pre>
<p><code>add_method_tracer</code> takes an optional metric name and a hash of options. For more information, see <a href="http://rubydoc.info/github/newrelic/newrelic-ruby-agent/NewRelic/Agent/MethodTracer/ClassMethods#add_method_tracer-instance_method">add_method_tracer in the New Relic RubyDoc</a> .</p>
<h2>Tracing initializers</h2>
<p>For Rails, a common way to add instrumentation is to create an initializer and "monkey patch" the instrumentation directives.</p>
<p>For example, to add a method tracer to <code>MyCache#get</code>:</p>
<ol>
  <li>Make sure the MyCache class is loaded before adding the method tracer.</li>
  <li>Add the following in a file named <strong>config/initializers/rpm_instrumentation.rb</strong>:</li>
</ol>
<pre><code>require 'new_relic/agent/method_tracer'

MyCache.class_eval do
  include ::NewRelic::Agent::MethodTracer

  add_method_tracer :get
end
</code></pre>
<h2>Tracing blocks of code [#tracing-blocks]</h2>
<p>Sometimes a single method is so complex that tracking overall time doesn't give enough detail. In these cases, you can wrap a block of code with a tracer. Call <code>trace_execution_scoped</code> passing the code to trace as a block:</p>
<pre><code>extend ::NewRelic::Agent::MethodTracer

def slow_action
  self.class.trace_execution_scoped(['Custom/slow_action/beginning_work']) do
    # do stuff and report execution time with a custom metric name
  end

  # more stuff, whose time will be "blamed" to slow_action
end
</code></pre>
<p>For more information, see <a href="http://www.rubydoc.info/github/newrelic/newrelic-ruby-agent/NewRelic/Agent/MethodTracer#trace_execution_scoped-instance_method">add_method_tracer in the New Relic RubyDoc</a> .</p>
<h2>Naming transactions</h2>
<p>Instrumented transactions are used to determine the throughput and overall response time for your application. The name of the method and the class will be used for the name of the transaction as reported to New Relic. For more information, see <a href="/docs/traces/viewing-transaction-traces">Viewing transaction traces</a>.</p>
<p>Normally the agent automatically chooses the transaction name. If you want to change the name of a transaction while it is still running, use <code>NewRelic::Agent.set_transaction_name</code> and the corresponding <code>NewRelic::Agent.get_transaction_name</code>.</p>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJpbXBvcnRhbnQifV0=">
  <p>Do not use brackets <code>[suffix]</code> at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses <code>(suffix)</code> or other symbols if needed.</p>
</div>
<p>This is useful if you want to segment your transaction based on some criteria. For example, if you wanted to vary the transaction name by response format in Rails:</p>
<pre><code>class UsersController
  def index
    @users = User.all
    respond_to do |format|
      format.html
      format.json do 
        NewRelic::Agent.set_transaction_name('Users/index.json')
        render :json => @users
      end
      format.xml do 
        NewRelic::Agent.set_transaction_name('Users/index.xml')
        render :xml => @users
      end
    end
  end
end
</code></pre>
<p>Renaming transactions can also be used to segment your requests around some business criteria. For example, you could segment a transaction into "Big Customer" and "Small Customer" with code like this:</p>
<pre><code>class UsersController

  before_filter :segment_new_relic_by_customer_size

  def segment_new_relic_by_customer_size
    new_relic_name = NewRelic::Agent.get_transaction_name
    if current_user.big_customer?
      NewRelic::Agent.set_transaction_name("#{new_relic_name} - big customer")
    else
      NewRelic::Agent.set_transaction_name("#{new_relic_name} - small customer")
    end
  end

end
</code></pre>
<h2>Tracing transaction entry points [#transaction-tracers]</h2>
<p>Ordinarily the agent will be able to identify transactions within your application, but if you're not using a supported framework, or if you'd like to record transactions that the agent is not automatically recording, you can define methods as being transaction entry points:</p>
<pre><code>class Controller
  include NewRelic::Agent::Instrumentation::ControllerInstrumentation

  def transaction
    # execute a transaction
  end
  add_transaction_tracer :transaction
end
</code></pre>
<h2>Instrumenting non-web transactions [#non-web-transactions]</h2>
<p>Along with method-level tracing, you can instrument non-web transactions, such as background tasks, with the same level of transaction and error detail as web transactions. For more information, see <a href="/docs/ruby/monitoring-ruby-background-processes-and-daemons">Monitoring Ruby background processes and daemons</a>.</p>
<h2>Advanced custom instrumentation [#advanced-tracing]</h2>
<p>When tracing code not automatically instrumented by the agent, the standard <a href="https://docs.newrelic.com/docs/agents/ruby-agent/api-guides/ruby-custom-instrumentation#method_tracers">method tracers</a> will usually be enough.</p>
<p>However, sometimes you need to instrument something more complex than a single method call. For example, you may want to instrument a few lines of code within a method, or you may want to start a transaction in one part of your code and finish it elsewhere.</p>
<p>The Tracer module, introduced in agent version 6.0, provides a flexible API that lets you create transactions and segments as well as interact with the current transaction.</p>
<h3>Instrumenting a section of code [#in-transaction]</h3>
<p>To instrument a section of code, wrap the code in a block, then pass the block to the <code>Tracer.in_transaction</code> method:</p>
<pre><code>require 'new_relic/agent/tracer'

def long_and_complex_process
  expensive_setup

  Tracer.in_transaction(partial_name: 'Complex/process',
                        category:     :task) do
    code_to_be_instrumented
  end
  
  expensive_teardown
end
</code></pre>
<p>The agent will ensure that a transaction exists, and will create a segment within it for the code inside the block.</p>
<h3>Starting a transaction or segment [#start-transaction-or-segment]</h3>
<p>If you need to start a transaction at one location in your code but finish it in another (as can happen with callback-based events), call <code>Tracer.start_transaction_or_segment</code>. You <strong>must</strong> call <code>finish</code> on the return value of this method:</p>
<pre><code>require 'new_relic/agent/tracer'

class MyEventWatcher
  def event_started
    @transaction = Tracer.start_transaction_or_segment(
      partial_name: 'MyEventWatcher/my_event',
      category:     :task)
  end
  
  def event_completed
    @transaction.finish
  end
end
</code></pre>
<p>For more information, see <a href="http://rubydoc.info/github/newrelic/newrelic-ruby-agent/NewRelic/Agent/Tracer/">Tracer in the New Relic RubyDoc</a>.</p>
<h2>For more help [#more_help]</h2>
<p>Additional documentation resources include:</p>
<ul>
  <li><a href="/docs/features/custom-instrumentation">Custom instrumentation</a> (Overview of custom instrumentation)</li>
  <li><a href="/docs/ruby/ruby-custom-metrics">Ruby custom metrics</a> (Use an API call to record arbitrary metrics)</li>
</ul>
