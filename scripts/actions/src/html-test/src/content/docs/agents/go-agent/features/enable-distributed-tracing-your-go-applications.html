
<p>Read on to learn how to enable and set up <a href="https://docs.newrelic.com/docs/apm/distributed-tracing/getting-started/introduction-distributed-tracing">distributed tracing</a> for the New Relic's Go agent.</p>
<h2>Enable distributed tracing [#enable]</h2>
<p>To enable distributed tracing for a Go application:</p>
<ol>
  <li>Use <a href="/docs/agents/go-agent/configuration/go-agent-configuration#distributed-tracing">Go agent configuration settings</a> for the type of distributed tracing you want:
    <ul>
      <li>Standard distributed tracing</li>
      <li>Infinite Tracing</li>
    </ul>
  </li>
  <li>Continue reading the <a href="#guidelines">transaction and request instrumentation guidelines</a> below.</li>
</ol>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJ0aXAifV0=">
  <p>For help understanding the different types of agent distributed tracing, see <a href="/docs/understand-dependencies/distributed-tracing/get-started/how-new-relic-distributed-tracing-works">How distributed tracing works</a>.</p>
</div>
<h2>Instrument transactions and HTTP requests [#guidelines]</h2>
<p>In order for distributed tracing to work optimally, your Go application must adhere to guidelines for the following scenarios:</p>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiY3JlYXRlLXRyYW5zYWN0aW9ucyJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ0aXRsZSIsInZhbHVlIjoiSW5zdHJ1bWVudCB0cmFuc2FjdGlvbnMgKGlmIHVzaW5nIFNlcnZlTXV4KSJ9XQ==">
    <div data-prop-text="title">Instrument transactions (if using ServeMux)</div>
    <p>If you are using Go's <a href="https://golang.org/pkg/net/http/#ServeMux"><code>http.ServeMux</code></a> and want to enable New Relic's distributed tracing, your Go application must be instrumented with New Relic's <code>WrapHandle</code> and <code>WrapHandleFunc</code> wrappers. These wrappers automatically start and end transactions with the request and response writer, which will automatically add the correct distributed tracing headers. For more on how header propagation works, see <a href="/docs/apm/distributed-tracing/getting-started/how-new-relic-distributed-tracing-works">How distributed tracing works</a>.</p>
    <div data-component="CollapserGroup" data-prop="W10=">
      <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiZXhhbXBsZS1nby1pbnN0cnVtZW50YXRpb24ifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6IkJlZm9yZSBhbmQgYWZ0ZXIgZXhhbXBsZSJ9XQ==">
        <div data-prop-text="title">Before and after example</div>
        <p>Here is an example of code before instrumentation:</p>
        <pre><code>http.HandleFunc("/users", usersHandler)

</code></pre>
        <pre><code>
http.HandleFunc(newrelic.WrapHandleFunc(app, "/users", usersHandler))

</code></pre>And here is an example of that same code after instrumentation:
      </div>
    </div>
    <p>Read more about using these wrappers in <a href="/docs/agents/go-agent/get-started/instrument-go-transactions#http-handler-txns">Instrument Go transactions</a>.</p>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoibWFrZS1odHRwLXJlcXVlc3RzIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJJbnN0cnVtZW50IG91dGJvdW5kIEhUVFAgcmVxdWVzdHMgYXMgZXh0ZXJuYWwgc2VnbWVudHMifV0=">
    <div data-prop-text="title">Instrument outbound HTTP requests as external segments</div>
    <p>In order to have your outbound HTTP requests eligible for distributed tracing, <a href="/docs/agents/go-agent/get-started/instrument-go-segments#go-external-segments">create an external segment</a>.</p>
    <p>The easiest way to create an external segment for your outbound HTTP request is to use the <code>newrelic.NewRoundTripper</code> method. Here is an example of making a request to <code>http://api.example.com</code> that includes the outgoing distributed tracing headers:</p>
    <pre><code>func useNewRoundTripper(txn *newrelic.Transaction) (*http.Response, error) {
    client := &#x26;http.Client{}
    client.Transport = newrelic.NewRoundTripper(client.Transport)
    request, _ := http.NewRequest("GET", "http://example.com", nil)
    request = newrelic.RequestWithTransactionContext(request, txn)
    return client.Do(request)
}

</code></pre>
    <pre><code>
func noGoodForDt(txn *newrelic.Transaction, url string) (*http.Response, error) {
    // Distributed tracing headers are not added to the outgoing request.
    // Use newrelic.NewRoundTripper or newrelicc.StartExternalSegment instead.
    defer newrelic.ExternalSegment{
        StartTime: txn.StartSegmentNow(),
        URL:       url,
    }.End()

    return http.Get(url)
}

</code></pre>An `ExternalSegment` created with a struct literal cannot be used for distributed tracing. Because of this, New Relic recommends using [`newrelic.NewRoundTripper` or `newrelic.StartExternalSegment`](https://docs.newrelic.com/docs/agents/go-agent/get-started/instrument-go-segments#go-external-segments).
    <pre><code>
func external(txn *newrelic.Transaction, req *http.Request) (*http.Response, error) { 
    s := newrelic.StartExternalSegment(txn, req) 
    response, err := http.DefaultClient.Do(req) 
    s.Response = response 
    s.End() 
    return response, err
}

</code></pre>If you have a more complex request that uses the Go standard library's `http.Request`, use the `newrelic.StartExternalSegment` method to ensure your outbound request is eligible for distributed tracing:
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiY3JlYXRlLW1hbnVhbGx5In0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJNYW51YWxseSBjcmVhdGUgYW5kIGFjY2VwdCBkaXN0cmlidXRlZCB0cmFjZSBwYXlsb2FkIn1d">
    <div data-prop-text="title">Manually create and accept distributed trace payload</div>
    <p>The distributed trace payload contains information that allows New Relic to stitch together transactions occurring in multiple services into a complete transaction trace. If New Relic-monitored services are not sending trace context to each other, it will result in incomplete trace details.</p>
    <p>For general instructions on how to use the API calls below to implement distributed tracing, first see <a href="https://docs.newrelic.com/docs/enable-distributed-tracing#agent-apis">Use distributed tracing APIs</a>.</p>
    <div data-component="Table" data-prop="W10=">
      <div>
        <div>
          <div>
            <p>If you want to...</p>
          </div>
          <div>
            <p>Use this</p>
          </div>
        </div>
      </div>
      <div>
        <div>
          <div>
            <p>Create a payload to be sent to the called service.</p>
          </div>
          <div>
            <pre><code>InsertDistributedTraceHeaders(h http.Header)

</code></pre>
          </div>
        </div>
        <div>
          <div>
            <p>Accept a payload sent from the first service; this will link these services together in a trace.</p>
          </div>
          <div>
            <pre><code>AcceptDistributedTraceHeaders(h http.Header)

</code></pre>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
<p>For more details on using these, see the <a href="https://github.com/newrelic/go-agent/blob/master/GUIDE.md#distributed-tracing">Go agent GitHub repo</a>.</p>
