
<h2>Syntax</h2>
<pre><code>newrelic.agent.create_distributed_trace_payload()
</code></pre>
<p>This method is used for generating payloads used to connect transactions within a distributed trace.</p>
<h2>Requirements</h2>
<p>Python agent version 4.2.0.100 or higher.</p>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJjYXV0aW9uIn1d">
  <p>This API has been deprecated. Please use newrelic.agent.insert_distributed_trace_headers instead.</p>
</div>
<p>Distributed tracing must be <a href="https://docs.newrelic.com/docs/enable-distributed-tracing#python">enabled</a>.</p>
<h2>Description</h2>
<p>This API requires <a href="https://docs.newrelic.com/docs/enable-distributed-tracing">distributed tracing to be enabled</a>.</p>
<p>For instructions on how to use this call, along with its partner call <a href="https://docs.newrelic.com/docs/agents/python-agent/python-agent-api/accept_distributed_trace_payload"><code>accept_distributed_trace_payload</code></a>, see <a href="https://docs.newrelic.com/docs/enable-distributed-tracing#agent-apis">Enable distributed tracing with agent APIs</a>.</p>
<p>This call is used to implement distributed tracing. It generates a payload that is read by the receiving application with the <code>accept_distributed_trace_payload</code> method.</p>
<h2>Return values</h2>
<p>When successful, returns a <code>DistributedTracePayload</code> object, which inherits from Python's builtin <code>dict</code> type and has the following additional methods:</p>
<ul>
  <li><code>text</code>: Generate a JSON encoded string version of the payload.</li>
  <li><code>http_safe</code>: Generate a base64 encoded string version of the payload.</li>
</ul>
<p>When unsuccessful, returns <code>None</code>. This can happen when distributed tracing is not enabled or when called from outside an active transaction.</p>
<h2>Examples</h2>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJpbXBvcnRhbnQifV0=">
  <p>In order to maintain proper ordering of spans in a trace, you must generate the payload in the context of the span that sends it.</p>
</div>
<h3>Create a distributed trace payload inside a background task [#function-trace-example]</h3>
<p>An example of using <code>create_distributed_trace_payload</code> in creating two <a href="/docs/agents/python-agent/python-agent-api/external-trace">external traces</a> from within single a background task:</p>
<pre><code>@newrelic.agent.background_task()
def main(url):
    header_key = newrelic.agent.ExternalTrace.cat_distributed_trace_key

    with newrelic.agent.ExternalTrace('my_external_library',
            url, method='GET'):
        # Generate the payload in the context of the ExternalTrace
        # span that sends it
        payload = newrelic.agent.create_distributed_trace_payload()
        headers = {header_key: payload.http_safe()}
        response = my_external_library._get(url, headers=headers)

    data = _process_response(response)
    
    with newrelic.agent.ExternalTrace('my_external_library',
            url, method='POST'):
        # Generate the payload in the context of the ExternalTrace
        # span that sends it
        payload = newrelic.agent.create_distributed_trace_payload()
        headers = {header_key: payload.http_safe()}
        response = my_external_library._post(url, data=data, headers=headers)
</code></pre>
<h3>Create a distributed trace payload inside an external trace [#function-trace-example]</h3>
<p>An example of using <code>create_distributed_trace_payload</code> in creating an <a href="/docs/agents/python-agent/python-agent-api/external-trace">external trace</a>:</p>
<pre><code>def _bind_url(url, *args, **kwargs):
    # _bind_url is called with the args and kwargs sent to the `get`
    # method below
    return url

@newrelic.agent.external_trace('my_external_library', _bind_url, method='GET')
def get(url):
    payload = newrelic.agent.create_distributed_trace_payload()
    header_key = newrelic.agent.ExternalTrace.cat_distributed_trace_key
    headers = {header_key: payload.http_safe()}
    return my_external_library._get(url, headers=headers)
</code></pre>
