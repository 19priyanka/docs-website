
<p>Insight into the behavior of the Ruby virtual machine can help you understand and improve the performance of your application as a whole. New Relic gathers some key metrics that can help you get a better picture of what your Ruby VM is doing. This can also help you to evaluate the impact of adjustments to VM configuration to improve performance.</p>
<h2>Minimum requirements [#minimum_requirements]</h2>
<p>Ruby VM metric collections are available in versions 3.8.0 or higher of the Ruby agent (although earlier versions did support collection of some basic garbage collection measurements).</p>
<p>In addition, in order to use this feature, you'll need to be on a Ruby version compatible with MRI (Matz's Ruby Interpreter, the most commonly used Ruby implementation) <strong>1.9.2 or higher</strong>. The sections below on each individual measurement explains what Ruby versions support collection of each measurement.</p>
<p>Lastly, in order to capture GC timings, you'll need to <a href="/docs/ruby/garbage-collection">enable GC::Profiler</a> in your application.</p>
<h2>Viewing Ruby VM data [#viewing_data]</h2>
<p>To view data about the performance of your Ruby VMs. <a href="https://one.newrelic.com/">Log into New Relic</a>, click <strong>APM</strong>, then select an app and go to <strong>Monitoring > Ruby VMs</strong>. This page appears only if your application uses Ruby agent version 3.8.0 or higher.</p>
<h2>Measurement details [#measurement_details]</h2>
<p>Most of these metrics help understand the behavior of Ruby's garbage collector.</p>
<p>Not all metrics can be collected across all Ruby versions. In general, you'll get the most complete data if you're on the most recent version of MRI. The list below explains exactly what's available where:</p>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoib2JqZWN0LWFsbG9jYXRpb25zIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJPYmplY3QgYWxsb2NhdGlvbnMifV0=">
    <div data-prop-text="title">Object allocations</div>
    <p><strong>Available on</strong>: MRI 2.0+</p>
    <p>The number of Ruby objects allocated in your processes. In the UI, this measurement is normalized by the number of requests, so that you can get a sense of how many objects are allocated per request.</p>
    <p>This is an important number to watch, since the frequency of object allocations is one of the biggest drivers for how often Ruby's garbage collector must run.</p>
    <p>On MRI, this value is derived from <code>GC.stat[:total_allocated_object]</code>.</p>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoidGltZS1pbi1nYXJiYWdlLWNvbGxlY3Rpb24ifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6IlRpbWUgaW4gZ2FyYmFnZSBjb2xsZWN0aW9uIn1d">
    <div data-prop-text="title">Time in garbage collection</div>
    <p><strong>Available on</strong>: MRI 1.9.2+, Rubinius 2.x (see note below about JRuby support)</p>
    <p>The amount of time spent in garbage collection (both mark and sweep phases) in your Ruby processes.</p>
    <p>The Ruby agent actually measures this value in two different ways: garbage collection time that is incurred in the middle of request processing, and total garbage collection time. Garbage collection time that happens in the middle of request processing is presented as a band on the main overview graph, and in the breakdown charts for individual transactions. Total GC time as a percentage of wall-clock time is shown on the Ruby VMs tab.</p>
    <p>This measurement is derived from <code>GC::Profiler.total_time</code>.</p>
    <p><strong>Note</strong>: You must enable <code>GC::Profiler</code> in order to get this measurement. For more information, see <a href="/docs/ruby/garbage-collection">GC instrumentation</a>.</p>
    <p><strong>JRuby note</strong>: Due to what appears to be <a href="https://github.com/jruby/jruby/issues/1620" title="Link opens in a new window">a bug</a> in either JRuby or certain versions of the JVM, GC timings may be off by a factor of 1000 on JRuby. For this reason, we don't currently recommend enabling <code>GC::Profiler</code> on JRuby.</p>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiZnJlcXVlbmN5LW9mLWdhcmJhZ2UtY29sbGVjdG9yLXJ1bnMifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6IkZyZXF1ZW5jeSBvZiBnYXJiYWdlIGNvbGxlY3RvciBydW5zIn1d">
    <div data-prop-text="title">Frequency of garbage collector runs</div>
    <p><strong>Available on</strong>: MRI 1.9.2+, JRuby 1.7+, Rubinius 2.x</p>
    <p>How often does the garbage collector need to stop your Ruby process in order to run? On MRI 2.1+, this will be segmented into major and minor GC runs. This number is presented in the UI as the number of requests processed per GC run.</p>
    <p>Depending on the version of Ruby in use, this value may be derived from <code>GC.count</code>, or from <code>GC.stat[:minor_gc_count]</code> and <code>GC.stat[:major_gc_count]</code>.</p>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoic2l6ZS1vZi10aGUtcnVieS1oZWFwIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJTaXplIG9mIHRoZSBSdWJ5IGhlYXAifV0=">
    <div data-prop-text="title">Size of the Ruby heap</div>
    <p><strong>Available on</strong>: MRI 1.9.2+</p>
    <p>The Ruby interpreter stores objects on a <em>heap</em>, with each object occupying a single <em>heap slot</em>. As slots within the heap fill up with objects, the heap will be expanded by the Ruby VM as necessary.</p>
    <p>The Ruby agent measures both the number of live objects in the heap, and the number of unoccupied heap slots on a periodic basis.</p>
    <p>Generally speaking, the more objects there are on the heap, the longer each GC run will take (since potentially every object on the heap must be examined). More objects on the heap also correlates to higher memory usage for your application.</p>
    <p>This value is derived from <code>GC.stat[:heap_live_slot]</code> or <code>GC.stat[:heap_live_num]</code>, and <code>GC.stat[:heap_free_slot]</code> or <code>GC.stat[:heap_free_num]</code>.</p>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoibWVtb3J5LXVzYWdlIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJNZW1vcnkgdXNhZ2UifV0=">
    <div data-prop-text="title">Memory usage</div>
    <p><strong>Available on</strong>: Any Ruby version</p>
    <p>This measurement shows the memory usage (resident set size) of your Ruby processes, presented as the average size per instance (process). Keeping memory usage in check is an important consideration when tuning your Ruby VM settings. If it grows too large, you can cause the host machine to start paging to disk, or bump up against software-enforced memory limits.</p>
    <p>On Linux hosts, this is derived from the <code>VmRSS</code> field of <code>/proc/PID/status</code>.</p>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoibWV0aG9kLWNhY2hlLWludmFsaWRhdGlvbi1yYXRlIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJNZXRob2QgY2FjaGUgaW52YWxpZGF0aW9uIHJhdGUifV0=">
    <div data-prop-text="title">Method cache invalidation rate</div>
    <p><strong>Available on</strong>: MRI 2.1+</p>
    <p>Every time a method is invoked on an object, Ruby must locate the implementation of that method by searching up the ancestor chain of the object. Because these searches are expensive, the Ruby VM will cache the results of these searches.</p>
    <p>In older versions of MRI (prior to 2.0), there was a single, global method cache, and there were a variety of <a href="https://github.com/charliesome/charlie.bz/blob/master/posts/things-that-clear-rubys-method-cache.md">operations</a> that could cause the entire cache to be invalidated.</p>
    <p>In MRI 2.1 or higher, the global cache has been broken up into a set of smaller, per-class caches, so that cache-invalidating changes to one class won't throw out cache entries for other unrelated classes.</p>
    <p>There are, however, still some operations that will cause all method caches to be invalidated. The Ruby agent will measure how frequently these invalidations happen, and report this measurement normalized against the number of requests, to give you an idea of how many times per request all of the method caches are invalidated.</p>
    <p>For more information, see this <a href="http://tmm1.net/ruby21-method-cache/" title="Link opens in a new window">blog post</a> by Aman Gupta.</p>
    <p>This value is derived from <code>RubyVM.stat[:global_method_state]</code>.</p>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiY29uc3RhbnQtY2FjaGUtaW52YWxpZGF0aW9uLXJhdGUifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6IkNvbnN0YW50IGNhY2hlIGludmFsaWRhdGlvbiByYXRlIn1d">
    <div data-prop-text="title">Constant cache invalidation rate</div>
    <p><strong>Available on</strong>: MRI 2.1+</p>
    <p>Ruby caches the locations of constants in a way that's similar to the method caching behavior described above. The Ruby agent can also measure the number of times the global constant cache is invalidated, and report this as an average number of invalidations per request.</p>
    <p>This value is derived from <code>RubyVM.stat[:global_constant_state]</code>.</p>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoidGhyZWFkLWNvdW50In0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJUaHJlYWQgY291bnQifV0=">
    <div data-prop-text="title">Thread count</div>
    <p><strong>Available on</strong>: MRI 1.9.2+, JRuby 1.7+, Rubinius 2.x</p>
    <p>The Ruby agent can keep track of the number of threads in your Ruby processes. If you're using a multi-threaded web server, this can be used to confirm that your thread pool is actually the size you have configured it to be. It can also highlight if you have a thread leak (where you're spawning threads that never get torn down).</p>
  </div>
</div>
<h2>Background processes [#background_processes]</h2>
<p>By default, data from all processes reporting into a given application name in New Relic will be combined on the <strong>Ruby VM</strong> page in the user interface. This means that if you have both web and background processes (such as Resque, Sidekiq, DelayedJob, etc.) reporting into the same New Relic application, the data may be confusing.</p>
<p>There are two ways to work around this issue:</p>
<ol>
  <li>Pull your web and background processes into separate applications in New Relic, by setting the <code>app_name</code> configuration setting, or the <code>NEW_RELIC_APP_NAME</code> environment variable.</li>
  <li>Disable the collection of Ruby VM metrics in your background processes, by setting <code>disable_vm_sampler: true</code> in your configuration file, or by setting <code>NEW_RELIC_DISABLE_VM_SAMPLER=1</code> in your application's environment.</li>
</ol>
<h2>Additional Documentation resources</h2>
<p>Additional documentation resources include:</p>
<ul>
  <li>The <a href="/docs/applications-menu/applications-overview">APM Summary page</a> discusses features and drill-down details when in the UI.</li>
  <li>The <a href="/docs/apm/applications-menu/monitoring/transactions-page">Transactions page</a> shows a summary of your app's performance.</li>
  <li>The <a href="/docs/ruby/ruby-agent-configuration">Ruby agent configuration</a> resource contains update procedures and configuration file values, including general, proxy, transaction traces, and error collector.</li>
</ul>
<h2>For more help [#more_help]</h2>
