
<h2>Syntax</h2>
<pre><code>newrelic.agent.function_trace(name=None, group=None, label=None, params=None, terminal=False)
</code></pre>
<p>Used to instrument functions, methods, generators, and coroutines that aren't instrumented by default.</p>
<h2>Description</h2>
<p><code>function_trace</code> is a decorator for adding to functions, methods, generators, and coroutines. Adding this decorator lets you collect additional <a href="/docs/accounts-partnerships/education/getting-started-new-relic/glossary#transaction">transaction</a> information (including transaction trace information). (An alternate way to instrument functions without having to touch your app code is to <a href="/docs/agents/python-agent/custom-instrumentation/python-custom-instrumentation-config-file">list them in the config file</a>.)</p>
<p><code>function_trace</code> does not give you a full profile of all the functions that happen in a decorated function. What it does is add the decorated function as a node in the New Relic UI and capture the time spent in that function. If you need more detail about what is going on in that function, you would need to also apply the function trace to the function's child functions.</p>
<p>The <code>function_trace</code> decorator can be used on generators and coroutines with agent version 2.102.0.85 or higher. Timing of these objects begins when consumption starts, and ends when the object is exhausted or goes out of scope. This is a change from earlier versions where the metric represented the time taken to create the generator or coroutine object itself.</p>
<p>You can use the decorator in conjunction with existing decorators, including those for static and class methods. When nesting multiple decorators, have the <code>function_trace</code> decorator as the outermost decorator.</p>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJpbXBvcnRhbnQifV0=">
  <p>For any decorators that are being wrapped, use <code>functools.wraps()</code> from the Python standard library in their implementation. (Or, otherwise ensure that the decorator propagates the correct name attributes of the innermost wrapped object required to allow correct name introspection.) If this is not done, then when the metric is reported, the name of the nested decorator function (not the innermost wrapped function) will be used.</p>
</div>
<h2>Alternate call forms [#alternate]</h2>
<p>For setups where you cannot use the decorator, these alternate call forms are available:</p>
<h3>The context manager [#context-manager]</h3>
<p>The <code>FunctionTrace</code> context manager is used when the parameters to be passed cannot be determined before runtime. (For example, you may not know the name of a function at import time.) When using the context manager to name a metric, you must always supply the name and the metric path prefix.</p>
<p>The <code>FunctionTrace</code> class implements the context manager and is used in conjunction with the <code>with</code> statement. The <code>FunctionTrace</code> class is the lowest level primitive available for tracing time against a transaction.</p>
<p>The <code>with</code> statement defines the bounds of what is timed and not a single function. Thus, the context manager could be applied to an arbitrary block of code. The block of code could therefore contain calls to multiple functions, or it could be a self-contained block of code implementing a time-oriented algorithm that you want to track.</p>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJpbXBvcnRhbnQifV0=">
  <p>Avoid tracing blocks of code that are called an excessive number of times. For example, do not use it within the context of a loop that executes many times. The data generated will incur a performance overhead. A better solution is to enclose the loop.</p>
</div>
<h3>The wrapper</h3>
<p>If you know in advance where the specific functions you want to trace are, you could use the <code>function_trace</code> decorator. However, if you <strong>don't</strong> know all the functions that need to be traced (for example, if they're being looked up dynamically as part of a routing system), then you must use the <code>FunctionTraceWrapper</code> to wrap the function at the time of registration or at the time of calling.</p>
<h3>Path-based wrapping [#path-based]</h3>
<p><code>wrap_function_trace</code> is used for wrapping functions outside of the code they're declared in. For example: you might use this to instrument library code that you don't want to modify.</p>
<p>For more about the differences between these call formats, see <a href="/docs/python-agent-api-different-call-forms">Different call formats</a>.</p>
<h2>Parameters</h2>
<h3>Parameters for decorator [#main-parameters]</h3>
<pre><code>newrelic.agent.function_trace(name=None, group=None, label=None, params=None, terminal=False)
</code></pre>
<p>This call includes these parameters:</p>
<div data-component="Table" data-prop="W10=">
  <div>
    <div>
      <div>
        <p>Parameter</p>
      </div>
      <div>
        <p>Description</p>
      </div>
    </div>
  </div>
  <div>
    <div>
      <div>
        <p><code>name</code></p>
        <p><em>string</em></p>
      </div>
      <div>
        <p>Optional. The function name. If not set, defaults to the captured name of the function.</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>group</code></p>
        <p><em>string</em></p>
      </div>
      <div>
        <p>Optional. The <code>group</code> represents the naming structure for the <code>name</code> parameter. This is used in the UI for segregating the <a href="/docs/apm/applications-menu/monitoring/transactions-page#tx_functions">transaction types</a>.</p>
        <p>If not supplied, the group will default to <code>Function</code> in expectation that the name is of the form <code>module:class.function</code> or <code>module:function</code> and represents the name of the function being executed. If you are creating a custom group, it's recommended you prefix it with <code>Python/</code>.</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>label</code></p>
        <p><em>string</em></p>
      </div>
      <div>
        <p>Optional. Adds a callout-style flag to the segment in a transaction trace. Default is <code>None</code>.</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>params</code></p>
        <p><em>dict</em></p>
      </div>
      <div>
        <p>Optional. Custom parameters to add to the segment in transaction traces.</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>terminal</code></p>
        <p><em>boolean</em></p>
      </div>
      <div>
        <p>Optional. If true, no children segments will be recorded. Default is False.</p>
      </div>
    </div>
  </div>
</div>
<h3>Parameters for context manager [#context-mgr-parameters]</h3>
<pre><code>newrelic.agent.FunctionTrace(name, group=None, label=None, params=None, terminal=False)
</code></pre>
<p>Parameters for the context manager includes all of the <a href="#main-parameters">parameters</a> from <code>function_trace</code>. The <code>name</code> parameter is required and not optional.</p>
<div data-component="Table" data-prop="W10=">
  <div>
    <div>
      <div>
        <p>Parameter</p>
      </div>
      <div>
        <p>Description</p>
      </div>
    </div>
  </div>
  <div>
    <div>
      <div>
        <p><code>name</code></p>
        <p><em>string</em></p>
      </div>
      <div>
        <p>Required. The function name.</p>
      </div>
    </div>
  </div>
</div>
<h3>Wrapper parameters</h3>
<pre><code>newrelic.agent.FunctionTraceWrapper(wrapped, name=None, group=None, label=None, params=None, terminal=False)
</code></pre>
<p>Parameters for the wrapper include all <a href="#main-parameters">parameters</a> for <code>function_trace</code> and a <code>wrapped</code> parameter:</p>
<div data-component="Table" data-prop="W10=">
  <div>
    <div>
      <div>
        <p>Parameter</p>
      </div>
      <div>
        <p>Description</p>
      </div>
    </div>
  </div>
  <div>
    <div>
      <div>
        <p><code>wrapped</code></p>
        <p><em>function</em></p>
      </div>
      <div>
        <p>Required. The function being wrapped.</p>
      </div>
    </div>
  </div>
</div>
<h3>Path-based wrapping parameters [#path-wrap-parameters]</h3>
<pre><code>newrelic.agent.wrap_function_trace(module, object_path, name=None, group=None, label=None, params=None, terminal=False)
</code></pre>
<p>Parameters include all <a href="#main-parameters">parameters</a> for <code>function_trace</code> and these parameters:</p>
<div data-component="Table" data-prop="W10=">
  <div>
    <div>
      <div>
        <p>Parameter</p>
      </div>
      <div>
        <p>Description</p>
      </div>
    </div>
  </div>
  <div>
    <div>
      <div>
        <p><code>module</code></p>
        <p><em>object</em></p>
      </div>
      <div>
        <p>Required. The module containing the function to be instrumented.</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>object_path</code></p>
        <p><em>string</em></p>
      </div>
      <div>
        <p>The path to the location of the function.</p>
      </div>
    </div>
  </div>
</div>
<h2>Examples</h2>
<h3><code>function_trace</code> example [#trace_example]</h3>
<p>An example of using the <code>function_trace</code> decorator:</p>
<pre><code>import newrelic.agent

class _Database(UserDict.DictMixin):

    ...

    @newrelic.agent.function_trace()
    def _commit(self):
        ...

@newrelic.agent.function_trace()
def open(file, flag=None, mode=0666):
...
</code></pre>
<p>An example of using the <code>function_trace</code> decorator with native coroutines:</p>
<pre><code>import newrelic.agent

class _Database(UserDict.DictMixin):

    ...

    @newrelic.agent.function_trace()
    async def _commit(self):
        ...

@newrelic.agent.function_trace()
async def open(file, flag=None, mode=0666):
...
</code></pre>
<h3>Context manager example [#context-mgr-example]</h3>
<p>An example of using the <code>FunctionTrace</code> context manager:</p>
<pre><code>import newrelic.agent

def dispatch_request(self, request):
    adapter = self.url_map.bind_to_environ(request.environ)
    try:
        endpoint, values = adapter.match()
        function = getattr(self, 'on_' + endpoint)
        with newrelic.agent.FunctionTrace(
                endpoint, 'Python/EndPoint'):
            return function(request, **values)
    except HTTPException as e:
        return e
</code></pre>
<h3>Wrapper example [#trace-wrap-example]</h3>
<p>An example of using the <code>FunctionTraceWrapper</code>:</p>
<p>URL routing with Werkzeug yields a name that is used first to dynamically look up a method of a class using <code>getattr()</code> and the result then invoked:</p>
<pre><code>def dispatch_request(self, request):
    adapter = self.url_map.bind_to_environ(request.environ)
    try:
        endpoint, values = adapter.match()
        return getattr(self, 'on_' + endpoint)(request, **values)
    except HTTPException as e:
        return e
</code></pre>
<p>If you want to trace the endpoint function, you can rewrite this as:</p>
<pre><code>import newrelic.agent

def dispatch_request(self, request):
    adapter = self.url_map.bind_to_environ(request.environ)
    try:
        endpoint, values = adapter.match()
        function = getattr(self, 'on_' + endpoint)
        function = newrelic.agent.FunctionTraceWrapper(function)
        return function(request, **values)
    except HTTPException as e:
        return e
</code></pre>
<p>If you want to name the metric after the endpoint name (rather than naming the metric based on the identifier for the function being called), you can supply the name to use plus an alternate metric path prefix when the <code>FunctionTraceWrapper</code> object is created.</p>
<pre><code>import newrelic.agent

def dispatch_request(self, request):
    adapter = self.url_map.bind_to_environ(request.environ)
    try:
        endpoint, values = adapter.match()
        function = getattr(self, 'on_' + endpoint)
        function = newrelic.agent.FunctionTraceWrapper(
                function, name=endpoint, group='Python/EndPoint')
        return function(request, **values)
    except HTTPException as e:
        return e
</code></pre>
<p>For this example, if the endpoint were called <code>help</code>, the final metric would be:</p>
<pre><code>Python/EndPoint/help
</code></pre>
<p>In the performance breakdown for a transaction, the category would be <code>Python</code> and the segment name <code>EndPoint/help</code>. That segment name would also appear in slow transaction traces as the node name.</p>
