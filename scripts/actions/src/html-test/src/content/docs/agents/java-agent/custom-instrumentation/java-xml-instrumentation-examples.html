
<p>For your New Relic-monitored Java application, one <a href="/docs/agents/java-agent/custom-instrumentation/java-custom-instrumentation">custom instrumentation</a> method is to use an XML file that lists the methods and classes you want to instrument. This documentation shows an example XML instrumentation file. For more information, see <a href="/docs/agents/java-agent/custom-instrumentation/java-instrumentation-xml">Java instrumentation by XML</a>.</p>
<h2>Edit XML file in UI [#ui]</h2>
<p>To edit your XML file directly from the New Relic UI: Go to <strong><a href="https://one.newrelic.com">one.newrelic.com</a> > APM > (select an app) > Settings > Instrumentation</strong>. From here you can:</p>
<ul>
  <li>Download a sample XML file.</li>
  <li>Select an edit existing XML file.</li>
  <li>Search the instrumentation history.</li>
</ul>
<h2>XML file format [#file-format]</h2>
<p>The XML file format includes root and child nodes.</p>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJjYXV0aW9uIn1d">
  <p>Do not instrument all of your methods, as this can lead to a <a href="/docs/apm/other-features/metrics/metric-grouping-issues">metric grouping issue</a>.</p>
</div>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiZXh0ZW5zaW9uIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJSb290IG5vZGU6IGV4dGVuc2lvbiJ9XQ==">
    <div data-prop-text="title">Root node: extension</div>
    <p>The root node of an XML file is <code>extension</code>. It can have three different attributes:</p>
    <div data-component="Table" data-prop="W10=">
      <div>
        <div>
          <div>
            <p>Value</p>
          </div>
          <div>
            <p>Definition</p>
          </div>
        </div>
      </div>
      <div>
        <div>
          <div>
            <p><code>name</code></p>
          </div>
          <div>
            <p>A unique but descriptive name identifying your XML extension.</p>
          </div>
        </div>
        <div>
          <div>
            <p><code>enabled</code></p>
          </div>
          <div>
            <p>Identifies whether the extension will be read by the Java agent. Default is <code>true</code>. If <code>false</code>, New Relic will ignore the extension.</p>
          </div>
        </div>
        <div>
          <div>
            <p><code>version</code></p>
          </div>
          <div>
            <p>The version of the extension. If two extensions have the same name, only the extension with the highest version will be used.</p>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiaW5zdHJ1bWVudGF0aW9uIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJJbnN0cnVtZW50YXRpb24gKGNoaWxkIG9mIGV4dGVuc2lvbikifV0=">
    <div data-prop-text="title">Instrumentation (child of extension)</div>
    <p>The <code>instrumentation</code> node is a child of <code>extension</code>. It can have one attribute: <code>metricPrefix</code>. This is the prefix used for the metric names when the <code>nameTransaction</code> node is not specified. Default is <code>CUSTOM</code>.</p>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoicG9pbnRjdXQifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6IlBvaW50Y3V0IChjaGlsZCBvZiBpbnN0cnVtZW50YXRpb24pIn1d">
    <div data-prop-text="title">Pointcut (child of instrumentation)</div>
    <p>The <code>pointcut</code> is a child node of <code>instrumentation</code> and can have several attributes. Also, a <code>pointcut</code> can have several different <a href="#pointcut-children">child nodes</a>.</p>
    <div data-component="Table" data-prop="W10=">
      <div>
        <div>
          <div>
            <p>Value</p>
          </div>
          <div>
            <p>Definition</p>
          </div>
        </div>
      </div>
      <div>
        <div>
          <div>
            <p><code>transactionStartPoint</code></p>
          </div>
          <div>
            <p>If a transaction is not already in progress when this pointcut is reached, then a transaction will be started. If a transaction is already in progress, then that transaction will continue. A new transaction will not be created.</p>
          </div>
        </div>
        <div>
          <div>
            <p><code>metricNameFormat</code></p>
          </div>
          <div>
            <p>The name format to use for a metric. If not present, then this will default to the class name followed by the method name. You can only set the <code>metricNameFormat</code> on pointcuts where <code>transactionStartPoint</code> is set to <code>false</code>.</p>
          </div>
        </div>
        <div>
          <div>
            <p><code>excludeFromTransactionTrace</code></p>
          </div>
          <div>
            <p>When <code>true</code> the transaction trace will not be provided if this pointcut initiates the transaction. If the pointcut is reached in the middle of a transaction, then the transaction trace will still be present, but this method will be excluded from the call graph.</p>
          </div>
        </div>
        <div>
          <div>
            <p><code>ignoreTransaction</code></p>
          </div>
          <div>
            <p>When <code>true</code> the entire transaction will be ignored.</p>
          </div>
        </div>
        <div>
          <div>
            <p><code>transactionType</code></p>
          </div>
          <div>
            <p>Sets the type of the transaction. Possible values are <code>background</code> (default, reported as a <a href="/docs/apm/transactions/intro-transactions/monitor-background-processes-other-non-web-transactions">non-web transaction</a>) and <code>web</code> (reported as a <a href="/docs/apm/transactions/intro-transactions/transactions-new-relic-apm">web transaction</a>).</p>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoicG9pbnRjdXQtY2hpbGRyZW4ifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6IkNoaWxkIG5vZGVzIGZvciBwb2ludGN1dCJ9XQ==">
    <div data-prop-text="title">Child nodes for pointcut</div>
    <p>A <code>pointcut</code> can have several different child nodes:</p>
    <div data-component="Table" data-prop="W10=">
      <div>
        <div>
          <div>
            <p>Value</p>
          </div>
          <div>
            <p>Definition</p>
          </div>
        </div>
      </div>
      <div>
        <div>
          <div>
            <p><code>nameTransaction</code></p>
          </div>
          <div>
            <p>If this element is present, the agent will name the transaction using the class name and method(s) instrumented by this pointcut.</p>
          </div>
        </div>
        <div>
          <div>
            <p><code>methodAnnotation</code></p>
          </div>
          <div>
            <p>The case sensitive full name of an annotation class including the package name. All methods that are marked with this annotation will be matched.</p>
          </div>
        </div>
        <div>
          <div>
            <p><code>className</code></p>
          </div>
          <div>
            <p>The case sensitive name of the class to match, including the package name. Pair this node with the method node. If this node is present on a pointcut, then the <code>interfaceName</code> node cannot be present on the same pointcut node.</p>
            <p>The <code>className</code> node has the attribute <code>includeSubclasses</code>. If <code>true</code> the methods on the class with the matching name will be instrumented along with the matching methods on any child class of this class. If <code>false</code> (default), only methods on the exact class specified will be instrumented.</p>
            <p>The <code>className</code> must follow these rules:</p>
            <ul>
              <li>Inner classes can be instrumented.</li>
              <li>The full package structure with dots between packages must be used.</li>
              <li>To match subclasses of the specified class, set the attribute <code>includeSubclasses</code> to <code>true</code>.</li>
            </ul>
          </div>
        </div>
        <div>
          <div>
            <p><code>interfaceName</code></p>
          </div>
          <div>
            <p>The case sensitive name of an interface, including the package name, whose implementation classes will be matched. Pair this node with the method node. If this node is present on a pointcut, then the <code>className</code> node cannot be present on the same pointcut node.</p>
            <p>The <code>interfaceName</code> must follow this rule: The full package structure with dots between packages must be used.</p>
          </div>
        </div>
        <div>
          <div>
            <p><code>method</code></p>
          </div>
          <div>
            <p>A method on the class to instrument. Pair this node with a <code>className</code> node. Also, the <code>method</code> node can have <a href="#method-children">children</a>.</p>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoibWV0aG9kLWNoaWxkcmVuIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJDaGlsZCBub2RlcyBmb3IgbWV0aG9kIn1d">
    <div data-prop-text="title">Child nodes for method</div>
    <p>The <code>method</code> node can have several children. For more information and examples, see <a href="/docs/agents/java-agent/custom-instrumentation/troubleshooting-java-custom-instrumentation#separate-transaction">Troubleshooting Java custom instrumentation</a>.</p>
    <div data-component="Table" data-prop="W10=">
      <div>
        <div>
          <div>
            <p>Value</p>
          </div>
          <div>
            <p>Definition</p>
          </div>
        </div>
      </div>
      <div>
        <div>
          <div>
            <p><code>name</code></p>
          </div>
          <div>
            <p>The exact case sensitive name of the method to match.</p>
            <p>A method <code>name</code> node must follow these rules:</p>
            <ul>
              <li>Public, protected, private, and package methods can all be instrumented.</li>
              <li>Static and instance methods can be instrumented.</li>
              <li>Constructors cannot be instrumented.</li>
            </ul>
          </div>
        </div>
        <div>
          <div>
            <p><code>parameters</code></p>
          </div>
          <div>
            <p>The parameter types of the method specified in order. If the <code>parameters</code> element is not present, then all methods matching the name will be matched. This includes private and protected declarations.</p>
            <p>A method <code>parameters</code> node contains a list of the method's parameters, specified by <code>type</code> elements. Here are the major rules for the <code>type</code> elements:</p>
            <ul>
              <li>Primitives are specified using their normal name: int, float, double, long, byte, short, boolean, char.</li>
              <li>Objects require a full package structure. For example, do not use <code>String</code> in the XML; instead, use <code>java.lang.String</code>.</li>
              <li>Do not use generics with collection objects. For example, write <code>java.util.List</code> instead of <code>java.util.List&#x3C;String></code>.</li>
              <li>Include brackets for arrays. For example, an array of integers will be <code>int[ ]</code> and an array of strings will be <code>java.lang.String[ ]</code>.</li>
              <li>Include two sets of brackets for an array of arrays. For example, an array of arrays of longs would be <code>long[ ][ ]</code>.</li>
              <li>To send the parameter as an analytic event to New Relic One, add an XML attribute to the type element called <code>attributeName</code>.</li>
              <li>To use a method with no parameters, the <code>parameters</code> node needs to be present to match a "no arguments" method.</li>
            </ul>
          </div>
        </div>
        <div>
          <div>
            <p><code>returnType</code></p>
          </div>
          <div>
            <p>The case sensitive name of a class indicating a return type to match. All methods that return this class type will be matched.</p>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
<h2>Example</h2>
<p>Here is a sample class and an XML file that could be used to instrument that class.</p>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoicGFja2FnZS10ZXN0In0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJTYW1wbGUgY2xhc3MifV0=">
    <div data-prop-text="title">Sample class</div>
    <pre><code>package test;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class SampleTester {

    private String configName;
    private Map&#x3C;String, Long> maxSampleTimes;

    public SampleTester(String pConfigName) {
        configName = pConfigName;
        maxSampleTimes = new HashMap&#x3C;>();
    }

    public void checkSample(String name, long[] times) {
        if (times != null) {
            maxSampleTimes.put(name, getFirst(times));
        } else {
            maxSampleTimes.put(name, (long) getFirst());
        }
    }

    private Long getFirst(long[] times) {
        return times[0];
    }

    private int getFirst() {
        return 0;
    }

    public void printMaxRepeat(final long max) throws Exception {
        Runnable myRunnable = new Runnable() {
            public void run() {
                try {
                    printMax(max);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        };

        ScheduledExecutorService scheduledExecutor = Executors.newScheduledThreadPool(1);
        scheduledExecutor.scheduleWithFixedDelay(myRunnable, 0, 10000, TimeUnit.MILLISECONDS);
    }

    private void printMax(long max) {
        System.out.println("max is " + max);
    }
}

</code></pre>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoic2FtcGxlLXhtbC1maWxlIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJTYW1wbGUgWE1MIGluc3RydW1lbnRhdGlvbiBmaWxlIGFuZCBleHBsYW5hdGlvbiJ9XQ==">
    <div data-prop-text="title">Sample XML instrumentation file and explanation</div>
    <pre><code>&#x3C;?xml version="1.0" encoding="UTF-8"?>
&#x3C;extension xmlns="https://newrelic.com/docs/java/xsd/v1.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="newrelic-extension extension.xsd "
    name="customExtension" version="1.0">
  &#x3C;instrumentation metricPrefix="EXAMPLE">
    &#x3C;pointcut transactionStartPoint="true">

      &#x3C;!--class name is preceded by package name-->
      &#x3C;className>test.SampleTester&#x3C;/className>
      &#x3C;method>
        &#x3C;name>checkSample&#x3C;/name>
        &#x3C;parameters>
          &#x3C;type attributeName="sampleName">java.lang.String&#x3C;/type>
          &#x3C;type>long[]&#x3C;/type>
        &#x3C;/parameters>
      &#x3C;/method>
      &#x3C;!--two methods with the same name but different signatures can share one node-->
      &#x3C;method>
        &#x3C;name>getFirst&#x3C;/name>
      &#x3C;/method>
      &#x3C;method>
        &#x3C;name>run&#x3C;/name>
      &#x3C;/method>
    &#x3C;/pointcut>

    &#x3C;pointcut transactionStartPoint="false" ignoreTransaction="false"
      excludeFromTransactionTrace="false"
      metricNameFormat="SampleTester/methods">
      &#x3C;className>test.SampleTester&#x3C;/className>
      &#x3C;method>
        &#x3C;name>printMaxRepeat&#x3C;/name>
      &#x3C;/method>
     &#x3C;method>
        &#x3C;name>printMax&#x3C;/name>
      &#x3C;/method>
    &#x3C;/pointcut>

  &#x3C;/instrumentation>
&#x3C;/extension>

</code></pre>The first block of the XML file specifies the name and version of the extension. As the XML extension is default `enabled`, that attribute is not specified.
    The second block specifies the methods in `SampleClass` that should be instrumented. A transaction is started at the beginning of the block. It is worth noting that in the example class, there are two methods that share a name (`getFirst`) but have different signatures. These are instrumented with a single method node. By removing the `parameters` node, all methods with the same name can be matched under one method node.
    In the third block, the specified methods do not have a transaction started on them. This is because the transaction has already been started in `run`. The transaction will not be ignored, and will be included in the transaction trace.
  </div>
</div>
