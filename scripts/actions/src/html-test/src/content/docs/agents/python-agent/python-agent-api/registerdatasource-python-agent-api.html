
<h2>Syntax</h2>
<pre><code>newrelic.agent.register_data_source(source, application=None, name=None, settings=None, **properties)
</code></pre>
<p>Registers a data source for generating custom metric data.</p>
<h2>Description</h2>
<p>This call registers a data source to be polled at the completion of each <a href="https://docs.newrelic.com/docs/accounts-partnerships/education/getting-started-new-relic/glossary#harvest-cycle">harvest cycle</a> for generating custom <a href="/docs/data-analysis/metrics/analyze-your-metrics/data-collection-metric-timeslice-event-data#timeslice-data">metric timeslice data</a>. For more about why and how to use data sources for custom metrics, see <a href="/docs/agents/python-agent/supported-features/python-custom-metrics#custom-metric-data-sources">Custom metric data sources</a>.</p>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJ0aXAifV0=">
  <p>In most cases, you won't need to use any optional arguments except for <code>name</code>.</p>
</div>
<p>Metrics returned by a data source can be a simple <code>(name, value)</code> tuple where the value is a numeric or float, or the value can be a dictionary that corresponds to an already aggregated data sample for a specific metric.</p>
<p>When returning a dictionary as the metric value, the fields that can be supplied are:</p>
<ul>
  <li><code>count</code></li>
  <li><code>total</code></li>
  <li><code>min</code></li>
  <li><code>max</code></li>
  <li><code>sum_of_squares</code></li>
</ul>
<p>For more about these fields and some general usage tips, see <a href="/docs/agents/python-agent/supported-features/python-custom-metrics#pre-aggregated-metrics">Pre-aggregated metrics</a>.</p>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJ0aXAifV0=">
  <p>You can also accomplish the same result using <a href="/docs/agents/python-agent/installation-configuration/python-agent-configuration">agent configuration</a>, which doesn't require you to change your code. To add the data source in this way, add a section in the config file with the prefix <code>data-source:</code>, followed by a unique value to distinguish the section for that of another data source if more than one is specified. Here's an example:</p>
  <pre><code>[data-source:memory-usage]enabled = truefunction = samplers:memory_metrics# application = ...# name = ...[data-source:cpu-usage]enabled = truefunction = samplers:CPUMetricsDataSource# application = ...# name = ...
</code></pre>
  <p>If the data source was specified by a function, then the name would be <code>module:function</code>. If a class, then it would be: <code>module:class</code>. The module must be able to be found using the Python module search path.</p>
  <p>As with <code>register_data_source</code>, the application to report data to and the name are optional.</p>
</div>
<h2>Parameters</h2>
<div data-component="Table" data-prop="W10=">
  <div>
    <div>
      <div>
        <p>Parameter</p>
      </div>
      <div>
        <p>Description</p>
      </div>
    </div>
  </div>
  <div>
    <div>
      <div>
        <p><code>source</code></p>
        <p><em>function</em> or <em>class</em></p>
      </div>
      <div>
        <p>Required. The data source, which is a function or class that has had the <a href="/docs/agents/python-agent/python-agent-api/data_source_generator"><code>data_source_generator</code></a> or <a href="/docs/agents/python-agent/python-agent-api/data_source_factory"><code>data_source_factory</code></a> decorator assigned.</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>application</code></p>
        <p><em>application object</em></p>
      </div>
      <div>
        <p>Optional. The application object corresponding to the New Relic-monitored account to report data to. If set to the default of <code>None</code>, the data source will be polled at the end of each harvest cycle for each instrumented app. Alternatively, when an application object is supplied, then the data source will only be polled to generate metrics for that one specific application.</p>
        <p>In cases where you need a data source to retain distinct data for each reporting application, you can use a factory pattern to create a separate instance of the data source for each application.</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>name</code></p>
        <p><em>string</em></p>
      </div>
      <div>
        <p>Optional. The name of the data source. This is used only for logging purposes and will default to the name provided by the data source itself.</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>settings</code></p>
        <p><em>string</em></p>
      </div>
      <div>
        <p>Optional. The settings to pass to a data source factory.</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>properties</code></p>
        <p><em>string</em></p>
      </div>
      <div>
        <p>Optional. Any additional properties to pass to the data source factory.</p>
      </div>
    </div>
  </div>
</div>
<h2>Return values</h2>
<p>None.</p>
<h2>Examples</h2>
<h3>Registering a data source [#register-example]</h3>
<p>Here's an example of some app code that generates custom metric data:</p>
<pre><code>@newrelic.agent.data_source_generator(name='External') 
def services(): 
    # code goes here
Â    pass


if __name__ == '__main__': 
    application = nr.configure_newrelic() 
    newrelic.agent.register_data_source(services, application)

    while True: 
        pass
</code></pre>
<h3>Memory usage from data source [#data-source-memory]</h3>
<pre><code>import psutil
import os


@newrelic.agent.data_source_generator(name='Memory Usage')
def memory_metrics():
    pid = os.getpid()
    p = psutil.Process(os.getpid())
    m = p.get_memory_info()
    yield ('Custom/Memory/Physical', float(m.rss) / (1024 * 1024))
    yield ('Custom/Memory/Virtual', float(m.vms) / (1024 * 1024))


newrelic.agent.register_data_source(memory_metrics)
</code></pre>
