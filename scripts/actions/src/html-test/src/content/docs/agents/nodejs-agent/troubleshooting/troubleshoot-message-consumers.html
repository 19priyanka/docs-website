
<h2>Problem</h2>
<p>Message consumer services have a few differences to HTTP servers that make monitoring them more difficult. This document discusses those limitations and ways to work around them with the New Relic Node.js agent.</p>
<p>Because a message does not necessarily have a reply, it can be hard to determine the end of a transaction. If New Relic's Node.js agent cannot determine when a message consumer will be done, it will immediately end the transaction. Follow these troubleshooting tips depending on your application.</p>
<h2>Solution</h2>
<p>The solution to this issue depends on whether you are using callbacks or promises:</p>
<h3>Callbacks</h3>
<p>When using a callback-based messaging API such as <code>amqplib</code>'s <code>callback_api</code>, there is no easy way to determine when your consumer is done. Here is an example.</p>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiY2FsbGJhY2stcHJvYmxlbSJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ0aXRsZSIsInZhbHVlIjoiQ2FsbGJhY2sgcHJvYmxlbSJ9XQ==">
    <div data-prop-text="title">Callback problem</div>
    <p>In this example, all the transactions created for this service will be immediately ended and not show any of the work done by <code>doWorkWithMessage</code>.</p>
    <pre><code>const newrelic = require('newrelic');
const amqp = require('amqplib/callback_api');

// Connect, make a channel, and assert required queues...

channel.consume('my.queue', (msg) => {
  doWorkWithMessage(msg, (err) => {
    if (err) {
      logger.error(err);
      channel.reject(msg, true); // Requeue message on failure.
    }
  });
}, {noAck: true});

</code></pre>In order to properly time the transaction, you need to get the transaction and end it manually, as shown in the following solution.
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiY2FsbGJhY2stc29sdXRpb24ifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6IlNvbHV0aW9uIn1d">
    <div data-prop-text="title">Solution</div>
    <p>To properly time the transaction, get the transaction and end it manually. Modify the consumer to this:</p>
    <pre><code>channel.consume('my.queue', (msg) => {
  var transaction = newrelic.getTransaction();

  doWorkWithMessage(msg, (err) => {
    if (err) {
      logger.error(err);
      channel.reject(msg, true); // Requeue message on failure.
    }

    transaction.end();
  });
}, {noAck: true});

</code></pre>
  </div>
</div>
<h3>Promises</h3>
<p>For promise-based servers, the message consumer simply needs to return a promise. When that promise resolves or rejects, the transaction will be ended. Here is an example:</p>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoicHJvbWlzZS1wcm9ibGVtIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJQcm9taXNlIHByb2JsZW0ifV0=">
    <div data-prop-text="title">Promise problem</div>
    <p>In this example, <code>doWorkWithMessage</code> returns a promise:</p>
    <pre><code>const newrelic = require('newrelic');
const amqp = require('amqplib');

// Connect, make a channel, and assert required queues...

channel.consume('my.queue', (msg) => {
  doWorkWithMessage(msg).catch((err) => {
    if (err) {
      logger.error(err);
      channel.reject(msg, true); // Requeue message on failure.
    }
  });
}, {noAck: true});

</code></pre>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoicHJvbWlzZS1zb2x1dGlvbiJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ0aXRsZSIsInZhbHVlIjoiU29sdXRpb24ifV0=">
    <div data-prop-text="title">Solution</div>
    <p>To get correct timing, return the end of the chain by modifying the code to:</p>
    <pre><code>channel.consume('my.queue', (msg) => {
  return doWorkWithMessage(msg).catch((err) => {
    if (err) {
      logger.error(err);
      channel.reject(msg, true); // Requeue message on failure.
    }
  });
}, {noAck: true});

</code></pre>
  </div>
</div>
