
<p>With New Relic for Go, you can monitor the specific segments of a <a href="/docs/apm/transactions/intro-transactions/transactions-new-relic-apm">transaction</a> in a Go application to get more detail about specific functions or code blocks.</p>
<h2>Measure time for functions and code blocks [#go-segments]</h2>
<p><strong>Segments</strong> are the specific parts of a <a href="/docs/apm/transactions/intro-transactions/transactions-new-relic-apm">transaction</a> in an application. By instrumenting segments, you can measure the time taken by functions and code blocks, such as external calls, datastore calls, adding messages to queues, and background tasks.</p>
<p><strong>Example:</strong> You have a transaction associated with a checkout process, which processes both shipping information and credit card information. You could instrument your application to break that transaction up into two pieces: one segment for shipping and one segment for payment.</p>
<h2>Block-of-code segments [#segment-code-block]</h2>
<p>Once you instrument a <a href="/docs/agents/go-agent/get-started/instrument-go-transactions">transaction</a>, you are ready to instrument one or more segments in that transaction.</p>
<p>To instrument an arbitrary block of code as a segment, use the following pattern, and include <a href="/docs/agents/go-agent/get-started/instrument-go-transactions"><code>txn</code></a> as the variable name set for the transaction:</p>
<pre><code>segment := newrelic.Segment{}
segment.Name = "mySegmentName"
segment.StartTime = txn.StartSegmentNow()
// ... code you want to time here ...
segment.End()
</code></pre>
<p><code>StartSegment</code> is a convenient helper. It creates a segment and starts it:</p>
<pre><code>segment := txn.StartSegment("mySegmentName")
// ... code you want to time here ...
segment.End()
</code></pre>
<h2>Function segments [#segment-function]</h2>
<p>Instrumenting a function as a segment is essentially the same as instrumenting an arbitrary block of code as a segment. The main difference is that, because a function has a discrete ending, you can use Go's <a href="https://gobyexample.com/defer">defer statement</a>.</p>
<p>To instrument a function as a segment, add the following code at the start of the function, and include <a href="/docs/agents/go-agent/get-started/instrument-go-transactions"><code>txn</code></a> as the variable name set for the transaction:</p>
<pre><code>defer txn.StartSegment("mySegmentName").End()
</code></pre>
<h2>Nest segments [#go-nesting-segments]</h2>
<p>Segments can be nested. The segment being ended must be the most recently started segment.</p>
<p>Here's an example of a segment starting and ending inside another segment:</p>
<pre><code>s1 := txn.StartSegment("outerSegment")
s2 := txn.StartSegment("innerSegment")
// s2 must end before s1
s2.End()
s1.End()
</code></pre>
<p>A zero value segment may safely be ended. Therefore, the following code is safe even if the conditional fails:</p>
<pre><code>var s newrelic.Segment
if recordSegment {
    s.StartTime = txn.StartSegmentNow(),
}
// ... code you wish to time here ...
s.End()
</code></pre>
<h2>Datastore segments [#go-datastore-segments]</h2>
<p>You can instrument Go application datastore calls. Datastore segments appear in the APM <strong>Transactions breakdown</strong> table and <strong>Databases</strong> tab of the <a href="/docs/apm/applications-menu/monitoring/transactions-page"><strong>Transactions</strong> page</a> in New Relic.</p>
<p>If you are using a MySQL, PostgreSQL, or SQLite database driver, the easiest way to add Datastore segments is to use our pre-built integration packages. Otherwise, you can manually create Datastore segments for each database call.</p>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiaW5zdHJ1bWVudGF0aW9uLXBrZyJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ0aXRsZSIsInZhbHVlIjoiVXNlIGluc3RydW1lbnRhdGlvbiBwYWNrYWdlIn1d">
    <div data-prop-text="title">Use instrumentation package</div>
    <p>There is an integration package for each database driver that we support:</p>
    <div data-component="Table" data-prop="W10=">
      <div>
        <div>
          <div>
            <p>Database library supported</p>
          </div>
          <div>
            <p>Integration package</p>
          </div>
        </div>
      </div>
      <div>
        <div>
          <div>
            <p><a href="https://github.com/go-sql-driver/mysql">go-sql-driver/mysql</a></p>
          </div>
          <div>
            <p><a href="https://godoc.org/github.com/newrelic/go-agent/v3/integrations/nrmysql">v3/integrations/nrmysql</a></p>
          </div>
        </div>
        <div>
          <div>
            <p><a href="https://github.com/lib/pq">lib/pq</a></p>
          </div>
          <div>
            <p><a href="https://godoc.org/github.com/newrelic/go-agent/v3/integrations/nrpq">v3/integrations/nrpq</a></p>
          </div>
        </div>
        <div>
          <div>
            <p><a href="https://github.com/mattn/go-sqlite3">mattn/go-sqlite3</a></p>
          </div>
          <div>
            <p><a href="https://godoc.org/github.com/newrelic/go-agent/v3/integrations/nrsqlite3">v3/integrations/nrsqlite3</a></p>
          </div>
        </div>
      </div>
    </div>
    <p>To use one of these integrations, first replace the driver with our integration version:</p>
    <pre><code>import (
	// import our integration package in place of "github.com/go-sql-driver/mysql"
	_ "github.com/newrelic/go-agent/v3/integrations/nrmysql"
)

func main() {
	// open "nrmysql" in place of "mysql"
	db, err := sql.Open("nrmysql", "user@unix(/path/to/socket)/dbname")
}

</code></pre>If you are using a [database/sql](https://golang.org/pkg/database/sql/) database not listed above, you can write your own instrumentation for it using [InstrumentConnector](https://godoc.org/github.com/newrelic/go-agent/v3/newrelic#InstrumentConnector), [InstrumentDriver](https://godoc.org/github.com/newrelic/go-agent/v3/newrelic#InstrumentDriver), and [DriverSegmentBuilder](https://godoc.org/github.com/newrelic/go-agent/v3/newrelic#DriverSegmentBuilder). The integration packages act as examples of how to do this.
    &#x3C;Callout variant="important">
    Datastore integration packages for MySQL, PostgreSQL, and SQLite were added in Go Agent v2.8.0 and require Go v1.10 or above.
    &#x3C;/Callout>
    <pre><code>
ctx := newrelic.NewContext(context.Background(), txn)
row := db.QueryRowContext(ctx, "SELECT count(*) from tables")

</code></pre>Second, use the `ExecContext`, `QueryContext`, and `QueryRowContext` methods of [sql.DB](https://golang.org/pkg/database/sql/#DB), [sql.Conn](https://golang.org/pkg/database/sql/#Conn), [sql.Tx](https://golang.org/pkg/database/sql/#Tx), and [sql.Stmt](https://golang.org/pkg/database/sql/#Stmt) and provide a transaction-containing context. Calls to `Exec`, `Query`, and `QueryRow` do not get instrumented.
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOnsidHlwZSI6Im1keFZhbHVlRXhwcmVzc2lvbiIsInZhbHVlIjoiPD5Vc2UgPElubGluZUNvZGU+RGF0YXN0b3JlU2VnbWVudDwvSW5saW5lQ29kZT48Lz4iLCJwb3NpdGlvbiI6eyJzdGFydCI6eyJsaW5lIjoxNjgsImNvbHVtbiI6MTEsIm9mZnNldCI6NjU5Mn0sImVuZCI6eyJsaW5lIjoxNjgsImNvbHVtbiI6NjMsIm9mZnNldCI6NjY0NH19fX1d">
    <div data-prop-text="title">[object Object]</div>
    <p>Just like basic segments, datastore segments begin when the <code>StartTime</code> field is populated and finish when the <code>End</code> method is called. To instrument a datastore segment, place the following at the beginning of the function you want to monitor:</p>
    <pre><code>s := newrelic.DatastoreSegment{
    Product: newrelic.DatastoreMySQL,
    Collection: "users",
    Operation: "INSERT",
    ParameterizedQuery: "INSERT INTO users (name, age) VALUES ($1, $2)",
    QueryParameters: map[string]interface{}{
        "name": "Dracula",
        "age": 439,
    },
    Host: "mysql-server-1",
    PortPathOrID: "3306",
    DatabaseName: "my_database",
}
s.StartTime = txn.StartSegmentNow()
// ... make the datastore call
s.End()

</code></pre>
    <pre><code>
s := newrelic.DatastoreSegment{
    StartTime: txn.StartSegmentNow(),
    Product: newrelic.DatastoreMySQL,
    Collection: "users",
    Operation: "INSERT",
    ParameterizedQuery: "INSERT INTO users (name, age) VALUES ($1, $2)",
    QueryParameters: map[string]interface{}{
        "name": "Dracula",
        "age": 439,
    },
    Host: "mysql-server-1",
    PortPathOrID: "3306",
    DatabaseName: "my_database",
}
defer s.End()

</code></pre>For more information about:
    * Assigning the `Collection`, `Operation`, `DatabaseName`, and other parameter values: See the [New Relic datastore segment documentation on GoDoc](https://godoc.org/github.com/newrelic/go-agent#DatastoreSegment).
    * Available values for `Product`: See the [New Relic documentation on GitHub](https://github.com/newrelic/go-agent/blob/master/datastore.go).
    When instrumenting a datastore call that spans an entire function call, you can use the defer statement to simplify instrumentation:
  </div>
</div>
<h2>External segments [#go-external-segments]</h2>
<p>You can instrument Go application calls to external services, such as web services, resources in the cloud, and any other network calls. External segments appear in the APM <strong>Transactions breakdown</strong> table and the <a href="/docs/apm/applications-menu/monitoring/external-services-page"><strong>External services</strong> page</a> in New Relic.</p>
<p>There are two ways to instrument external segments:</p>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoic3RhcnQtZXh0ZXJuYWwtc2VnbWVudCJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ0aXRsZSIsInZhbHVlIjp7InR5cGUiOiJtZHhWYWx1ZUV4cHJlc3Npb24iLCJ2YWx1ZSI6Ijw+VXNlIDxJbmxpbmVDb2RlPlN0YXJ0RXh0ZXJuYWxTZWdtZW50KCk8L0lubGluZUNvZGU+PC8+IiwicG9zaXRpb24iOnsic3RhcnQiOnsibGluZSI6MjI3LCJjb2x1bW4iOjExLCJvZmZzZXQiOjkwMDZ9LCJlbmQiOnsibGluZSI6MjI3LCJjb2x1bW4iOjY5LCJvZmZzZXQiOjkwNjR9fX19XQ==">
    <div data-prop-text="title">[object Object]</div>
    <p><strong>Recommendation:</strong> Use the <code>StartExternalSegment</code> helper, since New Relic uses it to trace activity between your applications using <a href="/docs/agents/go-agent/features/cross-application-tracing-go">cross application tracing</a>.</p>
    <pre><code>func external(txn *newrelic.Transaction, req *http.Request) (*http.Response, error) {
    s := newrelic.StartExternalSegment(txn, req)
    response, err := http.DefaultClient.Do(req)
    s.Response = response
    s.End()
    return response, err
}

</code></pre>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoibmV3LXJvdW5kLXRyaXBwZXIifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6eyJ0eXBlIjoibWR4VmFsdWVFeHByZXNzaW9uIiwidmFsdWUiOiI8PlVzZSA8SW5saW5lQ29kZT5OZXdSb3VuZFRyaXBwZXIoKTwvSW5saW5lQ29kZT48Lz4iLCJwb3NpdGlvbiI6eyJzdGFydCI6eyJsaW5lIjoyNDQsImNvbHVtbiI6MTEsIm9mZnNldCI6OTY1NX0sImVuZCI6eyJsaW5lIjoyNDQsImNvbHVtbiI6NjQsIm9mZnNldCI6OTcwOH19fX1d">
    <div data-prop-text="title">[object Object]</div>
    <p><code>NewRoundTripper</code> returns an <a href="https://golang.org/pkg/net/http/#RoundTripper">http.RoundTripper</a>, which allows you to instrument external calls without calling <code>StartExternalSegment</code> by modifying your <code>http.Client</code>'s <code>Transport</code> field. The <code>RoundTripper</code> returned will look for a <code>Transaction</code> in the request's context using <a href="https://godoc.org/github.com/newrelic/go-agent#FromContext">FromContext</a>.</p>
    <p>Here is an example of <code>NewRoundTripper</code> instrumentation:</p>
    <pre><code>client := &#x26;http.Client{}
client.Transport = newrelic.NewRoundTripper(client.Transport)

request, _ := http.NewRequest("GET", "http://example.com", nil)
request = newrelic.RequestWithTransactionContext(request, txn)

response, err := client.Do(request)

</code></pre>
  </div>
</div>
<h2>Message producer segments [#go-message-producer-segments]</h2>
<p>You can instrument Go application calls that add messages to queuing systems like RabbitMQ and Kafka. Message producer segments appear in the APM <strong>Transactions breakdown</strong> in New Relic.</p>
<p>There is only one way to instrument message producer segments:</p>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoic3RhcnQtZXh0ZXJuYWwtc2VnbWVudCJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ0aXRsZSIsInZhbHVlIjp7InR5cGUiOiJtZHhWYWx1ZUV4cHJlc3Npb24iLCJ2YWx1ZSI6Ijw+VXNlIDxJbmxpbmVDb2RlPk1lc3NhZ2VQcm9kdWNlclNlZ21lbnQ8L0lubGluZUNvZGU+PC8+IiwicG9zaXRpb24iOnsic3RhcnQiOnsibGluZSI6MjcxLCJjb2x1bW4iOjExLCJvZmZzZXQiOjEwODg3fSwiZW5kIjp7ImxpbmUiOjI3MSwiY29sdW1uIjo2OSwib2Zmc2V0IjoxMDk0NX19fX1d">
    <div data-prop-text="title">[object Object]</div>
    <p>Just like basic segments, message producer segments begin when the <code>StartTime</code> field is populated, and finish when the <code>End</code> method is called. To instrument a message producer segment, place the following at the beginning of the function you want to monitor:</p>
    <pre><code>s := newrelic.MessageProducerSegment{
    Library:              "RabbitMQ",
    DestinationType:      newrelic.MessageExchange,
    DestinationName:      "myExchange",
    DestinationTemporary: false,
}
s.StartTime = txn.StartSegmentNow()
// ... add message to queue
s.End()

</code></pre>&#x3C;Callout variant="important">
    Message producer segments were added in Go Agent version 2.14.0.
    &#x3C;/Callout>
    <pre><code>
s := newrelic.MessageProducerSegment{
    StartTime:            txn.StartSegmentNow(),
    Library:              "RabbitMQ",
    DestinationType:      newrelic.MessageExchange,
    DestinationName:      "myExchange",
    DestinationTemporary: false,
}
defer s.End()
// ... add message to queue

</code></pre>For more information about assigning the `Library`, `DestinationType`, `DestinationName`, or `DestinationTemporary` fields, see the [New Relic message producer segment documentation on GoDoc](https://godoc.org/github.com/newrelic/go-agent#MessageProducerSegment).
    When instrumenting a message producer call that spans an entire function call, you can use the defer statement to simplify instrumentation:
  </div>
</div>
