
<h2>Syntax</h2>
<pre><code>newrelic_record_datastore_segment(callable $func, array $parameters)
</code></pre>
<p>Records a datastore segment.</p>
<h2>Requirements</h2>
<p>Agent version <a href="/docs/release-notes/agent-release-notes/php-release-notes/php-agent-750199">7.5.0.199</a> or higher.</p>
<h2>Description</h2>
<p>Records a datastore segment. Datastore segments appear in the <strong>Breakdown table</strong> and <strong>Databases</strong> tab of the <a href="https://docs.newrelic.com/docs/apm/applications-menu/monitoring/transactions-page">Transactions page</a> in the New Relic UI.</p>
<p>This function allows an unsupported datastore to be instrumented in the same way as the PHP agent automatically instruments its <a href="https://docs.newrelic.com/docs/agents/php-agent/getting-started/php-agent-compatibility-requirements#databases">supported datastores</a>.</p>
<h2>Parameters</h2>
<div data-component="Table" data-prop="W10=">
  <div>
    <div>
      <div>
        <p>Parameter</p>
      </div>
      <div>
        <p>Description</p>
      </div>
    </div>
  </div>
  <div>
    <div>
      <div>
        <p><code>$callback</code></p>
        <p><em>callable</em></p>
      </div>
      <div>
        <p>Required. The function that should be timed to create the datastore segment.</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>$parameters</code></p>
        <p><em>array</em></p>
      </div>
      <div>
        <p>Required. An associative array of parameters describing the datastore call.</p>
      </div>
    </div>
  </div>
</div>
<p>The supported keys in the <code>$parameters</code> array are as follows:</p>
<div data-component="Table" data-prop="W10=">
  <div>
    <div>
      <div>
        <p>Key</p>
      </div>
      <div>
        <p>Description</p>
      </div>
    </div>
  </div>
  <div>
    <div>
      <div>
        <p><code>product</code></p>
        <p><em>string</em></p>
      </div>
      <div>
        <p>Required. The name of the datastore product being used: for example, <code>MySQL</code> to indicate that the segment represents a query against a MySQL database.</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>collection</code></p>
        <p><em>string</em></p>
      </div>
      <div>
        <p>Optional. The table or collection being used or queried against.</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>operation</code></p>
        <p><em>string</em></p>
      </div>
      <div>
        <p>Optional. The operation being performed: for example, <code>select</code> for an SQL SELECT query, or <code>set</code> for a Memcached set operation.</p>
        <p>While operations may be specified with any case, New Relic suggests using lowercase to better line up with the operation names used by the PHP agent's automated datastore instrumentation.</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>host</code></p>
        <p><em>string</em></p>
      </div>
      <div>
        <p>Optional. The datastore host name.</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>portPathOrId</code></p>
        <p><em>string</em></p>
      </div>
      <div>
        <p>Optional. The port or socket used to connect to the datastore.</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>databaseName</code></p>
        <p><em>string</em></p>
      </div>
      <div>
        <p>Optional. The database name or number in use.</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>query</code></p>
        <p><em>string</em></p>
      </div>
      <div>
        <p>Optional. The query that was sent to the server.</p>
        <p>For security reasons, this value is only used if you set <code>product</code> to a supported datastore. This allows the agent to correctly obfuscate the query. The supported product values (which are matched in a case insensitive manner) are: <code>MySQL</code>, <code>MSSQL</code>, <code>Oracle</code>, <code>Postgres</code>, <code>SQLite</code>, <code>Firebird</code>, <code>Sybase</code>, and <code>Informix</code>.</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>inputQueryLabel</code></p>
        <p><em>string</em></p>
      </div>
      <div>
        <p>Optional. The name of the ORM in use (for example: <code>Doctrine</code>).</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>inputQuery</code></p>
        <p><em>string</em></p>
      </div>
      <div>
        <p>Optional. The input query that was provided to the ORM.</p>
        <p>For security reasons, and as with the <code>query</code> parameter, this value will be ignored if the product is not a supported datastore.</p>
      </div>
    </div>
  </div>
</div>
<h2>Return values</h2>
<p>The return value of <code>$callback</code> is returned. If an error occurs, <code>false</code> is returned, and an error at the <code>E_WARNING</code> level will be triggered.</p>
<h2>Examples</h2>
<h3>Instrumenting an unsupported NoSQL datastore [#unsupported-nosql]</h3>
<p>To instrument a hypothetical NoSQL datastore called <code>Bucket</code> that exposes a <code>get</code> method, the following code would create a datastore metric that would show up in the New Relic UI:</p>
<pre><code>$bucket = new Bucket($host, $port);
$id = 12345;

$value = newrelic_record_datastore_segment(function () use ($bucket, $id) {
    return $bucket->get($id);
}, array(
    'product'      => 'Bucket',
    'collection'   => $id,
    'operation'    => 'get',
    'host'         => $host,
    'portPathOrId' => $port,
));
</code></pre>
<h3>Instrumenting an unsupported SQL client library [#unspported-sql]</h3>
<p>To record a query for an unsupported MySQL client library with the query obfuscated and attached to the segment:</p>
<pre><code>$sql = 'SELECT * FROM table';
$stmt = $db->prepare($sql);

$result = newrelic_record_datastore_segment(function () use ($stmt) {
    return $stmt->execute();
}, array(
    'product'      => 'MySQL',
    'collection'   => 'table',
    'operation'    => 'select',
    'host'         => $host,
    'portPathOrId' => $port,
    'databaseName' => 'dbname',
    'query'        => $query,
));
</code></pre>
