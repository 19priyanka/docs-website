
<p>This document details how to instrument third-party gems with the Ruby agent, as well as some best practices for interacting with the agent. This is useful if you are using a gem that the Ruby agent does not instrument by default, or if you are a gem author who wants to add instrumentation for your library.</p>
<h2>Contents [#qiklinks]</h2>
<h2>Finding third-party extensions</h2>
<p>Anyone can write a gem that builds on top of the Ruby agent. New Relic maintains a repository called <a href="https://github.com/newrelic/extends_newrelic_rpm">extends_newrelic_rpm</a> to track these extensions and to provide links to other gems that build the Ruby agent.</p>
<p>These extensions are <strong>not</strong> supported by New Relic. New Relic gathers these links as a service to our customers. Issues with those gems should be reported to the respective projects on GitHub.</p>
<h2>Extensions as gems</h2>
<p>New Relic encourages third-party extensions to be maintained as gems, with one gem per instrumented library. For example, <code>newrelic-redis</code> provides instrumentation for the <code>redis</code> gem.</p>
<h2>Starting transactions</h2>
<p>If your library provides code which should be represented as a full transaction in New Relic (for example: a web request or background job that isn't instrumented by the Ruby agent), then use one of these mechanisms for starting a transaction.</p>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiYWRkX3RyYW5zYWN0aW9uX3RyYWNlciJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ0aXRsZSIsInZhbHVlIjoiYWRkX3RyYW5zYWN0aW9uX3RyYWNlciJ9XQ==">
    <div data-prop-text="title">add_transaction_tracer</div>
    <p>The simplest way to get a transaction started is to call <code>add_transaction_tracer</code> on the method. This assumes that <code>NewRelic::Agent::Instrumentation::ControllerInstrumentation</code> is included in your class.</p>
    <pre><code class="language-ruby">class CustomBackgroundJob
  include NewRelic::Agent::Instrumentation::ControllerInstrumentation

  def transaction
    # execute a transaction
  end

  add_transaction_tracer :transaction
end

</code></pre>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoicGVyZm9ybV9hY3Rpb25fd2l0aF9uZXdyZWxpY190cmFjZSJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ0aXRsZSIsInZhbHVlIjoicGVyZm9ybV9hY3Rpb25fd2l0aF9uZXdyZWxpY190cmFjZSJ9XQ==">
    <div data-prop-text="title">perform_action_with_newrelic_trace</div>
    <p>Sometimes you need slightly more control over the transaction that New Relic generates. When that happens, you can use <code>perform_action_with_newrelic_trace</code>. Some of the parameters you can override include the transaction name and category (whether it's a web transaction or a background transaction).</p>
    <pre><code class="language-ruby">class CustomBackgroundJob
  include NewRelic::Agent::Instrumentation::ControllerInstrumentation

  def transaction
   perform_action_with_newrelic_trace(:name    => "custom_name",
                                     :category => :task) do
     # your work here...
   end  
  end

end

</code></pre>See the [full documentation of perform_action_with_newrelic_trace](http://www.rubydoc.info/github/newrelic/rpm/master/NewRelic/Agent/Instrumentation/ControllerInstrumentation#perform_action_with_newrelic_trace-instance_method) for further information on parameters and usage.
  </div>
</div>
<h2>Nodes in transaction traces [#nodes-transaction-traces]</h2>
<p>You may want to add timing information to New Relic about calls to a method, but it does not represent a full transaction. New Relic recommends adding a method tracer to accomplish this.</p>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiYWRkX21ldGhvZF90cmFjZXIifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6ImFkZF9tZXRob2RfdHJhY2VyIn1d">
    <div data-prop-text="title">add_method_tracer</div>
    <pre><code class="language-ruby">require 'new_relic/agent/method_tracer'
class Foo
  include ::NewRelic::Agent::MethodTracer

  def generate_image
    # ...
  end

  add_method_tracer :generate_image, 'Custom/generate_image'
end

</code></pre>The above example results in metrics being recorded for the name `'Custom/generate_image'`, as well as an entry in transaction traces that includes the method call.
  </div>
</div>
<h2>Custom Datastores</h2>
<p>The Ruby agent provides special functionality for recording calls to Datastores. These are intended to support both SQL and NoSQL databases, and provide a consistent interface for use by third-party gems.</p>
<p>Metrics recorded via the <code>NewRelic::Agent::Datastores</code> module functions will show up in the <a href="/docs/apm/applications-menu/monitoring/databases-slow-queries-dashboard">Databases UI in New Relic</a>.</p>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoidHJhY2UifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6Ik5ld1JlbGljOjpBZ2VudDo6RGF0YXN0b3Jlcy50cmFjZSJ9XQ==">
    <div data-prop-text="title">NewRelic::Agent::Datastores.trace</div>
    <p><code>trace</code> is the simplest way to record Datastore for a method.</p>
    <pre><code class="language-ruby">class FauxDB

 def find
   # FauxDB lookup
 end

 NewRelic::Agent::Datastores.trace self, :find, "FauxDB"

end

</code></pre>The first parameter is the class to instrument, the second the method to find, the third the datastore product name. An optional operation name can be included as the final parameter, otherwise the method name is used to represent the operation in metrics.
    Note that Datastore metrics recorded with this interface do not allow for adding a collection/table name. For that, see the `wrap` method below.
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoid3JhcCJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ0aXRsZSIsInZhbHVlIjoiTmV3UmVsaWM6OkFnZW50OjpEYXRhc3RvcmVzLndyYXAifV0=">
    <div data-prop-text="title">NewRelic::Agent::Datastores.wrap</div>
    <p><code>wrap</code> allows for recording Datastore metrics with additional collection/table information in the metric names. It also provides a callback for operations such as noticing slow statements.</p>
    <pre><code class="language-ruby">class FauxDB

  def find(table)
    NewRelic::Agent::Datastores.wrap("FauxDB", "find", table) do
    # FauxDB lookup
    end
  end

end

</code></pre>
    <pre><code>ruby
class FauxDB

 def find(query)
   callback = Proc.new do |result, scoped_metric, elapsed|
     NewRelic::Agent::Datastores.notice_sql(query, scoped_metric, elapsed)
   end

   NewRelic::Agent::Datastores.wrap("FauxDB", "find", "items", callback) do
     # execute query
   end
 end

end

</code></pre>If you want to record additional information about your datastore call, you can use the optional callback parameter on `wrap`:
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoibm90aWNlX3NxbCJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ0aXRsZSIsInZhbHVlIjoiTmV3UmVsaWM6OkFnZW50OjpEYXRhc3RvcmVzLm5vdGljZV9zcWwifV0=">
    <div data-prop-text="title">NewRelic::Agent::Datastores.notice_sql</div>
    <p>This helper method records slow SQL queries for presentation in transaction traces and slow SQL pages. SQL is filtered and obfuscated based on the user's settings.</p>
    <pre><code class="language-ruby">NewRelic::Agent::Datastores.notice_sql(query, scoped_metric, elapsed)

</code></pre>Non-SQL queries should never be sent through `notice_sql`.Use `notice_statement` instead.
    &#x3C;Callout variant="caution">
    New Relic's Transaction Tracing and Slow SQL features will attempt to apply obfuscation to the passed queries, but it is possible for a query format to be unsupported and result in exposing user information embedded within captured queries.
    &#x3C;/Callout>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoibm90aWNlX3N0YXRlbWVudCJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ0aXRsZSIsInZhbHVlIjoiTmV3UmVsaWM6OkFnZW50OjpEYXRhc3RvcmVzLm5vdGljZV9zdGF0ZW1lbnQifV0=">
    <div data-prop-text="title">NewRelic::Agent::Datastores.notice_statement</div>
    <p>This helper method records statements for slow datastore calls to transaction traces. These are <strong>not</strong> obfuscated.</p>
    <pre><code class="language-ruby">NewRelic::Agent::Datastores.notice_statement(statement, elapsed)

</code></pre>SQL queries should never be sent through `notice_statement`. Use `notice_sql` instead.
    &#x3C;Callout variant="caution">
    This method will properly ignore statements when the user has turned off capturing queries, but it is not able to obfuscate arbitrary data! Ensure all data passed to this method is safe to transmit to New Relic in order to prevent exposing user information embedded in captured queries.
    &#x3C;/Callout>
  </div>
</div>
<h2>Testing your extension</h2>
<p>You can write automated tests when you author a gem that extends New Relic. The test helpers used by the agent itself are available to simplify some common testing tasks.</p>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoicmVxdWlyZV90ZXN0X2hlbHBlciJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ0aXRsZSIsInZhbHVlIjoiTmV3UmVsaWM6OkFnZW50LnJlcXVpcmVfdGVzdF9oZWxwZXIifV0=">
    <div data-prop-text="title">NewRelic::Agent.require_test_helper</div>
    <p>The test methods documented in this section can be accessed by calling this from your test code (most commonly a <code>test_helper.rb</code> file)</p>
    <pre><code class="language-ruby">NewRelic::Agent.require_test_helper

</code></pre>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiYXNzZXJ0X21ldHJpY3NfcmVjb3JkZWQifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6ImFzc2VydF9tZXRyaWNzX3JlY29yZGVkIn1d">
    <div data-prop-text="title">assert_metrics_recorded</div>
    <p>This method is the primary way to ensure your expected metrics are recorded by the Ruby agent. <code>refute_metrics_recorded</code> is also available.</p>
    <p>In the simplest form, <code>assert_metrics_recorded</code> can be called like this:</p>
    <pre><code class="language-ruby">assert_metrics_recorded(["MetricA", "MetricB"])

</code></pre>
    <pre><code>ruby
assert_metrics_recorded('MetricA' => {
                         :call_count => 1,
                         :total_call_time => 1.0 })

</code></pre>Metrics with specific values can be asserted via this syntax:
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiaW5fd2ViX3RyYW5zYWN0aW9uIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJpbl93ZWJfdHJhbnNhY3Rpb24vaW5fYmFja2dyb3VuZF90cmFuc2FjdGlvbiJ9XQ==">
    <div data-prop-text="title">in_web_transaction/in_background_transaction</div>
    <p>These methods simulate running in web or background transaction.</p>
    <pre><code class="language-ruby">in_web_transaction do
  # Perform work to test behavior in transaction
end

</code></pre>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoid2l0aF9jb25maWcifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6IndpdGhfY29uZmlnIn1d">
    <div data-prop-text="title">with_config</div>
    <p>Configuration of the agent can be changed for testing via <code>with_config</code>. It takes a hash which is applied to the other configuration values in agent.</p>
    <pre><code class="language-ruby">with_config(:enabled => false) do
  # Check what happens when agent's disabled
end

</code></pre>&#x3C;Callout variant="tip">
    This method doesn't help for testing installation of instrumentation, as those config values are typically checked when instrumentation happens on `require`, and isn't influenced by the setting change in a test.
    &#x3C;/Callout>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoibXVsdGl2ZXJzZSJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ0aXRsZSIsInZhbHVlIjoiTXVsdGl2ZXJzZTogVGVzdCBhZ2FpbnN0IG11bHRpcGxlIGdlbSB2ZXJzaW9ucyJ9XQ==">
    <div data-prop-text="title">Multiverse: Test against multiple gem versions</div>
    <p>If you need to test your extension against multiple gem versions, you can use Multiverse, a part of the Ruby agent's own testing code. For examples of Multiverse testing, see the <a href="https://github.com/newrelic/rpm/tree/master/test/multiverse/suites">suites directory in the agent files</a>.</p>
    <p>To configure Multiverse for your own gem:</p>
    <ol>
      <li>
        <p><strong>Require <code>tasks/multiverse</code> in Rakefile</strong>. To enable the <code>rake test:multiverse</code> command, add the following to your Rakefile:</p>
        <pre><code>require "tasks/multiverse"
</code></pre>
      </li>
      <li>
        <p><strong>Create the Multiverse test directory</strong>. Multiverse tests require a specific file layout. Create a directory named <code>test/multiverse/YOUR_PROJECT</code> with the following file locations:</p>
        <pre><code>test/multiverse/YOUR_PROJECT
test/multiverse/YOUR_PROJECT/Envfile
test/multiverse/YOUR_PROJECT/config/newrelic.yml
test/multiverse/YOUR_PROJECT/FILE_WITH_A_TEST.rb
</code></pre>
      </li>
      <li>
        <p><strong>Configure your Envfile</strong>. Use the <strong>Envfile</strong> to declare sets of gem dependencies for your Multiverse tests. For example, your <strong>Envfile</strong> might look like this:</p>
        <pre><code>gemfile &#x3C;-RB
  gem 'your-project', '~> 1.0.0'
  gem 'rack'
  gem 'newrelic_rpm'
  gem 'newrelic_your-project', path: '../../..'
RB

gemfile &#x3C;-RB
  gem 'your-project', '~> 2.1.0'
  gem 'rack'
  gem 'newrelic_rpm'
  gem 'newrelic_your-project', path: '../../..'
RB
</code></pre>
        <div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJ0aXAifV0=">
          <p>Include the <code>gem</code> lines for <code>newrelic_rpm</code> and <code>rack</code> to ensure your Multiverse tests work.</p>
        </div>
      </li>
      <li>
        <p><strong>Detect dependencies</strong>. If necessary, ensure your extension's instrumentation is loaded by running an additional dependency detection from your Multiverse tests:</p>
        <pre><code>require 'newrelic/your-project'

DependencyDetection.detect!

class YourProjectTest > Minitest::Test
end
</code></pre>
        <p>To run your Multiverse tests against the gem dependencies in your <strong>Envfile</strong>:</p>
      </li>
    </ol>
    <ul>
      <li>After setting up Multiverse for your gem, run <code>rake test:multiverse</code> to execute the tests in your directory.</li>
    </ul>
  </div>
</div>
