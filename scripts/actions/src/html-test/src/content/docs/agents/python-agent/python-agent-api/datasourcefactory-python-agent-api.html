
<h2>Syntax</h2>
<pre><code>data_source_factory(name=None, **properties)
</code></pre>
<p>Wraps a data source defined as a factory.</p>
<h2>Description</h2>
<p>The data source APIs provide a way to generate <a href="/docs/data-analysis/metrics/analyze-your-metrics/data-collection-metric-timeslice-event-data#timeslice-data">metric timeslice data</a> using a <a href="/docs/agents/python-agent/supported-features/python-custom-metrics#push-versus-pull-interfaces">pull-style API</a> rather than the push-style API implemented by <code>record_custom_metric</code>. For more about why and how to use data sources for custom metrics, see <a href="/docs/agents/python-agent/supported-features/python-custom-metrics#custom-metric-data-sources">Custom metric data sources</a>.</p>
<p>The <code>data_source_factory</code> decorator wraps a data source defined as a factory. The decorator can be applied to a class or a function. The class constructor or function must accept arguments of <code>settings</code> (configuration settings for the data source) and <code>environ</code> (information about context in which the data source is being used).</p>
<p>The resulting object must be a callable which directly returns an iterable/generator with the metrics for each sample.</p>
<h2>Parameters</h2>
<div data-component="Table" data-prop="W10=">
  <div>
    <div>
      <div>
        <p>Parameter</p>
      </div>
      <div>
        <p>Description</p>
      </div>
    </div>
  </div>
  <div>
    <div>
      <div>
        <p><code>name</code></p>
        <p><em>string</em></p>
      </div>
      <div>
        <p>Optional. The name of the data source. This is used only for logging purposes. If not provided, it defaults to the callable name derived from the decorated function.</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>properties</code></p>
        <p><em>dictionary</em></p>
      </div>
      <div>
        <p>Optional. Any additional properties to pass to the data source factory.</p>
        <p>The possible fields for a dictionary are:</p>
        <ul>
          <li>
            <p><code>count</code></p>
          </li>
          <li>
            <p><code>total</code></p>
          </li>
          <li>
            <p><code>min</code></p>
          </li>
          <li>
            <p><code>max</code></p>
          </li>
          <li>
            <p><code>sum_of_squares</code></p>
            <p>For explanations of these fields and some general usage tips, see the <a href="https://docs.newrelic.com/docs/plugins/plugin-developer-resources/developer-reference/metric-value-reference">documentation for the our Plugins custom metrics API</a>.</p>
          </li>
        </ul>
      </div>
    </div>
  </div>
</div>
<h2>Return values</h2>
<p>Returns a function.</p>
<h2>Examples</h2>
<h3>data_source_factory example [#example]</h3>
<p>An example:</p>
<pre><code>import os
import time
import multiprocessing

@newrelic.agent.data_source_factory(name='CPU Usage')
class CPUMetricsDataSource(object):

    def __init__(self, settings, environ):
        self.last_timestamp = None
        self.times = None
 
    def start(self):
        self.last_timestamp = time.time()
        self.times = os.times()
 
    def stop(self):
        self.last_timestamp = None
        self.times = None

    def __call__(self):
        if self.times is None:
            return

        now = time.time()
        new_times = os.times()
        elapsed_time = now - self.last_timestamp
        user_time = new_times[0] - self.times[0]
        utilization = user_time / (elapsed_time*multiprocessing.cpu_count())
        self.last_timestamp = now
        self.times = new_times

        yield ('Custom/CPU/User Time', user_time)
        yield ('Custom/CPU/User/Utilization', utilization)

newrelic.agent.register_data_source(CPUMetricsDataSource)
</code></pre>
