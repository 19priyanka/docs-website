
<p>With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster.</p>
<h2>Find performance bottlenecks [#feature]</h2>
<p>Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following:</p>
<ul>
  <li>Where you’re wasting resources</li>
  <li>When an incident occurs</li>
  <li>What happened during an incident</li>
  <li>What performance issues led up to an incident</li>
</ul>
<p>To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time.</p>
<h2>JFR daemon [#about]</h2>
<p>The New Relic <a href="https://github.com/newrelic/newrelic-jfr-core">JFR daemon</a> runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic <a href="https://github.com/newrelic/newrelic-telemetry-sdk-java">Java telemetry SDK</a> as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs.</p>
<p>On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent.</p>
<ul>
  <li>If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity.</li>
  <li>If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it.</li>
</ul>
<h2>Requirements</h2>
<p>Requirements include:</p>
<ul>
  <li>The JFR daemon must be run with Java 11 or higher.</li>
  <li>The application being monitored by the daemon must use a version of Java that supports Java Flight Recorder: Java 8 (specifically, version <code>8u262</code>+) or higher.</li>
  <li>An <a href="/docs/insights/insights-data-sources/custom-data/introduction-event-api#register">Insights insert API key</a>.</li>
  <li><a href="https://oss.sonatype.org/content/groups/public/com/newrelic/jfr-daemon/">JFR daemon jar</a>.</li>
  <li>Required for <a href="#flamegraph">flamegraphs</a>, otherwise optional but recommended: Install of New Relic <a href="/docs/agents/java-agent">Java agent</a> version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application.</li>
</ul>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJpbXBvcnRhbnQifV0=">
  <p>Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory.</p>
</div>
<h2>Installation</h2>
<p>To monitor an application with the JFR daemon you must first expose a remote JMX port on the application that you wish to monitor by adding the following system properties:</p>
<pre><code>-Dcom.sun.management.jmxremote
-Dcom.sun.management.jmxremote.port=1099
-Dcom.sun.management.jmxremote.ssl=false
-Dcom.sun.management.jmxremote.authenticate=false
</code></pre>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJ0aXAifV0=">
  <p>By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. To change this behavior, see the <a href="https://github.com/newrelic/newrelic-jfr-core#how-to-use">fully documented configuration options</a>.</p>
</div>
<p>To use the JFR daemon:</p>
<ol>
  <li>
    <p>Download the latest version of the JFR daemon jar: <a href="https://oss.sonatype.org/content/groups/public/com/newrelic/jfr-daemon/">jfr-daemon-n.n.n.jar</a>.</p>
  </li>
  <li>
    <p><a href="/docs/insights/insights-data-sources/custom-data/introduction-event-api#register">Register an Insert API key</a> for publishing data to New Relic.</p>
  </li>
  <li>
    <p><strong>Required</strong>: Assign your Insert API key to the <code>INSIGHTS_INSERT_KEY</code> environment variable.</p>
  </li>
  <li>
    <p><strong>Recommended</strong>: Set the name of the application being monitored to the <code>NEW_RELIC_APP_NAME</code> environment variable. If this is not set, then the <a href="https://github.com/newrelic/newrelic-jfr-core#how-to-use">default app name</a> will be used.</p>
  </li>
  <li>
    <p>Start your application and the JFR daemon:</p>
    <pre><code>java -jar jfr-daemon-n.n.n.jar
</code></pre>
  </li>
</ol>
<p><strong>Optional (but recommended)</strong>: Include the Java agent:</p>
<ol>
  <li>
    <p><a href="/docs/agents/java-agent/installation/install-java-agent">Install Java agent</a> version 6.1.0 or higher to monitor your application.</p>
  </li>
  <li>
    <p>Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the <a href="/docs/agents/java-agent/configuration/java-agent-configuration-config-file"><code>newrelic.yml</code></a> configuration file:</p>
    <pre><code>jmx:
    enabled: true
    linkingMetadataMBean: true
</code></pre>
  </li>
</ol>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJ0aXAifV0=">
  <p>Enabling <code>linkingMetadataMBean</code> allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using <code>NEW_RELIC_APP_NAME</code>would be overridden in favor of the name specified by the agent.</p>
</div>
<h2>View your data [#find-data]</h2>
<p>To view your data, go to <strong><a href="https://one.newrelic.com">one.newrelic.com</a> > Entity explorer > (select service) > More Views > Realtime Profiling Java</strong>.</p>
<h2>Understand JVM cluster behavior over time [#ui]</h2>
<p>The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see:</p>
<ul>
  <li>How a recent deployment affected the rest of the JVM cluster</li>
  <li>When a JVM restarted</li>
  <li>How an individual instance was affected by its noisy neighbor</li>
</ul>
<p>To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time.</p>
<p>
  <img src="./images/new-relic-one-java-flight-record-ui.jpg" alt="New Relic One Java Flight Recorder (JFR) UI" title="new-relic-one-java-flight-record-ui">
</p>
<p><strong><a href="https://one.newrelic.com">one.newrelic.com</a> > Entity explorer > (select service) > Realtime Profiling Java</strong>: The JVM cluster timeline view shows the JVM behavior across the cluster.</p>
<p>Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues.</p>
<p>
  <img src="./images/new-relic-one-JVM-health.jpg" alt="How JVM health is measured" title="JVM-health-info">
</p>
<p>Select <strong>How is JVM health determined?</strong> for a detailed breakdown of how JVM health is calculated.</p>
<h2>JVM details [#details]</h2>
<p>The details panel for each JVM provides several critical views:</p>
<ul>
  <li>How resources are allocated within a process</li>
  <li>How garbage collection affects performance</li>
  <li>How to track garbage collection with logs</li>
  <li>How CPU is used</li>
</ul>
<p>
  <img src="./images/new-relic-one-java-flight-recorder-details-ui_0.jpg" alt="New Relic One Java Flight Recorder details page UI" title="new-relic-one-java-flight-recorder-details-ui.jpg">
</p>
<p><strong><a href="https://one.newrelic.com">one.newrelic.com</a> > Entity explorer > (select service) > Realtime Profiling Java > (select JVM)</strong>: You can see details for each JVM.</p>
<h2>Identify resource intensive code paths using flamegraphs [#flamegraph]</h2>
<p>Requirements:</p>
<ul>
  <li>Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email <a href="mailto:flamegraph@newrelic.com">flamegraph@newrelic.com</a>.</li>
  <li>At this time, this requires deployment of both the <a href="#requirements">JFR daemon and Java agent</a>.</li>
</ul>
<p>Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance.</p>
<p>
  <img src="./images/jfr_flamegraphs.png" alt="Screenshot showing a flamegraph example." title="jfr_flamegraphs.png">
</p>
<p><strong><a href="one.newrelic.com/">one.newrelic.com</a> > Entity explorer > (select service) > Realtime Profiling Java > (select JVM)</strong>: You can see details for each JVM, including flamegraphs.</p>
