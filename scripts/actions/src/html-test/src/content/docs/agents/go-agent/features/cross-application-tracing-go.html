
<p>The Go agent supports <a href="/docs/apm/transactions/cross-application-traces/introduction-cross-application-traces">cross application tracing (CAT)</a>. Cross application tracing links transactions between APM-monitored app, which is vital for applications implementing a service-oriented or microservices architecture.</p>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJpbXBvcnRhbnQifV0=">
  <p><a href="https://docs.newrelic.com/docs/apm/distributed-tracing/getting-started/introduction-distributed-tracing">Distributed tracing</a> is now available. Distributed tracing is an improvement on cross application tracing and is recommended for large, distributed systems.</p>
</div>
<h2>Enable cross application tracing with Go [#enable]</h2>
<p>You can enable or disable cross application tracing in the Go agent by using the <a href="/docs/agents/go-agent/instrumentation/go-agent-configuration#cross-tracer-enabled"><code>CrossApplicationTracer.Enabled</code></a> configuration flag.</p>
<h2>Transaction and HTTP request guidelines with Go [#guidelines]</h2>
<p>Even with cross application tracing enabled, you'll need to make sure your application follows a few simple conventions when responding to HTTP(s) requests, making its own HTTP(s) requests, or <a href="/docs/agents/go-agent/get-started/instrument-go-transactions">creating its own transactions</a>.</p>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiY3JlYXRlLXRyYW5zYWN0aW9ucyJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ0aXRsZSIsInZhbHVlIjoiQ3JlYXRpbmcgdHJhbnNhY3Rpb25zIHZpYSBodHRwLlNlcnZlTXV4In1d">
    <div data-prop-text="title">Creating transactions via http.ServeMux</div>
    <p>If you're using Go's <a href="https://golang.org/pkg/net/http/#ServeMux"><code>http.ServeMux</code></a> and want CAT support, you'll need to use the agent's <code>WrapHandle</code> and <code>WrapHandleFunc</code> wrappers. These wrappers automatically start and end transactions with the request and response writer, which will <a href="/docs/apm/transactions/cross-application-traces/introduction-cross-application-traces#security">automatically add the correct CAT headers</a>. Your code should look similar to the following:</p>
    <pre><code>http.HandleFunc("/users", usersHandler)
    http.HandleFunc(newrelic.WrapHandleFunc(app, "/users", usersHandler))

</code></pre>You can read more about these wrappers in [Instrument Go transactions](/docs/agents/go-agent/get-started/instrument-go-transactions#http-handler-txns).
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiY3JlYXRlLW1hbnVhbGx5In0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJDcmVhdGluZyB3ZWIgdHJhbnNhY3Rpb25zIG1hbnVhbGx5In1d">
    <div data-prop-text="title">Creating web transactions manually</div>
    <p>When creating your own transactions with <code>app.StartTransaction</code>, ensure that you also call <code>Transaction.SetWebRequest</code> and <code>Transaction.SetWebResponse</code>. For example, a transaction started with the following code will have CAT enabled:</p>
    <pre><code>txn := app.StartTransaction("transactionName")
// req is a *http.Request, this marks the transaction as a web transaction
txn.SetWebRequestHTTP(req)

// writer is a http.ResponseWriter, use the returned writer in place of the original
writer = txn.SetWebResponse(writer)
writer.WriteHeader(500)

defer txn.End()

</code></pre>
    <pre><code>
// old code
// writer.WriteHeader(http.StatusInternalServerError)

// replace with this
txn := app.StartTransaction("transactionName")
txn.SetWebRequest(req)
writer = txn.SetWebResponse(writer)
writer.WriteHeader(http.StatusInternalServerError)

</code></pre>Additionally, if you're setting HTTP response codes, use the Go agent's `txn.WriteHeader` method rather than the standard library's [`http.ResponseWriter.WriteHeader`](https://golang.org/pkg/net/http/#ResponseWriter) method.
    <pre><code>
// Cross application tracing not enabled
txn := app.StartTransaction("transactionName")
defer txn.End()

</code></pre>However, a transaction started without the calls to `Transaction.SetWebRequest` and `Transaction.SetWebResponse` **will not** have CAT enabled:
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoibWFrZS1odHRwLXJlcXVlc3RzIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJNYWtpbmcgSFRUUCByZXF1ZXN0cyJ9XQ==">
    <div data-prop-text="title">Making HTTP requests</div>
    <p>In order to have your outbound HTTP(s) requests eligible for CAT, you'll need to <a href="/docs/agents/go-agent/get-started/instrument-go-segments#go-external-segments">create an external segment</a>.</p>
    <p>The easiest way to create an external segment for your outbound HTTP(s) request is to use the <code>newrelic.NewRoundTripper</code> method. For example, this code will make a request to <code>http://api.example.com/</code> that includes the outgoing CAT headers.</p>
    <pre><code>func useNewRoundTripper(txn *newrelic.Transaction) (*http.Response, error) {
    client := &#x26;http.Client{}
    client.Transport = newrelic.NewRoundTripper(client.Transport)
    req, _ := http.NewRequest("GET", "http://api.example.com/", nil)
    req = newrelic.RequestWithTransactionContext(req, txn)
    return client.Do(req)
}

</code></pre>
    <pre><code>
func noGoodForCat(txn *newrelic.Transaction, url string) (*http.Response, error) {
    // CAT headers not inserted
    defer newrelic.ExternalSegment{
        StartTime: txn.StartSegmentNow(),
        URL:       url,
    }.End()

    return http.Get(url)
}

</code></pre>While it's also possible to create an `ExternalSegment` via a struct literal, this segment **will not** be eligible for CAT. Because of this, New Relic recommends using [`newrelic.NewRoundTripper` or `newrelic.ExternalSegment`](https://docs.newrelic.com/docs/agents/go-agent/get-started/instrument-go-segments#go-external-segments).
    <pre><code>
func external(txn *newrelic.Transaction, req *http.Request) (*http.Response, error) {
    s := newrelic.StartExternalSegment(txn, req)
    response, err := http.DefaultClient.Do(req)
    s.Response = response
    s.End()
    return response, err
}

</code></pre>If you have a more complex request that uses the Go standard library's `http.Request`, you'll need to use the `newrelic.StartExternalSegment` method to ensure your outbound request is eligible for CAT.
  </div>
</div>
<h2>Get distributed tracing [#distributed-tracing]</h2>
<p>New Relic also offers <a href="https://docs.newrelic.com/docs/apm/distributed-tracing/getting-started/introduction-distributed-tracing">distributed tracing</a>. Distributed tracing is an improvement on cross application tracing and is recommended for large, distributed systems.</p>
