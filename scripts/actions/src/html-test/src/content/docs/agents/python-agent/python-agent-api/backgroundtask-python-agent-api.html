
<h2>Syntax</h2>
<pre><code>newrelic.agent.background_task(application=None, name=None, group=None)
</code></pre>
<p>Used to instrument a background task or other non-web transaction.</p>
<h2>Description</h2>
<p>This Python decorator can be used to instrument background tasks or other <a href="/docs/apm/transactions/intro-transactions/monitor-background-processes-other-non-web-transactions">non-web transactions</a>. This is typically used to instrument non-web activity like worker processes, job-based systems, and standalone scripts. Transactions marked as background tasks are displayed as non-web transactions in the APM UI and separated from web transactions.</p>
<p>If a function using the background task decorator is called within the context of a web transaction, then the web transaction is marked as a background task. The measurement of the time taken begins when the original web transaction starts.</p>
<p>If you cannot use the decorator, one of these call formats may be more useful:</p>
<ul>
  <li><strong>The context manager</strong>: If the tasks to be monitored will only be determined at runtime (and not import time), you can use the <code>BackgroundTask</code> context manager to directly wrap the execution of a block of code. (This is the context manager used by <code>BackgroundTaskWrapper</code>.)</li>
  <li><strong>The wrapper</strong>: If you know in advance where the specific functions you want to track are, you can use the <code>background_task</code> decorator. But if you don't know all the functions that need to be traced (for example, if they're being looked up dynamically as part of a routing system), then you must use the <code>BackgroundTaskWrapper</code> to wrap the function at the time of registration or at the time of calling.</li>
  <li><strong>The path-based wrapper</strong>: The path-based wrapper form is <code>wrap_background_task</code>.</li>
</ul>
<p>For more on the differences between and uses of these function forms, see <a href="/docs/python-agent-api-different-call-forms">Variable call formats</a>.</p>
<h2>Parameters</h2>
<h3>Decorator and context manager parameters [#main-params]</h3>
<pre><code>newrelic.agent.background_task(application=None, name=None, group=None)
</code></pre>
<pre><code>newrelic.agent.BackgroundTask(application=None, name=None, group=None)
</code></pre>
<p>Parameters for these calls:</p>
<div data-component="Table" data-prop="W10=">
  <div>
    <div>
      <div>
        <p>Parameter</p>
      </div>
      <div>
        <p>Description</p>
      </div>
    </div>
  </div>
  <div>
    <div>
      <div>
        <p><code>application</code></p>
        <p><em>Application instance</em></p>
      </div>
      <div>
        <p>Required. The application under which the data will be reported. Default is <code>None</code>. If left without a value, the application specified in the agent <a href="/docs/agents/python-agent/installation-configuration/python-agent-configuration">configuration</a> (config file or environment variable) will be used.</p>
        <p>For more on generating an application object, see the <a href="/docs/agents/python-agent/python-agent-api/application"><code>application()</code></a> method.</p>
        <p>The application, even if specified, can still be overridden if <code>newrelic.app_name</code> is defined in the WSGI application per request environ dictionary.</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>name</code></p>
        <p><em>string</em></p>
      </div>
      <div>
        <p>Required. The name of the transaction. The default value is <code>None</code>. By default, the name will be the name of the function the decorator has been applied to but you can override this by supplying this name.</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>group</code></p>
        <p><em>string</em></p>
      </div>
      <div>
        <p>Optional. The <code>group</code> represents the naming structure for the <code>name</code> parameter. This is used in the UI to set the <a href="/docs/apm/applications-menu/monitoring/transactions-page#tx_functions">transaction type</a>.</p>
        <p>If not supplied, the group defaults to <code>Function</code> in expectation that the name is of the form <code>module:class.function</code> or <code>module:function</code> and represents the name of the function being executed. If you are creating a custom group, we recommend you prefix it with <code>Python/</code>.</p>
      </div>
    </div>
  </div>
</div>
<h3>Wrapper parameters: [#wrapper-params]</h3>
<pre><code>newrelic.agent.BackgroundTaskWrapper(wrapped, application=None, name=None, group=None)
</code></pre>
<p><code>BackgroundTaskWrapper</code> takes the same <a href="#main-params">parameters</a> as the <code>background_task</code> decorator and this additional <code>wrapped</code> parameter:</p>
<div data-component="Table" data-prop="W10=">
  <div>
    <div>
      <div>
        <p>Parameter</p>
      </div>
      <div>
        <p>Description</p>
      </div>
    </div>
  </div>
  <div>
    <div>
      <div>
        <p><code>wrapped</code></p>
        <p><em>method</em></p>
      </div>
      <div>
        <p>Required. The method to be traced.</p>
      </div>
    </div>
  </div>
</div>
<h3>Path-based parameters: [#path-based-params]</h3>
<pre><code>newrelic.agent.wrap_background_task(module, object_path, application=None, name=None, group=None)
</code></pre>
<p><code>wrap_background_task</code> takes the same <a href="#main-params">parameters</a> as the <code>background_task</code> decorator plus these additional parameters:</p>
<div data-component="Table" data-prop="W10=">
  <div>
    <div>
      <div>
        <p>Parameter</p>
      </div>
      <div>
        <p>Description</p>
      </div>
    </div>
  </div>
  <div>
    <div>
      <div>
        <p><code>module</code></p>
        <p><em>module</em> or <em>string</em></p>
      </div>
      <div>
        <p>Required. The module containing the non-web function/activity you are instrumenting.</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>object_path</code></p>
        <p><em>string</em></p>
      </div>
      <div>
        <p>Required. The path to the module.</p>
      </div>
    </div>
  </div>
</div>
<h2>Examples</h2>
<h3><code>background_task</code> decorator example [#bg_task_example]</h3>
<p>Here's an example of using the <code>background_task</code> decorator:</p>
<pre><code>@newrelic.agent.background_task()
def task():
    ...
</code></pre>
<h3><code>BackgroundTask</code> context manager example [#context-mgr-example]</h3>
<p>An example of using <code>BackgroundTask</code>:</p>
<pre><code>application = newrelic.agent.application()
name = newrelic.agent.callable_name(task)

with BackgroundTask(application, name):
    task()
</code></pre>
<p>Here's another example with more parameters:</p>
<pre><code>application = newrelic.agent.register_application(timeout=10.0)

def execute_task(task_name):
    with newrelic.agent.BackgroundTask(application, name=task_name, group='Task'):
        ...
</code></pre>
<h3><code>BackgroundTaskWrapper</code> example [#wrapper-example]</h3>
<p>An example of using the <code>BackgroundTaskWrapper</code>:</p>
<pre><code>task = newrelic.agent.BackgroundTaskWrapper(get_next_task())
result = task(*args, **kwargs)
</code></pre>
<p>In this example, if this call was made in a web transaction being monitored by an agent, the call will reclassify the web transaction as a background task. If, however, the call was made in a background thread or coroutine, then it would start the recording of a fresh background task transaction that tracks what occurs until the call returns.</p>
