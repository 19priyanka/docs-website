
<p>New Relic's PHP agent supports <a href="https://docs.newrelic.com/docs/apm/distributed-tracing/getting-started/introduction-distributed-tracing">distributed tracing</a> (including <a href="https://docs.newrelic.com/docs/understand-dependencies/distributed-tracing/get-started/introduction-distributed-tracing#w3c-support">W3C Trace Context</a>, as of PHP Agent version 9.8), which lets you see the path that requests take as they travel through a distributed system. This document contains PHP-specific tips to enable distributed tracing for a PHP application or service.</p>
<h2>Enable distributed tracing for PHP [#enable-distributed]</h2>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJpbXBvcnRhbnQifV0=">
  <p>When distributed tracing is enabled, it implicitly disables cross application tracing. The PHP agent will ignore the <a href="https://docs.newrelic.com/docs/agents/php-agent/configuration/php-agent-configuration#inivar-cross-app-tracer-enabled">cross application tracing configuration value</a>, and act as though this value is set to <code>false</code>.</p>
</div>
<p>To enable or disable distributed tracing for the PHP agent:</p>
<ol>
  <li>
    <p>If applicable, <a href="/docs/agents/php-agent/installation/upgrade-php-agent">update your PHP agent</a> to support distributed tracing (version 8.4 or higher, although we recommend version 9.8 or higher for the most complete functionality).</p>
  </li>
  <li>
    <p>Make sure that the <a href="https://docs.newrelic.com/docs/agents/php-agent/configuration/php-agent-configuration#inivar-tt-settings">transaction tracer</a> configuration option is enabled (default is <code>true</code>):</p>
    <pre><code>newrelic.transaction_tracer.enabled = true
</code></pre>
  </li>
  <li>
    <p>Enable (or disable) distributed tracing for the PHP agent with the <a href="https://docs.newrelic.com/docs/agents/php-agent/configuration/php-agent-configuration#inivar-distributed-enabled"><code>distributed_tracing_enabled</code></a> configuration option:</p>
    <pre><code>newrelic.distributed_tracing_enabled = true
</code></pre>
  </li>
  <li>
    <p>Set the <a href="https://docs.newrelic.com/docs/agents/php-agent/configuration/php-agent-configuration#inivar-tt-threshold">transaction tracer threshold</a> value to a suitable value. <strong>Recommendation:</strong></p>
    <ul>
      <li>If you want to make all transactions eligible for a distributed trace, set this value to <code>0</code> seconds.</li>
      <li>If you are only interested in traces for longer running transactions, or if generating a trace for every transaction creates unacceptable application performance, set this value higher than <code>0</code> seconds.</li>
    </ul>
    <p>For example:</p>
    <pre><code>newrelic.transaction_tracer.threshold = 0
</code></pre>
  </li>
  <li>
    <p>Optionally, if only W3C Trace Context tracing is desired, the New Relic Distributed Tracing headers can be disabled with the <code>newrelic.distributed_tracing_exclude_newrelic_header</code> configuration option:</p>
    <p><code>newrelic.distributed_tracing_exclude_newrelic_header = 1</code></p>
  </li>
  <li>
    <p>Enable spans with the configuration setting:</p>
    <p>newrelic.span_events_enabled = true</p>
  </li>
  <li>
    <p>Be sure to restart your web server (or other PHP SAPI) so the agent will pick up the newly configured values.</p>
  </li>
</ol>
<h2>Enable Infinite Tracing</h2>
<p>Infinite Tracing (PHP agent version 9.12 or later) extends distributed tracing to collect your span data in a trace observer, which runs in a cluster of services in AWS called New Relic Edge. The PHP agent sends all your spans to the trace observer so they can be assembled into traces for you to view in New Relic.</p>
<p>To turn on Infinite Tracing, enable distributed tracing and configure the additional settings below:</p>
<p>newrelic.span_events_enabled = true<br>newrelic.infinite_tracing.trace_observer_host= YOUR_TRACE_OBSERVER_HOST</p>
<h2>Leverage automatic distributed tracing instrumentation</h2>
<p>The PHP agent automatically will instrument a number of native PHP functions, as well as some third party HTTP clients, with distributed trace information. These include:</p>
<ul>
  <li>PHP function <a href="http://php.net/manual/en/function.file-get-contents.php"><code>file_get_contents</code></a></li>
  <li>PHP functions <a href="http://php.net/manual/en/function.curl-exec.php"><code>curl_exec</code></a> and <a href="http://php.net/manual/en/function.curl-multi-exec.php"><code>curl_multi_exec</code></a></li>
  <li>Guzzle 4, Guzzle 5, Guzzle 6</li>
  <li>Drupal's <code>drupal_http_request function</code></li>
  <li>Laravel's queue jobs</li>
</ul>
<h2>Set trace detail level [#performance]</h2>
<p>Distributed tracing support depends on the PHP agent's <a href="/docs/agents/php-agent/configuration/php-agent-configuration#inivar-tt-enable">transaction tracer</a>. When <a href="#enable-distributed">distributed tracing is enabled</a>, a <a href="https://docs.newrelic.com/docs/apm/distributed-tracing/ui-data/distributed-tracing-attributes">span</a> is created for each segment seen by the transaction tracer.</p>
<p>As <a href="https://docs.newrelic.com/docs/apm/distributed-tracing/getting-started/how-new-relic-distributed-tracing-works">spans are sampled</a>, the PHP agent will prioritize spans related to external calls above other spans, which are then recorded in descending order of their duration.</p>
<p>If you find that there are too many unimportant spans being reported for PHP function calls, you can reduce the detail of the transaction tracer by setting <a href="https://docs.newrelic.com/docs/agents/php-agent/configuration/php-agent-configuration#inivar-tt-detail"><code>newrelic.transaction_tracer.detail</code></a> to <code>0</code>. You may then use the <a href="https://docs.newrelic.com/docs/agents/php-agent/configuration/php-agent-configuration#inivar-tt-custom"><code>newrelic.transaction_tracer.custom</code></a> configuration setting or the <a href="https://docs.newrelic.com/docs/agents/php-agent/php-agent-api/newrelic_add_custom_tracer"><code>newrelic_add_custom_tracer</code></a> API method to add trace segments and spans for the specific PHP function or methods you want to add to your traces.</p>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJpbXBvcnRhbnQifV0=">
  <p>For PHP agent versions 8.4 to 8.7: When distributed tracing is enabled, these versions behave as if <a href="https://docs.newrelic.com/docs/agents/php-agent/configuration/php-agent-configuration#inivar-tt-detail"><code>newrelic.transaction_tracer.detail</code></a> is set to <code>0</code> (as described above), which results in PHP function calls not generating spans. To get spans related to PHP function calls, update to version 9.0 or higher.</p>
</div>
<h2>Manually instrument applications and services [#manual]</h2>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJpbXBvcnRhbnQifV0=">
  <p>W3C Trace Context support was added in version 9.8. With this, the API for manually instrumenting applications has changed from the JSON payload related functions</p>
  <p><code>newrelic_create_distributed_trace_payload()</code> and <code>newrelic_accept_distributed_trace_payload($payload),</code></p>
  <p>to the header array forms <code>newrelic_insert_distributed_trace_headers($outbound_headers)</code> and <code>newrelic_accept_distributed_trace_headers($inbound_headers)</code>.</p>
  <p>The JSON functions are now considered deprecated, and will be removed in a future release.</p>
</div>
<p>If you're using an unsupported library, or have a non-HTTP based distributed system component (such as messaging queues), you can use the PHP agent API to manually identify transactions to be included in a distributed trace. This is a two step process:</p>
<ol>
  <li>Modify your service or application to <strong>create</strong> or <strong>insert</strong> the distributed tracing data</li>
  <li>Modify your service or application to <strong>accept</strong> distributed trace data created by other transactions or requests.</li>
</ol>
<p>The following example uses a generic message/job queue. While the actual details will vary depending on what sort of system you're trying to add to a distributed trace, the core concepts are the same. Also, while we've used a job queue as an example, you can use these methods with <strong>any</strong> distributed system component.</p>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJ0aXAifV0=">
  <p>When you <strong>create a payload</strong> or <strong>insert headers</strong>, you're telling New Relic you want this request or transaction or request to participate in a distributed trace. When you <strong>accept</strong> them, you're linking the current request or transaction with its parent request or transaction.</p>
</div>
<p>For more information about using manual instrumentation to get more detail or to see connections between services, see the documentation about <a href="/docs/apm/distributed-tracing/enable-configure/enable-distributed-tracing#agent-apis">distributed tracing APIs</a>.</p>
<h3>Header API</h3>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiZXhhbXBsZS1kdC1jcmVhdGUifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6Ikluc2VydCBkaXN0cmlidXRlZCB0cmFjZSBoZWFkZXJzIn1d">
    <div data-prop-text="title">Insert distributed trace headers</div>
    <p>Somewhere in your application you'll have code that looks or acts like the following:</p>
    <pre><code>// create a job object
$job = new \Generic\Queue\Job;

// set the information needed to run the queue job
$job->setData('info', $info);

// save the job
$job->save();

</code></pre>&#x3C;Callout variant="tip">
    Tip: The headers created via `newrelic_insert_distributed_trace_headers()` are HTTP safe.
    &#x3C;/Callout>
    This is step one: You've inserted the distributed trace headers.
    <pre><code>
$outbound_headers = array();
if (newrelic_insert_distributed_trace_headers($outbound_headers)) {

    // create a job object
    $job = new \Generic\Queue\Job;

    // set the information needed to run the queue job
    $job->setData('info', $info);

    // add the headers to the job data
    $job->setData('nr_dt_headers', $outbound_headers);

    // save the job
    $job->save();
} else {
    echo "Unable to obtain distributed tracing headers";
}

</code></pre>If you want this job to appear in a distributed trace, you need to insert distributed trace headers into an array by using `newrelic_insert_distributed_trace_headers`, and then add those headers to the job's data:
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiZXhhbXBsZS1kdC1hY2NlcHQifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6IkFjY2VwdCB0aGUgZGlzdHJpYnV0ZWQgdHJhY2luZyBoZWFkZXJzIn1d">
    <div data-prop-text="title">Accept the distributed tracing headers</div>
    <p>Next, somewhere in your application stack you'll have a queue runner that looks or acts like the following:</p>
    <pre><code>// create the job runner
$jobRunner = \Generic\Queue\Runner;

// grab jobs until there aren't any
while($job = $jobRunner->next()) {
    // run the job
    $job->run();
}

</code></pre>
    <pre><code>
// create the job runner
$jobRunner = \Generic\Queue\Runner;

while($job = $jobRunner->next()) {
    $inbound_headers = $job->getData('nr_dt_headers');
    if($inbound_headers) {
        newrelic_accept_distributed_trace_headers($inbound_headers);
    }
    $job->run();
}

</code></pre>In order to accept distributed trace headers, use the `newrelic_accept_distributed_trace_headers` function
  </div>
</div>
<h3>Payload API (deprecated)</h3>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiZXhhbXBsZS1kdC1jcmVhdGUifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6IkNyZWF0ZSBhIGRpc3RyaWJ1dGVkIHRyYWNlIHBheWxvYWQifV0=">
    <div data-prop-text="title">Create a distributed trace payload</div>
    <p>Somewhere in your application you'll have code that looks or acts like the following:</p>
    <pre><code>// create a job object
$job = new \Generic\Queue\Job;

// set the information needed to run the queue job
$job->setData('info', $info);

// save the job
$job->save();

</code></pre>This is step one: You've created a distributed trace payload.
    <pre><code>
$payload = newrelic_create_distributed_trace_payload();

// create a job object
$job = new \Generic\Queue\Job;

// set the information needed to run the queue job
$job->setData('info', $info);

// add the payload data to the job data as a text json string
$job->setData('dt_payload', $payload->Text());

// save the job
$job->save();

</code></pre>If you want this job to appear in a distributed trace, you need to create a distributed trace payload using `newrelic_create_distributed_trace_payload`, and then add that payload to the job's data:
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiZXhhbXBsZS1kdC1hY2NlcHQifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6IkFjY2VwdCB0aGUgZGlzdHJpYnV0ZWQgdHJhY2luZyBwYXlsb2FkIn1d">
    <div data-prop-text="title">Accept the distributed tracing payload</div>
    <p>Next, somewhere in your application stack you'll have a queue runner that looks or acts like the following:</p>
    <pre><code>// create the job runner
$jobRunner = \Generic\Queue\Runner;

// grab jobs until there aren't any
while($job = $jobRunner->next()) {
    // run the job
    $job->run();
}

</code></pre>
    <pre><code>
// create the job runner
$jobRunner = \Generic\Queue\Runner;

while($job = $jobRunner->next()) {
    $payload = $job->getData('dt_payload');
    if($payload) {
        newrelic_accept_distributed_trace_payload($payload);
    }
    $job->run();
}

</code></pre>In order to accept a distributed trace payload, use the `newrelic_accept_distributed_trace_payload` function
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiZXhhbXBsZS1kdC1hY2NlcHQifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6Ik9wdGlvbmFsOiBVc2UgSFRUUCBzYWZlIHBheWxvYWQgc3RyaW5ncyJ9XQ==">
    <div data-prop-text="title">Optional: Use HTTP safe payload strings</div>
    <p>If you need to transport the payload via a mechanism that requires HTTP safe strings, (HTTP headers, URL query strings, POST fields, etc.), the API includes distributed tracing methods and functions that will create and accept HTTP safe versions of the strings.</p>
    <pre><code>// create the HTTP safe payload string 
$payload = newrelic_create_distributed_trace_payload();
$httpSafePayload = $payload->httpSafe();

// ...

// accept the HTTP safe payload string
newrelic_accept_distributed_trace_payload_httpsafe($httpSafePayload);

</code></pre>
  </div>
</div>
<h2>Command line PHP programs [#command-line]</h2>
<p>PHP programs run from the PHP command line are always sampled by the agent's distributed tracer. Depending on the programs you run, these processes could see an over-representation in your collection of distributed traces. In these situations, you can opt to disable command line instrumentation by using the <a href="https://docs.newrelic.com/docs/agents/php-agent/configuration/php-agent-configuration"><code>per-directory newrelic.enabled</code></a> setting in your <code>newrelic.ini files</code>.</p>
