
<p>This document demonstrates using the New Relic <a href="/docs/agents/java-agent/custom-instrumentation/java-agent-api">Java agent API</a> to instrument a simple client and server application. The instrumentation has these goals:</p>
<ul>
  <li>To record external HTTP and datastore <a href="https://docs.newrelic.com/docs/apm/applications-menu/monitoring/transactions-page">transactions</a>.</li>
  <li>To link external transactions between two applications running New Relic agents (known as <a href="https://docs.newrelic.com/docs/apm/transactions/cross-application-traces/cross-application-tracing">cross application tracing</a> or CAT).</li>
</ul>
<p>See the <a href="http://newrelic.github.io/java-agent-api/javadoc/index.html?com/newrelic/api/agent/NewRelic.html">Java agent API Javadoc</a> for full descriptions of the available API classes and methods.</p>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJpbXBvcnRhbnQifV0=">
  <p>For best results when using the API, ensure that you have the <a href="/docs/release-notes/agent-release-notes/java-release-notes">latest Java agent release</a>. Several APIs used in the examples require Java agent 3.36.0 or higher.</p>
</div>
<h2>Client-side example [#complete-client]</h2>
<p>Here is an example of the client-side code for a simple client-server application:</p>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJjbGFzc05hbWUiLCJ2YWx1ZSI6ImZyZXEtbGluayJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiY29tcGxldGUtY2xpZW50In0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJDb21wbGV0ZSBjbGllbnQgZXhhbXBsZSBjb2RlIn1d">
    <div data-prop-text="title">Complete client example code</div>
    <pre><code>package com.newrelic.example;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;

// New Relic API imports
import com.newrelic.api.agent.ExternalParameters;
import com.newrelic.api.agent.HeaderType;
import com.newrelic.api.agent.HttpParameters;
import com.newrelic.api.agent.InboundHeaders;
import com.newrelic.api.agent.NewRelic;
import com.newrelic.api.agent.OutboundHeaders;
import com.newrelic.api.agent.Trace;
import com.newrelic.api.agent.TracedMethod;

import fi.iki.elonen.NanoHTTPD;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpUriRequest;
import org.apache.http.client.methods.RequestBuilder;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClientBuilder;

public class NewRelicApiExample extends NanoHTTPD {

    public NewRelicApiExample() throws IOException, URISyntaxException {
        super(8080);

        // Set Dispatcher name and version
        NewRelic.setServerInfo("NanoHttp", "2.3.1");
        // Set Appserver port for JVM identification
        NewRelic.setAppServerPort(8080);
        // Set JVM instance name
        NewRelic.setInstanceName("Client");

        start(NanoHTTPD.SOCKET_READ_TIMEOUT, false);
        System.out.println("Running at: http://localhost:8080/");
    }

    public static void main(String[] args) throws URISyntaxException {
        try {
            new NewRelicApiExample();
        } catch (IOException ioe) {
            System.err.println("Unable to start the server:\n" + ioe);
        }
    }

    @Trace(dispatcher = true)
    @Override
    public Response serve(IHTTPSession session) {
        URI uri = null;
        int status = 0;

        try {
            createDB();
            Thread.sleep(1000);
            uri = new URI("http://localhost:8081");
            status = makeExternalCall(uri);
        } catch (URISyntaxException | InterruptedException | IOException e) {
            e.printStackTrace();
        }

        if (status == 200) {
            return newFixedLengthResponse("&#x3C;html>&#x3C;body>&#x3C;h1>Successful Response&#x3C;/h1>\n&#x3C;/body>&#x3C;/html>\n");
        } else {
            return newFixedLengthResponse("&#x3C;html>&#x3C;body>&#x3C;h1>Error\n" + status + "&#x3C;/h1>\n&#x3C;/body>&#x3C;/html>\n");
        }
    }

    @Trace
    public int makeExternalCall(URI uri) throws IOException {
        HttpUriRequest request = RequestBuilder.get().setUri(uri).build();

        // Wrap the outbound Request object
        OutboundWrapper outboundHeaders = new OutboundWrapper(request);

        // Obtain a reference to the method currently being traced
        TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod();
        // Add headers for outbound external request
        tracedMethod.addOutboundRequestHeaders(outboundHeaders);

        CloseableHttpClient connection = HttpClientBuilder.create().build();
        CloseableHttpResponse response = connection.execute(request);

        // Wrap the incoming Response object
        InboundWrapper inboundHeaders = new InboundWrapper(response);

        // Create an input parameter object for a call to an external HTTP service
        ExternalParameters params = HttpParameters
            .library("HttpClient")
            .uri(uri)
            .procedure("execute")
            .inboundHeaders(inboundHeaders)
            .build();

        // Report a call to an external HTTP service
        tracedMethod.reportAsExternal(params);

        return response.getStatusLine().getStatusCode();
    }

    // Implement OutboundHeaders interface to create a wrapper for the outgoing Request headers
    class OutboundWrapper implements OutboundHeaders {
        private final HttpUriRequest delegate;

        public OutboundWrapper(HttpUriRequest request) {
            this.delegate = request;
        }

        @Override
        public void setHeader(String name, String value) {
            delegate.addHeader(name, value);
        }

        @Override
        public HeaderType getHeaderType() {
            return HeaderType.HTTP;
        }
    }

    // Implement InboundHeaders interface to create a wrapper for the incoming Response headers
    class InboundWrapper implements InboundHeaders {
        private final CloseableHttpResponse responseHeaders;

        public InboundWrapper(CloseableHttpResponse requestHeaders) {
            this.responseHeaders = requestHeaders;
        }

        @Override
        public HeaderType getHeaderType() {
            return HeaderType.HTTP;
        }

        @Override
        public String getHeader(String name) {
            return responseHeaders.getFirstHeader(name).getValue();
        }
    }

    @Trace
    public void createDB() {
        Connection c = null;
        Statement stmt = null;

        try {
            Class.forName("org.sqlite.JDBC");
            c = DriverManager.getConnection("jdbc:sqlite:/tmp/test.db");
            System.out.println("Opened database successfully");

            stmt = c.createStatement();

            String dropSql = "DROP TABLE IF EXISTS COMPANY;";
            stmt.executeUpdate(dropSql);

            String sql = "CREATE TABLE COMPANY " +
                    "(ID INT PRIMARY KEY     NOT NULL," +
                    " NAME           TEXT    NOT NULL, " +
                    " AGE            INT     NOT NULL, " +
                    " ADDRESS        CHAR(50), " +
                    " SALARY         REAL)";
            stmt.executeUpdate(sql);

            sql = "INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) " +
                   "VALUES (1, 'Paul', 32, 'California', 20000.00 );";
            stmt.executeUpdate(sql);

            sql = "INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) " +
                    "VALUES (2, 'Allen', 25, 'Texas', 15000.00 );";
            stmt.executeUpdate(sql);

            sql = "INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) " +
            "VALUES (3, 'Teddy', 23, 'Norway', 20000.00 );";
            stmt.executeUpdate(sql);

            sql = "INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) " +
                    "VALUES (4, 'Mark', 25, 'Rich-Mond ', 65000.00 );";
            stmt.executeUpdate(sql);

            stmt.close();
            c.close();
        } catch (Exception e) {
            System.err.println(e.getClass().getName() + ": " + e.getMessage());
            System.exit(0);
        }
    }
}

</code></pre>
  </div>
</div>
<p>Here is the same client app code divided into sections that describe how the API is used:</p>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJjbGFzc05hbWUiLCJ2YWx1ZSI6ImZyZXEtbGluayJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiY2xpZW50LWltcG9ydC1qYXZhIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJJbXBvcnQgSmF2YSBhZ2VudCBBUEkgY2xhc3NlcyJ9XQ==">
    <div data-prop-text="title">Import Java agent API classes</div>
    <p>This section calls the Java agent API imports used to add cross application tracing to the client application later in the example code.</p>
    <pre><code>import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;

// New Relic API imports
import com.newrelic.api.agent.ExternalParameters;
import com.newrelic.api.agent.HeaderType;
import com.newrelic.api.agent.InboundHeaders;
import com.newrelic.api.agent.NewRelic;
import com.newrelic.api.agent.OutboundHeaders;
import com.newrelic.api.agent.Trace;
import com.newrelic.api.agent.TracedMethod;

import fi.iki.elonen.NanoHTTPD;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpUriRequest;
import org.apache.http.client.methods.RequestBuilder;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClientBuilder;

</code></pre>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJjbGFzc05hbWUiLCJ2YWx1ZSI6ImZyZXEtbGluayJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiY2xpZW50LWVudi1kZXRhaWxzIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJTdGFydCB0aGUgY2xpZW50IGFuZCBzZXQgZW52aXJvbm1lbnQgZGV0YWlscyBhcyBkaXNwbGF5ZWQgaW4gdGhlIFVJIn1d">
    <div data-prop-text="title">Start the client and set environment details as displayed in the UI</div>
    <p>This section starts up the client server on port 8080 and uses the <code>NewRelic</code> class from the API to call the methods <code>setServerInfo</code>, <code>setAppServerPort</code>, and <code>setInstanceName</code>. These API calls affect what is shown in the New Relic UI.</p>
    <pre><code>public NewRelicApiExample() throws IOException, URISyntaxException {
        super(8080);

        // Set Dispatcher name and version
        NewRelic.setServerInfo("NanoHttp", "2.3.1");
        // Set Appserver port for jvm identification
        NewRelic.setAppServerPort(8080);
        // Set JVM instance name
        NewRelic.setInstanceName("Client");

        start(NanoHTTPD.SOCKET_READ_TIMEOUT, false);
        System.out.println("Running at: http://localhost:8080/");
    }

    public static void main(String[] args) throws URISyntaxException {
        try {
            new NewRelicApiExample();
        } catch (IOException ioe) {
            System.err.println("Unable to start the server:\n" + ioe);
        }
    }

</code></pre>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJjbGFzc05hbWUiLCJ2YWx1ZSI6ImZyZXEtbGluayJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiY2xpZW50LXRyYWNlIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJTdGFydCB0cmFjaW5nIGEgdHJhbnNhY3Rpb24gd2l0aCB0aGUgSmF2YSBhZ2VudCB1c2luZyBAVHJhY2UgYW5ub3RhdGlvbiJ9XQ==">
    <div data-prop-text="title">Start tracing a transaction with the Java agent using @Trace annotation</div>
    <p>This method creates a sample database, sleeps the thread, and makes an external call to the server app listening on port 8081. The <code>@Trace(dispatcher = true)</code> annotation tells the agent to start a new transaction when the <code>serve</code> method is called, if it is not called as part of an existing transaction (and in this case, it is not). If it were called as part of an existing transaction, it would simply be included as part of that transaction rather than start a new one.</p>
    <pre><code>@Trace(dispatcher = true)
    @Override
    public Response serve(IHTTPSession session) {
        URI uri = null;
        int status = 0;

        try {
            createDB();
            Thread.sleep(1000);
            uri = new URI("http://localhost:8081");
            status = makeExternalCall(uri);
        } catch (URISyntaxException | InterruptedException | IOException e) {
            e.printStackTrace();
        }

        if (status == 200) {
            return newFixedLengthResponse("&#x3C;html>&#x3C;body>&#x3C;h1>Successful Response&#x3C;/h1>\n&#x3C;/body>&#x3C;/html>\n");
        } else {
            return newFixedLengthResponse("&#x3C;html>&#x3C;body>&#x3C;h1>Error\n" + status + "&#x3C;/h1>\n&#x3C;/body>&#x3C;/html>\n");
        }
    }

</code></pre>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJjbGFzc05hbWUiLCJ2YWx1ZSI6ImZyZXEtbGluayJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiY2xpZW50LWV4dGVybmFsIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJNYWtlIGFuIGV4dGVybmFsIGNhbGwgdXNpbmcgdGhlIEphdmEgYWdlbnQgQVBJIn1d">
    <div data-prop-text="title">Make an external call using the Java agent API</div>
    <p>This section contains the code that initiates cross application tracing to the application making the request. The <code>@Trace</code> annotation tells the agent to track this method as part of an existing transaction as started by the <code>serve</code> method.</p>
    <p>The request object is wrapped by a class that implements the Java agent API's <code>OutboundHeaders</code> interface, which ensures that the proper <code>HeaderType</code> is set (in this case <code>HTTP</code>). A call to <code>addOutboundRequestHeaders</code> adds the headers to the <code>request</code> and the request is sent to the server.</p>
    <p>When the <code>response</code> returns it is wrapped by a class implementing the Java agent API's <code>InboundHeaders</code> interface. The <code>inboundHeaders</code>, along with the <code>"library"</code>, <code>URI</code>, and <code>"procedure"</code> arguments, are used to build an <code>HttpParameters</code> object. The <code>params</code> object is then passed as an argument to the <code>reportAsExternal</code> method, which reports the <code>TracedMethod</code> as an external HTTP call.</p>
    <pre><code>@Trace
    public int makeExternalCall(URI uri) throws IOException {
        HttpUriRequest request = RequestBuilder.get().setUri(uri).build();

        // Wrap the outbound Request object
        OutboundWrapper outboundHeaders = new OutboundWrapper(request);

        // Obtain a reference to the method currently being traced
        TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod();
        // Add headers for outbound external request
        tracedMethod.addOutboundRequestHeaders(outboundHeaders);

        CloseableHttpClient connection = HttpClientBuilder.create().build();
        CloseableHttpResponse response = connection.execute(request);

        // Wrap the incoming Response object
        InboundWrapper inboundHeaders = new InboundWrapper(response);

        // Create an input parameter object for a call to an external HTTP service
        ExternalParameters params = HttpParameters
            .library("HttpClient")
            .uri(uri)
            .procedure("execute")
            .inboundHeaders(inboundHeaders)
            .build();

        // Report a call to an external HTTP service
        tracedMethod.reportAsExternal(params);

        return response.getStatusLine().getStatusCode();
    }

</code></pre>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJjbGFzc05hbWUiLCJ2YWx1ZSI6ImZyZXEtbGluayJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiY2xpZW50LW91dGJvdW5kaGVhZGVycyJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ0aXRsZSIsInZhbHVlIjoiSW1wbGVtZW50IHRoZSBKYXZhIGFnZW50IEFQSSdzIE91dGJvdW5kSGVhZGVycyBJbnRlcmZhY2UifV0=">
    <div data-prop-text="title">Implement the Java agent API's OutboundHeaders Interface</div>
    <p>An implementation of the Java agent API's <code>OutboundHeaders</code> Interface is used to wrap the request object of the client server, which in this example is of type <code>HttpUriRequest</code>. The request is passed into the constructor of the <code>OutboundWrapper</code> class and implementations of the <code>setHeader</code> and <code>getHeaderType</code> methods are provided.</p>
    <p>The <code>getHeaderType</code> method returns a <code>HeaderType</code> enum that can either be <code>HeaderType.HTTP</code> or <code>HeaderType.MESSAGE</code>, as defined by the Java agent API. In this example the external call protocol is HTTP, so <code>HeaderType.HTTP</code> is returned.</p>
    <pre><code>// Implement OutboundHeaders interface to create a wrapper for the outgoing Request headers
    class OutboundWrapper implements OutboundHeaders {
        private final HttpUriRequest delegate;

        public OutboundWrapper(HttpUriRequest request) {
            this.delegate = request;
        }

        @Override
        public void setHeader(String name, String value) {
            delegate.addHeader(name, value);
        }

        @Override
        public HeaderType getHeaderType() {
            return HeaderType.HTTP;
        }
    }

</code></pre>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJjbGFzc05hbWUiLCJ2YWx1ZSI6ImZyZXEtbGluayJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiY2xpZW50LWluYm91bmRoZWFkZXJzIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJJbXBsZW1lbnQgdGhlIEphdmEgYWdlbnQgQVBJJ3MgSW5ib3VuZEhlYWRlcnMgSW50ZXJmYWNlIn1d">
    <div data-prop-text="title">Implement the Java agent API's InboundHeaders Interface</div>
    <p>An implementation of the Java agent API's <code>InboundHeaders</code> Interface is used to wrap the response object returned to the client server, which in this example is of type <code>CloseableHttpResponse</code>. The response is passed into the constructor of the <code>InboundWrapper</code> class, where implementations of the <code>getHeaderType</code> and <code>getHeader</code> methods are provided.</p>
    <p>The <code>getHeaderType</code> method returns a <code>HeaderType</code> enum that can either be <code>HeaderType.HTTP</code> or <code>HeaderType.MESSAGE</code>, as defined by the Java agent API. In this example the external call protocol is HTTP so <code>HeaderType.HTTP</code> is returned.</p>
    <pre><code>// Implement InboundHeaders interface to create a wrapper for the incoming Response headers
    class InboundWrapper implements InboundHeaders {
        private final CloseableHttpResponse responseHeaders;

        public InboundWrapper(CloseableHttpResponse requestHeaders) {
            this.responseHeaders = requestHeaders;
        }

        @Override
        public HeaderType getHeaderType() {
            return HeaderType.HTTP;
        }

        @Override
        public String getHeader(String name) {
            return responseHeaders.getFirstHeader(name).getValue();
        }
    }

</code></pre>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJjbGFzc05hbWUiLCJ2YWx1ZSI6ImZyZXEtbGluayJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoiY2xpZW50LWRhdGFiYXNlIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJDcmVhdGUgYSBzaW1wbGUgZGF0YWJhc2UifV0=">
    <div data-prop-text="title">Create a simple database</div>
    <p>This method simply creates an example SQLite database. The <code>@Trace</code> annotation tells the agent to track this method as part of an existing transaction as started by the <code>serve</code> method.</p>
    <pre><code>@Trace
    public void createDB() {
        Connection c = null;
        Statement stmt = null;

        try {
            Class.forName("org.sqlite.JDBC");
            c = DriverManager.getConnection("jdbc:sqlite:/tmp/test.db");
            System.out.println("Opened database successfully");

            stmt = c.createStatement();

            String dropSql = "DROP TABLE IF EXISTS COMPANY;";
            stmt.executeUpdate(dropSql);

            String sql = "CREATE TABLE COMPANY " +
                    "(ID INT PRIMARY KEY     NOT NULL," +
                    " NAME           TEXT    NOT NULL, " +
                    " AGE            INT     NOT NULL, " +
                    " ADDRESS        CHAR(50), " +
                    " SALARY         REAL)";
            stmt.executeUpdate(sql);

            sql = "INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) " +
                   "VALUES (1, 'Paul', 32, 'California', 20000.00 );";
            stmt.executeUpdate(sql);

            sql = "INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) " +
                    "VALUES (2, 'Allen', 25, 'Texas', 15000.00 );";
            stmt.executeUpdate(sql);

            sql = "INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) " +
            "VALUES (3, 'Teddy', 23, 'Norway', 20000.00 );";
            stmt.executeUpdate(sql);

            sql = "INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) " +
                    "VALUES (4, 'Mark', 25, 'Rich-Mond ', 65000.00 );";
            stmt.executeUpdate(sql);

            stmt.close();
            c.close();
        } catch (Exception e) {
            System.err.println(e.getClass().getName() + ": " + e.getMessage());
            System.exit(0);
        }
    }

</code></pre>
  </div>
</div>
<h2>Server-side example [#complete-server]</h2>
<p>Here is the server-side code for this example application:</p>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJjbGFzc05hbWUiLCJ2YWx1ZSI6ImZyZXEtbGluayJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoic2VydmVyLWNvbXBsZXRlIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJDb21wbGV0ZSBzZXJ2ZXIgZXhhbXBsZSBjb2RlIn1d">
    <div data-prop-text="title">Complete server example code</div>
    <pre><code>package com.newrelic.example;

import java.io.IOException;
import java.net.URISyntaxException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.Collections;
import java.util.Enumeration;

// New Relic API imports
import com.newrelic.api.agent.DatastoreParameters;
import com.newrelic.api.agent.ExtendedRequest;
import com.newrelic.api.agent.HeaderType;
import com.newrelic.api.agent.NewRelic;
import com.newrelic.api.agent.Trace;
import com.newrelic.api.agent.TracedMethod;
import com.newrelic.api.agent.Transaction;

import fi.iki.elonen.NanoHTTPD;

public class NewRelicApiServer extends NanoHTTPD {

    public NewRelicApiServer() throws IOException, URISyntaxException {
        super(8081);

        // Set Dispatcher name and version
        NewRelic.setServerInfo("NanoHttp", "2.3.1");
        // Set Appserver port for jvm identification
        NewRelic.setAppServerPort(8081);
        // Set JVM instance name
        NewRelic.setInstanceName("Server");

        start(NanoHTTPD.SOCKET_READ_TIMEOUT, false);
        System.out.println("\nRunning on http://localhost:8081/ \n");
    }

    public static void main(String[] args) throws URISyntaxException {
        try {
            new NewRelicApiServer();
        } catch (IOException ioe) {
            System.err.println("Unable to start the server:\n" + ioe);
        }
    }

    @Trace(dispatcher = true)
    @Override
    public Response serve(IHTTPSession session) {
        // Obtain a reference to the current Transaction
        Transaction tx = NewRelic.getAgent().getTransaction();
        // Set the name of the current transaction
        NewRelic.setTransactionName("Custom", "ExternalHTTPServer");

        // Wrap the Request object
        ExtendedRequest req = new RequestWrapper(session);

        // Set the request for the current transaction and convert it into a web transaction
        tx.setWebRequest(req);

        queryDB();
        Response res = newFixedLengthResponse("&#x3C;html>&#x3C;body>&#x3C;h1>SuccessfulResponse&#x3C;/h1>\n&#x3C;/body>&#x3C;/html>\n");

        // Set the response for the current transaction and convert it into a web transaction
        tx.setWebResponse(new ResponseWrapper(res));

        // Instruct the transaction to write the outbound response headers
        tx.addOutboundResponseHeaders();

        // Mark the time when the response left the server
        tx.markResponseSent();

        return res;
    }

    // Implement Response interface to create a wrapper for the outgoing Response object
    public class ResponseWrapper implements com.newrelic.api.agent.Response {

        private final Response httpResponse;

        public ResponseWrapper(Response httpResponse) {
            this.httpResponse = httpResponse;
        }

        @Override
        public int getStatus() throws Exception {
            return 200;
        }

        @Override
        public String getStatusMessage() throws Exception {
            return null;
        }

        @Override
        public void setHeader(String name, String value) {
            httpResponse.addHeader(name, value);
        }

        @Override
        public String getContentType() {
            return "";
        }

        @Override
        public HeaderType getHeaderType() {
            return HeaderType.HTTP;
        }
    }

    // Extend ExtendedRequest class to create a wrapper for the Request object
    class RequestWrapper extends ExtendedRequest {
        private IHTTPSession session;

        public RequestWrapper(IHTTPSession session) {
            super();
            this.session = session;
        }

        @Override
        public String getRequestURI() {
            return session.getUri();
        }

        @Override
        public String getHeader(String name) {
            return session.getHeaders().get(name.toLowerCase());
        }

        @Override
        public String getRemoteUser() {
            return null;
        }

        @SuppressWarnings("rawtypes")
        @Override
        public Enumeration getParameterNames() {
            return Collections.enumeration(session.getParms().keySet());
        }

        @Override
        public String[] getParameterValues(String name) {
            return new String[]{session.getParms().get(name)};
        }

        @Override
        public Object getAttribute(String name) {
            return null;
        }

        @Override
        public String getCookieValue(String name) {
            return null;
        }

        @Override
        public HeaderType getHeaderType() {
            return HeaderType.HTTP;
        }

        @Override
        public String getMethod() {
            return session.getMethod().toString();
        }
    }

    @Trace
    public void queryDB() {
        Connection c = null;
        Statement stmt = null;
        try {
            Class.forName("org.sqlite.JDBC");
            c = DriverManager.getConnection("jdbc:sqlite:/tmp/test.db");
            c.setAutoCommit(false);
            System.out.println("Opened database successfully");

            stmt = c.createStatement();
            ResultSet rs = stmt.executeQuery("SELECT * FROM COMPANY;");
            while (rs.next()) {
                int id = rs.getInt("id");
                String name = rs.getString("name");
                int age = rs.getInt("age");
                String address = rs.getString("address");
                float salary = rs.getFloat("salary");
                System.out.println("ID = " + id);
                System.out.println("NAME = " + name);
                System.out.println("AGE = " + age);
                System.out.println("ADDRESS = " + address);
                System.out.println("SALARY = " + salary);
                System.out.println();
            }
            rs.close();
            stmt.close();
            c.close();
        } catch (Exception e) {
            System.err.println(e.getClass().getName() + ": " + e.getMessage());
            System.exit(0);
        }
        // Obtain a reference to the method currently being traced
        TracedMethod method = NewRelic.getAgent().getTracedMethod();

        // Create a DatastoreParameters object and report a call to an external datastore service
        method.reportAsExternal(
                DatastoreParameters
                        .product("sqlite")
                        .collection("test.db")
                        .operation("select")
                        .instance("localhost", 8080)
                        .databaseName("test.db")
                        .build());
    }
}

</code></pre>
  </div>
</div>
<p>Here is the same example server code broken into sections that describe how the API is used:</p>
<div data-component="CollapserGroup" data-prop="W10=">
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJjbGFzc05hbWUiLCJ2YWx1ZSI6ImZyZXEtbGluayJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoic2VydmVyLWltcG9ydC1qYXZhIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJJbXBvcnQgSmF2YSBhZ2VudCBBUEkgY2xhc3NlcyJ9XQ==">
    <div data-prop-text="title">Import Java agent API classes</div>
    <p>This section shows the relevant Java agent API imports needed to add cross application tracing and reporting of external datastore calls to the server application.</p>
    <pre><code>import java.io.IOException;
import java.net.URISyntaxException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.Collections;
import java.util.Enumeration;

// New Relic API imports
import com.newrelic.api.agent.DatastoreParameters;
import com.newrelic.api.agent.ExtendedRequest;
import com.newrelic.api.agent.HeaderType;
import com.newrelic.api.agent.NewRelic;
import com.newrelic.api.agent.Trace;
import com.newrelic.api.agent.TracedMethod;
import com.newrelic.api.agent.Transaction;

import fi.iki.elonen.NanoHTTPD;

</code></pre>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJjbGFzc05hbWUiLCJ2YWx1ZSI6ImZyZXEtbGluayJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoic2VydmVyLWVudi1kZXRhaWxzIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJTdGFydCB0aGUgc2VydmVyIGFuZCBzZXQgaXRzIGluZm8gYXMgZGlzcGxheWVkIGluIFVJIn1d">
    <div data-prop-text="title">Start the server and set its info as displayed in UI</div>
    <p>This section starts up the server on port 8081 and uses the <code>NewRelic</code> class from the API to call the methods <code>setServerInfo</code>, <code>setAppServerPort</code>, and <code>setInstanceName</code>. These API calls affect what is shown in the APM UI.</p>
    <pre><code>public NewRelicApiServer() throws IOException, URISyntaxException {
        super(8081);

        // Set Dispatcher name and version
        NewRelic.setServerInfo("NanoHttp", "2.3.1");
        // Set Appserver port for jvm identification
        NewRelic.setAppServerPort(8081);
        // Set JVM instance name
        NewRelic.setInstanceName("Server");

        start(NanoHTTPD.SOCKET_READ_TIMEOUT, false);
        System.out.println("\nRunning on http://localhost:8081/ \n");
    }

    public static void main(String[] args) throws URISyntaxException {
        try {
            new NewRelicApiServer();
        } catch (IOException ioe) {
            System.err.println("Unable to start the server:\n" + ioe);
        }
    }

</code></pre>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJjbGFzc05hbWUiLCJ2YWx1ZSI6ImZyZXEtbGluayJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoic2VydmVyLXRyYWNlIn0seyJ0eXBlIjoibWR4QXR0cmlidXRlIiwibmFtZSI6InRpdGxlIiwidmFsdWUiOiJTdGFydCB0cmFjaW5nIGEgdHJhbnNhY3Rpb24gYW5kIGFkZCBvdXRib3VuZCBSZXNwb25zZSBoZWFkZXJzIn1d">
    <div data-prop-text="title">Start tracing a transaction and add outbound Response headers</div>
    <p>The <code>@Trace(dispatcher = true)</code> annotation tells the agent to start a new transaction when the <code>serve</code> method is called if it is not called as part of an existing transaction (which in this case, it is not). If it were called as part of an existing transaction, it would simply be included as part of that transaction rather than start a new one.</p>
    <p>A reference to the current <code>Transaction</code> is obtained via a call to <code>getTransaction</code> and the name of the transaction is set via a call to the <code>setTransactionName</code> method.</p>
    <p>The request object, which in this example is of type <code>IHTTPSession</code>, is then wrapped using a class extending the Java agent API's <code>ExtendedRequest</code> class. The current <code>Transaction</code> is then converted to a web transaction via a call to <code>setWebRequest</code> which takes the wrapped <code>ExtendedRequest</code> as an argument.</p>
    <p>A call to the database is then made and the response object is generated and wrapped by a class implementing the Java agent API's <code>Response</code> interface. The wrapped response object is passed as an argument to <code>setWebResponse</code> which converts the current <code>Transaction</code> into a web transaction.</p>
    <p>Once the web request and response are set, a call to <code>addOutboundResponseHeaders</code> adds the headers to the response. This must be called after <code>setWebRequest</code> and <code>setWebResponse</code>, which together provide the agent with the inbound request headers and a place to record the outbound headers.</p>
    <p>A call to <code>markResponseSent</code> marks the time when the last byte of the response left the server as the current timestamp.</p>
    <pre><code>@Trace(dispatcher = true)
    @Override
    public Response serve(IHTTPSession session) {
        // Obtain a reference to the current Transaction
        Transaction tx = NewRelic.getAgent().getTransaction();
        // Set the name of the current transaction
        NewRelic.setTransactionName("Custom", "ExternalHTTPServer");

        // Wrap the Request object
        ExtendedRequest req = new RequestWrapper(session);


        // Set the request for the current transaction and convert it into a web transaction
        tx.setWebRequest(req);

        queryDB();
        Response res = newFixedLengthResponse("&#x3C;html>&#x3C;body>&#x3C;h1>SuccessfulResponse&#x3C;/h1>\n&#x3C;/body>&#x3C;/html>\n");

        // Set the response for the current transaction and convert it into a web transaction
        tx.setWebResponse(new ResponseWrapper(res));

        // Instruct the transaction to write the outbound response headers
        tx.addOutboundResponseHeaders();
    
        // Mark the time when the response left the server
        tx.markResponseSent();

        return res;
    }

</code></pre>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJjbGFzc05hbWUiLCJ2YWx1ZSI6ImZyZXEtbGluayJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoic2VydmVyLXJlc3BvbnNlLWludGVyZmFjZSJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ0aXRsZSIsInZhbHVlIjoiSW1wbGVtZW50IHRoZSBKYXZhIGFnZW50IEFQSSdzIFJlc3BvbnNlIEludGVyZmFjZSJ9XQ==">
    <div data-prop-text="title">Implement the Java agent API's Response Interface</div>
    <p>An implementation of the Java agent API's <code>Response</code> Interface is used to wrap the response object of the server, which in this example is of type <code>fi.iki.elonen.NanoHTTPD.Response</code>. The response is passed into the constructor of the <code>ResponseWrapper</code> class and implementations of the <code>getStatus</code>, <code>getStatusMessage</code>, <code>setHeader</code>, <code>getContentType</code> and <code>getHeaderType</code> methods are provided.</p>
    <p>The <code>getHeaderType</code> method returns a <code>HeaderType</code> enum that can either be <code>HeaderType.HTTP</code> or <code>HeaderType.MESSAGE</code>, as defined by the Java agent API. In this example the external call protocol is HTTP, so <code>HeaderType.HTTP</code> is returned.</p>
    <pre><code>// Implement Response interface to create a wrapper for the outgoing Response object
    public class ResponseWrapper implements com.newrelic.api.agent.Response {

        private final Response httpResponse;

        public ResponseWrapper(Response httpResponse) {
            this.httpResponse = httpResponse;
        }

        @Override
        public int getStatus() throws Exception {
            return 200;
        }

        @Override
        public String getStatusMessage() throws Exception {
            return null;
        }

        @Override
        public void setHeader(String name, String value) {
            httpResponse.addHeader(name, value);
        }

        @Override
        public String getContentType() {
            return "";
        }

        @Override
        public HeaderType getHeaderType() {
            return HeaderType.HTTP;
        }
    }

</code></pre>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJjbGFzc05hbWUiLCJ2YWx1ZSI6ImZyZXEtbGluayJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoic2VydmVyLWV4dGVuZHJlcXVlc3QifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6IkV4dGVuZCB0aGUgSmF2YSBhZ2VudCBBUEkncyBFeHRlbmRlZFJlcXVlc3QgY2xhc3MifV0=">
    <div data-prop-text="title">Extend the Java agent API's ExtendedRequest class</div>
    <p>A subclass of the Java agent API's <code>ExtendedRequest</code> class is used to wrap the request object of the server, which in this example is of type <code>IHTTPSession</code>. The request is passed into the constructor of the <code>RequestWrapper</code> class, which provides implementations of the <code>getRequestURI</code>, <code>getHeader</code>, <code>getRemoteUser</code>, <code>getParameterNames</code>, <code>getParameterValues</code>, <code>getAttribute</code>, <code>getCookieValue</code>, <code>getHeaderType</code>, and <code>getMethod</code> methods.</p>
    <p>The <code>getHeaderType</code> method returns a <code>HeaderType</code> enum that can either be <code>HeaderType.HTTP</code> or <code>HeaderType.MESSAGE</code>, as defined by the Java agent API. In this example the external call protocol is HTTP so <code>HeaderType.HTTP</code> is returned.</p>
    <pre><code>// Extend ExtendedRequest class to create a wrapper for the Request object
    class RequestWrapper extends ExtendedRequest {
        private IHTTPSession session;

        public RequestWrapper(IHTTPSession session) {
            super();
            this.session = session;
        }

        @Override
        public String getRequestURI() {
            return session.getUri();
        }

        @Override
        public String getHeader(String name) {
            return session.getHeaders().get(name.toLowerCase());
        }

        @Override
        public String getRemoteUser() {
            return null;
        }

        @SuppressWarnings("rawtypes")
        @Override
        public Enumeration getParameterNames() {
            return Collections.enumeration(session.getParms().keySet());
        }

        @Override
        public String[] getParameterValues(String name) {
            return new String[]{session.getParms().get(name)};
        }

        @Override
        public Object getAttribute(String name) {
            return null;
        }

        @Override
        public String getCookieValue(String name) {
            return null;
        }

        @Override
        public HeaderType getHeaderType() {
            return HeaderType.HTTP;
        }

        @Override
        public String getMethod() {
            return session.getMethod().toString();
        }
    }

</code></pre>
  </div>
  <div data-component="Collapser" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJjbGFzc05hbWUiLCJ2YWx1ZSI6ImZyZXEtbGluayJ9LHsidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJpZCIsInZhbHVlIjoic2VydmVyLWV4dGVybmFsLWNhbGwifSx7InR5cGUiOiJtZHhBdHRyaWJ1dGUiLCJuYW1lIjoidGl0bGUiLCJ2YWx1ZSI6Ikluc3RydW1lbnQgYW4gZXh0ZXJuYWwgY2FsbCB0byBhIGRhdGFzdG9yZSJ9XQ==">
    <div data-prop-text="title">Instrument an external call to a datastore</div>
    <p>This method makes an external call to the SQLite database that is created by the client. The <code>@Trace</code> annotation tells the agent to track this method as part of an existing transaction as started by the <code>serve</code> method.</p>
    <p>A reference to the current <code>TracedMethod</code> is obtained via a call to <code>getTracedMethod</code>. A <code>DatastoreParameters</code> object is then created using the builder pattern. The <code>ExternalParameters</code> object is then passed as an argument to the <code>reportAsExternal</code> method, which has the effect of reporting the <code>TracedMethod</code> as an external datastore call.</p>
    <pre><code>@Trace
    public void queryDB() {
        Connection c = null;
        Statement stmt = null;
        try {
            Class.forName("org.sqlite.JDBC");
            c = DriverManager.getConnection("jdbc:sqlite:/tmp/test.db");
            c.setAutoCommit(false);
            System.out.println("Opened database successfully");

            stmt = c.createStatement();
            ResultSet rs = stmt.executeQuery("SELECT * FROM COMPANY;");
            while (rs.next()) {
                int id = rs.getInt("id");
                String name = rs.getString("name");
                int age = rs.getInt("age");
                String address = rs.getString("address");
                float salary = rs.getFloat("salary");
                System.out.println("ID = " + id);
                System.out.println("NAME = " + name);
                System.out.println("AGE = " + age);
                System.out.println("ADDRESS = " + address);
                System.out.println("SALARY = " + salary);
                System.out.println();
            }
            rs.close();
            stmt.close();
            c.close();
        } catch (Exception e) {
            System.err.println(e.getClass().getName() + ": " + e.getMessage());
            System.exit(0);
        }
        // Obtain a reference to the method currently being traced
        TracedMethod method = NewRelic.getAgent().getTracedMethod();

        // Create a DatastoreParameters object and report a call to an external datastore service
        method.reportAsExternal(
                DatastoreParameters
                        .product("sqlite")
                        .collection("test.db")
                        .operation("select")
                        .instance("localhost", 8080)
                        .databaseName("test.db")
                        .build());
    }

</code></pre>
  </div>
</div>
