
<p>A properly instrumented system gives teams full visibility into the impact of the changes they make. Capturing tangible, measurable metrics from before and after each change allows teams to optimize changes in isolation, and reduce the impact to other ongoing changes.</p>
<h2>Prerequisite</h2>
<p>Before starting this tutorial, be sure to complete the <a href="/docs/using-new-relic/welcome-new-relic/measure-devops-success/establish-objectives-baselines">Establish objectives and baselines</a> tutorial and set the appropriate KPI targets for your applications.</p>
<h2>1. Integrate measurements into your development process</h2>
<p>With appropriate measurements incorporated into all phases of your development cycle, you can surface errors and performance issues before your customers uncover them. As your application teams plan their work, use your <a href="/docs/using-new-relic/welcome-new-relic/measure-devops-success/establish-team-dashboards">KPI dashboards</a> in daily stand-ups and other planning meetings to analyze necessary debugging work, assess whether recent deployments were successful, and to prioritize other work efforts. When development and operations teams use dashboards during planning and discussions, they ensure that they’re consistently incorporating feedback about customer experiences and reliability risks into their development efforts.</p>
<p>For proper testing, ensure that instrumentation in your pre-production environments is in parity with your production environments. Use dashboards to compare the environments and verify that the code and infrastructure changes you make are correct across them, and eliminate any anomalies before pushing code to production.</p>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJ0aXAifV0=">
  <p>Beyond using instrumentation to measure software performance, also use it to analyze team efficiency. For example, <a href="https://blog.newrelic.com/2016/03/21/sending-alerts-data-to-insights/">send Alerts data to Insights</a>, and use <a href="https://docs.newrelic.com/docs/insights/nrql-new-relic-query-language/using-nrql/introduction-nrql">NRQL</a> to calculate mean time to repair (MTTR) by subtracting the difference in event timestamps as the <code>current_state</code> of each event changes from OPEN to ACKNOWLEDGED to CLOSED.</p>
  <p>Or <a href="https://docs.newrelic.com/docs/insights/insights-data-sources/custom-data/insert-custom-events-insights-api">push events into Insights</a> from a source code management (SCM) system like GitHub, and calculate the amount of time it takes a code change to go live by comparing the timestamp of a commit event to that of a deploy event. Plotted over time, this could become a KPI in an organization’s DevOps transformation.</p>
</div>
<h2>2. Add automated deployment markers</h2>
<p>It’s important to track deployments and how the impact of the code and infrastructure changes you make affect customer experience. <a href="https://docs.newrelic.com/docs/apm/new-relic-apm/getting-started/introduction-new-relic-apm">New Relic APM</a>’s deployment markers feature allows you to <a href="https://docs.newrelic.com/docs/apm/new-relic-apm/maintenance/record-deployments">record deployments</a> for each application. A deployment marker is an event indicating that a deployment happened, and it's paired with metadata available from your SCM system (such metadata typically includes the user, revision, change-log, etc.). APM displays a vertical line, or “marker”, on charts and graphs at the deployment event’s timestamp. When you hover over the line, APM displays the associated metadata for that deployment.</p>
<p>
  <img src="./images/APM_web-transaction-times_Catalyst.png" alt="APM_web-transaction-times_Catalyst.png" title="APM_web-transaction-times_Catalyst.png">
</p>
<p><strong><a href="https://rpm.newrelic.com/apm">rpm.newrelic.com/apm</a> > (select an app) > Monitoring > Overview</strong></p>
<p>APM also provides a chronological list of deployments of your application, and additional metrics, such as error rate and Apdex from the time of the deployment, are available as well.</p>
<p>
  <img src="./images/APM_Deployments_Catalyst.png" alt="APM_Deployments_Catalyst.png" title="APM_Deployments_Catalyst.png">
</p>
<p><strong><a href="https://rpm.newrelic.com/apm">rpm.newrelic.com/apm</a> > (select an app) > Events > Deployments</strong></p>
<p>Tracking deployments is an invaluable way to determine the root cause of immediate, long-term, or gradual degradations in your application.</p>
<div data-component="Callout" data-prop="W3sidHlwZSI6Im1keEF0dHJpYnV0ZSIsIm5hbWUiOiJ2YXJpYW50IiwidmFsdWUiOiJ0aXAifV0=">
  <p>New Relic recommends that you make <strong>POST</strong> requests to the New Relic REST API as the final step of a successful CI/CD deployment as described in the <a href="https://docs.newrelic.com/docs/apm/new-relic-apm/maintenance/record-deployments">API documentation</a>. The following tools have integrations or plugins available to help automate this:</p>
  <ul>
    <li><a href="https://supermarket.chef.io/cookbooks/newrelic">Chef</a> (see <code>newrelic_depoyment</code>)</li>
    <li><a href="https://wiki.jenkins.io/display/JENKINS/New+Relic+Deployment+Notifier+Plugin">Jenkins</a></li>
    <li><a href="https://docs.ansible.com/ansible/latest/modules/newrelic_deployment_module.html">Ansible</a></li>
  </ul>
</div>
<h2>3. Test your pipeline with Infrastructure</h2>
<p>An important part of a successful DevOps transformation is a cultural shift toward smaller, more frequent changes to your code and infrastructure. After you complete the first two steps of this tutorial, begin to test and gather appropriate performance insights about your deployment pipeline to more clearly understand the impact of the changes you make.</p>
<p>Code changes should be as small as possible in terms of the number of lines of code and source files you change. Changes should also involve as few team members as possible. This makes it much easier to identify issue owners and determine root causes if errors occur.</p>
<p>Similarly, infrastructure changes should also have as small a footprint as possible to minimize the number of applications affected by each change. <a href="https://docs.newrelic.com/docs/infrastructure/new-relic-infrastructure/installation/install-infrastructure-linux">New Relic Infrastructure</a> helps you see when an infrastructure change has caused a spike in issues, as shown in the following example:</p>
<p>
  <img src="./images/Infra_hosts_events_0.png" alt="New Relic infrastructure hosts events" title="Infra_hosts_events.png">
</p>
<p><strong><a href="https://one.newrelic.com">one.newrelic.com/apm</a> > Infrastructure > Hosts</strong></p>
<p>For cloud infrastructure changes or larger code changes, consider using a <a href="https://martinfowler.com/bliki/BlueGreenDeployment.html">blue/green deployment</a> strategy. APM supports <a href="https://docs.newrelic.com/docs/agents/manage-apm-agents/app-naming/use-multiple-names-app">multiple app names</a> which fits this model quite nicely.</p>
<p>To implement this strategy:</p>
<ol>
  <li>Deploy a version of your application to existing infrastructure using a rollup app name that signifies it as the “blue” version (or control version).</li>
  <li>Deploy a new version of your application to a subset of the infrastructure (or an alternate set of infrastructure) with a rollup name that signifies this as the “green” version (or experimental version).</li>
  <li>Ensure that traffic is routed appropriately between both versions.</li>
  <li>Compare established KPI dashboards of both versions against one another.</li>
  <li>Optimize the new version accordingly to meet your KPI targets.</li>
  <li>When you’re satisfied with the application’s performance, deploy the new version across your infrastructure using the original app name, and consider this the new baseline for any future changes you'll make to the application.</li>
</ol>
