
<p>As IT departments seek to optimize their cloud applications, they are decomposing application monoliths into microservices. A microservice architecture is an approach that delivers a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms. Following a service-oriented architecture (SOA) model, each service should offer public API interfaces to any other service in the environment.</p>
<p>Fragmenting applications into their most basic services enables the continuous delivery/deployment of large, complex applications by removing barriers and silos that previously lengthened the application release cycle. It also enables an organization to evolve its technology stack for modern cloud environments and to operate at internet-scale.</p>
<p>With microservices, app developers can build, manage, scale, and reuse services independently, resolve issues faster, increase the rate of deployments, and ultimately deliver an enhanced end-user experience.</p>
<p>This quest to use microservices to optimize applications is an iterative process. We recommend the following six steps, using the New Relic platform, to ensure an effective migration path to microservices.</p>
<h2>1. Deploy instrumentation on all application tiers and components [#deploy]</h2>
<p>In order to determine which components of an application can be broken into microservices, you need to deploy instrumentation on all tiers and components of the target application. This will allow you to determine baseline application performance, quantify transaction volumes, and gather other key metrics that will determine where you begin your microservice journey.</p>
<p>Specifically, you should:</p>
<ul>
  <li>Monitor your web apps with <a href="https://docs.newrelic.com/docs/apm">APM</a>. See <a href="https://docs.newrelic.com/docs/agents/manage-apm-agents/installation/compatibility-requirements-new-relic-agents">Compatibility and requirements for New Relic agents and products</a> to learn precise compatibility details for each supported language, and then <a href="https://docs.newrelic.com/docs/agents/manage-apm-agents/installation/install-agent">install the APM agent</a> on your application stack. Steps for installing APM agents vary based on language.</li>
  <li>Monitor your compute resources with <a href="https://docs.newrelic.com/docs/infrastructure">Infrastructure</a>. See <a href="https://docs.newrelic.com/docs/infrastructure/new-relic-infrastructure/getting-started/compatibility-requirements-new-relic-infrastructure">Compatibility and requirements for Infrastructure</a> for supported operating systems and environments. You can also instrument other products and services with <a href="https://docs.newrelic.com/docs/integrations/host-integrations/host-integrations-list">on-host integrations</a>.</li>
</ul>
<p>In some cases, it may be helpful to use <a href="https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/custom-instrumentation">custom instrumentation</a> to gather detailed performance metrics that aren’t necessarily required in the course of normal application monitoring. For example, you may want to add custom instrumentation to key controllers that are candidates for decomposition to gather very granular response time and throughput information.</p>
<h2>2. Use key metrics to identify components that you can migrate to microservices [#key-metrics]</h2>
<p>Once you have instrumented your application, you can begin to identify which components are strong candidates to migrate to microservices.</p>
<p>It is important to consult with colleagues who have written, designed, and/or maintained the application, to supplement the context that your baseline data provides. Their experience and recommendations will help to guide the decomposition effort.</p>
<p>In addition, you should analyze objective metrics such as transaction call volume and response time. These metrics will point to components in your monolithic application that are heavily called and/or are responding slowly, which means that they are adding disproportionate load to the monolith, possibly degrading application performance and end-user experience.</p>
<p>As microservices, it will be easier to regularly improve and optimize these components. As a result, you will be able to break away and eliminate the most pressing bottlenecks from your monolithic application.</p>
<p>
  <img src="./images/APM_transaction_catalyst.png" alt="Transactions displayed in New Relic APM" title="APM_transaction_catalyst.png">
</p>
<p><strong><a href="https://one.newrelic.com">one.newrelic.com</a> > APM > Transactions</strong>: Identify which components are slowing you down.</p>
<h2>3. Use deployment markers to establish app performance baselines [#deployment-markers]</h2>
<p>Breaking down monolithic applications into a microservice architecture is typically an iterative project. You will be continually identifying monolithic components that can be decomposed into microservices, and then optimizing them as business and technology requirements dictate. Deployment tracking lets you quickly see, in a side-by-side comparative view, how architectural and code changes impact your application’s performance. You can then use this information to direct future development efforts and to demonstrate return on investment to the business. You should make deployment markers an integral part of the development process by adding them into your build/deployment process automation.</p>
<p>You can view instructions on setting up deployment markers on the <a href="https://docs.newrelic.com/docs/apm/applications-menu/events/deployments-page">Deployments page in APM</a>.</p>
<p>
  <img src="./images/deployment_markers.png" alt="deployment_markers.png" title="deployment_markers.png">
</p>
<p><strong><a href="http://one.newrelic.com">one.newrelic.com</a> > APM > Events > Deployments</strong>: Understand how deployments affect your performance.</p>
<h2>4. Implement the new microservice-based architecture, and measure the success of your application development processes [#implement]</h2>
<p>Your developers should now have marching orders for which application components to migrate to microservices. It’s important for these teams to embrace modern software development practices to support your overarching business and technology initiatives. Measuring process improvements is vital to driving alignment and velocity.</p>
<p>You should instrument your build/test pipeline using <a href="/docs/insights/insights-data-sources/custom-data/send-custom-data-insights">custom events</a>. This will allow you to gather data about:</p>
<ul>
  <li>The rate at which new code is moving through the pipeline</li>
  <li>Quality metrics (for example, what percent of the code is passing tests, if there is automated testing involved)</li>
  <li>The rate of new deployments via deployment markers</li>
</ul>
<p>These quantitative data points will allow development and operations teams to visualize the adoption of new processes, measure development team productivity, and assess whether these new processes are moving the needle positively or negatively.</p>
<p>
  <img src="./images/new_processes.png" alt="new_processes.png" title="new_processes.png">
</p>
<p><strong><a href="https://one.newrelic.com">one.newrelic.com</a> > Dashboards</strong>: Visualize the adoption of new processes with dashboards.</p>
<h2>5. Create a dashboard to monitor KPIs [#dashboard]</h2>
<p>Once you have determined that the application and its microservices components are (somewhat) production-ready, compare the performance of your new, modern application to the monolithic application (either today or how it performed pre-migration). This will allow you to demonstrate success and to highlight areas for improvement.</p>
<p>Key KPIs to monitor and compare include Response Time, Error Rate, Transaction Call Volume, Operational Cost, Availability, and Apdex.</p>
<p>
  <img src="./images/perf_comparison.png" alt="perf_comparison.png" title="perf_comparison.png">
</p>
<p><strong><a href="https://one.newrelic.com">one.newrelic.com</a> > Dashboards</strong>: Build KPI dashboards to view all your indicators in one place.</p>
<h2>6. Create a new baseline to use for comparisons [#new-baseline]</h2>
<p>At this point, you have migrated components of your monolithic application to microservices, and you are now empowered with up-to-date data on how your new application is performing compared to your legacy application. Now you have a new launching point for evaluating which other components of your application can be decomposed into microservices, or which microservice components require more performance tuning.</p>
