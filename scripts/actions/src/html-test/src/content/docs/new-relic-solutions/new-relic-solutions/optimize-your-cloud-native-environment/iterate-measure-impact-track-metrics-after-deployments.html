
<p>Proper instrumentation gives teams full visibility into the impact of the changes they make in a system. Capturing tangible, measurable metrics from before and after each change allows teams to optimize changes in isolation and reduce the impact to other work happening in the system.</p>
<h2>Prerequisite</h2>
<p>Before starting this tutorial, complete the <a href="https://docs.newrelic.com/docs/establish-objectives-baselines-define-team-slos">Establish objectives and baselines</a>.</p>
<h2>1. Integrate measurements into your development process [#integrate-measurements]</h2>
<p>With appropriate measurements incorporated into all phases of your development cycle, you can surface errors and performance issues before your customers uncover them. As your application teams plan their work, use your <a href="https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/measure-devops-success/establish-team-dashboards">KPI dashboards</a> in daily stand-ups and other planning meetings to analyze necessary debugging work, assess whether recent deployments were successful, and prioritize other work efforts. When development and operations teams use dashboards during planning and discussions, they ensure that they're consistently incorporating feedback about customer experiences and reliability risks into their development efforts.</p>
<p>For proper testing, ensure that instrumentation in your pre-production environments is in parity with your production environments. Use dashboards to compare the environments and verify that the code and infrastructure changes you make across them are correct, and eliminate any anomalies before pushing code to production.</p>
<p>Beyond using instrumentation to measure software performance, also use it to analyze team efficiency. For example, <a href="https://blog.newrelic.com/2016/03/21/sending-alerts-data-to-insights/">send Alerts data to Insights</a> and use <a href="https://docs.newrelic.com/docs/insights/nrql-new-relic-query-language/using-nrql/introduction-nrql">NRQL</a> and external integrations to calculate mean time to repair (MTTR) by subtracting the difference in event timestamps as the current state of each event changes from OPEN to ACKNOWLEDGED to CLOSED.</p>
<p>Or <a href="https://docs.newrelic.com/docs/insights/insights-data-sources/custom-data/insert-custom-events-insights-api">push events into Insights</a> from a source code management (SCM) system like GitHub, and calculate the amount of time it takes a code change to go live by comparing the timestamp of a commit event to that of a deploy event. Plotted over time, this could become a KPI in a DevOps transformation.</p>
<h2>2. Add automated deployment markers [#deployment-markers]</h2>
<p>It's important to track deployments and the impact code and infrastructure changes have on your end-user experience. Using deployment markers in <a href="https://docs.newrelic.com/docs/apm/new-relic-apm/getting-started/introduction-new-relic-apm">New Relic APM</a>, you can <a href="https://docs.newrelic.com/docs/apm/new-relic-apm/maintenance/record-deployments">record deployments</a> for each application.</p>
<p>A deployment marker is an event indicating that a deployment happened, and it's paired with metadata available from your SCM system (for example, the user, revision, or change-log). APM displays a vertical line, or “marker,” on charts and graphs at the deployment event's timestamp. When you hover over the line, APM displays the associated metadata for that deployment.</p>
<p>
  <img src="./images/APM_web-transaction-times_Catalyst.png" alt="APM_web-transaction-times_Catalyst.png" title="APM_web-transaction-times_Catalyst.png">
</p>
<p><strong><a href="https://rpm.newrelic.com/apm">rpm.newrelic.com/apm</a> > (select an app) > Monitoring > Overview</strong></p>
<p>APM also provides a chronological list of deployments of your application. Additional metrics, such as error rate and Apdex from the time of the deployment, are available as well.</p>
<p>
  <img src="./images/APM_Deployments_Catalyst.png" alt="APM_Deployments_Catalyst.png" title="APM_Deployments_Catalyst.png">
</p>
<p><strong><a href="https://rpm.newrelic.com/apm">rpm.newrelic.com/apm</a> > (select an app) > Events > Deployments</strong></p>
<p>Tracking deployments is a valuable way to determine the root cause of immediate, long-term, or gradual degradations in your application.</p>
<p>New Relic recommends that you make POST requests to the New Relic REST API as the final step of a successful CI/CD deployment as described in the <a href="https://docs.newrelic.com/docs/apm/new-relic-apm/maintenance/record-deployments">API documentation</a>. The following tools have integrations or plugins available to help automate this:</p>
<ul>
  <li><a href="https://supermarket.chef.io/cookbooks/newrelic">Chef</a> (see newrelic_deployment)</li>
  <li><a href="https://wiki.jenkins.io/display/JENKINS/New+Relic+Deployment+Notifier+Plugin">Jenkins</a></li>
  <li><a href="https://docs.ansible.com/ansible/latest/modules/newrelic_deployment_module.html">Ansible</a></li>
  <li><a href="https://forge.puppet.com/claranet/newrelic/readme">Puppet</a></li>
</ul>
<h2>3. Test your pipeline with Infrastructure</h2>
<p>An important part of optimizing your cloud native environment is a making a cultural shift toward smaller, more frequent changes to your code and infrastructure. After you complete the first two steps of this tutorial, begin to test and gather appropriate performance insights about your deployment pipeline to more clearly understand the impact of the changes you make.</p>
<p>Code changes should be as small as possible in terms of the number of lines of code and source files you change. Changes should also involve as few team members as possible. This makes it much easier to identify issue owners and determine root causes if errors occur.</p>
<p>Similarly, infrastructure changes should also have as small a footprint as possible to minimize the number of applications affected by each change. <a href="https://docs.newrelic.com/docs/infrastructure/new-relic-infrastructure/installation/install-infrastructure-linux">New Relic Infrastructure</a> helps you see when an infrastructure change has caused a spike in issues, as shown in the following example:</p>
<p>
  <img src="https://docs.newrelic.com/sites/default/files/thumbnails/image/Infra_hosts_events.png" alt="Infra_hosts_events.png" title="Infra_hosts_events.png">
</p>
<p><strong><a href="https://infrastructure.newrelic.com/apm">infrastructure.newrelic.com/apm</a> > Hosts</strong></p>
<p>For cloud infrastructure changes or larger code changes, consider using a <a href="https://martinfowler.com/bliki/BlueGreenDeployment.html">blue/green deployment</a> strategy. APM supports <a href="https://docs.newrelic.com/docs/agents/manage-apm-agents/app-naming/use-multiple-names-app">multiple app names</a>, which is a good fit for this model.</p>
<p>To implement this strategy:</p>
<ol>
  <li>Deploy a version of your application to existing infrastructure using a rollup app name that signifies it as the “blue” version (or control version).</li>
  <li>Deploy a new version of your application to a subset of the infrastructure (or an alternate set of infrastructure) with a rollup name that signifies this as the “green” version (or experimental version).</li>
  <li>Ensure that traffic is routed appropriately between both versions.</li>
  <li>Compare established KPI dashboards of both versions against one another.</li>
  <li>Optimize the new version accordingly to meet your KPI targets.</li>
  <li>When you're satisfied with the application's performance, deploy the new version across your infrastructure using the original app name, and consider this the new baseline for any future changes you'll make to the application.</li>
</ol>
