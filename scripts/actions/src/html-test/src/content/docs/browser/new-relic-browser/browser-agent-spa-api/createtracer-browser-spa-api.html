
<h2>Syntax</h2>
<pre><code>newrelic.interaction().createTracer(string $name[, function $callback])
</code></pre>
<p>Times sub-components of a SPA interaction separately, including wait time and JS execution time.</p>
<h2>Requirements</h2>
<p>Agent version <a href="https://docs.newrelic.com/docs/release-notes/new-relic-browser-release-notes/browser-agent-release-notes">nr-963</a> or higher.</p>
<h2>Description</h2>
<p>This method provides a way to time sub-components of a SPA interaction separately in Browser. Each sub-component will measure:</p>
<ul>
  <li>Wait time until callback is executed</li>
  <li>JS execution time of callback once it is invoked</li>
</ul>
<p>This method also can be used to bridge the asynchronous gap created by uninstrumented async methods.</p>
<p>If the current interaction is saved, New Relic will create a <a href="/docs/insights/explore-data/attributes/browser-default-attributes-insights#browsertiming-attributes"><code>BrowserTiming</code> event</a> in New Relic One. To view this timing information in Browser:</p>
<ol>
  <li>Go to <strong><a href="https://one.newrelic.com">one.newrelic.com</a>, click on Browser > (select a SPA app) > Page views</strong>.</li>
  <li>From <strong>Page views</strong>, select a browser interaction, then select the <strong>Breakdowns</strong> tab.</li>
</ol>
<p>The <code>createTracer()</code> method returns a wrapped callback method, which you must invoke from your code. The returned wrapped callback will do three things when invoked:</p>
<ol>
  <li>Records the end of the async portion of the custom tracer.</li>
  <li>Runs the original callback passed to <code>createTracer()</code> with the same arguments and context.</li>
  <li>Times the execution of the original callback.</li>
</ol>
<p>A <a href="/docs/insights/explore-data/attributes/browser-default-attributes-insights#browserinteraction-attributes"><code>BrowserInteraction</code></a> that runs <code>createTracer()</code> will create a <a href="/docs/insights/explore-data/attributes/browser-default-attributes-insights#browsertiming-attributes"><code>BrowserTiming</code> event</a>. Any new XHRs or custom traces created during the callback will be included as part of the interaction.</p>
<p>An interaction will not be considered complete until all of its tracers finish. This is what allows tracers to wrap async functions that the Browser agent does not handle by default.</p>
<h2>Parameters</h2>
<div data-component="Table" data-prop="W10=">
  <div>
    <div>
      <div>
        <p>Parameter</p>
      </div>
      <div>
        <p>Description</p>
      </div>
    </div>
  </div>
  <div>
    <div>
      <div>
        <p><code>$name</code></p>
        <p><em>string</em></p>
      </div>
      <div>
        <p>Required. This will be used as the name of the tracer.</p>
        <p>If you do not include a name, Browser does not add a node to the interaction tree. The callback time will be attributed to the parent node.</p>
      </div>
    </div>
    <div>
      <div>
        <p><code>$callback</code></p>
        <p><em>function</em></p>
      </div>
      <div>
        <p>Optional. A callback that contains the synchronous work to run at the end of the async work. To execute this callback, call the wrapper function returned using <code>createTracer()</code>.</p>
      </div>
    </div>
  </div>
</div>
<h2>Return values</h2>
<p>Returns a method that wraps the original callback. When this method is invoked, it calls the original callback and ends the async timing.</p>
<h2>Examples</h2>
<h3>Create tracer [#tracer-example]</h3>
<p>If you simply want to measure how long a particular JavaScript function call takes, you can pass the function to <code>createTracer()</code> as a callback. This immediately invokes the returned wrapper callback:</p>
<pre><code>newrelic
  .interaction()
  .createTracer('customSegment', function myCallback () {
    // ... do your work ...
  })()
</code></pre>
<p>In this scenario, the resulting custom tracer will have a negligible async wait duration, as well as a synchronous duration equal to the execution time of <code>myCallback()</code>.</p>
<h3>Trace an uninstrumented asynchronous API [#asynch-api-tracer]</h3>
<p>By default, the Browser agent wraps many of the most common asynchronous functions (such as <code>setTimeout()</code>). However, there are some functions that are not handled automatically (for example, <code>requestAnimationFrame()</code>). In addition, some cases occur where causality cannot easily be determined (for example, a custom RPC implementation over websockets). For these cases, you can use <code>createTracer()</code> to make sure callbacks to these uninstrumented functions are considered part of the interaction.</p>
<p>Using <code>createTracer()</code> is not necessary for any async scheduling system based on async APIs that are wrapped natively by the Browser agent, such as <code>setTimeout()</code>, <code>setImmediate()</code>, <code>Promise()</code>, <code>fetch()</code>, and <code>XMLHttpRequest()</code>. The async boundaries created by these APIs will be bridged automatically by the Browser agent.</p>
<p>In the example code below, you have a function, <code>doAsyncWork()</code>, that accepts a callback and executes it asynchronously at some point in the future. You want to measure both the time between when you invoke <code>doAsyncWork()</code> and when the callback begins executing (the async wait time), and the time taken to run the callback (the synchronous callback time).</p>
<pre><code>var wrappedCallback = newrelic
  .interaction()
  .createTracer('customSegment', doTheWork)

doAsyncWork(wrappedCallback)

function doTheWork() {
  // ... do your work ...
}
</code></pre>
<p>Here is a timeline of events for tracer timing:</p>
<p>
  <img src="./images/spa-trace-async-timeline.png" alt="SPA async timeline image" title="spa-trace-async-timeline.png">
</p>
