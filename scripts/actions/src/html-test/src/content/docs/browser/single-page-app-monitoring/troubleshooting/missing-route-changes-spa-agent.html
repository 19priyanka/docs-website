
<h2>Problem</h2>
<p>You are using the Browser Pro + SPA agent, but you are not seeing all of the <code>route change</code> browser interactions you expect.</p>
<p>We are aware that this can be frustrating. Our goal in summer 2020 is to reevaluate the SPA feature functionality, making it simpler and more reliable, starting with the methods we use to detect and capture route changes. Additionally, we plan to add new frameworks and use cases to our testing suite based on your feedback and examples. Likely this work will include new APIs as well as framework-specific plug-ins. Check our <a href="/docs/release-notes/new-relic-browser-release-notes/browser-agent-release-notes">release notes</a> for the latest updates.</p>
<h2>Solution</h2>
<h3>Short term solutions</h3>
<p>To make sure all route changes are captured, you can use our <a href="/docs/browser/new-relic-browser/browser-agent-spa-api">SPA interaction() API</a>. Using the interaction API will categorize the <code>BrowserInteraction</code> event (in the <code>category</code> attribute) as <code>custom</code> rather than a <code>route</code> change if no route change is in fact detected.</p>
<p>If your framework is exposing events that represent router activity, you can use custom instrumentation in these events. Here is an example using our API with the Angular router:</p>
<pre><code>router.events.subscribe( (event: Event) => {
 if (event instanceof NavigationStart) {
 let i = newrelic.interaction()
 i.setName(event.url)
 i.save()
 }
});
</code></pre>
<p>In this example, the <code>router</code> object is an instance of the Angular router (from the <code>@angular/router</code> module). The <code>setName</code> call sets the name attribute of the <code>BrowserInteraction</code> event to the new URL, and the <code>save</code> call ensures that the interaction is captured. You will need to adapt this for the needs of your own application’s framework.</p>
<p>If your framework does not provide routing events, then you can add this code in the event handler of the original interaction event such as <code>click</code>):</p>
<pre><code>myButton.addEventListener('click', function () {
 let i = newrelic.interaction()
 i.setName(‘new URL')
 i.save()
});
</code></pre>
<p><strong>Recommendation:</strong> If you do not have access to router events nor the interaction event handler, implement this as soon as possible in code that you know is the result of a user interaction.</p>
<p>An alternative to using the SPA API is to capture routes as <code>PageAction</code> events. <a href="/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action"><code>PageAction</code> events</a> can be used to capture any custom data. We recommend this option as a fallback in case using the SPA interaction API does not work as expected, or to completely separate the custom instrumentation from built-in <code>BrowserInteraction</code> events.</p>
<p>Both of these solutions can ensure these events are captured, either as a <code>BrowserInteraction</code> event or as a <code>PageAction</code> event. However, they will not address recording the correct duration and related AJAX calls.</p>
<h3>Support</h3>
<p>If this solution does not resolve your issue, please file a support ticket, and have the following information available:</p>
<ul>
  <li>For situations where you are seeing most route changes, but none for a particular route change you expect, attempt to evaluate the difference in the implementation of the code for that particular route. Is there something non-standard or unique about that route that you could provide to our support team?</li>
  <li>Document the frameworks and any libraries that might be of interest. If this is a new problem, has anything changed in your environment that has led to these interactions suddenly not being tracked?</li>
  <li>Note the Browser agent version you are using. If you are more than a few releases behind, we will recommend that you update to the latest release, as we may have already resolved a similar issue.</li>
  <li>Be aware that due to the complexity of diagnosing these issues, the team will likely need access to an environment and code that demonstrates the problem for testing and research.</li>
</ul>
<h2>Cause</h2>
<p>The Browser product attempts to be framework agnostic, as well as support coding best practices. However, there are often edge cases that will be missed that lead to you not collecting the route changes you expect. The implementation is based on instrumenting most common asynchronous browser APIs. There are cases when a web application uses some asynchronous API or uses custom or third-party code that we do not instrument, and this can result in inaccurate or missed route changes.</p>
