
<h2>2.15.0</h2>
<h3>New Features</h3>
<ul>
  <li>
    <p>Added support for monitoring <a href="https://github.com/mongodb/mongo-go-driver/">MongoDB</a> queries with the new <a href="https://godoc.org/github.com/newrelic/go-agent/_integrations/nrmongo">_integrations/nrmongo</a> package.</p>
    <ul>
      <li><a href="https://github.com/newrelic/go-agent/blob/master/_integrations/nrmongo/example/main.go">Example application</a></li>
      <li><a href="https://godoc.org/github.com/newrelic/go-agent/_integrations/nrmongo">Full godocs Documentation</a></li>
    </ul>
  </li>
  <li>
    <p>Added new method <code>Transaction.IsSampled()</code> that returns a boolean that indicates if the transaction is sampled. A sampled transaction records a span event for each segment. Distributed tracing must be enabled for transactions to be sampled. <code>false</code> is returned if the transaction has finished. This sampling flag is needed for B3 trace propagation and future support of W3C Trace Context.</p>
  </li>
  <li>
    <p>Added support for adding <a href="https://github.com/openzipkin/b3-propagation">B3 Headers</a> to outgoing requests. This is helpful if the service you are calling uses B3 for trace state propagation (for example, it uses Zipkin instrumentation). You can use the new <a href="https://godoc.org/github.com/newrelic/go-agent/_integrations/nrb3">_integrations/nrb3</a> package's <a href="https://godoc.org/github.com/newrelic/go-agent/_integrations/nrb3#NewRoundTripper"><code>nrb3.NewRoundTripper</code></a> like this:</p>
    <pre><code>// When defining the client, set the Transport to the NewRoundTripper. This
// will create ExternalSegments and add B3 headers for each request.
client := &#x26;http.Client{
  Transport: nrb3.NewRoundTripper(nil),
}

// Distributed Tracing must be enabled for this application.
// (see https://docs.newrelic.com/docs/understand-dependencies/distributed-tracing/enable-configure/enable-distributed-tracing)
txn := currentTxn()

req, err := http.NewRequest("GET", "http://example.com", nil)
if nil != err {
  log.Fatalln(err)
}

// Be sure to add the transaction to the request context.  This step is
// required.
req = newrelic.RequestWithTransactionContext(req, txn)
resp, err := client.Do(req)
if nil != err {
  log.Fatalln(err)
}

defer resp.Body.Close()
fmt.Println(resp.StatusCode)
</code></pre>
  </li>
</ul>
