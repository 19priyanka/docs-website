---
title: 意思決定に伴うアプライドインテリジェンスの相関ロジックの変更
metaDescription: 'For New Relic''s Applied Intelligence, how to configure the correlation logic using decisions.'
translationType: machine
---

import nraiDecisionsIndex from 'images/NRAI_Decisions_Index.png'

import iiDecisionsStatistics from 'images/II---Decisions---Statistics.png'

import screenShot20200727At65041Am from 'images/Screen-Shot-2020-07-27-at-6.50.41-AM.png'

import topology4 from 'images/topology-4.png'

import topology1 from 'images/topology-1.png'

import topology2 from 'images/topology-2.png'

import topology3 from 'images/topology-3.png'

当社の [インシデント・インテリジェンス](/docs/new-relic-one/use-new-relic-one/new-relic-ai/get-started-incident-intelligence) は、ロジックを使用して [インシデント](/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/get-started-incident-intelligence#issue-feed) を相関させます。これらのロジックを"デシジョンと呼んでいます。" 当社にはデシジョンが組み込まれていますが、インシデント・インテリジェンス **デシジョン** UIページで独自のデシジョンを作成、カスタマイズすることができます。デシジョンを最適に設定すればするほど、インシデントイベントのグループ化と相関性が高まり、ノイズが減り、オンコールチームのコンテキストが向上します。

<img
  title="NRAI_Decisions_Index.png"
  alt="Our AI correlates data related to incidents in the Decisions UI."
  src={nraiDecisionsIndex}
/>

**[one.newrelic.com](https://one.newrelic.com) > Applied Intelligence> Incident Intelligence> Decisions**: 私たちのUIは、それぞれの決定がインシデントとどのように相関しているかを示しています。

## キーコンセプト

ここでは、意思決定のロジックを理解するためのキーコンセプトをご紹介します。

* **相関とは"相関とは" どのように機能するのか** 様々なアラートエンジンから Incident Intelligence に送られてくる [インシデントイベント](/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/get-started-incident-intelligence#issue-feed) について、直近に作成されたアクティブなインシデントを相関させることができます。相関は、任意の判断基準が満たされるたびに2つのイベント間で発生します。相関に利用できるすべてのイベントは、可能なすべてのペアの組み合わせで互いにテストされ、"欲張りなマージ" が実行されます。つまり、インシデントAがBと相関して [イシュー](/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/get-started-incident-intelligence#issue-feed) になり、インシデントBがインシデントCと相関して別のイシューになった場合、ABとBCも一緒にマージされ、A、B、Cを含む単一のイシューになります。
* **デシジョンで使用できるロジックの種類は？** 高いレベルでは、デシジョンでは、時間（イベント間の期間）、頻度（イベントの数）、コンテキスト（メタデータ構造& 値）、 [トポロジー](#topology) （エンティティの関係）に基づいてロジックを定義することができます。

## 積極的な意思決定の見直し [#decisions]

決定事項は、Incident Intelligenceがインシデントをどのように相関させるかを決定します。デフォルトでは、Incident Intelligenceの使用を開始すると、幅広いグローバルな決定事項が有効になります。

既存の決定事項を見直すこと。

1. **[one.newrelic.com](https://one.newrelic.com)** にアクセスし、 **Alerts& AI** をクリックします。左側のナビゲーションで、 **Incident Intelligence** の下で、 **Decisions** をクリックします。
2. アクティブなデシジョンのリストを確認します。課題間の相関関係を作成するルールロジックを確認するには、決定事項をクリックします。
3. デシジョンが相関したインシデントの例を見るには、 **Recent correlations** タブをクリックします。
4. これらのグローバルな決定を有効または無効にするには、他のオプションを使用してください。

あなたの決定は、その有効性や他のベストプラクティスについて日常的に分析され、レビューのための推奨事項が添付されます。

### 相関関係の統計 [#correlation]

パターン認識アルゴリズムを使用して提供される提案された判断を使用する場合でも、独自の相関ロジックを追加する場合でも、以下のように、相関率、ノイズ除去の改善、相関問題の発生数などの洞察を得ることができます。

UIからは、基礎となるNRQLクエリ [、このデータから独自のカスタムチャートやダッシュボードを作成して見ることができます。](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language)

<img
  title="Decisions Statistic Block"
  alt="Decisions Statistic Block"
  src={iiDecisionsStatistics}
>
  [](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language)
</img>

[****](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language)**[one.newrelic.com](https://one.newrelic.com) > Applied Intelligence> Incident Intelligence> Decisions**: decisions UIからの統計情報の例です。

統計の定義をいくつかご紹介します。

* Correlation rate（相関率）。相関関係が発生している場合とそうでない場合の割合。
* 相関関係にある課題の合計。別の課題と相関している課題の数。
* ノイズの低減。コレレーション後の課題数の合計をコレレーション前の課題数の合計で割ったもの。
* Correlation reason（相関理由）。どの決定が最も問題に相関しているかを示しています。

### 提案された決定事項の使用 [#suggested-decisions]

提案された決定事項の種類に関する情報

* **決断の提案：** 選択したソースからのデータは、ノイズを減らすためにパターンを継続的に検査されます。データにパターンが観察されると、これらのイベントが将来的に相関関係を持つようにするための決定が提案されます。
* **提案される意思決定の高速化：** アラートをしばらくの間使用していた場合、ソースにアラートポリシーを追加すると、その履歴データを使用してパターン認識ステップを高速化し、意思決定の提案を最大30%高速化することができます。

**Decisions** UIページの統計ブロックの下にある、提案された決定事項をクリックしてください。提案された決定事項の背景にある論理、その決定事項がお客様に役立つと思われる理由、その決定事項の推定相関率などの情報が表示されます。

<img
  title="Suggested Decision Block"
  alt="Suggested Decision Block"
  src={screenShot20200727At65041Am}
/>

**[one.newrelic.com](https://one.newrelic.com) > Applied Intelligence> Incident Intelligence> Decisions**: Suggested decision block

相関率を確認するのに十分なデータがない場合は、割合の推定値のすぐ下にあるリンクから、より強力な結果を得るために追加できる他のソースを確認することができます。 **注意：月間のインシデント数が5000件未満の場合は、おそらく提案された決定事項はないでしょう。**

提案された決定事項を追加するには、 **決定事項を有効にする** をクリックすると、他の決定事項と並んで有効に表示されます。その決定が自分のニーズに合わない場合は、 **「却下」** をクリックしてください。

## カスタムディシジョンの作成 [#customize]

独自のカスタムデシジョンを構築することで、ノイズを減らし、相関性を高めることができます。デシジョンの構築を開始するには、 **[one.newrelic.com](https://one.newrelic.com)** にアクセスし、 **Alerts& AI** をクリックします。左側のナビゲーションでは、 **Incident Intelligence** の下で、 **Decisions** をクリックし、次に **Add a decision** をクリックします。そのUIの使い方のヒントは、以下の表にあります。

デシジョンを構築する際、ステップ1、2、3はそれぞれ任意ですが、デシジョンを作成するためには少なくとも1つは定義しなければなりません。

<table id="decision-guidelines">
  <thead>
    <tr>
      <th style={{ width: "250px" }}>
        オプション
      </th>

      <th>
        説明
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        ステップ1：データのフィルタリング
      </td>

      <td>
        このステップでは、フィルターを定義します。相関関係は2つのインシデント間で発生することを忘れないでください。フィルターが定義されていない場合、着信したすべてのインシデントが判断の対象となります。

        インシデントの最初のセグメント（またはバケット）、およびインシデントの2番目のセグメントに対してフィルタを定義します。フィルター演算子の種類は、部分一致から [正規表現マッチング](#regex) まであり、必要なインシデントイベントをターゲットにし、そうでないものを除外するのに役立ちます。

        セグメント1とセグメント2の間のイベントペアのすべての組み合わせが、次のステップの決定に使用されます。
      </td>
    </tr>

    <tr>
      <td>
        ステップ2：文脈相関
      </td>

      <td>
        データのフィルタリングが完了したら、インシデントのコンテキストを比較する際に使用するロジックを定義します。以下の方法でイベントを相関させることができます。

        * 標準演算子による属性値の比較
        * [類似性アルゴリズムを用いた属性値の類似性](#algorithms)
        * 属性値 [regex with capture groups](#regex)
        * 類似性やクラスタリングアルゴリズムを用いたインシデント全体の比較
      </td>
    </tr>

    <tr>
      <td>
        ステップ3：トポロジー相関
      </td>

      <td>
        [トポロジー相関図](#topology) は現在限定公開中です。この機能を有効にするには、お客様のアカウント担当者にお問い合わせください。この機能を有効にするには、まず、NerdGraph `aiTopologyCollector` （ [NerdGraph GraphiQL explorer](https://api.newrelic.com/graphiql) で aiTopology を検索）を介してトポロジーデータを取り込む必要があります。これにより、トポロジーに関連するあらゆる判断が、あなたのトポロジーデータと照合されるようになります。 [トポロジーの相関関係の設定について詳しくはこちら](#topology).
      </td>
    </tr>

    <tr>
      <td>
        名前をつける
      </td>

      <td>
        ディシジョンロジックを設定したら、それを認識できる名前と説明を付けます。これは通知やUIの他の領域で使用され、どの決定が原因で一組のインシデントが相関関係にあるかを示すために使われます。
      </td>
    </tr>

    <tr>
      <td>
        詳細設定
      </td>

      <td>
        オプションです。詳細設定エリアでは、イベントを相関させる際の判定の動作をさらにカスタマイズすることができます。各設定にはデフォルト値があるので、カスタマイズは任意です。

        * **Time window**: コレレーションの対象となる時間を作成した2つのインシデント間の最大時間を設定します。
        * **Issue priority**: デフォルトの優先度設定（`inherit priority` ）を上書きし、インシデントが相関している場合に、より高いまたは低い優先度を追加します。
        * **Frequency**: 決定をトリガーするためにルールロジックを満たす必要のあるインシデントの最小数を変更します。
        * **Similarity**: ルールロジックで `similar to` 演算子を使用している場合、アルゴリズムのリストから選択し、その感度を設定することができます。これは、決定に含まれるすべての `similar to` 演算子に適用されます。
      </td>
    </tr>
  </tbody>
</table>

### 類似性アルゴリズム [#algorithms]

ここでは、私たちが使用している類似性アルゴリズムの技術的な詳細について説明します。

<CollapserGroup>
  <Collapser
    id="levenshtein-distance"
    title="レーベンシュテイン距離"
  >
    この尺度は、ホスト名のように静的なスキーマと固定長の短い文字列を比較するのに便利です。レーベンシュタイン距離は、編集距離としても知られています。

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            詳細
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            使用方法
          </td>

          <td>
            2つの文字列の間のレーベンシュタイン距離は、ある文字列から他の文字列への1文字の編集の最小数である。許可されている編集操作は、削除、挿入、および置換です。

            Applied Intelligenceのデシジョンのデフォルトの類似性のしきい値は、編集距離が3です。この値は、デシジョンビルダーの **Advanced mode** で変更できます。
          </td>
        </tr>

        <tr>
          <td>
            使うタイミング
          </td>

          <td>
            この尺度は、静的なスキーマと固定長の比較的短い文字列を比較する場合に最も有効です。一般的な用途としては、スペルチェッカー、計算生物学、音声認識などがあります。
          </td>
        </tr>

        <tr>
          <td>
            例
          </td>

          <td>
            `number/bumble: 3 (number → bumber → bumblr → bumble)`

            `try/lying: 2 (try → rying → lying)`

            `strong/through: 4 (strong → htrong → throng → throug → through)`
          </td>
        </tr>

        <tr>
          <td>
            欠点
          </td>

          <td>
            レーベンシュタイン距離は、デフォルトでは文字列の長さを考慮して正規化されていません。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="fuzzy-score"
    title="ファジィ・スコア"
  >
    この指標は、同じ長さの文字列を比較する際に便利で、同じ接頭辞があれば相関性の良い指標となります。

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            詳細
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            使用方法
          </td>

          <td>
            ファジー・スコア・アルゴリズムは、文字列間の文字のマッチに対して"ポイント" を割り当てることで機能します。

            * 一致したキャラクターで1ポイント

            * その後の試合で2つのボーナスポイント

              ファジィスコアが高いほど、2つの文字列の類似性が高いことを示しています。
          </td>
        </tr>

        <tr>
          <td>
            使うタイミング
          </td>

          <td>
            Fuzzy scoreは、同じで比較的短い（理想的には&lt;5文字）接頭辞を持つ文字列に対して最も有効です。最小限の保証スコアは、 `(length(expected prefix) * 3) - 2` となります。
          </td>
        </tr>

        <tr>
          <td>
            例
          </td>

          <td>
            例： `Decisions / dcsions`

            `d:1`

            `c: 1`

            `i 1`

            `s:2`

            `o:1`

            `n:1`

            `シ：2`

            `io: 2`

            `オン：2`

            `ns：2`

            `=15ポイント`
          </td>
        </tr>

        <tr>
          <td>
            欠点
          </td>

          <td>
            1つ目の文字列の最初の文字が2つ目の文字列の中に見つからない場合、ポイントは加算されません。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="fuzzy-wuzzy-ratio"
    title="ファジィ・ワジィ比率"
  >
    この指標は、同じような長さの文字列を比較するのに便利です。

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            詳細
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            使用方法
          </td>

          <td>
            **fuzzy wuzzy** 類似性測定のファミリーは、 [SeatGeek](https://chairnerd.seatgeek.com/fuzzywuzzy-fuzzy-string-matching-in-python/) が開発したもので、複数のプラットフォームで異なるラベルを持つ同じイベントのチケットを見つけるのに役立ちます。2 つの文字列の fuzzy wuzzy 比率はパーセンテージで表され、数値が大きいほどより類似した文字列であることを示します。これは、Pythonのdifflibに含まれる [SequenceMatcherアルゴリズム](https://docs.python.org/3/library/difflib.html) に基づいています。
          </td>
        </tr>

        <tr>
          <td>
            使うタイミング
          </td>

          <td>
            Fuzzy wuzzy ratioは、非常に短い文字列（例：ホスト名）や非常に長い文字列（例：イベントの説明）に有効で、特に同じような長さの文字列を比較する場合に有効です。
          </td>
        </tr>

        <tr>
          <td>
            欠点
          </td>

          <td>
            このアルゴリズムは、3〜10単語の文字列に効果的に使用するには、あまりにも敏感です。fuzzy wuzzyの他の改良点（下記参照）の方が良いかもしれません。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="fuzzzy-wuzzy-partial"
    title="ファジィ・ウジィ・パーシャル・レシオ"
  >
    この指標は、異なる長さの文字列を比較するのに便利です。fuzzy wuzzyアルゴリズムのこの修正は、有効長の制限に対処するのに役立ちます。

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            詳細
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            使用方法
          </td>

          <td>
            fuzzy wuzzy partial ratioでは、短い方の文字列を、長い方の文字列の中の同じ長さの各部分文字列と比較します。最もよく一致する」部分文字列のスコアが、ファジーファジー部分比の決定に使用されます。
          </td>
        </tr>

        <tr>
          <td>
            使うタイミング
          </td>

          <td>
            Fuzzy wuzzy partial ratioは、基本的なfuzzy wuzzyアルゴリズムが失敗するタイプの比較に特に有効です。重要な部分文字列が重なっている可能性のある3〜10個の単語列。
          </td>
        </tr>

        <tr>
          <td>
            例
          </td>

          <td>
            例えば、次のような文字列の間。

            `DevOpsチームとSREチーム`

            `DevOps`

            ... "DevOps" (短い方の文字列、長さ = 6) は、"DevOps and SRE teams" の中の長さ 6 の各部分文字列と比較されます。これらの部分文字列の1つ（"DevOps"）は完全に一致しているので、これらの2つの文字列のファジー・ファジー・パーシャル・レシオは高くなります。
          </td>
        </tr>

        <tr>
          <td>
            欠点
          </td>

          <td>
            fuzzy wuzzyが保守的すぎる場合、fuzzy wuzzyの部分一致は相関関係が予想以上に自由である可能性があります。ニーズに応じて、決定ビルダーで閾値を調整することができます。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="fuzzy-wuzzy-token"
    title="ファジィ・ウォジィ・トークンセット比"
  >
    この指標は、情報が同じ順序ではなく、長さも異なる可能性がある文字列を比較する場合に役立ちます。メッセージや説明文などの文章に適しています。

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            詳細
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            使用方法
          </td>

          <td>
            トークンセットレシオアルゴリズムは、いくつかのステップを経て文字列を比較します。

            1. 各文字列のトークン化（例："DevOps and SRE teams" → "DevOps" "and" "SRE" "teams"、"SRE team and DevOps engineers" → "SRE" "teams" "and" "DevOps" "engineers"）。

            2. 交差するトークンを新しい文字列に結合し、残りのトークンを残す。 (例：交差する。"DevOps", "and", "SRE"; 残りの1: "team"; 残りの2:"team", "engineers")

            3. 各トークングループをアルファベット化（例：「and, DevOps, SRE」、「teams」、「engineers, team」）。

            4. 次の文字列のペアを比較してください。

               1. 交差点グループ
               2. 交差点グループ＋残差1
               3. 交差点群＋残差2

               これらのペア（「ベストマッチ」）からの比較が、ファジィ・ウォジィ・トークンセット比となります。
          </td>
        </tr>

        <tr>
          <td>
            使うタイミング
          </td>

          <td>
            この指標は、類似した文字列に重複する単語があっても、構成が異なる場合に役立ちます。たとえば、同じリソースの異なる課題のイベントの説明などです。
          </td>
        </tr>

        <tr>
          <td>
            欠点
          </td>

          <td>
            fuzzy wuzzyが保守的すぎる場合、fuzzy wuzzy token set matchは相関関係が予想以上に自由である可能性があります。ニーズに応じて決定ビルダーのしきい値を調整することができます。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="Jaro-winkler-distance"
    title="Jaro-Winkler距離"
  >
    この指標は、同じ接頭辞があれば相関関係を強く示すような短い文字列に有効です。

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            詳細
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            使用方法
          </td>

          <td>
            この指標では、2つの文字列の類似性を0～1の尺度で表します。0は類似性がなく（文字列間のマッチング文字数が0）、1は完全に一致することを意味します。Jaro-Winklerの類似度では、次の点が考慮されます。

            * `マッチング`: 文字列の中で同じで似たような位置にある2つの文字。
            * `転置`: 文字列の中で異なる配列順にある文字のマッチング。
            * `prefix scale`: 文字列が最初から一致している場合、Jaro-Winkler距離が有利に調整される（プレフィックスは4文字まで）。
          </td>
        </tr>

        <tr>
          <td>
            使うタイミング
          </td>

          <td>
            この指標は、移調に対してかなり寛容ですが、弦の中で離れた場所にある移調はあまり役に立ちません。

            中程度から長い文字列のJaro-Winklerの類似性に使用する一般的に安全な数値は0.9ですが、より寛容であっても構わない場合（他にもっと具体的な判断材料がある場合）には'~'0.85を使用することができます。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="cosine-distance"
    title="コサイン距離"
  >
    この指標は、大きなテキストブロック（例えば、事件の説明文など）を比較するために最もよく使われ、類似性を簡単に視覚化することができます。

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            詳細
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            使用方法
          </td>

          <td>
            比較している各テキストブロックについて、ブロック内の各ユニークな単語のカウントを表すベクトルが計算されます。結果として得られるベクトルのコサイン距離は、それらのドットプロダクトをそれらのマグニチュードの積で割ったものです。
          </td>
        </tr>

        <tr>
          <td>
            使うタイミング
          </td>

          <td>
            この測定法は、長いテキストブロックを比較する際に最も有効です。特に、個々の単語の違いやスペルミスではなく、テキスト全体を考慮して比較する場合に適しています。
          </td>
        </tr>

        <tr>
          <td>
            例
          </td>

          <td>
            ```
            It is not length of life, but depth of life.
            Depth of life does not depend on length.
            ```

            これらの文章の単語数は以下の通りです。

            `it 1 0`

            `は0 1`

            `not 1 1`

            `長さ 1 1`

            `の2 1`

            `ライフ 2 1`

            `が、1 0`

            `デプス1 1`

            `does 0 1`

            `dependence 0 1`

            `on 0 1`

            そして、その数をベクトルで表したものがこちらです。

            ```
            [1, 0, 1, 1, 2, 2, 1, 1, 0, 0, 0]
            [0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1]
            ```

            これらのベクトルのコサイン距離は約0.9です（1が最も高い類似性）。
          </td>
        </tr>

        <tr>
          <td>
            欠点
          </td>

          <td>
            コサイン距離は、単語の小さな文字の違いが重要ではない状況では、あまり有用ではありません。また、コサイン距離は、テキストブロック内の単語の順序を無視します。
          </td>
        </tr>
      </tbody>
    </table>

    cosine distanceの実装については、こちらの [詳細なウォークスルー](http://blog.christianperone.com/2013/09/machine-learning-cosine-similarity-for-vector-space-models-part-iii/) を参照してください。
  </Collapser>

  <Collapser
    id="hamming-distance"
    title="ハミング距離"
  >
    この対策は、静的なスキーマを持つ短いテキストには有効ですが、同じ長さの文字列にしか効果がありません。

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            詳細
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            使うタイミング
          </td>

          <td>
            ハミング距離は、比較する文字列が同じ長さであることを必要とします。これは、2つの文字列の違いがタイプミスによるものかもしれない場合や、長さがわかっている2つの属性を比較したい場合に便利な類似性指標です。例えば、以下のような場合です。データセンターus01のアプリケーションmyappのディスクスペースが少ない

            データセンターの変更に耐性を持たせたい場合は、ハミング距離を4に設定する必要があります。
          </td>
        </tr>

        <tr>
          <td>
            例
          </td>

          <td>
            "編集距離の簡易版" レーベンシュタイン距離のような指標で、2つの文字列間のハミング距離は、文字列の中で一致しない（同じ位置にある）文字の数である。例えば、以下の文字列では、ハミング距離は2です。

            ```
            flowers / florets
            ```
          </td>
        </tr>

        <tr>
          <td>
            欠点
          </td>

          <td>
            上記の例では、データセンターではなくアプリケーション名が変更された場合にも相関関係が発生します。距離が長くなると、ハミング距離の有用性は急激に低下します。このような理由から、1～2文字の置換に寛容な場合（または文字列の長さが一致しない場合）よりも少しでも複雑な場合は、別の類似性測定を使用する必要があります。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="Jaccard-distance"
    title="ジャカード距離"
  >
    この指標は、説明文やインシデント全体など、大きなブロックのテキストを比較するのに便利です。

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            詳細
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            使用方法
          </td>

          <td>
            完全に似ているものを0、全く似ていないものを1としたパーセンテージで表示される距離を以下の式で算出します。

            ```
            1 - [(# of characters in both sets) / (# of characters in either set) * 100]
            ```

            つまり、共有されているキャラクターの数を、共有されているキャラクターと共有されていないキャラクターの合計数で割ったものが、ジャカード距離です。ジャカード距離が0.1ということは、2つのインシデント間で異なるキャラクターが10%以下であることを意味します。
          </td>
        </tr>

        <tr>
          <td>
            使うタイミング
          </td>

          <td>
            ジャカード距離は、非常に解釈しやすく、特に大規模なデータセットを持つケースで有効です。例えば、2つのインシデント全体（1つの属性ではなく）の類似性を比較する場合などです。
          </td>
        </tr>

        <tr>
          <td>
            欠点
          </td>

          <td>
            データセットが小さい場合や、データが欠損している場合には効果がありません。また、文字セットの並べ替えがあってもJaccard distanceには影響しないので、誤検出を防ぐために注意が必要です。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>

## Regex演算子 [#regex]

[決定事項を構築する際、](#customize) 利用可能な演算子は以下の通りです。

* `contains (regex)`: used in [ステップ1：データのフィルタリング](#customize).
* `正規表現の一致`: [で使用 ステップ2：文脈の相関関係](#customize)

デシジョン・ビルダーは、正規表現について、これらの文書 [で説明されている基準に従っています](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html) 。

### ステップ1のRegex [#regex-step-1]

正規表現が真であると判定するためには、属性値（評価対象のデータ）全体が、指定された正規表現と一致する必要があります。キャプチャーされたグループは使用できますが、明示的には評価されません。

例えば、属性値が `foobarbaz` であれば、これらの例は基準を満たしており、真と判定されます。

* `foo.jp`
* `^.*バズ`
* `\w+`

### ステップ2のRegex [#regex-step-2]

正規表現が真であるとテストするためには、インシデント 1 とインシデント 2 の属性値全体がマッチに含まれている必要があります。また、キャプチャされた各グループ（ `( )` の括弧内の表現）は、両方の値（インシデント1とインシデント2の属性）に存在し、同じ値を持つ必要があります。

* キャプチャしたグループの数は、両方のインシデント属性で同じでなければなりません。
* 各グループは、属性値間で対応するグループと等しくなければなりません。インシデント1の属性値で最初に捕捉されたグループの値は、インシデント2の属性値で最初に捕捉されたグループの値と等しくなります。

例えば、属性値1が `abc-123-xyz` であり、属性値2が `abc-777-xyz` である場合、 `(˶ˆ꒳ˆ˵ ) (?:˶ˆ꒳ˆ˵ )` が基準を満たすことになります。

* 値全体が表現にマッチします。
* 第1と第3のキャプチャグループは、それぞれ同じ値を持っています。
* 2つ目のグループは、 `?:` を使用してキャプチャされていません。この場合、値全体が一致しますが、キャプチャグループの比較には使用されていません。

### 旗について [#flags]

デフォルトでは、どのフラグも有効ではありません。ディシジョン・ビルダーの正規表現に含めると便利なフラグをいくつか紹介します。

* CASE_INSENSITIVE: (?i)
* MULTILINE: (?m)
* DOTALL：(?s)

これらの各フラグの機能と実装に関する詳細な注意点については、 [field detail](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#field.detail) を参照してください。

## 相関アシスタント [#assistant]

コレレーションアシスタントを使用すると、 [インシデント](/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/get-started-incident-intelligence#issue-feed) をより迅速に分析し、ディシジョンロジックを作成し、そのロジックをシミュレーションでテストすることができます。コレレーションアシスタントを使用するには

1. **one.newrelic.com** から、 **Alerts& AI** をクリックし、 **Issues& Activity** をクリックし、 **Incidents** のタブをクリックします。
2. 相関させたいインシデントのボックスをチェックします。次に、インシデントリストの下部で、 **Correlate incidents** をクリックします。
3. インシデントを相関させるための最良の結果を得るには、頻度の割合が低い共通の属性を選択してください。 [頻度の使用についての詳細はこちら](#frequency-tips).
4. **Simulate** をクリックすると、データの最後の週に新しい決定を行った場合に考えられる効果を確認できます。
5. 相関ペアの例をクリックして、それらの相関関係が必要かどうかを判断します。
6. シミュレーションされた内容が気に入れば、 **Next** をクリックし、決定した内容を名前と説明で表します。
7. シミュレーションの結果、潜在的なインシデントが多すぎる場合は、意思決定に必要な属性やインシデントのセットを変えて、別のシミュレーションを実行するとよいでしょう。 [シミュレーションについて詳しくはこちら](#simulations).

### 属性分析 [#frequency-tips]

ここでは、UIに表示される2種類の属性分析について説明します。

* **共通の属性**: この分析では、選択したすべてのインシデント間でまったく同じ属性や値を単純にハイライトします。

* **似ている属性**: 類似性分析では、距離が3のLevenshteinアルゴリズムを使用して、3以下の文字変更を行った場合に値が同じになる属性を見つけます。その他の詳細

  * 数値や一文字の値は、結果から除外されます。
  * 2つのインシデントを選択する必要があります。3つ以上のインシデントを選択した場合、類似性分析は行われません。

最適な意思決定を行うためには、インシデントでの頻度が低い共通の属性を選択することをお勧めします。ここでは、頻度の低い属性と高い属性の選択が意思決定に与える影響を理解するためのヒントをご紹介します。

* **低頻度：** 例として、頻度欄が0％の属性は、ユニークな識別子や、先月のデータで最近報告されたばかりの属性である可能性が高いです。頻度の低い属性を選択すると、ほとんどのイベントと相関がない可能性があります。
* **高頻度:** 一方、頻度が100%の属性は、すべてのデータに存在する属性です。これらの属性を選択すると、すべてのイベントが関連付けられます。

デフォルトでは、頻度の低い属性が上に来るようにソートされています。属性の頻度の割合をクリックすると、過去1ヶ月間にその属性について報告された値の分布についての詳細情報が表示されます。

### シミュレーション活用のヒント [#simulations]

相関アシスタント [は、一連のインシデントを使用して、それらのインシデントに共通する属性や、類似した値を持つ属性を特定します。イベントが相関していることを示す良い指標と思われる属性を選択し、意思決定のシミュレーションを行います。シミュレーションでは、データの最後の1週間に対してロジックをテストし、実際の例に加えて、どのような相関関係が発生したかを表示します。](#assistant)

[シミュレーションの結果が良ければ、実際の意思決定の作成を続けます。シミュレーションで有用な相関関係が見られない場合は、別の属性を選択してシミュレーションをやり直します。](#assistant)

[ここでは、シミュレーション作成時に表示されるデシジョンプレビュー情報の内訳をご紹介します。](#assistant)

* * **潜在的相関率**: この決定が影響を与えたであろうテスト済みインシデントの割合。

  * **Total created incidents**: この決定によってテストされたインシデントの数。

  * **Total estimated correlated incidents**: この決定が相関したであろうインシデントの推定数。

  * **インシデントの例**: この決定が相関関係を持つであろうインシデントペアのリスト。これらをクリックすると、すべての属性と値を横に並べて比較することができ、相関関係が望ましいかどうかを判断するのに役立ちます。

[気に入った結果が得られるまで、属性を変えて何度もシミュレーションを行います。準備ができたら、UIの指示に従って決定内容を保存します。](#assistant)

## [トポロジー相関 [#topology]](#assistant)

[トポロジー」とは何を意味するのでしょうか？New Relic の Applied Intelligence では、トポロジーとはサービスマップを表現したもので、インフラストラクチャ内のサービスやリソースが互いにどのように関連しているかを表しています。](#assistant)

[](#assistant)[カスタムディシジョン](#build-decision) を作成する際には、当社のトポロジー相関を使用することができます。トポロジー相関は、インシデントソース間の関係を見つけ、 [インシデント](/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/get-started-incident-intelligence#issue-feed) が相関すべきかどうかを判断します。トポロジー相関は、相関関係の品質とその発見速度を向上させるように設計されています。

### 要件 [#topology-requirements]

**Topology Correlationは現在限定公開されています。** Requirements:

* New Relic の担当者からトポロジー機能へのアクセス権を与えられる。
* New Relicの1組織1環境につき10K頂点までとする。

### トポロジー相関はどのように機能するのですか？ [#topology-explained]

<img
  title="topology-4.png"
  alt="New Relic topology explained 4"
  src={topology4}
/>

<figcaption>
  このサービスマップでは、ホストとアプリが頂点であり、それらの関係を示す線がエッジです。
</figcaption>

トポロジーの相関関係は、2つの主要なコンセプトに基づいています。

* **バーテックス**: バーテックスは監視対象のエンティティを表します。インシデントイベントの発生源であり、問題となる症状を記述するものです。頂点には、エンティティのGUIDやその他のIDなどの属性（キー／バリュー・ペア）が設定されており、それによって入ってくるインシデント・イベントと関連付けることができます。
* **Edges**: エッジとは、2つの頂点間の接続のことです。辺は頂点間の関係を表します。

トポロジーを設定するには、 [NerdGraph API](#create-topology-graph) を使用します。しかしその前に、インシデントを相関させるためにトポロジーがどのように使われているかを理解しておく必要があるでしょう。

1. まず、New Relic は関連するすべてのインシデントを収集します。これには、 [decision-logic steps 1 and 2](#build-decision) が真であり、かつ詳細設定で定義された時間ウィンドウ内にあるインシデントが含まれます。

<img
  title="topology-1.png"
  alt="New Relic topology explained 1"
  src={topology1}
/>

<figcaption>
  この例では、点線の選択のすべてのインシデントがこれらの要件を満たしています。[ステップ1と2で決定ロジックを](#build-decision)通過し、[決定ロジックのステップ2](#build-decision)で行われたすべてのコンテキスト比較が真です。
</figcaption>

2. 次に、各インシデントを、頂点の定義属性とインシデントの利用可能な属性を用いて、 [トポロジーグラフ](#create-topology-graph) の頂点に関連付けることを試みます。

<img
  title="topology-2.png"
  alt="New Relic topology explained 2"
  src={topology2}
/>

<figcaption>
  インシデントをトポロジグラフの情報に関連付ける手順の例を次に示します。
</figcaption>

3. 次に、インシデントに関連した頂点のペアを、"トポロジカルに依存する" 演算子を使ってテストし、これらの頂点が互いに接続されているかどうかを判断します。この演算子は、2つの頂点を5ホップ以内で結ぶパスがグラフ内に存在するかどうかをチェックする。

<img
  title="topology-3.png"
  alt="New Relic topology explained 3"
  src={topology3}
/>

4. その後、インシデントは相関関係にあり、問題は統合されます。

### インシデントイベントに属性を追加 [#add-attributes]

インシデントは、頂点の定義属性を使用して頂点に接続されます（ [Topology explained](#topology-explained) のトポロジー例では、各頂点は一意の値を持つ定義属性"CID" を持っています）。次にApplied Intelligenceは、その属性に一致する頂点を見つけます。

頂点に使用したい定義属性がインシデントイベントにまだない場合、いくつかの方法で追加することができます。

1. **New Relic でエンティティにタグを付ける:** [エンティティにタグを付けることで](/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data) 、これらのタグはアラートによって生成されるインシデントイベントを豊かにします。例えば、エンティティに `CID` と、それに対応するユニークな値をタグ付けした場合、頂点に以下のような定義属性を設定することができます。 `'newrelic/tags/CID' : CID_VALUE`
2. **Facet your data:** [NRQL アラート条件](/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions) を、1 つ以上の [facet](/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions#syntax) を定義して作成すると、データが属性別にグループ化されます。また、発信されるインシデント・イベントは、これらの属性と値で強化されます。インシデントの場合、ファセット化された属性は同じフォーマットに従います： `newrelic/tags/ATTRIBUTE_NAME`

### トポロジーの作成と表示 [#create-topology-graph]

トポロジーを設定したり、既存のトポロジーを見るには、 [NerdGraph topology tutorial](/docs/apis/nerdgraph/examples/topology-nerdgraph-tutorial) をご覧ください。