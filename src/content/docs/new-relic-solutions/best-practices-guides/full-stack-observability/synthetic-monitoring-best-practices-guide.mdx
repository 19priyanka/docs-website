---
title: Synthetic monitoring best practices guide
tags:
  - New Relic solutions
  - Best practices guides
translate:
  - jp
metaDescription: Best practices designed to help you get the most out of New Relic's synthetic monitoring.
redirects:
  - /docs/synthetics/new-relic-synthetics/guides/new-relic-synthetics-best-practices-guide
  - /docs/synthetics/synthetic-monitoring/guides/synthetic-monitoring-best-practices-guide
  - /docs.newrelic.com/docs/new-relic-solutions/best-practices-guides/full-stack-observability/synthetic-monitoring-best-practices-guide
---

Synthetic monitoring—powered by a Selenium-driven Chrome browser—allows you to monitor and test your apps and address issues before they affect your end users. Here are five tips to help you take immediate advantage of its full power.

## 1. Match your monitor type to monitoring need [#add-monitor]

Synthetic monitors are virtual browsers that measure the performance of your website, recording each check in detail. They also capture aggregate numbers for load time, uptime, and average download size, as well as an overview, detailed statistics for each page resource, and downtime incidents.

We have [seven types of synthetic monitors](/docs/synthetics/synthetic-monitoring/getting-started/types-synthetic-monitors) to choose from, depending on what you want to monitor and how you'd like to do it. For example, a [step monitor](/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors#stepmonitor) is a great way to create what essentially functions as a scripted browser without having to write code. If you're looking for programmatic management of your monitors, you can also bulk create, edit, or delete your synthetic monitors with our [NerdGraph API](/docs/apis/nerdgraph/examples/nerdgraph-synthetics-tutorial).

### How to do it [#howto-1]

1. To add a monitor, go to **[one.newrelic.com](http://one.newrelic.com)** > **Synthetics**. If you have an [EU-based account](/docs/using-new-relic/welcome-new-relic/get-started/introduction-eu-region-data-center), go to  **[one.eu.newrelic.com](http://one.eu.newrelic.com)*. Click **Create monitor** at the top right of the page.
    ![](/src/images/synthetics-create-monitor.png)
2. Select a monitor type and then fill in all required fields.
3. You have the option to add tags, change the **Period** or [Runtime version](/docs/synthetics/synthetic-monitoring/using-monitors/new-runtime)(available for simple browser, scripted browser and API monitors), or add a validation string (available for ping and simple browser monitors), or use advanced options, which enable substring monitoring for the following types of response validation:

   * **Verify SSL (for ping and simple browser).** This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax:

     ```sh
     openssl s_client -servername <var>{YOUR_HOSTNAME}</var> -connect <var>{YOUR_HOSTNAME</var>}:443 -CApath /etc/ssl/certs > /dev/null
     ```

   * **Bypass HEAD request (for ping monitors).** This option skips the default HEAD request and instead uses the GET verb with a ping check. GET requests will always happen if the HEAD request fails.
   * **Redirect is Failure (for ping).** If a redirect result occurs when `Redirect is Failure` is enabled, your synthetic monitors categorize it as a failure (rather than following the redirect and checking the resulting URL).

4. Select the locations where you want your monitor to run. It is recommended to select at least three locations to avoid false positives. In other words, if at least one location returns a successful result then the endpoint must be up and triggering of an alert can be avoided.
5. Depending on the monitor type, choose to either Save monitor, Validate, or Write script.
6. You'll be taken to the [Summary page](#summary-page) where results will start to appear as they are received.

## 2. Get a quick summary of how a monitor is running [#summary-page]

TBD, screenshots, what's useful on this page?

Once on the Summary page, you'll be presented with the most relevant information to assist you in determining the status of this monitor. If an alert has triggered and created an active incident, click to open the critical alert in a new tab for this monitor, or click to manage alert policies for all monitors at the top of the page.
![](/src/images/synthetics-monitor-critical-alert.png)

## 3. View all monitors on the Synthetics Monitors page [#synthetics-monitors]

Continuous application performance monitoring is essential to ensure that web services are in place, working correctly, and error-free. Synthetic monitoring provides this type of assurance by performing automated tests on your web application for each selected location—noting downtime instances ("violations") and collecting aggregate numbers, results, and detailed statistics for each page resource.

Use the Monitors index page to get a high level view of this information, or select an individual monitor to view the [Summary](/docs/new-relic-one-monitors-index), for ping monitors, or [Overview](/docs/synthetics/new-relic-synthetics/pages/synthetics-overview-page-view-monitors-performance), for simple and scripted monitors, page and get a deeper insight into its performance over time.

### How to view your monitors in the New Relic One: [#howto-2]

<CollapserGroup>
  <Collapser
    id="summary-ui"
    title="New Relic Explorer"
  >
    To view a list of monitors using the New Relic One Monitors index page:

    Go to **[one.newrelic.com](https://one.newrelic.com) > Explorer > Synthetic monitors**.

    For more information, see the documentation about [navigating core UI components](/docs/new-relic-one/use-new-relic-one/get-started/new-relic-one-core-ui-components) in New Relic One.
  </Collapser>

  <Collapser
    id="overview-ui"
    title="Monitors index page"
  >
    To view a list of monitors using the [Monitors index](/docs/synthetics/new-relic-synthetics/pages/synthetics-monitors-index-access-your-monitors) page:

    Go to [**one.newrelic.com**](http://one.newrelic.com/) **> Synthetics**.
  </Collapser>
</CollapserGroup>

## 4. View individual monitor results [#view]

It's not enough to understand how your web apps are performing for your West Coast customers; you need to be able to view how they're performing across the country and around the globe. By taking advantage of synthetic monitors and visiting your [Results](/docs/synthetics/new-relic-synthetics/pages/synthetics-results-access-individual-monitor-runs) page, you can see how everything from development to production affects user experience. You can locate interesting results by sorting the list to identify slow, fast, or other unusual results. Or filter by location to understand how monitor performance varies with geography. (The "Network timings" graph below provides a snapshot of webpage performance over a given period.)

### How to do it: [#howto-3]

1. Go to [**one.newrelic.com**](http://one.newrelic.com/) **> Synthetics** and, from the **Monitors** tab, select your monitor.
2. Select **Monitor > Results**.
3. Gain an up-to-the-minute view of the slowest page loads for every monitored location.

## 5. Understand the load-time impact of each resource [#impact]

Visit the [synthetics Resources](/docs/synthetics/new-relic-synthetics/pages/synthetics-resources-understand-load-times) page to see how each resource on your website—including CSS, JavaScript, images, HTML and more—is affecting your overall load. You can drill into detailed metrics collected at run time, locate performance information for time spent by third-party resources, and identify HTTP response codes for each resource.

### How to do it: [#howto-4]

1. Go to [**one.newrelic.com**](http://one.newrelic.com/) **> Synthetics** and, from the **Monitors** drop-down menu, select your monitor.
2. Select **Monitor > Resources**.

## 6. Configure and develop a scripted browser test [#scripted-test]

Using scripted browsers, you can build complex monitoring workflows using the Selenium JavaScript Webdriver bindings. For instance, you can log in to the application, navigate to a particular link, and wait for a page element to load and add an assertion.

### How to do it: [#howto-5]

1. Go to [**one.newrelic.com**](http://one.newrelic.com/) **> Synthetics**.
2. Choose your monitor type (for example, scripted browser).
3. Enter the name and details of your monitor (for example, Sitename.com scripted browser)
4. Select the locations from which you want your monitor to run (for example, Mumbai, Seoul, Columbus, and Montreal).
5. Choose a frequency to determine how often each location will run your monitor (for example, five minutes).
6. Set a notification method to alert your team when performance violations occur.
7. You are now ready to write your script. (Below is an example script to test performance of newrelic.com and check that certain elements have loaded.)

```js
/**
 * Script Name: scripted browser - next gen runtime
 * Author: New Relic
 * Version: 1.0
 * Purpose: best practices example
 * Reference: https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetic-scripted-browser-reference-monitor-versions-chrome-100
 */

/** CONFIGURATION **/
var assert = require("assert")
var ScriptName = "scripted browser - next gen runtime"
var UserAgent = "default"
// script-wide timeout (ms) for functions: waitForAndFindElement and waitForPendingRequests
// better to fail early if it is expected to take less time than the defaultTimeout
// in order to release the heavy worker thread on the minion for the next job
var DefaultTimeout = 10000                                   // default is 10 seconds to locate page loc
var PageloadTimeout = 60000                                  // a negative value defaults to 180 seconds
$webDriver.manage().setTimeouts({pageLoad: DefaultTimeout})  // sets element load timeout
$webDriver.manage().setTimeouts({pageLoad: PageloadTimeout}) // sets page load timeout

/** VARIABLES **/
var By = $selenium.By
var url = "https://newrelic.com"
var check = "Correlate issues across your entire stack"
var btnPath = "#main-content > article > div.r08-media-playlist.js-r08-media-playlist.r08-media-playlist--margin-64 > div.r08-media-playlist__tablist > "
var loc = {
  main: By.id("main-content"),
  nav: By.className("header-site-nav"),
  issues: By.xpath("//*[@id='main-content']/article/div[11]/div/div[2]/div/div/div/ul/li[1]"),
  what_you_get: [
    { service: 'apm',        selector: By.css(btnPath + "button:nth-child(2)")  },
    { service: 'pixie',      selector: By.css(btnPath + "button:nth-child(3)")  },
    { service: 'codestream', selector: By.css(btnPath + "button:nth-child(4)")  },
    { service: 'ml',         selector: By.css(btnPath + "button:nth-child(5)")  },
    { service: 'logs',       selector: By.css(btnPath + "button:nth-child(6)")  },
    { service: 'errors',     selector: By.css(btnPath + "button:nth-child(7)")  },
    { service: 'infra',      selector: By.css(btnPath + "button:nth-child(8)")  },
    { service: 'npm',        selector: By.css(btnPath + "button:nth-child(9)")  },
    { service: 'browser',    selector: By.css(btnPath + "button:nth-child(10)") },
    { service: 'synthetics', selector: By.css(btnPath + "button:nth-child(11)") },
    { service: 'aiops',      selector: By.css(btnPath + "button:nth-child(12)") }
  ]
}

/** FUNCTIONS **/
// for backwards compatibility with legacy runtimes
async function waitForAndFindElement(locator, timeout) {
  const webElement = await $webDriver.wait(
    $selenium.until.elementLocated(locator),
    timeout,
    "Timed-out waiting for element to be located using: " + locator
  )
  await $webDriver.wait(
    $selenium.until.elementIsVisible(webElement),
    timeout,
    "Timed-out waiting for element to be visible using ${element}"
  )
  return await $webDriver.findElement(locator)
}

/** BEGINNING OF SCRIPT **/
console.log("Starting synthetics script: " + ScriptName)
console.log("Default timeout is set to " + DefaultTimeout / 1000 + " seconds")
console.log("URI: " + url)

// Setting User Agent is not then-able, so we do this first (if defined and not default)
if (UserAgent && 0 !== UserAgent.trim().length && UserAgent != "default") {
  $headers.add("User-Agent", UserAgent)
  console.log("Setting User-Agent to " + UserAgent)
}

// Get browser capabilities and do nothing with it, so that we start with a then-able command
$webDriver
  .getCapabilities()
  .then(function () {})
  // Step 1
  // if an error happens at any step, script execution is halted and a failed result is returned
  .then(function () {
    console.log("1. first step")
    return $webDriver.get(url)
  })
  // Step 2
  .then(function () {
    console.log("2. waitForAndFindElement: ", loc.main.value)
    // verify id for main has loaded
    return waitForAndFindElement(loc.main, DefaultTimeout)
  })
  // Step 3
  .then(function () {
    console.log("3. waitForAndFindElement: ", loc.nav.value)
    // verify site nav has loaded
    return waitForAndFindElement(loc.nav, DefaultTimeout)
  })
  // Step 4
  .then(function () {
    console.log("4. findElement: ", loc.issues.value)
    return $webDriver.findElement(loc.issues, DefaultTimeout)  })
  // Step 5
  .then(function (el) {
    console.log("5. getText")
    return el.getText()
  })
  // Step 6
  .then(function (text) {
    console.log("6. assert.equal: " + text + " == " + check)
    assert.equal(text, check, "validation text not found")
  })
  // Step 7 (if assert is equal)
  .then(function () {
    console.log("7. verify what_you_get:")
    // loop through the what_you_get array
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
    loc.what_you_get.forEach(function (nr, i, arr) {
      let n = i+1
      console.log("  " + n + ". " + nr.service)
      // verify each asset has loaded
      return $webDriver.findElement(nr.selector, DefaultTimeout).catch(function (err) {
        console.error("Failure in Step 7." + n)
        throw err
      })
    })
  })
```
