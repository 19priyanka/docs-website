---
title: "NerdGraph tutorial: Manage log parsing rules"
tags:
  - APIs
  - NerdGraph
  - Examples
  - Logs
metaDescription: How to create, query, and manage log parsing rules with NerdGraph, the New Relic GraphQL explorer.
---

You can use our NerdGraph GraphQL explorer at [api.newrelic.com/graphiql](https://api.newrelic.com/graphiql) to create, query, and manage your [parsing rules](/docs/logs/log-management/ui-data/parsing/) for logs.
This document includes:

* [The parsing rule schema](#data-partition-schema)
* [An example query of parsing rules](#query-data-partition-rules) 
* [How to create a parsing rule](#create-data-partition-rules)
* [How to update a parsing rule](#update-data-partition-rules)
* [How to delete a parsing rule](#delete-data-partition-rules)

## Data parsing schema [#parsing-schema]

Available parsing rule fields include:

**REVIEWER: The parsing doc says all they need is an attribute, value, and Grok pattern. This list comes from the NerdGraph data partition rules tutorial. Do any of these apply to parsing, or completely different? Thanks for confirming!**

<table>
  <thead>
  <tr>
    <th style={{width: "200px"}}>
      Fields
    </th>
    <th>
      Description
    </th>
  </tr>
  </thead>

  <tbody>
  <tr>
    <td>id</td>
    <td>Unique data parsing identifier.</td>
  </tr>
  <tr>
    <td>parsingRules</td>
    <td>The name of the parsing rule.</td>
  </tr>
  <tr>
    <td>description</td>
    <td>A description of what this parsing rule represents.</td>
  </tr>
  <tr>
    <td>lucene</td>
    <td>The matching criteria for this parsing rule. To simplify the matching process, we recommend adding a `logtype` attribute to your logs. For example, you can include the `logtype` for the Grok pattern you are using with a [built-in parsing ruleset](docs/logs/log-management/ui-data/built-log-parsing-rulesets/). However, you are not limited to using `logtype`; any attribute can be used as matching criteria.
    **REVIEWER: Is this right?**
    </td>
  </tr>
  <tr>
    <td>accountId</td>
    <td>The New Relic account ID for the user.</td>
  </tr>
  <tr>
    <td>nrql</td>
    <td>The NRQL query used, if applicable; for example:

      ```
      "SELECT * FROM Log WHERE `logtype` = 'testLogs'"
      ```
    </td>
  </tr>
  <tr>
    <td>createdBy</td>
    <td>The user who created the rule.</td>
  </tr>
  <tr>
    <td>updatedBy</td>
    <td>The user who last updated the rule.</td>
  </tr>
  <tr>
    <td>enabled</td>
    <td>Whether or not this parsing rule is enabled.</td>
  </tr>
  <tr>
    <td>deleted</td>
    <td>Whether or not this parsing rule has been deleted. Deleting a parsing rule does not delete the already routed logs.
    </td>
  </tr>
  </tbody>
</table>

## Example query of log parsing rules [#query-parsing-rules]

This NerdGraph API request example gets all of the parsing rules for a given account. In this example, only a few fields are requested.

```
{
  actor {
    account(id: 123456) {
      logConfigurations {
        dataPartitionRules {
          id
          targetDataPartition
          description
          matchingCriteria {
            attributeName
            matchingOperator
            matchingExpression
          }
        }
      }
    }
  }
}
```



## Create parsing rules [#create-data-partition-rules]

This example creates a new log parsing rule. Before creating the rule, be sure to review the documentation about [log parsing](/docs/logs/log-management/ui-data/parsing/) and [built-in parsing rulesets](/docs/logs/log-management/ui-data/built-log-parsing-rulesets/).

```
mutation {
  logConfigurationsCreateParsingRule(accountId: 123456789, rule: {description: "example parsing rule", enabled: false, grok: "sampleattribute=%{NUMBER:test:int}", lucene: "logtype:testLogs", nrql: "SELECT * FROM Log WHERE `logtype` = 'testLogs'"}) {
    rule {
      id
      enabled
      description
      grok
    }
    errors {
      message
      type
    }
  }
}
```

## Update parsing rules [#update-parsing-rules]

This example updates the parsing rule with the given id `"123"`. The fields that can be updated are `description`, `matchingCriteria`, and `enabled`. All of them are optional, so you only need to use the ones you want to update.

```
{
  "data": {
    "actor": {
      "account": {
        "id": 123456789,
        "logConfigurations": {
          "parsingRules": [
            {
              "accountId": 123456789,
              "createdBy": {
                "email": "myname@company.com",
                "gravatar": "https://secure.gravatar.com/avatar/c0a1829304156d999d123456789012345f",
                "id": 7654321,
                "name": "My Name"
              },
              "deleted": false,
              "description": "Integer Test",
              "enabled": true,
              "grok": "source=%{NUMBER:test:int}",
              "id": "3333",
              "lucene": "\"logtype\":\"integer\"",
              "nrql": "SELECT * FROM Log WHERE `logtype` = 'integer'",
              "updatedAt": "2021-08-23T17:25:06.553Z[UTC]",
              "updatedBy": {
                "email": "myname@company.com",
                "gravatar": "https://secure.gravatar.com/avatar/c0a1829304156d999d123456789012345f",
                "id": 7654321,
                "name": "My Name"
            }
        ]}
      }
    }
  }
}
```
            
## Delete parsing rules [#delete-parsing-rules]

This example deletes a parsing rule. Deleting a parsing rule doesn't delete the already persisted data. The data is retained for a given period of time defined by the `retentionPolicy` field.

```
mutation {
  logConfigurationsDeleteParsingRule(accountId: 123456789, id: "3333") {
    errors {
      message
      type
    }
  }
}
```
