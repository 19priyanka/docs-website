---
title: New runtime transition guide
tags:
  - Synthetics
  - Synthetic monitoring
  - Runtime conversion
metaDescription: "Synthetic monitoring's new runtime requires that you make some changes to your already existing monitors."
---

Synthetic monitoring has a new runtime that affects your public monitors. By converting from the legacy runtime to the new runtime, you improve the backend environment that your public monitors execute from. New synthetic monitors default to using the new runtime. If you've created a synthetic monitor using the legacy runtime, there are extra [configuration steps](#runtime-convert).

Making the switch gives you these features:

* Access to newer versions of Google Chrome, so your scripted browser monitors use browser versions similar to the ones used by your customers. 
* Access to the updated scripted API runtime that uses `Got` node.js library  instead of the deprecated `Request` library. 
* Support for async / await syntax. This simplifies script creation and maintenance, diverging from the old runtime’s `.then` promise chaining.
* Better support for shadow DOM objects.
* [Custom timing library](/docs/synthetics/synthetic-monitoring/scripting-monitors/custom-timing-details) for scripted API monitors.
- Access to  our [NerdGraph API](/docs/apis/nerdgraph/examples/nerdgraph-synthetics-tutorial) to automate the management of your synthetic monitors. 

We recommend updating your synthetic monitors that were created using the legacy runtime to take advantage of these capabilities. We plan to release this new runtime for private monitoring locations later this year.

<Callout variant="important">
Before switching, make sure that you've updated your allow lists to accept network requests from the new runtime’s [public IP ranges](/docs/synthetics/synthetic-monitoring/administration/new-synthetic-public-minion-ips).
</Callout>

## Convert your monitors to the new runtime [#runtime-convert]

Existing monitors default to the runtime used at their time of creation. To prevent your critical monitors from breaking during future end of life processes, we recommend you convert your public monitors sooner rather than later. To convert:

1. Go to [one.newrelic.com](https://one.newrelic.com/nr1-core), click **Synthetics**, then select the monitor you want to edit.
2. From the **Settings** tab, click **General**. 
3. Use the dropdown menu to switch the current runtime view (use Node 16 for scripted API monitors and Chrome 100 for scripted browser monitors). 
4. Click **Validate** to check that your monitors function in the new runtime. Make any script script modifications if needed. 
5. Save.

## Switch to the new runtime from the UI [#runtime-UI]

From the UI, you have the option to toggle between the legacy runtime and the new runtime. While the new runtime is backwards compatible with the legacy runtime, we recommend that you convert to the new environment as soon as possible. 

1. Go to [one.newrelic.com](https://one.newrelic.com/nr1-core), then click **Synthetics**.
2. Click **Create monitor**, then select the public monitor type you want to create.
3. Use the **Runtime** dropdown menu to switch between the legacy and new runtime environment. 
4. Create your monitor. 

## Use NerdGraph to manage your monitors

We have expanded support for synthetic monitors to NerdGraph. By using NerdGraph to manage your monitors, you get: 

* Management of your certificate check monitors, broken links monitors, and step monitors, not previously supported through REST APIs.
* Simplified processes for creating scripted monitors.
* The ability to attach scripts to scripted monitors with only one call, rather than the four calls needed with REST APIs.
* The ability to add tags to your monitors. 

Unlike with REST APIs, NerdGraph lets you programatically create [broken links](#create-broken-links), [step](#create-step), and [certificate check](create-certificate-check) monitors.

## Get custom timing details with your scripted API monitors

Previously, you needed to use `$util.insights.set` to time and trend actions across your monitor executions, but the requests would not generate any data in the New Relic UI. This prevented you from using queries and dashboards to extract values from these requests. 

The new synthetic monitoring runtime introduces some out-of-the-box timing details, including the ability to test `$http` objects with your scripted API monitors. Additionally, you can retrieve more specific timing details by [using $har](/docs/synthetics/synthetic-monitoring/scripting-monitors/custom-timing-details).

## Deprecated features [#deprecated]

We’re introducing new language that changes the script syntax in your scripted browser monitors. We recommend that you update your scripts to account for language changes and prevent potential broken monitors in the future. 

<table>
  <thead>
    <tr>
      <th style={{ width: "100px" }}>
        Deprecated syntax
      </th>
      <th>
        New syntax
      </th>
      <th>
        Why?
      </th>
    </tr>
  </thead>

    <tbody>
      <tr>
        <td>
          `$browser`
        </td>
        <td>
          `$webDriver`
        </td>
        <td>$browser provides backwards compatibility with Selenium WebDriver 3.6, but $webDriver allows you to use Selenium WebDriver 4.1 syntax. 
        </td>
      </tr>
      
      <tr>
        <td>
          `$driver`
        </td> 
        <td>
          `$selenium`
        </td>
        <td>$driver provides backwards compatibility with Selenium WebDriver 3.6, while $selenium allows you to use Selenium WebDriver 4.1 syntax.
        </td>
      </tr>

      <tr>
        <td>
          white/black list
        </td> 
        <td>
          allow/deny list
        </td>
        <td>
          New Relic is committed to inclusivity, which you can read more about on our [diversity, equity, and inclusion page](https://newrelic.com/about/diversity-equity-inclusion). 
        </td>
      </tr>
    </tbody>
</table>