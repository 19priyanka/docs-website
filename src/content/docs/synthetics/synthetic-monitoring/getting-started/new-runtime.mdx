---
title: Start using the new synthetic monitoring runtime
tags:
  - Synthetics
  - Synthetic monitoring
  - Runtime conversion
metaDescription: "Synthetic monitoring's new runtime requires that you make some changes to your already existing monitors."
---

Synthetic monitoring has a new runtime that affects your public monitors. The new runtime enables us to better maintain the backend infrastructure that your synthetic monitors execute from. We recommend converting your legacy runtime to take advantage of capabilities made possible through the new runtime. Eventually, we plan to make this new runtime available for private monitoring locations. 

New synthetic monitors default to using the new runtime. If you've created a synthetic monitor using the legacy runtime, there are extra [configuration steps](#runtime-convert).

<Callout variant="important">
Before switching to the new runtime, make sure that you've updated your allow lists to accept network requests from the new runtime’s [public IP ranges](/docs/synthetics/synthetic-monitoring/administration/new-synthetic-public-minion-ips).
</Callout>

## Benefits of using the new runtime [#benefits]

When you convert to the new runtime, you get these features:

* Access to newer versions of Google Chrome, so your scripted browser monitors run with browser versions closer to the versions used by your customers. 
* Access to the updated scripted API runtime, giving you access to newer versions of node.js. 
* Support for async / await syntax. This simplifies script creation and maintenance, diverging from the old runtime’s `.then` promise chaining.
* Support for shadow DOM objects, allowing your monitors to find objects inside the shadow DOM.
* [Custom timing library](#custome-timing) for scripted API monitors.
- Access to programmatic management of your synthetic monitors using [NerdGraph APIs](SOMETHING). 

## Switching to the new runtime from the UI [#runtime-UI]

SOMETHING.png

<figcaption>
  Go to [one.newrelic.com](https://one.newrelic.com/nr1-core), then click **Synthetics** > **Create monitor** > Select public monitor type > **Runtime** > Toggle between the Legacy and current runtime. 
</figcaption>

## Convert your monitors to the new runtime [#runtime-convert]

1. Go to one.newrelic.com, click **Synthetics**, then select the monitor you want to edit.
2. From the **Settings** tab, click **General**. 
3. Use the dropdown menu to switch the current runtime view (use Node 16 for scripted APIs and Chrome 97 for scripted browser monitors). 
4. Validate that your monitors function, and make any script modifications as needed. 
5. Save.

## Custom timing library 

The New Relic synthetics runtime environment provides out of the box timing details for each monitor type, including the usage of the $http object in scripted API monitors. While the $http object enables SOAP, REST, and GraphQL API testing, there are many other Node.JS modules available for use in scripted API monitors that do not produce out of the box timing details.

These additional modules include:
* Default Node.js modules
* Additional importable Node.js modules

## Benefits

Custom timers can be combined with usage of $util.insights.set to time and trend actions across monitor executions, but the end result is still a blank result waterfall view and the requirement to use queries and dashboards.

Using the $har custom timing library provides an experience that better mirrors default details including:

* Easy custom timing for other Node.js modules
* Timers are included in result waterfall views
* SyntheticRequest events are created for each timer
* Usage
* Timing resources can be created by using the `addResource()` or `getResource`() methods and timers can be started and stopped using `startTimer()` and `stopTimer()`.

Simple Example:

Create a resource named Test Timer, then start and stop the timer.

```
const testTimer = $har.addResource('Test Timer');
testTimer.startTimer();
await sleep(100);
testTimer.endTimer();
```

Simple Example 2:

Resources can also be created using the getResource method.

```
$har.getResource('Test Timer').startTimer();
await sleep(100);
$har.getResource('Test Timer').endTimer();
```

Additional timer attributes are available to extend the details collected in the timer and visible in the result waterfall view. These include:

* blocked
* dns
* connect
* ssl
* send
* wait
* receive

DNS Attribute Example:

This simple DNS monitor includes a DNS attribute timer:

```
const { Resolver } = require('dns').promises;
const myResolver = new Resolver();

myResolver.setServers(['1.1.1.1']);

const dnsResource = $har.addResource('DNS Lookup');
dnsResource.startTimer();
dnsResource.dns().startTimer();

let addresses = await myResolver.resolve4('newrelic.com')
dnsResource.dns().endTimer();
dnsResource.endTimer();
console.log(addresses);
```

## Deprecated features [#deprecated]

We’re introducing new syntax that changes how your scripted monitors direct your browsers. We recommend that you update your scripts to account for language changes and prevent potential broken monitors in the future. 

<table>
  <thead>
    <tr>
      <th style={{ width: "100px" }}>
        Deprecated syntax
      </th>
      <th>
        New syntax
      </th>
      <th>
        Why?
      </th>
    </tr>
  </thead>

    <tbody>
      <tr>
        <td>
          `$browser`
        </td>
        <td>
          `$webDriver`
        </td>
        <td>Accounts for the full range of compatibility with Selenium WebDriver types, rather than limiting to only browser-types.
        </td>
      </tr>
      
      <tr>
        <td>
          `$driver`
        </td> 
        <td>
          `$Selenium`
        </td>
        <td>SOMETHING
        </td>
      </tr>

      <tr>
        <td>
          white/black list
        </td> 
        <td>
          allow/deny list
        </td>
        <td>
          New Relic is committed inclusivity, which you can read more about on our [diversity, equity, and inclusion page](https://newrelic.com/about/diversity-equity-inclusion). 
        </td>
      </tr>
    </tbody>
</table>