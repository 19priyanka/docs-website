{
  "/docs/browser/new-relic-browser/guides/guide-using-browser-spa-apis": [
    {
      "sections": [
        "Introduction to browser monitoring",
        "More than Real User Monitoring (RUM)",
        "Examine user perceptions",
        "Improve interactive app performance",
        "Correlate front-end and back-end problems",
        "Get started with browser monitoring"
      ],
      "title": "Introduction to browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "4928b2a5981bd2d6263f04b4b882d65adef22779",
      "image": "https://docs.newrelic.com/static/98ad878ffa7b586b779178656f19ec58/c1b63/browser_intro_0.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/introduction-browser-monitoring/",
      "published_at": "2021-10-24T19:11:37Z",
      "updated_at": "2021-10-24T19:11:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your end-user experience depends on your entire technology stack. You need to quickly understand what's causing a customer complaint or issue. Did the problem come from your infrastructure, your application, or the browsers that ultimately render it? Is it the result of a problematic internet provider, a problem in your own data center with failing CPU or memory, or something else? More than Real User Monitoring (RUM) Many websites contain dynamic content that is loaded after the initial page has finished loading, and complex JavaScript code increases the need for error reporting. Browser monitoring in New Relic One provides a Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. With browser monitoring in New Relic One, you see actionable data about your end users' experience with your app. But browser monitoring in New Relic goes far beyond the initial page load to measure full page life cycle data. For example, our browser UI shows you: Actual performance data, such as by page view popularity and user satisfaction (Apdex) scores Perceived performance data that measures how quickly your async or dynamic visuals and interactive page contents display JavaScript error analytics, stack traces, and line-of-code visibility, to show you the end-user steps leading up to an error itself Session performance with a detailed timeline and heat map of the load and interaction events during a webpage's full life cycle AJAX requests indicating problems with timing, end points, and specific locations in the webpage Hash-based route changes in apps with single-page application (SPA) architectures These tools (and more!) help your teams optimize your end users' page load experience, eliminate bugs, and troubleshoot faster across your full stack. Examine user perceptions Real user data gives insights into actual page performance, but you also need to look into your users' perception of your site's performance. Pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser monitoring agent. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. Additional metrics include: First paint, first contentful paint, and largest contentful paint First input delay First interaction This helps you understand how users experience your site, both from visual and responsiveness standpoints. Improve interactive app performance Our single-page app (SPA) monitoring automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during browser interactions. You can also use our browser agent and SPA API to monitor virtually anything that executes inside the browser. If you are a developer, SPA monitoring can help you: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query and visualize the data to assist with business decisions. Bring better apps to the marketplace more quickly. Correlate front-end and back-end problems With New Relic One, you can instrument any type of data you need, such as metrics, events, logs, and traces. This helps you find actionable data about your end users' experience across the stack. For example: Type of data Comments Locations or domains Limit browser monitoring to focus on specific geographical locations or specific types of end-user activity. You can also monitor or block specific domains. Trends in interactions Use our comparative charting feature for a direct page load time comparison between real user (browser) interactions and trends appearing in Synthetic monitors. Distributed tracing Isolate latency from the web browser through back-end services with distributed tracing. The UI helps you see the connection across across a full transaction, from browser activity, to time spent in network, to back-end activity. Browser types Explore your end users' experience with your app segmented by any types of browsers they use, including: Top browsers by throughput Average page load time by platform type (mobile, desktop, and other) Selected browser type by version (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Get started with browser monitoring Follow these basic steps, and you'll quickly be up and running in New Relic with browser monitoring! Review the compatibility details and basic requirements for browser monitoring. Install the browser agent. Go to [one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. View summary data from your Browser summary page, then drill down into page load timing details and other UI data. Configure your alerts for key performance data, or use our Applied Intelligence solutions to reduce alert noise, correlate incidents, and automatically detect anomalies. Query and visualize your default data (or customize your own), then analyze what that data says about your business. Customize and share your own charts and dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.03043,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>browser</em> <em>monitoring</em>",
        "sections": "Introduction to <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " performance Our single-page app (SPA) <em>monitoring</em> automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during <em>browser</em> interactions. You can also use our <em>browser</em> agent and SPA API to <em>monitor</em> virtually anything that executes inside the <em>browser</em>. If you"
      },
      "id": "604429a9e7b9d2bde7579a04"
    },
    {
      "sections": [
        "Usage dictionary",
        "account ID",
        "agent",
        "am and pm",
        "Amazon Web Services (AWS) product names",
        "app name vs. app alias",
        "beta",
        "BETA FEATURE",
        "bits and bytes",
        "Tip",
        "blacklist and whitelist",
        "capitalization",
        "Child account",
        "click",
        "collector vs. connect to New Relic",
        "contractions",
        "customer vs. user",
        "dashboard",
        "doc, document, documentation, docs site",
        "dropdown",
        "e.g. and i.e.",
        "em dash (—)",
        "etc.",
        "hostname",
        "icons",
        "index",
        "infrastructure",
        "introduction",
        "macOS",
        "master account",
        "menu",
        "mouse over",
        ".NET",
        "New Relic One",
        "Node.js",
        "NR ONLY",
        "Oxford comma",
        "open source",
        "page",
        "parent account",
        "permissions",
        "pricing",
        "real user monitoring (RUM)",
        "record vs. report vs. collect",
        "RPM",
        "serial comma",
        "time zone",
        "UI",
        "UI paths",
        "update vs. upgrade",
        "users",
        "username, not user name",
        "version number references",
        "we",
        "you"
      ],
      "title": "Usage dictionary",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "eb1b15a359f1676c50bb9f0a1270f4659c435f63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/quick-reference/usage-dictionary/",
      "published_at": "2021-10-24T22:49:44Z",
      "updated_at": "2021-10-24T22:49:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For consistency across New Relic content, here are our general word usage guidelines: We generally follow the Microsoft Style Guide, which is based on the Chicago Manual of Style. We follow American English conventions, rather than British English ones. We defer to the official product names for references to products. (For example, for Amazon Web Services (AWS), see aws.amazon.com/products.) For terminology specific to New Relic, we use the product glossary. account ID A unique number that identifies a particular New Relic account. Don't use account number. agent Don't capitalize. Install the Ruby agent, not Install the Ruby Agent. Don't refer to a Synthetics private minion as an agent. am and pm Use the 12-hour clock followed by the (lowercased) time period am or pm. Don’t put a space after the last number in a timestamp (12:00am, not 12:00 am). Don't include a leading 0 when the hour is less than 10. 9:30am, 12:30pm, 8:30pm Copy Amazon Web Services (AWS) product names Refer to the specific product, not just AWS broadly. As a courtesy to your readers, on first mention always refer to Amazon products by their full names; for example Amazon Web Services (AWS). You can use the acronym after that, if there is one. Example: Amazon Elastic Compute Cloud. After that, use the short name according to the AWS Documentation site. Example: Amazon EC2. app name vs. app alias The \"machine name\" that the collector uses to uniquely identify an app is its app name. The server-side configuration setting that changes the visible \"name\" of an app without changing its unique identifier is its app alias. beta Use the beta callout. In the body text, use lowercase. For example: BETA FEATURE This feature is currently in beta. If the developer team prefers to use a term other than beta or private beta, clarify what is driving that use of the term (Legal requirement?), and add any relevant info here in the usage dictionary. bits and bytes Use standard prefixes and capitalization for International System of Units (SI), International Organization for Standardization (ISO), or Joint Electron Device Engineering Council (JEDEC memory) values when referring to multiples of bits (b) and bytes (B). 1 byte = 8 bits. Decimal value SI prefix Binary value ISO prefix JEDEC prefix 1000 k: kilo 1024 Ki: kibi K: kilo 1000^2 M: mega 1024^2 Mi: mebi M: mega 1000^3 G: giga 1024^3 Gi: gibi G: giga 1000^4 T: tera 1024^4 Ti: tebi - -- 1000^5 P: peta 1024^5 Pi: pebi - -- Tip For help with converting byte values (such as bytes to kilobytes), try this byte converter. blacklist and whitelist Don't use. Instead, use deny list and allow list; for example, \"Add a hostname to your deny list.\" capitalization This is more complex than can be covered in this usage dictionary. For detailed information, see: Heading capitalization Capitalization of features and UI elements Child account A parent account contains one or more child accounts. Child accounts were previously referred to as \"sub-accounts\". click In general, use click rather than the vaguer select. For example, you might click something in the UI, but then select something from a list. Be particularly careful to use click to describe actions that only make sense with a mouse; for example, with a right click or a click and drag. Also use click when the user must click on a non-selectable object (to save your changes, click anywhere outside the dialog box). See also [mouse over] #mouse-over). collector vs. connect to New Relic When referring to an agent talking to the New Relic servers, describe this as the New Relic collector. Although internally the collector refers only to specific parts of our architecture, we use it more broadly in our documentation to mean \"any endpoint a customer must connect to report data, for any product.\" Avoid \"connect to New Relic,\" and do not use \"connect to the New Relic UI.\" contractions When it makes sense for clarity, conciseness, and tone and voice, use contractions. Use them where they make the writing sound more like natural speech, and where they improve clarity and accessibility without sacrificing expertise and authority. There are no hard and fast rules for which contractions are or aren't acceptable, but simple and common is preferable to complicated and rare. For example, it's for it is is fine, but less common constructions like mustn't or wouldn't've are best avoided. Also: When using a negative contraction (don't, can't, won't) try to provide some additional info about what what to do and what can be done. (See the style guide intro for more on this.) There are places in our docs—for example, in notes and warnings—where spelling out do not, cannot, or will not is preferable to contractions to emphasize the action or blockage to be avoided. customer vs. user When possible, use the second person you to form a sense of connection with the reader. For times when you need a descriptive third-person noun, keep the following guidelines in mind: customer and user are both appropriate depending on context. customer makes more sense when talking about billing, or about a group of people or a business entity. For example, one customer may have one or more individual users who interact with New Relic through the customer's account(s). user makes more sense as a general term for an individual user, or when talking about users as an object in the account model. For example, when discussing account models, it's important to be specific about what constitutes a single person identity in our system. dashboard Don't use. Instead, use page. doc, document, documentation, docs site If you need to refer to the docs themselves—don't. Generally it's better to directly link to the doc you're referencing and use the doc title as your link text. For example, See [Install the .NET agent](URL) rather than See our [.NET agent install docs](URL). If there's not a good alternative, doc generally sounds more natural than document or documentation. If you're tempted to use a longer form, try reading it aloud to see which reads best. If you must refer to the site as a whole, call it the docs site rather than Docs site or documentation site. Internally, you can also refer to the whole URL docs.newrelic.com to avoid ambiguity with other sources of docs like internal platform docs or API explorer docs. To refer to our docs GitHub repo, use the repo name docs-website or the repo path newrelic/docs-website. dropdown Use dropdown instead of drop-down or drop down. Although it isn't common usage, you can use dropdown independently as a noun, without needing to say dropdown menu or dropdown list. For example, select a date from the <b>date</b> dropdown. e.g. and i.e. Don't use Latin abbreviations. Instead of e.g., use for example or such as. Instead of i.e. or its English equivalent in other words, rewrite so your description is clear. em dash (—) Em dashes are rarely needed in tech docs, sadly. You can usually accomplish what you need to by breaking the thought into multiple sentences or using parentheses. In some rare cases, though, an em dash can add drama and spice. If you think you've found such a case, make sure you use them right. An em dash should always use the real em dash character (not a hyphen), and no space before and after. For example: You can sign up for New Relic fast and free—we won't even ask for a credit card number. Copy You can insert an em dash with the COMMAND+OPTION+- shortcut or use the HTML entity. etc. Unlike the Latin abbreviations e.g. or i.e.), you're welcome to use etc. Please ensure that you have several meaningful examples, though, before using. For example, cities including Portland, Seattle, Dublin, etc. but not cities including Portland, etc.. hostname This is one word. Don't hyphenate. icons When using an inline icon from the UI, always describe it first, then embed the icon image, and then end with the word icon. For example, select the delete icon. Don't put icons in bold. When writing about icons, describe the icon for its purpose or action, not what the icon looks like. For example: Yes: Select the edit icon. No: Select the pencil icon. For technical information on embedding images, see Inserting inline images and Embedding Font Awesome icons. index A list of entities, such as the APM applications index, the Synthetics Monitors index, or the Alerts Incidents index. See also page. infrastructure Don't use, unless referring to the New Relic Infrastructure product. Instead, use an appropriate substitute such as architecture, environment, system, host, etc. introduction Always use Introduction to for overview docs for a particular product. For example, Introduction to New Relic Infrastructure or Introduction to the PHP agent or Introduction to transaction traces. Don't use welcome to, basics, intro, overview, etc. Also avoid the Thing: Tagline format, as in X-Ray sessions: Traces and thread profiles for key transactions, unless having a title with keywords will help with SEO. macOS The proper name for Apple's desktop operating system is macOS. Don't use the older product names Mac OS X or OS X. master account We previously used \"master account\" and \"sub-account\" but now we use parent account and child account. menu The list of pages and indexes on the top and left sides of the New Relic user interface. mouse over For mouse movements that involve placing the mouse pointer over an area, but not clicking it. For example, the APM Overview page includes functions that are only visible when the mouse pointer is over a particular chart. Do not use point to or hover over. See also click. .NET Always refer to the agent and language as .NET, never as .Net or .net or dotnet. New Relic One New Relic One isn't a product. It's a way to view New Relic data more easily, all in one place, and from multiple related accounts. This has several implications for how we should refer to it: Avoid phrasing that makes New Relic One sound like a separate product or a separate platform. There is a single New Relic platform through which our users interact with our products. Avoid mentioning New Relic One where it can be avoided. For example, instead of saying \"Use New Relic One workloads to...\", you could instead say, \"In New Relic, you can use workloads to...\" and then in the doc explain where to find the feature. Another example: instead of referring to \"The programmable New Relic One platform,\" we might say, \"The New Relic platform is programmable: To start building, go to one.newrelic.com and...\" Do not use NR1 or nr1 as an abbreviation of New Relic One. The only reason to use nr1 is when referring to the nr1 package or library (for example: a reference to the command nr1 nerdpack:serve). In general, we want to avoid overloading our docs with \"New Relic\". For more details, see the New Relic One messaging guidelines, the docs glossary entry, or the New Relic One docs. Node.js Always refer to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this style guide). Don't use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some legal contracts may require upper case. page A specific place in the New Relic UI, located at a particular URL. Compare and contrast index, menu, and UI. Don't use dashboard, menu, tab, screen, or similar terms. parent account New Relic organizations can have a parent/child account structure. This is more important for our original user model but still plays a role for some behind-the-scenes features on our New Relic One user model. Learn more about account structure. Parent accounts were previously referred to as master accounts, and there are still some uses of this in the codebase. permissions See User-related language. For pricing tier/edition language, see Pricing language. pricing See Pricing language. real user monitoring (RUM) Don't use this outside of browser monitoring docs. Often abbreviated as RUM, this is a generic industry term for browser monitoring. New Relic refers to this as page load timing or browser monitoring. Use this term only for SEO or clarification, not to refer to the actual feature. record vs. report vs. collect Use report when discussing data sent to New Relic, such as, \"your host reports data to New Relic.\" Avoid using report as a noun. Instead use \"the reported metrics\" or \"the collected data.\" If \"report\" sounds too clunky, you can also use collect as long as whatever New Relic is collecting doesn't sound security sensitive. RPM Don't refer to the New Relic UI as RPM. Always refer to the specific product, such as the APM UI or the Browser UI. However, you may use rpm when required in the visible URL string in UI paths. serial comma Also referred to as an Oxford comma. Always use serial commas with inline lists. For example, Portland, Seattle, and Dublin rather than Portland, Seattle and Dublin. time zone Include a space (time zone). Don't hyphenate or run together as timezone. UI The graphical component of a New Relic product, encompassing all its pages, menus, and indexes. See also UI paths. UI paths If you need to tell a user how to path through the UI, see our style guide page on UI paths. update vs. upgrade Use update when users need to change the version of whatever they're using. No money or payment is needed for an update. Use upgrade whenever money or payment may be involved, such as upgrading to the Pro version of a product. The new pricing model makes it unlikely that you'll need to use this. users For styles and formats related to user roles and groups and more, see User-related style. username, not user name One word (username), not two. This is the most common usage and is recommended by Microsoft and Google style guides. version number references When referring to multiple version numbers, always use or higher. Don't use and higher, or the words greater or later. Also don't use punctuation, as in version 1.2+. For example: Foo requires Ruby agent version 1.2.3 or higher. Copy In addition: Tell users to use the latest version and not an up-to-date or current version. To abbreviate the word version, use a lowercase v with no space before the number; for example, v2 or v1.2.3. Use update not upgrade when talking about agent versions, as in \"To update to the latest version...\" For security reasons, do not use version numbers with licensing docs. The Tech Docs team doesn't have a set standard when referring to previous versions. Recommendation: Consider using version x.x or lower when identifying a specific version. Consider using In earlier agent versions when referring to versions more vaguely. we Say “we” and “our” when it works with the flow of your writing. Avoid overloading paragraphs with “New Relic” mentions, or reword so the focus is on the user, not New Relic. For example, avoid writing something like this: New Relic recommends setting a startup timeout. Copy Instead, write something like this: Recommendation: To help with troubleshooting, include a startup timeout in your configuration. Copy OR We recommend setting a startup timeout. Copy you We use “you” and “your” liberally in our docs. Addressing the reader directly makes for simpler, cleaner sentences. It also tends to expose lazy uses of passive construction and it helps users to understand procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.5784,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "real user <em>monitoring</em> (RUM)",
        "tags": "Basic style <em>guide</em>",
        "body": " accounts, and there are still some uses of this in the codebase. permissions See User-related language. For pricing tier&#x2F;edition language, see Pricing language. pricing See Pricing language. real user <em>monitoring</em> (RUM) Don&#x27;t use this outside of <em>browser</em> <em>monitoring</em> docs. Often abbreviated as RUM"
      },
      "id": "60421ec1196a676986a83d87"
    },
    {
      "sections": [
        "addToTrace (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples"
      ],
      "title": "addToTrace (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "cfc07079342fec5115dbc68cff1d4a40a66f9836",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api/",
      "published_at": "2021-10-24T21:33:57Z",
      "updated_at": "2021-10-01T23:08:02Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within browser session traces can provide context for other user actions, errors, and default events within the trace. This event will appear in the browser session trace details. If a session trace currently is in progress, this adds an object with a user-defined name, start time, and other optional fields. If you make this call and a session trace is not already in progress, this will not cause browser to capture a trace. Note that the number of events shared this way is limited by the Browser agent harvest cycle. Here is the last update on that limit. Parameters Parameter Description $custom_object JavaScript object Required. Supply a JavaScript object with these required and optional name/value pairs: Required name/value pairs: NAME, START Optional name/value pairs: END, ORIGIN, TYPE If you are sending the same event object to New Relic One as a PageAction, omit the TYPE attribute. (TYPE is a string to describe what type of event you are marking inside of a session trace.) If included, it will override the event type and cause the PageAction event to be sent incorrectly. Instead, use the NAME attribute for event information. Examples var obj = { // REQUIRED name: 'Event Name', start: 1417044274239, // Time in ms since epoch // OPTIONAL end: 1417044274252, // Time in ms since epoch. Defaults to same as start resulting in trace object with a duration of zero. origin: 'Origin of event', // Defaults to empty string type: 'What type of event was this' // Defaults to empty string } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.3475,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addToTrace (<em>browser</em> agent API)",
        "sections": "addToTrace (<em>browser</em> agent API)",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within <em>browser</em> session traces can provide context for other user"
      },
      "id": "6043faae196a6774ac960f30"
    }
  ],
  "/docs/browser/new-relic-browser/installation/disable-browser-monitoring": [
    {
      "sections": [
        "Introduction to browser monitoring",
        "More than Real User Monitoring (RUM)",
        "Examine user perceptions",
        "Improve interactive app performance",
        "Correlate front-end and back-end problems",
        "Get started with browser monitoring"
      ],
      "title": "Introduction to browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "4928b2a5981bd2d6263f04b4b882d65adef22779",
      "image": "https://docs.newrelic.com/static/98ad878ffa7b586b779178656f19ec58/c1b63/browser_intro_0.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/introduction-browser-monitoring/",
      "published_at": "2021-10-24T19:11:37Z",
      "updated_at": "2021-10-24T19:11:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your end-user experience depends on your entire technology stack. You need to quickly understand what's causing a customer complaint or issue. Did the problem come from your infrastructure, your application, or the browsers that ultimately render it? Is it the result of a problematic internet provider, a problem in your own data center with failing CPU or memory, or something else? More than Real User Monitoring (RUM) Many websites contain dynamic content that is loaded after the initial page has finished loading, and complex JavaScript code increases the need for error reporting. Browser monitoring in New Relic One provides a Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. With browser monitoring in New Relic One, you see actionable data about your end users' experience with your app. But browser monitoring in New Relic goes far beyond the initial page load to measure full page life cycle data. For example, our browser UI shows you: Actual performance data, such as by page view popularity and user satisfaction (Apdex) scores Perceived performance data that measures how quickly your async or dynamic visuals and interactive page contents display JavaScript error analytics, stack traces, and line-of-code visibility, to show you the end-user steps leading up to an error itself Session performance with a detailed timeline and heat map of the load and interaction events during a webpage's full life cycle AJAX requests indicating problems with timing, end points, and specific locations in the webpage Hash-based route changes in apps with single-page application (SPA) architectures These tools (and more!) help your teams optimize your end users' page load experience, eliminate bugs, and troubleshoot faster across your full stack. Examine user perceptions Real user data gives insights into actual page performance, but you also need to look into your users' perception of your site's performance. Pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser monitoring agent. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. Additional metrics include: First paint, first contentful paint, and largest contentful paint First input delay First interaction This helps you understand how users experience your site, both from visual and responsiveness standpoints. Improve interactive app performance Our single-page app (SPA) monitoring automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during browser interactions. You can also use our browser agent and SPA API to monitor virtually anything that executes inside the browser. If you are a developer, SPA monitoring can help you: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query and visualize the data to assist with business decisions. Bring better apps to the marketplace more quickly. Correlate front-end and back-end problems With New Relic One, you can instrument any type of data you need, such as metrics, events, logs, and traces. This helps you find actionable data about your end users' experience across the stack. For example: Type of data Comments Locations or domains Limit browser monitoring to focus on specific geographical locations or specific types of end-user activity. You can also monitor or block specific domains. Trends in interactions Use our comparative charting feature for a direct page load time comparison between real user (browser) interactions and trends appearing in Synthetic monitors. Distributed tracing Isolate latency from the web browser through back-end services with distributed tracing. The UI helps you see the connection across across a full transaction, from browser activity, to time spent in network, to back-end activity. Browser types Explore your end users' experience with your app segmented by any types of browsers they use, including: Top browsers by throughput Average page load time by platform type (mobile, desktop, and other) Selected browser type by version (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Get started with browser monitoring Follow these basic steps, and you'll quickly be up and running in New Relic with browser monitoring! Review the compatibility details and basic requirements for browser monitoring. Install the browser agent. Go to [one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. View summary data from your Browser summary page, then drill down into page load timing details and other UI data. Configure your alerts for key performance data, or use our Applied Intelligence solutions to reduce alert noise, correlate incidents, and automatically detect anomalies. Query and visualize your default data (or customize your own), then analyze what that data says about your business. Customize and share your own charts and dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 161.7062,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>browser</em> <em>monitoring</em>",
        "sections": "Introduction to <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " performance Our single-page app (SPA) <em>monitoring</em> automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during <em>browser</em> interactions. You can also use our <em>browser</em> agent and SPA API to <em>monitor</em> virtually anything that executes inside the <em>browser</em>. If you"
      },
      "id": "604429a9e7b9d2bde7579a04"
    },
    {
      "sections": [
        "Install the browser monitoring agent",
        "Enable browser monitoring",
        "Deployment options",
        "Enable an APM-monitored app",
        "Enable with copy/paste",
        "Instrument webpages using the APM agent",
        "Use REST API",
        "Browser agent types: Lite, Pro, Pro+SPA"
      ],
      "title": "Install the browser monitoring agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "bc45bbc86cd4d8b81367ad0904907ddc735717f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/",
      "published_at": "2021-10-24T23:04:12Z",
      "updated_at": "2021-08-08T05:47:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser uses a JavaScript snippet, also referred to as an \"agent,\" to instrument your app's webpages. The JavaScript collects data for browser monitoring. To install the browser agent, you can choose from a number of deployment options. If you don't have one already, create a New Relic account. It's free, forever. Enable browser monitoring Browser Pro+SPA is the default agent when you enable browser monitoring. This automatically gives you access to all of our browser monitoring features. For more information about the browser monitoring options, see Browser agent types in this document. To enable browser monitoring: Go to one.newrelic.com, select Browser, and then select Add more data. Follow the instructions in the UI to add browser monitoring to your app. Generate some traffic for your app, then wait a few minutes for data to appear in New Relic. Optional: After installation is complete and you are seeing data, go to the App settings page for additional agent configuration, or to change the browser agent type. It may take several minutes after enabling the browser monitoring agent before your webpage data appear in New Relic. If have problems, follow our troubleshooting tips. Deployment options No matter which option you use to deploy browser monitoring, the end result is the same: the browser monitoring JavaScript snippet (also referred to as the \"agent\") is inserted into your app pages. The method you select depends on your preferences and business needs. Enable an APM-monitored app When enabling browser monitoring, you can use an APM agent to automatically inject the browser monitoring JavaScript snippet for you. This is the easiest way to install the agent for an app that's already being monitored by APM. APM-monitored apps are listed on your APM Applications index. Enable with copy/paste When enabling browser monitoring, you can manually insert the JavaScript snippet into your app's webpages. The copy/paste option gives you control over the exact placement of our JavaScript snippet, which is required to monitor the webpage's performance. This is useful for: Standalone apps, static sites, and cached pages delivered by CDN APM apps that are not as closely coupled to the browser app as with a standard server-side app (for example, when your client-side app talks to a REST API back end) Some tips for using the JavaScript snippet: Placement in your webpage: Copy the code snippet, then paste it inline into your pages as close to the top of the <head> element as possible, but after any position-sensitive <meta> tags (for example, X-UA-Compatible or charset information). For more information on the inline head placement, see JavaScript placement requirements. License key and app ID: Near the bottom of the generated JavaScript is your browser license key and application ID. This is useful with the REST API and API Explorer. Instrument webpages using the APM agent This information applies to apps that are also monitored by APM. Our APM agents can instrument webpages with the required JavaScript for page load timing. If you are using an APM agent's API to manually add the JavaScript snippet to your webpages, insert the instrumentation snippet as close to the top as possible. This allows you to take advantage of detailed information about browser's AJAX calls and JavaScript errors. For more information, see the instructions for your APM agent: C SDK Go Java .NET Node.js PHP Python Ruby Use REST API This information applies to apps that are also monitored by APM. The REST API lets you manage deployment outside the browser monitoring UI. This is useful for large organizations deploying multiple apps. Browser agent types: Lite, Pro, Pro+SPA We have three types of browser agents: Lite, Pro, and Pro+SPA. The agent type has no impact on your billing. Browser agent type Comparison Pro+SPA This is the default installed agent when you enable browser monitoring. What it includes: Gives you access to all of the Browser Pro features and to Single Page App (SPA) monitoring. Provides detailed page timing data and the most up-to-date New Relic features, including distributed tracing, for all types of applications. Pro+SPA is not limited only to single page applications. After install, you can downgrade anytime to the less advanced agents if you don't want or need SPA monitoring. Pro What it includes: Gives you access to the Browser Pro features. What it doesn't include: Lacks the functionality designed for single page app monitoring. Lite What it includes: Gives you information about some basic page load timing and browser user information. What it doesn't include: Lacks the Browser Pro features and SPA features. Details about how agent types relate to pricing: New Relic One pricing: This pricing plan has data ingest as a billing factor. If you want to reduce data ingest, you may want to consider downgrading to lesser agent types after install. Original pricing: Your access to browser monitoring features is gated by your subscription plan, not by the agent type. This means there is no reason not to use the default Pro+SPA agent. After initial agent installation is finished, you can go to the App settings page to edit your configuration or to change your subscription.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.68637,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the <em>browser</em> <em>monitoring</em> agent",
        "sections": "<em>Install</em> the <em>browser</em> <em>monitoring</em> agent",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": ". To enable <em>browser</em> <em>monitoring</em>: Go to one.newrelic.com, select <em>Browser</em>, and then select Add more data. Follow the instructions in the UI to add <em>browser</em> <em>monitoring</em> to your app. Generate some traffic for your app, then wait a few minutes for data to appear in New Relic. Optional: After <em>installation</em>"
      },
      "id": "604429e628ccbcb80b2c60d0"
    },
    {
      "sections": [
        "Introduction to New Relic for Node.js",
        "Why it matters",
        "Installation",
        "Extend your instrumentation",
        "Troubleshoot your installation",
        "Check the source code"
      ],
      "title": "Introduction to New Relic for Node.js",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Getting started"
      ],
      "external_id": "ed1db81e3ecf2a097db43baa318c847ec2e1ad7d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/nodejs-agent/getting-started/introduction-new-relic-nodejs/",
      "published_at": "2021-10-25T15:53:28Z",
      "updated_at": "2021-10-23T21:37:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Pinpoint and solve issues down to the line of code with Node.js monitoring from New Relic. With features like service maps and error analytics, our Node.js agent helps you get the full picture of your app environment. Why it matters Many Node application requests are based on raw URLs. Our solution is different. New Relic for Node.js assumes it can group requests to your application into transactions instead of HTTP requests. Transactions are defined by giving one or more request paths a name. These names are used to: Visualize where your app is spending its time (in transaction breakdowns). Identify slow requests. Group metrics. Show you which portions of your application are suffering from slow database performance. Installation To install our agent, you need to sign up for New Relic first. Once you're logged in, follow the instructions or use our launcher to get data flowing in. Review the system requirements. Read the install docs. Go directly to the New Relic UI to add Node.js data. Extend your instrumentation After installing the Node.js agent, extend your instrumentation: Extend your instrumentation Comments Customization Implement Node.js custom instrumentation. Collect custom metrics via an API call. Use our Node.js agent API to control, customize, or extend the agent's functionality. Open source telemetry To create your own integrations, use our Node Telemetry SDK. To gain visibility into your GraphQL payloads, use our Apollo Server plugin. Traces Enable distributed tracing. VM measurements Collect key metric timeslice data from the Node.js virtual machine. View detailed VM statistics in the New Relic UI. End-user activity Integrate the Node.js agent with browser monitoring. Gain visibility into user activity with browser monitoring's page load timing process. Troubleshoot your installation If you encounter issues with your Node.js agent, see our troubleshooting information: Large memory usage: If you've installed the Node.js agent and your memory usage has increased, check out these possible solutions. Troubleshooting your Node.js installation: Try these steps if you don't see any data, cannot log files, or encounter other installation problems with the Node.js agent. Troubleshooting browser instrumentation: If you encounter problems with browser data, see these additional tips for Node.js. You can also view all troubleshooting docs. If you need additional assistance, get support at support.newrelic.com. Check the source code Our Node.js agent is open source software. You can browse the source code and send improvements, or create your own fork and build it. For more information, see the node-newrelic README on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.660934,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Installation</em>",
        "body": " distributed tracing. VM measurements Collect key metric timeslice data from the Node.js virtual machine. View detailed VM statistics in the New Relic UI. End-user activity Integrate the Node.js agent with <em>browser</em> <em>monitoring</em>. Gain visibility into user activity with <em>browser</em> <em>monitoring</em>&#x27;s page load timing process"
      },
      "id": "617480b664441fdadc5fbef8"
    }
  ],
  "/docs/browser/new-relic-browser/installation/update-browser-agent": [
    {
      "sections": [
        "Introduction to browser monitoring",
        "More than Real User Monitoring (RUM)",
        "Examine user perceptions",
        "Improve interactive app performance",
        "Correlate front-end and back-end problems",
        "Get started with browser monitoring"
      ],
      "title": "Introduction to browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "4928b2a5981bd2d6263f04b4b882d65adef22779",
      "image": "https://docs.newrelic.com/static/98ad878ffa7b586b779178656f19ec58/c1b63/browser_intro_0.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/introduction-browser-monitoring/",
      "published_at": "2021-10-24T19:11:37Z",
      "updated_at": "2021-10-24T19:11:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your end-user experience depends on your entire technology stack. You need to quickly understand what's causing a customer complaint or issue. Did the problem come from your infrastructure, your application, or the browsers that ultimately render it? Is it the result of a problematic internet provider, a problem in your own data center with failing CPU or memory, or something else? More than Real User Monitoring (RUM) Many websites contain dynamic content that is loaded after the initial page has finished loading, and complex JavaScript code increases the need for error reporting. Browser monitoring in New Relic One provides a Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. With browser monitoring in New Relic One, you see actionable data about your end users' experience with your app. But browser monitoring in New Relic goes far beyond the initial page load to measure full page life cycle data. For example, our browser UI shows you: Actual performance data, such as by page view popularity and user satisfaction (Apdex) scores Perceived performance data that measures how quickly your async or dynamic visuals and interactive page contents display JavaScript error analytics, stack traces, and line-of-code visibility, to show you the end-user steps leading up to an error itself Session performance with a detailed timeline and heat map of the load and interaction events during a webpage's full life cycle AJAX requests indicating problems with timing, end points, and specific locations in the webpage Hash-based route changes in apps with single-page application (SPA) architectures These tools (and more!) help your teams optimize your end users' page load experience, eliminate bugs, and troubleshoot faster across your full stack. Examine user perceptions Real user data gives insights into actual page performance, but you also need to look into your users' perception of your site's performance. Pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser monitoring agent. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. Additional metrics include: First paint, first contentful paint, and largest contentful paint First input delay First interaction This helps you understand how users experience your site, both from visual and responsiveness standpoints. Improve interactive app performance Our single-page app (SPA) monitoring automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during browser interactions. You can also use our browser agent and SPA API to monitor virtually anything that executes inside the browser. If you are a developer, SPA monitoring can help you: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query and visualize the data to assist with business decisions. Bring better apps to the marketplace more quickly. Correlate front-end and back-end problems With New Relic One, you can instrument any type of data you need, such as metrics, events, logs, and traces. This helps you find actionable data about your end users' experience across the stack. For example: Type of data Comments Locations or domains Limit browser monitoring to focus on specific geographical locations or specific types of end-user activity. You can also monitor or block specific domains. Trends in interactions Use our comparative charting feature for a direct page load time comparison between real user (browser) interactions and trends appearing in Synthetic monitors. Distributed tracing Isolate latency from the web browser through back-end services with distributed tracing. The UI helps you see the connection across across a full transaction, from browser activity, to time spent in network, to back-end activity. Browser types Explore your end users' experience with your app segmented by any types of browsers they use, including: Top browsers by throughput Average page load time by platform type (mobile, desktop, and other) Selected browser type by version (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Get started with browser monitoring Follow these basic steps, and you'll quickly be up and running in New Relic with browser monitoring! Review the compatibility details and basic requirements for browser monitoring. Install the browser agent. Go to [one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. View summary data from your Browser summary page, then drill down into page load timing details and other UI data. Configure your alerts for key performance data, or use our Applied Intelligence solutions to reduce alert noise, correlate incidents, and automatically detect anomalies. Query and visualize your default data (or customize your own), then analyze what that data says about your business. Customize and share your own charts and dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 161.7062,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>browser</em> <em>monitoring</em>",
        "sections": "Introduction to <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " performance Our single-page app (SPA) <em>monitoring</em> automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during <em>browser</em> interactions. You can also use our <em>browser</em> agent and SPA API to <em>monitor</em> virtually anything that executes inside the <em>browser</em>. If you"
      },
      "id": "604429a9e7b9d2bde7579a04"
    },
    {
      "sections": [
        "Install the browser monitoring agent",
        "Enable browser monitoring",
        "Deployment options",
        "Enable an APM-monitored app",
        "Enable with copy/paste",
        "Instrument webpages using the APM agent",
        "Use REST API",
        "Browser agent types: Lite, Pro, Pro+SPA"
      ],
      "title": "Install the browser monitoring agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "bc45bbc86cd4d8b81367ad0904907ddc735717f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/",
      "published_at": "2021-10-24T23:04:12Z",
      "updated_at": "2021-08-08T05:47:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser uses a JavaScript snippet, also referred to as an \"agent,\" to instrument your app's webpages. The JavaScript collects data for browser monitoring. To install the browser agent, you can choose from a number of deployment options. If you don't have one already, create a New Relic account. It's free, forever. Enable browser monitoring Browser Pro+SPA is the default agent when you enable browser monitoring. This automatically gives you access to all of our browser monitoring features. For more information about the browser monitoring options, see Browser agent types in this document. To enable browser monitoring: Go to one.newrelic.com, select Browser, and then select Add more data. Follow the instructions in the UI to add browser monitoring to your app. Generate some traffic for your app, then wait a few minutes for data to appear in New Relic. Optional: After installation is complete and you are seeing data, go to the App settings page for additional agent configuration, or to change the browser agent type. It may take several minutes after enabling the browser monitoring agent before your webpage data appear in New Relic. If have problems, follow our troubleshooting tips. Deployment options No matter which option you use to deploy browser monitoring, the end result is the same: the browser monitoring JavaScript snippet (also referred to as the \"agent\") is inserted into your app pages. The method you select depends on your preferences and business needs. Enable an APM-monitored app When enabling browser monitoring, you can use an APM agent to automatically inject the browser monitoring JavaScript snippet for you. This is the easiest way to install the agent for an app that's already being monitored by APM. APM-monitored apps are listed on your APM Applications index. Enable with copy/paste When enabling browser monitoring, you can manually insert the JavaScript snippet into your app's webpages. The copy/paste option gives you control over the exact placement of our JavaScript snippet, which is required to monitor the webpage's performance. This is useful for: Standalone apps, static sites, and cached pages delivered by CDN APM apps that are not as closely coupled to the browser app as with a standard server-side app (for example, when your client-side app talks to a REST API back end) Some tips for using the JavaScript snippet: Placement in your webpage: Copy the code snippet, then paste it inline into your pages as close to the top of the <head> element as possible, but after any position-sensitive <meta> tags (for example, X-UA-Compatible or charset information). For more information on the inline head placement, see JavaScript placement requirements. License key and app ID: Near the bottom of the generated JavaScript is your browser license key and application ID. This is useful with the REST API and API Explorer. Instrument webpages using the APM agent This information applies to apps that are also monitored by APM. Our APM agents can instrument webpages with the required JavaScript for page load timing. If you are using an APM agent's API to manually add the JavaScript snippet to your webpages, insert the instrumentation snippet as close to the top as possible. This allows you to take advantage of detailed information about browser's AJAX calls and JavaScript errors. For more information, see the instructions for your APM agent: C SDK Go Java .NET Node.js PHP Python Ruby Use REST API This information applies to apps that are also monitored by APM. The REST API lets you manage deployment outside the browser monitoring UI. This is useful for large organizations deploying multiple apps. Browser agent types: Lite, Pro, Pro+SPA We have three types of browser agents: Lite, Pro, and Pro+SPA. The agent type has no impact on your billing. Browser agent type Comparison Pro+SPA This is the default installed agent when you enable browser monitoring. What it includes: Gives you access to all of the Browser Pro features and to Single Page App (SPA) monitoring. Provides detailed page timing data and the most up-to-date New Relic features, including distributed tracing, for all types of applications. Pro+SPA is not limited only to single page applications. After install, you can downgrade anytime to the less advanced agents if you don't want or need SPA monitoring. Pro What it includes: Gives you access to the Browser Pro features. What it doesn't include: Lacks the functionality designed for single page app monitoring. Lite What it includes: Gives you information about some basic page load timing and browser user information. What it doesn't include: Lacks the Browser Pro features and SPA features. Details about how agent types relate to pricing: New Relic One pricing: This pricing plan has data ingest as a billing factor. If you want to reduce data ingest, you may want to consider downgrading to lesser agent types after install. Original pricing: Your access to browser monitoring features is gated by your subscription plan, not by the agent type. This means there is no reason not to use the default Pro+SPA agent. After initial agent installation is finished, you can go to the App settings page to edit your configuration or to change your subscription.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.68637,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the <em>browser</em> <em>monitoring</em> agent",
        "sections": "<em>Install</em> the <em>browser</em> <em>monitoring</em> agent",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": ". To enable <em>browser</em> <em>monitoring</em>: Go to one.newrelic.com, select <em>Browser</em>, and then select Add more data. Follow the instructions in the UI to add <em>browser</em> <em>monitoring</em> to your app. Generate some traffic for your app, then wait a few minutes for data to appear in New Relic. Optional: After <em>installation</em>"
      },
      "id": "604429e628ccbcb80b2c60d0"
    },
    {
      "sections": [
        "Introduction to New Relic for Node.js",
        "Why it matters",
        "Installation",
        "Extend your instrumentation",
        "Troubleshoot your installation",
        "Check the source code"
      ],
      "title": "Introduction to New Relic for Node.js",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Getting started"
      ],
      "external_id": "ed1db81e3ecf2a097db43baa318c847ec2e1ad7d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/nodejs-agent/getting-started/introduction-new-relic-nodejs/",
      "published_at": "2021-10-25T15:53:28Z",
      "updated_at": "2021-10-23T21:37:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Pinpoint and solve issues down to the line of code with Node.js monitoring from New Relic. With features like service maps and error analytics, our Node.js agent helps you get the full picture of your app environment. Why it matters Many Node application requests are based on raw URLs. Our solution is different. New Relic for Node.js assumes it can group requests to your application into transactions instead of HTTP requests. Transactions are defined by giving one or more request paths a name. These names are used to: Visualize where your app is spending its time (in transaction breakdowns). Identify slow requests. Group metrics. Show you which portions of your application are suffering from slow database performance. Installation To install our agent, you need to sign up for New Relic first. Once you're logged in, follow the instructions or use our launcher to get data flowing in. Review the system requirements. Read the install docs. Go directly to the New Relic UI to add Node.js data. Extend your instrumentation After installing the Node.js agent, extend your instrumentation: Extend your instrumentation Comments Customization Implement Node.js custom instrumentation. Collect custom metrics via an API call. Use our Node.js agent API to control, customize, or extend the agent's functionality. Open source telemetry To create your own integrations, use our Node Telemetry SDK. To gain visibility into your GraphQL payloads, use our Apollo Server plugin. Traces Enable distributed tracing. VM measurements Collect key metric timeslice data from the Node.js virtual machine. View detailed VM statistics in the New Relic UI. End-user activity Integrate the Node.js agent with browser monitoring. Gain visibility into user activity with browser monitoring's page load timing process. Troubleshoot your installation If you encounter issues with your Node.js agent, see our troubleshooting information: Large memory usage: If you've installed the Node.js agent and your memory usage has increased, check out these possible solutions. Troubleshooting your Node.js installation: Try these steps if you don't see any data, cannot log files, or encounter other installation problems with the Node.js agent. Troubleshooting browser instrumentation: If you encounter problems with browser data, see these additional tips for Node.js. You can also view all troubleshooting docs. If you need additional assistance, get support at support.newrelic.com. Check the source code Our Node.js agent is open source software. You can browse the source code and send improvements, or create your own fork and build it. For more information, see the node-newrelic README on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.660934,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Installation</em>",
        "body": " distributed tracing. VM measurements Collect key metric timeslice data from the Node.js virtual machine. View detailed VM statistics in the New Relic UI. End-user activity Integrate the Node.js agent with <em>browser</em> <em>monitoring</em>. Gain visibility into user activity with <em>browser</em> <em>monitoring</em>&#x27;s page load timing process"
      },
      "id": "617480b664441fdadc5fbef8"
    }
  ],
  "/docs/browser/new-relic-browser/page-load-timing-resources/cached-pages": [
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-24T14:51:57Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 276.8942,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "sections": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": " and firstContentfulPaint attributes already are available with <em>Browser</em>Interaction and <em>Page</em>View events. However, they are not always reliably captured before the window onload event fires. Using <em>PageViewTiming</em> gives you a way to capture these metrics even if they happen after the original <em>page</em> <em>load</em> <em>time</em>"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "Page load timing process",
        "Tip",
        "Page load process",
        "Page load time charts in browser monitoring",
        "Web application",
        "Network",
        "Important",
        "DOM processing",
        "Page rendering",
        "Request queuing",
        "App server requests vs. browser transactions",
        "Outliers"
      ],
      "title": "Page load timing process",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "3c1b807e4433968a69a461a95e612812ff0ff8e9",
      "image": "https://docs.newrelic.com/static/ade867510b645a97e56c905e4cf019f9/8c557/browser-page-load-timeline.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/page-load-timing-process/",
      "published_at": "2021-10-24T14:58:33Z",
      "updated_at": "2021-10-07T03:03:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains: How a web page loads How browser monitoring measures page load timing, also known as real user monitoring (RUM) Tip This is a description of traditional, synchronous page load timing. Browser can also monitor asynchronous page load timing. Page load process Here are the major steps in the loading of most web pages. The numbers 1-6 in the diagram correspond to the numbered steps below. Page load timeline: The steps involved in a web page load. Browser monitoring charts display the following segments of that process: Network, Web application, DOM processing, and Page rendering. A page load begins when a user selects a hyperlink, submits a form, or types a URL in a browser. This is also referred to as the initial request or the navigation start. The user's action sends a request across the network to the web application server. The request reaches the application for processing. (The request may take some time to start being processed. This could be the result of request queuing or it could be other factors.) The app finishes processing and sends an HTML response back across the network to the user's browser. This is sometimes referred to as response start or first byte. (Time To First Byte) The user's browser begins receiving the HTML response, and starts to process the Document Object Model, or DOM. The DOM finishes loading; this point is known as DOM ready. Using the DOM, the user's browser starts to render the page. The page finishes rendering in the user's browser and the window load event fires. (For pages that use asynchronous loading, some elements may continue to load after the window load event occurs.) Page load time charts in browser monitoring Browser monitoring captures the major page load timing segments in the browser Summary page and the Page views page. If you have SPA monitoring enabled, you will have access to both this chart and SPA-specific charts. The charts show: Network Web application time DOM processing Page rendering Other segments as applicable, such as request queuing The chart colors match the colors in the page load timing diagram. one.newrelic.com > Browser > (select an app) > Summary: The load time chart appears on the Summary and Page views page. The way browser collects these times depends on the browser's capability to use the Navigation Timing Specification API. You can add custom page load timing events with the browser agent API. Here are descriptions of the activity included in the browser load time chart segments: Web application The web application time includes the time spent on the application server. This can only be determined if the browser instrumentation for page load timing was provided by an APM agent. Network The Network layer includes time spent in redirects as well as in requesting and receiving HTML. It does not include time on the server or for static assets. Network time measurement starts from the initial click on a link. Network time includes DNS and may include more than one lookup if you have redirects on your site, TCP (including the firewall, unless you have configured request queue time monitoring), and SSL connect time. If you have configured request queue time monitoring, then the network time does not include any of the request queue time that occurs after the X-Request header. If you have not configured request queue time monitoring, then the network time does include all of the request queue time. The Navigation Timing Specification API provides a detailed breakdown of network time. (For old browsers, the timer starts on the \"before unload event.\") For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. This is because browser relies on the server-side agent to pass the application values to the browser agent through auto-injection. For more information about how this back-end time breaks down from the browser's point of view, use the Session traces page. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser is spending time on DNS lookups and other network events. Important Even with request queuing configured, the front-end server's setup can still affect network time. This is because the front-end server does not add the queueing time header until after it actually accepts and processes the request. If the front-end server is configured in some way that causes requests to start backlogging and to queue up in the listener socket that the front-end server uses to accept connections, then you will see network time increase for browser monitoring. The queueing time headers can never account for backlog in this listener socket. DOM processing DOM processing is the time it takes to parse the HTML into a DOM and retrieve or execute synchronous scripts. If the browser starts to download images in this phase, page load timing will capture the image load time. The DOM processing and page rendering layers include network time for static assets (assets that are not explicitly retrieved after page load). However, if a script on the page dynamically inserts image tags and loads images after the server or content delivery system (CDN) finishes, page load timing cannot capture the image load time. Page rendering The Page rendering phase is the time between the DOM being complete and the window load event. This phase measures browser-side processing of the page content, and often includes time for scripts and static assets to load. Request queuing Request queuing will be displayed in the load time chart if your account has both browser and APM linked. In New Relic, request queuing refers to the time between a request entering your production systems and it reaching your application. Depending on the specifics of your production infrastructure, this time may include an actual queue that requests enter, or it may represent other functions that take time (such as load balancing or internal network latency). App server requests vs. browser transactions Often the number of app server transactions (requests per minute or rpm) is larger than the number of browser transactions (pages per minute or ppm) for the same application. For more information, see the troubleshooting procedures. Outliers No matter how well your application performs, there will be some slow browsers, platforms, and networks that make your overall aggregate response times appear slower. To minimize the skew caused by outliers, page load timing clamps and scales the end user response times that are greater than 4.5 times your application's browser Apdex T setting to 4.5 times the Apdex T, or to 13.5 seconds, whichever is greater. (Histogram outliers are cut off at 95%.) For example, if your application's end user Apdex T threshold is 8 seconds, those response times will be clamped at 36 seconds. This minimizes the impact of these response times on your overall application but still provides accounting for \"frustrated\" Apdex scores. For SPA monitoring, outliers are handled differently. When the duration of an initial page load or route change reaches 30 minutes, that event is treated as invalid data and is discarded.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 276.33224,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Page</em> <em>load</em> <em>timing</em> process",
        "sections": "<em>Page</em> <em>load</em> <em>time</em> charts in <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "This document explains: How a web <em>page</em> loads How <em>browser</em> <em>monitoring</em> measures <em>page</em> <em>load</em> <em>timing</em>, also known as real user <em>monitoring</em> (RUM) Tip This is a description of traditional, synchronous <em>page</em> <em>load</em> <em>timing</em>. <em>Browser</em> can also <em>monitor</em> asynchronous <em>page</em> <em>load</em> <em>timing</em>. <em>Page</em> <em>load</em> process Here"
      },
      "id": "6043efdf28ccbc21ff2c60a2"
    },
    {
      "sections": [
        "Navigation start time unknown",
        "Contents",
        "Network estimate",
        "Network estimate unavailable",
        "For more help"
      ],
      "title": "Navigation start time unknown",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "e0c839e445b4309c62704afd01702e6588232b45",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/navigation-start-time-unknown/",
      "published_at": "2021-10-24T15:02:51Z",
      "updated_at": "2021-07-10T02:45:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If a browser does not use the Navigation timing API for page load timing, the browser uses a cookie to determine the navigation start time. If a user navigates from a site without page load timing to a site with page load timing (for example, to the first page on your page load timing-enabled site), special considerations for navigation start time arise. Contents Network estimate The page load timing JavaScript utility file creates a cookie with the navigation start time when a user leaves a page (by hooking an event, beforeunload, or pagehide, depending on the browser). However, when navigating away from a site without page load timing enabled, the JavaScript code will not be present, and the cookie will not be created. Then, when the user hits the first page of a site, the navigation start time cannot be determined, because there is no cookie. In this case the browser agent has all the data (queue time, app time, DOM content and rendering time) except network time. Navigation start time is required to compute network time. Rather than toss the data, the page load timing feature estimates the network time based on recently accumulated averages for your application, regionally. This way the page load timing feature provides a more accurate throughput measurement, and the rest of the data is retained. This is especially important for sites with a high bounce rate (when users visit only one page). The more visitors you have from different regions, the more accurate the network estimate will be. Network estimate unavailable If a network estimate is not available for your application and for the region where the hit originated, the page load timing process reverts to a network estimate across all reporting apps for the region. Failing that, the data is tossed. Note: For browsers that have the Navigation Timing API, this is not an issue, as the navigation start time can be determined without using a cookie. For more help Additional documentation resources include: Instrumentation for page load timing (JavaScript elements, data transmission) Page load timing process (overview including time segments and colors, differences between app server requests and page load timing, outliers)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 217.49881,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Navigation start <em>time</em> unknown",
        "sections": "Navigation start <em>time</em> unknown",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "If a <em>browser</em> does not use the Navigation <em>timing</em> API for <em>page</em> <em>load</em> <em>timing</em>, the <em>browser</em> uses a cookie to determine the navigation start <em>time</em>. If a user navigates from a site without <em>page</em> <em>load</em> <em>timing</em> to a site with <em>page</em> <em>load</em> <em>timing</em> (for example, to the first <em>page</em> on your <em>page</em> <em>load</em> <em>timing</em>-enabled site"
      },
      "id": "6043ec3ae7b9d2b8d95799be"
    }
  ],
  "/docs/browser/new-relic-browser/page-load-timing-resources/instrumentation-browser-monitoring": [
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-24T14:51:57Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 276.89417,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "sections": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": " and firstContentfulPaint attributes already are available with <em>Browser</em>Interaction and <em>Page</em>View events. However, they are not always reliably captured before the window onload event fires. Using <em>PageViewTiming</em> gives you a way to capture these metrics even if they happen after the original <em>page</em> <em>load</em> <em>time</em>"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "Page load timing process",
        "Tip",
        "Page load process",
        "Page load time charts in browser monitoring",
        "Web application",
        "Network",
        "Important",
        "DOM processing",
        "Page rendering",
        "Request queuing",
        "App server requests vs. browser transactions",
        "Outliers"
      ],
      "title": "Page load timing process",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "3c1b807e4433968a69a461a95e612812ff0ff8e9",
      "image": "https://docs.newrelic.com/static/ade867510b645a97e56c905e4cf019f9/8c557/browser-page-load-timeline.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/page-load-timing-process/",
      "published_at": "2021-10-24T14:58:33Z",
      "updated_at": "2021-10-07T03:03:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains: How a web page loads How browser monitoring measures page load timing, also known as real user monitoring (RUM) Tip This is a description of traditional, synchronous page load timing. Browser can also monitor asynchronous page load timing. Page load process Here are the major steps in the loading of most web pages. The numbers 1-6 in the diagram correspond to the numbered steps below. Page load timeline: The steps involved in a web page load. Browser monitoring charts display the following segments of that process: Network, Web application, DOM processing, and Page rendering. A page load begins when a user selects a hyperlink, submits a form, or types a URL in a browser. This is also referred to as the initial request or the navigation start. The user's action sends a request across the network to the web application server. The request reaches the application for processing. (The request may take some time to start being processed. This could be the result of request queuing or it could be other factors.) The app finishes processing and sends an HTML response back across the network to the user's browser. This is sometimes referred to as response start or first byte. (Time To First Byte) The user's browser begins receiving the HTML response, and starts to process the Document Object Model, or DOM. The DOM finishes loading; this point is known as DOM ready. Using the DOM, the user's browser starts to render the page. The page finishes rendering in the user's browser and the window load event fires. (For pages that use asynchronous loading, some elements may continue to load after the window load event occurs.) Page load time charts in browser monitoring Browser monitoring captures the major page load timing segments in the browser Summary page and the Page views page. If you have SPA monitoring enabled, you will have access to both this chart and SPA-specific charts. The charts show: Network Web application time DOM processing Page rendering Other segments as applicable, such as request queuing The chart colors match the colors in the page load timing diagram. one.newrelic.com > Browser > (select an app) > Summary: The load time chart appears on the Summary and Page views page. The way browser collects these times depends on the browser's capability to use the Navigation Timing Specification API. You can add custom page load timing events with the browser agent API. Here are descriptions of the activity included in the browser load time chart segments: Web application The web application time includes the time spent on the application server. This can only be determined if the browser instrumentation for page load timing was provided by an APM agent. Network The Network layer includes time spent in redirects as well as in requesting and receiving HTML. It does not include time on the server or for static assets. Network time measurement starts from the initial click on a link. Network time includes DNS and may include more than one lookup if you have redirects on your site, TCP (including the firewall, unless you have configured request queue time monitoring), and SSL connect time. If you have configured request queue time monitoring, then the network time does not include any of the request queue time that occurs after the X-Request header. If you have not configured request queue time monitoring, then the network time does include all of the request queue time. The Navigation Timing Specification API provides a detailed breakdown of network time. (For old browsers, the timer starts on the \"before unload event.\") For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. This is because browser relies on the server-side agent to pass the application values to the browser agent through auto-injection. For more information about how this back-end time breaks down from the browser's point of view, use the Session traces page. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser is spending time on DNS lookups and other network events. Important Even with request queuing configured, the front-end server's setup can still affect network time. This is because the front-end server does not add the queueing time header until after it actually accepts and processes the request. If the front-end server is configured in some way that causes requests to start backlogging and to queue up in the listener socket that the front-end server uses to accept connections, then you will see network time increase for browser monitoring. The queueing time headers can never account for backlog in this listener socket. DOM processing DOM processing is the time it takes to parse the HTML into a DOM and retrieve or execute synchronous scripts. If the browser starts to download images in this phase, page load timing will capture the image load time. The DOM processing and page rendering layers include network time for static assets (assets that are not explicitly retrieved after page load). However, if a script on the page dynamically inserts image tags and loads images after the server or content delivery system (CDN) finishes, page load timing cannot capture the image load time. Page rendering The Page rendering phase is the time between the DOM being complete and the window load event. This phase measures browser-side processing of the page content, and often includes time for scripts and static assets to load. Request queuing Request queuing will be displayed in the load time chart if your account has both browser and APM linked. In New Relic, request queuing refers to the time between a request entering your production systems and it reaching your application. Depending on the specifics of your production infrastructure, this time may include an actual queue that requests enter, or it may represent other functions that take time (such as load balancing or internal network latency). App server requests vs. browser transactions Often the number of app server transactions (requests per minute or rpm) is larger than the number of browser transactions (pages per minute or ppm) for the same application. For more information, see the troubleshooting procedures. Outliers No matter how well your application performs, there will be some slow browsers, platforms, and networks that make your overall aggregate response times appear slower. To minimize the skew caused by outliers, page load timing clamps and scales the end user response times that are greater than 4.5 times your application's browser Apdex T setting to 4.5 times the Apdex T, or to 13.5 seconds, whichever is greater. (Histogram outliers are cut off at 95%.) For example, if your application's end user Apdex T threshold is 8 seconds, those response times will be clamped at 36 seconds. This minimizes the impact of these response times on your overall application but still provides accounting for \"frustrated\" Apdex scores. For SPA monitoring, outliers are handled differently. When the duration of an initial page load or route change reaches 30 minutes, that event is treated as invalid data and is discarded.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 276.3322,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Page</em> <em>load</em> <em>timing</em> process",
        "sections": "<em>Page</em> <em>load</em> <em>time</em> charts in <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "This document explains: How a web <em>page</em> loads How <em>browser</em> <em>monitoring</em> measures <em>page</em> <em>load</em> <em>timing</em>, also known as real user <em>monitoring</em> (RUM) Tip This is a description of traditional, synchronous <em>page</em> <em>load</em> <em>timing</em>. <em>Browser</em> can also <em>monitor</em> asynchronous <em>page</em> <em>load</em> <em>timing</em>. <em>Page</em> <em>load</em> process Here"
      },
      "id": "6043efdf28ccbc21ff2c60a2"
    },
    {
      "sections": [
        "Navigation start time unknown",
        "Contents",
        "Network estimate",
        "Network estimate unavailable",
        "For more help"
      ],
      "title": "Navigation start time unknown",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "e0c839e445b4309c62704afd01702e6588232b45",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/navigation-start-time-unknown/",
      "published_at": "2021-10-24T15:02:51Z",
      "updated_at": "2021-07-10T02:45:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If a browser does not use the Navigation timing API for page load timing, the browser uses a cookie to determine the navigation start time. If a user navigates from a site without page load timing to a site with page load timing (for example, to the first page on your page load timing-enabled site), special considerations for navigation start time arise. Contents Network estimate The page load timing JavaScript utility file creates a cookie with the navigation start time when a user leaves a page (by hooking an event, beforeunload, or pagehide, depending on the browser). However, when navigating away from a site without page load timing enabled, the JavaScript code will not be present, and the cookie will not be created. Then, when the user hits the first page of a site, the navigation start time cannot be determined, because there is no cookie. In this case the browser agent has all the data (queue time, app time, DOM content and rendering time) except network time. Navigation start time is required to compute network time. Rather than toss the data, the page load timing feature estimates the network time based on recently accumulated averages for your application, regionally. This way the page load timing feature provides a more accurate throughput measurement, and the rest of the data is retained. This is especially important for sites with a high bounce rate (when users visit only one page). The more visitors you have from different regions, the more accurate the network estimate will be. Network estimate unavailable If a network estimate is not available for your application and for the region where the hit originated, the page load timing process reverts to a network estimate across all reporting apps for the region. Failing that, the data is tossed. Note: For browsers that have the Navigation Timing API, this is not an issue, as the navigation start time can be determined without using a cookie. For more help Additional documentation resources include: Instrumentation for page load timing (JavaScript elements, data transmission) Page load timing process (overview including time segments and colors, differences between app server requests and page load timing, outliers)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 217.49881,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Navigation start <em>time</em> unknown",
        "sections": "Navigation start <em>time</em> unknown",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "If a <em>browser</em> does not use the Navigation <em>timing</em> API for <em>page</em> <em>load</em> <em>timing</em>, the <em>browser</em> uses a cookie to determine the navigation start <em>time</em>. If a user navigates from a site without <em>page</em> <em>load</em> <em>timing</em> to a site with <em>page</em> <em>load</em> <em>timing</em> (for example, to the first <em>page</em> on your <em>page</em> <em>load</em> <em>timing</em>-enabled site"
      },
      "id": "6043ec3ae7b9d2b8d95799be"
    }
  ],
  "/docs/browser/new-relic-browser/page-load-timing-resources/navigation-start-time-unknown": [
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-24T14:51:57Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 276.89417,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "sections": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": " and firstContentfulPaint attributes already are available with <em>Browser</em>Interaction and <em>Page</em>View events. However, they are not always reliably captured before the window onload event fires. Using <em>PageViewTiming</em> gives you a way to capture these metrics even if they happen after the original <em>page</em> <em>load</em> <em>time</em>"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "Page load timing process",
        "Tip",
        "Page load process",
        "Page load time charts in browser monitoring",
        "Web application",
        "Network",
        "Important",
        "DOM processing",
        "Page rendering",
        "Request queuing",
        "App server requests vs. browser transactions",
        "Outliers"
      ],
      "title": "Page load timing process",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "3c1b807e4433968a69a461a95e612812ff0ff8e9",
      "image": "https://docs.newrelic.com/static/ade867510b645a97e56c905e4cf019f9/8c557/browser-page-load-timeline.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/page-load-timing-process/",
      "published_at": "2021-10-24T14:58:33Z",
      "updated_at": "2021-10-07T03:03:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains: How a web page loads How browser monitoring measures page load timing, also known as real user monitoring (RUM) Tip This is a description of traditional, synchronous page load timing. Browser can also monitor asynchronous page load timing. Page load process Here are the major steps in the loading of most web pages. The numbers 1-6 in the diagram correspond to the numbered steps below. Page load timeline: The steps involved in a web page load. Browser monitoring charts display the following segments of that process: Network, Web application, DOM processing, and Page rendering. A page load begins when a user selects a hyperlink, submits a form, or types a URL in a browser. This is also referred to as the initial request or the navigation start. The user's action sends a request across the network to the web application server. The request reaches the application for processing. (The request may take some time to start being processed. This could be the result of request queuing or it could be other factors.) The app finishes processing and sends an HTML response back across the network to the user's browser. This is sometimes referred to as response start or first byte. (Time To First Byte) The user's browser begins receiving the HTML response, and starts to process the Document Object Model, or DOM. The DOM finishes loading; this point is known as DOM ready. Using the DOM, the user's browser starts to render the page. The page finishes rendering in the user's browser and the window load event fires. (For pages that use asynchronous loading, some elements may continue to load after the window load event occurs.) Page load time charts in browser monitoring Browser monitoring captures the major page load timing segments in the browser Summary page and the Page views page. If you have SPA monitoring enabled, you will have access to both this chart and SPA-specific charts. The charts show: Network Web application time DOM processing Page rendering Other segments as applicable, such as request queuing The chart colors match the colors in the page load timing diagram. one.newrelic.com > Browser > (select an app) > Summary: The load time chart appears on the Summary and Page views page. The way browser collects these times depends on the browser's capability to use the Navigation Timing Specification API. You can add custom page load timing events with the browser agent API. Here are descriptions of the activity included in the browser load time chart segments: Web application The web application time includes the time spent on the application server. This can only be determined if the browser instrumentation for page load timing was provided by an APM agent. Network The Network layer includes time spent in redirects as well as in requesting and receiving HTML. It does not include time on the server or for static assets. Network time measurement starts from the initial click on a link. Network time includes DNS and may include more than one lookup if you have redirects on your site, TCP (including the firewall, unless you have configured request queue time monitoring), and SSL connect time. If you have configured request queue time monitoring, then the network time does not include any of the request queue time that occurs after the X-Request header. If you have not configured request queue time monitoring, then the network time does include all of the request queue time. The Navigation Timing Specification API provides a detailed breakdown of network time. (For old browsers, the timer starts on the \"before unload event.\") For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. This is because browser relies on the server-side agent to pass the application values to the browser agent through auto-injection. For more information about how this back-end time breaks down from the browser's point of view, use the Session traces page. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser is spending time on DNS lookups and other network events. Important Even with request queuing configured, the front-end server's setup can still affect network time. This is because the front-end server does not add the queueing time header until after it actually accepts and processes the request. If the front-end server is configured in some way that causes requests to start backlogging and to queue up in the listener socket that the front-end server uses to accept connections, then you will see network time increase for browser monitoring. The queueing time headers can never account for backlog in this listener socket. DOM processing DOM processing is the time it takes to parse the HTML into a DOM and retrieve or execute synchronous scripts. If the browser starts to download images in this phase, page load timing will capture the image load time. The DOM processing and page rendering layers include network time for static assets (assets that are not explicitly retrieved after page load). However, if a script on the page dynamically inserts image tags and loads images after the server or content delivery system (CDN) finishes, page load timing cannot capture the image load time. Page rendering The Page rendering phase is the time between the DOM being complete and the window load event. This phase measures browser-side processing of the page content, and often includes time for scripts and static assets to load. Request queuing Request queuing will be displayed in the load time chart if your account has both browser and APM linked. In New Relic, request queuing refers to the time between a request entering your production systems and it reaching your application. Depending on the specifics of your production infrastructure, this time may include an actual queue that requests enter, or it may represent other functions that take time (such as load balancing or internal network latency). App server requests vs. browser transactions Often the number of app server transactions (requests per minute or rpm) is larger than the number of browser transactions (pages per minute or ppm) for the same application. For more information, see the troubleshooting procedures. Outliers No matter how well your application performs, there will be some slow browsers, platforms, and networks that make your overall aggregate response times appear slower. To minimize the skew caused by outliers, page load timing clamps and scales the end user response times that are greater than 4.5 times your application's browser Apdex T setting to 4.5 times the Apdex T, or to 13.5 seconds, whichever is greater. (Histogram outliers are cut off at 95%.) For example, if your application's end user Apdex T threshold is 8 seconds, those response times will be clamped at 36 seconds. This minimizes the impact of these response times on your overall application but still provides accounting for \"frustrated\" Apdex scores. For SPA monitoring, outliers are handled differently. When the duration of an initial page load or route change reaches 30 minutes, that event is treated as invalid data and is discarded.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 276.3322,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Page</em> <em>load</em> <em>timing</em> process",
        "sections": "<em>Page</em> <em>load</em> <em>time</em> charts in <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "This document explains: How a web <em>page</em> loads How <em>browser</em> <em>monitoring</em> measures <em>page</em> <em>load</em> <em>timing</em>, also known as real user <em>monitoring</em> (RUM) Tip This is a description of traditional, synchronous <em>page</em> <em>load</em> <em>timing</em>. <em>Browser</em> can also <em>monitor</em> asynchronous <em>page</em> <em>load</em> <em>timing</em>. <em>Page</em> <em>load</em> process Here"
      },
      "id": "6043efdf28ccbc21ff2c60a2"
    },
    {
      "sections": [
        "Instrumentation for browser monitoring",
        "Instrumentation to collect browser data",
        "JavaScript placement requirements",
        "Data transmission",
        "Important"
      ],
      "title": "Instrumentation for browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "a259fb8312470318f7907a17a9d228a3cf847a36",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/instrumentation-browser-monitoring/",
      "published_at": "2021-10-24T15:01:57Z",
      "updated_at": "2021-07-10T02:44:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For standard page load timing, sometimes referred to as real user monitoring (RUM), we measure the overall time to load the entire webpage. Additional monitoring after page load provides details on in-page AJAX calls, JavaScript errors, and other events and interactions. Browser monitoring can leverage the New Relic agent to dynamically inject JavaScript into pages as they are built, in order to collect more detailed back-end timing information. Browser can also monitor apps with single-page application (SPA) architectures. Instrumentation to collect browser data To collect data, browser monitoring uses JavaScript elements pasted or injected into your webpages, typically as part of the HEAD of the page, containing configuration details and essential browser environment instrumentation. Once the page finishes loading, an additional script is downloaded from a CDN server. This additional script processes the collected data and reports it back to New Relic via bam.nr-data.net so that you can see the data in your New Relic account. The script elements can be injected automatically or via the agent API by an APM agent installed in the back-end application, or they can be inserted manually via copy/paste. Both API calls and the copy/paste method allow you to control when and where the script elements are inserted. We use these methods to collect the page load timing information: Method Collecting page load timing information Browsers with Navigation Timing Specification API For browsers that implement the Navigation Timing Specification API, page load timing information is read from the browser and reported to New Relic by the browser agent. The appropriate values simply are read from the webpage's performance timing object to capture the timing information. Navigation start: navigationStart First byte: responseStart DOM ready: DOMContentLoadedEventEnd Page ready: loadEventEnd Browsers without Navigation Timing Specification API For browsers that do not implement the Navigation Timing Specification API, we rely on the NREUM cookie and the browser agent to collect timing information. Additional instrumentation Browser also uses: Instrumentation of the XMLHttpRequest object to collect AJAX timing data. Instrumentation of JavaScript functions to collect uncaught JavaScript errors. Resource Timing API For browsers that implement the Resource Timing API, the browser agent reads and reports session trace details. Single page app (SPA) monitoring For SPA monitoring, we require the Navigation Timing Specification API and the addEventListener API. JavaScript placement requirements Injecting the JavaScript inline in the HEAD is an unusual requirement for a JavaScript library, and different from how third-party scripts are typically included. We require this so that browser provides accurate information without impacting page load performance. The injected browser JavaScript elements wrap many of the browser's built in APIs to record information about JavaScript errors or callback timings. The unusual placement of the code element is necessary for the following reasons: The inline HEAD placement ensures the instrumentation code is loaded before all other scripts so that wrapping will occur when other libraries are registered. Inline code placement also eliminates the network round trips caused by externally referenced scripts. Data transmission For both https and http webpages, we transmit data via https. This summarizes when the data is transmitted to and from the webpage. Important New Relic requires support of the SHA256 hash function, which some older operating systems do not support. If an end user lacks SHA256, the browser agent will not connect to New Relic and data will not be sent. Data transmission Frequency Fetch the agent script Once following page load via https Send page load timing data Once following page load via https Send AJAX and JavaScript error data Once per minute when there is activity via https Send session trace data Every ten seconds when there is activity and a session trace is occurring via https Send SPA data At the end of an interaction via https",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 217.49872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Instrumentation for <em>browser</em> <em>monitoring</em>",
        "sections": "Instrumentation for <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "For standard <em>page</em> <em>load</em> <em>timing</em>, sometimes referred to as real user <em>monitoring</em> (RUM), we measure the overall <em>time</em> to <em>load</em> the entire webpage. Additional <em>monitoring</em> after <em>page</em> <em>load</em> provides details on in-<em>page</em> AJAX calls, JavaScript errors, and other events and interactions. <em>Browser</em> <em>monitoring</em> can"
      },
      "id": "6043ef69e7b9d2d7055799f9"
    }
  ],
  "/docs/browser/new-relic-browser/page-load-timing-resources/page-load-timing-process": [
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-24T14:51:57Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 276.89413,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "sections": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": " and firstContentfulPaint attributes already are available with <em>Browser</em>Interaction and <em>Page</em>View events. However, they are not always reliably captured before the window onload event fires. Using <em>PageViewTiming</em> gives you a way to capture these metrics even if they happen after the original <em>page</em> <em>load</em> <em>time</em>"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "Navigation start time unknown",
        "Contents",
        "Network estimate",
        "Network estimate unavailable",
        "For more help"
      ],
      "title": "Navigation start time unknown",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "e0c839e445b4309c62704afd01702e6588232b45",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/navigation-start-time-unknown/",
      "published_at": "2021-10-24T15:02:51Z",
      "updated_at": "2021-07-10T02:45:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If a browser does not use the Navigation timing API for page load timing, the browser uses a cookie to determine the navigation start time. If a user navigates from a site without page load timing to a site with page load timing (for example, to the first page on your page load timing-enabled site), special considerations for navigation start time arise. Contents Network estimate The page load timing JavaScript utility file creates a cookie with the navigation start time when a user leaves a page (by hooking an event, beforeunload, or pagehide, depending on the browser). However, when navigating away from a site without page load timing enabled, the JavaScript code will not be present, and the cookie will not be created. Then, when the user hits the first page of a site, the navigation start time cannot be determined, because there is no cookie. In this case the browser agent has all the data (queue time, app time, DOM content and rendering time) except network time. Navigation start time is required to compute network time. Rather than toss the data, the page load timing feature estimates the network time based on recently accumulated averages for your application, regionally. This way the page load timing feature provides a more accurate throughput measurement, and the rest of the data is retained. This is especially important for sites with a high bounce rate (when users visit only one page). The more visitors you have from different regions, the more accurate the network estimate will be. Network estimate unavailable If a network estimate is not available for your application and for the region where the hit originated, the page load timing process reverts to a network estimate across all reporting apps for the region. Failing that, the data is tossed. Note: For browsers that have the Navigation Timing API, this is not an issue, as the navigation start time can be determined without using a cookie. For more help Additional documentation resources include: Instrumentation for page load timing (JavaScript elements, data transmission) Page load timing process (overview including time segments and colors, differences between app server requests and page load timing, outliers)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 217.49881,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Navigation start <em>time</em> unknown",
        "sections": "Navigation start <em>time</em> unknown",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "If a <em>browser</em> does not use the Navigation <em>timing</em> API for <em>page</em> <em>load</em> <em>timing</em>, the <em>browser</em> uses a cookie to determine the navigation start <em>time</em>. If a user navigates from a site without <em>page</em> <em>load</em> <em>timing</em> to a site with <em>page</em> <em>load</em> <em>timing</em> (for example, to the first <em>page</em> on your <em>page</em> <em>load</em> <em>timing</em>-enabled site"
      },
      "id": "6043ec3ae7b9d2b8d95799be"
    },
    {
      "sections": [
        "Instrumentation for browser monitoring",
        "Instrumentation to collect browser data",
        "JavaScript placement requirements",
        "Data transmission",
        "Important"
      ],
      "title": "Instrumentation for browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "a259fb8312470318f7907a17a9d228a3cf847a36",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/instrumentation-browser-monitoring/",
      "published_at": "2021-10-24T15:01:57Z",
      "updated_at": "2021-07-10T02:44:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For standard page load timing, sometimes referred to as real user monitoring (RUM), we measure the overall time to load the entire webpage. Additional monitoring after page load provides details on in-page AJAX calls, JavaScript errors, and other events and interactions. Browser monitoring can leverage the New Relic agent to dynamically inject JavaScript into pages as they are built, in order to collect more detailed back-end timing information. Browser can also monitor apps with single-page application (SPA) architectures. Instrumentation to collect browser data To collect data, browser monitoring uses JavaScript elements pasted or injected into your webpages, typically as part of the HEAD of the page, containing configuration details and essential browser environment instrumentation. Once the page finishes loading, an additional script is downloaded from a CDN server. This additional script processes the collected data and reports it back to New Relic via bam.nr-data.net so that you can see the data in your New Relic account. The script elements can be injected automatically or via the agent API by an APM agent installed in the back-end application, or they can be inserted manually via copy/paste. Both API calls and the copy/paste method allow you to control when and where the script elements are inserted. We use these methods to collect the page load timing information: Method Collecting page load timing information Browsers with Navigation Timing Specification API For browsers that implement the Navigation Timing Specification API, page load timing information is read from the browser and reported to New Relic by the browser agent. The appropriate values simply are read from the webpage's performance timing object to capture the timing information. Navigation start: navigationStart First byte: responseStart DOM ready: DOMContentLoadedEventEnd Page ready: loadEventEnd Browsers without Navigation Timing Specification API For browsers that do not implement the Navigation Timing Specification API, we rely on the NREUM cookie and the browser agent to collect timing information. Additional instrumentation Browser also uses: Instrumentation of the XMLHttpRequest object to collect AJAX timing data. Instrumentation of JavaScript functions to collect uncaught JavaScript errors. Resource Timing API For browsers that implement the Resource Timing API, the browser agent reads and reports session trace details. Single page app (SPA) monitoring For SPA monitoring, we require the Navigation Timing Specification API and the addEventListener API. JavaScript placement requirements Injecting the JavaScript inline in the HEAD is an unusual requirement for a JavaScript library, and different from how third-party scripts are typically included. We require this so that browser provides accurate information without impacting page load performance. The injected browser JavaScript elements wrap many of the browser's built in APIs to record information about JavaScript errors or callback timings. The unusual placement of the code element is necessary for the following reasons: The inline HEAD placement ensures the instrumentation code is loaded before all other scripts so that wrapping will occur when other libraries are registered. Inline code placement also eliminates the network round trips caused by externally referenced scripts. Data transmission For both https and http webpages, we transmit data via https. This summarizes when the data is transmitted to and from the webpage. Important New Relic requires support of the SHA256 hash function, which some older operating systems do not support. If an end user lacks SHA256, the browser agent will not connect to New Relic and data will not be sent. Data transmission Frequency Fetch the agent script Once following page load via https Send page load timing data Once following page load via https Send AJAX and JavaScript error data Once per minute when there is activity via https Send session trace data Every ten seconds when there is activity and a session trace is occurring via https Send SPA data At the end of an interaction via https",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 217.49872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Instrumentation for <em>browser</em> <em>monitoring</em>",
        "sections": "Instrumentation for <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "For standard <em>page</em> <em>load</em> <em>timing</em>, sometimes referred to as real user <em>monitoring</em> (RUM), we measure the overall <em>time</em> to <em>load</em> the entire webpage. Additional <em>monitoring</em> after <em>page</em> <em>load</em> provides details on in-<em>page</em> AJAX calls, JavaScript errors, and other events and interactions. <em>Browser</em> <em>monitoring</em> can"
      },
      "id": "6043ef69e7b9d2d7055799f9"
    }
  ],
  "/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details": [
    {
      "sections": [
        "Page load timing process",
        "Tip",
        "Page load process",
        "Page load time charts in browser monitoring",
        "Web application",
        "Network",
        "Important",
        "DOM processing",
        "Page rendering",
        "Request queuing",
        "App server requests vs. browser transactions",
        "Outliers"
      ],
      "title": "Page load timing process",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "3c1b807e4433968a69a461a95e612812ff0ff8e9",
      "image": "https://docs.newrelic.com/static/ade867510b645a97e56c905e4cf019f9/8c557/browser-page-load-timeline.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/page-load-timing-process/",
      "published_at": "2021-10-24T14:58:33Z",
      "updated_at": "2021-10-07T03:03:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains: How a web page loads How browser monitoring measures page load timing, also known as real user monitoring (RUM) Tip This is a description of traditional, synchronous page load timing. Browser can also monitor asynchronous page load timing. Page load process Here are the major steps in the loading of most web pages. The numbers 1-6 in the diagram correspond to the numbered steps below. Page load timeline: The steps involved in a web page load. Browser monitoring charts display the following segments of that process: Network, Web application, DOM processing, and Page rendering. A page load begins when a user selects a hyperlink, submits a form, or types a URL in a browser. This is also referred to as the initial request or the navigation start. The user's action sends a request across the network to the web application server. The request reaches the application for processing. (The request may take some time to start being processed. This could be the result of request queuing or it could be other factors.) The app finishes processing and sends an HTML response back across the network to the user's browser. This is sometimes referred to as response start or first byte. (Time To First Byte) The user's browser begins receiving the HTML response, and starts to process the Document Object Model, or DOM. The DOM finishes loading; this point is known as DOM ready. Using the DOM, the user's browser starts to render the page. The page finishes rendering in the user's browser and the window load event fires. (For pages that use asynchronous loading, some elements may continue to load after the window load event occurs.) Page load time charts in browser monitoring Browser monitoring captures the major page load timing segments in the browser Summary page and the Page views page. If you have SPA monitoring enabled, you will have access to both this chart and SPA-specific charts. The charts show: Network Web application time DOM processing Page rendering Other segments as applicable, such as request queuing The chart colors match the colors in the page load timing diagram. one.newrelic.com > Browser > (select an app) > Summary: The load time chart appears on the Summary and Page views page. The way browser collects these times depends on the browser's capability to use the Navigation Timing Specification API. You can add custom page load timing events with the browser agent API. Here are descriptions of the activity included in the browser load time chart segments: Web application The web application time includes the time spent on the application server. This can only be determined if the browser instrumentation for page load timing was provided by an APM agent. Network The Network layer includes time spent in redirects as well as in requesting and receiving HTML. It does not include time on the server or for static assets. Network time measurement starts from the initial click on a link. Network time includes DNS and may include more than one lookup if you have redirects on your site, TCP (including the firewall, unless you have configured request queue time monitoring), and SSL connect time. If you have configured request queue time monitoring, then the network time does not include any of the request queue time that occurs after the X-Request header. If you have not configured request queue time monitoring, then the network time does include all of the request queue time. The Navigation Timing Specification API provides a detailed breakdown of network time. (For old browsers, the timer starts on the \"before unload event.\") For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. This is because browser relies on the server-side agent to pass the application values to the browser agent through auto-injection. For more information about how this back-end time breaks down from the browser's point of view, use the Session traces page. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser is spending time on DNS lookups and other network events. Important Even with request queuing configured, the front-end server's setup can still affect network time. This is because the front-end server does not add the queueing time header until after it actually accepts and processes the request. If the front-end server is configured in some way that causes requests to start backlogging and to queue up in the listener socket that the front-end server uses to accept connections, then you will see network time increase for browser monitoring. The queueing time headers can never account for backlog in this listener socket. DOM processing DOM processing is the time it takes to parse the HTML into a DOM and retrieve or execute synchronous scripts. If the browser starts to download images in this phase, page load timing will capture the image load time. The DOM processing and page rendering layers include network time for static assets (assets that are not explicitly retrieved after page load). However, if a script on the page dynamically inserts image tags and loads images after the server or content delivery system (CDN) finishes, page load timing cannot capture the image load time. Page rendering The Page rendering phase is the time between the DOM being complete and the window load event. This phase measures browser-side processing of the page content, and often includes time for scripts and static assets to load. Request queuing Request queuing will be displayed in the load time chart if your account has both browser and APM linked. In New Relic, request queuing refers to the time between a request entering your production systems and it reaching your application. Depending on the specifics of your production infrastructure, this time may include an actual queue that requests enter, or it may represent other functions that take time (such as load balancing or internal network latency). App server requests vs. browser transactions Often the number of app server transactions (requests per minute or rpm) is larger than the number of browser transactions (pages per minute or ppm) for the same application. For more information, see the troubleshooting procedures. Outliers No matter how well your application performs, there will be some slow browsers, platforms, and networks that make your overall aggregate response times appear slower. To minimize the skew caused by outliers, page load timing clamps and scales the end user response times that are greater than 4.5 times your application's browser Apdex T setting to 4.5 times the Apdex T, or to 13.5 seconds, whichever is greater. (Histogram outliers are cut off at 95%.) For example, if your application's end user Apdex T threshold is 8 seconds, those response times will be clamped at 36 seconds. This minimizes the impact of these response times on your overall application but still provides accounting for \"frustrated\" Apdex scores. For SPA monitoring, outliers are handled differently. When the duration of an initial page load or route change reaches 30 minutes, that event is treated as invalid data and is discarded.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 276.33218,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Page</em> <em>load</em> <em>timing</em> process",
        "sections": "<em>Page</em> <em>load</em> <em>time</em> charts in <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "This document explains: How a web <em>page</em> loads How <em>browser</em> <em>monitoring</em> measures <em>page</em> <em>load</em> <em>timing</em>, also known as real user <em>monitoring</em> (RUM) Tip This is a description of traditional, synchronous <em>page</em> <em>load</em> <em>timing</em>. <em>Browser</em> can also <em>monitor</em> asynchronous <em>page</em> <em>load</em> <em>timing</em>. <em>Page</em> <em>load</em> process Here"
      },
      "id": "6043efdf28ccbc21ff2c60a2"
    },
    {
      "sections": [
        "Navigation start time unknown",
        "Contents",
        "Network estimate",
        "Network estimate unavailable",
        "For more help"
      ],
      "title": "Navigation start time unknown",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "e0c839e445b4309c62704afd01702e6588232b45",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/navigation-start-time-unknown/",
      "published_at": "2021-10-24T15:02:51Z",
      "updated_at": "2021-07-10T02:45:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If a browser does not use the Navigation timing API for page load timing, the browser uses a cookie to determine the navigation start time. If a user navigates from a site without page load timing to a site with page load timing (for example, to the first page on your page load timing-enabled site), special considerations for navigation start time arise. Contents Network estimate The page load timing JavaScript utility file creates a cookie with the navigation start time when a user leaves a page (by hooking an event, beforeunload, or pagehide, depending on the browser). However, when navigating away from a site without page load timing enabled, the JavaScript code will not be present, and the cookie will not be created. Then, when the user hits the first page of a site, the navigation start time cannot be determined, because there is no cookie. In this case the browser agent has all the data (queue time, app time, DOM content and rendering time) except network time. Navigation start time is required to compute network time. Rather than toss the data, the page load timing feature estimates the network time based on recently accumulated averages for your application, regionally. This way the page load timing feature provides a more accurate throughput measurement, and the rest of the data is retained. This is especially important for sites with a high bounce rate (when users visit only one page). The more visitors you have from different regions, the more accurate the network estimate will be. Network estimate unavailable If a network estimate is not available for your application and for the region where the hit originated, the page load timing process reverts to a network estimate across all reporting apps for the region. Failing that, the data is tossed. Note: For browsers that have the Navigation Timing API, this is not an issue, as the navigation start time can be determined without using a cookie. For more help Additional documentation resources include: Instrumentation for page load timing (JavaScript elements, data transmission) Page load timing process (overview including time segments and colors, differences between app server requests and page load timing, outliers)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 217.49881,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Navigation start <em>time</em> unknown",
        "sections": "Navigation start <em>time</em> unknown",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "If a <em>browser</em> does not use the Navigation <em>timing</em> API for <em>page</em> <em>load</em> <em>timing</em>, the <em>browser</em> uses a cookie to determine the navigation start <em>time</em>. If a user navigates from a site without <em>page</em> <em>load</em> <em>timing</em> to a site with <em>page</em> <em>load</em> <em>timing</em> (for example, to the first <em>page</em> on your <em>page</em> <em>load</em> <em>timing</em>-enabled site"
      },
      "id": "6043ec3ae7b9d2b8d95799be"
    },
    {
      "sections": [
        "Instrumentation for browser monitoring",
        "Instrumentation to collect browser data",
        "JavaScript placement requirements",
        "Data transmission",
        "Important"
      ],
      "title": "Instrumentation for browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "a259fb8312470318f7907a17a9d228a3cf847a36",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/instrumentation-browser-monitoring/",
      "published_at": "2021-10-24T15:01:57Z",
      "updated_at": "2021-07-10T02:44:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For standard page load timing, sometimes referred to as real user monitoring (RUM), we measure the overall time to load the entire webpage. Additional monitoring after page load provides details on in-page AJAX calls, JavaScript errors, and other events and interactions. Browser monitoring can leverage the New Relic agent to dynamically inject JavaScript into pages as they are built, in order to collect more detailed back-end timing information. Browser can also monitor apps with single-page application (SPA) architectures. Instrumentation to collect browser data To collect data, browser monitoring uses JavaScript elements pasted or injected into your webpages, typically as part of the HEAD of the page, containing configuration details and essential browser environment instrumentation. Once the page finishes loading, an additional script is downloaded from a CDN server. This additional script processes the collected data and reports it back to New Relic via bam.nr-data.net so that you can see the data in your New Relic account. The script elements can be injected automatically or via the agent API by an APM agent installed in the back-end application, or they can be inserted manually via copy/paste. Both API calls and the copy/paste method allow you to control when and where the script elements are inserted. We use these methods to collect the page load timing information: Method Collecting page load timing information Browsers with Navigation Timing Specification API For browsers that implement the Navigation Timing Specification API, page load timing information is read from the browser and reported to New Relic by the browser agent. The appropriate values simply are read from the webpage's performance timing object to capture the timing information. Navigation start: navigationStart First byte: responseStart DOM ready: DOMContentLoadedEventEnd Page ready: loadEventEnd Browsers without Navigation Timing Specification API For browsers that do not implement the Navigation Timing Specification API, we rely on the NREUM cookie and the browser agent to collect timing information. Additional instrumentation Browser also uses: Instrumentation of the XMLHttpRequest object to collect AJAX timing data. Instrumentation of JavaScript functions to collect uncaught JavaScript errors. Resource Timing API For browsers that implement the Resource Timing API, the browser agent reads and reports session trace details. Single page app (SPA) monitoring For SPA monitoring, we require the Navigation Timing Specification API and the addEventListener API. JavaScript placement requirements Injecting the JavaScript inline in the HEAD is an unusual requirement for a JavaScript library, and different from how third-party scripts are typically included. We require this so that browser provides accurate information without impacting page load performance. The injected browser JavaScript elements wrap many of the browser's built in APIs to record information about JavaScript errors or callback timings. The unusual placement of the code element is necessary for the following reasons: The inline HEAD placement ensures the instrumentation code is loaded before all other scripts so that wrapping will occur when other libraries are registered. Inline code placement also eliminates the network round trips caused by externally referenced scripts. Data transmission For both https and http webpages, we transmit data via https. This summarizes when the data is transmitted to and from the webpage. Important New Relic requires support of the SHA256 hash function, which some older operating systems do not support. If an end user lacks SHA256, the browser agent will not connect to New Relic and data will not be sent. Data transmission Frequency Fetch the agent script Once following page load via https Send page load timing data Once following page load via https Send AJAX and JavaScript error data Once per minute when there is activity via https Send session trace data Every ten seconds when there is activity and a session trace is occurring via https Send SPA data At the end of an interaction via https",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 217.49872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Instrumentation for <em>browser</em> <em>monitoring</em>",
        "sections": "Instrumentation for <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "For standard <em>page</em> <em>load</em> <em>timing</em>, sometimes referred to as real user <em>monitoring</em> (RUM), we measure the overall <em>time</em> to <em>load</em> the entire webpage. Additional <em>monitoring</em> after <em>page</em> <em>load</em> provides details on in-<em>page</em> AJAX calls, JavaScript errors, and other events and interactions. <em>Browser</em> <em>monitoring</em> can"
      },
      "id": "6043ef69e7b9d2d7055799f9"
    }
  ],
  "/docs/browser/new-relic-browser/performance-quality/browser-monitoring-performance-impact": [
    {
      "sections": [
        "Security for browser monitoring",
        "Reported data",
        "Page view data",
        "AJAX timing data",
        "JavaScript error data",
        "Session trace data",
        "SPA data",
        "URL query strings",
        "Visitor's IP address",
        "Browser types",
        "CDN access",
        "Important",
        "Cookies",
        "JSONP requests"
      ],
      "title": "Security for browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Performance quality"
      ],
      "external_id": "99cd4023fc519082ebe94082e3a6affd1cc2344f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/performance-quality/security-browser-monitoring/",
      "published_at": "2021-10-24T14:53:32Z",
      "updated_at": "2021-07-09T23:05:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring provides insights into how your application or site behaves when it is loaded in a web browser. Browser only records performance data, as explained in this document. It does not record any data used or stored by the monitored application unless you explicitly configure it to do so. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Reported data Browser reports many different types of data to help you analyze your website's performance. It only reports page view data, unless you have subscribed to Pro features. You can also enable functionality for AJAX requests, JavaScript errors, and session traces. For most data types, browser transmits the data securely using HTTPS encryption. The browser agent transmits data to New Relic's collectors by using either of the domains bam.nr-data.net or bam-cell.nr-data.net. Here is a summary of the types of data reported by browser monitoring. Page view data This data is reported once per page view and consists of: Page load timing data Name of the server-side app controller that served the page, if available (obfuscated in the page and during transmission) Additional custom parameters set by the server-side app controller, if available (obfuscated in the page and during transmission) Additional custom parameters set by the browser agent API, if set prior to page load This information appears on the Page views page. For data security reasons, browser does not record or collect URL query strings. Server-side data can only be collected when the host is also instrumented by New Relic and the browser monitoring instrumentation is injected by the agent. For more information about how we collect and present this data, see Instrumentation for page load timing. AJAX timing data When enabled, browser periodically reports AJAX timing data until the user navigates away from or closes the page. (New Relic automatically filters out all AJAX requests that take longer than two minutes.) Data includes: Hostnames, ports, and paths (but not search/query parameters) of AJAX request URLs HTTP status code of responses Byte size of request message bodies Name of the server-side app controller servicing the AJAX request and server-side timing data (obfuscated in the page and during transmission), when the browser instrumentation is injected by the New Relic agent Timing data for the AJAX transaction Timing data for the AJAX callbacks This information appears on the AJAX page. JavaScript error data When enabled, browser periodically reports data about every error that occurs on the page until the user navigates away from or closes the page. This information appears on the JavaScript errors page. For each error, the data includes: Exception class of the error Error message containing arbitrary text Stack trace of the error, which may contain function names and URLs of scripts causing the error Error messages typically do not contain any confidential or sensitive information. However, it is possible for messages to be purposefully constructed with sensitive information. Before enabling JavaScript error reporting, ensure that your website does not expose any sensitive information in error messages. Session trace data When enabled, browser periodically reports data on the details of the a single page's life cycle, including user interactions, AJAX loads, and JavaScript errors, until the user navigates away from or closes the page. New Relic automatically stops recording further data after ten minutes. Data includes: Asset load timing details User interactions such as scrolling, mousing, and clicking JavaScript error timing and other JavaScript error information Triggered Javascript events Session traces are captured randomly at a fixed rate from among the monitored page views. Session trace information appears on the Session traces page. SPA data If you use browser's single-page app (SPA) monitoring, New Relic reports the following data once per page load or route change. Browser data for page views, AJAX timing, JavaScript errors, and session traces Hash fragments associated with SPA route changes Additional custom parameters added from the SPA API When SPA monitoring has been enabled, this information appears on the Page views page. Server-side data can only be collected when the host is also instrumented by New Relic, and the browser monitoring instrumentation is injected by the agent. For more information about how we collect and present this data, see Instrumentation for page load timing. URL query strings The browser agent uses the HTTP referer attribute to track page URLs. URLs can sometimes contain potentially sensitive user-entered query data (for example, a user's name). For data security reasons, browser does not record or collect URL query strings. Visitor's IP address Browser uses the visitor's IP address to enrich data for additional visitor segmentation. Details such as the ASN and geoID are mapped to browser data from the IP address. For data security reasons, browser does not retain the visitor's IP address for reporting. The IP address is obtained in the HTTP header from the request to the New Relic collector. New Relic does not retain the visitor's IP address after the attributes have been mapped. The IP address value is overwritten within 24 hours of data being collected. Browser types Browser determines the browser type from the User-Agent header and the geographical location based on the browser's IP address. New Relic does not retain the IP address, only the country and region associated with the performance data. This information appears on the selected app's Geography page. Also, details about specific browser types appear on the selected app's Browsers page. CDN access Page load timing requires access to the content delivery network (CDN), where New Relic's utility JavaScript file (nr.js) is hosted. The domain name for the file (js-agent.newrelic.com) remains static, but the number in the path (version) may change periodically. A script tag is injected by the New Relic agent (or pasted into the webpage for standalone apps) that references the JavaScript on the CDN, which is then loaded by the browser. The loaded JavaScript collects and reports the metrics dynamically to either of the domains bam.nr-data.net or bam-cell.nr-data.net. Important If your end users are behind a firewall or proxy and do not have access to the CDN or to New Relic's networks (including bam.nr-data.net and bam-cell.nr-data.net), browser monitoring will not work. Cookies Browser monitoring creates cookies in the end user's browser. If the user has cookies disabled, page load timing (sometimes referred to as real user monitoring or RUM) will not be able to track sessions properly. Also, if the user has an older browser that does not support the Navigation Timing Specification API, page load timing will not be able to track response times as accurately. New Relic's cookies generated by browser agents older than version 995 may not contain the secure attribute. This is because page load timing data transmission in versions before version 995 use HTTP when the page is HTTP, but use HTTPS when the page is HTTPS. All browser agent versions above version 995 will always use the secure flag for cookies and transmit over HTTPS. JavaScript and AJAX data may contain more sensitive information, so they are always transmitted over HTTPS. Transmission of these cookies using HTTP or access to them from JavaScript is not a significant security risk, because the cookies are not used to make security decisions or allow access to an account. They are used only to collect performance data, with any identifiable data obfuscated. For customers subject to special guidelines for cookie collection, such as those under the EU GDPR/PECR ICO Guidelines, we now provide the option to disable cookie collection for your application. Please see our browser agent v1169 release notes for more information. Important If your site uses P3P, it must be configured to allow these cookies. JSONP requests Page load timing metrics are reported to New Relic using a Script GET, also known as a JSONP request. The Script GET returns a value that is subsequently stored in a cookie and used to trigger trace capturing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.74901,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Security for <em>browser</em> <em>monitoring</em>",
        "sections": "Security for <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em> provides insights into how your application or site behaves when it is loaded in a web <em>browser</em>. <em>Browser</em> only records <em>performance</em> data, as explained in this document. It does not record any data used or stored by the monitored application unless you explicitly configure it to do"
      },
      "id": "6043efdf64441f772e378f12"
    },
    {
      "sections": [
        "Browser monitoring and search engine optimization",
        "Contents",
        "Efficiency of inline JavaScript",
        "Impact on SEO"
      ],
      "title": "Browser monitoring and search engine optimization",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Performance quality"
      ],
      "external_id": "1f3f91b4e13af6b49f484d7ba08f338e7f4344f0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/performance-quality/browser-monitoring-search-engine-optimization/",
      "published_at": "2021-10-24T14:51:56Z",
      "updated_at": "2021-07-09T23:05:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring places a small \"loader\" script into the head section of each page on a monitored site. This JavaScript instrumentation has been designed to: Provide maximum visibility into front-end performance, accurately time how long it takes for pages to load in all browsers, and to report details for JavaScript errors and AJAX calls. Have minimal impact on overall page load time and search engine optimization (SEO), including search engine ranking, indexing, crawl efficiency, or other SEO-related concerns. Contents Efficiency of inline JavaScript The most effective method for browser monitoring is to include a minimal amount of JavaScript instrumentation code inline in the head of the monitored page. This code then retrieves the remainder of the necessary code after the page finishes loading. Other browser monitoring methods include JavaScript code at the end of the page body or exclusively using an external script. However, these methods can limit visibility into the end users' experience. Impact on SEO Performance testing results indicate that using browser monitoring's JavaScript has a negligible effect on page load time. In addition, it has no negative impact on how users or search engines interact with your site. Google's consistent recommendation to website owners is to build a site that is valuable to users and accessible to search engine crawlers. Google rankings favor sites that provide the most relevant information and the best user experience. Browser monitoring can help you improve user experience by identifying performance bottlenecks, including: Slow page loads Problematic JavaScript errors Long AJAX calls Identifying Javascript errors is especially helpful because Google's bots are increasingly running the JavaScript code on websites they crawl in order to access content provided by AJAX-heavy web applications. A JavaScript error that previously was only visible to human users (for example, a broken button) could affect whether the Google bots can successfully interact with your site. We understand that SEO and traffic referred by search engines are critically important to many businesses. When used effectively, browser monitoring can even increase a site's ranking in Google and other search engines by improving performance and user experience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.74901,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> <em>monitoring</em> and search engine optimization",
        "sections": "<em>Browser</em> <em>monitoring</em> and search engine optimization",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em> places a small &quot;loader&quot; script into the head section of each page on a monitored site. This JavaScript instrumentation has been designed to: Provide maximum visibility into front-end <em>performance</em>, accurately time how long it takes for pages to load in all browsers, and to report"
      },
      "id": "6043fa33196a675d7b960f85"
    },
    {
      "sections": [
        "Introduction to browser monitoring",
        "More than Real User Monitoring (RUM)",
        "Examine user perceptions",
        "Improve interactive app performance",
        "Correlate front-end and back-end problems",
        "Get started with browser monitoring"
      ],
      "title": "Introduction to browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "4928b2a5981bd2d6263f04b4b882d65adef22779",
      "image": "https://docs.newrelic.com/static/98ad878ffa7b586b779178656f19ec58/c1b63/browser_intro_0.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/introduction-browser-monitoring/",
      "published_at": "2021-10-24T19:11:37Z",
      "updated_at": "2021-10-24T19:11:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your end-user experience depends on your entire technology stack. You need to quickly understand what's causing a customer complaint or issue. Did the problem come from your infrastructure, your application, or the browsers that ultimately render it? Is it the result of a problematic internet provider, a problem in your own data center with failing CPU or memory, or something else? More than Real User Monitoring (RUM) Many websites contain dynamic content that is loaded after the initial page has finished loading, and complex JavaScript code increases the need for error reporting. Browser monitoring in New Relic One provides a Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. With browser monitoring in New Relic One, you see actionable data about your end users' experience with your app. But browser monitoring in New Relic goes far beyond the initial page load to measure full page life cycle data. For example, our browser UI shows you: Actual performance data, such as by page view popularity and user satisfaction (Apdex) scores Perceived performance data that measures how quickly your async or dynamic visuals and interactive page contents display JavaScript error analytics, stack traces, and line-of-code visibility, to show you the end-user steps leading up to an error itself Session performance with a detailed timeline and heat map of the load and interaction events during a webpage's full life cycle AJAX requests indicating problems with timing, end points, and specific locations in the webpage Hash-based route changes in apps with single-page application (SPA) architectures These tools (and more!) help your teams optimize your end users' page load experience, eliminate bugs, and troubleshoot faster across your full stack. Examine user perceptions Real user data gives insights into actual page performance, but you also need to look into your users' perception of your site's performance. Pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser monitoring agent. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. Additional metrics include: First paint, first contentful paint, and largest contentful paint First input delay First interaction This helps you understand how users experience your site, both from visual and responsiveness standpoints. Improve interactive app performance Our single-page app (SPA) monitoring automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during browser interactions. You can also use our browser agent and SPA API to monitor virtually anything that executes inside the browser. If you are a developer, SPA monitoring can help you: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query and visualize the data to assist with business decisions. Bring better apps to the marketplace more quickly. Correlate front-end and back-end problems With New Relic One, you can instrument any type of data you need, such as metrics, events, logs, and traces. This helps you find actionable data about your end users' experience across the stack. For example: Type of data Comments Locations or domains Limit browser monitoring to focus on specific geographical locations or specific types of end-user activity. You can also monitor or block specific domains. Trends in interactions Use our comparative charting feature for a direct page load time comparison between real user (browser) interactions and trends appearing in Synthetic monitors. Distributed tracing Isolate latency from the web browser through back-end services with distributed tracing. The UI helps you see the connection across across a full transaction, from browser activity, to time spent in network, to back-end activity. Browser types Explore your end users' experience with your app segmented by any types of browsers they use, including: Top browsers by throughput Average page load time by platform type (mobile, desktop, and other) Selected browser type by version (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Get started with browser monitoring Follow these basic steps, and you'll quickly be up and running in New Relic with browser monitoring! Review the compatibility details and basic requirements for browser monitoring. Install the browser agent. Go to [one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. View summary data from your Browser summary page, then drill down into page load timing details and other UI data. Configure your alerts for key performance data, or use our Applied Intelligence solutions to reduce alert noise, correlate incidents, and automatically detect anomalies. Query and visualize your default data (or customize your own), then analyze what that data says about your business. Customize and share your own charts and dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.03004,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>browser</em> <em>monitoring</em>",
        "sections": "Introduction to <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " <em>performance</em> Our single-page app (SPA) <em>monitoring</em> automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during <em>browser</em> interactions. You can also use our <em>browser</em> agent and SPA API to <em>monitor</em> virtually anything that executes inside the <em>browser</em>. If you"
      },
      "id": "604429a9e7b9d2bde7579a04"
    }
  ],
  "/docs/browser/new-relic-browser/performance-quality/browser-monitoring-search-engine-optimization": [
    {
      "sections": [
        "Browser monitoring and performance impact",
        "Contents",
        "Overall impact",
        "Network impact",
        "For more help"
      ],
      "title": "Browser monitoring and performance impact",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Performance quality"
      ],
      "external_id": "5504ef3846f4bcdae0ff4f58e8c745079d9a5cb7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/performance-quality/browser-monitoring-performance-impact/",
      "published_at": "2021-10-24T15:02:51Z",
      "updated_at": "2021-07-09T23:38:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's JavaScript snippet introduces a nearly invisible impact on website performance and user perception of the time it takes a page to load. The JavaScript is included in a packet of webpage data that is sent anyway. In addition, it immediately begins monitoring for errors and events as the rest of the webpage executes. The negligible amount of overhead required to load the JavaScript results in a significant return of actionable data. Contents Overall impact The JavaScript's overhead takes into consideration both the impact on the user and the impact on your systems' performance: User perception: Typically users cannot detect performance degradations on a website of less than 200ms. Browser's JavaScript adds less than 15ms in aggregated time per page load. This is split up over time, so at no point would a user be able to perceive any performance impact due to the JavaScript. Webserver and systems: Browser app monitoring occurs on the user's browser, not on the server. Processing time does not have an impact on your CPU consumption. In addition, we take additional steps to minimize any potential impact on the apps and webpages being monitored. For example, the \"loader\" script is loaded synchronously in the <HEAD> in order to ensure monitoring is enabled for the entire life cycle of the page. This script is included inline, which eliminates the need for another roundtrip network request to a content delivery network (CDN). The \"loader\" comes with the initial page load. Later in the life cycle of the page, New Relic loads an additional monitoring script asynchronously. This script should not have any perceivable effect to the user and is included in the overall overhead of less than 15ms per page. Network impact Browser monitoring also minimizes network traffic for the end user by aggregating data locally (in the client) and sending it back to New Relic on load, at periodic intervals, on unload, or when data has been collected. (During the browser session's idle periods, transmissions may not be required.) For more help Additional documentation resources include: Instrumentation for page load timing (JavaScript elements, data transmission) Browser monitoring and search engine optimization (how browser ensures that the JavaScript has a negligible impact on SEO)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.75206,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> <em>monitoring</em> and <em>performance</em> impact",
        "sections": "<em>Browser</em> <em>monitoring</em> and <em>performance</em> impact",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s JavaScript snippet introduces a nearly invisible impact on website <em>performance</em> and user perception of the time it takes a page to load. The JavaScript is included in a packet of webpage data that is sent anyway. In addition, it immediately begins <em>monitoring</em> for errors"
      },
      "id": "603ec318196a67a757a83dd1"
    },
    {
      "sections": [
        "Security for browser monitoring",
        "Reported data",
        "Page view data",
        "AJAX timing data",
        "JavaScript error data",
        "Session trace data",
        "SPA data",
        "URL query strings",
        "Visitor's IP address",
        "Browser types",
        "CDN access",
        "Important",
        "Cookies",
        "JSONP requests"
      ],
      "title": "Security for browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Performance quality"
      ],
      "external_id": "99cd4023fc519082ebe94082e3a6affd1cc2344f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/performance-quality/security-browser-monitoring/",
      "published_at": "2021-10-24T14:53:32Z",
      "updated_at": "2021-07-09T23:05:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring provides insights into how your application or site behaves when it is loaded in a web browser. Browser only records performance data, as explained in this document. It does not record any data used or stored by the monitored application unless you explicitly configure it to do so. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Reported data Browser reports many different types of data to help you analyze your website's performance. It only reports page view data, unless you have subscribed to Pro features. You can also enable functionality for AJAX requests, JavaScript errors, and session traces. For most data types, browser transmits the data securely using HTTPS encryption. The browser agent transmits data to New Relic's collectors by using either of the domains bam.nr-data.net or bam-cell.nr-data.net. Here is a summary of the types of data reported by browser monitoring. Page view data This data is reported once per page view and consists of: Page load timing data Name of the server-side app controller that served the page, if available (obfuscated in the page and during transmission) Additional custom parameters set by the server-side app controller, if available (obfuscated in the page and during transmission) Additional custom parameters set by the browser agent API, if set prior to page load This information appears on the Page views page. For data security reasons, browser does not record or collect URL query strings. Server-side data can only be collected when the host is also instrumented by New Relic and the browser monitoring instrumentation is injected by the agent. For more information about how we collect and present this data, see Instrumentation for page load timing. AJAX timing data When enabled, browser periodically reports AJAX timing data until the user navigates away from or closes the page. (New Relic automatically filters out all AJAX requests that take longer than two minutes.) Data includes: Hostnames, ports, and paths (but not search/query parameters) of AJAX request URLs HTTP status code of responses Byte size of request message bodies Name of the server-side app controller servicing the AJAX request and server-side timing data (obfuscated in the page and during transmission), when the browser instrumentation is injected by the New Relic agent Timing data for the AJAX transaction Timing data for the AJAX callbacks This information appears on the AJAX page. JavaScript error data When enabled, browser periodically reports data about every error that occurs on the page until the user navigates away from or closes the page. This information appears on the JavaScript errors page. For each error, the data includes: Exception class of the error Error message containing arbitrary text Stack trace of the error, which may contain function names and URLs of scripts causing the error Error messages typically do not contain any confidential or sensitive information. However, it is possible for messages to be purposefully constructed with sensitive information. Before enabling JavaScript error reporting, ensure that your website does not expose any sensitive information in error messages. Session trace data When enabled, browser periodically reports data on the details of the a single page's life cycle, including user interactions, AJAX loads, and JavaScript errors, until the user navigates away from or closes the page. New Relic automatically stops recording further data after ten minutes. Data includes: Asset load timing details User interactions such as scrolling, mousing, and clicking JavaScript error timing and other JavaScript error information Triggered Javascript events Session traces are captured randomly at a fixed rate from among the monitored page views. Session trace information appears on the Session traces page. SPA data If you use browser's single-page app (SPA) monitoring, New Relic reports the following data once per page load or route change. Browser data for page views, AJAX timing, JavaScript errors, and session traces Hash fragments associated with SPA route changes Additional custom parameters added from the SPA API When SPA monitoring has been enabled, this information appears on the Page views page. Server-side data can only be collected when the host is also instrumented by New Relic, and the browser monitoring instrumentation is injected by the agent. For more information about how we collect and present this data, see Instrumentation for page load timing. URL query strings The browser agent uses the HTTP referer attribute to track page URLs. URLs can sometimes contain potentially sensitive user-entered query data (for example, a user's name). For data security reasons, browser does not record or collect URL query strings. Visitor's IP address Browser uses the visitor's IP address to enrich data for additional visitor segmentation. Details such as the ASN and geoID are mapped to browser data from the IP address. For data security reasons, browser does not retain the visitor's IP address for reporting. The IP address is obtained in the HTTP header from the request to the New Relic collector. New Relic does not retain the visitor's IP address after the attributes have been mapped. The IP address value is overwritten within 24 hours of data being collected. Browser types Browser determines the browser type from the User-Agent header and the geographical location based on the browser's IP address. New Relic does not retain the IP address, only the country and region associated with the performance data. This information appears on the selected app's Geography page. Also, details about specific browser types appear on the selected app's Browsers page. CDN access Page load timing requires access to the content delivery network (CDN), where New Relic's utility JavaScript file (nr.js) is hosted. The domain name for the file (js-agent.newrelic.com) remains static, but the number in the path (version) may change periodically. A script tag is injected by the New Relic agent (or pasted into the webpage for standalone apps) that references the JavaScript on the CDN, which is then loaded by the browser. The loaded JavaScript collects and reports the metrics dynamically to either of the domains bam.nr-data.net or bam-cell.nr-data.net. Important If your end users are behind a firewall or proxy and do not have access to the CDN or to New Relic's networks (including bam.nr-data.net and bam-cell.nr-data.net), browser monitoring will not work. Cookies Browser monitoring creates cookies in the end user's browser. If the user has cookies disabled, page load timing (sometimes referred to as real user monitoring or RUM) will not be able to track sessions properly. Also, if the user has an older browser that does not support the Navigation Timing Specification API, page load timing will not be able to track response times as accurately. New Relic's cookies generated by browser agents older than version 995 may not contain the secure attribute. This is because page load timing data transmission in versions before version 995 use HTTP when the page is HTTP, but use HTTPS when the page is HTTPS. All browser agent versions above version 995 will always use the secure flag for cookies and transmit over HTTPS. JavaScript and AJAX data may contain more sensitive information, so they are always transmitted over HTTPS. Transmission of these cookies using HTTP or access to them from JavaScript is not a significant security risk, because the cookies are not used to make security decisions or allow access to an account. They are used only to collect performance data, with any identifiable data obfuscated. For customers subject to special guidelines for cookie collection, such as those under the EU GDPR/PECR ICO Guidelines, we now provide the option to disable cookie collection for your application. Please see our browser agent v1169 release notes for more information. Important If your site uses P3P, it must be configured to allow these cookies. JSONP requests Page load timing metrics are reported to New Relic using a Script GET, also known as a JSONP request. The Script GET returns a value that is subsequently stored in a cookie and used to trigger trace capturing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.74901,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Security for <em>browser</em> <em>monitoring</em>",
        "sections": "Security for <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em> provides insights into how your application or site behaves when it is loaded in a web <em>browser</em>. <em>Browser</em> only records <em>performance</em> data, as explained in this document. It does not record any data used or stored by the monitored application unless you explicitly configure it to do"
      },
      "id": "6043efdf64441f772e378f12"
    },
    {
      "sections": [
        "Introduction to browser monitoring",
        "More than Real User Monitoring (RUM)",
        "Examine user perceptions",
        "Improve interactive app performance",
        "Correlate front-end and back-end problems",
        "Get started with browser monitoring"
      ],
      "title": "Introduction to browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "4928b2a5981bd2d6263f04b4b882d65adef22779",
      "image": "https://docs.newrelic.com/static/98ad878ffa7b586b779178656f19ec58/c1b63/browser_intro_0.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/introduction-browser-monitoring/",
      "published_at": "2021-10-24T19:11:37Z",
      "updated_at": "2021-10-24T19:11:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your end-user experience depends on your entire technology stack. You need to quickly understand what's causing a customer complaint or issue. Did the problem come from your infrastructure, your application, or the browsers that ultimately render it? Is it the result of a problematic internet provider, a problem in your own data center with failing CPU or memory, or something else? More than Real User Monitoring (RUM) Many websites contain dynamic content that is loaded after the initial page has finished loading, and complex JavaScript code increases the need for error reporting. Browser monitoring in New Relic One provides a Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. With browser monitoring in New Relic One, you see actionable data about your end users' experience with your app. But browser monitoring in New Relic goes far beyond the initial page load to measure full page life cycle data. For example, our browser UI shows you: Actual performance data, such as by page view popularity and user satisfaction (Apdex) scores Perceived performance data that measures how quickly your async or dynamic visuals and interactive page contents display JavaScript error analytics, stack traces, and line-of-code visibility, to show you the end-user steps leading up to an error itself Session performance with a detailed timeline and heat map of the load and interaction events during a webpage's full life cycle AJAX requests indicating problems with timing, end points, and specific locations in the webpage Hash-based route changes in apps with single-page application (SPA) architectures These tools (and more!) help your teams optimize your end users' page load experience, eliminate bugs, and troubleshoot faster across your full stack. Examine user perceptions Real user data gives insights into actual page performance, but you also need to look into your users' perception of your site's performance. Pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser monitoring agent. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. Additional metrics include: First paint, first contentful paint, and largest contentful paint First input delay First interaction This helps you understand how users experience your site, both from visual and responsiveness standpoints. Improve interactive app performance Our single-page app (SPA) monitoring automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during browser interactions. You can also use our browser agent and SPA API to monitor virtually anything that executes inside the browser. If you are a developer, SPA monitoring can help you: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query and visualize the data to assist with business decisions. Bring better apps to the marketplace more quickly. Correlate front-end and back-end problems With New Relic One, you can instrument any type of data you need, such as metrics, events, logs, and traces. This helps you find actionable data about your end users' experience across the stack. For example: Type of data Comments Locations or domains Limit browser monitoring to focus on specific geographical locations or specific types of end-user activity. You can also monitor or block specific domains. Trends in interactions Use our comparative charting feature for a direct page load time comparison between real user (browser) interactions and trends appearing in Synthetic monitors. Distributed tracing Isolate latency from the web browser through back-end services with distributed tracing. The UI helps you see the connection across across a full transaction, from browser activity, to time spent in network, to back-end activity. Browser types Explore your end users' experience with your app segmented by any types of browsers they use, including: Top browsers by throughput Average page load time by platform type (mobile, desktop, and other) Selected browser type by version (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Get started with browser monitoring Follow these basic steps, and you'll quickly be up and running in New Relic with browser monitoring! Review the compatibility details and basic requirements for browser monitoring. Install the browser agent. Go to [one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. View summary data from your Browser summary page, then drill down into page load timing details and other UI data. Configure your alerts for key performance data, or use our Applied Intelligence solutions to reduce alert noise, correlate incidents, and automatically detect anomalies. Query and visualize your default data (or customize your own), then analyze what that data says about your business. Customize and share your own charts and dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.03004,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>browser</em> <em>monitoring</em>",
        "sections": "Introduction to <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " <em>performance</em> Our single-page app (SPA) <em>monitoring</em> automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during <em>browser</em> interactions. You can also use our <em>browser</em> agent and SPA API to <em>monitor</em> virtually anything that executes inside the <em>browser</em>. If you"
      },
      "id": "604429a9e7b9d2bde7579a04"
    }
  ],
  "/docs/browser/new-relic-browser/performance-quality/security-browser-monitoring": [
    {
      "sections": [
        "Browser monitoring and performance impact",
        "Contents",
        "Overall impact",
        "Network impact",
        "For more help"
      ],
      "title": "Browser monitoring and performance impact",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Performance quality"
      ],
      "external_id": "5504ef3846f4bcdae0ff4f58e8c745079d9a5cb7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/performance-quality/browser-monitoring-performance-impact/",
      "published_at": "2021-10-24T15:02:51Z",
      "updated_at": "2021-07-09T23:38:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's JavaScript snippet introduces a nearly invisible impact on website performance and user perception of the time it takes a page to load. The JavaScript is included in a packet of webpage data that is sent anyway. In addition, it immediately begins monitoring for errors and events as the rest of the webpage executes. The negligible amount of overhead required to load the JavaScript results in a significant return of actionable data. Contents Overall impact The JavaScript's overhead takes into consideration both the impact on the user and the impact on your systems' performance: User perception: Typically users cannot detect performance degradations on a website of less than 200ms. Browser's JavaScript adds less than 15ms in aggregated time per page load. This is split up over time, so at no point would a user be able to perceive any performance impact due to the JavaScript. Webserver and systems: Browser app monitoring occurs on the user's browser, not on the server. Processing time does not have an impact on your CPU consumption. In addition, we take additional steps to minimize any potential impact on the apps and webpages being monitored. For example, the \"loader\" script is loaded synchronously in the <HEAD> in order to ensure monitoring is enabled for the entire life cycle of the page. This script is included inline, which eliminates the need for another roundtrip network request to a content delivery network (CDN). The \"loader\" comes with the initial page load. Later in the life cycle of the page, New Relic loads an additional monitoring script asynchronously. This script should not have any perceivable effect to the user and is included in the overall overhead of less than 15ms per page. Network impact Browser monitoring also minimizes network traffic for the end user by aggregating data locally (in the client) and sending it back to New Relic on load, at periodic intervals, on unload, or when data has been collected. (During the browser session's idle periods, transmissions may not be required.) For more help Additional documentation resources include: Instrumentation for page load timing (JavaScript elements, data transmission) Browser monitoring and search engine optimization (how browser ensures that the JavaScript has a negligible impact on SEO)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.75206,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> <em>monitoring</em> and <em>performance</em> impact",
        "sections": "<em>Browser</em> <em>monitoring</em> and <em>performance</em> impact",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s JavaScript snippet introduces a nearly invisible impact on website <em>performance</em> and user perception of the time it takes a page to load. The JavaScript is included in a packet of webpage data that is sent anyway. In addition, it immediately begins <em>monitoring</em> for errors"
      },
      "id": "603ec318196a67a757a83dd1"
    },
    {
      "sections": [
        "Browser monitoring and search engine optimization",
        "Contents",
        "Efficiency of inline JavaScript",
        "Impact on SEO"
      ],
      "title": "Browser monitoring and search engine optimization",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Performance quality"
      ],
      "external_id": "1f3f91b4e13af6b49f484d7ba08f338e7f4344f0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/performance-quality/browser-monitoring-search-engine-optimization/",
      "published_at": "2021-10-24T14:51:56Z",
      "updated_at": "2021-07-09T23:05:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring places a small \"loader\" script into the head section of each page on a monitored site. This JavaScript instrumentation has been designed to: Provide maximum visibility into front-end performance, accurately time how long it takes for pages to load in all browsers, and to report details for JavaScript errors and AJAX calls. Have minimal impact on overall page load time and search engine optimization (SEO), including search engine ranking, indexing, crawl efficiency, or other SEO-related concerns. Contents Efficiency of inline JavaScript The most effective method for browser monitoring is to include a minimal amount of JavaScript instrumentation code inline in the head of the monitored page. This code then retrieves the remainder of the necessary code after the page finishes loading. Other browser monitoring methods include JavaScript code at the end of the page body or exclusively using an external script. However, these methods can limit visibility into the end users' experience. Impact on SEO Performance testing results indicate that using browser monitoring's JavaScript has a negligible effect on page load time. In addition, it has no negative impact on how users or search engines interact with your site. Google's consistent recommendation to website owners is to build a site that is valuable to users and accessible to search engine crawlers. Google rankings favor sites that provide the most relevant information and the best user experience. Browser monitoring can help you improve user experience by identifying performance bottlenecks, including: Slow page loads Problematic JavaScript errors Long AJAX calls Identifying Javascript errors is especially helpful because Google's bots are increasingly running the JavaScript code on websites they crawl in order to access content provided by AJAX-heavy web applications. A JavaScript error that previously was only visible to human users (for example, a broken button) could affect whether the Google bots can successfully interact with your site. We understand that SEO and traffic referred by search engines are critically important to many businesses. When used effectively, browser monitoring can even increase a site's ranking in Google and other search engines by improving performance and user experience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.74901,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> <em>monitoring</em> and search engine optimization",
        "sections": "<em>Browser</em> <em>monitoring</em> and search engine optimization",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em> places a small &quot;loader&quot; script into the head section of each page on a monitored site. This JavaScript instrumentation has been designed to: Provide maximum visibility into front-end <em>performance</em>, accurately time how long it takes for pages to load in all browsers, and to report"
      },
      "id": "6043fa33196a675d7b960f85"
    },
    {
      "sections": [
        "Introduction to browser monitoring",
        "More than Real User Monitoring (RUM)",
        "Examine user perceptions",
        "Improve interactive app performance",
        "Correlate front-end and back-end problems",
        "Get started with browser monitoring"
      ],
      "title": "Introduction to browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "4928b2a5981bd2d6263f04b4b882d65adef22779",
      "image": "https://docs.newrelic.com/static/98ad878ffa7b586b779178656f19ec58/c1b63/browser_intro_0.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/introduction-browser-monitoring/",
      "published_at": "2021-10-24T19:11:37Z",
      "updated_at": "2021-10-24T19:11:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your end-user experience depends on your entire technology stack. You need to quickly understand what's causing a customer complaint or issue. Did the problem come from your infrastructure, your application, or the browsers that ultimately render it? Is it the result of a problematic internet provider, a problem in your own data center with failing CPU or memory, or something else? More than Real User Monitoring (RUM) Many websites contain dynamic content that is loaded after the initial page has finished loading, and complex JavaScript code increases the need for error reporting. Browser monitoring in New Relic One provides a Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. With browser monitoring in New Relic One, you see actionable data about your end users' experience with your app. But browser monitoring in New Relic goes far beyond the initial page load to measure full page life cycle data. For example, our browser UI shows you: Actual performance data, such as by page view popularity and user satisfaction (Apdex) scores Perceived performance data that measures how quickly your async or dynamic visuals and interactive page contents display JavaScript error analytics, stack traces, and line-of-code visibility, to show you the end-user steps leading up to an error itself Session performance with a detailed timeline and heat map of the load and interaction events during a webpage's full life cycle AJAX requests indicating problems with timing, end points, and specific locations in the webpage Hash-based route changes in apps with single-page application (SPA) architectures These tools (and more!) help your teams optimize your end users' page load experience, eliminate bugs, and troubleshoot faster across your full stack. Examine user perceptions Real user data gives insights into actual page performance, but you also need to look into your users' perception of your site's performance. Pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser monitoring agent. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. Additional metrics include: First paint, first contentful paint, and largest contentful paint First input delay First interaction This helps you understand how users experience your site, both from visual and responsiveness standpoints. Improve interactive app performance Our single-page app (SPA) monitoring automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during browser interactions. You can also use our browser agent and SPA API to monitor virtually anything that executes inside the browser. If you are a developer, SPA monitoring can help you: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query and visualize the data to assist with business decisions. Bring better apps to the marketplace more quickly. Correlate front-end and back-end problems With New Relic One, you can instrument any type of data you need, such as metrics, events, logs, and traces. This helps you find actionable data about your end users' experience across the stack. For example: Type of data Comments Locations or domains Limit browser monitoring to focus on specific geographical locations or specific types of end-user activity. You can also monitor or block specific domains. Trends in interactions Use our comparative charting feature for a direct page load time comparison between real user (browser) interactions and trends appearing in Synthetic monitors. Distributed tracing Isolate latency from the web browser through back-end services with distributed tracing. The UI helps you see the connection across across a full transaction, from browser activity, to time spent in network, to back-end activity. Browser types Explore your end users' experience with your app segmented by any types of browsers they use, including: Top browsers by throughput Average page load time by platform type (mobile, desktop, and other) Selected browser type by version (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Get started with browser monitoring Follow these basic steps, and you'll quickly be up and running in New Relic with browser monitoring! Review the compatibility details and basic requirements for browser monitoring. Install the browser agent. Go to [one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. View summary data from your Browser summary page, then drill down into page load timing details and other UI data. Configure your alerts for key performance data, or use our Applied Intelligence solutions to reduce alert noise, correlate incidents, and automatically detect anomalies. Query and visualize your default data (or customize your own), then analyze what that data says about your business. Customize and share your own charts and dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.02995,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>browser</em> <em>monitoring</em>",
        "sections": "Introduction to <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " <em>performance</em> Our single-page app (SPA) <em>monitoring</em> automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during <em>browser</em> interactions. You can also use our <em>browser</em> agent and SPA API to <em>monitor</em> virtually anything that executes inside the <em>browser</em>. If you"
      },
      "id": "604429a9e7b9d2bde7579a04"
    }
  ],
  "/docs/browser/new-relic-browser/troubleshooting/ajax-call-fails-cors-redirect-error-message": [
    {
      "sections": [
        "Introduction to browser monitoring",
        "More than Real User Monitoring (RUM)",
        "Examine user perceptions",
        "Improve interactive app performance",
        "Correlate front-end and back-end problems",
        "Get started with browser monitoring"
      ],
      "title": "Introduction to browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "4928b2a5981bd2d6263f04b4b882d65adef22779",
      "image": "https://docs.newrelic.com/static/98ad878ffa7b586b779178656f19ec58/c1b63/browser_intro_0.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/introduction-browser-monitoring/",
      "published_at": "2021-10-24T19:11:37Z",
      "updated_at": "2021-10-24T19:11:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your end-user experience depends on your entire technology stack. You need to quickly understand what's causing a customer complaint or issue. Did the problem come from your infrastructure, your application, or the browsers that ultimately render it? Is it the result of a problematic internet provider, a problem in your own data center with failing CPU or memory, or something else? More than Real User Monitoring (RUM) Many websites contain dynamic content that is loaded after the initial page has finished loading, and complex JavaScript code increases the need for error reporting. Browser monitoring in New Relic One provides a Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. With browser monitoring in New Relic One, you see actionable data about your end users' experience with your app. But browser monitoring in New Relic goes far beyond the initial page load to measure full page life cycle data. For example, our browser UI shows you: Actual performance data, such as by page view popularity and user satisfaction (Apdex) scores Perceived performance data that measures how quickly your async or dynamic visuals and interactive page contents display JavaScript error analytics, stack traces, and line-of-code visibility, to show you the end-user steps leading up to an error itself Session performance with a detailed timeline and heat map of the load and interaction events during a webpage's full life cycle AJAX requests indicating problems with timing, end points, and specific locations in the webpage Hash-based route changes in apps with single-page application (SPA) architectures These tools (and more!) help your teams optimize your end users' page load experience, eliminate bugs, and troubleshoot faster across your full stack. Examine user perceptions Real user data gives insights into actual page performance, but you also need to look into your users' perception of your site's performance. Pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser monitoring agent. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. Additional metrics include: First paint, first contentful paint, and largest contentful paint First input delay First interaction This helps you understand how users experience your site, both from visual and responsiveness standpoints. Improve interactive app performance Our single-page app (SPA) monitoring automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during browser interactions. You can also use our browser agent and SPA API to monitor virtually anything that executes inside the browser. If you are a developer, SPA monitoring can help you: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query and visualize the data to assist with business decisions. Bring better apps to the marketplace more quickly. Correlate front-end and back-end problems With New Relic One, you can instrument any type of data you need, such as metrics, events, logs, and traces. This helps you find actionable data about your end users' experience across the stack. For example: Type of data Comments Locations or domains Limit browser monitoring to focus on specific geographical locations or specific types of end-user activity. You can also monitor or block specific domains. Trends in interactions Use our comparative charting feature for a direct page load time comparison between real user (browser) interactions and trends appearing in Synthetic monitors. Distributed tracing Isolate latency from the web browser through back-end services with distributed tracing. The UI helps you see the connection across across a full transaction, from browser activity, to time spent in network, to back-end activity. Browser types Explore your end users' experience with your app segmented by any types of browsers they use, including: Top browsers by throughput Average page load time by platform type (mobile, desktop, and other) Selected browser type by version (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Get started with browser monitoring Follow these basic steps, and you'll quickly be up and running in New Relic with browser monitoring! Review the compatibility details and basic requirements for browser monitoring. Install the browser agent. Go to [one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. View summary data from your Browser summary page, then drill down into page load timing details and other UI data. Configure your alerts for key performance data, or use our Applied Intelligence solutions to reduce alert noise, correlate incidents, and automatically detect anomalies. Query and visualize your default data (or customize your own), then analyze what that data says about your business. Customize and share your own charts and dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.02995,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>browser</em> <em>monitoring</em>",
        "sections": "Introduction to <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " performance Our single-page app (SPA) <em>monitoring</em> automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during <em>browser</em> interactions. You can also use our <em>browser</em> agent and SPA API to <em>monitor</em> virtually anything that executes inside the <em>browser</em>. If you"
      },
      "id": "604429a9e7b9d2bde7579a04"
    },
    {
      "sections": [
        "Diagnostics CLI (nrdiag)",
        "Compatibility",
        "Get started"
      ],
      "title": "Diagnostics CLI (nrdiag)",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Diagnostics CLI (nrdiag)"
      ],
      "external_id": "973501f4752e56caf3d68e37bf21b823d0e42078",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/cross-product-functions/diagnostics-cli-nrdiag/diagnostics-cli-nrdiag/",
      "published_at": "2021-10-25T16:26:14Z",
      "updated_at": "2021-10-25T16:26:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Download latest version The Diagnostics CLI (nrdiag) is a utility that automatically detects common problems with New Relic products. If the Diagnostics CLI detects a problem, it suggests troubleshooting steps. The Diagnostics CLI can automatically upload troubleshooting data to a New Relic account. The Diagnostics CLI is open source and is located in GitHub. For additional troubleshooting steps for your agent, check out Not seeing data. Here's an example of the Diagnostics CLI running on Ubuntu Linux. The program checks your New Relic agent configurations for issues and generates zipped troubleshooting logs that are ready to be attached to support tickets. Compatibility The Diagnostics CLI is available for Linux, macOS, and Windows. It can detect common configuration issues for: APM: Available for all APM agents except C SDK. For the Go agent, only basic connectivity checks are available. Browser monitoring: Browser agent detection Infrastructure monitoring: Linux and Windows agents Mobile agents: iOS and Android Synthetic monitoring: Containerized private minions (CPM) The Diagnostics CLI does not require superuser or admin permissions to run, although we recommend those permissions for some checks. It will return an error if it does not have permissions to read the files it scans. Get started To use the Diagnostics CLI: Run the Diagnostics CLI, including task suites and command line options as needed. Supply the -attach flag for uploading results to your New Relic account. Optional: Validate your config file settings. Interpret the output. Like any other New Relic tool, the Diagnostics CLI service is designed to protect you and your customers' data privacy. For detailed information, see our Diagnostics CLI licensing and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.25864,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " are available. <em>Browser</em> <em>monitoring</em>: <em>Browser</em> agent detection Infrastructure <em>monitoring</em>: Linux and Windows agents Mobile agents: iOS and Android Synthetic <em>monitoring</em>: Containerized private minions (CPM) The Diagnostics CLI does not require superuser or admin permissions to run, although we recommend those"
      },
      "id": "604469f8e7b9d2abb65799f0"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "17c97a462616f2b23ead796b62780a1ffeb3dfac",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Agent version Your browser monitoring agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute browser API call To add a custom attribute to the PageView event via the browser agent, use the setCustomAttribute browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.90755,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>browser</em> <em>monitoring</em> custom events and attributes",
        "sections": "Report <em>browser</em> <em>monitoring</em> custom events and attributes",
        "body": " it to true. Python Add the <em>browser_monitoring</em>.attributes.enabled option and set it to true. Ruby Add the <em>browser_monitoring</em>.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see <em>Browser</em> events. <em>Troubleshooting</em> Here"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    }
  ],
  "/docs/browser/new-relic-browser/troubleshooting/angularjs-errors-do-not-appear": [
    {
      "sections": [
        "Introduction to browser monitoring",
        "More than Real User Monitoring (RUM)",
        "Examine user perceptions",
        "Improve interactive app performance",
        "Correlate front-end and back-end problems",
        "Get started with browser monitoring"
      ],
      "title": "Introduction to browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "4928b2a5981bd2d6263f04b4b882d65adef22779",
      "image": "https://docs.newrelic.com/static/98ad878ffa7b586b779178656f19ec58/c1b63/browser_intro_0.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/introduction-browser-monitoring/",
      "published_at": "2021-10-24T19:11:37Z",
      "updated_at": "2021-10-24T19:11:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your end-user experience depends on your entire technology stack. You need to quickly understand what's causing a customer complaint or issue. Did the problem come from your infrastructure, your application, or the browsers that ultimately render it? Is it the result of a problematic internet provider, a problem in your own data center with failing CPU or memory, or something else? More than Real User Monitoring (RUM) Many websites contain dynamic content that is loaded after the initial page has finished loading, and complex JavaScript code increases the need for error reporting. Browser monitoring in New Relic One provides a Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. With browser monitoring in New Relic One, you see actionable data about your end users' experience with your app. But browser monitoring in New Relic goes far beyond the initial page load to measure full page life cycle data. For example, our browser UI shows you: Actual performance data, such as by page view popularity and user satisfaction (Apdex) scores Perceived performance data that measures how quickly your async or dynamic visuals and interactive page contents display JavaScript error analytics, stack traces, and line-of-code visibility, to show you the end-user steps leading up to an error itself Session performance with a detailed timeline and heat map of the load and interaction events during a webpage's full life cycle AJAX requests indicating problems with timing, end points, and specific locations in the webpage Hash-based route changes in apps with single-page application (SPA) architectures These tools (and more!) help your teams optimize your end users' page load experience, eliminate bugs, and troubleshoot faster across your full stack. Examine user perceptions Real user data gives insights into actual page performance, but you also need to look into your users' perception of your site's performance. Pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser monitoring agent. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. Additional metrics include: First paint, first contentful paint, and largest contentful paint First input delay First interaction This helps you understand how users experience your site, both from visual and responsiveness standpoints. Improve interactive app performance Our single-page app (SPA) monitoring automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during browser interactions. You can also use our browser agent and SPA API to monitor virtually anything that executes inside the browser. If you are a developer, SPA monitoring can help you: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query and visualize the data to assist with business decisions. Bring better apps to the marketplace more quickly. Correlate front-end and back-end problems With New Relic One, you can instrument any type of data you need, such as metrics, events, logs, and traces. This helps you find actionable data about your end users' experience across the stack. For example: Type of data Comments Locations or domains Limit browser monitoring to focus on specific geographical locations or specific types of end-user activity. You can also monitor or block specific domains. Trends in interactions Use our comparative charting feature for a direct page load time comparison between real user (browser) interactions and trends appearing in Synthetic monitors. Distributed tracing Isolate latency from the web browser through back-end services with distributed tracing. The UI helps you see the connection across across a full transaction, from browser activity, to time spent in network, to back-end activity. Browser types Explore your end users' experience with your app segmented by any types of browsers they use, including: Top browsers by throughput Average page load time by platform type (mobile, desktop, and other) Selected browser type by version (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Get started with browser monitoring Follow these basic steps, and you'll quickly be up and running in New Relic with browser monitoring! Review the compatibility details and basic requirements for browser monitoring. Install the browser agent. Go to [one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. View summary data from your Browser summary page, then drill down into page load timing details and other UI data. Configure your alerts for key performance data, or use our Applied Intelligence solutions to reduce alert noise, correlate incidents, and automatically detect anomalies. Query and visualize your default data (or customize your own), then analyze what that data says about your business. Customize and share your own charts and dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.02995,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>browser</em> <em>monitoring</em>",
        "sections": "Introduction to <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " performance Our single-page app (SPA) <em>monitoring</em> automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during <em>browser</em> interactions. You can also use our <em>browser</em> agent and SPA API to <em>monitor</em> virtually anything that executes inside the <em>browser</em>. If you"
      },
      "id": "604429a9e7b9d2bde7579a04"
    },
    {
      "sections": [
        "Diagnostics CLI (nrdiag)",
        "Compatibility",
        "Get started"
      ],
      "title": "Diagnostics CLI (nrdiag)",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Diagnostics CLI (nrdiag)"
      ],
      "external_id": "973501f4752e56caf3d68e37bf21b823d0e42078",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/cross-product-functions/diagnostics-cli-nrdiag/diagnostics-cli-nrdiag/",
      "published_at": "2021-10-25T16:26:14Z",
      "updated_at": "2021-10-25T16:26:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Download latest version The Diagnostics CLI (nrdiag) is a utility that automatically detects common problems with New Relic products. If the Diagnostics CLI detects a problem, it suggests troubleshooting steps. The Diagnostics CLI can automatically upload troubleshooting data to a New Relic account. The Diagnostics CLI is open source and is located in GitHub. For additional troubleshooting steps for your agent, check out Not seeing data. Here's an example of the Diagnostics CLI running on Ubuntu Linux. The program checks your New Relic agent configurations for issues and generates zipped troubleshooting logs that are ready to be attached to support tickets. Compatibility The Diagnostics CLI is available for Linux, macOS, and Windows. It can detect common configuration issues for: APM: Available for all APM agents except C SDK. For the Go agent, only basic connectivity checks are available. Browser monitoring: Browser agent detection Infrastructure monitoring: Linux and Windows agents Mobile agents: iOS and Android Synthetic monitoring: Containerized private minions (CPM) The Diagnostics CLI does not require superuser or admin permissions to run, although we recommend those permissions for some checks. It will return an error if it does not have permissions to read the files it scans. Get started To use the Diagnostics CLI: Run the Diagnostics CLI, including task suites and command line options as needed. Supply the -attach flag for uploading results to your New Relic account. Optional: Validate your config file settings. Interpret the output. Like any other New Relic tool, the Diagnostics CLI service is designed to protect you and your customers' data privacy. For detailed information, see our Diagnostics CLI licensing and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.25864,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " are available. <em>Browser</em> <em>monitoring</em>: <em>Browser</em> agent detection Infrastructure <em>monitoring</em>: Linux and Windows agents Mobile agents: iOS and Android Synthetic <em>monitoring</em>: Containerized private minions (CPM) The Diagnostics CLI does not require superuser or admin permissions to run, although we recommend those"
      },
      "id": "604469f8e7b9d2abb65799f0"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "17c97a462616f2b23ead796b62780a1ffeb3dfac",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Agent version Your browser monitoring agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute browser API call To add a custom attribute to the PageView event via the browser agent, use the setCustomAttribute browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.90755,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>browser</em> <em>monitoring</em> custom events and attributes",
        "sections": "Report <em>browser</em> <em>monitoring</em> custom events and attributes",
        "body": " it to true. Python Add the <em>browser_monitoring</em>.attributes.enabled option and set it to true. Ruby Add the <em>browser_monitoring</em>.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see <em>Browser</em> events. <em>Troubleshooting</em> Here"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    }
  ],
  "/docs/browser/new-relic-browser/troubleshooting/app-server-requests-greatly-outnumber-browser-pageview-transactions": [
    {
      "sections": [
        "Introduction to browser monitoring",
        "More than Real User Monitoring (RUM)",
        "Examine user perceptions",
        "Improve interactive app performance",
        "Correlate front-end and back-end problems",
        "Get started with browser monitoring"
      ],
      "title": "Introduction to browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "4928b2a5981bd2d6263f04b4b882d65adef22779",
      "image": "https://docs.newrelic.com/static/98ad878ffa7b586b779178656f19ec58/c1b63/browser_intro_0.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/introduction-browser-monitoring/",
      "published_at": "2021-10-24T19:11:37Z",
      "updated_at": "2021-10-24T19:11:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your end-user experience depends on your entire technology stack. You need to quickly understand what's causing a customer complaint or issue. Did the problem come from your infrastructure, your application, or the browsers that ultimately render it? Is it the result of a problematic internet provider, a problem in your own data center with failing CPU or memory, or something else? More than Real User Monitoring (RUM) Many websites contain dynamic content that is loaded after the initial page has finished loading, and complex JavaScript code increases the need for error reporting. Browser monitoring in New Relic One provides a Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. With browser monitoring in New Relic One, you see actionable data about your end users' experience with your app. But browser monitoring in New Relic goes far beyond the initial page load to measure full page life cycle data. For example, our browser UI shows you: Actual performance data, such as by page view popularity and user satisfaction (Apdex) scores Perceived performance data that measures how quickly your async or dynamic visuals and interactive page contents display JavaScript error analytics, stack traces, and line-of-code visibility, to show you the end-user steps leading up to an error itself Session performance with a detailed timeline and heat map of the load and interaction events during a webpage's full life cycle AJAX requests indicating problems with timing, end points, and specific locations in the webpage Hash-based route changes in apps with single-page application (SPA) architectures These tools (and more!) help your teams optimize your end users' page load experience, eliminate bugs, and troubleshoot faster across your full stack. Examine user perceptions Real user data gives insights into actual page performance, but you also need to look into your users' perception of your site's performance. Pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser monitoring agent. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. Additional metrics include: First paint, first contentful paint, and largest contentful paint First input delay First interaction This helps you understand how users experience your site, both from visual and responsiveness standpoints. Improve interactive app performance Our single-page app (SPA) monitoring automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during browser interactions. You can also use our browser agent and SPA API to monitor virtually anything that executes inside the browser. If you are a developer, SPA monitoring can help you: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query and visualize the data to assist with business decisions. Bring better apps to the marketplace more quickly. Correlate front-end and back-end problems With New Relic One, you can instrument any type of data you need, such as metrics, events, logs, and traces. This helps you find actionable data about your end users' experience across the stack. For example: Type of data Comments Locations or domains Limit browser monitoring to focus on specific geographical locations or specific types of end-user activity. You can also monitor or block specific domains. Trends in interactions Use our comparative charting feature for a direct page load time comparison between real user (browser) interactions and trends appearing in Synthetic monitors. Distributed tracing Isolate latency from the web browser through back-end services with distributed tracing. The UI helps you see the connection across across a full transaction, from browser activity, to time spent in network, to back-end activity. Browser types Explore your end users' experience with your app segmented by any types of browsers they use, including: Top browsers by throughput Average page load time by platform type (mobile, desktop, and other) Selected browser type by version (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Get started with browser monitoring Follow these basic steps, and you'll quickly be up and running in New Relic with browser monitoring! Review the compatibility details and basic requirements for browser monitoring. Install the browser agent. Go to [one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. View summary data from your Browser summary page, then drill down into page load timing details and other UI data. Configure your alerts for key performance data, or use our Applied Intelligence solutions to reduce alert noise, correlate incidents, and automatically detect anomalies. Query and visualize your default data (or customize your own), then analyze what that data says about your business. Customize and share your own charts and dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.02986,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>browser</em> <em>monitoring</em>",
        "sections": "Introduction to <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " performance Our single-page app (SPA) <em>monitoring</em> automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during <em>browser</em> interactions. You can also use our <em>browser</em> agent and SPA API to <em>monitor</em> virtually anything that executes inside the <em>browser</em>. If you"
      },
      "id": "604429a9e7b9d2bde7579a04"
    },
    {
      "sections": [
        "Diagnostics CLI (nrdiag)",
        "Compatibility",
        "Get started"
      ],
      "title": "Diagnostics CLI (nrdiag)",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Diagnostics CLI (nrdiag)"
      ],
      "external_id": "973501f4752e56caf3d68e37bf21b823d0e42078",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/cross-product-functions/diagnostics-cli-nrdiag/diagnostics-cli-nrdiag/",
      "published_at": "2021-10-25T16:26:14Z",
      "updated_at": "2021-10-25T16:26:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Download latest version The Diagnostics CLI (nrdiag) is a utility that automatically detects common problems with New Relic products. If the Diagnostics CLI detects a problem, it suggests troubleshooting steps. The Diagnostics CLI can automatically upload troubleshooting data to a New Relic account. The Diagnostics CLI is open source and is located in GitHub. For additional troubleshooting steps for your agent, check out Not seeing data. Here's an example of the Diagnostics CLI running on Ubuntu Linux. The program checks your New Relic agent configurations for issues and generates zipped troubleshooting logs that are ready to be attached to support tickets. Compatibility The Diagnostics CLI is available for Linux, macOS, and Windows. It can detect common configuration issues for: APM: Available for all APM agents except C SDK. For the Go agent, only basic connectivity checks are available. Browser monitoring: Browser agent detection Infrastructure monitoring: Linux and Windows agents Mobile agents: iOS and Android Synthetic monitoring: Containerized private minions (CPM) The Diagnostics CLI does not require superuser or admin permissions to run, although we recommend those permissions for some checks. It will return an error if it does not have permissions to read the files it scans. Get started To use the Diagnostics CLI: Run the Diagnostics CLI, including task suites and command line options as needed. Supply the -attach flag for uploading results to your New Relic account. Optional: Validate your config file settings. Interpret the output. Like any other New Relic tool, the Diagnostics CLI service is designed to protect you and your customers' data privacy. For detailed information, see our Diagnostics CLI licensing and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.25854,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " are available. <em>Browser</em> <em>monitoring</em>: <em>Browser</em> agent detection Infrastructure <em>monitoring</em>: Linux and Windows agents Mobile agents: iOS and Android Synthetic <em>monitoring</em>: Containerized private minions (CPM) The Diagnostics CLI does not require superuser or admin permissions to run, although we recommend those"
      },
      "id": "604469f8e7b9d2abb65799f0"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "17c97a462616f2b23ead796b62780a1ffeb3dfac",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Agent version Your browser monitoring agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute browser API call To add a custom attribute to the PageView event via the browser agent, use the setCustomAttribute browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.90747,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>browser</em> <em>monitoring</em> custom events and attributes",
        "sections": "Report <em>browser</em> <em>monitoring</em> custom events and attributes",
        "body": " it to true. Python Add the <em>browser_monitoring</em>.attributes.enabled option and set it to true. Ruby Add the <em>browser_monitoring</em>.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see <em>Browser</em> events. <em>Troubleshooting</em> Here"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    }
  ],
  "/docs/browser/new-relic-browser/troubleshooting/browser-data-doesnt-match-other-analytics-tools": [
    {
      "sections": [
        "Introduction to browser monitoring",
        "More than Real User Monitoring (RUM)",
        "Examine user perceptions",
        "Improve interactive app performance",
        "Correlate front-end and back-end problems",
        "Get started with browser monitoring"
      ],
      "title": "Introduction to browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "4928b2a5981bd2d6263f04b4b882d65adef22779",
      "image": "https://docs.newrelic.com/static/98ad878ffa7b586b779178656f19ec58/c1b63/browser_intro_0.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/introduction-browser-monitoring/",
      "published_at": "2021-10-24T19:11:37Z",
      "updated_at": "2021-10-24T19:11:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your end-user experience depends on your entire technology stack. You need to quickly understand what's causing a customer complaint or issue. Did the problem come from your infrastructure, your application, or the browsers that ultimately render it? Is it the result of a problematic internet provider, a problem in your own data center with failing CPU or memory, or something else? More than Real User Monitoring (RUM) Many websites contain dynamic content that is loaded after the initial page has finished loading, and complex JavaScript code increases the need for error reporting. Browser monitoring in New Relic One provides a Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. With browser monitoring in New Relic One, you see actionable data about your end users' experience with your app. But browser monitoring in New Relic goes far beyond the initial page load to measure full page life cycle data. For example, our browser UI shows you: Actual performance data, such as by page view popularity and user satisfaction (Apdex) scores Perceived performance data that measures how quickly your async or dynamic visuals and interactive page contents display JavaScript error analytics, stack traces, and line-of-code visibility, to show you the end-user steps leading up to an error itself Session performance with a detailed timeline and heat map of the load and interaction events during a webpage's full life cycle AJAX requests indicating problems with timing, end points, and specific locations in the webpage Hash-based route changes in apps with single-page application (SPA) architectures These tools (and more!) help your teams optimize your end users' page load experience, eliminate bugs, and troubleshoot faster across your full stack. Examine user perceptions Real user data gives insights into actual page performance, but you also need to look into your users' perception of your site's performance. Pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser monitoring agent. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. Additional metrics include: First paint, first contentful paint, and largest contentful paint First input delay First interaction This helps you understand how users experience your site, both from visual and responsiveness standpoints. Improve interactive app performance Our single-page app (SPA) monitoring automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during browser interactions. You can also use our browser agent and SPA API to monitor virtually anything that executes inside the browser. If you are a developer, SPA monitoring can help you: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query and visualize the data to assist with business decisions. Bring better apps to the marketplace more quickly. Correlate front-end and back-end problems With New Relic One, you can instrument any type of data you need, such as metrics, events, logs, and traces. This helps you find actionable data about your end users' experience across the stack. For example: Type of data Comments Locations or domains Limit browser monitoring to focus on specific geographical locations or specific types of end-user activity. You can also monitor or block specific domains. Trends in interactions Use our comparative charting feature for a direct page load time comparison between real user (browser) interactions and trends appearing in Synthetic monitors. Distributed tracing Isolate latency from the web browser through back-end services with distributed tracing. The UI helps you see the connection across across a full transaction, from browser activity, to time spent in network, to back-end activity. Browser types Explore your end users' experience with your app segmented by any types of browsers they use, including: Top browsers by throughput Average page load time by platform type (mobile, desktop, and other) Selected browser type by version (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Get started with browser monitoring Follow these basic steps, and you'll quickly be up and running in New Relic with browser monitoring! Review the compatibility details and basic requirements for browser monitoring. Install the browser agent. Go to [one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. View summary data from your Browser summary page, then drill down into page load timing details and other UI data. Configure your alerts for key performance data, or use our Applied Intelligence solutions to reduce alert noise, correlate incidents, and automatically detect anomalies. Query and visualize your default data (or customize your own), then analyze what that data says about your business. Customize and share your own charts and dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.02986,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>browser</em> <em>monitoring</em>",
        "sections": "Introduction to <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " performance Our single-page app (SPA) <em>monitoring</em> automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during <em>browser</em> interactions. You can also use our <em>browser</em> agent and SPA API to <em>monitor</em> virtually anything that executes inside the <em>browser</em>. If you"
      },
      "id": "604429a9e7b9d2bde7579a04"
    },
    {
      "sections": [
        "Diagnostics CLI (nrdiag)",
        "Compatibility",
        "Get started"
      ],
      "title": "Diagnostics CLI (nrdiag)",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Diagnostics CLI (nrdiag)"
      ],
      "external_id": "973501f4752e56caf3d68e37bf21b823d0e42078",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/cross-product-functions/diagnostics-cli-nrdiag/diagnostics-cli-nrdiag/",
      "published_at": "2021-10-25T16:26:14Z",
      "updated_at": "2021-10-25T16:26:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Download latest version The Diagnostics CLI (nrdiag) is a utility that automatically detects common problems with New Relic products. If the Diagnostics CLI detects a problem, it suggests troubleshooting steps. The Diagnostics CLI can automatically upload troubleshooting data to a New Relic account. The Diagnostics CLI is open source and is located in GitHub. For additional troubleshooting steps for your agent, check out Not seeing data. Here's an example of the Diagnostics CLI running on Ubuntu Linux. The program checks your New Relic agent configurations for issues and generates zipped troubleshooting logs that are ready to be attached to support tickets. Compatibility The Diagnostics CLI is available for Linux, macOS, and Windows. It can detect common configuration issues for: APM: Available for all APM agents except C SDK. For the Go agent, only basic connectivity checks are available. Browser monitoring: Browser agent detection Infrastructure monitoring: Linux and Windows agents Mobile agents: iOS and Android Synthetic monitoring: Containerized private minions (CPM) The Diagnostics CLI does not require superuser or admin permissions to run, although we recommend those permissions for some checks. It will return an error if it does not have permissions to read the files it scans. Get started To use the Diagnostics CLI: Run the Diagnostics CLI, including task suites and command line options as needed. Supply the -attach flag for uploading results to your New Relic account. Optional: Validate your config file settings. Interpret the output. Like any other New Relic tool, the Diagnostics CLI service is designed to protect you and your customers' data privacy. For detailed information, see our Diagnostics CLI licensing and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.25854,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " are available. <em>Browser</em> <em>monitoring</em>: <em>Browser</em> agent detection Infrastructure <em>monitoring</em>: Linux and Windows agents Mobile agents: iOS and Android Synthetic <em>monitoring</em>: Containerized private minions (CPM) The Diagnostics CLI does not require superuser or admin permissions to run, although we recommend those"
      },
      "id": "604469f8e7b9d2abb65799f0"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "17c97a462616f2b23ead796b62780a1ffeb3dfac",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Agent version Your browser monitoring agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute browser API call To add a custom attribute to the PageView event via the browser agent, use the setCustomAttribute browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.90747,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>browser</em> <em>monitoring</em> custom events and attributes",
        "sections": "Report <em>browser</em> <em>monitoring</em> custom events and attributes",
        "body": " it to true. Python Add the <em>browser_monitoring</em>.attributes.enabled option and set it to true. Ruby Add the <em>browser_monitoring</em>.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see <em>Browser</em> events. <em>Troubleshooting</em> Here"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    }
  ],
  "/docs/browser/new-relic-browser/troubleshooting/browser-javascript-injection-causes-problems-page": [
    {
      "sections": [
        "Introduction to browser monitoring",
        "More than Real User Monitoring (RUM)",
        "Examine user perceptions",
        "Improve interactive app performance",
        "Correlate front-end and back-end problems",
        "Get started with browser monitoring"
      ],
      "title": "Introduction to browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "4928b2a5981bd2d6263f04b4b882d65adef22779",
      "image": "https://docs.newrelic.com/static/98ad878ffa7b586b779178656f19ec58/c1b63/browser_intro_0.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/introduction-browser-monitoring/",
      "published_at": "2021-10-24T19:11:37Z",
      "updated_at": "2021-10-24T19:11:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your end-user experience depends on your entire technology stack. You need to quickly understand what's causing a customer complaint or issue. Did the problem come from your infrastructure, your application, or the browsers that ultimately render it? Is it the result of a problematic internet provider, a problem in your own data center with failing CPU or memory, or something else? More than Real User Monitoring (RUM) Many websites contain dynamic content that is loaded after the initial page has finished loading, and complex JavaScript code increases the need for error reporting. Browser monitoring in New Relic One provides a Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. With browser monitoring in New Relic One, you see actionable data about your end users' experience with your app. But browser monitoring in New Relic goes far beyond the initial page load to measure full page life cycle data. For example, our browser UI shows you: Actual performance data, such as by page view popularity and user satisfaction (Apdex) scores Perceived performance data that measures how quickly your async or dynamic visuals and interactive page contents display JavaScript error analytics, stack traces, and line-of-code visibility, to show you the end-user steps leading up to an error itself Session performance with a detailed timeline and heat map of the load and interaction events during a webpage's full life cycle AJAX requests indicating problems with timing, end points, and specific locations in the webpage Hash-based route changes in apps with single-page application (SPA) architectures These tools (and more!) help your teams optimize your end users' page load experience, eliminate bugs, and troubleshoot faster across your full stack. Examine user perceptions Real user data gives insights into actual page performance, but you also need to look into your users' perception of your site's performance. Pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser monitoring agent. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. Additional metrics include: First paint, first contentful paint, and largest contentful paint First input delay First interaction This helps you understand how users experience your site, both from visual and responsiveness standpoints. Improve interactive app performance Our single-page app (SPA) monitoring automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during browser interactions. You can also use our browser agent and SPA API to monitor virtually anything that executes inside the browser. If you are a developer, SPA monitoring can help you: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query and visualize the data to assist with business decisions. Bring better apps to the marketplace more quickly. Correlate front-end and back-end problems With New Relic One, you can instrument any type of data you need, such as metrics, events, logs, and traces. This helps you find actionable data about your end users' experience across the stack. For example: Type of data Comments Locations or domains Limit browser monitoring to focus on specific geographical locations or specific types of end-user activity. You can also monitor or block specific domains. Trends in interactions Use our comparative charting feature for a direct page load time comparison between real user (browser) interactions and trends appearing in Synthetic monitors. Distributed tracing Isolate latency from the web browser through back-end services with distributed tracing. The UI helps you see the connection across across a full transaction, from browser activity, to time spent in network, to back-end activity. Browser types Explore your end users' experience with your app segmented by any types of browsers they use, including: Top browsers by throughput Average page load time by platform type (mobile, desktop, and other) Selected browser type by version (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Get started with browser monitoring Follow these basic steps, and you'll quickly be up and running in New Relic with browser monitoring! Review the compatibility details and basic requirements for browser monitoring. Install the browser agent. Go to [one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. View summary data from your Browser summary page, then drill down into page load timing details and other UI data. Configure your alerts for key performance data, or use our Applied Intelligence solutions to reduce alert noise, correlate incidents, and automatically detect anomalies. Query and visualize your default data (or customize your own), then analyze what that data says about your business. Customize and share your own charts and dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.02975,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>browser</em> <em>monitoring</em>",
        "sections": "Introduction to <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " performance Our single-page app (SPA) <em>monitoring</em> automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during <em>browser</em> interactions. You can also use our <em>browser</em> agent and SPA API to <em>monitor</em> virtually anything that executes inside the <em>browser</em>. If you"
      },
      "id": "604429a9e7b9d2bde7579a04"
    },
    {
      "sections": [
        "Diagnostics CLI (nrdiag)",
        "Compatibility",
        "Get started"
      ],
      "title": "Diagnostics CLI (nrdiag)",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Diagnostics CLI (nrdiag)"
      ],
      "external_id": "973501f4752e56caf3d68e37bf21b823d0e42078",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/cross-product-functions/diagnostics-cli-nrdiag/diagnostics-cli-nrdiag/",
      "published_at": "2021-10-25T16:26:14Z",
      "updated_at": "2021-10-25T16:26:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Download latest version The Diagnostics CLI (nrdiag) is a utility that automatically detects common problems with New Relic products. If the Diagnostics CLI detects a problem, it suggests troubleshooting steps. The Diagnostics CLI can automatically upload troubleshooting data to a New Relic account. The Diagnostics CLI is open source and is located in GitHub. For additional troubleshooting steps for your agent, check out Not seeing data. Here's an example of the Diagnostics CLI running on Ubuntu Linux. The program checks your New Relic agent configurations for issues and generates zipped troubleshooting logs that are ready to be attached to support tickets. Compatibility The Diagnostics CLI is available for Linux, macOS, and Windows. It can detect common configuration issues for: APM: Available for all APM agents except C SDK. For the Go agent, only basic connectivity checks are available. Browser monitoring: Browser agent detection Infrastructure monitoring: Linux and Windows agents Mobile agents: iOS and Android Synthetic monitoring: Containerized private minions (CPM) The Diagnostics CLI does not require superuser or admin permissions to run, although we recommend those permissions for some checks. It will return an error if it does not have permissions to read the files it scans. Get started To use the Diagnostics CLI: Run the Diagnostics CLI, including task suites and command line options as needed. Supply the -attach flag for uploading results to your New Relic account. Optional: Validate your config file settings. Interpret the output. Like any other New Relic tool, the Diagnostics CLI service is designed to protect you and your customers' data privacy. For detailed information, see our Diagnostics CLI licensing and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.25845,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " are available. <em>Browser</em> <em>monitoring</em>: <em>Browser</em> agent detection Infrastructure <em>monitoring</em>: Linux and Windows agents Mobile agents: iOS and Android Synthetic <em>monitoring</em>: Containerized private minions (CPM) The Diagnostics CLI does not require superuser or admin permissions to run, although we recommend those"
      },
      "id": "604469f8e7b9d2abb65799f0"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "17c97a462616f2b23ead796b62780a1ffeb3dfac",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Agent version Your browser monitoring agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute browser API call To add a custom attribute to the PageView event via the browser agent, use the setCustomAttribute browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.90741,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>browser</em> <em>monitoring</em> custom events and attributes",
        "sections": "Report <em>browser</em> <em>monitoring</em> custom events and attributes",
        "body": " it to true. Python Add the <em>browser_monitoring</em>.attributes.enabled option and set it to true. Ruby Add the <em>browser_monitoring</em>.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see <em>Browser</em> events. <em>Troubleshooting</em> Here"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    }
  ],
  "/docs/browser/new-relic-browser/troubleshooting/get-browser-side-troubleshooting-details-har-file": [
    {
      "sections": [
        "Introduction to browser monitoring",
        "More than Real User Monitoring (RUM)",
        "Examine user perceptions",
        "Improve interactive app performance",
        "Correlate front-end and back-end problems",
        "Get started with browser monitoring"
      ],
      "title": "Introduction to browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "4928b2a5981bd2d6263f04b4b882d65adef22779",
      "image": "https://docs.newrelic.com/static/98ad878ffa7b586b779178656f19ec58/c1b63/browser_intro_0.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/introduction-browser-monitoring/",
      "published_at": "2021-10-24T19:11:37Z",
      "updated_at": "2021-10-24T19:11:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your end-user experience depends on your entire technology stack. You need to quickly understand what's causing a customer complaint or issue. Did the problem come from your infrastructure, your application, or the browsers that ultimately render it? Is it the result of a problematic internet provider, a problem in your own data center with failing CPU or memory, or something else? More than Real User Monitoring (RUM) Many websites contain dynamic content that is loaded after the initial page has finished loading, and complex JavaScript code increases the need for error reporting. Browser monitoring in New Relic One provides a Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. With browser monitoring in New Relic One, you see actionable data about your end users' experience with your app. But browser monitoring in New Relic goes far beyond the initial page load to measure full page life cycle data. For example, our browser UI shows you: Actual performance data, such as by page view popularity and user satisfaction (Apdex) scores Perceived performance data that measures how quickly your async or dynamic visuals and interactive page contents display JavaScript error analytics, stack traces, and line-of-code visibility, to show you the end-user steps leading up to an error itself Session performance with a detailed timeline and heat map of the load and interaction events during a webpage's full life cycle AJAX requests indicating problems with timing, end points, and specific locations in the webpage Hash-based route changes in apps with single-page application (SPA) architectures These tools (and more!) help your teams optimize your end users' page load experience, eliminate bugs, and troubleshoot faster across your full stack. Examine user perceptions Real user data gives insights into actual page performance, but you also need to look into your users' perception of your site's performance. Pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser monitoring agent. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. Additional metrics include: First paint, first contentful paint, and largest contentful paint First input delay First interaction This helps you understand how users experience your site, both from visual and responsiveness standpoints. Improve interactive app performance Our single-page app (SPA) monitoring automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during browser interactions. You can also use our browser agent and SPA API to monitor virtually anything that executes inside the browser. If you are a developer, SPA monitoring can help you: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query and visualize the data to assist with business decisions. Bring better apps to the marketplace more quickly. Correlate front-end and back-end problems With New Relic One, you can instrument any type of data you need, such as metrics, events, logs, and traces. This helps you find actionable data about your end users' experience across the stack. For example: Type of data Comments Locations or domains Limit browser monitoring to focus on specific geographical locations or specific types of end-user activity. You can also monitor or block specific domains. Trends in interactions Use our comparative charting feature for a direct page load time comparison between real user (browser) interactions and trends appearing in Synthetic monitors. Distributed tracing Isolate latency from the web browser through back-end services with distributed tracing. The UI helps you see the connection across across a full transaction, from browser activity, to time spent in network, to back-end activity. Browser types Explore your end users' experience with your app segmented by any types of browsers they use, including: Top browsers by throughput Average page load time by platform type (mobile, desktop, and other) Selected browser type by version (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Get started with browser monitoring Follow these basic steps, and you'll quickly be up and running in New Relic with browser monitoring! Review the compatibility details and basic requirements for browser monitoring. Install the browser agent. Go to [one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. View summary data from your Browser summary page, then drill down into page load timing details and other UI data. Configure your alerts for key performance data, or use our Applied Intelligence solutions to reduce alert noise, correlate incidents, and automatically detect anomalies. Query and visualize your default data (or customize your own), then analyze what that data says about your business. Customize and share your own charts and dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.02975,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>browser</em> <em>monitoring</em>",
        "sections": "Introduction to <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " performance Our single-page app (SPA) <em>monitoring</em> automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during <em>browser</em> interactions. You can also use our <em>browser</em> agent and SPA API to <em>monitor</em> virtually anything that executes inside the <em>browser</em>. If you"
      },
      "id": "604429a9e7b9d2bde7579a04"
    },
    {
      "sections": [
        "Diagnostics CLI (nrdiag)",
        "Compatibility",
        "Get started"
      ],
      "title": "Diagnostics CLI (nrdiag)",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Diagnostics CLI (nrdiag)"
      ],
      "external_id": "973501f4752e56caf3d68e37bf21b823d0e42078",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/cross-product-functions/diagnostics-cli-nrdiag/diagnostics-cli-nrdiag/",
      "published_at": "2021-10-25T16:26:14Z",
      "updated_at": "2021-10-25T16:26:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Download latest version The Diagnostics CLI (nrdiag) is a utility that automatically detects common problems with New Relic products. If the Diagnostics CLI detects a problem, it suggests troubleshooting steps. The Diagnostics CLI can automatically upload troubleshooting data to a New Relic account. The Diagnostics CLI is open source and is located in GitHub. For additional troubleshooting steps for your agent, check out Not seeing data. Here's an example of the Diagnostics CLI running on Ubuntu Linux. The program checks your New Relic agent configurations for issues and generates zipped troubleshooting logs that are ready to be attached to support tickets. Compatibility The Diagnostics CLI is available for Linux, macOS, and Windows. It can detect common configuration issues for: APM: Available for all APM agents except C SDK. For the Go agent, only basic connectivity checks are available. Browser monitoring: Browser agent detection Infrastructure monitoring: Linux and Windows agents Mobile agents: iOS and Android Synthetic monitoring: Containerized private minions (CPM) The Diagnostics CLI does not require superuser or admin permissions to run, although we recommend those permissions for some checks. It will return an error if it does not have permissions to read the files it scans. Get started To use the Diagnostics CLI: Run the Diagnostics CLI, including task suites and command line options as needed. Supply the -attach flag for uploading results to your New Relic account. Optional: Validate your config file settings. Interpret the output. Like any other New Relic tool, the Diagnostics CLI service is designed to protect you and your customers' data privacy. For detailed information, see our Diagnostics CLI licensing and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.25845,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " are available. <em>Browser</em> <em>monitoring</em>: <em>Browser</em> agent detection Infrastructure <em>monitoring</em>: Linux and Windows agents Mobile agents: iOS and Android Synthetic <em>monitoring</em>: Containerized private minions (CPM) The Diagnostics CLI does not require superuser or admin permissions to run, although we recommend those"
      },
      "id": "604469f8e7b9d2abb65799f0"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "17c97a462616f2b23ead796b62780a1ffeb3dfac",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Agent version Your browser monitoring agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute browser API call To add a custom attribute to the PageView event via the browser agent, use the setCustomAttribute browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.90741,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>browser</em> <em>monitoring</em> custom events and attributes",
        "sections": "Report <em>browser</em> <em>monitoring</em> custom events and attributes",
        "body": " it to true. Python Add the <em>browser_monitoring</em>.attributes.enabled option and set it to true. Ruby Add the <em>browser_monitoring</em>.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see <em>Browser</em> events. <em>Troubleshooting</em> Here"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    }
  ],
  "/docs/browser/new-relic-browser/troubleshooting/not-seeing-specific-page-or-endpoint-names-browser-data": [
    {
      "sections": [
        "Introduction to browser monitoring",
        "More than Real User Monitoring (RUM)",
        "Examine user perceptions",
        "Improve interactive app performance",
        "Correlate front-end and back-end problems",
        "Get started with browser monitoring"
      ],
      "title": "Introduction to browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "4928b2a5981bd2d6263f04b4b882d65adef22779",
      "image": "https://docs.newrelic.com/static/98ad878ffa7b586b779178656f19ec58/c1b63/browser_intro_0.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/introduction-browser-monitoring/",
      "published_at": "2021-10-24T19:11:37Z",
      "updated_at": "2021-10-24T19:11:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your end-user experience depends on your entire technology stack. You need to quickly understand what's causing a customer complaint or issue. Did the problem come from your infrastructure, your application, or the browsers that ultimately render it? Is it the result of a problematic internet provider, a problem in your own data center with failing CPU or memory, or something else? More than Real User Monitoring (RUM) Many websites contain dynamic content that is loaded after the initial page has finished loading, and complex JavaScript code increases the need for error reporting. Browser monitoring in New Relic One provides a Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. With browser monitoring in New Relic One, you see actionable data about your end users' experience with your app. But browser monitoring in New Relic goes far beyond the initial page load to measure full page life cycle data. For example, our browser UI shows you: Actual performance data, such as by page view popularity and user satisfaction (Apdex) scores Perceived performance data that measures how quickly your async or dynamic visuals and interactive page contents display JavaScript error analytics, stack traces, and line-of-code visibility, to show you the end-user steps leading up to an error itself Session performance with a detailed timeline and heat map of the load and interaction events during a webpage's full life cycle AJAX requests indicating problems with timing, end points, and specific locations in the webpage Hash-based route changes in apps with single-page application (SPA) architectures These tools (and more!) help your teams optimize your end users' page load experience, eliminate bugs, and troubleshoot faster across your full stack. Examine user perceptions Real user data gives insights into actual page performance, but you also need to look into your users' perception of your site's performance. Pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser monitoring agent. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. Additional metrics include: First paint, first contentful paint, and largest contentful paint First input delay First interaction This helps you understand how users experience your site, both from visual and responsiveness standpoints. Improve interactive app performance Our single-page app (SPA) monitoring automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during browser interactions. You can also use our browser agent and SPA API to monitor virtually anything that executes inside the browser. If you are a developer, SPA monitoring can help you: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query and visualize the data to assist with business decisions. Bring better apps to the marketplace more quickly. Correlate front-end and back-end problems With New Relic One, you can instrument any type of data you need, such as metrics, events, logs, and traces. This helps you find actionable data about your end users' experience across the stack. For example: Type of data Comments Locations or domains Limit browser monitoring to focus on specific geographical locations or specific types of end-user activity. You can also monitor or block specific domains. Trends in interactions Use our comparative charting feature for a direct page load time comparison between real user (browser) interactions and trends appearing in Synthetic monitors. Distributed tracing Isolate latency from the web browser through back-end services with distributed tracing. The UI helps you see the connection across across a full transaction, from browser activity, to time spent in network, to back-end activity. Browser types Explore your end users' experience with your app segmented by any types of browsers they use, including: Top browsers by throughput Average page load time by platform type (mobile, desktop, and other) Selected browser type by version (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Get started with browser monitoring Follow these basic steps, and you'll quickly be up and running in New Relic with browser monitoring! Review the compatibility details and basic requirements for browser monitoring. Install the browser agent. Go to [one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. View summary data from your Browser summary page, then drill down into page load timing details and other UI data. Configure your alerts for key performance data, or use our Applied Intelligence solutions to reduce alert noise, correlate incidents, and automatically detect anomalies. Query and visualize your default data (or customize your own), then analyze what that data says about your business. Customize and share your own charts and dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.02966,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>browser</em> <em>monitoring</em>",
        "sections": "Introduction to <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " performance Our single-page app (SPA) <em>monitoring</em> automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during <em>browser</em> interactions. You can also use our <em>browser</em> agent and SPA API to <em>monitor</em> virtually anything that executes inside the <em>browser</em>. If you"
      },
      "id": "604429a9e7b9d2bde7579a04"
    },
    {
      "sections": [
        "Diagnostics CLI (nrdiag)",
        "Compatibility",
        "Get started"
      ],
      "title": "Diagnostics CLI (nrdiag)",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Diagnostics CLI (nrdiag)"
      ],
      "external_id": "973501f4752e56caf3d68e37bf21b823d0e42078",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/cross-product-functions/diagnostics-cli-nrdiag/diagnostics-cli-nrdiag/",
      "published_at": "2021-10-25T16:26:14Z",
      "updated_at": "2021-10-25T16:26:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Download latest version The Diagnostics CLI (nrdiag) is a utility that automatically detects common problems with New Relic products. If the Diagnostics CLI detects a problem, it suggests troubleshooting steps. The Diagnostics CLI can automatically upload troubleshooting data to a New Relic account. The Diagnostics CLI is open source and is located in GitHub. For additional troubleshooting steps for your agent, check out Not seeing data. Here's an example of the Diagnostics CLI running on Ubuntu Linux. The program checks your New Relic agent configurations for issues and generates zipped troubleshooting logs that are ready to be attached to support tickets. Compatibility The Diagnostics CLI is available for Linux, macOS, and Windows. It can detect common configuration issues for: APM: Available for all APM agents except C SDK. For the Go agent, only basic connectivity checks are available. Browser monitoring: Browser agent detection Infrastructure monitoring: Linux and Windows agents Mobile agents: iOS and Android Synthetic monitoring: Containerized private minions (CPM) The Diagnostics CLI does not require superuser or admin permissions to run, although we recommend those permissions for some checks. It will return an error if it does not have permissions to read the files it scans. Get started To use the Diagnostics CLI: Run the Diagnostics CLI, including task suites and command line options as needed. Supply the -attach flag for uploading results to your New Relic account. Optional: Validate your config file settings. Interpret the output. Like any other New Relic tool, the Diagnostics CLI service is designed to protect you and your customers' data privacy. For detailed information, see our Diagnostics CLI licensing and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.25836,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " are available. <em>Browser</em> <em>monitoring</em>: <em>Browser</em> agent detection Infrastructure <em>monitoring</em>: Linux and Windows agents Mobile agents: iOS and Android Synthetic <em>monitoring</em>: Containerized private minions (CPM) The Diagnostics CLI does not require superuser or admin permissions to run, although we recommend those"
      },
      "id": "604469f8e7b9d2abb65799f0"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "17c97a462616f2b23ead796b62780a1ffeb3dfac",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Agent version Your browser monitoring agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute browser API call To add a custom attribute to the PageView event via the browser agent, use the setCustomAttribute browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.90735,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>browser</em> <em>monitoring</em> custom events and attributes",
        "sections": "Report <em>browser</em> <em>monitoring</em> custom events and attributes",
        "body": " it to true. Python Add the <em>browser_monitoring</em>.attributes.enabled option and set it to true. Ruby Add the <em>browser_monitoring</em>.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see <em>Browser</em> events. <em>Troubleshooting</em> Here"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    }
  ],
  "/docs/browser/new-relic-browser/troubleshooting/third-party-js-errors-missing-stack-traces": [
    {
      "sections": [
        "Introduction to browser monitoring",
        "More than Real User Monitoring (RUM)",
        "Examine user perceptions",
        "Improve interactive app performance",
        "Correlate front-end and back-end problems",
        "Get started with browser monitoring"
      ],
      "title": "Introduction to browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "4928b2a5981bd2d6263f04b4b882d65adef22779",
      "image": "https://docs.newrelic.com/static/98ad878ffa7b586b779178656f19ec58/c1b63/browser_intro_0.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/introduction-browser-monitoring/",
      "published_at": "2021-10-24T19:11:37Z",
      "updated_at": "2021-10-24T19:11:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your end-user experience depends on your entire technology stack. You need to quickly understand what's causing a customer complaint or issue. Did the problem come from your infrastructure, your application, or the browsers that ultimately render it? Is it the result of a problematic internet provider, a problem in your own data center with failing CPU or memory, or something else? More than Real User Monitoring (RUM) Many websites contain dynamic content that is loaded after the initial page has finished loading, and complex JavaScript code increases the need for error reporting. Browser monitoring in New Relic One provides a Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. With browser monitoring in New Relic One, you see actionable data about your end users' experience with your app. But browser monitoring in New Relic goes far beyond the initial page load to measure full page life cycle data. For example, our browser UI shows you: Actual performance data, such as by page view popularity and user satisfaction (Apdex) scores Perceived performance data that measures how quickly your async or dynamic visuals and interactive page contents display JavaScript error analytics, stack traces, and line-of-code visibility, to show you the end-user steps leading up to an error itself Session performance with a detailed timeline and heat map of the load and interaction events during a webpage's full life cycle AJAX requests indicating problems with timing, end points, and specific locations in the webpage Hash-based route changes in apps with single-page application (SPA) architectures These tools (and more!) help your teams optimize your end users' page load experience, eliminate bugs, and troubleshoot faster across your full stack. Examine user perceptions Real user data gives insights into actual page performance, but you also need to look into your users' perception of your site's performance. Pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser monitoring agent. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. Additional metrics include: First paint, first contentful paint, and largest contentful paint First input delay First interaction This helps you understand how users experience your site, both from visual and responsiveness standpoints. Improve interactive app performance Our single-page app (SPA) monitoring automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during browser interactions. You can also use our browser agent and SPA API to monitor virtually anything that executes inside the browser. If you are a developer, SPA monitoring can help you: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query and visualize the data to assist with business decisions. Bring better apps to the marketplace more quickly. Correlate front-end and back-end problems With New Relic One, you can instrument any type of data you need, such as metrics, events, logs, and traces. This helps you find actionable data about your end users' experience across the stack. For example: Type of data Comments Locations or domains Limit browser monitoring to focus on specific geographical locations or specific types of end-user activity. You can also monitor or block specific domains. Trends in interactions Use our comparative charting feature for a direct page load time comparison between real user (browser) interactions and trends appearing in Synthetic monitors. Distributed tracing Isolate latency from the web browser through back-end services with distributed tracing. The UI helps you see the connection across across a full transaction, from browser activity, to time spent in network, to back-end activity. Browser types Explore your end users' experience with your app segmented by any types of browsers they use, including: Top browsers by throughput Average page load time by platform type (mobile, desktop, and other) Selected browser type by version (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Get started with browser monitoring Follow these basic steps, and you'll quickly be up and running in New Relic with browser monitoring! Review the compatibility details and basic requirements for browser monitoring. Install the browser agent. Go to [one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. View summary data from your Browser summary page, then drill down into page load timing details and other UI data. Configure your alerts for key performance data, or use our Applied Intelligence solutions to reduce alert noise, correlate incidents, and automatically detect anomalies. Query and visualize your default data (or customize your own), then analyze what that data says about your business. Customize and share your own charts and dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.02966,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>browser</em> <em>monitoring</em>",
        "sections": "Introduction to <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " performance Our single-page app (SPA) <em>monitoring</em> automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during <em>browser</em> interactions. You can also use our <em>browser</em> agent and SPA API to <em>monitor</em> virtually anything that executes inside the <em>browser</em>. If you"
      },
      "id": "604429a9e7b9d2bde7579a04"
    },
    {
      "sections": [
        "Diagnostics CLI (nrdiag)",
        "Compatibility",
        "Get started"
      ],
      "title": "Diagnostics CLI (nrdiag)",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Diagnostics CLI (nrdiag)"
      ],
      "external_id": "973501f4752e56caf3d68e37bf21b823d0e42078",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/cross-product-functions/diagnostics-cli-nrdiag/diagnostics-cli-nrdiag/",
      "published_at": "2021-10-25T16:26:14Z",
      "updated_at": "2021-10-25T16:26:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Download latest version The Diagnostics CLI (nrdiag) is a utility that automatically detects common problems with New Relic products. If the Diagnostics CLI detects a problem, it suggests troubleshooting steps. The Diagnostics CLI can automatically upload troubleshooting data to a New Relic account. The Diagnostics CLI is open source and is located in GitHub. For additional troubleshooting steps for your agent, check out Not seeing data. Here's an example of the Diagnostics CLI running on Ubuntu Linux. The program checks your New Relic agent configurations for issues and generates zipped troubleshooting logs that are ready to be attached to support tickets. Compatibility The Diagnostics CLI is available for Linux, macOS, and Windows. It can detect common configuration issues for: APM: Available for all APM agents except C SDK. For the Go agent, only basic connectivity checks are available. Browser monitoring: Browser agent detection Infrastructure monitoring: Linux and Windows agents Mobile agents: iOS and Android Synthetic monitoring: Containerized private minions (CPM) The Diagnostics CLI does not require superuser or admin permissions to run, although we recommend those permissions for some checks. It will return an error if it does not have permissions to read the files it scans. Get started To use the Diagnostics CLI: Run the Diagnostics CLI, including task suites and command line options as needed. Supply the -attach flag for uploading results to your New Relic account. Optional: Validate your config file settings. Interpret the output. Like any other New Relic tool, the Diagnostics CLI service is designed to protect you and your customers' data privacy. For detailed information, see our Diagnostics CLI licensing and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.25836,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " are available. <em>Browser</em> <em>monitoring</em>: <em>Browser</em> agent detection Infrastructure <em>monitoring</em>: Linux and Windows agents Mobile agents: iOS and Android Synthetic <em>monitoring</em>: Containerized private minions (CPM) The Diagnostics CLI does not require superuser or admin permissions to run, although we recommend those"
      },
      "id": "604469f8e7b9d2abb65799f0"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "17c97a462616f2b23ead796b62780a1ffeb3dfac",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Agent version Your browser monitoring agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute browser API call To add a custom attribute to the PageView event via the browser agent, use the setCustomAttribute browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.90735,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>browser</em> <em>monitoring</em> custom events and attributes",
        "sections": "Report <em>browser</em> <em>monitoring</em> custom events and attributes",
        "body": " it to true. Python Add the <em>browser_monitoring</em>.attributes.enabled option and set it to true. Ruby Add the <em>browser_monitoring</em>.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see <em>Browser</em> events. <em>Troubleshooting</em> Here"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    }
  ],
  "/docs/browser/new-relic-browser/troubleshooting/troubleshoot-ajax-data-collection": [
    {
      "sections": [
        "Introduction to browser monitoring",
        "More than Real User Monitoring (RUM)",
        "Examine user perceptions",
        "Improve interactive app performance",
        "Correlate front-end and back-end problems",
        "Get started with browser monitoring"
      ],
      "title": "Introduction to browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "4928b2a5981bd2d6263f04b4b882d65adef22779",
      "image": "https://docs.newrelic.com/static/98ad878ffa7b586b779178656f19ec58/c1b63/browser_intro_0.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/introduction-browser-monitoring/",
      "published_at": "2021-10-24T19:11:37Z",
      "updated_at": "2021-10-24T19:11:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your end-user experience depends on your entire technology stack. You need to quickly understand what's causing a customer complaint or issue. Did the problem come from your infrastructure, your application, or the browsers that ultimately render it? Is it the result of a problematic internet provider, a problem in your own data center with failing CPU or memory, or something else? More than Real User Monitoring (RUM) Many websites contain dynamic content that is loaded after the initial page has finished loading, and complex JavaScript code increases the need for error reporting. Browser monitoring in New Relic One provides a Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. With browser monitoring in New Relic One, you see actionable data about your end users' experience with your app. But browser monitoring in New Relic goes far beyond the initial page load to measure full page life cycle data. For example, our browser UI shows you: Actual performance data, such as by page view popularity and user satisfaction (Apdex) scores Perceived performance data that measures how quickly your async or dynamic visuals and interactive page contents display JavaScript error analytics, stack traces, and line-of-code visibility, to show you the end-user steps leading up to an error itself Session performance with a detailed timeline and heat map of the load and interaction events during a webpage's full life cycle AJAX requests indicating problems with timing, end points, and specific locations in the webpage Hash-based route changes in apps with single-page application (SPA) architectures These tools (and more!) help your teams optimize your end users' page load experience, eliminate bugs, and troubleshoot faster across your full stack. Examine user perceptions Real user data gives insights into actual page performance, but you also need to look into your users' perception of your site's performance. Pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser monitoring agent. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. Additional metrics include: First paint, first contentful paint, and largest contentful paint First input delay First interaction This helps you understand how users experience your site, both from visual and responsiveness standpoints. Improve interactive app performance Our single-page app (SPA) monitoring automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during browser interactions. You can also use our browser agent and SPA API to monitor virtually anything that executes inside the browser. If you are a developer, SPA monitoring can help you: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query and visualize the data to assist with business decisions. Bring better apps to the marketplace more quickly. Correlate front-end and back-end problems With New Relic One, you can instrument any type of data you need, such as metrics, events, logs, and traces. This helps you find actionable data about your end users' experience across the stack. For example: Type of data Comments Locations or domains Limit browser monitoring to focus on specific geographical locations or specific types of end-user activity. You can also monitor or block specific domains. Trends in interactions Use our comparative charting feature for a direct page load time comparison between real user (browser) interactions and trends appearing in Synthetic monitors. Distributed tracing Isolate latency from the web browser through back-end services with distributed tracing. The UI helps you see the connection across across a full transaction, from browser activity, to time spent in network, to back-end activity. Browser types Explore your end users' experience with your app segmented by any types of browsers they use, including: Top browsers by throughput Average page load time by platform type (mobile, desktop, and other) Selected browser type by version (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Get started with browser monitoring Follow these basic steps, and you'll quickly be up and running in New Relic with browser monitoring! Review the compatibility details and basic requirements for browser monitoring. Install the browser agent. Go to [one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. View summary data from your Browser summary page, then drill down into page load timing details and other UI data. Configure your alerts for key performance data, or use our Applied Intelligence solutions to reduce alert noise, correlate incidents, and automatically detect anomalies. Query and visualize your default data (or customize your own), then analyze what that data says about your business. Customize and share your own charts and dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.02957,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>browser</em> <em>monitoring</em>",
        "sections": "Introduction to <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " performance Our single-page app (SPA) <em>monitoring</em> automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during <em>browser</em> interactions. You can also use our <em>browser</em> agent and SPA API to <em>monitor</em> virtually anything that executes inside the <em>browser</em>. If you"
      },
      "id": "604429a9e7b9d2bde7579a04"
    },
    {
      "sections": [
        "Diagnostics CLI (nrdiag)",
        "Compatibility",
        "Get started"
      ],
      "title": "Diagnostics CLI (nrdiag)",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Diagnostics CLI (nrdiag)"
      ],
      "external_id": "973501f4752e56caf3d68e37bf21b823d0e42078",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/cross-product-functions/diagnostics-cli-nrdiag/diagnostics-cli-nrdiag/",
      "published_at": "2021-10-25T16:26:14Z",
      "updated_at": "2021-10-25T16:26:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Download latest version The Diagnostics CLI (nrdiag) is a utility that automatically detects common problems with New Relic products. If the Diagnostics CLI detects a problem, it suggests troubleshooting steps. The Diagnostics CLI can automatically upload troubleshooting data to a New Relic account. The Diagnostics CLI is open source and is located in GitHub. For additional troubleshooting steps for your agent, check out Not seeing data. Here's an example of the Diagnostics CLI running on Ubuntu Linux. The program checks your New Relic agent configurations for issues and generates zipped troubleshooting logs that are ready to be attached to support tickets. Compatibility The Diagnostics CLI is available for Linux, macOS, and Windows. It can detect common configuration issues for: APM: Available for all APM agents except C SDK. For the Go agent, only basic connectivity checks are available. Browser monitoring: Browser agent detection Infrastructure monitoring: Linux and Windows agents Mobile agents: iOS and Android Synthetic monitoring: Containerized private minions (CPM) The Diagnostics CLI does not require superuser or admin permissions to run, although we recommend those permissions for some checks. It will return an error if it does not have permissions to read the files it scans. Get started To use the Diagnostics CLI: Run the Diagnostics CLI, including task suites and command line options as needed. Supply the -attach flag for uploading results to your New Relic account. Optional: Validate your config file settings. Interpret the output. Like any other New Relic tool, the Diagnostics CLI service is designed to protect you and your customers' data privacy. For detailed information, see our Diagnostics CLI licensing and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.25827,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " are available. <em>Browser</em> <em>monitoring</em>: <em>Browser</em> agent detection Infrastructure <em>monitoring</em>: Linux and Windows agents Mobile agents: iOS and Android Synthetic <em>monitoring</em>: Containerized private minions (CPM) The Diagnostics CLI does not require superuser or admin permissions to run, although we recommend those"
      },
      "id": "604469f8e7b9d2abb65799f0"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "17c97a462616f2b23ead796b62780a1ffeb3dfac",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Agent version Your browser monitoring agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute browser API call To add a custom attribute to the PageView event via the browser agent, use the setCustomAttribute browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.90727,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>browser</em> <em>monitoring</em> custom events and attributes",
        "sections": "Report <em>browser</em> <em>monitoring</em> custom events and attributes",
        "body": " it to true. Python Add the <em>browser_monitoring</em>.attributes.enabled option and set it to true. Ruby Add the <em>browser_monitoring</em>.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see <em>Browser</em> events. <em>Troubleshooting</em> Here"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    }
  ],
  "/docs/browser/new-relic-browser/troubleshooting/troubleshooting-session-trace-collection": [
    {
      "sections": [
        "Introduction to browser monitoring",
        "More than Real User Monitoring (RUM)",
        "Examine user perceptions",
        "Improve interactive app performance",
        "Correlate front-end and back-end problems",
        "Get started with browser monitoring"
      ],
      "title": "Introduction to browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "4928b2a5981bd2d6263f04b4b882d65adef22779",
      "image": "https://docs.newrelic.com/static/98ad878ffa7b586b779178656f19ec58/c1b63/browser_intro_0.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/introduction-browser-monitoring/",
      "published_at": "2021-10-24T19:11:37Z",
      "updated_at": "2021-10-24T19:11:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your end-user experience depends on your entire technology stack. You need to quickly understand what's causing a customer complaint or issue. Did the problem come from your infrastructure, your application, or the browsers that ultimately render it? Is it the result of a problematic internet provider, a problem in your own data center with failing CPU or memory, or something else? More than Real User Monitoring (RUM) Many websites contain dynamic content that is loaded after the initial page has finished loading, and complex JavaScript code increases the need for error reporting. Browser monitoring in New Relic One provides a Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. With browser monitoring in New Relic One, you see actionable data about your end users' experience with your app. But browser monitoring in New Relic goes far beyond the initial page load to measure full page life cycle data. For example, our browser UI shows you: Actual performance data, such as by page view popularity and user satisfaction (Apdex) scores Perceived performance data that measures how quickly your async or dynamic visuals and interactive page contents display JavaScript error analytics, stack traces, and line-of-code visibility, to show you the end-user steps leading up to an error itself Session performance with a detailed timeline and heat map of the load and interaction events during a webpage's full life cycle AJAX requests indicating problems with timing, end points, and specific locations in the webpage Hash-based route changes in apps with single-page application (SPA) architectures These tools (and more!) help your teams optimize your end users' page load experience, eliminate bugs, and troubleshoot faster across your full stack. Examine user perceptions Real user data gives insights into actual page performance, but you also need to look into your users' perception of your site's performance. Pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser monitoring agent. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. Additional metrics include: First paint, first contentful paint, and largest contentful paint First input delay First interaction This helps you understand how users experience your site, both from visual and responsiveness standpoints. Improve interactive app performance Our single-page app (SPA) monitoring automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during browser interactions. You can also use our browser agent and SPA API to monitor virtually anything that executes inside the browser. If you are a developer, SPA monitoring can help you: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query and visualize the data to assist with business decisions. Bring better apps to the marketplace more quickly. Correlate front-end and back-end problems With New Relic One, you can instrument any type of data you need, such as metrics, events, logs, and traces. This helps you find actionable data about your end users' experience across the stack. For example: Type of data Comments Locations or domains Limit browser monitoring to focus on specific geographical locations or specific types of end-user activity. You can also monitor or block specific domains. Trends in interactions Use our comparative charting feature for a direct page load time comparison between real user (browser) interactions and trends appearing in Synthetic monitors. Distributed tracing Isolate latency from the web browser through back-end services with distributed tracing. The UI helps you see the connection across across a full transaction, from browser activity, to time spent in network, to back-end activity. Browser types Explore your end users' experience with your app segmented by any types of browsers they use, including: Top browsers by throughput Average page load time by platform type (mobile, desktop, and other) Selected browser type by version (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Get started with browser monitoring Follow these basic steps, and you'll quickly be up and running in New Relic with browser monitoring! Review the compatibility details and basic requirements for browser monitoring. Install the browser agent. Go to [one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. View summary data from your Browser summary page, then drill down into page load timing details and other UI data. Configure your alerts for key performance data, or use our Applied Intelligence solutions to reduce alert noise, correlate incidents, and automatically detect anomalies. Query and visualize your default data (or customize your own), then analyze what that data says about your business. Customize and share your own charts and dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.02957,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>browser</em> <em>monitoring</em>",
        "sections": "Introduction to <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " performance Our single-page app (SPA) <em>monitoring</em> automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during <em>browser</em> interactions. You can also use our <em>browser</em> agent and SPA API to <em>monitor</em> virtually anything that executes inside the <em>browser</em>. If you"
      },
      "id": "604429a9e7b9d2bde7579a04"
    },
    {
      "sections": [
        "Diagnostics CLI (nrdiag)",
        "Compatibility",
        "Get started"
      ],
      "title": "Diagnostics CLI (nrdiag)",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Diagnostics CLI (nrdiag)"
      ],
      "external_id": "973501f4752e56caf3d68e37bf21b823d0e42078",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/cross-product-functions/diagnostics-cli-nrdiag/diagnostics-cli-nrdiag/",
      "published_at": "2021-10-25T16:26:14Z",
      "updated_at": "2021-10-25T16:26:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Download latest version The Diagnostics CLI (nrdiag) is a utility that automatically detects common problems with New Relic products. If the Diagnostics CLI detects a problem, it suggests troubleshooting steps. The Diagnostics CLI can automatically upload troubleshooting data to a New Relic account. The Diagnostics CLI is open source and is located in GitHub. For additional troubleshooting steps for your agent, check out Not seeing data. Here's an example of the Diagnostics CLI running on Ubuntu Linux. The program checks your New Relic agent configurations for issues and generates zipped troubleshooting logs that are ready to be attached to support tickets. Compatibility The Diagnostics CLI is available for Linux, macOS, and Windows. It can detect common configuration issues for: APM: Available for all APM agents except C SDK. For the Go agent, only basic connectivity checks are available. Browser monitoring: Browser agent detection Infrastructure monitoring: Linux and Windows agents Mobile agents: iOS and Android Synthetic monitoring: Containerized private minions (CPM) The Diagnostics CLI does not require superuser or admin permissions to run, although we recommend those permissions for some checks. It will return an error if it does not have permissions to read the files it scans. Get started To use the Diagnostics CLI: Run the Diagnostics CLI, including task suites and command line options as needed. Supply the -attach flag for uploading results to your New Relic account. Optional: Validate your config file settings. Interpret the output. Like any other New Relic tool, the Diagnostics CLI service is designed to protect you and your customers' data privacy. For detailed information, see our Diagnostics CLI licensing and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.25827,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " are available. <em>Browser</em> <em>monitoring</em>: <em>Browser</em> agent detection Infrastructure <em>monitoring</em>: Linux and Windows agents Mobile agents: iOS and Android Synthetic <em>monitoring</em>: Containerized private minions (CPM) The Diagnostics CLI does not require superuser or admin permissions to run, although we recommend those"
      },
      "id": "604469f8e7b9d2abb65799f0"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "17c97a462616f2b23ead796b62780a1ffeb3dfac",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Agent version Your browser monitoring agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute browser API call To add a custom attribute to the PageView event via the browser agent, use the setCustomAttribute browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.90727,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>browser</em> <em>monitoring</em> custom events and attributes",
        "sections": "Report <em>browser</em> <em>monitoring</em> custom events and attributes",
        "body": " it to true. Python Add the <em>browser_monitoring</em>.attributes.enabled option and set it to true. Ruby Add the <em>browser_monitoring</em>.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see <em>Browser</em> events. <em>Troubleshooting</em> Here"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    }
  ],
  "/docs/browser/new-relic-browser/troubleshooting/view-detailed-error-logs-browser": [
    {
      "sections": [
        "Introduction to browser monitoring",
        "More than Real User Monitoring (RUM)",
        "Examine user perceptions",
        "Improve interactive app performance",
        "Correlate front-end and back-end problems",
        "Get started with browser monitoring"
      ],
      "title": "Introduction to browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "4928b2a5981bd2d6263f04b4b882d65adef22779",
      "image": "https://docs.newrelic.com/static/98ad878ffa7b586b779178656f19ec58/c1b63/browser_intro_0.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/introduction-browser-monitoring/",
      "published_at": "2021-10-24T19:11:37Z",
      "updated_at": "2021-10-24T19:11:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your end-user experience depends on your entire technology stack. You need to quickly understand what's causing a customer complaint or issue. Did the problem come from your infrastructure, your application, or the browsers that ultimately render it? Is it the result of a problematic internet provider, a problem in your own data center with failing CPU or memory, or something else? More than Real User Monitoring (RUM) Many websites contain dynamic content that is loaded after the initial page has finished loading, and complex JavaScript code increases the need for error reporting. Browser monitoring in New Relic One provides a Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. With browser monitoring in New Relic One, you see actionable data about your end users' experience with your app. But browser monitoring in New Relic goes far beyond the initial page load to measure full page life cycle data. For example, our browser UI shows you: Actual performance data, such as by page view popularity and user satisfaction (Apdex) scores Perceived performance data that measures how quickly your async or dynamic visuals and interactive page contents display JavaScript error analytics, stack traces, and line-of-code visibility, to show you the end-user steps leading up to an error itself Session performance with a detailed timeline and heat map of the load and interaction events during a webpage's full life cycle AJAX requests indicating problems with timing, end points, and specific locations in the webpage Hash-based route changes in apps with single-page application (SPA) architectures These tools (and more!) help your teams optimize your end users' page load experience, eliminate bugs, and troubleshoot faster across your full stack. Examine user perceptions Real user data gives insights into actual page performance, but you also need to look into your users' perception of your site's performance. Pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser monitoring agent. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. Additional metrics include: First paint, first contentful paint, and largest contentful paint First input delay First interaction This helps you understand how users experience your site, both from visual and responsiveness standpoints. Improve interactive app performance Our single-page app (SPA) monitoring automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during browser interactions. You can also use our browser agent and SPA API to monitor virtually anything that executes inside the browser. If you are a developer, SPA monitoring can help you: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query and visualize the data to assist with business decisions. Bring better apps to the marketplace more quickly. Correlate front-end and back-end problems With New Relic One, you can instrument any type of data you need, such as metrics, events, logs, and traces. This helps you find actionable data about your end users' experience across the stack. For example: Type of data Comments Locations or domains Limit browser monitoring to focus on specific geographical locations or specific types of end-user activity. You can also monitor or block specific domains. Trends in interactions Use our comparative charting feature for a direct page load time comparison between real user (browser) interactions and trends appearing in Synthetic monitors. Distributed tracing Isolate latency from the web browser through back-end services with distributed tracing. The UI helps you see the connection across across a full transaction, from browser activity, to time spent in network, to back-end activity. Browser types Explore your end users' experience with your app segmented by any types of browsers they use, including: Top browsers by throughput Average page load time by platform type (mobile, desktop, and other) Selected browser type by version (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Get started with browser monitoring Follow these basic steps, and you'll quickly be up and running in New Relic with browser monitoring! Review the compatibility details and basic requirements for browser monitoring. Install the browser agent. Go to [one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. View summary data from your Browser summary page, then drill down into page load timing details and other UI data. Configure your alerts for key performance data, or use our Applied Intelligence solutions to reduce alert noise, correlate incidents, and automatically detect anomalies. Query and visualize your default data (or customize your own), then analyze what that data says about your business. Customize and share your own charts and dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.02957,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>browser</em> <em>monitoring</em>",
        "sections": "Introduction to <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " performance Our single-page app (SPA) <em>monitoring</em> automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during <em>browser</em> interactions. You can also use our <em>browser</em> agent and SPA API to <em>monitor</em> virtually anything that executes inside the <em>browser</em>. If you"
      },
      "id": "604429a9e7b9d2bde7579a04"
    },
    {
      "sections": [
        "Diagnostics CLI (nrdiag)",
        "Compatibility",
        "Get started"
      ],
      "title": "Diagnostics CLI (nrdiag)",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Diagnostics CLI (nrdiag)"
      ],
      "external_id": "973501f4752e56caf3d68e37bf21b823d0e42078",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/cross-product-functions/diagnostics-cli-nrdiag/diagnostics-cli-nrdiag/",
      "published_at": "2021-10-25T16:26:14Z",
      "updated_at": "2021-10-25T16:26:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Download latest version The Diagnostics CLI (nrdiag) is a utility that automatically detects common problems with New Relic products. If the Diagnostics CLI detects a problem, it suggests troubleshooting steps. The Diagnostics CLI can automatically upload troubleshooting data to a New Relic account. The Diagnostics CLI is open source and is located in GitHub. For additional troubleshooting steps for your agent, check out Not seeing data. Here's an example of the Diagnostics CLI running on Ubuntu Linux. The program checks your New Relic agent configurations for issues and generates zipped troubleshooting logs that are ready to be attached to support tickets. Compatibility The Diagnostics CLI is available for Linux, macOS, and Windows. It can detect common configuration issues for: APM: Available for all APM agents except C SDK. For the Go agent, only basic connectivity checks are available. Browser monitoring: Browser agent detection Infrastructure monitoring: Linux and Windows agents Mobile agents: iOS and Android Synthetic monitoring: Containerized private minions (CPM) The Diagnostics CLI does not require superuser or admin permissions to run, although we recommend those permissions for some checks. It will return an error if it does not have permissions to read the files it scans. Get started To use the Diagnostics CLI: Run the Diagnostics CLI, including task suites and command line options as needed. Supply the -attach flag for uploading results to your New Relic account. Optional: Validate your config file settings. Interpret the output. Like any other New Relic tool, the Diagnostics CLI service is designed to protect you and your customers' data privacy. For detailed information, see our Diagnostics CLI licensing and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.25827,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " are available. <em>Browser</em> <em>monitoring</em>: <em>Browser</em> agent detection Infrastructure <em>monitoring</em>: Linux and Windows agents Mobile agents: iOS and Android Synthetic <em>monitoring</em>: Containerized private minions (CPM) The Diagnostics CLI does not require superuser or admin permissions to run, although we recommend those"
      },
      "id": "604469f8e7b9d2abb65799f0"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "17c97a462616f2b23ead796b62780a1ffeb3dfac",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Agent version Your browser monitoring agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute browser API call To add a custom attribute to the PageView event via the browser agent, use the setCustomAttribute browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.90727,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>browser</em> <em>monitoring</em> custom events and attributes",
        "sections": "Report <em>browser</em> <em>monitoring</em> custom events and attributes",
        "body": " it to true. Python Add the <em>browser_monitoring</em>.attributes.enabled option and set it to true. Ruby Add the <em>browser_monitoring</em>.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see <em>Browser</em> events. <em>Troubleshooting</em> Here"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    }
  ],
  "/docs/browser/single-page-app-monitoring/get-started/install-single-page-app-monitoring": [
    {
      "sections": [
        "Introduction to Single Page App monitoring",
        "Enable SPA monitoring",
        "Analyze throughput and performance data",
        "Browser SPA features"
      ],
      "title": "Introduction to Single Page App monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Single page app monitoring",
        "Get started"
      ],
      "external_id": "6dedda52851e1ca1f180c8d88bdcb7038c4d1b5d",
      "image": "https://docs.newrelic.com/static/98d434a02c314f2bd2ce9828aa7b755d/c1b63/browser_SPA.png",
      "url": "https://docs.newrelic.com/docs/browser/single-page-app-monitoring/get-started/introduction-single-page-app-monitoring/",
      "published_at": "2021-10-24T14:57:43Z",
      "updated_at": "2021-07-21T20:07:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic browser monitoring has a single-page application (SPA) monitoring feature that provides deeper visibility and actionable insights into real user interactions with single-page apps, and for any app that uses AJAX requests. In addition to monitoring route changes automatically, our SPA API allows you to monitor virtually anything that executes inside the browser. This allows developers and their team to: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query your data to assist with business decisions. Bring better apps to the marketplace more quickly. Enable SPA monitoring SPA monitoring is enabled by default for new browser agent installations. The SPA-enabled version of the agent gives access to other powerful New Relic features, like distributed tracing. For more information, see Enable browser monitoring. For compatability information for SPA-related features, see SPA requirements. Analyze throughput and performance data Improving on traditional industry standards for measuring page load timing, we give you a complete picture of the activity, both synchronous and asynchronous, associated with page loads and route changes. one.newrelic.com > Browser > (select an app) > Page views: Use browser monitoring's SPA monitoring to examine the throughput and performance of your SPA-architecture app. SPA data monitored by browser monitoring includes: Performance data and throughput for page loads and route changes AJAX request data JavaScript activity, both synchronous and asynchronous Dynamic page updates, monitored using the SPA API With this data, you will gain a clear understanding of how your users experience your app's page loads and route changes, and be able to solve bottlenecks and troubleshoot errors. For more about how New Relic handles SPA data, see Understand SPA data collection. Browser SPA features Here is a summary of SPA monitoring features: Single-page app monitoring Take advantage of these features Robust views in browser's UI When a user initiates a page load or route change, New Relic begins to monitor all subsequent JavaScript, and ends the timing once all AJAX events are complete. This provides a more accurate view of when a page is actually ready for a user compared to the traditional method of ending the timing when the window load event is fired. When SPA monitoring is enabled, the Page views page in browser shows event-driven data about application usage levels (throughput) and user experience (performance), including: Charts with drill-down details about initial page load performance, route changes, and historical performance Sort, search, and filter options, including custom attributes Additional AJAX breakdown data for all initial page loads and route changes For an explanation of how SPA monitoring will impact your existing browser account's data usage, see SPA and browser data usage. Data analysis with data explorer The data explorer supports three SPA-specific event types: BrowserInteraction, AjaxRequest, and BrowserTiming. You can query these events in the query builder to analyze your app's performance and make business decisions. Customized data from API Use SPA API to obtain the specific data you need, such as custom naming, custom timing, finishline API, or other custom attributes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 195.36609,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Single</em> <em>Page</em> <em>App</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Single</em> <em>Page</em> <em>App</em> <em>monitoring</em>",
        "tags": "<em>Single</em> <em>page</em> <em>app</em> <em>monitoring</em>",
        "body": "New Relic <em>browser</em> <em>monitoring</em> has a <em>single</em>-<em>page</em> application (SPA) <em>monitoring</em> feature that provides deeper visibility and actionable insights into real user interactions with <em>single</em>-<em>page</em> apps, and for any <em>app</em> that uses AJAX requests. In addition to <em>monitoring</em> route changes automatically, our SPA API"
      },
      "id": "604408d328ccbcf69e2c6064"
    },
    {
      "sections": [
        "SPA compatibility and requirements",
        "Browser agent version",
        "Browser types",
        "Framework requirements",
        "Security when collecting hash fragments"
      ],
      "title": "SPA compatibility and requirements",
      "type": "docs",
      "tags": [
        "Browser",
        "Single page app monitoring",
        "Get started"
      ],
      "external_id": "17d916a952f7b86a1da190a9d7236072eff12361",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/single-page-app-monitoring/get-started/spa-compatibility-requirements/",
      "published_at": "2021-10-24T14:56:53Z",
      "updated_at": "2021-07-09T07:41:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In order to set up Single Page Application (SPA) monitoring for browser monitoring, make sure your app meets these SPA monitoring requirements. Browser agent version SPA monitoring requires an SPA-specific version of the browser snippet, available for browser agent version 885 or higher. To activate this snippet version for your application, enable your application for SPA monitoring. To check your version and integrate the updated snippet, follow the appropriate upgrade instructions. Browser types SPA monitoring requires the addEventListener browser API and the Navigation Timing API. Both APIs are available in all modern browsers, including Google Chrome, Mozilla Firefox, Apple Safari, and Microsoft Internet Explorer (IE) versions 9 or higher. Framework requirements Because SPA instrumentation works by wrapping low-level browser APIs, it is framework-agnostic. SPA instrumentation is compatible with most SPA frameworks, such as Angular, Backbone, Ember, and React. It can also instrument requests made using JSONP. Below are known compatibility issues: If your application uses AngularJS and you want to use browser's SPA monitoring capabilities, Zone.js versions 0.6.18-0.6.24 are not compatible with the SPA agent. The html2pdf.js library is not compatible with the SPA agent. Security when collecting hash fragments New Relic collects and saves hash fragments from route change URLs. If you use hashes to pass private or sensitive data, that data may be visible to your New Relic account users. Follow browser's guidelines for security with data collection and reporting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 193.41118,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Browser</em> agent version",
        "tags": "<em>Single</em> <em>page</em> <em>app</em> <em>monitoring</em>",
        "body": "In order to set up <em>Single</em> <em>Page</em> Application (SPA) <em>monitoring</em> for <em>browser</em> <em>monitoring</em>, make sure your <em>app</em> meets these SPA <em>monitoring</em> requirements. <em>Browser</em> agent version SPA <em>monitoring</em> requires an SPA-specific version of the <em>browser</em> snippet, available for <em>browser</em> agent version 885 or higher"
      },
      "id": "6044095ee7b9d20d555799f3"
    },
    {
      "sections": [
        "Introduction to browser monitoring",
        "More than Real User Monitoring (RUM)",
        "Examine user perceptions",
        "Improve interactive app performance",
        "Correlate front-end and back-end problems",
        "Get started with browser monitoring"
      ],
      "title": "Introduction to browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "4928b2a5981bd2d6263f04b4b882d65adef22779",
      "image": "https://docs.newrelic.com/static/98ad878ffa7b586b779178656f19ec58/c1b63/browser_intro_0.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/introduction-browser-monitoring/",
      "published_at": "2021-10-24T19:11:37Z",
      "updated_at": "2021-10-24T19:11:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your end-user experience depends on your entire technology stack. You need to quickly understand what's causing a customer complaint or issue. Did the problem come from your infrastructure, your application, or the browsers that ultimately render it? Is it the result of a problematic internet provider, a problem in your own data center with failing CPU or memory, or something else? More than Real User Monitoring (RUM) Many websites contain dynamic content that is loaded after the initial page has finished loading, and complex JavaScript code increases the need for error reporting. Browser monitoring in New Relic One provides a Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. With browser monitoring in New Relic One, you see actionable data about your end users' experience with your app. But browser monitoring in New Relic goes far beyond the initial page load to measure full page life cycle data. For example, our browser UI shows you: Actual performance data, such as by page view popularity and user satisfaction (Apdex) scores Perceived performance data that measures how quickly your async or dynamic visuals and interactive page contents display JavaScript error analytics, stack traces, and line-of-code visibility, to show you the end-user steps leading up to an error itself Session performance with a detailed timeline and heat map of the load and interaction events during a webpage's full life cycle AJAX requests indicating problems with timing, end points, and specific locations in the webpage Hash-based route changes in apps with single-page application (SPA) architectures These tools (and more!) help your teams optimize your end users' page load experience, eliminate bugs, and troubleshoot faster across your full stack. Examine user perceptions Real user data gives insights into actual page performance, but you also need to look into your users' perception of your site's performance. Pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser monitoring agent. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. Additional metrics include: First paint, first contentful paint, and largest contentful paint First input delay First interaction This helps you understand how users experience your site, both from visual and responsiveness standpoints. Improve interactive app performance Our single-page app (SPA) monitoring automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during browser interactions. You can also use our browser agent and SPA API to monitor virtually anything that executes inside the browser. If you are a developer, SPA monitoring can help you: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query and visualize the data to assist with business decisions. Bring better apps to the marketplace more quickly. Correlate front-end and back-end problems With New Relic One, you can instrument any type of data you need, such as metrics, events, logs, and traces. This helps you find actionable data about your end users' experience across the stack. For example: Type of data Comments Locations or domains Limit browser monitoring to focus on specific geographical locations or specific types of end-user activity. You can also monitor or block specific domains. Trends in interactions Use our comparative charting feature for a direct page load time comparison between real user (browser) interactions and trends appearing in Synthetic monitors. Distributed tracing Isolate latency from the web browser through back-end services with distributed tracing. The UI helps you see the connection across across a full transaction, from browser activity, to time spent in network, to back-end activity. Browser types Explore your end users' experience with your app segmented by any types of browsers they use, including: Top browsers by throughput Average page load time by platform type (mobile, desktop, and other) Selected browser type by version (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Get started with browser monitoring Follow these basic steps, and you'll quickly be up and running in New Relic with browser monitoring! Review the compatibility details and basic requirements for browser monitoring. Install the browser agent. Go to [one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. View summary data from your Browser summary page, then drill down into page load timing details and other UI data. Configure your alerts for key performance data, or use our Applied Intelligence solutions to reduce alert noise, correlate incidents, and automatically detect anomalies. Query and visualize your default data (or customize your own), then analyze what that data says about your business. Customize and share your own charts and dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.0541,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>browser</em> <em>monitoring</em>",
        "sections": "<em>Get</em> <em>started</em> with <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " performance Our <em>single</em>-<em>page</em> <em>app</em> (SPA) <em>monitoring</em> automatically tracks route changes, initial <em>page</em> loads, and synchronous and asynchronous activity during <em>browser</em> interactions. You can also use our <em>browser</em> agent and SPA API to <em>monitor</em> virtually anything that executes inside the <em>browser</em>. If you"
      },
      "id": "604429a9e7b9d2bde7579a04"
    }
  ],
  "/docs/browser/single-page-app-monitoring/get-started/introduction-single-page-app-monitoring": [
    {
      "sections": [
        "Install Single Page App monitoring",
        "Requirements",
        "Enable or disable SPA monitoring"
      ],
      "title": "Install Single Page App monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Single page app monitoring",
        "Get started"
      ],
      "external_id": "04501b8d90b2c9b3bf3fa29f1662596a1379e2b6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/single-page-app-monitoring/get-started/install-single-page-app-monitoring/",
      "published_at": "2021-10-24T14:56:12Z",
      "updated_at": "2021-07-27T14:14:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Single page app (SPA) monitoring comes with the default install of the browser agent. Requirements You can review compability and requirements for SPA monitoring here. When you set up your first monitored app in a New Relic account, you must agree to the Terms of Service. By agreeing to the terms, you authorize New Relic to collect hash fragments from URLs. You only need to select the checkbox option once for an account. Enable or disable SPA monitoring When you enable browser monitoring, SPA monitoring is included by default because it gives access to a range of our most recent features, including distributed tracing. Some older agent installations may need to be upgraded. Read more about browser agent types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 196.42955,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>Single</em> <em>Page</em> <em>App</em> <em>monitoring</em>",
        "sections": "Install <em>Single</em> <em>Page</em> <em>App</em> <em>monitoring</em>",
        "tags": "<em>Single</em> <em>page</em> <em>app</em> <em>monitoring</em>",
        "body": "<em>Single</em> <em>page</em> <em>app</em> (SPA) <em>monitoring</em> comes with the default install of the <em>browser</em> agent. Requirements You can review compability and requirements for SPA <em>monitoring</em> here. When you set up your first monitored <em>app</em> in a New Relic account, you must agree to the Terms of Service. By agreeing to the terms"
      },
      "id": "6043f16664441f56fa378eec"
    },
    {
      "sections": [
        "SPA compatibility and requirements",
        "Browser agent version",
        "Browser types",
        "Framework requirements",
        "Security when collecting hash fragments"
      ],
      "title": "SPA compatibility and requirements",
      "type": "docs",
      "tags": [
        "Browser",
        "Single page app monitoring",
        "Get started"
      ],
      "external_id": "17d916a952f7b86a1da190a9d7236072eff12361",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/single-page-app-monitoring/get-started/spa-compatibility-requirements/",
      "published_at": "2021-10-24T14:56:53Z",
      "updated_at": "2021-07-09T07:41:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In order to set up Single Page Application (SPA) monitoring for browser monitoring, make sure your app meets these SPA monitoring requirements. Browser agent version SPA monitoring requires an SPA-specific version of the browser snippet, available for browser agent version 885 or higher. To activate this snippet version for your application, enable your application for SPA monitoring. To check your version and integrate the updated snippet, follow the appropriate upgrade instructions. Browser types SPA monitoring requires the addEventListener browser API and the Navigation Timing API. Both APIs are available in all modern browsers, including Google Chrome, Mozilla Firefox, Apple Safari, and Microsoft Internet Explorer (IE) versions 9 or higher. Framework requirements Because SPA instrumentation works by wrapping low-level browser APIs, it is framework-agnostic. SPA instrumentation is compatible with most SPA frameworks, such as Angular, Backbone, Ember, and React. It can also instrument requests made using JSONP. Below are known compatibility issues: If your application uses AngularJS and you want to use browser's SPA monitoring capabilities, Zone.js versions 0.6.18-0.6.24 are not compatible with the SPA agent. The html2pdf.js library is not compatible with the SPA agent. Security when collecting hash fragments New Relic collects and saves hash fragments from route change URLs. If you use hashes to pass private or sensitive data, that data may be visible to your New Relic account users. Follow browser's guidelines for security with data collection and reporting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 193.41118,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Browser</em> agent version",
        "tags": "<em>Single</em> <em>page</em> <em>app</em> <em>monitoring</em>",
        "body": "In order to set up <em>Single</em> <em>Page</em> Application (SPA) <em>monitoring</em> for <em>browser</em> <em>monitoring</em>, make sure your <em>app</em> meets these SPA <em>monitoring</em> requirements. <em>Browser</em> agent version SPA <em>monitoring</em> requires an SPA-specific version of the <em>browser</em> snippet, available for <em>browser</em> agent version 885 or higher"
      },
      "id": "6044095ee7b9d20d555799f3"
    },
    {
      "sections": [
        "Introduction to browser monitoring",
        "More than Real User Monitoring (RUM)",
        "Examine user perceptions",
        "Improve interactive app performance",
        "Correlate front-end and back-end problems",
        "Get started with browser monitoring"
      ],
      "title": "Introduction to browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "4928b2a5981bd2d6263f04b4b882d65adef22779",
      "image": "https://docs.newrelic.com/static/98ad878ffa7b586b779178656f19ec58/c1b63/browser_intro_0.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/introduction-browser-monitoring/",
      "published_at": "2021-10-24T19:11:37Z",
      "updated_at": "2021-10-24T19:11:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your end-user experience depends on your entire technology stack. You need to quickly understand what's causing a customer complaint or issue. Did the problem come from your infrastructure, your application, or the browsers that ultimately render it? Is it the result of a problematic internet provider, a problem in your own data center with failing CPU or memory, or something else? More than Real User Monitoring (RUM) Many websites contain dynamic content that is loaded after the initial page has finished loading, and complex JavaScript code increases the need for error reporting. Browser monitoring in New Relic One provides a Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. With browser monitoring in New Relic One, you see actionable data about your end users' experience with your app. But browser monitoring in New Relic goes far beyond the initial page load to measure full page life cycle data. For example, our browser UI shows you: Actual performance data, such as by page view popularity and user satisfaction (Apdex) scores Perceived performance data that measures how quickly your async or dynamic visuals and interactive page contents display JavaScript error analytics, stack traces, and line-of-code visibility, to show you the end-user steps leading up to an error itself Session performance with a detailed timeline and heat map of the load and interaction events during a webpage's full life cycle AJAX requests indicating problems with timing, end points, and specific locations in the webpage Hash-based route changes in apps with single-page application (SPA) architectures These tools (and more!) help your teams optimize your end users' page load experience, eliminate bugs, and troubleshoot faster across your full stack. Examine user perceptions Real user data gives insights into actual page performance, but you also need to look into your users' perception of your site's performance. Pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser monitoring agent. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. Additional metrics include: First paint, first contentful paint, and largest contentful paint First input delay First interaction This helps you understand how users experience your site, both from visual and responsiveness standpoints. Improve interactive app performance Our single-page app (SPA) monitoring automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during browser interactions. You can also use our browser agent and SPA API to monitor virtually anything that executes inside the browser. If you are a developer, SPA monitoring can help you: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query and visualize the data to assist with business decisions. Bring better apps to the marketplace more quickly. Correlate front-end and back-end problems With New Relic One, you can instrument any type of data you need, such as metrics, events, logs, and traces. This helps you find actionable data about your end users' experience across the stack. For example: Type of data Comments Locations or domains Limit browser monitoring to focus on specific geographical locations or specific types of end-user activity. You can also monitor or block specific domains. Trends in interactions Use our comparative charting feature for a direct page load time comparison between real user (browser) interactions and trends appearing in Synthetic monitors. Distributed tracing Isolate latency from the web browser through back-end services with distributed tracing. The UI helps you see the connection across across a full transaction, from browser activity, to time spent in network, to back-end activity. Browser types Explore your end users' experience with your app segmented by any types of browsers they use, including: Top browsers by throughput Average page load time by platform type (mobile, desktop, and other) Selected browser type by version (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Get started with browser monitoring Follow these basic steps, and you'll quickly be up and running in New Relic with browser monitoring! Review the compatibility details and basic requirements for browser monitoring. Install the browser agent. Go to [one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. View summary data from your Browser summary page, then drill down into page load timing details and other UI data. Configure your alerts for key performance data, or use our Applied Intelligence solutions to reduce alert noise, correlate incidents, and automatically detect anomalies. Query and visualize your default data (or customize your own), then analyze what that data says about your business. Customize and share your own charts and dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.0541,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>browser</em> <em>monitoring</em>",
        "sections": "<em>Get</em> <em>started</em> with <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " performance Our <em>single</em>-<em>page</em> <em>app</em> (SPA) <em>monitoring</em> automatically tracks route changes, initial <em>page</em> loads, and synchronous and asynchronous activity during <em>browser</em> interactions. You can also use our <em>browser</em> agent and SPA API to <em>monitor</em> virtually anything that executes inside the <em>browser</em>. If you"
      },
      "id": "604429a9e7b9d2bde7579a04"
    }
  ],
  "/docs/browser/single-page-app-monitoring/get-started/spa-compatibility-requirements": [
    {
      "sections": [
        "Install Single Page App monitoring",
        "Requirements",
        "Enable or disable SPA monitoring"
      ],
      "title": "Install Single Page App monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Single page app monitoring",
        "Get started"
      ],
      "external_id": "04501b8d90b2c9b3bf3fa29f1662596a1379e2b6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/single-page-app-monitoring/get-started/install-single-page-app-monitoring/",
      "published_at": "2021-10-24T14:56:12Z",
      "updated_at": "2021-07-27T14:14:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Single page app (SPA) monitoring comes with the default install of the browser agent. Requirements You can review compability and requirements for SPA monitoring here. When you set up your first monitored app in a New Relic account, you must agree to the Terms of Service. By agreeing to the terms, you authorize New Relic to collect hash fragments from URLs. You only need to select the checkbox option once for an account. Enable or disable SPA monitoring When you enable browser monitoring, SPA monitoring is included by default because it gives access to a range of our most recent features, including distributed tracing. Some older agent installations may need to be upgraded. Read more about browser agent types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 196.42955,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>Single</em> <em>Page</em> <em>App</em> <em>monitoring</em>",
        "sections": "Install <em>Single</em> <em>Page</em> <em>App</em> <em>monitoring</em>",
        "tags": "<em>Single</em> <em>page</em> <em>app</em> <em>monitoring</em>",
        "body": "<em>Single</em> <em>page</em> <em>app</em> (SPA) <em>monitoring</em> comes with the default install of the <em>browser</em> agent. Requirements You can review compability and requirements for SPA <em>monitoring</em> here. When you set up your first monitored <em>app</em> in a New Relic account, you must agree to the Terms of Service. By agreeing to the terms"
      },
      "id": "6043f16664441f56fa378eec"
    },
    {
      "sections": [
        "Introduction to Single Page App monitoring",
        "Enable SPA monitoring",
        "Analyze throughput and performance data",
        "Browser SPA features"
      ],
      "title": "Introduction to Single Page App monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Single page app monitoring",
        "Get started"
      ],
      "external_id": "6dedda52851e1ca1f180c8d88bdcb7038c4d1b5d",
      "image": "https://docs.newrelic.com/static/98d434a02c314f2bd2ce9828aa7b755d/c1b63/browser_SPA.png",
      "url": "https://docs.newrelic.com/docs/browser/single-page-app-monitoring/get-started/introduction-single-page-app-monitoring/",
      "published_at": "2021-10-24T14:57:43Z",
      "updated_at": "2021-07-21T20:07:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic browser monitoring has a single-page application (SPA) monitoring feature that provides deeper visibility and actionable insights into real user interactions with single-page apps, and for any app that uses AJAX requests. In addition to monitoring route changes automatically, our SPA API allows you to monitor virtually anything that executes inside the browser. This allows developers and their team to: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query your data to assist with business decisions. Bring better apps to the marketplace more quickly. Enable SPA monitoring SPA monitoring is enabled by default for new browser agent installations. The SPA-enabled version of the agent gives access to other powerful New Relic features, like distributed tracing. For more information, see Enable browser monitoring. For compatability information for SPA-related features, see SPA requirements. Analyze throughput and performance data Improving on traditional industry standards for measuring page load timing, we give you a complete picture of the activity, both synchronous and asynchronous, associated with page loads and route changes. one.newrelic.com > Browser > (select an app) > Page views: Use browser monitoring's SPA monitoring to examine the throughput and performance of your SPA-architecture app. SPA data monitored by browser monitoring includes: Performance data and throughput for page loads and route changes AJAX request data JavaScript activity, both synchronous and asynchronous Dynamic page updates, monitored using the SPA API With this data, you will gain a clear understanding of how your users experience your app's page loads and route changes, and be able to solve bottlenecks and troubleshoot errors. For more about how New Relic handles SPA data, see Understand SPA data collection. Browser SPA features Here is a summary of SPA monitoring features: Single-page app monitoring Take advantage of these features Robust views in browser's UI When a user initiates a page load or route change, New Relic begins to monitor all subsequent JavaScript, and ends the timing once all AJAX events are complete. This provides a more accurate view of when a page is actually ready for a user compared to the traditional method of ending the timing when the window load event is fired. When SPA monitoring is enabled, the Page views page in browser shows event-driven data about application usage levels (throughput) and user experience (performance), including: Charts with drill-down details about initial page load performance, route changes, and historical performance Sort, search, and filter options, including custom attributes Additional AJAX breakdown data for all initial page loads and route changes For an explanation of how SPA monitoring will impact your existing browser account's data usage, see SPA and browser data usage. Data analysis with data explorer The data explorer supports three SPA-specific event types: BrowserInteraction, AjaxRequest, and BrowserTiming. You can query these events in the query builder to analyze your app's performance and make business decisions. Customized data from API Use SPA API to obtain the specific data you need, such as custom naming, custom timing, finishline API, or other custom attributes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 195.36609,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Single</em> <em>Page</em> <em>App</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Single</em> <em>Page</em> <em>App</em> <em>monitoring</em>",
        "tags": "<em>Single</em> <em>page</em> <em>app</em> <em>monitoring</em>",
        "body": "New Relic <em>browser</em> <em>monitoring</em> has a <em>single</em>-<em>page</em> application (SPA) <em>monitoring</em> feature that provides deeper visibility and actionable insights into real user interactions with <em>single</em>-<em>page</em> apps, and for any <em>app</em> that uses AJAX requests. In addition to <em>monitoring</em> route changes automatically, our SPA API"
      },
      "id": "604408d328ccbcf69e2c6064"
    },
    {
      "sections": [
        "Introduction to browser monitoring",
        "More than Real User Monitoring (RUM)",
        "Examine user perceptions",
        "Improve interactive app performance",
        "Correlate front-end and back-end problems",
        "Get started with browser monitoring"
      ],
      "title": "Introduction to browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "4928b2a5981bd2d6263f04b4b882d65adef22779",
      "image": "https://docs.newrelic.com/static/98ad878ffa7b586b779178656f19ec58/c1b63/browser_intro_0.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/introduction-browser-monitoring/",
      "published_at": "2021-10-24T19:11:37Z",
      "updated_at": "2021-10-24T19:11:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your end-user experience depends on your entire technology stack. You need to quickly understand what's causing a customer complaint or issue. Did the problem come from your infrastructure, your application, or the browsers that ultimately render it? Is it the result of a problematic internet provider, a problem in your own data center with failing CPU or memory, or something else? More than Real User Monitoring (RUM) Many websites contain dynamic content that is loaded after the initial page has finished loading, and complex JavaScript code increases the need for error reporting. Browser monitoring in New Relic One provides a Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. With browser monitoring in New Relic One, you see actionable data about your end users' experience with your app. But browser monitoring in New Relic goes far beyond the initial page load to measure full page life cycle data. For example, our browser UI shows you: Actual performance data, such as by page view popularity and user satisfaction (Apdex) scores Perceived performance data that measures how quickly your async or dynamic visuals and interactive page contents display JavaScript error analytics, stack traces, and line-of-code visibility, to show you the end-user steps leading up to an error itself Session performance with a detailed timeline and heat map of the load and interaction events during a webpage's full life cycle AJAX requests indicating problems with timing, end points, and specific locations in the webpage Hash-based route changes in apps with single-page application (SPA) architectures These tools (and more!) help your teams optimize your end users' page load experience, eliminate bugs, and troubleshoot faster across your full stack. Examine user perceptions Real user data gives insights into actual page performance, but you also need to look into your users' perception of your site's performance. Pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser monitoring agent. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. Additional metrics include: First paint, first contentful paint, and largest contentful paint First input delay First interaction This helps you understand how users experience your site, both from visual and responsiveness standpoints. Improve interactive app performance Our single-page app (SPA) monitoring automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during browser interactions. You can also use our browser agent and SPA API to monitor virtually anything that executes inside the browser. If you are a developer, SPA monitoring can help you: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query and visualize the data to assist with business decisions. Bring better apps to the marketplace more quickly. Correlate front-end and back-end problems With New Relic One, you can instrument any type of data you need, such as metrics, events, logs, and traces. This helps you find actionable data about your end users' experience across the stack. For example: Type of data Comments Locations or domains Limit browser monitoring to focus on specific geographical locations or specific types of end-user activity. You can also monitor or block specific domains. Trends in interactions Use our comparative charting feature for a direct page load time comparison between real user (browser) interactions and trends appearing in Synthetic monitors. Distributed tracing Isolate latency from the web browser through back-end services with distributed tracing. The UI helps you see the connection across across a full transaction, from browser activity, to time spent in network, to back-end activity. Browser types Explore your end users' experience with your app segmented by any types of browsers they use, including: Top browsers by throughput Average page load time by platform type (mobile, desktop, and other) Selected browser type by version (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Get started with browser monitoring Follow these basic steps, and you'll quickly be up and running in New Relic with browser monitoring! Review the compatibility details and basic requirements for browser monitoring. Install the browser agent. Go to [one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. View summary data from your Browser summary page, then drill down into page load timing details and other UI data. Configure your alerts for key performance data, or use our Applied Intelligence solutions to reduce alert noise, correlate incidents, and automatically detect anomalies. Query and visualize your default data (or customize your own), then analyze what that data says about your business. Customize and share your own charts and dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.05399,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>browser</em> <em>monitoring</em>",
        "sections": "<em>Get</em> <em>started</em> with <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " performance Our <em>single</em>-<em>page</em> <em>app</em> (SPA) <em>monitoring</em> automatically tracks route changes, initial <em>page</em> loads, and synchronous and asynchronous activity during <em>browser</em> interactions. You can also use our <em>browser</em> agent and SPA API to <em>monitor</em> virtually anything that executes inside the <em>browser</em>. If you"
      },
      "id": "604429a9e7b9d2bde7579a04"
    }
  ],
  "/docs/browser/single-page-app-monitoring/troubleshooting/missing-route-changes-spa-agent": [
    {
      "sections": [
        "Install Single Page App monitoring",
        "Requirements",
        "Enable or disable SPA monitoring"
      ],
      "title": "Install Single Page App monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Single page app monitoring",
        "Get started"
      ],
      "external_id": "04501b8d90b2c9b3bf3fa29f1662596a1379e2b6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/single-page-app-monitoring/get-started/install-single-page-app-monitoring/",
      "published_at": "2021-10-24T14:56:12Z",
      "updated_at": "2021-07-27T14:14:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Single page app (SPA) monitoring comes with the default install of the browser agent. Requirements You can review compability and requirements for SPA monitoring here. When you set up your first monitored app in a New Relic account, you must agree to the Terms of Service. By agreeing to the terms, you authorize New Relic to collect hash fragments from URLs. You only need to select the checkbox option once for an account. Enable or disable SPA monitoring When you enable browser monitoring, SPA monitoring is included by default because it gives access to a range of our most recent features, including distributed tracing. Some older agent installations may need to be upgraded. Read more about browser agent types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 156.69766,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>Single</em> <em>Page</em> <em>App</em> <em>monitoring</em>",
        "sections": "Install <em>Single</em> <em>Page</em> <em>App</em> <em>monitoring</em>",
        "tags": "<em>Single</em> <em>page</em> <em>app</em> <em>monitoring</em>",
        "body": "<em>Single</em> <em>page</em> <em>app</em> (SPA) <em>monitoring</em> comes with the default install of the <em>browser</em> agent. Requirements You can review compability and requirements for SPA <em>monitoring</em> here. When you set up your first monitored <em>app</em> in a New Relic account, you must agree to the Terms of Service. By agreeing to the terms"
      },
      "id": "6043f16664441f56fa378eec"
    },
    {
      "sections": [
        "Introduction to Single Page App monitoring",
        "Enable SPA monitoring",
        "Analyze throughput and performance data",
        "Browser SPA features"
      ],
      "title": "Introduction to Single Page App monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Single page app monitoring",
        "Get started"
      ],
      "external_id": "6dedda52851e1ca1f180c8d88bdcb7038c4d1b5d",
      "image": "https://docs.newrelic.com/static/98d434a02c314f2bd2ce9828aa7b755d/c1b63/browser_SPA.png",
      "url": "https://docs.newrelic.com/docs/browser/single-page-app-monitoring/get-started/introduction-single-page-app-monitoring/",
      "published_at": "2021-10-24T14:57:43Z",
      "updated_at": "2021-07-21T20:07:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic browser monitoring has a single-page application (SPA) monitoring feature that provides deeper visibility and actionable insights into real user interactions with single-page apps, and for any app that uses AJAX requests. In addition to monitoring route changes automatically, our SPA API allows you to monitor virtually anything that executes inside the browser. This allows developers and their team to: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query your data to assist with business decisions. Bring better apps to the marketplace more quickly. Enable SPA monitoring SPA monitoring is enabled by default for new browser agent installations. The SPA-enabled version of the agent gives access to other powerful New Relic features, like distributed tracing. For more information, see Enable browser monitoring. For compatability information for SPA-related features, see SPA requirements. Analyze throughput and performance data Improving on traditional industry standards for measuring page load timing, we give you a complete picture of the activity, both synchronous and asynchronous, associated with page loads and route changes. one.newrelic.com > Browser > (select an app) > Page views: Use browser monitoring's SPA monitoring to examine the throughput and performance of your SPA-architecture app. SPA data monitored by browser monitoring includes: Performance data and throughput for page loads and route changes AJAX request data JavaScript activity, both synchronous and asynchronous Dynamic page updates, monitored using the SPA API With this data, you will gain a clear understanding of how your users experience your app's page loads and route changes, and be able to solve bottlenecks and troubleshoot errors. For more about how New Relic handles SPA data, see Understand SPA data collection. Browser SPA features Here is a summary of SPA monitoring features: Single-page app monitoring Take advantage of these features Robust views in browser's UI When a user initiates a page load or route change, New Relic begins to monitor all subsequent JavaScript, and ends the timing once all AJAX events are complete. This provides a more accurate view of when a page is actually ready for a user compared to the traditional method of ending the timing when the window load event is fired. When SPA monitoring is enabled, the Page views page in browser shows event-driven data about application usage levels (throughput) and user experience (performance), including: Charts with drill-down details about initial page load performance, route changes, and historical performance Sort, search, and filter options, including custom attributes Additional AJAX breakdown data for all initial page loads and route changes For an explanation of how SPA monitoring will impact your existing browser account's data usage, see SPA and browser data usage. Data analysis with data explorer The data explorer supports three SPA-specific event types: BrowserInteraction, AjaxRequest, and BrowserTiming. You can query these events in the query builder to analyze your app's performance and make business decisions. Customized data from API Use SPA API to obtain the specific data you need, such as custom naming, custom timing, finishline API, or other custom attributes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 155.8493,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Single</em> <em>Page</em> <em>App</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Single</em> <em>Page</em> <em>App</em> <em>monitoring</em>",
        "tags": "<em>Single</em> <em>page</em> <em>app</em> <em>monitoring</em>",
        "body": " your <em>app</em>&#x27;s <em>page</em> loads and route changes, and be able to solve bottlenecks and <em>troubleshoot</em> errors. For more about how New Relic handles SPA data, see Understand SPA data collection. <em>Browser</em> SPA features Here is a summary of SPA <em>monitoring</em> features: <em>Single</em>-<em>page</em> <em>app</em> <em>monitoring</em> Take advantage"
      },
      "id": "604408d328ccbcf69e2c6064"
    },
    {
      "sections": [
        "SPA compatibility and requirements",
        "Browser agent version",
        "Browser types",
        "Framework requirements",
        "Security when collecting hash fragments"
      ],
      "title": "SPA compatibility and requirements",
      "type": "docs",
      "tags": [
        "Browser",
        "Single page app monitoring",
        "Get started"
      ],
      "external_id": "17d916a952f7b86a1da190a9d7236072eff12361",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/single-page-app-monitoring/get-started/spa-compatibility-requirements/",
      "published_at": "2021-10-24T14:56:53Z",
      "updated_at": "2021-07-09T07:41:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In order to set up Single Page Application (SPA) monitoring for browser monitoring, make sure your app meets these SPA monitoring requirements. Browser agent version SPA monitoring requires an SPA-specific version of the browser snippet, available for browser agent version 885 or higher. To activate this snippet version for your application, enable your application for SPA monitoring. To check your version and integrate the updated snippet, follow the appropriate upgrade instructions. Browser types SPA monitoring requires the addEventListener browser API and the Navigation Timing API. Both APIs are available in all modern browsers, including Google Chrome, Mozilla Firefox, Apple Safari, and Microsoft Internet Explorer (IE) versions 9 or higher. Framework requirements Because SPA instrumentation works by wrapping low-level browser APIs, it is framework-agnostic. SPA instrumentation is compatible with most SPA frameworks, such as Angular, Backbone, Ember, and React. It can also instrument requests made using JSONP. Below are known compatibility issues: If your application uses AngularJS and you want to use browser's SPA monitoring capabilities, Zone.js versions 0.6.18-0.6.24 are not compatible with the SPA agent. The html2pdf.js library is not compatible with the SPA agent. Security when collecting hash fragments New Relic collects and saves hash fragments from route change URLs. If you use hashes to pass private or sensitive data, that data may be visible to your New Relic account users. Follow browser's guidelines for security with data collection and reporting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.28983,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Browser</em> agent version",
        "tags": "<em>Single</em> <em>page</em> <em>app</em> <em>monitoring</em>",
        "body": "In order to set up <em>Single</em> <em>Page</em> Application (SPA) <em>monitoring</em> for <em>browser</em> <em>monitoring</em>, make sure your <em>app</em> meets these SPA <em>monitoring</em> requirements. <em>Browser</em> agent version SPA <em>monitoring</em> requires an SPA-specific version of the <em>browser</em> snippet, available for <em>browser</em> agent version 885 or higher"
      },
      "id": "6044095ee7b9d20d555799f3"
    }
  ],
  "/docs/browser/single-page-app-monitoring/use-spa-data/spa-data-collection": [
    {
      "sections": [
        "View SPA data in Browser UI",
        "Single-page app (SPA) data",
        "Filter SPA views",
        "Group SPA views",
        "SPA view details",
        "Initial page load performance details",
        "Route change performance details"
      ],
      "title": "View SPA data in Browser UI",
      "type": "docs",
      "tags": [
        "Browser",
        "Single page app monitoring",
        "Use SPA data"
      ],
      "external_id": "0ab30db71f34da6376ff5e71734292b247754ca4",
      "image": "https://docs.newrelic.com/static/04bcea9186a93fc786a6db3469765824/c1b63/spa_overview.png",
      "url": "https://docs.newrelic.com/docs/browser/single-page-app-monitoring/use-spa-data/view-spa-data-browser-ui/",
      "published_at": "2021-10-24T14:57:43Z",
      "updated_at": "2021-07-09T10:04:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have opted in to SPA (single-page app) monitoring, the browser Page views page will include data on SPA route changes and initial page loads. one.newrelic.com > Browser > (select an app) > Page views: When you opt in to SPA monitoring, the browser Page views page will display SPA data like route changes and associated asynchronous browser activity. Single-page app (SPA) data To view SPA data: Go to one.newrelic.com > Browser > (select an app) > Page views. Initial page loads and route changes are automatically grouped by browser interaction name. You can adjust this with your allow list settings for segments. If you set custom route names with the SPA API, the custom route names will be displayed. You can change how the page loads and route changes are grouped by using the Group page by dropdown. By default, the list of page loads and route changes displays the most time consuming views at the top of the list. You can also sort by average response time, median response time, and throughput per minute by using the Sort by dropdown. To search for specific views by grouped URL, type in the search bar below the Sort by dropdown. For example, to find URLs that represent your checkout page, search for checkout. The charts on the initial Page view page display: The five views with the slowest average response times The five views with the highest throughput To change the range of time being examined, use the time picker near the top of the page. (If you choose a time range more than eight days in the past, some filtering and grouping functionality won't be available.) Filter SPA views one.newrelic.com > Browser > (select an app) > Page views > Filter: Use the Filter to filter for route changes, initial page loads, and other attributes like location and browser type. To view only initial page loads or only route changes, use the Filter dropdown. For example, to view only route changes, select Filter > Route change. The filter also gives you the ability to filter by other attributes of page loads and route changes, such as app name, geographical location of the browser, and browser type. For example, to see only page loads and route changes that occurred on browsers in the city of Portland, Oregon, select Filter > City > Portland. Group SPA views You can use the Group page by dropdown to group the list of page views by any attribute. For example, if you want to compare the average response times by browser type, select Group page by > userAgent. The combination of filtering and grouping lets you quickly find very specific data. For example, to compare how a specific URL is loading on different browsers: From the Filter dropdown, select targetURL, then select the URL you want to study. From the Group page by dropdown, select userAgent. SPA view details one.newrelic.com > Browser > (select an app) > Page views > (select a view): Select a view from the list to see assorted details and breakdowns. Select an individual page load or route change to see details. Selecting either will provide a breakdown of where time was spent for a browser interaction, and display that data over a time series matching the window selected in the time picker. Every route change view can theoretically also be an initial page load. (For example, when a route change URL is sent to someone else and they load it, that will now be considered an initial page load to New Relic.) This is why the SPA view details page has charts for both initial page loads and route changes. This allows you to compare how a view performs as an initial page load to how its performance as a route change. There are three chart display options, selectable with the icons to the right of the Avg initial page load time chart title. The default display is the color-coded stacked area chart. You can also switch to a Histogram display or a percentile line graph. Also on the details page is a Throughput chart that combines initial page loads and route changes. The chart displays the 5 pages with the highest throughput, which are listed beneath the chart, and consolidates all other pages into Other. Here are details on the specific performance data displayed for both page loads and route changes: Initial page load performance details For initial page loads, the performance details include the average back end time, front end time, and the window onload event: Back end time includes network, web app time, and request queuing. Front end time includes DOM processing, page rendering, and the time to complete all XHRs. A horizontal red line shows when the window load event is fired. This corresponds to the traditional page load timing measured by the browser agent without SPA monitoring enabled. With SPA monitoring it is common to have a window load event before the front end time is complete. (For more about how SPA page load timing differs from traditional page load timing, see Understand SPA data collection.) Route change performance details For route changes, the performance chart displays JS duration and waiting time. JS Duration is the sum of all JavaScript execution time during the interaction, which is synchronous by definition. The remaining time is called Waiting time and is derived by subtracting JS duration from the total duration. The Historical performance and Breakdown details are similar for both page loads and route changes: Detail tab Comments Historical data The Historical performance tab displays throughput (views per minute) and response time charted against the same time period yesterday and last week. Breakdowns The Breakdowns tab lists the various components individually timed as part of an interaction. By default, all XHRs are captured and timed. You can also use the SPA API to include additional elements for a route change or page load.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.55078,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "View <em>SPA</em> <em>data</em> in <em>Browser</em> UI",
        "sections": "<em>Single</em>-<em>page</em> <em>app</em> (<em>SPA</em>) <em>data</em>",
        "tags": "<em>Single</em> <em>page</em> <em>app</em> <em>monitoring</em>",
        "body": "If you have opted in to <em>SPA</em> (<em>single</em>-<em>page</em> <em>app</em>) <em>monitoring</em>, the <em>browser</em> <em>Page</em> views <em>page</em> will include <em>data</em> on <em>SPA</em> route changes and initial <em>page</em> loads. one.newrelic.com &gt; <em>Browser</em> &gt; (select an <em>app</em>) &gt; <em>Page</em> views: When you opt in to <em>SPA</em> <em>monitoring</em>, the <em>browser</em> <em>Page</em> views <em>page</em> will display <em>SPA</em> <em>data</em> like"
      },
      "id": "60440de328ccbc26592c60be"
    },
    {
      "sections": [
        "Use SPA API"
      ],
      "title": "Use SPA API",
      "type": "docs",
      "tags": [
        "Browser",
        "Single page app monitoring",
        "Use SPA data"
      ],
      "external_id": "85ba9b61e8ba08112a3a276d186fbe7af894251d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/single-page-app-monitoring/use-spa-data/use-spa-api/",
      "published_at": "2021-10-24T14:57:43Z",
      "updated_at": "2021-03-11T07:35:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser's single-page application (SPA) monitoring includes an API to add custom monitoring of specific browser interactions. This is useful for monitoring interactions that New Relic does not record automatically because they do not result in route changes, such as a dynamically-updated widget. The SPA API also allows you to turn off default monitoring for interactions that you do not consider important enough to monitor. For more information about the SPA API, including specific API calls, see the Browser agent and SPA API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 206.27885,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Use</em> <em>SPA</em> API",
        "sections": "<em>Use</em> <em>SPA</em> API",
        "tags": "<em>Single</em> <em>page</em> <em>app</em> <em>monitoring</em>",
        "body": "<em>Browser</em>&#x27;s <em>single</em>-<em>page</em> application (<em>SPA</em>) <em>monitoring</em> includes an API to add custom <em>monitoring</em> of specific <em>browser</em> interactions. This is useful for <em>monitoring</em> interactions that New Relic does not record automatically because they do not result in route changes, such as a dynamically-updated widget"
      },
      "id": "60440de328ccbc04a23025de"
    },
    {
      "sections": [
        "Missing route changes with SPA agent",
        "Problem",
        "Solution",
        "Short term solutions",
        "Support",
        "Cause"
      ],
      "title": "Missing route changes with SPA agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Single page app monitoring",
        "Troubleshooting"
      ],
      "external_id": "9ca088a0459684464512ee51dfb7ffca22e26c14",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/single-page-app-monitoring/troubleshooting/missing-route-changes-spa-agent/",
      "published_at": "2021-10-24T14:56:53Z",
      "updated_at": "2021-08-20T21:36:39Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You are using the Pro + SPA agent, but you are not seeing all of the route change browser interactions you expect. We are aware that this can be frustrating. Our goal throughout 2021 is to reevaluate the SPA feature functionality, making it simpler and more reliable, starting with the methods we use to detect and capture route changes. Additionally, we plan to add new frameworks and use cases to our testing suite based on your feedback and examples. Likely this work will include new APIs as well as framework-specific plug-ins. Check our release notes for the latest updates. Solution Short term solutions To make sure all route changes are captured, you can use our SPA interaction() API. Using the interaction API will categorize the BrowserInteraction event (in the category attribute) as custom rather than a route change if no route change is in fact detected. If your framework is exposing events that represent router activity, you can use custom instrumentation in these events. Here is an example using our API with the Angular router: router.events.subscribe( (event: Event) => { if (event instanceof NavigationStart) { let i = newrelic.interaction() i.setName(event.url) i.save() } }); Copy In this example, the router object is an instance of the Angular router (from the @angular/router module). The setName call sets the name attribute of the BrowserInteraction event to the new URL, and the save call ensures that the interaction is captured. You will need to adapt this for the needs of your own application’s framework. If your framework does not provide routing events, then you can add this code in the event handler of the original interaction event such as click): myButton.addEventListener('click', function () { let i = newrelic.interaction() i.setName(‘new URL') i.save() }); Copy Recommendation: If you do not have access to router events nor the interaction event handler, implement this as soon as possible in code that you know is the result of a user interaction. An alternative to using the SPA API is to capture routes as PageAction events. PageAction events can be used to capture any custom data. We recommend this option as a fallback in case using the SPA interaction API does not work as expected, or to completely separate the custom instrumentation from built-in BrowserInteraction events. Both of these solutions can ensure these events are captured, either as a BrowserInteraction event or as a PageAction event. However, they will not address recording the correct duration and related AJAX calls. Support If this solution does not resolve your issue, please file a support ticket, and have the following information available: For situations where you are seeing most route changes, but none for a particular route change you expect, attempt to evaluate the difference in the implementation of the code for that particular route. Is there something non-standard or unique about that route that you could provide to our support team? Document the frameworks and any libraries that might be of interest. If this is a new problem, has anything changed in your environment that has led to these interactions suddenly not being tracked? Note the browser agent version you are using. If you are more than a few releases behind, we will recommend that you update to the latest release, as we may have already resolved a similar issue. Be aware that due to the complexity of diagnosing these issues, the team will likely need access to an environment and code that demonstrates the problem for testing and research. Cause The browser agent attempts to be framework agnostic, as well as support coding best practices. However, there are often edge cases that will be missed that lead to you not collecting the route changes you expect. The implementation is based on instrumenting most common asynchronous browser APIs. There are cases when a web application uses some asynchronous API or uses custom or third-party code that we do not instrument, and this can result in inaccurate or missed route changes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 161.70856,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Missing route changes with <em>SPA</em> agent",
        "sections": "Missing route changes with <em>SPA</em> agent",
        "tags": "<em>Single</em> <em>page</em> <em>app</em> <em>monitoring</em>",
        "body": " Short term solutions To make sure all route changes are captured, you can <em>use</em> our <em>SPA</em> interaction() API. Using the interaction API will categorize the <em>Browser</em>Interaction event (in the category attribute) as custom rather than a route change if no route change is in fact detected. If your framework"
      },
      "id": "603e937628ccbcd4efeba750"
    }
  ],
  "/docs/browser/single-page-app-monitoring/use-spa-data/use-spa-api": [
    {
      "sections": [
        "View SPA data in Browser UI",
        "Single-page app (SPA) data",
        "Filter SPA views",
        "Group SPA views",
        "SPA view details",
        "Initial page load performance details",
        "Route change performance details"
      ],
      "title": "View SPA data in Browser UI",
      "type": "docs",
      "tags": [
        "Browser",
        "Single page app monitoring",
        "Use SPA data"
      ],
      "external_id": "0ab30db71f34da6376ff5e71734292b247754ca4",
      "image": "https://docs.newrelic.com/static/04bcea9186a93fc786a6db3469765824/c1b63/spa_overview.png",
      "url": "https://docs.newrelic.com/docs/browser/single-page-app-monitoring/use-spa-data/view-spa-data-browser-ui/",
      "published_at": "2021-10-24T14:57:43Z",
      "updated_at": "2021-07-09T10:04:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have opted in to SPA (single-page app) monitoring, the browser Page views page will include data on SPA route changes and initial page loads. one.newrelic.com > Browser > (select an app) > Page views: When you opt in to SPA monitoring, the browser Page views page will display SPA data like route changes and associated asynchronous browser activity. Single-page app (SPA) data To view SPA data: Go to one.newrelic.com > Browser > (select an app) > Page views. Initial page loads and route changes are automatically grouped by browser interaction name. You can adjust this with your allow list settings for segments. If you set custom route names with the SPA API, the custom route names will be displayed. You can change how the page loads and route changes are grouped by using the Group page by dropdown. By default, the list of page loads and route changes displays the most time consuming views at the top of the list. You can also sort by average response time, median response time, and throughput per minute by using the Sort by dropdown. To search for specific views by grouped URL, type in the search bar below the Sort by dropdown. For example, to find URLs that represent your checkout page, search for checkout. The charts on the initial Page view page display: The five views with the slowest average response times The five views with the highest throughput To change the range of time being examined, use the time picker near the top of the page. (If you choose a time range more than eight days in the past, some filtering and grouping functionality won't be available.) Filter SPA views one.newrelic.com > Browser > (select an app) > Page views > Filter: Use the Filter to filter for route changes, initial page loads, and other attributes like location and browser type. To view only initial page loads or only route changes, use the Filter dropdown. For example, to view only route changes, select Filter > Route change. The filter also gives you the ability to filter by other attributes of page loads and route changes, such as app name, geographical location of the browser, and browser type. For example, to see only page loads and route changes that occurred on browsers in the city of Portland, Oregon, select Filter > City > Portland. Group SPA views You can use the Group page by dropdown to group the list of page views by any attribute. For example, if you want to compare the average response times by browser type, select Group page by > userAgent. The combination of filtering and grouping lets you quickly find very specific data. For example, to compare how a specific URL is loading on different browsers: From the Filter dropdown, select targetURL, then select the URL you want to study. From the Group page by dropdown, select userAgent. SPA view details one.newrelic.com > Browser > (select an app) > Page views > (select a view): Select a view from the list to see assorted details and breakdowns. Select an individual page load or route change to see details. Selecting either will provide a breakdown of where time was spent for a browser interaction, and display that data over a time series matching the window selected in the time picker. Every route change view can theoretically also be an initial page load. (For example, when a route change URL is sent to someone else and they load it, that will now be considered an initial page load to New Relic.) This is why the SPA view details page has charts for both initial page loads and route changes. This allows you to compare how a view performs as an initial page load to how its performance as a route change. There are three chart display options, selectable with the icons to the right of the Avg initial page load time chart title. The default display is the color-coded stacked area chart. You can also switch to a Histogram display or a percentile line graph. Also on the details page is a Throughput chart that combines initial page loads and route changes. The chart displays the 5 pages with the highest throughput, which are listed beneath the chart, and consolidates all other pages into Other. Here are details on the specific performance data displayed for both page loads and route changes: Initial page load performance details For initial page loads, the performance details include the average back end time, front end time, and the window onload event: Back end time includes network, web app time, and request queuing. Front end time includes DOM processing, page rendering, and the time to complete all XHRs. A horizontal red line shows when the window load event is fired. This corresponds to the traditional page load timing measured by the browser agent without SPA monitoring enabled. With SPA monitoring it is common to have a window load event before the front end time is complete. (For more about how SPA page load timing differs from traditional page load timing, see Understand SPA data collection.) Route change performance details For route changes, the performance chart displays JS duration and waiting time. JS Duration is the sum of all JavaScript execution time during the interaction, which is synchronous by definition. The remaining time is called Waiting time and is derived by subtracting JS duration from the total duration. The Historical performance and Breakdown details are similar for both page loads and route changes: Detail tab Comments Historical data The Historical performance tab displays throughput (views per minute) and response time charted against the same time period yesterday and last week. Breakdowns The Breakdowns tab lists the various components individually timed as part of an interaction. By default, all XHRs are captured and timed. You can also use the SPA API to include additional elements for a route change or page load.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.55078,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "View <em>SPA</em> <em>data</em> in <em>Browser</em> UI",
        "sections": "<em>Single</em>-<em>page</em> <em>app</em> (<em>SPA</em>) <em>data</em>",
        "tags": "<em>Single</em> <em>page</em> <em>app</em> <em>monitoring</em>",
        "body": "If you have opted in to <em>SPA</em> (<em>single</em>-<em>page</em> <em>app</em>) <em>monitoring</em>, the <em>browser</em> <em>Page</em> views <em>page</em> will include <em>data</em> on <em>SPA</em> route changes and initial <em>page</em> loads. one.newrelic.com &gt; <em>Browser</em> &gt; (select an <em>app</em>) &gt; <em>Page</em> views: When you opt in to <em>SPA</em> <em>monitoring</em>, the <em>browser</em> <em>Page</em> views <em>page</em> will display <em>SPA</em> <em>data</em> like"
      },
      "id": "60440de328ccbc26592c60be"
    },
    {
      "sections": [
        "SPA data collection",
        "Browser interactions",
        "Types of SPA data reporting",
        "Initial page loads",
        "Route changes",
        "Custom monitoring",
        "Difference from traditional page load timing",
        "Tip",
        "Timers",
        "Events and attributes"
      ],
      "title": "SPA data collection",
      "type": "docs",
      "tags": [
        "Browser",
        "Single page app monitoring",
        "Use SPA data"
      ],
      "external_id": "d42d239aca2ea13a37fd926dca3672fcf83d73dd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/single-page-app-monitoring/use-spa-data/spa-data-collection/",
      "published_at": "2021-10-24T20:13:14Z",
      "updated_at": "2021-07-09T08:08:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how browser collects and stores your asynchronous single page app (SPA) data. This will give you a better understanding of the SPA data you see in the browser UI. This will also help you more easily add custom monitoring with the SPA API. Browser interactions At the heart of SPA monitoring is the concept of the browser interaction. New Relic defines a browser interaction as anything that occurs in the app user's browser; for example: A user interaction that leads to a page load or route change A scheduled, dynamic update to an app's widget A browser interaction includes not just the initial triggering event, but also the activity caused by that event, such as AJAX requests and both synchronous and asynchronous JavaScript. By tracking not just the cause but also the effects of a browser interaction, we help you understand how users experience your application's views and route changes. All apps are different and have different monitoring needs. That's why we include default monitoring as well as the ability to set up custom monitoring for any browser interactions you choose. Types of SPA data reporting Three major categories of single page app data can be reported to New Relic: Initial page loads Route changes Custom browser interactions created via the SPA API Each of these creates a BrowserInteraction event. If one or more AJAX requests are part of an interaction, then associated AjaxRequest events are also created. These events and their attributes can be queried in the query builder. Initial page loads An initial page load is a traditional URL change, stemming from a complete load or reload of a URL. This is indicated in the browser when a page load event fires (the window.onload event). Initial page loads appear along with route changes in the browser UI. Route changes SPA users experience dynamic route changes in a similar way to page loads. Visitors to a site or app generally do not care how a new view was delivered; they simply know that when they perform an action, a new view appears. For this reason, we treat route changes in a similar way to page loads in the UI. In order to optimally monitor single page applications, we start monitoring many browser interactions that could theoretically lead to route changes. If these interactions do not lead to route changes, browser initiates monitoring but then discards them. If these interactions do lead to a route change, browser saves the interaction sequence as a BrowserInteraction event, including information about both synchronous and asynchronous activity. An interaction is considered a route change and saved as a BrowserInteraction event when one of the following occurs: The URL hash changes (usually using window.location.hash). A popstate event fires during a callback associated with an interaction. A pushState or replaceState API is called. Route changes appear along with initial page loads in the browser UI. We receive and save hash fragments from route change URLs. If you use hashes to pass private or sensitive data, that data may be visible to your New Relic account users. For more information about data collection and reporting, see Security for browser. Custom monitoring You can use the SPA API to set up custom monitoring of browser interactions that are not monitored by default. You can also use the API to disable default monitoring. Custom events are saved as BrowserInteraction events and have the following attributes: The category attribute will have the value Custom. The trigger attribute will have the value api. (This is the default value but can be changed with the API.) Difference from traditional page load timing To provide optimized data for single page app monitoring, we measure page load timing in a new way: by wrapping low level browser functions, both synchronous and asynchronous. This gives a fuller depiction of how long it takes to complete the changes required for a new view. This is different from the traditional method for page load timing. Traditional page load timing uses the firing of the window.onload event to determine when a page is loaded. This is not an optimal way to measure view change timing because web apps often have asynchronous code that runs for a significant amount of time after the window.onload event occurs. Tip Browser's standard, non-SPA Page views page displays different page load times than when SPA monitoring is enabled. Because SPA monitoring is measuring all asynchronous activity, the SPA load times will generally be longer than standard page load times. The traditional window.onload page load timing still appears on the SPA Page views page. When you select a specific page load event, Window onload appears as a red line in the page load time chart. You can also select Switch to standard page views to return to traditional load timing displays. Timers The agent monitors all asynchronous calls, including timers. Timers with durations shorter than one second are wrapped. Timers longer than one second are not wrapped because usually they are meant for non-web transactions, such as background work or polling that is unrelated to a user interaction. Events and attributes We save browser interactions that lead to route changes and page loads as BrowserInteraction events, and AJAX requests as AjaxRequest events. You can query these events in the query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.53822,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>SPA</em> <em>data</em> collection",
        "sections": "<em>SPA</em> <em>data</em> collection",
        "tags": "<em>Single</em> <em>page</em> <em>app</em> <em>monitoring</em>",
        "body": "This document explains how <em>browser</em> collects and stores your asynchronous <em>single</em> <em>page</em> <em>app</em> (<em>SPA</em>) <em>data</em>. This will give you a better understanding of the <em>SPA</em> <em>data</em> you see in the <em>browser</em> UI. This will also help you more easily add custom <em>monitoring</em> with the <em>SPA</em> API. <em>Browser</em> interactions At the heart"
      },
      "id": "60440d9b196a672eb1960f6d"
    },
    {
      "sections": [
        "Missing route changes with SPA agent",
        "Problem",
        "Solution",
        "Short term solutions",
        "Support",
        "Cause"
      ],
      "title": "Missing route changes with SPA agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Single page app monitoring",
        "Troubleshooting"
      ],
      "external_id": "9ca088a0459684464512ee51dfb7ffca22e26c14",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/single-page-app-monitoring/troubleshooting/missing-route-changes-spa-agent/",
      "published_at": "2021-10-24T14:56:53Z",
      "updated_at": "2021-08-20T21:36:39Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You are using the Pro + SPA agent, but you are not seeing all of the route change browser interactions you expect. We are aware that this can be frustrating. Our goal throughout 2021 is to reevaluate the SPA feature functionality, making it simpler and more reliable, starting with the methods we use to detect and capture route changes. Additionally, we plan to add new frameworks and use cases to our testing suite based on your feedback and examples. Likely this work will include new APIs as well as framework-specific plug-ins. Check our release notes for the latest updates. Solution Short term solutions To make sure all route changes are captured, you can use our SPA interaction() API. Using the interaction API will categorize the BrowserInteraction event (in the category attribute) as custom rather than a route change if no route change is in fact detected. If your framework is exposing events that represent router activity, you can use custom instrumentation in these events. Here is an example using our API with the Angular router: router.events.subscribe( (event: Event) => { if (event instanceof NavigationStart) { let i = newrelic.interaction() i.setName(event.url) i.save() } }); Copy In this example, the router object is an instance of the Angular router (from the @angular/router module). The setName call sets the name attribute of the BrowserInteraction event to the new URL, and the save call ensures that the interaction is captured. You will need to adapt this for the needs of your own application’s framework. If your framework does not provide routing events, then you can add this code in the event handler of the original interaction event such as click): myButton.addEventListener('click', function () { let i = newrelic.interaction() i.setName(‘new URL') i.save() }); Copy Recommendation: If you do not have access to router events nor the interaction event handler, implement this as soon as possible in code that you know is the result of a user interaction. An alternative to using the SPA API is to capture routes as PageAction events. PageAction events can be used to capture any custom data. We recommend this option as a fallback in case using the SPA interaction API does not work as expected, or to completely separate the custom instrumentation from built-in BrowserInteraction events. Both of these solutions can ensure these events are captured, either as a BrowserInteraction event or as a PageAction event. However, they will not address recording the correct duration and related AJAX calls. Support If this solution does not resolve your issue, please file a support ticket, and have the following information available: For situations where you are seeing most route changes, but none for a particular route change you expect, attempt to evaluate the difference in the implementation of the code for that particular route. Is there something non-standard or unique about that route that you could provide to our support team? Document the frameworks and any libraries that might be of interest. If this is a new problem, has anything changed in your environment that has led to these interactions suddenly not being tracked? Note the browser agent version you are using. If you are more than a few releases behind, we will recommend that you update to the latest release, as we may have already resolved a similar issue. Be aware that due to the complexity of diagnosing these issues, the team will likely need access to an environment and code that demonstrates the problem for testing and research. Cause The browser agent attempts to be framework agnostic, as well as support coding best practices. However, there are often edge cases that will be missed that lead to you not collecting the route changes you expect. The implementation is based on instrumenting most common asynchronous browser APIs. There are cases when a web application uses some asynchronous API or uses custom or third-party code that we do not instrument, and this can result in inaccurate or missed route changes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 161.70856,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Missing route changes with <em>SPA</em> agent",
        "sections": "Missing route changes with <em>SPA</em> agent",
        "tags": "<em>Single</em> <em>page</em> <em>app</em> <em>monitoring</em>",
        "body": " Short term solutions To make sure all route changes are captured, you can <em>use</em> our <em>SPA</em> interaction() API. Using the interaction API will categorize the <em>Browser</em>Interaction event (in the category attribute) as custom rather than a route change if no route change is in fact detected. If your framework"
      },
      "id": "603e937628ccbcd4efeba750"
    }
  ],
  "/docs/browser/single-page-app-monitoring/use-spa-data/view-spa-data-browser-ui": [
    {
      "sections": [
        "SPA data collection",
        "Browser interactions",
        "Types of SPA data reporting",
        "Initial page loads",
        "Route changes",
        "Custom monitoring",
        "Difference from traditional page load timing",
        "Tip",
        "Timers",
        "Events and attributes"
      ],
      "title": "SPA data collection",
      "type": "docs",
      "tags": [
        "Browser",
        "Single page app monitoring",
        "Use SPA data"
      ],
      "external_id": "d42d239aca2ea13a37fd926dca3672fcf83d73dd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/single-page-app-monitoring/use-spa-data/spa-data-collection/",
      "published_at": "2021-10-24T20:13:14Z",
      "updated_at": "2021-07-09T08:08:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how browser collects and stores your asynchronous single page app (SPA) data. This will give you a better understanding of the SPA data you see in the browser UI. This will also help you more easily add custom monitoring with the SPA API. Browser interactions At the heart of SPA monitoring is the concept of the browser interaction. New Relic defines a browser interaction as anything that occurs in the app user's browser; for example: A user interaction that leads to a page load or route change A scheduled, dynamic update to an app's widget A browser interaction includes not just the initial triggering event, but also the activity caused by that event, such as AJAX requests and both synchronous and asynchronous JavaScript. By tracking not just the cause but also the effects of a browser interaction, we help you understand how users experience your application's views and route changes. All apps are different and have different monitoring needs. That's why we include default monitoring as well as the ability to set up custom monitoring for any browser interactions you choose. Types of SPA data reporting Three major categories of single page app data can be reported to New Relic: Initial page loads Route changes Custom browser interactions created via the SPA API Each of these creates a BrowserInteraction event. If one or more AJAX requests are part of an interaction, then associated AjaxRequest events are also created. These events and their attributes can be queried in the query builder. Initial page loads An initial page load is a traditional URL change, stemming from a complete load or reload of a URL. This is indicated in the browser when a page load event fires (the window.onload event). Initial page loads appear along with route changes in the browser UI. Route changes SPA users experience dynamic route changes in a similar way to page loads. Visitors to a site or app generally do not care how a new view was delivered; they simply know that when they perform an action, a new view appears. For this reason, we treat route changes in a similar way to page loads in the UI. In order to optimally monitor single page applications, we start monitoring many browser interactions that could theoretically lead to route changes. If these interactions do not lead to route changes, browser initiates monitoring but then discards them. If these interactions do lead to a route change, browser saves the interaction sequence as a BrowserInteraction event, including information about both synchronous and asynchronous activity. An interaction is considered a route change and saved as a BrowserInteraction event when one of the following occurs: The URL hash changes (usually using window.location.hash). A popstate event fires during a callback associated with an interaction. A pushState or replaceState API is called. Route changes appear along with initial page loads in the browser UI. We receive and save hash fragments from route change URLs. If you use hashes to pass private or sensitive data, that data may be visible to your New Relic account users. For more information about data collection and reporting, see Security for browser. Custom monitoring You can use the SPA API to set up custom monitoring of browser interactions that are not monitored by default. You can also use the API to disable default monitoring. Custom events are saved as BrowserInteraction events and have the following attributes: The category attribute will have the value Custom. The trigger attribute will have the value api. (This is the default value but can be changed with the API.) Difference from traditional page load timing To provide optimized data for single page app monitoring, we measure page load timing in a new way: by wrapping low level browser functions, both synchronous and asynchronous. This gives a fuller depiction of how long it takes to complete the changes required for a new view. This is different from the traditional method for page load timing. Traditional page load timing uses the firing of the window.onload event to determine when a page is loaded. This is not an optimal way to measure view change timing because web apps often have asynchronous code that runs for a significant amount of time after the window.onload event occurs. Tip Browser's standard, non-SPA Page views page displays different page load times than when SPA monitoring is enabled. Because SPA monitoring is measuring all asynchronous activity, the SPA load times will generally be longer than standard page load times. The traditional window.onload page load timing still appears on the SPA Page views page. When you select a specific page load event, Window onload appears as a red line in the page load time chart. You can also select Switch to standard page views to return to traditional load timing displays. Timers The agent monitors all asynchronous calls, including timers. Timers with durations shorter than one second are wrapped. Timers longer than one second are not wrapped because usually they are meant for non-web transactions, such as background work or polling that is unrelated to a user interaction. Events and attributes We save browser interactions that lead to route changes and page loads as BrowserInteraction events, and AJAX requests as AjaxRequest events. You can query these events in the query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.53822,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>SPA</em> <em>data</em> collection",
        "sections": "<em>SPA</em> <em>data</em> collection",
        "tags": "<em>Single</em> <em>page</em> <em>app</em> <em>monitoring</em>",
        "body": "This document explains how <em>browser</em> collects and stores your asynchronous <em>single</em> <em>page</em> <em>app</em> (<em>SPA</em>) <em>data</em>. This will give you a better understanding of the <em>SPA</em> <em>data</em> you see in the <em>browser</em> UI. This will also help you more easily add custom <em>monitoring</em> with the <em>SPA</em> API. <em>Browser</em> interactions At the heart"
      },
      "id": "60440d9b196a672eb1960f6d"
    },
    {
      "sections": [
        "Use SPA API"
      ],
      "title": "Use SPA API",
      "type": "docs",
      "tags": [
        "Browser",
        "Single page app monitoring",
        "Use SPA data"
      ],
      "external_id": "85ba9b61e8ba08112a3a276d186fbe7af894251d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/single-page-app-monitoring/use-spa-data/use-spa-api/",
      "published_at": "2021-10-24T14:57:43Z",
      "updated_at": "2021-03-11T07:35:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser's single-page application (SPA) monitoring includes an API to add custom monitoring of specific browser interactions. This is useful for monitoring interactions that New Relic does not record automatically because they do not result in route changes, such as a dynamically-updated widget. The SPA API also allows you to turn off default monitoring for interactions that you do not consider important enough to monitor. For more information about the SPA API, including specific API calls, see the Browser agent and SPA API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 206.27885,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Use</em> <em>SPA</em> API",
        "sections": "<em>Use</em> <em>SPA</em> API",
        "tags": "<em>Single</em> <em>page</em> <em>app</em> <em>monitoring</em>",
        "body": "<em>Browser</em>&#x27;s <em>single</em>-<em>page</em> application (<em>SPA</em>) <em>monitoring</em> includes an API to add custom <em>monitoring</em> of specific <em>browser</em> interactions. This is useful for <em>monitoring</em> interactions that New Relic does not record automatically because they do not result in route changes, such as a dynamically-updated widget"
      },
      "id": "60440de328ccbc04a23025de"
    },
    {
      "sections": [
        "Missing route changes with SPA agent",
        "Problem",
        "Solution",
        "Short term solutions",
        "Support",
        "Cause"
      ],
      "title": "Missing route changes with SPA agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Single page app monitoring",
        "Troubleshooting"
      ],
      "external_id": "9ca088a0459684464512ee51dfb7ffca22e26c14",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/single-page-app-monitoring/troubleshooting/missing-route-changes-spa-agent/",
      "published_at": "2021-10-24T14:56:53Z",
      "updated_at": "2021-08-20T21:36:39Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You are using the Pro + SPA agent, but you are not seeing all of the route change browser interactions you expect. We are aware that this can be frustrating. Our goal throughout 2021 is to reevaluate the SPA feature functionality, making it simpler and more reliable, starting with the methods we use to detect and capture route changes. Additionally, we plan to add new frameworks and use cases to our testing suite based on your feedback and examples. Likely this work will include new APIs as well as framework-specific plug-ins. Check our release notes for the latest updates. Solution Short term solutions To make sure all route changes are captured, you can use our SPA interaction() API. Using the interaction API will categorize the BrowserInteraction event (in the category attribute) as custom rather than a route change if no route change is in fact detected. If your framework is exposing events that represent router activity, you can use custom instrumentation in these events. Here is an example using our API with the Angular router: router.events.subscribe( (event: Event) => { if (event instanceof NavigationStart) { let i = newrelic.interaction() i.setName(event.url) i.save() } }); Copy In this example, the router object is an instance of the Angular router (from the @angular/router module). The setName call sets the name attribute of the BrowserInteraction event to the new URL, and the save call ensures that the interaction is captured. You will need to adapt this for the needs of your own application’s framework. If your framework does not provide routing events, then you can add this code in the event handler of the original interaction event such as click): myButton.addEventListener('click', function () { let i = newrelic.interaction() i.setName(‘new URL') i.save() }); Copy Recommendation: If you do not have access to router events nor the interaction event handler, implement this as soon as possible in code that you know is the result of a user interaction. An alternative to using the SPA API is to capture routes as PageAction events. PageAction events can be used to capture any custom data. We recommend this option as a fallback in case using the SPA interaction API does not work as expected, or to completely separate the custom instrumentation from built-in BrowserInteraction events. Both of these solutions can ensure these events are captured, either as a BrowserInteraction event or as a PageAction event. However, they will not address recording the correct duration and related AJAX calls. Support If this solution does not resolve your issue, please file a support ticket, and have the following information available: For situations where you are seeing most route changes, but none for a particular route change you expect, attempt to evaluate the difference in the implementation of the code for that particular route. Is there something non-standard or unique about that route that you could provide to our support team? Document the frameworks and any libraries that might be of interest. If this is a new problem, has anything changed in your environment that has led to these interactions suddenly not being tracked? Note the browser agent version you are using. If you are more than a few releases behind, we will recommend that you update to the latest release, as we may have already resolved a similar issue. Be aware that due to the complexity of diagnosing these issues, the team will likely need access to an environment and code that demonstrates the problem for testing and research. Cause The browser agent attempts to be framework agnostic, as well as support coding best practices. However, there are often edge cases that will be missed that lead to you not collecting the route changes you expect. The implementation is based on instrumenting most common asynchronous browser APIs. There are cases when a web application uses some asynchronous API or uses custom or third-party code that we do not instrument, and this can result in inaccurate or missed route changes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 161.70856,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Missing route changes with <em>SPA</em> agent",
        "sections": "Missing route changes with <em>SPA</em> agent",
        "tags": "<em>Single</em> <em>page</em> <em>app</em> <em>monitoring</em>",
        "body": " Short term solutions To make sure all route changes are captured, you can <em>use</em> our <em>SPA</em> interaction() API. Using the interaction API will categorize the <em>Browser</em>Interaction event (in the category attribute) as custom rather than a route change if no route change is in fact detected. If your framework"
      },
      "id": "603e937628ccbcd4efeba750"
    }
  ],
  "/docs/codestream/codestream-integrations/msteams-integration": [
    {
      "image": "https://docs.newrelic.com/static/8945e0a9c512b8638ebf8165d47aee04/69902/QS-SignUp3.png",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/codestream-user-guide/",
      "sections": [
        "CodeStream user guide",
        "Quick Start",
        "1. Install the CodeStream extension in your IDE and sign up.",
        "2. Connect your tools",
        "3. Discuss any block of code, at any time",
        "4. Get feedback on your work in progress",
        "5. Create or review a pull request",
        "Help & Feedback"
      ],
      "published_at": "2021-10-24T21:19:37Z",
      "title": "CodeStream user guide",
      "updated_at": "2021-10-23T17:07:02Z",
      "type": "docs",
      "external_id": "fa9af0118a8872fea89fda91482c44fb69913ea2",
      "document_type": "page",
      "popularity": 1,
      "body": "Quick Start Use the navigation to the left to jump straight to any topic. Otherwise, read on to get started with CodeStream. 1. Install the CodeStream extension in your IDE and sign up. Install CodeStream for VS Code, Visual Studio or JetBrains. The CodeStream pane should automatically appear in the sidebar for VS Code, or in a tool window at the right side for a JetBrains IDE or Visual Studio. Click on \"Sign Up and Create a team\" if you are the first person from your team to join CodeStream, or paste in your invitation code if you were invited to a team already on CodeStream. Learn more about how to use CodeStream. 2. Connect your tools Create and review pull requests on GitHub, GitLab or Bitbucket. Create issues on Jira, Trello, and other issue trackers. Share code discussions on Slack or Microsoft Teams. CodeStream brings the tools you use every day together in your IDE. Click on your headshot at the top of the CodeStream pane and go to the Integrations page to get all of your tools connected. 3. Discuss any block of code, at any time Whether you're trying to understand someone else's code or getting help with some code you just wrote, just select the code and ask your question. Learn more about discussing code. 4. Get feedback on your work in progress Select \"Request Feedback\" from the \"+\" menu at any time in the development cycle, whether it’s a quick look over some work in progress (even uncommitted code!) or a formal review of a completed effort. Teammates can review your changes right in their IDE, with no need to switch branches or set aside their own work. Learn more about feedback requests. 5. Create or review a pull request Look for the Pull Requests section of the CodeStream sidebar to review an open pull request. Just click on a pull request (or load one from URL) to get a complete GitHub experience right in your IDE! Note that you can create a pull request in GitHub, GitLab or Bitbucket, but support for reviewing pull requests is currently only available for GitHub (cloud or Enterprise). Learn more about pull requests. Help & Feedback Report a bug or send a suggestion in GitHub issues. Contact us directly at support@codestream.com. Follow @teamcodestream for product updates and to share feedback and questions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1783.7969,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> user guide",
        "sections": "1. Install the <em>CodeStream</em> extension in your IDE <em>and</em> sign up.",
        "body": " about how to use <em>CodeStream</em>. 2. Connect your tools Create and review pull requests on GitHub, GitLab or Bitbucket. Create issues on Jira, Trello, and other issue trackers. Share <em>code</em> discussions on Slack or <em>Microsoft</em> <em>Teams</em>. <em>CodeStream</em> brings the tools you use every day together in your IDE. Click"
      },
      "id": "61744137e7b9d2428b13c6a0"
    },
    {
      "image": "https://docs.newrelic.com/static/5c1d085b14abf961ca66b96285f0c0fa/69902/QS-Integrations.png",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/install-codestream/",
      "sections": [
        "Install CodeStream",
        "Tip",
        "Install with Instant Observability (I/O)",
        "Connect your tools",
        "Discuss any block of code, at any time",
        "Get feedback on your work in progress",
        "Create or review a pull request",
        "Help & Feedback"
      ],
      "published_at": "2021-10-24T21:19:37Z",
      "title": "Install CodeStream",
      "updated_at": "2021-10-23T17:01:57Z",
      "type": "docs",
      "external_id": "5d431c8f9a2690b64d26ac9fc173b18085153aac",
      "document_type": "page",
      "popularity": 1,
      "body": "CodeStream is a developer collaboration platform that makes it easy to discuss and review code in a more natural and contextual way. Install CodeStream Install CodeStream for Visual Studio Code, Visual Studio or JetBrains. You can also install the CodeStream extension directly via your Visual Studio Code/Visual Studio's extensions or JetBrains plugins menus. Tip Once you've installed CodeStream, if you want to connect it to New Relic, you'll need your New Relic user key. Go here to learn more about finding or creating your user key. Install with Instant Observability (I/O) You can also install CodeStream via an Instant Observability (I/O) quickstart. Connect your tools Create and review pull requests on GitHub, GitLab or Bitbucket. Create issues on Jira, Trello, and other issue trackers. Share code discussions on Slack or Microsoft Teams. CodeStream brings the tools you use every day together in your IDE. Click on your headshot at the top of the CodeStream pane and go to the Integrations page to get all of your tools connected. Discuss any block of code, at any time Whether you're trying to understand someone else's code or getting help with some code you just wrote, just select the code and ask your question. Learn more about discussing code. Get feedback on your work in progress Select \"Request Feedback\" from the \"+\" menu at any time in the development cycle, whether it’s a quick look over some work in progress (even uncommitted code!) or a formal review of a completed effort. Teammates can review your changes right in their IDE, with no need to switch branches or set aside their own work. Learn more about feedback requests. Create or review a pull request Look for the Pull Requests section of the CodeStream sidebar to review an open pull request. Just click on a pull request (or load one from URL) to get a complete GitHub experience right in your IDE! Note that you can create a pull request in GitHub, GitLab or Bitbucket, but support for reviewing pull requests is currently only available for GitHub (cloud or Enterprise). Learn more about pull requests. Help & Feedback Report a bug or send a suggestion in GitHub issues. Contact us directly at support@codestream.com. Follow @teamcodestream for product updates and to share feedback and questions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1782.3682,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>CodeStream</em>",
        "sections": "Install <em>CodeStream</em>",
        "body": " install <em>CodeStream</em> via an Instant Observability (I&#x2F;O) quickstart. Connect your tools Create and review pull requests on GitHub, GitLab or Bitbucket. Create issues on Jira, Trello, and other issue trackers. Share <em>code</em> discussions on Slack or <em>Microsoft</em> <em>Teams</em>. <em>CodeStream</em> brings the tools you use every day"
      },
      "id": "6174400564441ff1025fd832"
    },
    {
      "sections": [
        "CodeStream licenses"
      ],
      "title": "CodeStream licenses",
      "type": "docs",
      "tags": [
        "Licenses",
        "Product or service licenses",
        "CodeStream"
      ],
      "external_id": "331f3d1cd0897f453f98bc054fda09a9ad2725c1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/codestream/codestream-licenses/",
      "published_at": "2021-10-24T17:53:35Z",
      "updated_at": "2021-10-23T17:05:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We love open-source software, and we use the following with CodeStream. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we've chosen to use. CodeStream license on GitHub CodeStream's third-party software notices on GitHub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 643.0548,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> licenses",
        "sections": "<em>CodeStream</em> licenses",
        "tags": "<em>CodeStream</em>",
        "body": "We love open-source software, and we use the following with <em>CodeStream</em>. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we&#x27;ve chosen to use. <em>CodeStream</em> license on GitHub <em>CodeStream</em>&#x27;s third-party software notices on GitHub"
      },
      "id": "617440e2196a677ea62f0193"
    }
  ],
  "/docs/codestream/codestream-integrations/notifications": [
    {
      "sections": [
        "Proactive Detection with Applied Intelligence",
        "Requirements",
        "Why it matters",
        "How it works",
        "Set up notifications for Proactive Detection",
        "Set up for Slack",
        "Tip",
        "Set up for webhooks",
        "Set up without notifications",
        "Mute notifications (Slack only)",
        "Use Proactive Detection Slack messages",
        "View overview of anomalies",
        "Anomaly visibility settings",
        "Query anomaly data",
        "Important",
        "Add anomalies as source in Incident Intelligence",
        "Webhook payload and examples",
        "JSON schema example",
        "Data limits"
      ],
      "title": "Proactive Detection with Applied Intelligence",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "53e01b53fc341ef1e89b96e7927b16de03e72358",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/proactive-detection-applied-intelligence/",
      "published_at": "2021-10-24T23:54:15Z",
      "updated_at": "2021-10-24T23:54:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With Applied Intelligence's Proactive Detection, anomalies from your APM-monitored applications are automatically surfaced in our activity streams and anomalies feed. Each anomaly can be clicked on to bring up an automatic analysis. You can have notifications for anomalies delivered in Slack, or you can set up a webhook to deliver messages when you need them. These events are available for querying, creating custom dashboards, and alerting. By creating a Proactive Detection configuration (a group of apps you’re interested in), you can then add this configuration as a source, and have anomalies automatically correlated with other data sources via Incident Intelligence. Requirements To use Proactive Detection, ensure you have: An APM agent installed for at least one applications. To receive notifications in Slack, you'll need to ask your IT administrator to install the New Relic application in your Slack workspace. For more on data limits, see Data limits. Why it matters With Proactive Detection, Applied Intelligence delivers insights about anomalies in your production system, along with an automatic analysis of the anomaly. It’s enabled automatically, at no additional cost. When an anomaly is detected, you can view it in the Applied Intelligence anomalies feed, or we'll send notifications directly to your Slack channel or a webhook. How it works Proactive Detection uses the following methods to detect anomalies in your app data: Proactive Detection monitors metric data reported by an APM agent, building a model of your typical application dynamics, and focuses on key golden signals: throughput, response time, and errors. If one of these golden signals shows anomalous behavior, the system flags it and tracks recovery to normal behavior. The system adapts to changes in your data, and continuously updates models based on new data. Automatically on: By default, Proactive Detection monitors all your APM applications, with no action required by you. When an anomaly is detected, it's automatically surfaced in various activity streams, the Applied Intelligence anomalies feed and is available for querying via NRQL. Receiving notifications: We send notifications when we detect anomalous changes in throughput, error rate, or response time. The notifications are sent to selected Slack channels, or sent via webhook. When the anomaly goes back to normal, a recovery message is sent. If you don't want to receive notifications, you still have access to the data via NRQL query. Anomaly analysis: For each anomaly, we provide a link in Slack to an analyze anomaly page. This page generates automatic insights into the anomaly. The page is also available from the anomalies tab, which lists recent anomalies. This page uses your existing APM and Proactive Detection data to provide explanations as to the cause of the anomaly. Activity stream: Inside various activity streams such as the New Relic One homepage, APM Summary page, Lookout and Explorer, you'll see relevant anomalies from your APM-monitored applications. Clicking on any of the anomaly events in the activity stream brings up the analysis page for that anomaly. Applications will not always generate anomalies, so it can be normal to not receive any detections. Set up notifications for Proactive Detection Proactive Detection is enabled automatically, at no additional cost. To receive notifications or to have a configuration (group of apps) that you can add as a source for Incident Intelligence, you will need to create a Proactive Detection configuration. You can create a configuration in the Proactive Detection UI: From one.newrelic.com, click Alerts & AI. Under Proactive Detection, click Settings. Click Add a configuration. Input the following information into the form: Choose a name for your configuration that helps you easily identify it from others in your account. Select an account. Select up to 1,000 applications. Note that certain applications with low throughput might not be good candidates for Proactive Detection, as they can be more sensitive to smaller amounts of data fluctuation. Optional: select the golden signals you'd like to monitor for anomalies. Optional: connect to Incident Intelligence. Set up for Slack To use Proactive Detection with Slack: Select Slack. Choose which Slack channel receives notifications. You can select any existing public or private channel. This prompts the workflow to add the Applied Intelligence Slack application to your selected channel. To create a new channel, do that directly in Slack first. Tip If you experience an error when assigning Slack channels, make sure that the New Relic AI Slack application has been added to your Slack workspace. Save the configuration. You can modify the applications for each configuration at any time by selecting the configuration in the configuration table. Set up for webhooks To use Proactive Detection with webhooks: Select Webhook. Input the following information into the form: Provide the webhook URL. Provide optional custom headers. Choose to edit the custom payload, or enable using the default payload. Save the configuration. You can modify the applications for each configuration at any time by selecting the configuration in the configuration table. Set up without notifications To use Proactive Detection when you don't need to receive notifications: Select No notifications. Save the configuration. You can modify the applications for each configuration at any time by selecting the configuration in the configuration table. Mute notifications (Slack only) In Slack, detections coming from specific applications can be muted temporarily or permanently. The entire channel can also be muted temporarily. This is useful in the case of an incident or when the channel should otherwise not be interrupted. To mute in Slack, select Mute this app’s warnings or Mute all warnings, then select the duration. We will resume sending notifications for any detections once the muting duration has completed. Muting an application permanently removes it from the configuration. To add it back in, go to one.newrelic.com, in the top nav click Alerts & AI, then click Proactive Detection, and select the configuration to edit. Muting Proactive Detection notifications does not affect alerts. Use Proactive Detection Slack messages Each anomaly message has several key pieces of information you can use to learn more about and start troubleshooting the potential issue: The application name and a link to more information about it in New Relic One. The metric experiencing an anomaly and a link to its details in New Relic One. A graph of the metric over time to provide a visual understanding of the anomaly’s behavior and degree. An Analyze button that navigates to an analysis page in Applied Intelligence that identifies key attributes that are unique to the anomaly, anomalies found upstream or downstream, and any other relevant signals. Once an anomaly has returned to normal, we send a recovery notification with the option to provide feedback. Your feedback provides our development team with input to help us improve detection quality. In the case of feedback provided on throughput anomalies, an evaluation is run each hour based on feedback to fit a more suitable model. If we helped you, you can select Yes or No. View overview of anomalies In addition to notifications for anomalies that give you information via Slack or webhook, you can view more information about the anomalies in your environment via the Anomalies tab on the Alerts & AI Overview page. That tab provides a list of all the recent anomalies from every configuration in the selected account, and you can select an anomaly for a detailed analysis. Anomaly visibility settings Anomalies are displayed in various New Relic activity streams and in the Applied Intelligence anomalies feed. You can customize what is displayed using the anomaly visibility settings (for example, hiding throughput anomalies on an activity stream but keeping them in the anomalies feed). To find these settings: from Alerts & AI, under Proactive Detection, click Settings. Notes on using these settings: These settings are applied at the user level. Changes you make won’t affect others users in your organization. Regardless of these settings, the anomalies are still reported and available for NRQL querying. Details on these UI sections: AI overview and anomalies tab: Use the AI overview and anomalies tab setting to hide anomalies from the AI overview and anomalies tab setting. Please note you also can use filters specific to these views as well. Global activity stream: Use the global activity stream section to customize what anomalies are shown in the various New Relic activity streams, including the New Relic One homepage, APM Summary, and Lookout. Anomaly types: Use the check boxes here to hide specific types of anomalies. For example uncheck Web throughput and Non-web throughput anomalies to hide these types of anomalies from both the activity streams and the AI overview and anomalies tab. (Note they are still reported and available for querying.) Query anomaly data You can use NRQL to query and chart your Proactive Detection data using the NrAiAnomaly event. For example: FROM NrAiAnomaly SELECT * Important This data has previously been attached to the ProactiveDetection event. That event will be deprecated on April 7, 2021. If you use ProactiveDetection in your custom charts, you should convert those queries to using NrAiAnomaly. Here are important attributes attached to this event: Attribute Description closeTime timestamp The time when the anomaly ended. Example: 1615304100000. configurationType string The type of configuration monitoring the event. If at least one configuration is monitoring the entity, this is set to configuration. Otherwise, it's set to automatic. entity.accountId number The New Relic account ID to which the entity belongs. entity.domain number The domain of the entity (currently only APM but will change with future functionality). entity.guid string The GUID of the entity. This is used to identify and retrieve data about the entity via NerdGraph. Identical to entityGuid. entityGuid string The GUID of the entity. This is used to identify and retrieve data about the entity via NerdGraph. Identical to entity.guid. entity.name string The name of the entity whose data was determined to be anomalous. Identical to entityName. Example: Laura's coffee service. entityName string The name of the entity whose data was determined to be anomalous. Identical to entity.name. entity.type string The type of entity (currently only APPLICATION but will change with future functionality). evaluationType string This is always anomaly. event string Indicates whether it's the beginning (open) or end (close) of the anomalous data. openTime timestamp The time when the anomaly opened. Example: 1615303740000. signalType string The type of data that was analyzed. For example, error_rate or response_time.non_web. timestamp timestamp The time at which the event was written. title string Description of the anomaly. Example: Error rate was much higher than normal. Add anomalies as source in Incident Intelligence By integrating Incident Intelligence with your Proactive Detection anomalies, you can get context and correlations. To learn about doing this in Incident Intelligence, see Configure sources. You can also select Connect to Incident Intelligence from inside of a configuration. Webhook payload and examples Proactive Detection sends the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Proactive Detection, use these examples of the webhook body format and JSON schema. Attribute Description category enum The category of data that was analyzed. Categories include web throughput, non-web throughput, web transactions, non-web transactions, and error class. data list The time series data leading up to the detection. data[].timestamp number The timestamp of the data point in milliseconds since the Unix epoch. Example: 1584366819000 data[].unit string The unit describing the value of the data point. Data units include count, milliseconds, and error_rate. data[].value number The value of the data point. Example: 1.52 detectionType enum The type of data that was analyzed. Types include latency, throughput, and error_rate. entity object The entity that reported the unusual data. entity.accountId number The ID for the entity's account. entity.domain enum The domain for the entity. Example: APM. entity.domainId string The id used to uniquely identify the entity within the domain. entity.guid string The guid used to uniquely identify the entity across all products. entity.name string The name of the entity. Example: Laura’s coffee service entity.link string A link to view the entity. Example: https://rpm.newrelic.com/accounts/YOUR_ACCOUNT_ID/applications/987654321” Copy severity enum A description of how unusual of a change occurred, including NORMAL, WARNING, or CRITICAL. version string Version used to describe the data being provided. Example: v1 JSON schema example Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). Template: { \"version\": \"{{version}}\", \"entity\": { \"type\": \"{{entity.type}}\", \"name\": \"{{entity.name}}\", \"link\": \"{{entity.link}}\", \"entityGuid\": \"{{entity.entityGuid}}\", \"domainId\": \"{{entity.domainId}}\", \"domain\": \"{{entity.domain}}\", \"accountId\": {{entity.accountId}} }, \"detectionType\": \"{{detectionType}}\", \"category\": \"{{category}}\", \"data\": [{{#each data}} { \"value\": {{value}}, \"unit\": \"{{unit}}\", \"timestamp\": {{timestamp}} } {{#unless @last}},{{/unless}} {{/each}}] } Copy Sample payload: { \"version\": \"v1\", \"entity\": { \"type\": \"APPLICATION\", \"name\": \"My Application\", \"link\": \"https://rpm.newrelic.com/accounts/ACCOUNT_ID/applications/123\", \"entityGuid\": \"foo\", \"domainId\": \"123\", \"domain\": \"APM\", \"accountId\": YOUR_ACCOUNT_ID }, \"detectionType\": \"metric\", \"category\": \"web throughput\", \"severity\": \"CRITICAL\", \"data\": [ { \"value\": 100, \"unit\": \"count\", \"timestamp\": 1584047560917 } , { \"value\": 99, \"unit\": \"count\", \"timestamp\": 1584047620917 } , { \"value\": 0, \"unit\": \"count\", \"timestamp\": 1584047680917 } ] } Copy Data limits In addition to requirements, data limits include: Monitored APM applications: limited to 1,000 per configuration Slack configurations: limited to 200 per account Webhook configurations: limited to 200 per account Configurations without notifications: limited to 200 per account",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 69.23857,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>notifications</em> for Proactive Detection",
        "body": "With Applied Intelligence&#x27;s Proactive Detection, anomalies from your APM-monitored applications are automatically surfaced in our activity streams and anomalies feed. Each anomaly can be clicked on to bring up an automatic analysis. You can have <em>notifications</em> for anomalies delivered in Slack"
      },
      "id": "603e9d68196a67dc21a83dd2"
    },
    {
      "sections": [
        "Manage alert notification channels",
        "Tip",
        "Reference for updating channels",
        "View email channels",
        "Add or update email channels",
        "Create more channels",
        "Add or remove policies assigned to a channel",
        "Assign a channel to a policy",
        "Change a channel's name",
        "Check for policies assigned to a user",
        "Check how many policies are assigned to a channel",
        "View assigned alert policies",
        "Delete a channel",
        "Basic process"
      ],
      "title": "Manage alert notification channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "521bed5aa6fdcea5c1cffd11d01e6dad19bc7c40",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/update-alert-notification-channels/",
      "published_at": "2021-10-24T19:55:45Z",
      "updated_at": "2021-09-08T15:38:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To keep alert notifications consistent with your business needs, manage your channels. When you make updates, you can rename a channel, add policies to an existing channel, create a new channel entirely, and more. Tip Your selected channel type determines the communication method that appears. For example, if your channel type is email, then the channel will include an email address value. For more information, see channel types. Reference for updating channels Here's a quick reference for updating channels which also includes links to more detailed information and procedures. View email channels Alerts automatically includes the email addresses for all users in the selected account as individual notification channels. If the account is a child account, the list shows only the users on the child account, not the users in the parent account. To view or search the list of user names and emails: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. In the search field, search for 'user'. Add or update email channels Users can't unsubscribe from email notifications. The account Owner or Admin must remove them from the policy's notification channel. To add or update account users as notification channels for a policy: Go to one.newrelic.com, in the top nav click Alerts & AI, click Policies, and then choose the policy you want to change. Optional: You can update notification channels for specific users. On the Notification channels page, select a user, select any policy subscription already associated with the user as applicable to view policy details. Click Notification channels, then follow standard procedures to add notification channels. Click Update policy. Create more channels To create a new notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. Click New notification channel. Add or remove policies assigned to a channel To add or remove policies assigned to a notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. Choose a channel, and then click Alert policies. From the selected policy, use the windows to select, remove, or clear all notification channels. Assign a channel to a policy To add a notification channel to one or more policies: Go to one.newrelic.com, in the top nav click Alerts & AI, click Policies. Choose a policy, click Notification channels, and then click Add notification channels. Choose a channel, and then click Update policy. Change a channel's name To rename an existing notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels, then choose a channel. From the Channel details, change the name (maximum 64 characters) based on the channel type if applicable, and then save. Check for policies assigned to a user To check whether an account user has any policies assigned: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. Optional: Search by \"user\" to browse users or a specific username or email. Choose the user, then click Alert policies. Check how many policies are assigned to a channel To check whether a notification channel has any policies assigned: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. View assigned alert policies To view the policies assigned to a notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels, choose a channel, and then click Alert policies. OR To view the notification channels assigned to a policy: Go to one.newrelic.com, in the top nav click Alerts & AI, click Policies, choose a policy, then click Notification channels. Delete a channel To delete a notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. In the list, click the Delete icon. Basic process Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels, then choose a channel. From the Channel details page, make any necessary changes, and then save. The user interface shows a Last modified time stamp for any changes to policies, including their conditions and notification channels.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 51.06097,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage alert <em>notification</em> channels",
        "sections": "Manage alert <em>notification</em> channels",
        "tags": "Alert <em>notifications</em>",
        "body": "To keep alert <em>notifications</em> consistent with your business needs, manage your channels. When you make updates, you can rename a channel, add policies to an existing channel, create a new channel entirely, and more. Tip Your selected channel type determines the communication method that appears"
      },
      "id": "603eca45e7b9d2d1d82a0806"
    },
    {
      "sections": [
        "Customize your webhook payload",
        "Define webhooks",
        "Webhook values",
        "Targets values",
        "Webhook format example",
        "JSON webhook example",
        "Important",
        "Form webhook example",
        "Plain text output",
        "Microsoft Teams example"
      ],
      "title": "Customize your webhook payload",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "771a90b704617dff744104e22f88a06da9bcae9b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/customize-your-webhook-payload/",
      "published_at": "2021-10-25T15:26:48Z",
      "updated_at": "2021-08-27T08:29:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use webhooks as your alerts notification channel, you can use the default values. You can also customize the payload in the POST message for further integration into your system. Define webhooks When defining JSON webhooks, use the format \"name\":\"value\",. For example: \"current_state\":\"acknowledged\", Copy When defining static webhook variables in a form payload, use the format name=\"value\". For example: current_state=\"acknowledged\" Copy Do not include any custom, self-signed SSL certificates in your webhook. Our agents enable SSL by default. Due to our security policy, custom SSL certificates will not be imported into our Trust store. Webhooks with the $METADATA variable for Synthetics multi-location failure conditions are currently not supported. Webhook values We support these default dynamic webhook values. For your convenience, they are listed in alphabetical order, but you can define your webhook values in any order. You may also add custom variables by using your own key/value pairs. Key Variable \"account_id\" $ACCOUNT_ID Possible values: New Relic account ID (string) \"account_name\" $ACCOUNT_NAME Possible values: New Relic account name (string) \"closed_violations_count_critical\" $CLOSED_VIOLATIONS_COUNT_CRITICAL \"closed_violations_count_warning\" $CLOSED_VIOLATIONS_COUNT_WARNING \"condition_id\" $CONDITION_ID \"condition_description\" $DESCRIPTION This includes the description field from the alert condition, if there is one. \"condition_name\" $CONDITION_NAME Possible values: (user-defined string) \"current_state\" $EVENT_STATE Possible values: [open|acknowledged|closed] \"details\" $EVENT_DETAILS \"duration\" $DURATION \"event_type\" $EVENT_TYPE Possible values: [INCIDENT] \"incident_acknowledge_url\" $INCIDENT_ACKNOWLEDGE_URL \"incident_id\" $INCIDENT_ID \"incident_url\" $INCIDENT_URL \"metadata\" $METADATA Currently used only for Synthetic monitoring multi-location failure conditions. \"open_violations_count_critical\" $OPEN_VIOLATIONS_COUNT_CRITICAL \"open_violations_count_warning\" $OPEN_VIOLATIONS_COUNT_WARNING \"owner\" $EVENT_OWNER \"policy_name\" $POLICY_NAME Possible values: (user-defined string) \"policy_url\" $POLICY_URL \"runbook_url\" $RUNBOOK_URL \"severity\" $SEVERITY Possible values: [CRITICAL] \"targets\" $TARGETS The $TARGETS variable cannot be used with FORM data, but is compatible with JSON data. For static NRQL faceted alerts, the name of the facet that triggered the alert will be populated in the target’s name field. For a description of the available fields, see Target values. \"timestamp\" $TIMESTAMP \"timestamp_utc_string\" $TIMESTAMP_UTC_STRING A human-readable timestamp in the YYYY-MM-DD, HH:MM UTC format. \"version\" $VERSION \"violation_callback_url\" $VIOLATION_CALLBACK_URL \"violation_chart_url\" $VIOLATION_CHART_URL Targets values This section describes the $TARGETS field in your webhook. This data is not customizable and is provided here for reference. Your $TARGETS contain a list of zero or more targets (entities). Each target is described by a JSON object with the following fields. Key Variable \"id\" ID of the target or entity \"name\" Name of the target or entity \"labels\" Combined entity tags and NRQL facets that are derived from the condition evaluation and available entity tags. \"link\" URL link to this target or entity. \"product\" Type of product for this target or entity; for example, APM \"type\" Type of target or entity under product; for example, Application Webhook format example The following examples show a webhook payload using both the default dynamic variables and a custom variable. You can use some or all of the dynamic variables, along with any custom variables, to define your own payload. JSON webhook example Important The following webhook example has extra spaces and line breaks for readability. Actual webhook responses are delivered as one continuous line of text. The \"team\": \"DevOps\" line is an example of a custom variable. { \"account_id\": \"$ACCOUNT_ID\", \"account_name\": \"$ACCOUNT_NAME\", \"closed_violations_count_critical\": \"$CLOSED_VIOLATIONS_COUNT_CRITICAL\", \"closed_violations_count_warning\": \"$CLOSED_VIOLATIONS_COUNT_WARNING\", \"condition_family_id\": \"$CONDITION_FAMILY_ID\", \"condition_id\": \"$CONDITION_ID\", \"condition_name\": \"$CONDITION_NAME\", \"current_state\": \"$EVENT_STATE\", \"details\": \"$EVENT_DETAILS\", \"duration\": \"$DURATION\", \"event_type\": \"$EVENT_TYPE\", \"incident_acknowledge_url\": \"$INCIDENT_ACKNOWLEDGE_URL\", \"incident_id\": \"$INCIDENT_ID\", \"incident_url\": \"$INCIDENT_URL\", \"open_violations_count_critical\": \"$OPEN_VIOLATIONS_COUNT_CRITICAL\", \"open_violations_count_warning\": \"$OPEN_VIOLATIONS_COUNT_WARNING\", \"owner\": \"$EVENT_OWNER\", \"policy_name\": \"$POLICY_NAME\", \"policy_url\": \"$POLICY_URL\", \"runbook_url\": \"$RUNBOOK_URL\", \"severity\": \"$SEVERITY\", \"targets\": \"$TARGETS\", \"timestamp\": \"$TIMESTAMP\", \"timestamp_utc_string\": \"$TIMESTAMP_UTC_STRING\", \"violation_callback_url\": \"$VIOLATION_CALLBACK_URL\", \"violation_chart_url\": \"$VIOLATION_CHART_URL\", \"team\": \"DevOps\" } Copy Form webhook example Important The following webhook example has extra spaces and line breaks for readability. Actual webhook responses are delivered as one continuous line of text. account_id=$ACCOUNT_ID account_name=$ACCOUNT_NAME closed_violations_count_critical=$CLOSED_VIOLATIONS_COUNT_CRITICAL closed_violations_count_warning=$CLOSED_VIOLATIONS_COUNT_WARNING condition_family_id=$CONDITION_FAMILY_ID condition_id=$CONDITION_ID condition_name=$CONDITION_NAME current_state=$EVENT_STATE details=$EVENT_DETAILS duration=$DURATION event_type=$EVENT_TYPE incident_acknowledge_url=$INCIDENT_ACKNOWLEDGE_URL incident_id=$INCIDENT_ID incident_url=$INCIDENT_URL open_violations_count_critical=$OPEN_VIOLATIONS_COUNT_CRITICAL open_violations_count_warning=$OPEN_VIOLATIONS_COUNT_WARNING owner=$EVENT_OWNER policy_name=$POLICY_NAME policy_url=$POLICY_URL runbook_url=$RUNBOOK_URL severity=$SEVERITY timestamp=$TIMESTAMP timestamp_utc_string=$TIMESTAMP_UTC_STRING violation_callback_url=$VIOLATION_CALLBACK_URL violation_chart_url=$VIOLATION_CHART_URL team=\"DevOps\" <--[example of custom variable] Copy Plain text output New Relic Alert Incident open: CPU > 50% for 5 minutes Policy: http://alerts.newrelic.com/accounts/1234/policies/5678 Chart URL: http://gorgon.nr-assets.net/image/12345678-abcd-efgh-ijkl-1234567890 For more details, see: http://alerts.newrelic.com/accounts/1234/incidents/3456 Copy Microsoft Teams example { \"@type\": \"MessageCard\", \"@context\": \"http://schema.org/extensions\", \"themeColor\": \"0076D7\", \"summary\": \"$CONDITION_NAME\", \"sections\": [{ \"activityTitle\": \"$CONDITION_NAME\", \"activitySubtitle\": \"$POLICY_NAME\", \"activityImage\": \"https://newrelic.com/themes/custom/curio/assets/mediakit/NR_logo_Horizontal_Rev.png\", \"facts\": [{ \"name\": \"Timestamp\", \"value\": \"$TIMESTAMP_UTC_STRING\" }, { \"name\": \"Account ID\", \"value\": \"$ACCOUNT_ID\" }, { \"name\": \"Account Name\", \"value\": \"$ACCOUNT_NAME\" }, { \"name\": \"Severity\", \"value\": \"$SEVERITY\" }, { \"name\": \"State\", \"value\": \"$EVENT_STATE\" }, { \"name\": \"Duration\", \"value\": \"$DURATION\" }, { \"name\": \"Details\", \"value\": \"$EVENT_DETAILS\" }], \"markdown\": true }, { \"text\": \"$METADATA<p><img src=\\\"$VIOLATION_CHART_URL\\\" alt=\\\"Incident Chart\\\"></img></p>\" }], \"potentialAction\": [{ \"@type\": \"OpenUri\", \"name\": \"View Incident\", \"targets\": [{ \"os\": \"default\", \"uri\": \"$INCIDENT_URL\" }] }, { \"@type\": \"OpenUri\", \"name\": \"Acknowledge Incident\", \"targets\": [{ \"os\": \"default\", \"uri\": \"$INCIDENT_ACKNOWLEDGE_URL\" }] }, { \"@type\": \"OpenUri\", \"name\": \"Open Runbook\", \"targets\": [{ \"os\": \"default\", \"uri\": \"$RUNBOOK_URL\" }] }] } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 49.58272,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "Alert <em>notifications</em>"
      },
      "id": "6128a26a196a671aa500b327"
    }
  ],
  "/docs/codestream/codestream-integrations/slack-integration": [
    {
      "image": "https://docs.newrelic.com/static/8945e0a9c512b8638ebf8165d47aee04/69902/QS-SignUp3.png",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/codestream-user-guide/",
      "sections": [
        "CodeStream user guide",
        "Quick Start",
        "1. Install the CodeStream extension in your IDE and sign up.",
        "2. Connect your tools",
        "3. Discuss any block of code, at any time",
        "4. Get feedback on your work in progress",
        "5. Create or review a pull request",
        "Help & Feedback"
      ],
      "published_at": "2021-10-24T21:19:37Z",
      "title": "CodeStream user guide",
      "updated_at": "2021-10-23T17:07:02Z",
      "type": "docs",
      "external_id": "fa9af0118a8872fea89fda91482c44fb69913ea2",
      "document_type": "page",
      "popularity": 1,
      "body": "Quick Start Use the navigation to the left to jump straight to any topic. Otherwise, read on to get started with CodeStream. 1. Install the CodeStream extension in your IDE and sign up. Install CodeStream for VS Code, Visual Studio or JetBrains. The CodeStream pane should automatically appear in the sidebar for VS Code, or in a tool window at the right side for a JetBrains IDE or Visual Studio. Click on \"Sign Up and Create a team\" if you are the first person from your team to join CodeStream, or paste in your invitation code if you were invited to a team already on CodeStream. Learn more about how to use CodeStream. 2. Connect your tools Create and review pull requests on GitHub, GitLab or Bitbucket. Create issues on Jira, Trello, and other issue trackers. Share code discussions on Slack or Microsoft Teams. CodeStream brings the tools you use every day together in your IDE. Click on your headshot at the top of the CodeStream pane and go to the Integrations page to get all of your tools connected. 3. Discuss any block of code, at any time Whether you're trying to understand someone else's code or getting help with some code you just wrote, just select the code and ask your question. Learn more about discussing code. 4. Get feedback on your work in progress Select \"Request Feedback\" from the \"+\" menu at any time in the development cycle, whether it’s a quick look over some work in progress (even uncommitted code!) or a formal review of a completed effort. Teammates can review your changes right in their IDE, with no need to switch branches or set aside their own work. Learn more about feedback requests. 5. Create or review a pull request Look for the Pull Requests section of the CodeStream sidebar to review an open pull request. Just click on a pull request (or load one from URL) to get a complete GitHub experience right in your IDE! Note that you can create a pull request in GitHub, GitLab or Bitbucket, but support for reviewing pull requests is currently only available for GitHub (cloud or Enterprise). Learn more about pull requests. Help & Feedback Report a bug or send a suggestion in GitHub issues. Contact us directly at support@codestream.com. Follow @teamcodestream for product updates and to share feedback and questions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 772.67737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> user guide",
        "sections": "1. Install the <em>CodeStream</em> extension in your IDE <em>and</em> sign up.",
        "body": " about how to use <em>CodeStream</em>. 2. Connect your tools Create and review pull requests on GitHub, GitLab or Bitbucket. Create issues on Jira, Trello, and other issue trackers. Share <em>code</em> discussions on <em>Slack</em> or Microsoft Teams. <em>CodeStream</em> brings the tools you use every day together in your IDE. Click"
      },
      "id": "61744137e7b9d2428b13c6a0"
    },
    {
      "image": "https://docs.newrelic.com/static/5c1d085b14abf961ca66b96285f0c0fa/69902/QS-Integrations.png",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/install-codestream/",
      "sections": [
        "Install CodeStream",
        "Tip",
        "Install with Instant Observability (I/O)",
        "Connect your tools",
        "Discuss any block of code, at any time",
        "Get feedback on your work in progress",
        "Create or review a pull request",
        "Help & Feedback"
      ],
      "published_at": "2021-10-24T21:19:37Z",
      "title": "Install CodeStream",
      "updated_at": "2021-10-23T17:01:57Z",
      "type": "docs",
      "external_id": "5d431c8f9a2690b64d26ac9fc173b18085153aac",
      "document_type": "page",
      "popularity": 1,
      "body": "CodeStream is a developer collaboration platform that makes it easy to discuss and review code in a more natural and contextual way. Install CodeStream Install CodeStream for Visual Studio Code, Visual Studio or JetBrains. You can also install the CodeStream extension directly via your Visual Studio Code/Visual Studio's extensions or JetBrains plugins menus. Tip Once you've installed CodeStream, if you want to connect it to New Relic, you'll need your New Relic user key. Go here to learn more about finding or creating your user key. Install with Instant Observability (I/O) You can also install CodeStream via an Instant Observability (I/O) quickstart. Connect your tools Create and review pull requests on GitHub, GitLab or Bitbucket. Create issues on Jira, Trello, and other issue trackers. Share code discussions on Slack or Microsoft Teams. CodeStream brings the tools you use every day together in your IDE. Click on your headshot at the top of the CodeStream pane and go to the Integrations page to get all of your tools connected. Discuss any block of code, at any time Whether you're trying to understand someone else's code or getting help with some code you just wrote, just select the code and ask your question. Learn more about discussing code. Get feedback on your work in progress Select \"Request Feedback\" from the \"+\" menu at any time in the development cycle, whether it’s a quick look over some work in progress (even uncommitted code!) or a formal review of a completed effort. Teammates can review your changes right in their IDE, with no need to switch branches or set aside their own work. Learn more about feedback requests. Create or review a pull request Look for the Pull Requests section of the CodeStream sidebar to review an open pull request. Just click on a pull request (or load one from URL) to get a complete GitHub experience right in your IDE! Note that you can create a pull request in GitHub, GitLab or Bitbucket, but support for reviewing pull requests is currently only available for GitHub (cloud or Enterprise). Learn more about pull requests. Help & Feedback Report a bug or send a suggestion in GitHub issues. Contact us directly at support@codestream.com. Follow @teamcodestream for product updates and to share feedback and questions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 771.39795,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>CodeStream</em>",
        "sections": "Install <em>CodeStream</em>",
        "body": " install <em>CodeStream</em> via an Instant Observability (I&#x2F;O) quickstart. Connect your tools Create and review pull requests on GitHub, GitLab or Bitbucket. Create issues on Jira, Trello, and other issue trackers. Share <em>code</em> discussions on <em>Slack</em> or Microsoft Teams. <em>CodeStream</em> brings the tools you use every day"
      },
      "id": "6174400564441ff1025fd832"
    },
    {
      "sections": [
        "CodeStream licenses"
      ],
      "title": "CodeStream licenses",
      "type": "docs",
      "tags": [
        "Licenses",
        "Product or service licenses",
        "CodeStream"
      ],
      "external_id": "331f3d1cd0897f453f98bc054fda09a9ad2725c1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/codestream/codestream-licenses/",
      "published_at": "2021-10-24T17:53:35Z",
      "updated_at": "2021-10-23T17:05:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We love open-source software, and we use the following with CodeStream. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we've chosen to use. CodeStream license on GitHub CodeStream's third-party software notices on GitHub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 643.05444,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> licenses",
        "sections": "<em>CodeStream</em> licenses",
        "tags": "<em>CodeStream</em>",
        "body": "We love open-source software, and we use the following with <em>CodeStream</em>. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we&#x27;ve chosen to use. <em>CodeStream</em> license on GitHub <em>CodeStream</em>&#x27;s third-party software notices on GitHub"
      },
      "id": "617440e2196a677ea62f0193"
    }
  ],
  "/docs/codestream/codestream-settings/account-settings": [
    {
      "image": "https://docs.newrelic.com/static/80938a17dd570bd0f6c463ea41abafab/f96db/ProxySettings1.png",
      "url": "https://docs.newrelic.com/docs/codestream/troubleshooting/proxy-support/",
      "sections": [
        "CodeStream proxy support"
      ],
      "published_at": "2021-10-24T21:23:30Z",
      "title": "CodeStream proxy support",
      "updated_at": "2021-10-23T17:09:22Z",
      "type": "docs",
      "external_id": "0c1272602b2a6c485599bf738eba1eb42c6ebff6",
      "document_type": "page",
      "popularity": 1,
      "body": "If you are experiencing connectivity issues with the CodeStream extension it could be because you’re behind a network proxy and CodeStream is not configured to work with it. To find CodeStream’s settings in your IDE: VS Code - Go to Settings/Preferences and search for “CodeStream”. Visual Studio - Go to Tools > Options > CodeStream. JetBrains - Go to Settings/Preferences > Tools > CodeStream. Look for the “Proxy Support” setting and make sure it is set to “on”. You will also need to disable Strict SSL checking since your CodeStream extension won’t see the SSL/TLS certificates as coming from a legitimate Certificate Authority. Here's what these settings look like in VS Code. If you have proxy support configured in your IDE, CodeStream will first try to inherit those settings. Otherwise, CodeStream will inherit proxy settings from your operating system/environment. After changing your settings, restart your IDE.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 287.18365,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> proxy support",
        "sections": "<em>CodeStream</em> proxy support",
        "body": " - Go to Tools &gt; Options &gt; <em>CodeStream</em>. JetBrains - Go to <em>Settings</em>&#x2F;Preferences &gt; Tools &gt; <em>CodeStream</em>. Look for the “Proxy Support” setting and make sure it is <em>set</em> to “on”. You will also need to disable Strict SSL checking since your <em>CodeStream</em> extension won’t see the SSL&#x2F;TLS certificates as coming from"
      },
      "id": "617441c328ccbc299dc6c449"
    },
    {
      "image": "https://docs.newrelic.com/static/13641ba13c10755096fdee8f67741a02/f96db/ConfigureJiraServer1.png",
      "url": "https://docs.newrelic.com/docs/codestream/troubleshooting/jira-server-integration/",
      "sections": [
        "Configure the Jira server CodeStream connection",
        "Generate a public/private key pair",
        "Create an application link",
        "Set up the integration in CodeStream"
      ],
      "published_at": "2021-10-24T21:22:45Z",
      "title": "Configure the Jira server CodeStream connection",
      "updated_at": "2021-10-23T17:10:17Z",
      "type": "docs",
      "external_id": "fa12660611b9120e3aace8e1abdfb74ff89d82be",
      "document_type": "page",
      "popularity": 1,
      "body": "NOTE #1: Recent versions of Jira Server (>=8.14.0) support the use of API Tokens to access the Jira Server REST API. We recommend you use API Tokens if possible to avoid the more complicated setup described here. Check your Jira Server version. NOTE #2: You must be a Jira administrator in order to configure this integration. To determine if you have the proper permissions in order to proceed, look for the Jira Settings menu (cog icon, mostly likely at the top-right next to your headshot) and make sure there's an \"Applications\" option there. If you don't have the Settings menu, or the Applications option, then you won't be able to configure the integration. NOTE #3: This integration requires that your Jira Server instance be at a publicly accessible URL. CodeStream can integrate with Jira Server using Atlassian’s published REST API. To enable CodeStream to integrate with your Jira Server installation, you will need to set up a CodeStream application link. This application link serves as a conduit for users to authenticate against their Jira Server account without ever having to enter their credentials in CodeStream. Jira Server uses the OAuth standard (version 1.0a) for client authorization. For reference, this page from Atlassian describes the process: https://developer.atlassian.com/server/jira/platform/oauth/. However, you do not need to follow the full instructions on that page; the relevant instructions are duplicated and simplified here for clarity. Note that you will need the openssl command-line tool to generate a public/private key pair for use with the application link. Generate a public/private key pair In a terminal, use openssl to generate your public/private key pair, following these steps carefully: Generate a 1024-bit private key: openssl genrsa -out jira_privatekey.pem 1024 Create an X509 certificate: openssl req -newkey rsa:1024 -x509 -key jira_privatekey.pem -out jira_publickey.cer -days 365 Enter whatever information you see fit to accompany the certificate. Extract the private key (PKCS8 format) to the jira_privatekey.pcks8 file: openssl pkcs8 -topk8 -nocrypt -in jira_privatekey.pem -out jira_privatekey.pcks8 Extract the public key from the certificate to the jira_publickey.pem file: openssl x509 -pubkey -noout -in jira_publickey.cer > jira_publickey.pem Create an application link Follow these steps to create your application link within Jira Server. In Jira, navigate to Jira settings (gear icon in upper-right), select Applications. Type in your Administrator password if needed. Then select Application links under \"Integrations\", in the left sidebar. Where it says Enter the URL of the application you want to link, enter any URL you want, for example, http://example.com/. Then click Create new link. You will likely see a warning starting with: No response was received from the URL you entered. You can ignore the warning; click Continue. Fill out the form as you see here, or as you like. None of the data entered here really matters, except to make sure that Create incoming link is checked. The Application Name can be whatever name works best for you to identify the link. Then click Continue. On the next dialog, enter any unique string you want for the Consumer Key. It does not need to be secure or encoded, just something fairly easy to remember. Make a note of what you enter here; it will be needed when you go to set up the integration with Jira Server from CodeStream. For Consumer Name, you can enter anything meaningful to you, like \"CodeStream app\". The important field to fill out correctly is Public Key; for this you will want to copy the full text of the contents of the jira_publickey.pem file you created in Step #1. Paste this into the Public Key field, then click Continue. The application link you created should now show like this: Set up the integration in CodeStream Now you are ready to set up the integration from CodeStream to Jira Server for your team, using the application link you just created. Assuming you have signed up for CodeStream and have the extension open in your IDE: In CodeStream, go to the Integrations panel by clicking the menu next to your username in the top-left. Then click Jira Server under \"Issue Providers\". Since you will not be using API Tokens with your Jira Server integration, you'll need to click at the top where it says \"Click here if you organization uses a version of Jira Server older than...\" to configure Jira Server using the OAuth method described herein. Fill out the form as follows. For Jira Server Base URL, enter the URL used to access your Jira Server installation as known to your internal network, in the form http(s)://host:port. For Consumer Key, use the \"consumer key\" you entered when created the application link, from Step #2, above. Then copy the full contents of the private key, in PCKS8 format, that you created in Step #1 above. The file should be called jira_privatekey.pcks8. Paste those contents into the Private Key field, then click Submit. You'll then be taken to your Jira Server instance, where you'll approve access to your account using the application link. When you are finished, return to your IDE and you should see something similar to this: Now that the integration has been set up for your organization, other users will NOT have to go through the process described above. Other users in your organization will see the integration with your Jira Server (specified by host) alongside other available integrations. Initiating this integration will only require your other users to allow the CodeStream application link to access their account, as you did in the final step.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 270.45203,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Configure the Jira server <em>CodeStream</em> connection",
        "sections": "<em>Set</em> up the integration in <em>CodeStream</em>",
        "body": " installation, you will need to <em>set</em> up a <em>CodeStream</em> application link. This application link serves as a conduit for users to authenticate against their Jira Server <em>account</em> without ever having to enter their credentials in <em>CodeStream</em>. Jira Server uses the OAuth standard (version 1.0a) for client"
      },
      "id": "617441f964441fa1775fe265"
    },
    {
      "image": "https://docs.newrelic.com/static/0d940de4d107acece21b6e518f1a2c53/d10fb/OrganizationSettings.png",
      "url": "https://docs.newrelic.com/docs/codestream/codestream-settings/team-administration/",
      "sections": [
        "CodeStream organization settings and administration",
        "Managing People & Roles",
        "Organization Settings",
        "Onboarding Settings",
        "Feedback Request Assignment & Approval",
        "Change Organization Name",
        "Data Export"
      ],
      "published_at": "2021-10-24T21:15:45Z",
      "title": "CodeStream organization settings and administration",
      "updated_at": "2021-10-23T16:57:06Z",
      "type": "docs",
      "external_id": "643e62ff1fc920ca94e3bcd2e27e3a9be4317515",
      "document_type": "page",
      "popularity": 1,
      "body": "Managing People & Roles Select \"My Organization\" from the My Organization menu at the top of the CodeStream pane to invite people to the organization and assign or remove admin privileges. Select \"Blame Map\" to define code ownership with your organization. By default, when you comment on code, CodeStream mentions (or offers to email) the author(s) of the code you are commenting on. But if that person has left the company it might not be the right thing to do. Note that non-admins are able to set up blame maps for themselves to handle situations where the email address they use to commit code is different than the one they used to sign up for CodeStream. Organization Settings If you are an organization admin, look for the Organization Admin menu under the headshot menu at the top of the CodeStream pane. Onboarding Settings Domain-based joining allows anyone with email addresses on the specified domains to join your CodeStream organization without being first invited. Not only does this make it very easy to get your teammates on board, but it ensures that they'll be part of your organization (as opposed to accidentally creating their own). Feedback Request Assignment & Approval Admins can control how both feedback request assignments and approvals work for the organization. By default, the person requesting feedback can decide how approvals work, but you can, instead, set a default behavior for all feedback requests for the organization. Any reviewer can approve - Any one can approve the feedback request, regardless of how many reviewers are assigned. All reviewers must approve individually - Each assigned reviewer must individually approve the feedback request before it’s considered approved. You can also decide if and how CodeStream suggests reviewers. Round-robin will cycle through all developers in the organization. Random will randomly assign the feedback request to any developer in the organization. The Authorship options will suggest up to three reviewers based on the developers who wrote the lines of code impacted by the changes, as well as other developers who may have committed to the branch. Change Organization Name Update the name of your CodeStream organization at any time. Data Export A lightweight export facility for getting your organization's discussions out of CodeStream. Click the icon to copy all of the data to the clipboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 267.5174,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> organization <em>settings</em> <em>and</em> administration",
        "sections": "<em>CodeStream</em> organization <em>settings</em> <em>and</em> administration",
        "body": ", <em>CodeStream</em> mentions (or offers to email) the author(s) of the <em>code</em> you are commenting on. But if that person has left the company it might not be the right thing to do. Note that non-admins are able to <em>set</em> up blame maps for themselves to handle situations where the email address they use to commit <em>code</em>"
      },
      "id": "61743ee264441ff1025fd5b5"
    }
  ],
  "/docs/codestream/codestream-settings/team-administration": [
    {
      "sections": [
        "CodeStream licenses"
      ],
      "title": "CodeStream licenses",
      "type": "docs",
      "tags": [
        "Licenses",
        "Product or service licenses",
        "CodeStream"
      ],
      "external_id": "331f3d1cd0897f453f98bc054fda09a9ad2725c1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/codestream/codestream-licenses/",
      "published_at": "2021-10-24T17:53:35Z",
      "updated_at": "2021-10-23T17:05:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We love open-source software, and we use the following with CodeStream. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we've chosen to use. CodeStream license on GitHub CodeStream's third-party software notices on GitHub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 650.55145,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> licenses",
        "sections": "<em>CodeStream</em> licenses",
        "tags": "<em>CodeStream</em>",
        "body": "We love open-source software, and we use the following with <em>CodeStream</em>. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we&#x27;ve chosen to use. <em>CodeStream</em> license on GitHub <em>CodeStream</em>&#x27;s third-party software notices on GitHub"
      },
      "id": "617440e2196a677ea62f0193"
    },
    {
      "image": "https://docs.newrelic.com/static/48721d72a10a277b2ef615b62a07f0fe/f96db/GitHubAuth.png",
      "url": "https://docs.newrelic.com/docs/codestream/troubleshooting/github-org-repos/",
      "sections": [
        "Why aren't PRs and issues from all my GitHub organizations listed in CodeStream?"
      ],
      "published_at": "2021-10-24T21:22:45Z",
      "title": "Why aren't PRs and issues from all my GitHub organizations listed in CodeStream?",
      "updated_at": "2021-10-23T17:09:23Z",
      "type": "docs",
      "external_id": "aa4cd2a3acc746bc90aa1cf6663335e36084c002",
      "document_type": "page",
      "popularity": 1,
      "body": "When you connect to GitHub you should see all of your open pull requests in the Pull Requests section of the CodeStream pane, as well as all issues assigned to you in the Issues section. If pull requests or issues from any of your GitHub organizations are missing, it's probably because at the time you authenticated with GitHub, you didn't grant access to all of your organizations. If you didn't click on that Grant button at authentication time, simply go to GitHub and navigate to Settings > Applications and click on the Authorized OAuth Apps tab. From there, click on the CodeStream application. On the following page, click the Grant button next to any organizations that you'd like to be able to access from CodeStream. Note that in some instances you'll see a Request button instead of Grant, which means that the owner of your GitHub organization will need to grant access.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 314.6441,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Why aren&#x27;t PRs <em>and</em> issues from all my GitHub <em>organizations</em> listed in <em>CodeStream</em>?",
        "sections": "Why aren&#x27;t PRs <em>and</em> issues from all my GitHub <em>organizations</em> listed in <em>CodeStream</em>?",
        "body": " you authenticated with GitHub, you didn&#x27;t grant access to all of your organizations. If you didn&#x27;t click on that Grant button at authentication time, simply go to GitHub and navigate to <em>Settings</em> &gt; Applications and click on the Authorized OAuth Apps tab. From there, click on the <em>CodeStream</em>"
      },
      "id": "617441c3e7b9d2478513cf8c"
    },
    {
      "image": "https://docs.newrelic.com/static/30e00c292c5aa1c5d702d67be5021a45/f96db/CreateAnAccount6.png",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/sign-up-codestream/",
      "sections": [
        "Sign up for CodeStream",
        "Create an account",
        "CodeStream organizations [$organizations]",
        "Create or join an organization",
        "Invite your team"
      ],
      "published_at": "2021-10-24T21:21:10Z",
      "title": "Sign up for CodeStream",
      "updated_at": "2021-10-23T17:05:39Z",
      "type": "docs",
      "external_id": "2f8eda03703523f62844512a3b8ef005b624ebc2",
      "document_type": "page",
      "popularity": 1,
      "body": "To get the most out of CodeStream's collaboration tools, create an organization, and then invite your team members to it. Create an account If you already have the CodeStream extension installed in your IDE, you can start the signup process from the CodeStream pane. You can sign up by either creating a set of CodeStream credentials (such as, email address and password), or you can sign up using GitHub, GitLab or Bitbucket (cloud versions only). Signing up via your code host saves you from having to connect later, but if the email address you're using there isn't your work email you should create CodeStream credentials instead. If you sign up via CodeStream, your next step will be to confirm your email address by entering a code sent to you via email. Note that you can paste the code into any of the boxes rather than typing each number individually. CodeStream organizations [$organizations] An “organization” on CodeStream is where you and your teammates will discuss code. Similar to a Slack workspace, all of the developers in your company should be in the same CodeStream organization. This is true even for very large organizations as CodeStream's activity feed keeps things relevant for each member by showing just activity related to the code you have open in your IDE. The discussions about code build up a knowledge base that is a company-wide resource, so the only reason to have multiple organizations on CodeStream is if you truly need separation. For example, you might have an organization for your day job and another for an open-source project you work on. Or maybe you're a consultant that is a member of different CodeStream organizations for each of your clients. Create or join an organization If you were invited to join an organization on CodeStream, all you need to do is sign up using the same email address the invitation was sent to. You'll automatically be added to that organization. If you're the first person from your company to sign up for CodeStream you can go ahead and create a new organization. Otherwise, there may be existing CodeStream organizations available for you to join based on your email domain. If you think your company is already on CodeStream, but don't see an organization to join, make sure that you've signed up with your work email address. Click the link to change your email address if necessary. If you decide to create an organization you'll be asked to give it a name, and if you signed up with your work email address, you'll also be able to indicate that anyone else on that email domain can join the organization. Invite your team Collaboration is a team sport so invite your teammates to join you on CodeStream! CodeStream will offer up some suggestions based on the commit history of the repositories you have open in your IDE. Now you're ready to start using CodeStream.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 311.20972,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Sign up for <em>CodeStream</em>",
        "sections": "<em>CodeStream</em> <em>organizations</em> [$<em>organizations</em>]",
        "body": "To get the most out of <em>CodeStream</em>&#x27;s collaboration tools, create an <em>organization</em>, and then invite your team members to it. Create an account If you already have the <em>CodeStream</em> extension installed in your IDE, you can start the signup process from the <em>CodeStream</em> pane. You can sign up by either"
      },
      "id": "617440e3196a6782592f011c"
    }
  ],
  "/docs/codestream/codestream-ui-overview/activity-feed": [
    {
      "image": "https://docs.newrelic.com/static/eeb160b7c86583a706f3b8b4cc3d5f41/f96db/AccountSettings2.png",
      "url": "https://docs.newrelic.com/docs/codestream/codestream-settings/account-settings/",
      "sections": [
        "CodeStream account settings and profile pages",
        "Profile"
      ],
      "published_at": "2021-10-24T23:23:37Z",
      "title": "CodeStream account settings and profile pages",
      "updated_at": "2021-10-23T17:00:53Z",
      "type": "docs",
      "external_id": "83e4ba3ea989b1f2a0bce57b59bf3a7ca92ad2cc",
      "document_type": "page",
      "popularity": 1,
      "body": "Look for the “Account” menu under the ellipses menu at the top of the CodeStream pane and you’ll find options for viewing your own profile, and changing your profile photo, username, full name and email address. Note that when you change your email address, the old one will remain in effect until you click on the link in the confirmation email sent to you. If you would like to cancel your CodeStream account look for the option to do so under Other Actions. Profile If you click on a headshot from anywhere in CodeStream (e.g., activity feed, a discussion thread, etc.) you'll be taken to the person's profile page. When viewing your own profile page, hover over entries for username, email address, phone number, works on or the profile photo to see a pencil icon that will allow you to make changes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2603.1445,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> account settings and profile pages",
        "sections": "<em>CodeStream</em> account settings and profile pages",
        "body": " you click on the link in the confirmation email sent to you. If you would like to cancel your <em>CodeStream</em> account look for the option to do so under Other Actions. Profile If you click on a headshot from anywhere in <em>CodeStream</em> (e.g., <em>activity</em> <em>feed</em>, a discussion thread, etc.) you&#x27;ll be taken"
      },
      "id": "61743fc5e7b9d2b9e813cf20"
    },
    {
      "image": "https://docs.newrelic.com/static/30e00c292c5aa1c5d702d67be5021a45/f96db/CreateAnAccount6.png",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/sign-up-codestream/",
      "sections": [
        "Sign up for CodeStream",
        "Create an account",
        "CodeStream organizations [$organizations]",
        "Create or join an organization",
        "Invite your team"
      ],
      "published_at": "2021-10-24T21:21:10Z",
      "title": "Sign up for CodeStream",
      "updated_at": "2021-10-23T17:05:39Z",
      "type": "docs",
      "external_id": "2f8eda03703523f62844512a3b8ef005b624ebc2",
      "document_type": "page",
      "popularity": 1,
      "body": "To get the most out of CodeStream's collaboration tools, create an organization, and then invite your team members to it. Create an account If you already have the CodeStream extension installed in your IDE, you can start the signup process from the CodeStream pane. You can sign up by either creating a set of CodeStream credentials (such as, email address and password), or you can sign up using GitHub, GitLab or Bitbucket (cloud versions only). Signing up via your code host saves you from having to connect later, but if the email address you're using there isn't your work email you should create CodeStream credentials instead. If you sign up via CodeStream, your next step will be to confirm your email address by entering a code sent to you via email. Note that you can paste the code into any of the boxes rather than typing each number individually. CodeStream organizations [$organizations] An “organization” on CodeStream is where you and your teammates will discuss code. Similar to a Slack workspace, all of the developers in your company should be in the same CodeStream organization. This is true even for very large organizations as CodeStream's activity feed keeps things relevant for each member by showing just activity related to the code you have open in your IDE. The discussions about code build up a knowledge base that is a company-wide resource, so the only reason to have multiple organizations on CodeStream is if you truly need separation. For example, you might have an organization for your day job and another for an open-source project you work on. Or maybe you're a consultant that is a member of different CodeStream organizations for each of your clients. Create or join an organization If you were invited to join an organization on CodeStream, all you need to do is sign up using the same email address the invitation was sent to. You'll automatically be added to that organization. If you're the first person from your company to sign up for CodeStream you can go ahead and create a new organization. Otherwise, there may be existing CodeStream organizations available for you to join based on your email domain. If you think your company is already on CodeStream, but don't see an organization to join, make sure that you've signed up with your work email address. Click the link to change your email address if necessary. If you decide to create an organization you'll be asked to give it a name, and if you signed up with your work email address, you'll also be able to indicate that anyone else on that email domain can join the organization. Invite your team Collaboration is a team sport so invite your teammates to join you on CodeStream! CodeStream will offer up some suggestions based on the commit history of the repositories you have open in your IDE. Now you're ready to start using CodeStream.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2331.1929,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Sign up for <em>CodeStream</em>",
        "sections": "Sign up for <em>CodeStream</em>",
        "body": " [$organizations] An “organization” on <em>CodeStream</em> is where you and your teammates will discuss <em>code</em>. Similar to a Slack workspace, all of the developers in your company should be in the same <em>CodeStream</em> organization. This is true even for very large organizations as <em>CodeStream</em>&#x27;s <em>activity</em> <em>feed</em> keeps things relevant"
      },
      "id": "617440e3196a6782592f011c"
    },
    {
      "sections": [
        "CodeStream licenses"
      ],
      "title": "CodeStream licenses",
      "type": "docs",
      "tags": [
        "Licenses",
        "Product or service licenses",
        "CodeStream"
      ],
      "external_id": "331f3d1cd0897f453f98bc054fda09a9ad2725c1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/codestream/codestream-licenses/",
      "published_at": "2021-10-24T17:53:35Z",
      "updated_at": "2021-10-23T17:05:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We love open-source software, and we use the following with CodeStream. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we've chosen to use. CodeStream license on GitHub CodeStream's third-party software notices on GitHub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 643.05414,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> licenses",
        "sections": "<em>CodeStream</em> licenses",
        "tags": "<em>CodeStream</em>",
        "body": "We love open-source software, and we use the following with <em>CodeStream</em>. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we&#x27;ve chosen to use. <em>CodeStream</em> license on GitHub <em>CodeStream</em>&#x27;s third-party software notices on GitHub"
      },
      "id": "617440e2196a677ea62f0193"
    }
  ],
  "/docs/codestream/codestream-ui-overview/codemarks-section": [
    {
      "sections": [
        "CodeStream licenses"
      ],
      "title": "CodeStream licenses",
      "type": "docs",
      "tags": [
        "Licenses",
        "Product or service licenses",
        "CodeStream"
      ],
      "external_id": "331f3d1cd0897f453f98bc054fda09a9ad2725c1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/codestream/codestream-licenses/",
      "published_at": "2021-10-24T17:53:35Z",
      "updated_at": "2021-10-23T17:05:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We love open-source software, and we use the following with CodeStream. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we've chosen to use. CodeStream license on GitHub CodeStream's third-party software notices on GitHub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 643.05383,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> licenses",
        "sections": "<em>CodeStream</em> licenses",
        "tags": "<em>CodeStream</em>",
        "body": "We love open-source software, and we use the following with <em>CodeStream</em>. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we&#x27;ve chosen to use. <em>CodeStream</em> license on GitHub <em>CodeStream</em>&#x27;s third-party software notices on GitHub"
      },
      "id": "617440e2196a677ea62f0193"
    },
    {
      "image": "https://docs.newrelic.com/static/74c274508fc745275751f72d3e01ea33/f96db/CodemarkAddRange1.png",
      "url": "https://docs.newrelic.com/docs/codestream/how-use-codestream/discuss-code/",
      "sections": [
        "Discuss code on CodeStream",
        "What is a codemark?",
        "Creating a codemark",
        "Comment Codemarks",
        "Issue Codemarks",
        "Bringing the right people into the discussion",
        "Different versions of the code?",
        "Resolving codemarks",
        "Advanced Features",
        "Multiple Ranges",
        "File Attachments",
        "Tagging",
        "Related codemarks",
        "Managing codemarks"
      ],
      "published_at": "2021-10-24T21:18:06Z",
      "title": "Discuss code on CodeStream",
      "updated_at": "2021-10-23T17:01:57Z",
      "type": "docs",
      "external_id": "9169c03142311fe838566856d0ff154df0e6d555",
      "document_type": "page",
      "popularity": 1,
      "body": "What is a codemark? Quite simply, a codemark is a discussion connected to the code. It could be a question, a suggestion, a bug report, or documentation. All of these discussions are saved, anchored to the blocks of code they refer to, so that they can be leveraged in the future. It could be a new developer joining the team, a developer trying to fix a bug in someone else’s code, or even just you trying to remember why you made that change six months ago… whatever the case, CodeStream helps you understand the code by surfacing the discussions in a contextual way. Even as a file changes over time, the codemarks will remain connected to the code. Add some new lines of code above the code block, make edits to the code, or even cut-and-paste the entire block to a different section of the file, and you’ll see the codemark move right along with the changes. Creating a codemark Create a codemark by selecting a block of code in your editor and then clicking on one of the icons that appears in the CodeStream pane next to your selection. If you're using a JetBrains IDE, such as IntelliJ, you can also create a codemark by using the \"+\" button that appears in the editor's gutter when you select a block of code. When you're viewing a diff, for either a feedback request or a pull request, the button will also appear when you hover in the gutter to make it easy to comment on a single line. Even when the CodeStream pane is closed or not in view, you can create a codemark via the CodeStream options in either the lightbulb or context menus. Lastly, you can also look for the \"+\" menu at the top of the CodeStream pane. Need to reach teammates that don’t spend a lot of time in the IDE? Or maybe some teammates that aren’t yet on CodeStream? You can optionally share a codemark out to Slack or Microsoft Teams. The Slack integration even allows your teammates to reply directly from Slack. Comment Codemarks The all-purpose codemark for linking any type of discussion to a block of code. Ask a question. Make a suggestion. Document some code. Make note of key sections of the codebase. The possibilities are endless! Issue Codemarks When something needs to get done there’s always a better chance of it happening if it’s captured as an issue, with someone’s name attached. Assign issues as a way of reporting bugs. Or manage your tech debt by capturing items as tracked issues instead of inline FIXMEs. If your team uses Asana, Azure DevOps, Bitbucket (cloud), Clubhouse, GitHub (cloud or Enterprise), GitLab (cloud or Self-Managed), Jira (cloud or Server), Linear, Trello, or YouTrack (cloud) for tracking issues, you can create an issue on one of those services directly from CodeStream. Just select the service you use from the dropdown at the top of the codemark form. After going through the authentication process with the selected service you'll now be able to select a destination for your issue. For example, with Jira you'll be able to select the appropriate issue type and project. Once the issue has been created on CodeStream, it will include a link to the issue that was created on the external service. In the example below you'll see the URL for the issue on Jira. And the issue on Jira includes a link to open the relevant code in your IDE. Bringing the right people into the discussion When you create a codemark, CodeStream automatically mentions the people that most recently touched of the code you are commenting on. They may be the best people to answer your question, but you can, of course, remove those mentions and manually mention someone else if appropriate. It may be the case that the people that have touched the code aren't yet on CodeStream, in which case CodeStream will provide checkboxes to have them notified via email. They can simply reply to the email to have their comment posted to CodeStream, and of course they can install CodeStream to participate from their IDE. Different versions of the code? Maybe you’re on a feature branch, have local changes, or simply haven’t pulled in a while. There are countless reasons why the code you’re looking at might be different than what a teammate is looking at, and as a result, there will be plenty of times when the code referenced in a codemark doesn’t match what you have locally. CodeStream recognizes these situations and includes the original version of the code block (i.e. at the time the codemark was created), the current version, and a diff. Keep in mind that with CodeStream you can discuss any line of code, in any source file, at any time, even if it’s code that you just typed into your editor and haven’t yet committed. CodeStream allows you to discuss code at the very earliest stages of the development process. Resolving codemarks Although not required, both comment and issue codemarks can be resolved. The Codemarks section of the CodeStream pane breaks out codemarks into Open, Resolved and Archived sections, and green, purple and gray icons are used to represent those different states. If you see a lot of Open/green codemarks in the codestream pane, that means that your teammates are being blocked by discussions and issues that haven't be resolved. You can add a comment at the same time your resolve the codemark, and you can also elect to archive the codemark at the same time. Advanced Features Multiple Ranges Many discussions about code involve more than just one block of code, and concepts are often best presented when you can refer to multiple code locations at once. Here are a few examples of multi-range codemark at work: A change to a function is being contemplated that will impact its name. Each instance of the function call can now be referenced in one discussion. A react component and its CSS styling aren’t interacting well, and you want to ask the team for input. You might select the div and the CSS rules you think should apply, so your teammates know exactly what you’re talking about. Clients which make API calls to the server might get an unexpected result. Select the code where you’re making the API call, and the handler in the API server, to connect the two actions together. To create a multi-range codemark, click on \"+ Add Code Block\". And then select another block of code from the same file, a different file, or even a different repo. You can intersperse the difference code blocks in your post by referring to each one as [#N] (or click the pin icon from one of the code blocks to insert the markdown for you), as in the following example. And here's how that example is rendered. Once you've created the codemark, you can easily jump between the different locations by clicking the Jump icon at the bottom-right of each code block. Note that when you edit a codemark you can add and remove code blocks, and you can change the location of any of the code blocks by clicking the dashed square icon. File Attachments Enrich your discussions about code by attaching files directly to code blocks. Think about how much more compelling your comments and documentation become when you... Attach a spec to guide the development of a new feature Attach a log file to help debug an issue in the code Attach a mockup to help clarify some UI work Attach a screenshot to highlight a problem When creating a code comment or issue, you can attach a file by dragging-and-dropping on the the description field, pasting from you clipboard, or by clicking the new paperclip icon. Images can even be displayed inline using markdown. Just click the pin icon to the right of the attachment, and CodeStream will insert the markdown for you. And now your teammate knows exactly what you’re looking for! You can click on files in the Attachments section to either download or open in the appropriate application. Tagging Look for the tag icon inside the codemark compose box to either select a tag or create a tag using any combination of color and text label. Tags are a great way to broadly organize and group your organization's codemarks, and the possibilities here are endless. Note that you can also filter by tag on the Filter & Search page. Related codemarks Click on the CodeStream icon in the codemark compose form to select other, related codemarks to “attach” to the current codemark. This allows you to easily establish a connection between different parts of a codebase. For example, when a change to one part of the codebase would require a change to another part, identify the dependency by creating two related codemarks. Once you’ve added the related codemarks they’ll be displayed in a “Related” section and you can click on any one to jump to that codemark and the corresponding section of the code. Managing codemarks Click on the ellipses menu for any codemark and you'll see options for managing the codemark. Share - In addition to sharing to Slack or Teams at the time you create a codemark, you can also share it anytime thereafter. Follow/Unfollow - Unfollow to stop receiving notifications for the codemark. Copy link - Get a permalink for the codemark to share it anywhere. Archive - If there’s a codemark that you don’t think is important enough to be on permanent display in a given file, but you don’t want to completely delete it, you can archive it instead. Settings in the codemarks section allow you to easily see all archived codemarks. Edit - Only the codemark's author can edit it. Delete - Only the codemark's author can delete it, but we encourage you to archive instead of delete unless you're positive the codemark won't have any future value. Inject as Inline Comment - If you'd like a specific codemark to become part of the repo use this option to have it added as an inline comment. You can select the appropriate format, and then indicate if you want to include timestamps, replies, or to have the comment wrapped at 80 characters. You can also elect to have the codemark archived once it's been added as an inline comment. Reposition codemark - In most cases, a codemark will automatically remain linked to the block of code it refers to as the file changes over time. For example, if you cut the block of code and paste it at a different location in the file, the codemark will move right along with it. There are some scenarios, however, that CodeStream isn't able to handle automatically. For example, if you pasted the block of code into a different file. In these cases, Reposition codemark allows you to select the new location of the block of code so that the codemark is displayed properly.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 421.7492,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Discuss <em>code</em> on <em>CodeStream</em>",
        "sections": "Discuss <em>code</em> on <em>CodeStream</em>",
        "body": " can be resolved. The <em>Codemarks</em> <em>section</em> of the <em>CodeStream</em> pane breaks out <em>codemarks</em> into Open, Resolved and Archived sections, and green, purple and gray icons are used to represent those different states. If you see a lot of Open&#x2F;green <em>codemarks</em> in the <em>codestream</em> pane, that means that your teammates"
      },
      "id": "6174400564441fe8685fd746"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/codestream/troubleshooting/git-issues/",
      "sections": [
        "Issues with Git and CodeStream",
        "Repo isn’t managed by Git, or Git can't be found",
        "Repo doesn’t have a remote URL",
        "Unsaved File"
      ],
      "published_at": "2021-10-24T21:21:10Z",
      "title": "Issues with Git and CodeStream",
      "updated_at": "2021-10-23T17:11:07Z",
      "type": "docs",
      "external_id": "97a49a95bd3cd8874f1a52d2242cd738d76f8662",
      "document_type": "page",
      "popularity": 1,
      "body": "When you post a message with a code block you may encounter one of the following Git-related warnings. Repo isn’t managed by Git, or Git can't be found While technically not a requirement, key elements of CodeStream’s functionality depend on your repository being managed by Git, or a Git hosting service like GitHub. If you’re not using Git, CodeStream will not be able to connect the comments and issues you create to the appropriate blocks of code in your source files. This means that comments and issues will appear in the activity feed and in search results, but they will not appear in the Codemarks section when your teammates are viewing the given source file. Note that this error could also mean that Git isn’t in your PATH. If so, please add it to your PATH and then restart your IDE. Repo doesn’t have a remote URL The remote URL is part of what allows CodeStream to tie the code block from your message to the appropriate file/location in the corresponding repo in your teammates’ IDEs. If CodeStream isn't able to identify the repository your teammate has open as the same one in which you created your comment/issue, they won't be able to see the comment/issue. From the command line, do a git remote -v to confirm whether or not you have a remote URL configured for this repository. If there is no remote URL, find out the correct URL and then specify the remote by doing a git remote add origin <remote URL>. Unsaved File As with files not managed by Git, CodeStream will not be able to link a comment/issue to a block of code in a new, unsaved file. Go ahead and save the file before creating your first comment/issue.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 355.7641,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Issues with Git and <em>CodeStream</em>",
        "sections": "Issues with Git and <em>CodeStream</em>",
        "body": " in the <em>Codemarks</em> <em>section</em> when your teammates are viewing the given source file. Note that this error could also mean that Git isn’t in your PATH. If so, please add it to your PATH and then restart your IDE. Repo doesn’t have a remote URL The remote URL is part of what allows <em>CodeStream</em> to tie the <em>code</em> block"
      },
      "id": "6174422b64441f5a7f5fd919"
    }
  ],
  "/docs/codestream/codestream-ui-overview/codestream-keyboard-shortcuts": [
    {
      "sections": [
        "CodeStream licenses"
      ],
      "title": "CodeStream licenses",
      "type": "docs",
      "tags": [
        "Licenses",
        "Product or service licenses",
        "CodeStream"
      ],
      "external_id": "331f3d1cd0897f453f98bc054fda09a9ad2725c1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/codestream/codestream-licenses/",
      "published_at": "2021-10-24T17:53:35Z",
      "updated_at": "2021-10-23T17:05:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We love open-source software, and we use the following with CodeStream. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we've chosen to use. CodeStream license on GitHub CodeStream's third-party software notices on GitHub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 643.05383,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> licenses",
        "sections": "<em>CodeStream</em> licenses",
        "tags": "<em>CodeStream</em>",
        "body": "We love open-source software, and we use the following with <em>CodeStream</em>. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we&#x27;ve chosen to use. <em>CodeStream</em> license on GitHub <em>CodeStream</em>&#x27;s third-party software notices on GitHub"
      },
      "id": "617440e2196a677ea62f0193"
    },
    {
      "image": "https://docs.newrelic.com/static/595e873b1bfe20aa5d39a66adf18d0c9/f96db/RequestFeedback.png",
      "url": "https://docs.newrelic.com/docs/codestream/how-use-codestream/request-feedback/",
      "sections": [
        "Request feedback on CodeStream",
        "Requesting feedback",
        "Providing feedback",
        "Comments & Change Requests",
        "Adding more code changes"
      ],
      "published_at": "2021-10-24T21:19:37Z",
      "title": "Request feedback on CodeStream",
      "updated_at": "2021-10-23T17:02:53Z",
      "type": "docs",
      "external_id": "752fa4dd9516d616b763d1552836fc30a93ccc7b",
      "document_type": "page",
      "popularity": 1,
      "body": "CodeStream's Feedback Requests are powerful enough to use for traditional end-of-cycle code reviews, but at the same time they're so easy and flexible that you can use them throughout the development process to get quick feedback on your work in progress. Even if you haven't committed your changes! Traditional code review happens at the end of the development cycle, when you’re looking to get the changes merged. Not only are end-of-cycle code reviews much more burdensome on your teammates, but you run the risk of identifying issues so late in the game that you end up having to decide between blowing up your schedule or taking on technical debt. Whether you’re at the very beginning of a project, with just some stubbed out functions, are mid-way through a work in progress, or are ready for a final review of a finished project, CodeStream allows you to get feedback at any point during the development cycle. CodeStream handles the complexity of sharing your current status, including pushed commits, local commits, and staged and saved changes. Teammates can provide feedback right from their IDE, with no need to switch applications, and no need to switch branches or pull changes. By the time you get to that formal code review/pull request at the end of the development cycle, it’s far less painful and more of a formality because issues have been raised, discussed and resolved all along the way. Requesting feedback Request feedback at any time, regardless of the current state of your work, by clicking on the \"+\" button at the top of the CodeStream pane, or the \"+\" button in the header of the Feedback Requests section. You can also use a keyboard shortcut (ctlr+shift+/ r, or ctrl+/ r on a Mac). With a single click you can name the feedback request based on the last commit message, the branch name, or, if you started work by selecting a ticket, the ticket title. CodeStream assumes that you are requesting feedback on changes in the repo/branch of the file currently selected in your editor. If you have multiple repositories open in your IDE, you can change this via the repo dropdown at the very top of the form. Depending on your organization's settings, CodeStream may suggest some reviewers. Based on the commit history of the code being changed, the suggestions may even include someone that isn't yet on your CodeStream team (in which case they'd be notified via email). Hover over a reviewer’s name to see more details or to remove them. If multiple reviewers are assigned you may also have the option to determine whether any of them can approve the review, or if each one has to approve it individually. The Changed Files section lists all of the files that have been added, removed or modified. Click on any file to view a diff if you want to review your changes before submitting the feedback request. If you have a file that’s not suitable for review, such as a checked-in binary file, you can hover over any file and click the \"x\" to exclude that file from the feedback request. That file will be moved to a list below the form. Note that new files are, by default, excluded from the feedback request, but you can hover over their entry in the list and click \"+\" to add them. Hover over an excluded file and click on the trashcan to permanently exclude it from all future feedback requests. Permanently excluding files creates a .codestreamignore file in the repository. If you think your teammates will also want to exclude these files (e.g., a package-lock.json or other system-generated file), you can commit and push the file so that they can make use of it as well. The changes represented across the selected files are broken out into four different categories, allowing you to select exactly what you would like to include in the feedback request. This includes changes that haven't been pushed, or even committed! Saved Changes Staged Changes Local Commits Pushed Commits Note that commits are listed in descending order across the Local Commits and Pushed Commits sections, and unchecking the box for a commit will automatically uncheck the boxes for all preceding commits. In other words, the commits included in the feedback request must be consecutive. Only your commits are checked by default, but you can include any of them in your review. (Tip: Make sure the email address in your git configuration matches your CodeStream email address. Or set up a blame map to map your git email address to you CodeStream email address.) Lastly, you can optionally share the feedback request out to either Slack or Microsoft Teams. When you submit your feedback request, teammates will be notified via the activity feed, with anyone assigned as a reviewer being @mentioned so that they’ll also receive an email notification. Providing feedback The best part of CodeStream's feedback requests is that having your teammates look over your code doesn't put any extra burden on them. No need for them to set aside their own work to switch branches or pull changes, and no need to for them to leave their IDE. As long as they have the appropriate repo, they can simply open the feedback request and start reviewing the changes. Click on any file in the Changed Files section to review the changes. You’ll be presented with a diff in your editor, and you can step through the changes in the file using your IDE's native navigation or the up/down arrows in the Changed Files section. Note that for JetBrains IDEs, CodeStream doesn't currently support the \"Unified viewer\" for diffs. Just the \"Side-by-side viewer\". Typically, the diff will represent the changes in the branch associated with the feedback request (i.e., usually a feature/topic branch) against the base branch, at the point at which the feature branch was created. Note that with CodeStream diffs this may not always be the case since the developer may not have included all of their changes in the feedback request. As a result, the version of the files that the changes are being diff’ed against may, in fact, also include changes that aren’t in the base branch. This is important in order to provide continuity. Comments & Change Requests If you have a general comment about the changes, just add a reply to the feedback request's thread. But if you want to comment on the actual changes, just select some code from the right side of the diff and then click on the comment button that appears in the CodeStream pane next to your selection. You can also use a keyboard shortcut (ctlr+shift+/ c, or ctrl+/ c on a Mac) after selecting some code. Since you have the full file context, you aren’t limited to commenting on just the lines of code that changed. For example, you might notice another part of the file that needs work as well, or that you simply want to reference. Whether it’s a general comment or a comment on code, you can mark it a “change request” to let the developer know that it’s required before you’ll approve the changes. While you are providing feedback, you can even comment on files that are not part of the changeset, and they will get added as a reply to the review. This is helpful to be able to point your teammate to another location in the codebase that might be an example of a better way to do something. All of the change requests associated with the the feedback request are summarized in a section at the top, in addition to being part of the discussion thread. This is where they will get marked complete when the work is done. Look for the green and red buttons at the top to either approve the changes or request that additional changes be made. Note that if there are any open change requests, the approve button will be replaced by a blue button that indicates the number. You can still approve the changes but we wanted to make sure you were aware of the outstanding work. When there are multiple reviewers, and approval is required from each, CodeStream makes it very clear when there are still outstanding approvals. The blue button at the top-right indicates how many approvals are outstanding, and the green “thumbs up” on the headshots of reviewers indicates those that have already approved. Adding more code changes A typical workflow involves the reviewer leaving some comments or suggesting some changes, and then the developer responding to that feedback with more changes to the code. To continue the process, click the blue Amend button to add your changes. As when you originally submitted the feedback request, you can choose from your saved and stages changes, and your local and pushed commits. Any open change requests are listed as well so that you can mark off any that are addressed by the update. When the reviewer goes back into the feedback request, by default they’ll be looking at the complete changeset (i.e., changes across all updates) as they go through the diffs for each file. They can, however, elect to view the diffs specific to any individual update. This process can continue across as many updates as needed to get to the ultimate approval of the changes. And once the feedback request has been approved, you can create a pull request, right from CodeStream, to get your code merged. Note that the feedback request may not be amended or reopened once a pull request has been created.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 269.7088,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Request feedback on <em>CodeStream</em>",
        "sections": "Request feedback on <em>CodeStream</em>",
        "body": " of your work, by clicking on the &quot;+&quot; button at the top of the <em>CodeStream</em> pane, or the &quot;+&quot; button in the header of the Feedback Requests section. You can also use a <em>keyboard</em> <em>shortcut</em> (ctlr+shift+&#x2F; r, or ctrl+&#x2F; r on a Mac). With a single click you can name the feedback request based on the last commit"
      },
      "id": "6174403d28ccbc9b20c6cca0"
    },
    {
      "image": "https://docs.newrelic.com/static/dd18b67123e9d4b7d40b56a8653a1f6b/f96db/OpenPullRequest1.png",
      "url": "https://docs.newrelic.com/docs/codestream/how-use-codestream/pull-requests/",
      "sections": [
        "Manage pull requests on CodeStream",
        "Creating a pull request",
        "Reviewing a pull request",
        "Leveraging pull request comments"
      ],
      "published_at": "2021-10-24T21:18:51Z",
      "title": "Manage pull requests on CodeStream",
      "updated_at": "2021-10-23T17:01:57Z",
      "type": "docs",
      "external_id": "7e35f2ff4f06799fe492ffb6b2fedbb52e898b69",
      "document_type": "page",
      "popularity": 1,
      "body": "For most development teams, the final step in the development process is a pull request. Even if your team has decided to use CodeStream's feedback requests as a replacement for, and not just a precursor to, your end-of-cycle PR-based code reviews, CodeStream allows you to keep all of that workflow right in your IDE. There are three elements of CodeStream's pull-request integration, and the following table outlines which code-hosting services are supported for each. Feature Supported Services Create a pull request GitHub, GitHub Enterprise, GitLab, GitLab Self-Managed, Bitbucket, Bitbucket Server Create a pull request across forks GitHub, GitHub Enterprise, GitLab, GitLab Self-Managed Review and edit a pull request GitHub, GitHub Enterprise, GitLab, GitLab Self-Managed Display pull request comments as code annotations GitHub, GitLab, Bitbucket Creating a pull request Open a pull request at any time by clicking on the \"+\" button at the top of the CodeStream pane, or the \"+\" button in the header of the Pull Requests section. You can also use a keyboard shortcut (ctlr+shift+/ p, or ctrl+/ p on a Mac... and you can use m if you're a GitLab user). CodeStream even provides you with different options (tree view, list view, diff hunks) for reviewing your changes before opening the pull request. With a single click you can name the pull request based on the last commit message, the branch name, or, if you started work by selecting a ticket, the ticket title. If you have a ticket selected, you can also explicitly tie the ticket to the pull request, and CodeStream will include a link to the ticket in the pull request's description. Before submitting the pull request you can even review your changes by clicking on any of the files listed below the form. To create a pull request across forks, click on the \"compare across forks\" link at the top of the page and the form will update to allow you to select both the base and head repositories. You can also create a pull request from within a CodeStream feedback request. Once the feedback request has been approved, you’ll see an option to open a pull request at the top. Before you can create a pull request you’ll need to make sure that any changes included in the feedback request have been committed and pushed. Also, if the feature branch you’re working on doesn’t have a remote tracking branch you’ll be given the option to set that as part of creating the pull request. When you create a pull request from a feedback request, CodeStream connect's the dots between the two by adding a link to the pull request to the feedback request. And by adding a link to the feedback request, along with information about who did the review and when, in the description of the pull request. Reviewing a pull request The ability to review pull requests is currently not available for Bitbucket. Regardless of where the pull request was created, you can edit, review, and even merge it, right from CodeStream. We've essentially brought GitHub and GitLab right into your IDE, so there's zero learning curve. If you know how to work with pull requests on GitHub or GitLab, you'll know how to do it in CodeStream as well. Edit a GitHub pull request's details, such as reviewers, assignees and labels. For a GitLab merge request, you can use edit mode (via the dropdown at the top of the page) or use the sidebar. By default, you can only add a single reviewer and a single assignee to a GitLab merge request. If your organization supports multiple reviewers and assignees, click the gear menu in the heading of the Merge Requests section of the CodeStream pane to enable this. Review the conversation and add comments, with the ability to @mention your collaborators. View the changes, add comments, and submit a review. Of course, we did improve upon the GitHub/GitLab experience in a couple of important ways. On GitHub and GitLab you can only view the changes as a series of \"diff hunks\". CodeStream provides that view as well, but if you'd prefer to see the changes in the context of the full file, and not just the lines that changed, you can use either List View or Tree View. Just select the code you want to comment on, and then click on the Comment button (or select Comment from the context menu). When commenting you can either add a single comment, or start a review. Another difference is that CodeStream allows you to comment on lines of code that haven't changed. You can select ANY lines of code in the diff, and not just those that are part of the changeset. Note that these comments are added as a \"single comment\" to the pull request and aren't part of any review you may have in progress. All the power of GitHub pull requests and GitLab merge requests, and then some, right in your IDE. Leveraging pull request comments Once the pull request has been approved and the code has been merged that's usually the end of life for any comments in that pull request. Although there is often useful information in those comments, that may have long-term value, they are rarely seen again. CodeStream gives those comments a second life by displaying them alongside the blocks of code that they refer to. To have pull request comments displayed as annotions in your codemarks, as well as in the Codemarks section of the CodeStream pane, click on the gear icon in that section and check the box to \"Show comments from pull requests\". When you first check that box, if you haven’t already authenticated with your code-hosting service you’ll be prompted to do so. Comments from merged PRs will appear next to the blocks of code they refer to. Comments from open PRs will also be included if you are on a relevant branch. For example, if the open PR is a request to merge the feature/some-name branch into main, you’ll see comments from that PR if you are checked out to either feature/some-name or main, but not when you’re on any other branch. As the code evolves, the location of each comment is automatically updated so that it remains linked to the block of code it refers to. Note that PR comments for a given file are updated roughly every 30 minutes, so new comments may not appear right away. You can force an update by restarting your IDE.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 259.51114,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage pull requests on <em>CodeStream</em>",
        "sections": "Manage pull requests on <em>CodeStream</em>",
        "body": " at any time by clicking on the &quot;+&quot; button at the top of the <em>CodeStream</em> pane, or the &quot;+&quot; button in the header of the Pull Requests section. You can also use a <em>keyboard</em> <em>shortcut</em> (ctlr+shift+&#x2F; p, or ctrl+&#x2F; p on a Mac... and you can use m if you&#x27;re a GitLab user). <em>CodeStream</em> even provides you"
      },
      "id": "61744006196a67ee542f0555"
    }
  ],
  "/docs/codestream/codestream-ui-overview/codestream-sidebar": [
    {
      "image": "https://docs.newrelic.com/static/e8d42feaa627a4f1abd362c85a07596d/c1b63/example-doc-in-folder.png",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/understand-edit-docs-site-structure/",
      "sections": [
        "Understand and edit docs site structure (nav file, sidebar, categories)",
        "Terms",
        "Understand how the docs site structure works",
        "How is the displayed structure related to the actual folders?",
        "What determines a doc's URL?",
        "What does a nav file do?",
        "Where is the docs site structure exposed?",
        "What determines a doc's sidebar?",
        "When you click a sidebar category, what determines how that auto-index page displays?",
        "Nav file format",
        "Tip",
        "Procedures",
        "Overview of steps for a large docs site restructure project",
        "Add a new category",
        "Add a new nav file",
        "Add a new category to a nav file",
        "Add a doc to sidebar/nav-file",
        "Add doc in multiple sidebar locations",
        "Move docs to other categories",
        "Move docs using nav file",
        "Move docs between folders",
        "Move or delete a folder",
        "Create a \"dummy\" sub-category of docs that don't live in that category",
        "Make a sidebar category heading clickable",
        "Troubleshoot category views not working correctly"
      ],
      "published_at": "2021-10-24T19:49:09Z",
      "title": "Understand and edit docs site structure (nav file, sidebar, categories)",
      "updated_at": "2021-10-24T19:49:09Z",
      "type": "docs",
      "external_id": "5498c89c5d5497ac899f70f86bb8bf0cda4bc840",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc contains information and procedures pertaining to the structure of the docs site, including: the nav files, the sidebar, docs category (index) views, and more. For succinct instructions, see Procedures, but it is highly recommended you understand the general concepts of how the docs site structure works if you will be doing larger docs site projects. Terms When talking about the docs site structure, sometimes people use different words for the same things. Below is a list of terms that can help us communicate about the docs site structure: Nav files: In the github docs site, there are yaml files under the nav folder that are used to determine the docs site structure that we display. This structure is exposed in the docs site left sidebar and when you view docs category views (also known as index views, like this one). Folder: In this context, \"folders\" refers to the actual docs site folder structure (those folders and files in the content section). Referring to \"folders\" can be a helpful way to differentiate between the actual folder structure and the displayed structure that's set using the nav files. Sidebar: On public-facing docs, the sidebar is what is visible on the left hand side, showing the structure of that category of docs. The sidebar and index view are both determined by the structure set in the nav file. Category or sub-category: we use these words a bit interchangeably to refer to specific areas of the docs site. For example, this view shows a list of docs in a specific category, as does this higher level category view. In this doc, we'll often use the phrase \"category view\" to indicate a page load of a specific category of docs. Auto-index pages: This is another way, the more technical way, to refer to a category view of docs (for example, this view). \"Auto-index page\" and \"category view\" are used a bit interchangably in this doc, with \"category view\" being used as it's more informal and easy to parse. (Note that this use of \"index\" is a different use of \"index\" than the authored index.mdx files, which are used to display landing pages.) Understand how the docs site structure works This section will explain some of the logic behind how the docs site structure is determined and how the structure we display to the public relates to the actual docs folder structure. How is the displayed structure related to the actual folders? The actual docs folder structure (the folders and mdx files in the content folder) is entirely separate from the docs site structure that we display (e.g., the structure shown in the sidebar and auto-index pages like this one). The displayed structure of the docs site is determined solely by the nav files (the yaml-format files in the nav folder). It's important to understand the above point. The divergence of the docs folder structure and the displayed docs site structure is necessary: we need a way to control the displayed site structure, which is used for the sidebar and auto-index pages, without requiring us to keep the folder structure and folder names and doc file names completely parallel and matching. Because these two things are so separate, it means we have some fairly complex behind-the-scenes logic to get them to work together. And this means that there can be fairly unintuitive aspects of how that logic works. We do have procedures for common use cases, but it will help you a lot to understand the specifics below of how the displayed structure is generated. What determines a doc's URL? Where a doc file (mdx file) is located in the content folder, and the associated folder and file names, are the only factors that govern that doc's URL. For example, consider the following doc file automated-user-provisioning-single-sign.mdx: This doc's URL is solely based on its folder location and the names of the folders. In this case, its URL is: docs.newrelic.com/docs/accounts/accounts/automated-user-management/automated-user-provisioning-single-sign Copy This has important implications, including: When you move a doc from one folder to another, its URL changes, and this means that you will have to add a redirect to that doc of its original URL. If you rename an mdx file name or a folder name, that changes its URL, so that means you would have to add a redirect to that doc for its original URL. What does a nav file do? The nav files are quite simple. A nav file controls these things: The docs structure (the various levels of docs) for that category of docs. The category headers, set by title (e.g., \"On-host integrations list\") and path (e.g., \"/docs/integrations/on-host-integrations\"). The doc information, set by title (e.g., \"NGINX integration\") and path (the doc's URL). A category and a doc in a nav file have the same elements: a title and a `path. What separates a category from a doc is that: A category contains docs in the level below it. If a category has a path (which isn't required but should be present for most docs), the path points to a content docs folder that has at least one doc in it. For more on nav file format, see Nav file format Where is the docs site structure exposed? The structure set in the nav files is exposed in two places: The left sidebar of a doc that shows the structure of that category. When a category header in the sidebar is clicked, it shows a view of that docs site category. Doc category views, also sometimes called auto-index pages: for example, this view, which shows a particular section of docs. What determines a doc's sidebar? As stated above, the sidebar is just one way that the docs site structure governed by the nav files is exposed. When a doc is loaded, the docs site searches for that URL in the nav files. If it finds a match, it displays that nav file in the sidebar with that doc highlighted. If it finds that doc in more than one nav file, it attempts to find the right nav file by choosing the nav that matches the top level category in the doc URL. For example, if a doc with a relative URL /docs/accounts/accounts-billing/account-setup/create-your-new-relic-account was in two nav files, the docs site code would search to see if one of the nav files has docs/accounts as its first path field. If it finds a match, it uses that nav file. For an example of a doc that is placed in two different nav files, for this auto-index page click the Manage data doc and see how, when it loads, it displays the sidebar for the nav file that better matches its URL. When you click a sidebar category, what determines how that auto-index page displays? When you click on a docs category header in the sidebar and an auto-index page loads (like this one), what governs what is displayed there? Here is how this process works: A category header in the sidebar has an associated URL, which is set in the nav file. In the example nav file snippet below, the Get started category view has a path set to /docs/apis/intro-apis. This is what governs the sidebar heading title of \"Get started\" and tells it the URL to use. - title: APIs path: /docs/apis pages: - title: Get started path: /docs/apis/intro-apis pages: - title: New Relic APIs path: /docs/apis/intro-apis/introduction-new-relic-apis - title: API keys path: /docs/apis/intro-apis/new-relic-api-keys Copy If the associated folder of that path has an index mdx file (representing a landing page, like this one), the docs site displays that landing page. If there is no landing page, we display the docs and structure contained in that section of the nav file. For example, this view is based on the nav file section under that category header. For this to work correctly, the docs site verifies that that path matches an actual docs site folder that has at least one mdx file. Put another way: if we used a completely arbitrary URL path for a category's path, like docs/random-category/random-category-2, it would not work. To display a nav file, the path requires an existing folder with at least one doc in there. Other aspects to consider: A path is not required. A category header in the nav file does not require a path; that is just what tells it to create a link and a URL for that view. If a category in a nav file lacks a path, it won't have a link or associated URL for it (for an example, see the \"New Relic University\" category in this section). Having a category without an associated link/URL can be an acceptable choice if you are creating a category of docs that don't reside in that section and you simply want to give a helpful category view in the sidebar. Folder structure URLs aren't important. Every folder in the docs site can be the basis for a URL, but we should only consider valuable the URLs we've chosen for inclusion in the nav files. For example, here's a URL based on an actual folder containing one doc. But because there is no path in a nav file corresponding to that URL, it doesn't display anything. Nav file format Below is a snippet of the agents.yml nav file. Note that the file has indentation that corresponds to the level of the navigation hierarchy. When making changes or creating a new nav file, be sure to use the existing spacing format. yml title: Agents path: /docs/agents pages: - title: Manage APM agents path: /docs/agents/manage-apm-agents pages: - title: Agent data path: /docs/agents/manage-apm-agents/agent-data pages: - title: Real time streaming path: /docs/agents/manage-apm-agents/agent-data/real-time-streaming - title: Custom instrumentation path: /docs/agents/manage-apm-agents/agent-data/custom-instrumentation - title: Agent attributes path: /docs/agents/manage-apm-agents/agent-data/agent-attributes - title: Custom events path: /docs/agents/manage-apm-agents/agent-data/collect-custom-events - title: Custom metrics path: /docs/agents/manage-apm-agents/agent-data/collect-custom-metrics - title: Manage errors path: /docs/agents/manage-apm-agents/agent-data/manage-errors-apm-collect-ignore-or-mark-expected - title: Link Kubernetes path: /docs/agents/manage-apm-agents/agent-data/link-your-applications-kubernetes - title: App naming pages: - title: Name your application path: /docs/agents/manage-apm-agents/app-naming/name-your-application - title: Use multiple names for an app path: /docs/agents/manage-apm-agents/app-naming/use-multiple-names-app Copy Tip Navigation nesting is currently limited to a maximum of six levels deep. Please reach out to the engineering team if that is not enough. Here are important elements of the nav file: Key Required? Description title yes The text shown in the navigation, either of a doc or a category. path yes The URL path to the doc or the category view. Do not use trailing slashes. For docs categories in the nav file, the path is required to create an index view. Without the path, a docs category won't be clickable as a link and won't display a view of those docs. Learn more about index views. rootNav no rootNav controls whether a nav file will be displayed or hidden on the docs site home page. It is enabled by default. If you want to hide a category from the home page (as we do for our style guide docs, for example), you would set this to false, as shown below: title: Style guide path: /docs/style-guide Copy children no This is hardly ever used. It indicates a sub-navigation node. Procedures Below are instructions for several common procedures. It may help you to review the terms we use before starting a procedure. Procedures include: Add a new docs category Add a doc to sidebar/nav-file Move docs between folders or categories Move or delete folders Create a \"dummy\" category for docs that don’t live in that area Make a category heading clickable Troubleshoot messed up category views Overview of steps for a large docs site restructure project For some smaller docs site edits, you can sometimes simply edit the nav files and not have to touch the doc files or folders. But for larger projects, you may want to or need to edit and move the docs files and folders themselves. Below is a broad overview of the chunks of work such larger projects generally entail. Plan out what the new nav file structure will look like, and plan out the work of moving docs files or creating new folders. It can help to write down the chunks of work a large project will entail. Move the affected doc files to their new folder locations, making sure to add redirects. For more on that, see Move docs between folders. Delete any empty folders. Edit the nav files to reflect the new desired structure and point to the new doc URLs. If there are category header path URLs that are no longer needed, add those URLs as redirects to specific docs (preferred) or the taxonomy redirects file. For more specific and granular procedures, keep reading. Add a new category We'll explain two procedures: adding a subcategory of docs in an existing nav file, and adding an entirely new nav file. Add a new nav file Adding an entirely new nav file should be rare, and something we only do occasionally during large overhauls of site structure. To add an entirely new nav file: Copy an existing file nav file, or create a new nav file. Customize the new nav file with the categories and docs you want, using the structure of existing nav files as a template. For more on structure, see nav format. Tip You need at least one level of nesting inside the nav file. Without that, doc titles in the auto-generated category views will render as H2 headings. For example, src/content/level-one/level-two/doc will work, but src/content/level-one/doc will produce strange formatting. Add a new category to a nav file To add a new category to a nav file: In an existing nav file, add a new category, represented by its title and path. If you're adding a path for that category (recommended), it must use the URL of an existing folder with at least one mdx file in it. Add the docs you want in that section. Ensure your new content matches the indenting of the surrounding nav file. To learn more about how this works, see: How a doc's sidebar is determined How a doc category view is determined If a category view isn't clickable, see Make category view clickable. Add a doc to sidebar/nav-file Once you create a doc, you need to place it in one or more nav files. To do this: In the nav file location where you want to locate it, add the title (its short title displayed in the sidebar and category views) and the path, which is the doc's URL. Ensure that you've emulated the indenting based on the surrounding nav file content or other nav files. Add doc in multiple sidebar locations To add a doc in more than one sidebar location, simply add that doc (its title and path) wherever you want it to be in the nav file. For more on how the sidebar is determined for docs in multiple nav files, see Sidebar. You can add a doc URL in multiple nav file locations. Move docs to other categories Because the nav file and the actual folder structure aren't connected, there are two different ways to \"move docs\": Move a doc in the nav files: preferred and most common procedure. Move a doc between folders: less frequent, mainly when doing larger projects where we want to do a significant overhaul of the docs structure and want to ensure the folder structure doesn't become too divergent from the nav file structure. Move docs using nav file You would move a doc in the nav file when you want to change its location in the displayed docs site structure (i.e., the sidebar and docs category views). To move a doc from one place to another in the nav file: In the first nav file, copy the two rows representing that doc's entry (the title and path lines) and paste that content into the place you want it to live in the new nav file. In the new nav file section, make sure that new content is aligned properly with the surrounding nav file content. See Nav format for more about nav file structure. Move docs between folders Note that moving docs between the folders should be relatively rare. The main reasons to do this are when the folder structure and nav file structure are becoming very different, which can be bad for a couple reasons: Too much divergence can create issues with category view displays or sidebar actions. Too much divergence can make finding and editing docs harder, so there can be value to keeping things fairly up to date and parallel. When you move a doc between folders or rename a doc, that changes its URL. Similarly, if you rename a folder, that changes the URL of all docs in that area. To move a doc between folders: Get the current URL of the doc you want to move and add that URL to its own list of redirects. Tips: One way to do this in VSCode is to right click the file and click \"Get relative path\". If you are moving many files, ask the team about ways to programmatically add redirects. Remove the trailing slash. Move the doc to the new folder. Update nav files with the new URL. This is easily overlooked but having the correct doc URL in the nav file, and not a redirect, is important. Note that a doc URL may be in more than one nav file so searching the site for that URL can help. Move or delete a folder Sometimes when we are doing a larger restructuring project, we may want to move or delete the actual folders instead of simply editing the nav files. If you are moving an entire folder or multiple folders to another folder, docs and all: Simply move these folders using your preferred method (e.g., using drag and drop) to the new location. Next, because that move changes all the URLs of the docs and categories, you'll need to add redirects: For adding redirects for docs, see the procedures for moving a doc between folders. For category redirects: For the section of the nav file affected by your folder editing, gather all the category URLs (path fields) that relate to the moved or deleted folders. We don't need to redirect all folder-related URL paths: we only need to redirect the nav file paths because those represent the paths that we actually link to in the docs (in other words: we aren't using folder-based URLs if they don't have a nav file path). Add those category path URLs as redirects in specific docs or, if that won't work, in the taxonomy-redirects file. We should aim to add category redirects in specific docs and the reason for this is that the taxonomy-redirects file is hard to use and because it's a better customer experience to land on a doc versus a category if possible. In most cases, you'll be able to find a fitting doc to redirect to but if only a category view makes sense, use the taxonomy redirects file. For larger projects, this can be tough work, so you'll want to check out the build and make sure all the sidebar links and category headers are working as expected. For deleting folders, you'll want to essentially follow the same steps as above: either moving or deleting the docs in those folders first, gathering the affected category path URLs and adding them as redirects, adn then deleting the empty folders. Create a \"dummy\" sub-category of docs that don't live in that category Sometimes you want to create a category of docs that is there to help expose a related doc or set of docs. For example, in this view, we have added a category for 'New Relic University' even though that's not a doc that lives in that section; in this case, it's not even a doc on our site. In the example above, this 'New Relic University' category header is in regular text and not a link, and that's because it doesn't have a path set for it in the nav file. This also means that in the sidebar, this category header is not a clickable link and simply functions as a collapser/expander. This is acceptable if you don't mind it but below we explain how you can get a clickable category if you need it. To create a so-called \"dummy\" category: Add the category structure you want in the nav file. If you're okay not having a clickable category header, your new category doesn't require a path. If you want a clickable category header, you will need to use or create a folder that matches the new category path and that has at least one mdx file in it (details). In the nav file, add the title and path information for the docs you want in that new category. Test your new category to ensure it is working correctly. Make a sidebar category heading clickable If there's a sidebar category that's only acting as an expander/collapser and doesn't have a link, that's because it either a) doesn't have a path set in the nav file, or b) that path goes to a folder that doesn't have a doc in it. For more on this, see the instructions regarding clickable headers in the \"dummy\" category section. Troubleshoot category views not working correctly If a docs category view is not working correctly, review how category views are formed. If this does happen, get another opinion from another tech writer to make sure you're not missing something, as we should rarely have problems. One reason that a category view might not work is specifically for path URLs that are also landing pages. In this case, if that path is used in more than one location in the same nav file, the docs site can be confused about which category view to use. We may fix this with a coding fix but in meantime: consider pointing to other URLs and not that path, so that there's only one use of that path per nav file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.14645,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Understand and edit docs site structure (nav file, <em>sidebar</em>, categories)",
        "sections": "Understand and edit docs site structure (nav file, <em>sidebar</em>, categories)",
        "body": ": Add a new docs category Add a doc to <em>sidebar</em>&#x2F;nav-file Move docs between folders or categories Move or delete folders Create a &quot;dummy&quot; category for docs that don’t live in that area Make a category heading clickable Troubleshoot messed up category views <em>Overview</em> of steps for a large docs site"
      },
      "id": "612eff27e7b9d25b16b6f24c"
    },
    {
      "image": "https://docs.newrelic.com/static/8945e0a9c512b8638ebf8165d47aee04/69902/QS-SignUp3.png",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/codestream-user-guide/",
      "sections": [
        "CodeStream user guide",
        "Quick Start",
        "1. Install the CodeStream extension in your IDE and sign up.",
        "2. Connect your tools",
        "3. Discuss any block of code, at any time",
        "4. Get feedback on your work in progress",
        "5. Create or review a pull request",
        "Help & Feedback"
      ],
      "published_at": "2021-10-24T21:19:37Z",
      "title": "CodeStream user guide",
      "updated_at": "2021-10-23T17:07:02Z",
      "type": "docs",
      "external_id": "fa9af0118a8872fea89fda91482c44fb69913ea2",
      "document_type": "page",
      "popularity": 1,
      "body": "Quick Start Use the navigation to the left to jump straight to any topic. Otherwise, read on to get started with CodeStream. 1. Install the CodeStream extension in your IDE and sign up. Install CodeStream for VS Code, Visual Studio or JetBrains. The CodeStream pane should automatically appear in the sidebar for VS Code, or in a tool window at the right side for a JetBrains IDE or Visual Studio. Click on \"Sign Up and Create a team\" if you are the first person from your team to join CodeStream, or paste in your invitation code if you were invited to a team already on CodeStream. Learn more about how to use CodeStream. 2. Connect your tools Create and review pull requests on GitHub, GitLab or Bitbucket. Create issues on Jira, Trello, and other issue trackers. Share code discussions on Slack or Microsoft Teams. CodeStream brings the tools you use every day together in your IDE. Click on your headshot at the top of the CodeStream pane and go to the Integrations page to get all of your tools connected. 3. Discuss any block of code, at any time Whether you're trying to understand someone else's code or getting help with some code you just wrote, just select the code and ask your question. Learn more about discussing code. 4. Get feedback on your work in progress Select \"Request Feedback\" from the \"+\" menu at any time in the development cycle, whether it’s a quick look over some work in progress (even uncommitted code!) or a formal review of a completed effort. Teammates can review your changes right in their IDE, with no need to switch branches or set aside their own work. Learn more about feedback requests. 5. Create or review a pull request Look for the Pull Requests section of the CodeStream sidebar to review an open pull request. Just click on a pull request (or load one from URL) to get a complete GitHub experience right in your IDE! Note that you can create a pull request in GitHub, GitLab or Bitbucket, but support for reviewing pull requests is currently only available for GitHub (cloud or Enterprise). Learn more about pull requests. Help & Feedback Report a bug or send a suggestion in GitHub issues. Contact us directly at support@codestream.com. Follow @teamcodestream for product updates and to share feedback and questions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.56328,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " in the <em>sidebar</em> for VS Code, or in a tool window at the right side for a JetBrains IDE or Visual Studio. Click on &quot;Sign Up and Create a team&quot; if you are the first person from your team to join CodeStream, or paste in your invitation code if you were invited to a team already on CodeStream. Learn more"
      },
      "id": "61744137e7b9d2428b13c6a0"
    },
    {
      "image": "https://docs.newrelic.com/static/c1b964985880261f094399e10af5773a/1efb2/MSTCSSigninPage.png",
      "url": "https://docs.newrelic.com/docs/codestream/codestream-integrations/msteams-integration/",
      "sections": [
        "Microsoft Teams and CodeStream",
        "Connecting to Microsoft Teams",
        "Participating from Microsoft Teams",
        "Open in IDE",
        "Open on GitHub (or Bitbucket or GitLab)"
      ],
      "published_at": "2021-10-24T21:15:03Z",
      "title": "Microsoft Teams and CodeStream",
      "updated_at": "2021-10-23T17:02:53Z",
      "type": "docs",
      "external_id": "6aa93f89e0a2de618a36e82930fcb23d72eb1321",
      "document_type": "page",
      "popularity": 1,
      "body": "When you post a codemark your teammates will get notified via the activity feed, and potentially via email. Sometimes, though, you might want to share to Microsoft Teams as well. This would allow you to reach people who haven’t yet joined CodeStream, or maybe don’t spend a lot of time in their IDE. Connecting to Microsoft Teams Click here to install the CodeStream app or go to \"Apps\" in your Teams sidebar and search for CodeStream. Once installed you should see the following popup for the CodeStream app, click on the Add button. Note, do not expand it and select the options to add to team or chat. Simply click Add. This will take you to your private chat with the CodeStream bot, and you’ll see the CodeStream logo appear in the Teams sidebar. Type signin in this chat and submit. A post from the bot will appear in the stream, along with a “Sign in” button. Click the button and you’ll be taken to the web and prompted to sign into CodeStream. After signing in you’ll be provided with a token that you’ll need to copy and paste into your chat with the CodeStream bot back in MS Teams. Paste the token into the chat and submit. Go to a channel in which you’d like to share, type @, and then select Get bots from the popup. Select the CodeStream bot from the list (and search for it if you need to), and then click \"Add\". Now return to the channel and @mention the CodeStream bot with the connect command. Repeat this in any channel that you'd like to share to. Once you get the following confirmation, you’re ready to share to Teams from CodeStream. When you return to CodeStream you'll now be able to share to the channels that you just connected. Participating from Microsoft Teams When you share to Teams, not only does it notify your teammates about the codemark, but they can use it to jump directly into their IDEs to participate in the conversation on CodeStream. Open in IDE Click “Open in IDE” to view both the code, and the discussion, right inside your IDE. You’ll be first taken through a CodeStream web page where you’ll specify which IDE to open, and CodeStream will remember this selection for the next time you view a discussion from the same repository. You’ll then be taken to the appropriate source file in your IDE, scrolled to the relevant block of code, with the discussion displayed in the CodeStream pane. If you don’t happen to have the given repository open in your IDE, CodeStream will automatically open the source file for you (assuming you’ve opened that repository previously, with CodeStream installed, so that we know where to find it). Note that if you’re using a JetBrains IDE you’ll need to first install the Toolbox App so that CodeStream can deep link into the IDE. Open on GitHub (or Bitbucket or GitLab) If the code block is from a repository hosted on GitHub, Bitbucket or GitLab, this button will take you to the corresponding block of code on that hosting service.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 84.28519,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ". Connecting to Microsoft Teams Click here to install the CodeStream app or go to &quot;Apps&quot; in your Teams <em>sidebar</em> and search for CodeStream. Once installed you should see the following popup for the CodeStream app, click on the Add button. Note, do not expand it and select the options to add to team"
      },
      "id": "6174403d196a678e4e2f271d"
    }
  ],
  "/docs/codestream/codestream-ui-overview/feedback-requests-section": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/what-is-codestream/",
      "sections": [
        "What is CodeStream?",
        "Discuss code just like commenting on a Google Doc",
        "Get feedback on work-in-progress with pre-PR code review",
        "Create and review pull requests",
        "Build the knowledge base behind your codebase"
      ],
      "published_at": "2021-10-24T21:21:10Z",
      "title": "What is CodeStream?",
      "updated_at": "2021-10-23T17:05:39Z",
      "type": "docs",
      "external_id": "0b3f4199050df98161ce8c46259a8bad30269d72",
      "document_type": "page",
      "popularity": 1,
      "body": "CodeStream is a developer collaboration platform that makes it incredibly easy for development teams, especially remote teams, to discuss and review code in a more natural and contextual way. CodeStream not only makes discussions easier, by allowing them to happen in your IDE, in context, but also preserves the institutional knowledge that is currently being lost in Slack channels and emails. Discuss code just like commenting on a Google Doc Simply select a block of code and type your question or comment. Teammates can participate in the discussion right from their IDE, and you can optionally share the discussion on Slack or Microsoft Teams so teammates can participate from their chat clients as well. Get feedback on work-in-progress with pre-PR code review CodeStream's lightweight feedback requests let you have someone look over your changes regardless of the current state of your repo, without the friction of committing, pushing or issuing a pull request. Your teammates can review your changes right in their IDE, with full file context, and with no need to set aside their current work to switch branches or pull the latest. CodeStream’s feedback requests are so easy that you can start doing them throughout the development process instead of waiting until the end. You’re a few days into a sprint and have some work stubbed out? Maybe some work that hasn’t even been committed? Request feedeback on your work in progress so that you can identify and resolve issues early instead of saving those gotchas for when you need to get the code merged. Create and review pull requests For most development teams, the final step in the development process is a pull request. Even if your team has decided to use CodeStream's feedback requests as a replacement for, and not just a precursor to, your end-of-cycle PR-based code reviews, CodeStream allows you to keep all of that workflow right in your IDE. You can create pull requests, and review pull requests, right inside your IDE. Build the knowledge base behind your codebase CodeStream turns conversation into documentation by capturing all of the discussion about your code, whether it was from a pull request, a feedback request, or a code comment/issue, and saving it with your code. And the real magic is that the discussions are automatically repositioned as your code changes, even across branches. All with zero effort on your part. Previously discussed questions and issues that explain important decisions are now accessible right where you need them, when you need them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2491.9639,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What is <em>CodeStream</em>?",
        "sections": "Get <em>feedback</em> on work-in-progress with pre-PR <em>code</em> review",
        "body": " of saving those gotchas for when you need to get the <em>code</em> merged. Create and review pull <em>requests</em> For most development teams, the final step in the development process is a pull <em>request</em>. Even if your team has decided to use <em>CodeStream</em>&#x27;s <em>feedback</em> <em>requests</em> as a replacement for, and not just"
      },
      "id": "617440e3e7b9d2836c13c43c"
    },
    {
      "image": "https://docs.newrelic.com/static/595e873b1bfe20aa5d39a66adf18d0c9/f96db/RequestFeedback.png",
      "url": "https://docs.newrelic.com/docs/codestream/how-use-codestream/request-feedback/",
      "sections": [
        "Request feedback on CodeStream",
        "Requesting feedback",
        "Providing feedback",
        "Comments & Change Requests",
        "Adding more code changes"
      ],
      "published_at": "2021-10-24T21:19:37Z",
      "title": "Request feedback on CodeStream",
      "updated_at": "2021-10-23T17:02:53Z",
      "type": "docs",
      "external_id": "752fa4dd9516d616b763d1552836fc30a93ccc7b",
      "document_type": "page",
      "popularity": 1,
      "body": "CodeStream's Feedback Requests are powerful enough to use for traditional end-of-cycle code reviews, but at the same time they're so easy and flexible that you can use them throughout the development process to get quick feedback on your work in progress. Even if you haven't committed your changes! Traditional code review happens at the end of the development cycle, when you’re looking to get the changes merged. Not only are end-of-cycle code reviews much more burdensome on your teammates, but you run the risk of identifying issues so late in the game that you end up having to decide between blowing up your schedule or taking on technical debt. Whether you’re at the very beginning of a project, with just some stubbed out functions, are mid-way through a work in progress, or are ready for a final review of a finished project, CodeStream allows you to get feedback at any point during the development cycle. CodeStream handles the complexity of sharing your current status, including pushed commits, local commits, and staged and saved changes. Teammates can provide feedback right from their IDE, with no need to switch applications, and no need to switch branches or pull changes. By the time you get to that formal code review/pull request at the end of the development cycle, it’s far less painful and more of a formality because issues have been raised, discussed and resolved all along the way. Requesting feedback Request feedback at any time, regardless of the current state of your work, by clicking on the \"+\" button at the top of the CodeStream pane, or the \"+\" button in the header of the Feedback Requests section. You can also use a keyboard shortcut (ctlr+shift+/ r, or ctrl+/ r on a Mac). With a single click you can name the feedback request based on the last commit message, the branch name, or, if you started work by selecting a ticket, the ticket title. CodeStream assumes that you are requesting feedback on changes in the repo/branch of the file currently selected in your editor. If you have multiple repositories open in your IDE, you can change this via the repo dropdown at the very top of the form. Depending on your organization's settings, CodeStream may suggest some reviewers. Based on the commit history of the code being changed, the suggestions may even include someone that isn't yet on your CodeStream team (in which case they'd be notified via email). Hover over a reviewer’s name to see more details or to remove them. If multiple reviewers are assigned you may also have the option to determine whether any of them can approve the review, or if each one has to approve it individually. The Changed Files section lists all of the files that have been added, removed or modified. Click on any file to view a diff if you want to review your changes before submitting the feedback request. If you have a file that’s not suitable for review, such as a checked-in binary file, you can hover over any file and click the \"x\" to exclude that file from the feedback request. That file will be moved to a list below the form. Note that new files are, by default, excluded from the feedback request, but you can hover over their entry in the list and click \"+\" to add them. Hover over an excluded file and click on the trashcan to permanently exclude it from all future feedback requests. Permanently excluding files creates a .codestreamignore file in the repository. If you think your teammates will also want to exclude these files (e.g., a package-lock.json or other system-generated file), you can commit and push the file so that they can make use of it as well. The changes represented across the selected files are broken out into four different categories, allowing you to select exactly what you would like to include in the feedback request. This includes changes that haven't been pushed, or even committed! Saved Changes Staged Changes Local Commits Pushed Commits Note that commits are listed in descending order across the Local Commits and Pushed Commits sections, and unchecking the box for a commit will automatically uncheck the boxes for all preceding commits. In other words, the commits included in the feedback request must be consecutive. Only your commits are checked by default, but you can include any of them in your review. (Tip: Make sure the email address in your git configuration matches your CodeStream email address. Or set up a blame map to map your git email address to you CodeStream email address.) Lastly, you can optionally share the feedback request out to either Slack or Microsoft Teams. When you submit your feedback request, teammates will be notified via the activity feed, with anyone assigned as a reviewer being @mentioned so that they’ll also receive an email notification. Providing feedback The best part of CodeStream's feedback requests is that having your teammates look over your code doesn't put any extra burden on them. No need for them to set aside their own work to switch branches or pull changes, and no need to for them to leave their IDE. As long as they have the appropriate repo, they can simply open the feedback request and start reviewing the changes. Click on any file in the Changed Files section to review the changes. You’ll be presented with a diff in your editor, and you can step through the changes in the file using your IDE's native navigation or the up/down arrows in the Changed Files section. Note that for JetBrains IDEs, CodeStream doesn't currently support the \"Unified viewer\" for diffs. Just the \"Side-by-side viewer\". Typically, the diff will represent the changes in the branch associated with the feedback request (i.e., usually a feature/topic branch) against the base branch, at the point at which the feature branch was created. Note that with CodeStream diffs this may not always be the case since the developer may not have included all of their changes in the feedback request. As a result, the version of the files that the changes are being diff’ed against may, in fact, also include changes that aren’t in the base branch. This is important in order to provide continuity. Comments & Change Requests If you have a general comment about the changes, just add a reply to the feedback request's thread. But if you want to comment on the actual changes, just select some code from the right side of the diff and then click on the comment button that appears in the CodeStream pane next to your selection. You can also use a keyboard shortcut (ctlr+shift+/ c, or ctrl+/ c on a Mac) after selecting some code. Since you have the full file context, you aren’t limited to commenting on just the lines of code that changed. For example, you might notice another part of the file that needs work as well, or that you simply want to reference. Whether it’s a general comment or a comment on code, you can mark it a “change request” to let the developer know that it’s required before you’ll approve the changes. While you are providing feedback, you can even comment on files that are not part of the changeset, and they will get added as a reply to the review. This is helpful to be able to point your teammate to another location in the codebase that might be an example of a better way to do something. All of the change requests associated with the the feedback request are summarized in a section at the top, in addition to being part of the discussion thread. This is where they will get marked complete when the work is done. Look for the green and red buttons at the top to either approve the changes or request that additional changes be made. Note that if there are any open change requests, the approve button will be replaced by a blue button that indicates the number. You can still approve the changes but we wanted to make sure you were aware of the outstanding work. When there are multiple reviewers, and approval is required from each, CodeStream makes it very clear when there are still outstanding approvals. The blue button at the top-right indicates how many approvals are outstanding, and the green “thumbs up” on the headshots of reviewers indicates those that have already approved. Adding more code changes A typical workflow involves the reviewer leaving some comments or suggesting some changes, and then the developer responding to that feedback with more changes to the code. To continue the process, click the blue Amend button to add your changes. As when you originally submitted the feedback request, you can choose from your saved and stages changes, and your local and pushed commits. Any open change requests are listed as well so that you can mark off any that are addressed by the update. When the reviewer goes back into the feedback request, by default they’ll be looking at the complete changeset (i.e., changes across all updates) as they go through the diffs for each file. They can, however, elect to view the diffs specific to any individual update. This process can continue across as many updates as needed to get to the ultimate approval of the changes. And once the feedback request has been approved, you can create a pull request, right from CodeStream, to get your code merged. Note that the feedback request may not be amended or reopened once a pull request has been created.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1928.0747,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Request</em> <em>feedback</em> on <em>CodeStream</em>",
        "sections": "<em>Request</em> <em>feedback</em> on <em>CodeStream</em>",
        "body": " of your work, by clicking on the &quot;+&quot; button at the top of the <em>CodeStream</em> pane, or the &quot;+&quot; button in the header of the <em>Feedback</em> <em>Requests</em> section. You can also use a keyboard shortcut (ctlr+shift+&#x2F; r, or ctrl+&#x2F; r on a Mac). With a single click you can name the <em>feedback</em> <em>request</em> based on the last commit"
      },
      "id": "6174403d28ccbc9b20c6cca0"
    },
    {
      "image": "https://docs.newrelic.com/static/dd18b67123e9d4b7d40b56a8653a1f6b/f96db/OpenPullRequest1.png",
      "url": "https://docs.newrelic.com/docs/codestream/how-use-codestream/pull-requests/",
      "sections": [
        "Manage pull requests on CodeStream",
        "Creating a pull request",
        "Reviewing a pull request",
        "Leveraging pull request comments"
      ],
      "published_at": "2021-10-24T21:18:51Z",
      "title": "Manage pull requests on CodeStream",
      "updated_at": "2021-10-23T17:01:57Z",
      "type": "docs",
      "external_id": "7e35f2ff4f06799fe492ffb6b2fedbb52e898b69",
      "document_type": "page",
      "popularity": 1,
      "body": "For most development teams, the final step in the development process is a pull request. Even if your team has decided to use CodeStream's feedback requests as a replacement for, and not just a precursor to, your end-of-cycle PR-based code reviews, CodeStream allows you to keep all of that workflow right in your IDE. There are three elements of CodeStream's pull-request integration, and the following table outlines which code-hosting services are supported for each. Feature Supported Services Create a pull request GitHub, GitHub Enterprise, GitLab, GitLab Self-Managed, Bitbucket, Bitbucket Server Create a pull request across forks GitHub, GitHub Enterprise, GitLab, GitLab Self-Managed Review and edit a pull request GitHub, GitHub Enterprise, GitLab, GitLab Self-Managed Display pull request comments as code annotations GitHub, GitLab, Bitbucket Creating a pull request Open a pull request at any time by clicking on the \"+\" button at the top of the CodeStream pane, or the \"+\" button in the header of the Pull Requests section. You can also use a keyboard shortcut (ctlr+shift+/ p, or ctrl+/ p on a Mac... and you can use m if you're a GitLab user). CodeStream even provides you with different options (tree view, list view, diff hunks) for reviewing your changes before opening the pull request. With a single click you can name the pull request based on the last commit message, the branch name, or, if you started work by selecting a ticket, the ticket title. If you have a ticket selected, you can also explicitly tie the ticket to the pull request, and CodeStream will include a link to the ticket in the pull request's description. Before submitting the pull request you can even review your changes by clicking on any of the files listed below the form. To create a pull request across forks, click on the \"compare across forks\" link at the top of the page and the form will update to allow you to select both the base and head repositories. You can also create a pull request from within a CodeStream feedback request. Once the feedback request has been approved, you’ll see an option to open a pull request at the top. Before you can create a pull request you’ll need to make sure that any changes included in the feedback request have been committed and pushed. Also, if the feature branch you’re working on doesn’t have a remote tracking branch you’ll be given the option to set that as part of creating the pull request. When you create a pull request from a feedback request, CodeStream connect's the dots between the two by adding a link to the pull request to the feedback request. And by adding a link to the feedback request, along with information about who did the review and when, in the description of the pull request. Reviewing a pull request The ability to review pull requests is currently not available for Bitbucket. Regardless of where the pull request was created, you can edit, review, and even merge it, right from CodeStream. We've essentially brought GitHub and GitLab right into your IDE, so there's zero learning curve. If you know how to work with pull requests on GitHub or GitLab, you'll know how to do it in CodeStream as well. Edit a GitHub pull request's details, such as reviewers, assignees and labels. For a GitLab merge request, you can use edit mode (via the dropdown at the top of the page) or use the sidebar. By default, you can only add a single reviewer and a single assignee to a GitLab merge request. If your organization supports multiple reviewers and assignees, click the gear menu in the heading of the Merge Requests section of the CodeStream pane to enable this. Review the conversation and add comments, with the ability to @mention your collaborators. View the changes, add comments, and submit a review. Of course, we did improve upon the GitHub/GitLab experience in a couple of important ways. On GitHub and GitLab you can only view the changes as a series of \"diff hunks\". CodeStream provides that view as well, but if you'd prefer to see the changes in the context of the full file, and not just the lines that changed, you can use either List View or Tree View. Just select the code you want to comment on, and then click on the Comment button (or select Comment from the context menu). When commenting you can either add a single comment, or start a review. Another difference is that CodeStream allows you to comment on lines of code that haven't changed. You can select ANY lines of code in the diff, and not just those that are part of the changeset. Note that these comments are added as a \"single comment\" to the pull request and aren't part of any review you may have in progress. All the power of GitHub pull requests and GitLab merge requests, and then some, right in your IDE. Leveraging pull request comments Once the pull request has been approved and the code has been merged that's usually the end of life for any comments in that pull request. Although there is often useful information in those comments, that may have long-term value, they are rarely seen again. CodeStream gives those comments a second life by displaying them alongside the blocks of code that they refer to. To have pull request comments displayed as annotions in your codemarks, as well as in the Codemarks section of the CodeStream pane, click on the gear icon in that section and check the box to \"Show comments from pull requests\". When you first check that box, if you haven’t already authenticated with your code-hosting service you’ll be prompted to do so. Comments from merged PRs will appear next to the blocks of code they refer to. Comments from open PRs will also be included if you are on a relevant branch. For example, if the open PR is a request to merge the feature/some-name branch into main, you’ll see comments from that PR if you are checked out to either feature/some-name or main, but not when you’re on any other branch. As the code evolves, the location of each comment is automatically updated so that it remains linked to the block of code it refers to. Note that PR comments for a given file are updated roughly every 30 minutes, so new comments may not appear right away. You can force an update by restarting your IDE.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1617.3579,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage pull <em>requests</em> on <em>CodeStream</em>",
        "sections": "Manage pull <em>requests</em> on <em>CodeStream</em>",
        "body": "For most development teams, the final step in the development process is a pull <em>request</em>. Even if your team has decided to use <em>CodeStream</em>&#x27;s <em>feedback</em> <em>requests</em> as a replacement for, and not just a precursor to, your end-of-cycle PR-based <em>code</em> reviews, <em>CodeStream</em> allows you to keep all of that workflow"
      },
      "id": "61744006196a67ee542f0555"
    }
  ],
  "/docs/codestream/codestream-ui-overview/filter-search": [
    {
      "sections": [
        "CodeStream licenses"
      ],
      "title": "CodeStream licenses",
      "type": "docs",
      "tags": [
        "Licenses",
        "Product or service licenses",
        "CodeStream"
      ],
      "external_id": "331f3d1cd0897f453f98bc054fda09a9ad2725c1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/codestream/codestream-licenses/",
      "published_at": "2021-10-24T17:53:35Z",
      "updated_at": "2021-10-23T17:05:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We love open-source software, and we use the following with CodeStream. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we've chosen to use. CodeStream license on GitHub CodeStream's third-party software notices on GitHub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 643.0535,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> licenses",
        "sections": "<em>CodeStream</em> licenses",
        "tags": "<em>CodeStream</em>",
        "body": "We love open-source software, and we use the following with <em>CodeStream</em>. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we&#x27;ve chosen to use. <em>CodeStream</em> license on GitHub <em>CodeStream</em>&#x27;s third-party software notices on GitHub"
      },
      "id": "617440e2196a677ea62f0193"
    },
    {
      "image": "https://docs.newrelic.com/static/c1b964985880261f094399e10af5773a/1efb2/MSTCSSigninPage.png",
      "url": "https://docs.newrelic.com/docs/codestream/codestream-integrations/msteams-integration/",
      "sections": [
        "Microsoft Teams and CodeStream",
        "Connecting to Microsoft Teams",
        "Participating from Microsoft Teams",
        "Open in IDE",
        "Open on GitHub (or Bitbucket or GitLab)"
      ],
      "published_at": "2021-10-24T21:15:03Z",
      "title": "Microsoft Teams and CodeStream",
      "updated_at": "2021-10-23T17:02:53Z",
      "type": "docs",
      "external_id": "6aa93f89e0a2de618a36e82930fcb23d72eb1321",
      "document_type": "page",
      "popularity": 1,
      "body": "When you post a codemark your teammates will get notified via the activity feed, and potentially via email. Sometimes, though, you might want to share to Microsoft Teams as well. This would allow you to reach people who haven’t yet joined CodeStream, or maybe don’t spend a lot of time in their IDE. Connecting to Microsoft Teams Click here to install the CodeStream app or go to \"Apps\" in your Teams sidebar and search for CodeStream. Once installed you should see the following popup for the CodeStream app, click on the Add button. Note, do not expand it and select the options to add to team or chat. Simply click Add. This will take you to your private chat with the CodeStream bot, and you’ll see the CodeStream logo appear in the Teams sidebar. Type signin in this chat and submit. A post from the bot will appear in the stream, along with a “Sign in” button. Click the button and you’ll be taken to the web and prompted to sign into CodeStream. After signing in you’ll be provided with a token that you’ll need to copy and paste into your chat with the CodeStream bot back in MS Teams. Paste the token into the chat and submit. Go to a channel in which you’d like to share, type @, and then select Get bots from the popup. Select the CodeStream bot from the list (and search for it if you need to), and then click \"Add\". Now return to the channel and @mention the CodeStream bot with the connect command. Repeat this in any channel that you'd like to share to. Once you get the following confirmation, you’re ready to share to Teams from CodeStream. When you return to CodeStream you'll now be able to share to the channels that you just connected. Participating from Microsoft Teams When you share to Teams, not only does it notify your teammates about the codemark, but they can use it to jump directly into their IDEs to participate in the conversation on CodeStream. Open in IDE Click “Open in IDE” to view both the code, and the discussion, right inside your IDE. You’ll be first taken through a CodeStream web page where you’ll specify which IDE to open, and CodeStream will remember this selection for the next time you view a discussion from the same repository. You’ll then be taken to the appropriate source file in your IDE, scrolled to the relevant block of code, with the discussion displayed in the CodeStream pane. If you don’t happen to have the given repository open in your IDE, CodeStream will automatically open the source file for you (assuming you’ve opened that repository previously, with CodeStream installed, so that we know where to find it). Note that if you’re using a JetBrains IDE you’ll need to first install the Toolbox App so that CodeStream can deep link into the IDE. Open on GitHub (or Bitbucket or GitLab) If the code block is from a repository hosted on GitHub, Bitbucket or GitLab, this button will take you to the corresponding block of code on that hosting service.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 262.73993,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Microsoft Teams <em>and</em> <em>CodeStream</em>",
        "sections": "Microsoft Teams <em>and</em> <em>CodeStream</em>",
        "body": ". Connecting to Microsoft Teams Click here to install the <em>CodeStream</em> app or go to &quot;Apps&quot; in your Teams sidebar and <em>search</em> for <em>CodeStream</em>. Once installed you should see the following popup for the <em>CodeStream</em> app, click on the Add button. Note, do not expand it and select the options to add to team"
      },
      "id": "6174403d196a678e4e2f271d"
    },
    {
      "image": "https://docs.newrelic.com/static/74c274508fc745275751f72d3e01ea33/f96db/CodemarkAddRange1.png",
      "url": "https://docs.newrelic.com/docs/codestream/how-use-codestream/discuss-code/",
      "sections": [
        "Discuss code on CodeStream",
        "What is a codemark?",
        "Creating a codemark",
        "Comment Codemarks",
        "Issue Codemarks",
        "Bringing the right people into the discussion",
        "Different versions of the code?",
        "Resolving codemarks",
        "Advanced Features",
        "Multiple Ranges",
        "File Attachments",
        "Tagging",
        "Related codemarks",
        "Managing codemarks"
      ],
      "published_at": "2021-10-24T21:18:06Z",
      "title": "Discuss code on CodeStream",
      "updated_at": "2021-10-23T17:01:57Z",
      "type": "docs",
      "external_id": "9169c03142311fe838566856d0ff154df0e6d555",
      "document_type": "page",
      "popularity": 1,
      "body": "What is a codemark? Quite simply, a codemark is a discussion connected to the code. It could be a question, a suggestion, a bug report, or documentation. All of these discussions are saved, anchored to the blocks of code they refer to, so that they can be leveraged in the future. It could be a new developer joining the team, a developer trying to fix a bug in someone else’s code, or even just you trying to remember why you made that change six months ago… whatever the case, CodeStream helps you understand the code by surfacing the discussions in a contextual way. Even as a file changes over time, the codemarks will remain connected to the code. Add some new lines of code above the code block, make edits to the code, or even cut-and-paste the entire block to a different section of the file, and you’ll see the codemark move right along with the changes. Creating a codemark Create a codemark by selecting a block of code in your editor and then clicking on one of the icons that appears in the CodeStream pane next to your selection. If you're using a JetBrains IDE, such as IntelliJ, you can also create a codemark by using the \"+\" button that appears in the editor's gutter when you select a block of code. When you're viewing a diff, for either a feedback request or a pull request, the button will also appear when you hover in the gutter to make it easy to comment on a single line. Even when the CodeStream pane is closed or not in view, you can create a codemark via the CodeStream options in either the lightbulb or context menus. Lastly, you can also look for the \"+\" menu at the top of the CodeStream pane. Need to reach teammates that don’t spend a lot of time in the IDE? Or maybe some teammates that aren’t yet on CodeStream? You can optionally share a codemark out to Slack or Microsoft Teams. The Slack integration even allows your teammates to reply directly from Slack. Comment Codemarks The all-purpose codemark for linking any type of discussion to a block of code. Ask a question. Make a suggestion. Document some code. Make note of key sections of the codebase. The possibilities are endless! Issue Codemarks When something needs to get done there’s always a better chance of it happening if it’s captured as an issue, with someone’s name attached. Assign issues as a way of reporting bugs. Or manage your tech debt by capturing items as tracked issues instead of inline FIXMEs. If your team uses Asana, Azure DevOps, Bitbucket (cloud), Clubhouse, GitHub (cloud or Enterprise), GitLab (cloud or Self-Managed), Jira (cloud or Server), Linear, Trello, or YouTrack (cloud) for tracking issues, you can create an issue on one of those services directly from CodeStream. Just select the service you use from the dropdown at the top of the codemark form. After going through the authentication process with the selected service you'll now be able to select a destination for your issue. For example, with Jira you'll be able to select the appropriate issue type and project. Once the issue has been created on CodeStream, it will include a link to the issue that was created on the external service. In the example below you'll see the URL for the issue on Jira. And the issue on Jira includes a link to open the relevant code in your IDE. Bringing the right people into the discussion When you create a codemark, CodeStream automatically mentions the people that most recently touched of the code you are commenting on. They may be the best people to answer your question, but you can, of course, remove those mentions and manually mention someone else if appropriate. It may be the case that the people that have touched the code aren't yet on CodeStream, in which case CodeStream will provide checkboxes to have them notified via email. They can simply reply to the email to have their comment posted to CodeStream, and of course they can install CodeStream to participate from their IDE. Different versions of the code? Maybe you’re on a feature branch, have local changes, or simply haven’t pulled in a while. There are countless reasons why the code you’re looking at might be different than what a teammate is looking at, and as a result, there will be plenty of times when the code referenced in a codemark doesn’t match what you have locally. CodeStream recognizes these situations and includes the original version of the code block (i.e. at the time the codemark was created), the current version, and a diff. Keep in mind that with CodeStream you can discuss any line of code, in any source file, at any time, even if it’s code that you just typed into your editor and haven’t yet committed. CodeStream allows you to discuss code at the very earliest stages of the development process. Resolving codemarks Although not required, both comment and issue codemarks can be resolved. The Codemarks section of the CodeStream pane breaks out codemarks into Open, Resolved and Archived sections, and green, purple and gray icons are used to represent those different states. If you see a lot of Open/green codemarks in the codestream pane, that means that your teammates are being blocked by discussions and issues that haven't be resolved. You can add a comment at the same time your resolve the codemark, and you can also elect to archive the codemark at the same time. Advanced Features Multiple Ranges Many discussions about code involve more than just one block of code, and concepts are often best presented when you can refer to multiple code locations at once. Here are a few examples of multi-range codemark at work: A change to a function is being contemplated that will impact its name. Each instance of the function call can now be referenced in one discussion. A react component and its CSS styling aren’t interacting well, and you want to ask the team for input. You might select the div and the CSS rules you think should apply, so your teammates know exactly what you’re talking about. Clients which make API calls to the server might get an unexpected result. Select the code where you’re making the API call, and the handler in the API server, to connect the two actions together. To create a multi-range codemark, click on \"+ Add Code Block\". And then select another block of code from the same file, a different file, or even a different repo. You can intersperse the difference code blocks in your post by referring to each one as [#N] (or click the pin icon from one of the code blocks to insert the markdown for you), as in the following example. And here's how that example is rendered. Once you've created the codemark, you can easily jump between the different locations by clicking the Jump icon at the bottom-right of each code block. Note that when you edit a codemark you can add and remove code blocks, and you can change the location of any of the code blocks by clicking the dashed square icon. File Attachments Enrich your discussions about code by attaching files directly to code blocks. Think about how much more compelling your comments and documentation become when you... Attach a spec to guide the development of a new feature Attach a log file to help debug an issue in the code Attach a mockup to help clarify some UI work Attach a screenshot to highlight a problem When creating a code comment or issue, you can attach a file by dragging-and-dropping on the the description field, pasting from you clipboard, or by clicking the new paperclip icon. Images can even be displayed inline using markdown. Just click the pin icon to the right of the attachment, and CodeStream will insert the markdown for you. And now your teammate knows exactly what you’re looking for! You can click on files in the Attachments section to either download or open in the appropriate application. Tagging Look for the tag icon inside the codemark compose box to either select a tag or create a tag using any combination of color and text label. Tags are a great way to broadly organize and group your organization's codemarks, and the possibilities here are endless. Note that you can also filter by tag on the Filter & Search page. Related codemarks Click on the CodeStream icon in the codemark compose form to select other, related codemarks to “attach” to the current codemark. This allows you to easily establish a connection between different parts of a codebase. For example, when a change to one part of the codebase would require a change to another part, identify the dependency by creating two related codemarks. Once you’ve added the related codemarks they’ll be displayed in a “Related” section and you can click on any one to jump to that codemark and the corresponding section of the code. Managing codemarks Click on the ellipses menu for any codemark and you'll see options for managing the codemark. Share - In addition to sharing to Slack or Teams at the time you create a codemark, you can also share it anytime thereafter. Follow/Unfollow - Unfollow to stop receiving notifications for the codemark. Copy link - Get a permalink for the codemark to share it anywhere. Archive - If there’s a codemark that you don’t think is important enough to be on permanent display in a given file, but you don’t want to completely delete it, you can archive it instead. Settings in the codemarks section allow you to easily see all archived codemarks. Edit - Only the codemark's author can edit it. Delete - Only the codemark's author can delete it, but we encourage you to archive instead of delete unless you're positive the codemark won't have any future value. Inject as Inline Comment - If you'd like a specific codemark to become part of the repo use this option to have it added as an inline comment. You can select the appropriate format, and then indicate if you want to include timestamps, replies, or to have the comment wrapped at 80 characters. You can also elect to have the codemark archived once it's been added as an inline comment. Reposition codemark - In most cases, a codemark will automatically remain linked to the block of code it refers to as the file changes over time. For example, if you cut the block of code and paste it at a different location in the file, the codemark will move right along with it. There are some scenarios, however, that CodeStream isn't able to handle automatically. For example, if you pasted the block of code into a different file. In these cases, Reposition codemark allows you to select the new location of the block of code so that the codemark is displayed properly.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 261.53296,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Discuss <em>code</em> on <em>CodeStream</em>",
        "sections": "Discuss <em>code</em> on <em>CodeStream</em>",
        "body": " developer joining the team, a developer trying to fix a bug in someone else’s <em>code</em>, or even just you trying to remember why you made that change six months ago… whatever the case, <em>CodeStream</em> helps you understand the <em>code</em> by surfacing the discussions in a contextual way. Even as a file changes over"
      },
      "id": "6174400564441fe8685fd746"
    }
  ],
  "/docs/codestream/codestream-ui-overview/issues-section": [
    {
      "sections": [
        "CodeStream licenses"
      ],
      "title": "CodeStream licenses",
      "type": "docs",
      "tags": [
        "Licenses",
        "Product or service licenses",
        "CodeStream"
      ],
      "external_id": "331f3d1cd0897f453f98bc054fda09a9ad2725c1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/codestream/codestream-licenses/",
      "published_at": "2021-10-24T17:53:35Z",
      "updated_at": "2021-10-23T17:05:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We love open-source software, and we use the following with CodeStream. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we've chosen to use. CodeStream license on GitHub CodeStream's third-party software notices on GitHub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 643.0532,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> licenses",
        "sections": "<em>CodeStream</em> licenses",
        "tags": "<em>CodeStream</em>",
        "body": "We love open-source software, and we use the following with <em>CodeStream</em>. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we&#x27;ve chosen to use. <em>CodeStream</em> license on GitHub <em>CodeStream</em>&#x27;s third-party software notices on GitHub"
      },
      "id": "617440e2196a677ea62f0193"
    },
    {
      "image": "https://docs.newrelic.com/static/48721d72a10a277b2ef615b62a07f0fe/f96db/GitHubAuth.png",
      "url": "https://docs.newrelic.com/docs/codestream/troubleshooting/github-org-repos/",
      "sections": [
        "Why aren't PRs and issues from all my GitHub organizations listed in CodeStream?"
      ],
      "published_at": "2021-10-24T21:22:45Z",
      "title": "Why aren't PRs and issues from all my GitHub organizations listed in CodeStream?",
      "updated_at": "2021-10-23T17:09:23Z",
      "type": "docs",
      "external_id": "aa4cd2a3acc746bc90aa1cf6663335e36084c002",
      "document_type": "page",
      "popularity": 1,
      "body": "When you connect to GitHub you should see all of your open pull requests in the Pull Requests section of the CodeStream pane, as well as all issues assigned to you in the Issues section. If pull requests or issues from any of your GitHub organizations are missing, it's probably because at the time you authenticated with GitHub, you didn't grant access to all of your organizations. If you didn't click on that Grant button at authentication time, simply go to GitHub and navigate to Settings > Applications and click on the Authorized OAuth Apps tab. From there, click on the CodeStream application. On the following page, click the Grant button next to any organizations that you'd like to be able to access from CodeStream. Note that in some instances you'll see a Request button instead of Grant, which means that the owner of your GitHub organization will need to grant access.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 580.53815,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Why aren&#x27;t PRs and <em>issues</em> from all my GitHub organizations listed in <em>CodeStream</em>?",
        "sections": "Why aren&#x27;t PRs and <em>issues</em> from all my GitHub organizations listed in <em>CodeStream</em>?",
        "body": "When you connect to GitHub you should see all of your open pull requests in the Pull Requests section of the <em>CodeStream</em> pane, as well as all <em>issues</em> assigned to you in the <em>Issues</em> section. If pull requests or <em>issues</em> from any of your GitHub organizations are missing, it&#x27;s probably because at the time"
      },
      "id": "617441c3e7b9d2478513cf8c"
    },
    {
      "image": "https://docs.newrelic.com/static/ec73595e0bcde8b47ae3040cc556ddd1/f96db/NotificationSettings4.png",
      "url": "https://docs.newrelic.com/docs/codestream/codestream-integrations/notifications/",
      "sections": [
        "Notifications",
        "Other Notifications"
      ],
      "published_at": "2021-10-24T23:23:37Z",
      "title": "Notifications",
      "updated_at": "2021-10-23T17:03:49Z",
      "type": "docs",
      "external_id": "0af3b7458032e1b89f8e3cc7225d7c7b0272354a",
      "document_type": "page",
      "popularity": 1,
      "body": "CodeStream will notify you about comments, issues and feedback requests that you \"follow\", and you can choose whether you want to be notified via email, desktop (for the VS Code and JetBrains extensions only), or both. Look for the Notifications option under the headshot menu at the top of the CodeStream pane. By default, you are set to automatically follow any comment, issue or feedback request that you created, where you’ve been mentioned (either in the original post or in a subsequent reply), or to which you’ve replied. You can always elect to follow/unfollow any individual comment, issue or feedback request via its ellipses menu. Email notifications are sent immediately. You can participate in the discussion by simply replying to the email. Your reply will get added to CodeStream as reply to the appropriate comment, issue or feedback request. Be sure that when you reply you are doing so from the same email address to which the notification was sent (i.e., your email address on CodeStream). Also note that you can unfollow a codemark or code review by clicking the link at the bottom of the email. If you’re using CodeStream in VS Code or a JetBrains IDE you’ll also receive desktop notifications in the IDE for comment, issue or feedback request that you follow. Clicking on the Open button will open the discussion so that you can participate. Other Notifications CodeStream also offers the following notifications that can be turned on and off via the checkboxes at the bottom of the page. Notify me about outstanding feedback requests - You'll get an email reminder about open feedback requests assigned to you that you haven't responded to in the last 24 hours. Notify me about new unreviewed commits from teammates when I pull - Any time you pull, if there are new commits from a teammate on the current branch you'll get a toast notification. Click the \"Review\" button to start reviewing your teammate's changes and provide feedback. Send me weekly emails summarizing my activity - Sent every Monday with information about you and your organization's activity for the previous week. If you've connected to GitHub or GitHub Enterprise to leverage CodeStream's pull request integration you'll also be notified when a pull request is assigned to you or you are added as a reviewer. Clicking on the Open button will open the pull request right in your IDE where you can review the changes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 448.18536,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "<em>CodeStream</em> will notify you about comments, <em>issues</em> and feedback requests that you &quot;follow&quot;, and you can choose whether you want to be notified via email, desktop (for the VS <em>Code</em> and JetBrains extensions only), or both. Look for the Notifications option under the headshot menu at the top"
      },
      "id": "6174407564441f5c515fcf66"
    }
  ],
  "/docs/codestream/codestream-ui-overview/my-organization": [
    {
      "image": "https://docs.newrelic.com/static/490255cdad35ea9f73a5ec0877f086e6/f0991/MyOrgMenu.png",
      "url": "https://docs.newrelic.com/docs/codestream/how-use-codestream/my-organization/",
      "sections": [
        "Manage My Organization on CodeStream",
        "My Organization",
        "Invite Teammates",
        "Blame Map"
      ],
      "published_at": "2021-10-24T21:18:06Z",
      "title": "Manage My Organization on CodeStream",
      "updated_at": "2021-10-23T16:57:06Z",
      "type": "docs",
      "external_id": "a632afe14f3e14e73f7dca6f4e4fe64d4bfe14c5",
      "document_type": "page",
      "popularity": 1,
      "body": "The My Organization menu allows you to see who is in your CodeStream organization, invite new members, and create blame maps. My Organization Select \"My Organization\" to see a list of all members of your CodeStream organization. Admins will be identified in the list, and if you are an admin, you'll have a dropdown to assign or remove admin priviledges to any member. Invite Teammates Select \"Invite Teammates\" to invite new members to your organization. The \"Outstanding Invitations\" section lists all open invitations, and at the right side of each row are links to remove the invitation or to reinvite. Clicking \"reinvite\" will have CodeStream send another invitation via email, but you can also hover over the reinvite link for the option to generate an email yourself. The \"Suggested Teammates\" section, which is only available for admins, is a list of possible teammates derived from the commit history of your open repositories. At the right side of each row are links to remove the suggestion from the list or to invite the person. Blame Map Select \"Blame Map\" to add email addresses that you use for committing code that may be different from the email address you used to sign up for CodeStream. For example, your CodeStream email address might be dave@acme.com, but you might also commit code as dave@webmail.com. Click \"Add mapping\", enter your git email address, and then select your entry from the list of organization members. That way, when someone comments on code committed by dave@webmail.com, CodeStream will know to at-mention you (i.e., dave@acme.com). While non-admins can only create blame maps for themselves, admins can create blame maps for any member of the organization. This is useful for reassigning code ownership when people leave the organization.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2031.384,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Manage</em> <em>My</em> <em>Organization</em> <em>on</em> <em>CodeStream</em>",
        "sections": "<em>Manage</em> <em>My</em> <em>Organization</em> <em>on</em> <em>CodeStream</em>",
        "body": "The <em>My</em> <em>Organization</em> menu allows you to see who is in your <em>CodeStream</em> <em>organization</em>, invite new members, and create blame maps. <em>My</em> <em>Organization</em> Select &quot;<em>My</em> <em>Organization</em>&quot; to see a list of all members of your <em>CodeStream</em> <em>organization</em>. Admins will be identified in the list, and if you are an admin, you&#x27;ll"
      },
      "id": "61743ee2e7b9d25bc613c0e8"
    },
    {
      "sections": [
        "CodeStream licenses"
      ],
      "title": "CodeStream licenses",
      "type": "docs",
      "tags": [
        "Licenses",
        "Product or service licenses",
        "CodeStream"
      ],
      "external_id": "331f3d1cd0897f453f98bc054fda09a9ad2725c1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/codestream/codestream-licenses/",
      "published_at": "2021-10-24T17:53:35Z",
      "updated_at": "2021-10-23T17:05:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We love open-source software, and we use the following with CodeStream. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we've chosen to use. CodeStream license on GitHub CodeStream's third-party software notices on GitHub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 643.0532,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> licenses",
        "sections": "<em>CodeStream</em> licenses",
        "tags": "<em>CodeStream</em>",
        "body": "We love open-source software, and we use the following with <em>CodeStream</em>. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we&#x27;ve chosen to use. <em>CodeStream</em> license on GitHub <em>CodeStream</em>&#x27;s third-party software notices on GitHub"
      },
      "id": "617440e2196a677ea62f0193"
    },
    {
      "image": "https://docs.newrelic.com/static/0d940de4d107acece21b6e518f1a2c53/d10fb/OrganizationSettings.png",
      "url": "https://docs.newrelic.com/docs/codestream/codestream-settings/team-administration/",
      "sections": [
        "CodeStream organization settings and administration",
        "Managing People & Roles",
        "Organization Settings",
        "Onboarding Settings",
        "Feedback Request Assignment & Approval",
        "Change Organization Name",
        "Data Export"
      ],
      "published_at": "2021-10-24T21:15:45Z",
      "title": "CodeStream organization settings and administration",
      "updated_at": "2021-10-23T16:57:06Z",
      "type": "docs",
      "external_id": "643e62ff1fc920ca94e3bcd2e27e3a9be4317515",
      "document_type": "page",
      "popularity": 1,
      "body": "Managing People & Roles Select \"My Organization\" from the My Organization menu at the top of the CodeStream pane to invite people to the organization and assign or remove admin privileges. Select \"Blame Map\" to define code ownership with your organization. By default, when you comment on code, CodeStream mentions (or offers to email) the author(s) of the code you are commenting on. But if that person has left the company it might not be the right thing to do. Note that non-admins are able to set up blame maps for themselves to handle situations where the email address they use to commit code is different than the one they used to sign up for CodeStream. Organization Settings If you are an organization admin, look for the Organization Admin menu under the headshot menu at the top of the CodeStream pane. Onboarding Settings Domain-based joining allows anyone with email addresses on the specified domains to join your CodeStream organization without being first invited. Not only does this make it very easy to get your teammates on board, but it ensures that they'll be part of your organization (as opposed to accidentally creating their own). Feedback Request Assignment & Approval Admins can control how both feedback request assignments and approvals work for the organization. By default, the person requesting feedback can decide how approvals work, but you can, instead, set a default behavior for all feedback requests for the organization. Any reviewer can approve - Any one can approve the feedback request, regardless of how many reviewers are assigned. All reviewers must approve individually - Each assigned reviewer must individually approve the feedback request before it’s considered approved. You can also decide if and how CodeStream suggests reviewers. Round-robin will cycle through all developers in the organization. Random will randomly assign the feedback request to any developer in the organization. The Authorship options will suggest up to three reviewers based on the developers who wrote the lines of code impacted by the changes, as well as other developers who may have committed to the branch. Change Organization Name Update the name of your CodeStream organization at any time. Data Export A lightweight export facility for getting your organization's discussions out of CodeStream. Click the icon to copy all of the data to the clipboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 321.0952,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> <em>organization</em> settings and administration",
        "sections": "<em>CodeStream</em> <em>organization</em> settings and administration",
        "body": "Managing People &amp; Roles Select &quot;<em>My</em> <em>Organization</em>&quot; from the <em>My</em> <em>Organization</em> menu at the top of the <em>CodeStream</em> pane to invite people to the <em>organization</em> and assign or remove admin privileges. Select &quot;Blame Map&quot; to define <em>code</em> ownership with your <em>organization</em>. By default, when you comment on <em>code</em>"
      },
      "id": "61743ee264441ff1025fd5b5"
    }
  ],
  "/docs/codestream/codestream-ui-overview/observability-section": [
    {
      "image": "https://docs.newrelic.com/static/5c1d085b14abf961ca66b96285f0c0fa/69902/QS-Integrations.png",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/install-codestream/",
      "sections": [
        "Install CodeStream",
        "Tip",
        "Install with Instant Observability (I/O)",
        "Connect your tools",
        "Discuss any block of code, at any time",
        "Get feedback on your work in progress",
        "Create or review a pull request",
        "Help & Feedback"
      ],
      "published_at": "2021-10-24T21:19:37Z",
      "title": "Install CodeStream",
      "updated_at": "2021-10-23T17:01:57Z",
      "type": "docs",
      "external_id": "5d431c8f9a2690b64d26ac9fc173b18085153aac",
      "document_type": "page",
      "popularity": 1,
      "body": "CodeStream is a developer collaboration platform that makes it easy to discuss and review code in a more natural and contextual way. Install CodeStream Install CodeStream for Visual Studio Code, Visual Studio or JetBrains. You can also install the CodeStream extension directly via your Visual Studio Code/Visual Studio's extensions or JetBrains plugins menus. Tip Once you've installed CodeStream, if you want to connect it to New Relic, you'll need your New Relic user key. Go here to learn more about finding or creating your user key. Install with Instant Observability (I/O) You can also install CodeStream via an Instant Observability (I/O) quickstart. Connect your tools Create and review pull requests on GitHub, GitLab or Bitbucket. Create issues on Jira, Trello, and other issue trackers. Share code discussions on Slack or Microsoft Teams. CodeStream brings the tools you use every day together in your IDE. Click on your headshot at the top of the CodeStream pane and go to the Integrations page to get all of your tools connected. Discuss any block of code, at any time Whether you're trying to understand someone else's code or getting help with some code you just wrote, just select the code and ask your question. Learn more about discussing code. Get feedback on your work in progress Select \"Request Feedback\" from the \"+\" menu at any time in the development cycle, whether it’s a quick look over some work in progress (even uncommitted code!) or a formal review of a completed effort. Teammates can review your changes right in their IDE, with no need to switch branches or set aside their own work. Learn more about feedback requests. Create or review a pull request Look for the Pull Requests section of the CodeStream sidebar to review an open pull request. Just click on a pull request (or load one from URL) to get a complete GitHub experience right in your IDE! Note that you can create a pull request in GitHub, GitLab or Bitbucket, but support for reviewing pull requests is currently only available for GitHub (cloud or Enterprise). Learn more about pull requests. Help & Feedback Report a bug or send a suggestion in GitHub issues. Contact us directly at support@codestream.com. Follow @teamcodestream for product updates and to share feedback and questions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 772.8866,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>CodeStream</em>",
        "sections": "Install <em>CodeStream</em>",
        "body": " Studio <em>Code</em>&#x2F;Visual Studio&#x27;s extensions or JetBrains plugins menus. Tip Once you&#x27;ve installed <em>CodeStream</em>, if you want to connect it to New Relic, you&#x27;ll need your New Relic user key. Go here to learn more about finding or creating your user key. Install with Instant <em>Observability</em> (I&#x2F;O) You can also"
      },
      "id": "6174400564441ff1025fd832"
    },
    {
      "image": "https://docs.newrelic.com/static/955e077a4753336027d003cec2388566/c5bb3/connect-repo.png",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/codestream-new-relic/",
      "sections": [
        "CodeStream and New Relic",
        "Preview release",
        "Connect CodeStream and New Relic",
        "Caution",
        "See your errors and what's causing them",
        "Tip",
        "How to go from errors inbox to your IDE",
        "APM errors and CodeStream",
        "Give us your repository's URL",
        "Use environment variable with APM (recommended)",
        "Use the UI",
        "Use the NerdGraph API",
        "Install APM agents with CodeStream",
        "Dynamic logging with Go and Pixie"
      ],
      "published_at": "2021-10-24T21:20:27Z",
      "title": "CodeStream and New Relic",
      "updated_at": "2021-10-23T16:54:24Z",
      "type": "docs",
      "external_id": "a6c04d95011d9150cb0798580c15695bb9f3bbda",
      "document_type": "page",
      "popularity": 1,
      "body": "CodeStream and New Relic work together in several ways to give you insight into your code's errors, as well as making it easier to get started instrumenting your code with our APM agents. Specifically, when CodeStream is connected to New Relic, you can to jump from a stack trace error in the New Relic UI directly to the offending line of code in your IDE. Once in your IDE, you can use all of CodeStream's collaboration tools to discuss the code, request feedback, and submit a pull request to resolve the issue and push up the fix to your repository. Preview release CodeStream's integration with New Relic One is a preview release limited to New Relic One accounts on our US data center, and your use is subject to the pre-release policy. (This does not apply to all other CodeStream functionality.) Connect CodeStream and New Relic Before you can take advantage of New Relic's observability features in CodeStream, you'll need to connect them. Requirements for connecting CodeStream and New Relic: New Relic account (If you don't have a New Relic account, sign up at newrelic.com/signup. It's free, forever!) New Relic user key If you don't have a user key or want to learn more about how you can use and manage them, see our doc on the New Relic user key. Once you have your New Relic user key, in CodeStream's Observability section click Connect to New Relic One, then paste your API key and click Connect. Caution New Relic users can share stacktrace errors on CodeStream. Once you've connected CodeStream to New Relic, any new users you add to your CodeStream organization can see those errors. See your errors and what's causing them After you connect CodeStream and New Relic, use workloads and errors inbox to jump to the offending code in your IDE. Requirements for opening stack trace errors in your IDE: New Relic account (If you don't have a New Relic account, sign up at newrelic.com/signup. It's free, forever!) New Relic user key CodeStream and New Relic connection Data being reported to New Relic via APM monitoring A workload for errors inbox An error For APM errors, your repository's commit hash and release tag New Relic errors inbox is a single place to proactively detect, prioritize, and take action on your errors before they impact customers. With CodeStream, you can jump from an error directly to the offending code in your IDE. Tip Limited to APM errors. How to go from errors inbox to your IDE From one.newrelic.com/, go to Errors Inbox, click a stack trace error, then click Open in IDE. APM errors and CodeStream To use CodeStream's Open in IDE with your APM stack trace errors, use environment variables to configure your APM agent with your application's commit sha and/or your release tag associated with the running version of your software. CodeStream only needs the first seven characters of your commit sha (for example, 734713b) to make this connection, but you can include the entire sha. Alternately, you can use a release tag (such as v0.1.209 or release-209) for CodeStream to find the correct version of your code. For New Relic APM, the commit and/or release tag (tags.commit and tags.releaseTag) are added as attributes on Transaction and TransactionError events. You can use APM environment variables to set these attributes. We recommend setting one or both of these variables as part of your build pipeline. NEW_RELIC_METADATA_COMMIT - The commit sha. You can include the whole thing or only the first seven characters. NEW_RELIC_METADATA_RELEASE_TAG - A release tag (such as v0.1.209 or release-209). This has the advantage of being human readable. For more on how to set these variables, here are specific configuration details for each language: Go Java .NET Node.js PHP Python Ruby Give us your repository's URL Once you've started monitoring for APM, mobile, browser, or Lambda, you can connect those things with your repository. In order to link your data in New Relic to your code, we need to know the URL for your repository. For example, the URL can be in either the SSH or HTTPS format: git@github.com:newrelic/beta-docs-site.git https://github.com/newrelic/beta-docs-site.git Caution It's possible to add the same GitHub repository more than once, if you're using different protocols to do so. The UI warns you about this, but won't prevent you from doing so. For example, https://github.com/tuna/repo and git@github.com:tuna/repo are the same repo, with different protocols. You can use any one of these methods to set up your repository: Use environment variable with APM (recommended) Set the environment variable NEW_RELIC_METADATA_REPOSITORY_URL. New Relic APM agents create the repository entity and associate it to your application entity automatically. This requires the SSH or HTTPS URL format. We recommend that these be set as part of your build pipeline. Use the UI Once you've started sending data to New Relic, use the UI to connect your related repository. For APM, mobile, browser, and Lambda monitoring, find the Connect repository button on the right-hand side. To connect your repository, click Connnect repository, then find an existing repository or add a new one. Use the NerdGraph API Use New Relic's NerdGraph APIsto create a repository and associate it with your application entities. Step 1: Create a repository entity To create a repository entity, use the referenceEntityCreateOrUpdateRepository API and make sure to save the GUID that's produced. The API takes the following parameters: accountId - the integer account ID for the account you want to add the repository to url - example https://github.com/newrelic/beta-docs-site.git name - example: newrelic/beta-docs-site mutation { referenceEntityCreateOrUpdateRepository(repositories: [{accountId: [YOUR_ACCOUNT_ID], name: \"[REPO_NAME]\", url: \"[REPO_URL]\"}]) { created failures { guid message type } } } Copy In order to find the entity you create, you can use a query like the following. Note that the URL you provided to referenceEntityCreateOrUpdateRepository gets saved as an entity tag. { actor { entitySearch(query: \"name = 'a name' OR tags.url = 'a url'\") { count query results { entities { guid name tags { key values } } } } } } Copy Step 2: Associate the repository entity to your application entity First, find the GUID for the application you want to associate your repository to. Parameters: sourceEntityGuid - the entity GUID of the application targetEntityGuid - the entity GUID of your repository type - always BUILT_FROM mutation { entityRelationshipUserDefinedCreateOrReplace(sourceEntityGuid: \"\", targetEntityGuid: \"\", type: BUILT_FROM) { errors { message type } } } Copy To see all entities related to your repository you can do a query like this: { actor { entity(guid: \"[YOUR_REPOSITORY_GUID]]\") { relatedEntities(filter: {direction: BOTH, relationshipTypes: {include: BUILT_FROM}}) { results { target { entity { name guid type } } type } } name type tags { values key } } } } Copy Step 3: Cleanup (if needed) Delete a repository with the following query: mutation DeleteRepository { entityDelete(guids: \"[ENTITY_GUID_HERE]]\") { deletedEntities failures { message guid } } } Copy Install APM agents with CodeStream Requirements for installing New Relic APM agents via CodeStream: New Relic account New Relic user key CodeStream and New Relic connection A supported language application codebase .NET Core Java Node.JS When you first connect CodeStream to New Relic, if you're working on an application's codebase that's not being monitored by New Relic, CodeStream will offer to instrument that application for you. Like New Relic's guided install, CodeStream will walk you through and automate all of the steps to installing the APM agent to start sending data to New Relic. This check only happens automatically when the initial connection is made. To do so later, in the CodeStream extension, click your username, then click New Relic Setup. Dynamic logging with Go and Pixie New Relic account New Relic user API key CodeStream and New Relic connection A Kubernetes cluster monitored by Pixie An application written in Go You can use CodeStream to enable dynamic logging for your Pixie-monitored Go applications. For relevant projects, you can use CodeStream to dynamically log your Go method names in your IDE.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 655.60876,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> and New Relic",
        "sections": "<em>CodeStream</em> and New Relic",
        "body": " with New Relic One is a preview release limited to New Relic One accounts on our US data center, and your use is subject to the pre-release policy. (This does not apply to all other <em>CodeStream</em> functionality.) Connect <em>CodeStream</em> and New Relic Before you can take advantage of New Relic&#x27;s <em>observability</em>"
      },
      "id": "6171e652196a67e9c92f0156"
    },
    {
      "sections": [
        "CodeStream licenses"
      ],
      "title": "CodeStream licenses",
      "type": "docs",
      "tags": [
        "Licenses",
        "Product or service licenses",
        "CodeStream"
      ],
      "external_id": "331f3d1cd0897f453f98bc054fda09a9ad2725c1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/codestream/codestream-licenses/",
      "published_at": "2021-10-24T17:53:35Z",
      "updated_at": "2021-10-23T17:05:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We love open-source software, and we use the following with CodeStream. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we've chosen to use. CodeStream license on GitHub CodeStream's third-party software notices on GitHub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 643.05286,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> licenses",
        "sections": "<em>CodeStream</em> licenses",
        "tags": "<em>CodeStream</em>",
        "body": "We love open-source software, and we use the following with <em>CodeStream</em>. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we&#x27;ve chosen to use. <em>CodeStream</em> license on GitHub <em>CodeStream</em>&#x27;s third-party software notices on GitHub"
      },
      "id": "617440e2196a677ea62f0193"
    }
  ],
  "/docs/codestream/codestream-ui-overview/permalinks": [
    {
      "sections": [
        "CodeStream licenses"
      ],
      "title": "CodeStream licenses",
      "type": "docs",
      "tags": [
        "Licenses",
        "Product or service licenses",
        "CodeStream"
      ],
      "external_id": "331f3d1cd0897f453f98bc054fda09a9ad2725c1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/codestream/codestream-licenses/",
      "published_at": "2021-10-24T17:53:35Z",
      "updated_at": "2021-10-23T17:05:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We love open-source software, and we use the following with CodeStream. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we've chosen to use. CodeStream license on GitHub CodeStream's third-party software notices on GitHub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 650.5502,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> licenses",
        "sections": "<em>CodeStream</em> licenses",
        "tags": "<em>CodeStream</em>",
        "body": "We love open-source software, and we use the following with <em>CodeStream</em>. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we&#x27;ve chosen to use. <em>CodeStream</em> license on GitHub <em>CodeStream</em>&#x27;s third-party software notices on GitHub"
      },
      "id": "617440e2196a677ea62f0193"
    },
    {
      "image": "https://docs.newrelic.com/static/c1b964985880261f094399e10af5773a/1efb2/MSTCSSigninPage.png",
      "url": "https://docs.newrelic.com/docs/codestream/codestream-integrations/msteams-integration/",
      "sections": [
        "Microsoft Teams and CodeStream",
        "Connecting to Microsoft Teams",
        "Participating from Microsoft Teams",
        "Open in IDE",
        "Open on GitHub (or Bitbucket or GitLab)"
      ],
      "published_at": "2021-10-24T21:15:03Z",
      "title": "Microsoft Teams and CodeStream",
      "updated_at": "2021-10-23T17:02:53Z",
      "type": "docs",
      "external_id": "6aa93f89e0a2de618a36e82930fcb23d72eb1321",
      "document_type": "page",
      "popularity": 1,
      "body": "When you post a codemark your teammates will get notified via the activity feed, and potentially via email. Sometimes, though, you might want to share to Microsoft Teams as well. This would allow you to reach people who haven’t yet joined CodeStream, or maybe don’t spend a lot of time in their IDE. Connecting to Microsoft Teams Click here to install the CodeStream app or go to \"Apps\" in your Teams sidebar and search for CodeStream. Once installed you should see the following popup for the CodeStream app, click on the Add button. Note, do not expand it and select the options to add to team or chat. Simply click Add. This will take you to your private chat with the CodeStream bot, and you’ll see the CodeStream logo appear in the Teams sidebar. Type signin in this chat and submit. A post from the bot will appear in the stream, along with a “Sign in” button. Click the button and you’ll be taken to the web and prompted to sign into CodeStream. After signing in you’ll be provided with a token that you’ll need to copy and paste into your chat with the CodeStream bot back in MS Teams. Paste the token into the chat and submit. Go to a channel in which you’d like to share, type @, and then select Get bots from the popup. Select the CodeStream bot from the list (and search for it if you need to), and then click \"Add\". Now return to the channel and @mention the CodeStream bot with the connect command. Repeat this in any channel that you'd like to share to. Once you get the following confirmation, you’re ready to share to Teams from CodeStream. When you return to CodeStream you'll now be able to share to the channels that you just connected. Participating from Microsoft Teams When you share to Teams, not only does it notify your teammates about the codemark, but they can use it to jump directly into their IDEs to participate in the conversation on CodeStream. Open in IDE Click “Open in IDE” to view both the code, and the discussion, right inside your IDE. You’ll be first taken through a CodeStream web page where you’ll specify which IDE to open, and CodeStream will remember this selection for the next time you view a discussion from the same repository. You’ll then be taken to the appropriate source file in your IDE, scrolled to the relevant block of code, with the discussion displayed in the CodeStream pane. If you don’t happen to have the given repository open in your IDE, CodeStream will automatically open the source file for you (assuming you’ve opened that repository previously, with CodeStream installed, so that we know where to find it). Note that if you’re using a JetBrains IDE you’ll need to first install the Toolbox App so that CodeStream can deep link into the IDE. Open on GitHub (or Bitbucket or GitLab) If the code block is from a repository hosted on GitHub, Bitbucket or GitLab, this button will take you to the corresponding block of code on that hosting service.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 232.63431,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Microsoft Teams and <em>CodeStream</em>",
        "sections": "Microsoft Teams and <em>CodeStream</em>",
        "body": "When you post a codemark your teammates will get notified via the activity feed, and potentially via email. Sometimes, though, you might want to share to Microsoft Teams as well. This would allow you to reach people who haven’t yet joined <em>CodeStream</em>, or maybe don’t spend a lot of time in their IDE"
      },
      "id": "6174403d196a678e4e2f271d"
    },
    {
      "image": "https://docs.newrelic.com/static/30e00c292c5aa1c5d702d67be5021a45/f96db/CreateAnAccount6.png",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/sign-up-codestream/",
      "sections": [
        "Sign up for CodeStream",
        "Create an account",
        "CodeStream organizations [$organizations]",
        "Create or join an organization",
        "Invite your team"
      ],
      "published_at": "2021-10-24T21:21:10Z",
      "title": "Sign up for CodeStream",
      "updated_at": "2021-10-23T17:05:39Z",
      "type": "docs",
      "external_id": "2f8eda03703523f62844512a3b8ef005b624ebc2",
      "document_type": "page",
      "popularity": 1,
      "body": "To get the most out of CodeStream's collaboration tools, create an organization, and then invite your team members to it. Create an account If you already have the CodeStream extension installed in your IDE, you can start the signup process from the CodeStream pane. You can sign up by either creating a set of CodeStream credentials (such as, email address and password), or you can sign up using GitHub, GitLab or Bitbucket (cloud versions only). Signing up via your code host saves you from having to connect later, but if the email address you're using there isn't your work email you should create CodeStream credentials instead. If you sign up via CodeStream, your next step will be to confirm your email address by entering a code sent to you via email. Note that you can paste the code into any of the boxes rather than typing each number individually. CodeStream organizations [$organizations] An “organization” on CodeStream is where you and your teammates will discuss code. Similar to a Slack workspace, all of the developers in your company should be in the same CodeStream organization. This is true even for very large organizations as CodeStream's activity feed keeps things relevant for each member by showing just activity related to the code you have open in your IDE. The discussions about code build up a knowledge base that is a company-wide resource, so the only reason to have multiple organizations on CodeStream is if you truly need separation. For example, you might have an organization for your day job and another for an open-source project you work on. Or maybe you're a consultant that is a member of different CodeStream organizations for each of your clients. Create or join an organization If you were invited to join an organization on CodeStream, all you need to do is sign up using the same email address the invitation was sent to. You'll automatically be added to that organization. If you're the first person from your company to sign up for CodeStream you can go ahead and create a new organization. Otherwise, there may be existing CodeStream organizations available for you to join based on your email domain. If you think your company is already on CodeStream, but don't see an organization to join, make sure that you've signed up with your work email address. Click the link to change your email address if necessary. If you decide to create an organization you'll be asked to give it a name, and if you signed up with your work email address, you'll also be able to indicate that anyone else on that email domain can join the organization. Invite your team Collaboration is a team sport so invite your teammates to join you on CodeStream! CodeStream will offer up some suggestions based on the commit history of the repositories you have open in your IDE. Now you're ready to start using CodeStream.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 232.40752,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Sign up for <em>CodeStream</em>",
        "sections": "Sign up for <em>CodeStream</em>",
        "body": "To get the most out of <em>CodeStream</em>&#x27;s collaboration tools, create an organization, and then invite your team members to it. Create an account If you already have the <em>CodeStream</em> extension installed in your IDE, you can start the signup process from the <em>CodeStream</em> pane. You can sign up by either"
      },
      "id": "617440e3196a6782592f011c"
    }
  ],
  "/docs/codestream/codestream-ui-overview/pull-requests-section": [
    {
      "sections": [
        "CodeStream licenses"
      ],
      "title": "CodeStream licenses",
      "type": "docs",
      "tags": [
        "Licenses",
        "Product or service licenses",
        "CodeStream"
      ],
      "external_id": "331f3d1cd0897f453f98bc054fda09a9ad2725c1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/codestream/codestream-licenses/",
      "published_at": "2021-10-24T17:53:35Z",
      "updated_at": "2021-10-23T17:05:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We love open-source software, and we use the following with CodeStream. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we've chosen to use. CodeStream license on GitHub CodeStream's third-party software notices on GitHub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 650.5502,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> licenses",
        "sections": "<em>CodeStream</em> licenses",
        "tags": "<em>CodeStream</em>",
        "body": "We love open-source software, and we use the following with <em>CodeStream</em>. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we&#x27;ve chosen to use. <em>CodeStream</em> license on GitHub <em>CodeStream</em>&#x27;s third-party software notices on GitHub"
      },
      "id": "617440e2196a677ea62f0193"
    },
    {
      "image": "https://docs.newrelic.com/static/48721d72a10a277b2ef615b62a07f0fe/f96db/GitHubAuth.png",
      "url": "https://docs.newrelic.com/docs/codestream/troubleshooting/github-org-repos/",
      "sections": [
        "Why aren't PRs and issues from all my GitHub organizations listed in CodeStream?"
      ],
      "published_at": "2021-10-24T21:22:45Z",
      "title": "Why aren't PRs and issues from all my GitHub organizations listed in CodeStream?",
      "updated_at": "2021-10-23T17:09:23Z",
      "type": "docs",
      "external_id": "aa4cd2a3acc746bc90aa1cf6663335e36084c002",
      "document_type": "page",
      "popularity": 1,
      "body": "When you connect to GitHub you should see all of your open pull requests in the Pull Requests section of the CodeStream pane, as well as all issues assigned to you in the Issues section. If pull requests or issues from any of your GitHub organizations are missing, it's probably because at the time you authenticated with GitHub, you didn't grant access to all of your organizations. If you didn't click on that Grant button at authentication time, simply go to GitHub and navigate to Settings > Applications and click on the Authorized OAuth Apps tab. From there, click on the CodeStream application. On the following page, click the Grant button next to any organizations that you'd like to be able to access from CodeStream. Note that in some instances you'll see a Request button instead of Grant, which means that the owner of your GitHub organization will need to grant access.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 388.35904,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Why aren&#x27;t PRs and issues from all my GitHub organizations listed in <em>CodeStream</em>?",
        "sections": "Why aren&#x27;t PRs and issues from all my GitHub organizations listed in <em>CodeStream</em>?",
        "body": "When you connect to GitHub you should see all of your open <em>pull</em> <em>requests</em> in the <em>Pull</em> <em>Requests</em> <em>section</em> of the <em>CodeStream</em> pane, as well as all issues assigned to you in the Issues <em>section</em>. If <em>pull</em> <em>requests</em> or issues from any of your GitHub organizations are missing, it&#x27;s probably because at the time"
      },
      "id": "617441c3e7b9d2478513cf8c"
    },
    {
      "image": "https://docs.newrelic.com/static/dd18b67123e9d4b7d40b56a8653a1f6b/f96db/OpenPullRequest1.png",
      "url": "https://docs.newrelic.com/docs/codestream/how-use-codestream/pull-requests/",
      "sections": [
        "Manage pull requests on CodeStream",
        "Creating a pull request",
        "Reviewing a pull request",
        "Leveraging pull request comments"
      ],
      "published_at": "2021-10-24T21:18:51Z",
      "title": "Manage pull requests on CodeStream",
      "updated_at": "2021-10-23T17:01:57Z",
      "type": "docs",
      "external_id": "7e35f2ff4f06799fe492ffb6b2fedbb52e898b69",
      "document_type": "page",
      "popularity": 1,
      "body": "For most development teams, the final step in the development process is a pull request. Even if your team has decided to use CodeStream's feedback requests as a replacement for, and not just a precursor to, your end-of-cycle PR-based code reviews, CodeStream allows you to keep all of that workflow right in your IDE. There are three elements of CodeStream's pull-request integration, and the following table outlines which code-hosting services are supported for each. Feature Supported Services Create a pull request GitHub, GitHub Enterprise, GitLab, GitLab Self-Managed, Bitbucket, Bitbucket Server Create a pull request across forks GitHub, GitHub Enterprise, GitLab, GitLab Self-Managed Review and edit a pull request GitHub, GitHub Enterprise, GitLab, GitLab Self-Managed Display pull request comments as code annotations GitHub, GitLab, Bitbucket Creating a pull request Open a pull request at any time by clicking on the \"+\" button at the top of the CodeStream pane, or the \"+\" button in the header of the Pull Requests section. You can also use a keyboard shortcut (ctlr+shift+/ p, or ctrl+/ p on a Mac... and you can use m if you're a GitLab user). CodeStream even provides you with different options (tree view, list view, diff hunks) for reviewing your changes before opening the pull request. With a single click you can name the pull request based on the last commit message, the branch name, or, if you started work by selecting a ticket, the ticket title. If you have a ticket selected, you can also explicitly tie the ticket to the pull request, and CodeStream will include a link to the ticket in the pull request's description. Before submitting the pull request you can even review your changes by clicking on any of the files listed below the form. To create a pull request across forks, click on the \"compare across forks\" link at the top of the page and the form will update to allow you to select both the base and head repositories. You can also create a pull request from within a CodeStream feedback request. Once the feedback request has been approved, you’ll see an option to open a pull request at the top. Before you can create a pull request you’ll need to make sure that any changes included in the feedback request have been committed and pushed. Also, if the feature branch you’re working on doesn’t have a remote tracking branch you’ll be given the option to set that as part of creating the pull request. When you create a pull request from a feedback request, CodeStream connect's the dots between the two by adding a link to the pull request to the feedback request. And by adding a link to the feedback request, along with information about who did the review and when, in the description of the pull request. Reviewing a pull request The ability to review pull requests is currently not available for Bitbucket. Regardless of where the pull request was created, you can edit, review, and even merge it, right from CodeStream. We've essentially brought GitHub and GitLab right into your IDE, so there's zero learning curve. If you know how to work with pull requests on GitHub or GitLab, you'll know how to do it in CodeStream as well. Edit a GitHub pull request's details, such as reviewers, assignees and labels. For a GitLab merge request, you can use edit mode (via the dropdown at the top of the page) or use the sidebar. By default, you can only add a single reviewer and a single assignee to a GitLab merge request. If your organization supports multiple reviewers and assignees, click the gear menu in the heading of the Merge Requests section of the CodeStream pane to enable this. Review the conversation and add comments, with the ability to @mention your collaborators. View the changes, add comments, and submit a review. Of course, we did improve upon the GitHub/GitLab experience in a couple of important ways. On GitHub and GitLab you can only view the changes as a series of \"diff hunks\". CodeStream provides that view as well, but if you'd prefer to see the changes in the context of the full file, and not just the lines that changed, you can use either List View or Tree View. Just select the code you want to comment on, and then click on the Comment button (or select Comment from the context menu). When commenting you can either add a single comment, or start a review. Another difference is that CodeStream allows you to comment on lines of code that haven't changed. You can select ANY lines of code in the diff, and not just those that are part of the changeset. Note that these comments are added as a \"single comment\" to the pull request and aren't part of any review you may have in progress. All the power of GitHub pull requests and GitLab merge requests, and then some, right in your IDE. Leveraging pull request comments Once the pull request has been approved and the code has been merged that's usually the end of life for any comments in that pull request. Although there is often useful information in those comments, that may have long-term value, they are rarely seen again. CodeStream gives those comments a second life by displaying them alongside the blocks of code that they refer to. To have pull request comments displayed as annotions in your codemarks, as well as in the Codemarks section of the CodeStream pane, click on the gear icon in that section and check the box to \"Show comments from pull requests\". When you first check that box, if you haven’t already authenticated with your code-hosting service you’ll be prompted to do so. Comments from merged PRs will appear next to the blocks of code they refer to. Comments from open PRs will also be included if you are on a relevant branch. For example, if the open PR is a request to merge the feature/some-name branch into main, you’ll see comments from that PR if you are checked out to either feature/some-name or main, but not when you’re on any other branch. As the code evolves, the location of each comment is automatically updated so that it remains linked to the block of code it refers to. Note that PR comments for a given file are updated roughly every 30 minutes, so new comments may not appear right away. You can force an update by restarting your IDE.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 385.834,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>pull</em> <em>requests</em> on <em>CodeStream</em>",
        "sections": "Manage <em>pull</em> <em>requests</em> on <em>CodeStream</em>",
        "body": " life by displaying them alongside the blocks of <em>code</em> that they refer to. To have <em>pull</em> <em>request</em> comments displayed as annotions in your codemarks, as well as in the Codemarks <em>section</em> of the <em>CodeStream</em> pane, click on the gear icon in that <em>section</em> and check the box to &quot;Show comments from <em>pull</em> <em>requests</em>"
      },
      "id": "61744006196a67ee542f0555"
    }
  ],
  "/docs/codestream/how-use-codestream/discuss-code": [
    {
      "sections": [
        "CodeStream licenses"
      ],
      "title": "CodeStream licenses",
      "type": "docs",
      "tags": [
        "Licenses",
        "Product or service licenses",
        "CodeStream"
      ],
      "external_id": "331f3d1cd0897f453f98bc054fda09a9ad2725c1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/codestream/codestream-licenses/",
      "published_at": "2021-10-24T17:53:35Z",
      "updated_at": "2021-10-23T17:05:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We love open-source software, and we use the following with CodeStream. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we've chosen to use. CodeStream license on GitHub CodeStream's third-party software notices on GitHub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 776.0831,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> licenses",
        "sections": "<em>CodeStream</em> licenses",
        "tags": "<em>CodeStream</em>",
        "body": "We love open-source software, and we use the following with <em>CodeStream</em>. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we&#x27;ve chosen to use. <em>CodeStream</em> license on GitHub <em>CodeStream</em>&#x27;s third-party software notices on GitHub"
      },
      "id": "617440e2196a677ea62f0193"
    },
    {
      "image": "https://docs.newrelic.com/static/5c1d085b14abf961ca66b96285f0c0fa/69902/QS-Integrations.png",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/install-codestream/",
      "sections": [
        "Install CodeStream",
        "Tip",
        "Install with Instant Observability (I/O)",
        "Connect your tools",
        "Discuss any block of code, at any time",
        "Get feedback on your work in progress",
        "Create or review a pull request",
        "Help & Feedback"
      ],
      "published_at": "2021-10-24T21:19:37Z",
      "title": "Install CodeStream",
      "updated_at": "2021-10-23T17:01:57Z",
      "type": "docs",
      "external_id": "5d431c8f9a2690b64d26ac9fc173b18085153aac",
      "document_type": "page",
      "popularity": 1,
      "body": "CodeStream is a developer collaboration platform that makes it easy to discuss and review code in a more natural and contextual way. Install CodeStream Install CodeStream for Visual Studio Code, Visual Studio or JetBrains. You can also install the CodeStream extension directly via your Visual Studio Code/Visual Studio's extensions or JetBrains plugins menus. Tip Once you've installed CodeStream, if you want to connect it to New Relic, you'll need your New Relic user key. Go here to learn more about finding or creating your user key. Install with Instant Observability (I/O) You can also install CodeStream via an Instant Observability (I/O) quickstart. Connect your tools Create and review pull requests on GitHub, GitLab or Bitbucket. Create issues on Jira, Trello, and other issue trackers. Share code discussions on Slack or Microsoft Teams. CodeStream brings the tools you use every day together in your IDE. Click on your headshot at the top of the CodeStream pane and go to the Integrations page to get all of your tools connected. Discuss any block of code, at any time Whether you're trying to understand someone else's code or getting help with some code you just wrote, just select the code and ask your question. Learn more about discussing code. Get feedback on your work in progress Select \"Request Feedback\" from the \"+\" menu at any time in the development cycle, whether it’s a quick look over some work in progress (even uncommitted code!) or a formal review of a completed effort. Teammates can review your changes right in their IDE, with no need to switch branches or set aside their own work. Learn more about feedback requests. Create or review a pull request Look for the Pull Requests section of the CodeStream sidebar to review an open pull request. Just click on a pull request (or load one from URL) to get a complete GitHub experience right in your IDE! Note that you can create a pull request in GitHub, GitLab or Bitbucket, but support for reviewing pull requests is currently only available for GitHub (cloud or Enterprise). Learn more about pull requests. Help & Feedback Report a bug or send a suggestion in GitHub issues. Contact us directly at support@codestream.com. Follow @teamcodestream for product updates and to share feedback and questions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 311.7204,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>CodeStream</em>",
        "sections": "<em>Discuss</em> any block of <em>code</em>, at any time",
        "body": "<em>CodeStream</em> is a developer collaboration platform that makes it easy to <em>discuss</em> and review <em>code</em> in a more natural and contextual way. Install <em>CodeStream</em> Install <em>CodeStream</em> for Visual Studio <em>Code</em>, Visual Studio or JetBrains. You can also install the <em>CodeStream</em> extension directly via your Visual"
      },
      "id": "6174400564441ff1025fd832"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/what-is-codestream/",
      "sections": [
        "What is CodeStream?",
        "Discuss code just like commenting on a Google Doc",
        "Get feedback on work-in-progress with pre-PR code review",
        "Create and review pull requests",
        "Build the knowledge base behind your codebase"
      ],
      "published_at": "2021-10-24T21:21:10Z",
      "title": "What is CodeStream?",
      "updated_at": "2021-10-23T17:05:39Z",
      "type": "docs",
      "external_id": "0b3f4199050df98161ce8c46259a8bad30269d72",
      "document_type": "page",
      "popularity": 1,
      "body": "CodeStream is a developer collaboration platform that makes it incredibly easy for development teams, especially remote teams, to discuss and review code in a more natural and contextual way. CodeStream not only makes discussions easier, by allowing them to happen in your IDE, in context, but also preserves the institutional knowledge that is currently being lost in Slack channels and emails. Discuss code just like commenting on a Google Doc Simply select a block of code and type your question or comment. Teammates can participate in the discussion right from their IDE, and you can optionally share the discussion on Slack or Microsoft Teams so teammates can participate from their chat clients as well. Get feedback on work-in-progress with pre-PR code review CodeStream's lightweight feedback requests let you have someone look over your changes regardless of the current state of your repo, without the friction of committing, pushing or issuing a pull request. Your teammates can review your changes right in their IDE, with full file context, and with no need to set aside their current work to switch branches or pull the latest. CodeStream’s feedback requests are so easy that you can start doing them throughout the development process instead of waiting until the end. You’re a few days into a sprint and have some work stubbed out? Maybe some work that hasn’t even been committed? Request feedeback on your work in progress so that you can identify and resolve issues early instead of saving those gotchas for when you need to get the code merged. Create and review pull requests For most development teams, the final step in the development process is a pull request. Even if your team has decided to use CodeStream's feedback requests as a replacement for, and not just a precursor to, your end-of-cycle PR-based code reviews, CodeStream allows you to keep all of that workflow right in your IDE. You can create pull requests, and review pull requests, right inside your IDE. Build the knowledge base behind your codebase CodeStream turns conversation into documentation by capturing all of the discussion about your code, whether it was from a pull request, a feedback request, or a code comment/issue, and saving it with your code. And the real magic is that the discussions are automatically repositioned as your code changes, even across branches. All with zero effort on your part. Previously discussed questions and issues that explain important decisions are now accessible right where you need them, when you need them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 304.88147,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What is <em>CodeStream</em>?",
        "sections": "<em>Discuss</em> <em>code</em> just like commenting <em>on</em> a Google Doc",
        "body": "<em>CodeStream</em> is a developer collaboration platform that makes it incredibly easy for development teams, especially remote teams, to <em>discuss</em> and review <em>code</em> in a more natural and contextual way. <em>CodeStream</em> not only makes discussions easier, by allowing them to happen in your IDE, in context, but also"
      },
      "id": "617440e3e7b9d2836c13c43c"
    }
  ],
  "/docs/codestream/how-use-codestream/performance-monitoring": [
    {
      "sections": [
        "CodeStream licenses"
      ],
      "title": "CodeStream licenses",
      "type": "docs",
      "tags": [
        "Licenses",
        "Product or service licenses",
        "CodeStream"
      ],
      "external_id": "331f3d1cd0897f453f98bc054fda09a9ad2725c1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/codestream/codestream-licenses/",
      "published_at": "2021-10-24T17:53:35Z",
      "updated_at": "2021-10-23T17:05:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We love open-source software, and we use the following with CodeStream. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we've chosen to use. CodeStream license on GitHub CodeStream's third-party software notices on GitHub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 643.0526,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> licenses",
        "sections": "<em>CodeStream</em> licenses",
        "tags": "<em>CodeStream</em>",
        "body": "We love open-source software, and we use the following with <em>CodeStream</em>. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we&#x27;ve chosen to use. <em>CodeStream</em> license on GitHub <em>CodeStream</em>&#x27;s third-party software notices on GitHub"
      },
      "id": "617440e2196a677ea62f0193"
    },
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-10-26T01:45:08Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 257.02295,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to Android <em>monitoring</em>",
        "sections": "Introduction to Android <em>monitoring</em>",
        "tags": "Mobile <em>monitoring</em>",
        "body": " by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in <em>CodeStream</em> You can also see your Android application&#x27;s directly in your IDE using <em>CodeStream</em> and errors inbox. To do this, install <em>CodeStream</em>, connect <em>CodeStream</em> and New Relic and create Git tags that match your appVersion."
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/whats-new/2021/10/wn-codestream-1021/",
      "sections": [
        "Simplify code collaboration and review with New Relic CodeStream"
      ],
      "published_at": "2021-10-24T23:17:17Z",
      "title": "Simplify code collaboration and review with New Relic CodeStream",
      "updated_at": "2021-10-23T16:14:17Z",
      "type": "docs",
      "external_id": "f9d13af696d67a12cebebfc6698e916f3a5a11c9",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "Now you can resolve production errors faster and improve software performance with New Relic CodeStream. CodeStream is an exciting new IDE extension that helps developers discuss, review, and understand their code by integrating with popular dev tools and providing advanced in-IDE commenting. With the latest integration to New Relic One, CodeStream surfaces production errors inside your development environment for faster debugging. A free preview is available for everyone until January 12, 2022!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 246.21219,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Simplify <em>code</em> collaboration and review <em>with</em> New Relic <em>CodeStream</em>",
        "sections": "Simplify <em>code</em> collaboration and review <em>with</em> New Relic <em>CodeStream</em>",
        "body": "Now you can resolve production errors faster and improve software <em>performance</em> with New Relic <em>CodeStream</em>. <em>CodeStream</em> is an exciting new IDE extension that helps developers discuss, review, and understand their <em>code</em> by integrating with popular dev tools and providing advanced in-IDE commenting"
      },
      "id": "617434da196a67c6212f0dde"
    }
  ],
  "/docs/codestream/how-use-codestream/pull-requests": [
    {
      "sections": [
        "CodeStream licenses"
      ],
      "title": "CodeStream licenses",
      "type": "docs",
      "tags": [
        "Licenses",
        "Product or service licenses",
        "CodeStream"
      ],
      "external_id": "331f3d1cd0897f453f98bc054fda09a9ad2725c1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/codestream/codestream-licenses/",
      "published_at": "2021-10-24T17:53:35Z",
      "updated_at": "2021-10-23T17:05:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We love open-source software, and we use the following with CodeStream. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we've chosen to use. CodeStream license on GitHub CodeStream's third-party software notices on GitHub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 650.54956,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> licenses",
        "sections": "<em>CodeStream</em> licenses",
        "tags": "<em>CodeStream</em>",
        "body": "We love open-source software, and we use the following with <em>CodeStream</em>. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we&#x27;ve chosen to use. <em>CodeStream</em> license on GitHub <em>CodeStream</em>&#x27;s third-party software notices on GitHub"
      },
      "id": "617440e2196a677ea62f0193"
    },
    {
      "image": "https://docs.newrelic.com/static/8945e0a9c512b8638ebf8165d47aee04/69902/QS-SignUp3.png",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/codestream-user-guide/",
      "sections": [
        "CodeStream user guide",
        "Quick Start",
        "1. Install the CodeStream extension in your IDE and sign up.",
        "2. Connect your tools",
        "3. Discuss any block of code, at any time",
        "4. Get feedback on your work in progress",
        "5. Create or review a pull request",
        "Help & Feedback"
      ],
      "published_at": "2021-10-24T21:19:37Z",
      "title": "CodeStream user guide",
      "updated_at": "2021-10-23T17:07:02Z",
      "type": "docs",
      "external_id": "fa9af0118a8872fea89fda91482c44fb69913ea2",
      "document_type": "page",
      "popularity": 1,
      "body": "Quick Start Use the navigation to the left to jump straight to any topic. Otherwise, read on to get started with CodeStream. 1. Install the CodeStream extension in your IDE and sign up. Install CodeStream for VS Code, Visual Studio or JetBrains. The CodeStream pane should automatically appear in the sidebar for VS Code, or in a tool window at the right side for a JetBrains IDE or Visual Studio. Click on \"Sign Up and Create a team\" if you are the first person from your team to join CodeStream, or paste in your invitation code if you were invited to a team already on CodeStream. Learn more about how to use CodeStream. 2. Connect your tools Create and review pull requests on GitHub, GitLab or Bitbucket. Create issues on Jira, Trello, and other issue trackers. Share code discussions on Slack or Microsoft Teams. CodeStream brings the tools you use every day together in your IDE. Click on your headshot at the top of the CodeStream pane and go to the Integrations page to get all of your tools connected. 3. Discuss any block of code, at any time Whether you're trying to understand someone else's code or getting help with some code you just wrote, just select the code and ask your question. Learn more about discussing code. 4. Get feedback on your work in progress Select \"Request Feedback\" from the \"+\" menu at any time in the development cycle, whether it’s a quick look over some work in progress (even uncommitted code!) or a formal review of a completed effort. Teammates can review your changes right in their IDE, with no need to switch branches or set aside their own work. Learn more about feedback requests. 5. Create or review a pull request Look for the Pull Requests section of the CodeStream sidebar to review an open pull request. Just click on a pull request (or load one from URL) to get a complete GitHub experience right in your IDE! Note that you can create a pull request in GitHub, GitLab or Bitbucket, but support for reviewing pull requests is currently only available for GitHub (cloud or Enterprise). Learn more about pull requests. Help & Feedback Report a bug or send a suggestion in GitHub issues. Contact us directly at support@codestream.com. Follow @teamcodestream for product updates and to share feedback and questions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 347.94617,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> user guide",
        "sections": "5. Create or review a <em>pull</em> <em>request</em>",
        "body": " your changes right in their IDE, with no need to switch branches or set aside their own work. Learn more about feedback <em>requests</em>. 5. Create or review a <em>pull</em> <em>request</em> Look for the <em>Pull</em> <em>Requests</em> section of the <em>CodeStream</em> sidebar to review an open <em>pull</em> <em>request</em>. Just click on a <em>pull</em> <em>request</em> (or load one"
      },
      "id": "61744137e7b9d2428b13c6a0"
    },
    {
      "image": "https://docs.newrelic.com/static/5c1d085b14abf961ca66b96285f0c0fa/69902/QS-Integrations.png",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/install-codestream/",
      "sections": [
        "Install CodeStream",
        "Tip",
        "Install with Instant Observability (I/O)",
        "Connect your tools",
        "Discuss any block of code, at any time",
        "Get feedback on your work in progress",
        "Create or review a pull request",
        "Help & Feedback"
      ],
      "published_at": "2021-10-24T21:19:37Z",
      "title": "Install CodeStream",
      "updated_at": "2021-10-23T17:01:57Z",
      "type": "docs",
      "external_id": "5d431c8f9a2690b64d26ac9fc173b18085153aac",
      "document_type": "page",
      "popularity": 1,
      "body": "CodeStream is a developer collaboration platform that makes it easy to discuss and review code in a more natural and contextual way. Install CodeStream Install CodeStream for Visual Studio Code, Visual Studio or JetBrains. You can also install the CodeStream extension directly via your Visual Studio Code/Visual Studio's extensions or JetBrains plugins menus. Tip Once you've installed CodeStream, if you want to connect it to New Relic, you'll need your New Relic user key. Go here to learn more about finding or creating your user key. Install with Instant Observability (I/O) You can also install CodeStream via an Instant Observability (I/O) quickstart. Connect your tools Create and review pull requests on GitHub, GitLab or Bitbucket. Create issues on Jira, Trello, and other issue trackers. Share code discussions on Slack or Microsoft Teams. CodeStream brings the tools you use every day together in your IDE. Click on your headshot at the top of the CodeStream pane and go to the Integrations page to get all of your tools connected. Discuss any block of code, at any time Whether you're trying to understand someone else's code or getting help with some code you just wrote, just select the code and ask your question. Learn more about discussing code. Get feedback on your work in progress Select \"Request Feedback\" from the \"+\" menu at any time in the development cycle, whether it’s a quick look over some work in progress (even uncommitted code!) or a formal review of a completed effort. Teammates can review your changes right in their IDE, with no need to switch branches or set aside their own work. Learn more about feedback requests. Create or review a pull request Look for the Pull Requests section of the CodeStream sidebar to review an open pull request. Just click on a pull request (or load one from URL) to get a complete GitHub experience right in your IDE! Note that you can create a pull request in GitHub, GitLab or Bitbucket, but support for reviewing pull requests is currently only available for GitHub (cloud or Enterprise). Learn more about pull requests. Help & Feedback Report a bug or send a suggestion in GitHub issues. Contact us directly at support@codestream.com. Follow @teamcodestream for product updates and to share feedback and questions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 346.7055,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>CodeStream</em>",
        "sections": "Create or review a <em>pull</em> <em>request</em>",
        "body": " effort. Teammates can review your changes right in their IDE, with no need to switch branches or set aside their own work. Learn more about feedback <em>requests</em>. Create or review a <em>pull</em> <em>request</em> Look for the <em>Pull</em> <em>Requests</em> section of the <em>CodeStream</em> sidebar to review an open <em>pull</em> <em>request</em>. Just click"
      },
      "id": "6174400564441ff1025fd832"
    }
  ],
  "/docs/codestream/how-use-codestream/request-feedback": [
    {
      "sections": [
        "CodeStream licenses"
      ],
      "title": "CodeStream licenses",
      "type": "docs",
      "tags": [
        "Licenses",
        "Product or service licenses",
        "CodeStream"
      ],
      "external_id": "331f3d1cd0897f453f98bc054fda09a9ad2725c1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/codestream/codestream-licenses/",
      "published_at": "2021-10-24T17:53:35Z",
      "updated_at": "2021-10-23T17:05:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We love open-source software, and we use the following with CodeStream. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we've chosen to use. CodeStream license on GitHub CodeStream's third-party software notices on GitHub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 650.54956,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> licenses",
        "sections": "<em>CodeStream</em> licenses",
        "tags": "<em>CodeStream</em>",
        "body": "We love open-source software, and we use the following with <em>CodeStream</em>. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we&#x27;ve chosen to use. <em>CodeStream</em> license on GitHub <em>CodeStream</em>&#x27;s third-party software notices on GitHub"
      },
      "id": "617440e2196a677ea62f0193"
    },
    {
      "image": "https://docs.newrelic.com/static/dd18b67123e9d4b7d40b56a8653a1f6b/f96db/OpenPullRequest1.png",
      "url": "https://docs.newrelic.com/docs/codestream/how-use-codestream/pull-requests/",
      "sections": [
        "Manage pull requests on CodeStream",
        "Creating a pull request",
        "Reviewing a pull request",
        "Leveraging pull request comments"
      ],
      "published_at": "2021-10-24T21:18:51Z",
      "title": "Manage pull requests on CodeStream",
      "updated_at": "2021-10-23T17:01:57Z",
      "type": "docs",
      "external_id": "7e35f2ff4f06799fe492ffb6b2fedbb52e898b69",
      "document_type": "page",
      "popularity": 1,
      "body": "For most development teams, the final step in the development process is a pull request. Even if your team has decided to use CodeStream's feedback requests as a replacement for, and not just a precursor to, your end-of-cycle PR-based code reviews, CodeStream allows you to keep all of that workflow right in your IDE. There are three elements of CodeStream's pull-request integration, and the following table outlines which code-hosting services are supported for each. Feature Supported Services Create a pull request GitHub, GitHub Enterprise, GitLab, GitLab Self-Managed, Bitbucket, Bitbucket Server Create a pull request across forks GitHub, GitHub Enterprise, GitLab, GitLab Self-Managed Review and edit a pull request GitHub, GitHub Enterprise, GitLab, GitLab Self-Managed Display pull request comments as code annotations GitHub, GitLab, Bitbucket Creating a pull request Open a pull request at any time by clicking on the \"+\" button at the top of the CodeStream pane, or the \"+\" button in the header of the Pull Requests section. You can also use a keyboard shortcut (ctlr+shift+/ p, or ctrl+/ p on a Mac... and you can use m if you're a GitLab user). CodeStream even provides you with different options (tree view, list view, diff hunks) for reviewing your changes before opening the pull request. With a single click you can name the pull request based on the last commit message, the branch name, or, if you started work by selecting a ticket, the ticket title. If you have a ticket selected, you can also explicitly tie the ticket to the pull request, and CodeStream will include a link to the ticket in the pull request's description. Before submitting the pull request you can even review your changes by clicking on any of the files listed below the form. To create a pull request across forks, click on the \"compare across forks\" link at the top of the page and the form will update to allow you to select both the base and head repositories. You can also create a pull request from within a CodeStream feedback request. Once the feedback request has been approved, you’ll see an option to open a pull request at the top. Before you can create a pull request you’ll need to make sure that any changes included in the feedback request have been committed and pushed. Also, if the feature branch you’re working on doesn’t have a remote tracking branch you’ll be given the option to set that as part of creating the pull request. When you create a pull request from a feedback request, CodeStream connect's the dots between the two by adding a link to the pull request to the feedback request. And by adding a link to the feedback request, along with information about who did the review and when, in the description of the pull request. Reviewing a pull request The ability to review pull requests is currently not available for Bitbucket. Regardless of where the pull request was created, you can edit, review, and even merge it, right from CodeStream. We've essentially brought GitHub and GitLab right into your IDE, so there's zero learning curve. If you know how to work with pull requests on GitHub or GitLab, you'll know how to do it in CodeStream as well. Edit a GitHub pull request's details, such as reviewers, assignees and labels. For a GitLab merge request, you can use edit mode (via the dropdown at the top of the page) or use the sidebar. By default, you can only add a single reviewer and a single assignee to a GitLab merge request. If your organization supports multiple reviewers and assignees, click the gear menu in the heading of the Merge Requests section of the CodeStream pane to enable this. Review the conversation and add comments, with the ability to @mention your collaborators. View the changes, add comments, and submit a review. Of course, we did improve upon the GitHub/GitLab experience in a couple of important ways. On GitHub and GitLab you can only view the changes as a series of \"diff hunks\". CodeStream provides that view as well, but if you'd prefer to see the changes in the context of the full file, and not just the lines that changed, you can use either List View or Tree View. Just select the code you want to comment on, and then click on the Comment button (or select Comment from the context menu). When commenting you can either add a single comment, or start a review. Another difference is that CodeStream allows you to comment on lines of code that haven't changed. You can select ANY lines of code in the diff, and not just those that are part of the changeset. Note that these comments are added as a \"single comment\" to the pull request and aren't part of any review you may have in progress. All the power of GitHub pull requests and GitLab merge requests, and then some, right in your IDE. Leveraging pull request comments Once the pull request has been approved and the code has been merged that's usually the end of life for any comments in that pull request. Although there is often useful information in those comments, that may have long-term value, they are rarely seen again. CodeStream gives those comments a second life by displaying them alongside the blocks of code that they refer to. To have pull request comments displayed as annotions in your codemarks, as well as in the Codemarks section of the CodeStream pane, click on the gear icon in that section and check the box to \"Show comments from pull requests\". When you first check that box, if you haven’t already authenticated with your code-hosting service you’ll be prompted to do so. Comments from merged PRs will appear next to the blocks of code they refer to. Comments from open PRs will also be included if you are on a relevant branch. For example, if the open PR is a request to merge the feature/some-name branch into main, you’ll see comments from that PR if you are checked out to either feature/some-name or main, but not when you’re on any other branch. As the code evolves, the location of each comment is automatically updated so that it remains linked to the block of code it refers to. Note that PR comments for a given file are updated roughly every 30 minutes, so new comments may not appear right away. You can force an update by restarting your IDE.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 592.43475,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage pull <em>requests</em> <em>on</em> <em>CodeStream</em>",
        "sections": "Manage pull <em>requests</em> <em>on</em> <em>CodeStream</em>",
        "body": "For most development teams, the final step in the development process is a pull <em>request</em>. Even if your team has decided to use <em>CodeStream</em>&#x27;s <em>feedback</em> requests as a replacement for, and not just a precursor to, your end-of-cycle PR-based <em>code</em> reviews, <em>CodeStream</em> allows you to keep all of that workflow"
      },
      "id": "61744006196a67ee542f0555"
    },
    {
      "image": "https://docs.newrelic.com/static/a6aec54accbdc1434b605775cb1bb6a6/f96db/FRSection1.png",
      "url": "https://docs.newrelic.com/docs/codestream/codestream-ui-overview/feedback-requests-section/",
      "sections": [
        "CodeStream feedback requests"
      ],
      "published_at": "2021-10-24T21:15:45Z",
      "title": "CodeStream feedback requests",
      "updated_at": "2021-10-23T16:58:50Z",
      "type": "docs",
      "external_id": "def1d9cba862bb96307f99a80da7c7a634355582",
      "document_type": "page",
      "popularity": 1,
      "body": "The Feedback Requests section of the CodeStream pane lists all open feedback requests that have been assigned to you or that you have requested, as well as your recent feedback requests that have been approved or where changes have been requested. Click on a request to jump in and start reviewing, or to see your teammate’s comments on your work. When you hover over the Feedback Requests section heading, you'll see a \"+\" icon to create a new feedback request. If you're an admin you'll also see a gear icon to control how both feedback request assignments and approvals work for your organization. By default, the person requesting feedback can decide how approvals work, but you can, instead, set a default behavior for all feedback requests for the organization. Any reviewer can approve - Any one can approve the feedback request, regardless of how many reviewers are assigned. All reviewers must approve individually - Each assigned reviewer must individually approve the feedback request before it’s considered approved. You can also decide if and how CodeStream suggests reviewers. Round-robin will cycle through all developers in the organization. Random will randomly assign the feedback request to any developer in the organization. The Authorship options will suggest up to three reviewers based on the developers who wrote the lines of code impacted by the changes, as well as other developers who may have committed to the branch.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 458.27814,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> <em>feedback</em> <em>requests</em>",
        "sections": "<em>CodeStream</em> <em>feedback</em> <em>requests</em>",
        "body": "The <em>Feedback</em> Requests section of the <em>CodeStream</em> pane lists all open <em>feedback</em> requests that have been assigned to you or that you have requested, as well as your recent <em>feedback</em> requests that have been approved or where changes have been requested. Click on a <em>request</em> to jump in and start reviewing"
      },
      "id": "61743f4ae7b9d2636813d144"
    }
  ],
  "/docs/codestream/how-use-codestream/start-work": [
    {
      "sections": [
        "New Relic Global Performance data sets",
        "Important",
        "Access valuable data and try out New Relic",
        "Get started with the Public API Performance dashboard"
      ],
      "title": "New Relic Global Performance data sets",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "ed1b2c2cdfb59dae247d2690bd470a93b585c9e8",
      "image": "https://docs.newrelic.com/static/2c9a2621107e0114a2c345fcbb22356f/8c557/Public-API-Performance-Dash-for-GPD.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/new-relic-global-performance-data-sets/",
      "published_at": "2021-10-24T20:04:26Z",
      "updated_at": "2021-10-24T20:04:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic’s Global Performance data sets offer immediate access to meaningful, large-scale, aggregated telemetry data. Global Performance data sets data are useful for: Existing New Relic customers who want to gain general monitoring and troubleshooting insights from a curated collection of aggregated, real-world data. Newcomers who want to get a feel for New Relic’s dashboards and data tools and view real data visualizations in order to make informed decisions about how to add their own data to New Relic. This resource provides information about the Global Performance data sets, how they work, what they do, and current options for accessing Global Performance data. Public API Performance dashboard Important Please note: Global Performance data sets are presented as-is. Global Performance data sets represent an aggregate of samples across a range of sources, and New Relic makes no effort to attempt to confirm the correctness, completeness, or veracity of the data. This data should not be relied on as the sole source of information for any purpose you may use it, and New Relic is not responsible for decisions made in reliance on this data. Global Performance data sets should not be viewed as either an endorsement or a recommendation by New Relic of the technologies represented in the data sets. Access valuable data and try out New Relic Our first Global Performance data set, Public API Performance, offers a large body of real-world, real-time data about the performance of public APIs including AWS, Google, and more as experienced by New Relic customers (as authorized). Because this data is already flowing through New Relic, you can access it within seconds of activating your account, and test drive New Relic dashboarding and querying capabilities in the process. There’s no need to connect your own data sources to New Relic first, although we recommend you do so because adding your own data is easy, free, and the best way to understand how New Relic can serve your business needs. Get started with the Public API Performance dashboard To help you get started using Public API Performance data, we've created a Public API Performance dashboard. This dashboard provides both actionable general insights and analytics and also an example of how you might apply dashboarding capabilities to your own data. Both new and existing customers should be able to view Global Performance data in the Public API Performance dashboard quickly and easliy. To start using this dashboard, see Explore the Public API Performance dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.44551,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> Relic Global Performance data sets",
        "sections": "<em>Access</em> valuable data <em>and</em> try out <em>New</em> Relic",
        "tags": "Explore <em>and</em> query data",
        "body": " they <em>work</em>, what they do, and current options for accessing Global Performance data. Public API Performance dashboard Important Please note: Global Performance data sets are presented as-is. Global Performance data sets represent an aggregate of samples across a range of sources, and <em>New</em> Relic makes"
      },
      "id": "60445920196a673eee960f25"
    },
    {
      "sections": [
        "Use content types and text formats",
        "Docs meta content (frontmatter)",
        "Document body",
        "Page templates"
      ],
      "title": "Use content types and text formats",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "22895e5a8b552b1cc2b278bf117f7269a539a61e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/use-content-types-text-formats/",
      "published_at": "2021-10-24T23:44:06Z",
      "updated_at": "2021-10-19T03:56:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our docs site is made up of different content types and templates. Most of the time, the default page content type and the basic template will have everything you'll need. Read on for more information about our page types. Docs meta content (frontmatter) Thr top of every doc begins with a set of metadata. Read on for more information about this metadata content: Meta content field Description Title Whenever possible, provide an action-oriented or task-oriented title; for example, \"AJAX page: Identify time-consuming calls.\" In general, use sentence case. Capitalize only the first word. Do not capitalize any other word in the title unless it's a proper noun, such as a specific product name, or it follows a colon (:). If you're looking for ideas on how to choose a title, browse the titles of similar docs. The title used in the sidebar (left navigation pane) is set in the nav file. type For the basicDoc template, use page or omit type. If omitted, the default type is page and the basicDoc template is used. template The template determines the basic layout and style of a page. Use basicDoc for more pages. tags Keywords related to your doc. Through some technical wizardry, they generate Related resources links in the right nav area. Start each topic with a - on a new line. A topic can include multiple words separated by spaces. japaneseVersion The URL to the Japanese language version of the doc. Leave this blank if there isn't a Japanese version. Document body The document body is where you edit the page content. Use the GitHub Markdown format when you write content. Page templates For most situations, use the basicDoc page template. Read on for information about our other page templates. Content type Description Basic page A standard HTML webpage without special fields. This content type is used for the majority of content on the site. API doc This format is for API reference documentation. For more information, see apiStyleGuidelines (for style guidelines) and Work with the API doc content type (for how to use and configure). Attribute definition This format is for defining attributes and event types. These definitions are shared with the UI via the data dictionary service. For more information, see Work with attribute definition content type. Landing pages This format is for a more user-friendly and readable landing page, which replaces the standard taxonomy list views. For more information, see Working with landing pages. Release notes This format includes specific fields for release notes. Users rely on release notes to keep up with smaller changes in the product, particularly for downloadble software like the agents. For more information, see Create release notes. What's New posts This format includes specific fields for product announcements. What's New posts are created by PMM for larger announcements. They're available in the docs site, but they're also visible in the New Relic One UI. For more information, see What's New style guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.59236,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use content types <em>and</em> text formats",
        "sections": "Use content types <em>and</em> text formats",
        "tags": "Processes <em>and</em> procedures",
        "body": " Related resources links in the right nav area. <em>Start</em> each topic with a - on a <em>new</em> line. A topic can include multiple words separated by spaces. japaneseVersion The URL to the Japanese language version of the doc. Leave this blank if there isn&#x27;t a Japanese version. Document body The document body"
      },
      "id": "6042220e64441f28b64e8843"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/serverless-function-monitoring/aws-lambda-monitoring/enable-lambda-monitoring/enable-serverless-monitoring-aws-lambda-legacy/",
      "sections": [
        "Legacy manual instrumentation for Lambda monitoring",
        "Go",
        "Zip and upload recommendations",
        "Java",
        "Tip",
        ".NET Core",
        "Async handler function",
        "Inheriting from APIGatewayProxyFunction",
        "Important",
        "Using the SQS Wrapper",
        "Using the SNS Wrapper",
        "Node.js",
        "Python"
      ],
      "published_at": "2021-10-25T17:51:59Z",
      "title": "Legacy manual instrumentation for Lambda monitoring",
      "updated_at": "2021-10-19T00:59:11Z",
      "type": "docs",
      "external_id": "694e22b2ce401a96d200ab2e12a08850532b3e5a",
      "document_type": "page",
      "popularity": 1,
      "body": "On this page, you will learn how to manually instrument your lambda function. It's organized by runtime language. Go To instrument your Go-language Lambda: Download our Go agent package and place it in the same directory as your function. Install the agent: go get -u github.com/newrelic/go-agent/v3/newrelic. Install the nrlambda integration go get -u github.com/newrelic/go-agent/v3/integrations/nrlambda. In your Lambda code, import our components, create an application, and update how you start your Lambda. See our instrumentation examples: Extension repo Go agent repo Optional: Add custom events that will be associated with your Lambda invocation by using the RecordCustomEvent API. For example: func handler(ctx context.Context) { if txn := newrelic.FromContext(ctx); nil != txn { txn.Application().RecordCustomEvent(\"MyEvent\", map[string]interface{}{ \"zip\": \"zap\", }) } fmt.Println(\"hello world!\") } Copy Build and zip your Lambda function and upload it to AWS. Zip and upload recommendations Here are suggestions for zipping and uploading the Lambda: Build the binary for execution on Linux. This produces a binary file called main. You can use: $ GOOS=linux go build -o main Copy Zip the binary into a deployment package using: $ zip deployment.zip main Copy Upload the zip file to AWS using either the AWS Lambda console or the AWS CLI. Name the handler main (to match the name given during the binary build). The following environment variables are not required for Lambda monitoring to function but they are required if you want your Lambda functions to be included in distributed traces. To enable distributed tracing, set these environment variables in the AWS console: NEW_RELIC_ACCOUNT_ID. Your account ID. NEW_RELIC_TRUSTED_ACCOUNT_KEY. This is also your account ID. If your account is a child account, this is the account ID for the root/parent account. Optional: To configure logging, see Go agent logging. Invoke the Lambda at least once. This creates a CloudWatch log group, which must be present for the next step to work. Our wrapper gathers data about the Lambda execution, generates a JSON message, and logs it to CloudWatch Logs. Next, you'll configure CloudWatch to send those logs to New Relic. Java Monitoring for AWS Lambda in Java doesn't use our APM Java agent. Instead, it uses these two OpenTracing dependencies: AWS Lambda OpenTracing Java SDK: OpenTracing instrumentation for AWS Lambda RequestHandler and RequestStreamHandler. Our AWS Lambda OpenTracing Tracer: An OpenTracing Tracer implementation designed to monitor AWS Lambda. It generates spans, error events, transaction events, error traces, and provides distributed tracing support. Tip Supported OpenTracing Versions OpenTracing 0.31.0: Lambda Tracer: com.newrelic.opentracing:newrelic-java-lambda:1.1.1 Lambda SDK: com.newrelic.opentracing:java-aws-lambda:1.0.0 OpenTracing 0.32.0, 0.33.0: Lambda Tracer: com.newrelic.opentracing:newrelic-java-lambda:2.2.1 Lambda SDK: com.newrelic.opentracing:java-aws-lambda:2.1.0 To instrument your Java Lambda: In your project’s build.gradle file, include our OpenTracing AWS Lambda Tracer and the AWS Lambda OpenTracing SDK dependencies: dependencies { compile(\"com.newrelic.opentracing:java-aws-lambda:2.1.0\") compile(\"com.newrelic.opentracing:newrelic-java-lambda:2.2.1\") compile(\"io.opentracing:opentracing-util:0.33.0\") } Copy Implement the AWS Lambda RequestHandler interface as shown in the Java Lambda example and override the doHandleRequest method. In the doHandleRequest method, call the LambdaTracing.instrument(...) API to create a root span to trace the lambda function's execution. This is also where you will define your business logic for the lambda function. Register a LambdaTracer.INSTANCE as the OpenTracing Global tracer, as shown in the Java Lambda example. Create a ZIP deployment package and upload it to AWS Lambda. Or deploy it via other means. In the AWS Lambda console, set the handler. For the example Java Lambda, the handler would be com.handler.example.MyLambdaHandler::handleRequest. Because handleRequest is assumed, you could also use com.handler.example.MyLambdaHandler. The following AWS console environment variables are required if you want your Lambda function to be included in distributed tracing. This is recommended. NEW_RELIC_ACCOUNT_ID. Your account ID. NEW_RELIC_PRIMARY_APPLICATION_ID. This is also your account ID. NEW_RELIC_TRUSTED_ACCOUNT_KEY. This is also your account ID. If your account is a child account, this must be the account ID for the root/parent account. Optional: In the Lambda console, enable debug logging by adding this environment variable: NEW_RELIC_DEBUG is true. Invoke the Lambda at least once. This creates a CloudWatch log group, which must be present for the next step to work. Our wrapper gathers data about the Lambda execution, generates a JSON message, and logs it to CloudWatch Logs. Next, you'll configure CloudWatch to send those logs to New Relic. Please see the AWS Lambda distributed tracing example for a complete project that illustrates common use cases such as: Distributed tracing between Lambda functions Manual span creation (aka custom instrumentation) Tracing external calls Adding custom attributes (aka Tags) to spans .NET Core Our monitoring of .NET Core-based AWS Lambda functions doesn't use our standard .NET Core APM agent. Instead, it uses a NuGet package. To instrument your .NET Core Lambda: In your Lambda Functions project, install the NewRelic.OpenTracing.AmazonLambda.Tracer NuGet package. Note: NewRelic.OpenTracing.AmazonLambda.Tracer depends on version 1.2.0+ of Amazon.Lambda.APIGatewayEvent NuGet package. If the environment already uses a lower version of Amazon.Lambda.APIGatewayEvent, the New Relic package may produce errors such as System.MissingMethodException . Import the NuGet package and OpenTracing utils: using OpenTracing.Util; using NewRelic.OpenTracing.AmazonLambda; Copy Instrument your function, as shown in this example: public class Function { static Function() { // Register The NewRelic Lambda Tracer Instance GlobalTracer.Register(NewRelic.OpenTracing.AmazonLambda.LambdaTracer.Instance); } public object FunctionWrapper(ILambdaContext context) { // Instantiate NewRelic TracingWrapper and pass your FunctionHandler as // an argument return new TracingRequestHandler().LambdaWrapper(FunctionHandler, context); } /// <summary> /// A simple function that takes a string and does a ToUpper /// </summary> /// <param name=\"input\"></param> /// <param name=\"context\"></param> /// <returns></returns> public object FunctionHandler(ILambdaContext context) { ... } } Copy Tip The arguments passed to FunctionWrapper must match the signature of FunctionHandler. If your handler function returns a Task, the Lambda wrapper will block on the return task until it completes, so that it can measure the duration and capture exceptions, if any are present. In addition, you may also inherit from the APIGatewayProxyFunction. For an example, see below: Async handler function public async Task<int> FunctionHandlerAsync(ILambdaContext lambdaContext) { return await new TracingRequestHandler().LambdaWrapper( ActualFunctionHandlerAsync, lambdaContext); } public async Task<APIGatewayProxyResponse> ActualFunctionHandlerAsync(ILambdaContext lambdaContext) { // Function can make other async operations here ... } Copy Inheriting from APIGatewayProxyFunction public class LambdaFunction : APIGatewayProxyFunction { static LambdaFunction() { // Register The NewRelic Lambda Tracer Instance OpenTracing.Util.GlobalTracer.Register(NewRelic.OpenTracing.AmazonLambda.LambdaTracer.Instance); } public override Task<APIGatewayProxyResponse> FunctionHandlerAsync(APIGatewayProxyRequest request, ILambdaContext lambdaContext) { Task<APIGatewayProxyResponse> task = new TracingRequestHandler().LambdaWrapper(ActualFunctionHandlerAsync, request, lambdaContext); return task; } public Task<APIGatewayProxyResponse> ActualFunctionHandlerAsync(APIGatewayProxyRequest request, ILambdaContext lambdaContext) { return base.FunctionHandlerAsync(request, lambdaContext); } } Copy Optional for SQS and SNS: Starting in version 1.0 of our .NET Lambda Tracer, distributed tracing support has been added for SQS and SNS. To enable distributed tracing for SQS or SNS you will need to complete the items in this step as well as setup the environment variables in the step that follows this one. Important Enabling distributed tracing support for SQS and SNS will disable automatic instrumentation for both of SQS and SNS and require the use of these wrappers to instrument them. Set the NEW_RELIC_USE_DT_WRAPPER environment variable to true. To instrument SQS and SNS calls you will need to use the provided wrappers. Using the SQS Wrapper The SQS wrapper supports wrapping the following methods: Amazon.SQS.AmazonSQSClient.SendMessageAsync(...) Amazon.SQS.AmazonSQSClient.SendMessageBatchAsync(...) Examples // SQS Client AmazonSQSClient client = new AmazonSQSClient(\"AWS_SECRET_ACCESS_KEY\", AWS_REGION); // SendMessageRequest SendMessageRequest sendRequest = new SendMessageRequest(\"QUEUE_URI_STRING\", \"An SQS Message\"); Task<SendMessageResponse> responseOne = SQSWrapper.WrapRequest(client.SendMessageAsync, sendRequest); // String-based Task<SendMessageResponse> responseTwo = SQSWrapper.WrapRequest(client.SendMessageAsync, \"QUEUE_URI_STRING\", \"Another SQS Message\"); // SendMessageBatchRequest List<SendMessageBatchRequestEntry> batchEntries = new List<SendMessageBatchRequestEntry>(); batchEntries.Add(new SendMessageBatchRequestEntry(\"id1\", \"First SQS Message\")); batchEntries.Add(new SendMessageBatchRequestEntry(\"id2\", \"Second SQS Message\")); batchEntries.Add(new SendMessageBatchRequestEntry(\"id3\", \"Third SQS Message\")); SendMessageBatchRequest sendBatchRequest = new SendMessageBatchRequest(QUEUE_URI, batchEntries); Task<SendMessageBatchResponse> response = SQSWrapper.WrapRequest(client.SendMessageBatchAsync, sendBatchRequest); // SendMessageBatchRequestEntry List List<SendMessageBatchRequestEntry> moreBatchEntries = new List<SendMessageBatchRequestEntry>(); batchEntries.Add(new SendMessageBatchRequestEntry(\"id4\", \"Fourth SQS Message\")); batchEntries.Add(new SendMessageBatchRequestEntry(\"id5\", \"Fifth SQS Message\")); batchEntries.Add(new SendMessageBatchRequestEntry(\"id6\", \"Sixth SQS Message\")); Task<SendMessageBatchResponse> response = SQSWrapper.WrapRequest(client.SendMessageBatchAsync, moreBatchEntries); Copy Using the SNS Wrapper The SNS wrapper supports wrapping the following methods: Amazon.SimpleNotificationService.AmazonSimpleNotificationServiceClient.PublishAsync(...) Examples // SNS Client AmazonSimpleNotificationServiceClient client = new Amazon.SimpleNotificationService.AmazonSimpleNotificationServiceClient(\"AWS_SECRET_ACCESS_KEY\", AWS_REGION); // PublishRequest - Phone Number PublishRequest phonePublishRequest = new PublishRequest(); phonePublishRequest.PhoneNumber = +1XXX5555100; phonePublishRequest.Message = \"An SNS Message for phones\"; Task<PublishResponse> phoneResponse = SNSWrapper.WrapRequest(client.PublishAsync, phonePublishRequest); // PublishRequest - ARN PublishRequest publishRequest = new PublishRequest(\"TOPIC_ARN\", \"An SNS Message\"); Task<PublishResponse> publishResponse = SNSWrapper.WrapRequest(client.PublishAsync, publishRequest); // String-based without subject Task<PublishResponse> ResponseOne = SNSWrapper.WrapRequest(client.PublishAsync, \"TOPIC_ARN\", \"Another SNS Message\"); // String-based with subject Task<PublishResponse> ResponseTwo = SNSWrapper.WrapRequest(client.PublishAsync, \"TOPIC_ARN\", \"Yet Another SNS Message\", \"A Subject\"); Copy The following environment variables are not required for Lambda monitoring to function but they are required if you want your Lambda functions to be included in distributed traces. To enable distributed tracing, set these environment variables in the AWS Lambda console: NEW_RELIC_ACCOUNT_ID: The account ID the Lambda is reporting to. NEW_RELIC_TRUSTED_ACCOUNT_KEY: This is also the account ID. If your account is a child account, this needs to be the account ID for the root/parent account. Ensure that the wrapper function (FunctionWrapper in above example) is set up as the function handler. Invoke the Lambda at least once. This creates a CloudWatch log group, which must be present for the next step to work. Our wrapper gathers data about the Lambda execution, generates a JSON message, and logs it to CloudWatch Logs. Next you'll configure CloudWatch to send those logs to New Relic. Node.js To instrument your Node.js Lambda: Download our Node.js agent package and place it in the same directory as your function, ensuring the agent is installed as a dependency in the node_modules directory. Use the Node Package Manager: npm install newrelic --save Copy Install our AWS SDK module alongside the Node.js agent: npm install @newrelic/aws-sdk --save Copy In your Lambda code, require the agent module and the AWS SDK at the top of the file, and wrap the handler function. For example: const newrelic = require('newrelic'); require('@newrelic/aws-sdk'); // Other module loads go under the two require statements above module.exports.handler = newrelic.setLambdaHandler((event, context, callback) => { // This is your handler function code console.log('Lambda executed'); callback(); }); Copy Optional: You can also add custom events to your Lambda using the recordCustomEvent API. For example: module.exports.handler = newrelic.setLambdaHandler((event, context, callback) => { newrelic.recordCustomEvent(‘MyEventType’, {foo: ‘bar’}); console.log('Lambda executed'); callback(); }); Copy Zip your Lambda function and the Node.js agent folder together. Requirements and recommendations: The New Relic files outside the New Relic agent folder don't need to be included. If your Lambda function file name is, for example, lambda_function.node, we recommend naming your zip file lambda_function.zip. Do not use a tarball. Your Lambda and its associated modules must all be in the zip file's root directory. This means that if you zip a folder that contains the files, it won't work. Upload the zipped file to your AWS Lambda account. In the AWS console, set these environment variables: NEW_RELIC_NO_CONFIG_FILE. Set to true if not using a configuration file. NEW_RELIC_APP_NAME: Your application name. NEW_RELIC_ACCOUNT_ID. Your account ID. NEW_RELIC_TRUSTED_ACCOUNT_KEY. This is also your account ID. If your account is a child account, this needs to be the account ID for the root/parent account. Optional: To run the agent in serverless mode outside of AWS in a local environment, set the environment variable NEW_RELIC_SERVERLESS_MODE_ENABLED to true. (When executing this in an AWS Lambda environment, the agent will automatically run in serverless mode. Do not use this variable if you're running in AWS.) Optional: To enable logging in serverless mode, set these environment variables: Set NEW_RELIC_LOG_ENABLED to true. Set NEW_RELIC_LOG to stdout for output to CloudWatch, or set to any writeable file location. The log level is set to info by default. See other log levels. Invoke the Lambda at least once. This creates a CloudWatch log group, which must be present for the next step to work. Our wrapper gathers data about the Lambda execution, generates a JSON message, and logs it to CloudWatch Logs. Next you'll configure CloudWatch to send those logs to New Relic. Python To instrument your Python Lambda: Download our Python agent package and place it in the same directory as your function. To do this, use pip: pip install -t . newrelic Copy Important If you use Homebrew, you may get this error: DistutilsOptionError: must supply either home or prefix/exec-prefix -- not both. For details, see the Homebrew GitHub post. In your Lambda code, import the Python agent module and decorate the handler function using the New Relic decorator. The New Relic package must be imported first in your code. Here's an example: import newrelic.agent newrelic.agent.initialize() @newrelic.agent.lambda_handler() def handler(event, context): ... Copy Optional: You can also add custom events to your Lambda using the record_custom_event API. Here's an example: @newrelic.agent.lambda_handler() def handler(event, context): newrelic.agent.record_custom_event('CustomEvent', {'foo': 'bar'}) … Copy Zip your lambda_function.py and newrelic/ folder together using these guidelines: The New Relic files outside the newrelic/ folder don't need to be included. If your Lambda function file name is, for example, lambda_function.py, name your zip file lambda_function.zip. Do not use a tarball. Your Lambda and its associated modules must all be in the zip file's root directory. This means that if you zip a folder that contains the files, it won't work. Upload the zipped file to your AWS Lambda account. In the AWS console, set this environment variable: NEW_RELIC_SERVERLESS_MODE_ENABLED. Set to true The following environment variables are not required for Lambda monitoring to function but they are required if you want your Lambda functions to be included in distributed traces. To enable distributed tracing, set these environment variables in the AWS console: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED. Set to true. NEW_RELIC_ACCOUNT_ID. Your account ID. NEW_RELIC_TRUSTED_ACCOUNT_KEY. This is also your account ID. If your account is a child account, this needs to be the account ID for the root/parent account. Optional: To configure logging, use the NEW_RELIC_LOG and NEW_RELIC_LOG_LEVEL environment variables in the AWS Console. Invoke the Lambda at least once. This creates a CloudWatch log group, which must be present for the next step to work. The New Relic decorator gathers data about the Lambda execution, generates a JSON message, and logs it to CloudWatch Logs. Next, configure CloudWatch to send those logs to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 88.70466,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Zip <em>and</em> upload recommendations",
        "body": ", this must be the account ID for the root&#x2F;parent account. Optional: In the Lambda console, enable debug logging by adding this environment variable: <em>NEW</em>_RELIC_DEBUG is true. Invoke the Lambda at least once. This creates a CloudWatch log group, which must be present for the next step to <em>work</em>. Our"
      },
      "id": "603ebbcb64441f800a4e8850"
    }
  ],
  "/docs/codestream/start-here/codestream-new-relic": [
    {
      "image": "https://docs.newrelic.com/static/a79469e10e231d9271d618d34c0e85d1/e17e5/ObservabilitySection-connect.png",
      "url": "https://docs.newrelic.com/docs/codestream/codestream-ui-overview/observability-section/",
      "sections": [
        "CodeStream observability",
        "Connect CodeStream and New Relic",
        "See your errors in CodeStream",
        "Tip"
      ],
      "published_at": "2021-10-24T21:17:20Z",
      "title": "CodeStream observability",
      "updated_at": "2021-10-23T16:59:55Z",
      "type": "docs",
      "external_id": "15085b32c3ff3c5e4a469b6ef9151cdb8624b25a",
      "document_type": "page",
      "popularity": 1,
      "body": "In order to get the most out of CodeStream and New Relic, connect CodeStream to New Relic via your New Relic user key. Once that's done, for entities you're monitoring with New Relic, you'll see your errors directly in CodeStream. Connect CodeStream and New Relic Before you can start seeing errors in your IDE and take advantage of other New Relic and CodeStream features, you'll need to enter your New Relic user key. Go here to get or create your New Relic user key. Once you have your user key, in Observability click Connect to New Relic One, then paste your user key and click Connect. See your errors in CodeStream Once you've connected New Relic to CodeStream, you'll see observed errors directly in CodeStream. These sections help you and your team manage and see your errors in different ways: Errors assigned to me: If an error has been assigned to you, you'll see it here. Recent errors in: Each repository you have open in your IDE will have its own grouping of errors. If your repository URL is mapped to more than one entity you're observing in New Relic, a dropdown lets you filter by entity. Select entity from New Relic: Use this to connect a repository in your IDE with an entity you're observing with New Relic. Tip If your project isn't monitored by New Relic, you can use CodeStream to get that started. In the CodeStream extension, in the Observability section, click the gear icon, and then click Instrument my App. Follow the instructions to instrument your code.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2119.7312,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> observability",
        "sections": "Connect <em>CodeStream</em> <em>and</em> <em>New</em> <em>Relic</em>",
        "body": "In order to get the most out of <em>CodeStream</em> and <em>New</em> <em>Relic</em>, connect <em>CodeStream</em> to <em>New</em> <em>Relic</em> via your <em>New</em> <em>Relic</em> user key. Once that&#x27;s done, for entities you&#x27;re monitoring with <em>New</em> <em>Relic</em>, you&#x27;ll see your errors directly in <em>CodeStream</em>. Connect <em>CodeStream</em> and <em>New</em> <em>Relic</em> Before you can start seeing errors"
      },
      "id": "61743f8be7b9d2b9d113c7cc"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/new-relic-codestream-quick-start/",
      "sections": [
        "New Relic and CodeStream quick start",
        "Preview release",
        "Start with a New Relic account",
        "Install CodeStream via New Relic",
        "Install CodeStream in your IDE",
        "Install New Relic"
      ],
      "published_at": "2021-10-24T21:20:26Z",
      "title": "New Relic and CodeStream quick start",
      "updated_at": "2021-10-23T17:07:51Z",
      "type": "docs",
      "external_id": "a033944a31b2a9b7c5c5dba553e592a856c41890",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these quick steps to get started with New Relic and CodeStream. Preview release CodeStream's integration with New Relic One is a preview release limited to New Relic One accounts on our US data center, and your use is subject to the pre-release policy. (This does not apply to all other CodeStream functionality.) Start with a New Relic account If you don't have a New Relic account, sign up at newrelic.com/signup. It's free, forever! Install CodeStream via New Relic Use our CodeStream quickstart to install it for your IDE. Install CodeStream in your IDE You can also install CodeStream via your Visual Studio Code and Visual Studio extensions menu or JetBrains plugins menu. Install New Relic Follow the steps in our Add your data UI page to get data flowing in. For your first install, we recommend using Guided install option, which will set up many integrations with a single command. (Go here for EU Guided install.)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2016.5765,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>and</em> <em>CodeStream</em> quick start",
        "sections": "<em>New</em> <em>Relic</em> <em>and</em> <em>CodeStream</em> quick start",
        "body": "Follow these quick steps to get started with <em>New</em> <em>Relic</em> and <em>CodeStream</em>. Preview release <em>CodeStream</em>&#x27;s integration with <em>New</em> <em>Relic</em> One is a preview release limited to <em>New</em> <em>Relic</em> One accounts on our US data center, and your use is subject to the pre-release policy. (This does not apply to all other"
      },
      "id": "6174416728ccbc350fc6a7be"
    },
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-10-26T01:45:08Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1732.8925,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> monitoring",
        "sections": "See your errors in <em>CodeStream</em>",
        "tags": "<em>New</em> <em>Relic</em> Mobile <em>Android</em>",
        "body": " by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in <em>CodeStream</em> You can also see your Android application&#x27;s directly in your IDE using <em>CodeStream</em> and errors inbox. To do this, install <em>CodeStream</em>, connect <em>CodeStream</em> and <em>New</em> <em>Relic</em> and create Git tags that match your appVersion."
      },
      "id": "6043a48f196a6784e6960f6d"
    }
  ],
  "/docs/codestream/start-here/codestream-user-guide": [
    {
      "sections": [
        "CodeStream licenses"
      ],
      "title": "CodeStream licenses",
      "type": "docs",
      "tags": [
        "Licenses",
        "Product or service licenses",
        "CodeStream"
      ],
      "external_id": "331f3d1cd0897f453f98bc054fda09a9ad2725c1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/codestream/codestream-licenses/",
      "published_at": "2021-10-24T17:53:35Z",
      "updated_at": "2021-10-23T17:05:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We love open-source software, and we use the following with CodeStream. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we've chosen to use. CodeStream license on GitHub CodeStream's third-party software notices on GitHub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 643.05164,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> licenses",
        "sections": "<em>CodeStream</em> licenses",
        "tags": "<em>CodeStream</em>",
        "body": "We love open-source software, and we use the following with <em>CodeStream</em>. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we&#x27;ve chosen to use. <em>CodeStream</em> license on GitHub <em>CodeStream</em>&#x27;s third-party software notices on GitHub"
      },
      "id": "617440e2196a677ea62f0193"
    },
    {
      "image": "https://docs.newrelic.com/static/a79469e10e231d9271d618d34c0e85d1/e17e5/ObservabilitySection-connect.png",
      "url": "https://docs.newrelic.com/docs/codestream/codestream-ui-overview/observability-section/",
      "sections": [
        "CodeStream observability",
        "Connect CodeStream and New Relic",
        "See your errors in CodeStream",
        "Tip"
      ],
      "published_at": "2021-10-24T21:17:20Z",
      "title": "CodeStream observability",
      "updated_at": "2021-10-23T16:59:55Z",
      "type": "docs",
      "external_id": "15085b32c3ff3c5e4a469b6ef9151cdb8624b25a",
      "document_type": "page",
      "popularity": 1,
      "body": "In order to get the most out of CodeStream and New Relic, connect CodeStream to New Relic via your New Relic user key. Once that's done, for entities you're monitoring with New Relic, you'll see your errors directly in CodeStream. Connect CodeStream and New Relic Before you can start seeing errors in your IDE and take advantage of other New Relic and CodeStream features, you'll need to enter your New Relic user key. Go here to get or create your New Relic user key. Once you have your user key, in Observability click Connect to New Relic One, then paste your user key and click Connect. See your errors in CodeStream Once you've connected New Relic to CodeStream, you'll see observed errors directly in CodeStream. These sections help you and your team manage and see your errors in different ways: Errors assigned to me: If an error has been assigned to you, you'll see it here. Recent errors in: Each repository you have open in your IDE will have its own grouping of errors. If your repository URL is mapped to more than one entity you're observing in New Relic, a dropdown lets you filter by entity. Select entity from New Relic: Use this to connect a repository in your IDE with an entity you're observing with New Relic. Tip If your project isn't monitored by New Relic, you can use CodeStream to get that started. In the CodeStream extension, in the Observability section, click the gear icon, and then click Instrument my App. Follow the instructions to instrument your code.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 262.22815,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> observability",
        "sections": "<em>CodeStream</em> observability",
        "body": "In order to get the most out of <em>CodeStream</em> and New Relic, connect <em>CodeStream</em> to New Relic via your New Relic <em>user</em> key. Once that&#x27;s done, for entities you&#x27;re monitoring with New Relic, you&#x27;ll see your errors directly in <em>CodeStream</em>. Connect <em>CodeStream</em> and New Relic Before you can start seeing errors"
      },
      "id": "61743f8be7b9d2b9d113c7cc"
    },
    {
      "image": "https://docs.newrelic.com/static/955e077a4753336027d003cec2388566/c5bb3/connect-repo.png",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/codestream-new-relic/",
      "sections": [
        "CodeStream and New Relic",
        "Preview release",
        "Connect CodeStream and New Relic",
        "Caution",
        "See your errors and what's causing them",
        "Tip",
        "How to go from errors inbox to your IDE",
        "APM errors and CodeStream",
        "Give us your repository's URL",
        "Use environment variable with APM (recommended)",
        "Use the UI",
        "Use the NerdGraph API",
        "Install APM agents with CodeStream",
        "Dynamic logging with Go and Pixie"
      ],
      "published_at": "2021-10-24T21:20:27Z",
      "title": "CodeStream and New Relic",
      "updated_at": "2021-10-23T16:54:24Z",
      "type": "docs",
      "external_id": "a6c04d95011d9150cb0798580c15695bb9f3bbda",
      "document_type": "page",
      "popularity": 1,
      "body": "CodeStream and New Relic work together in several ways to give you insight into your code's errors, as well as making it easier to get started instrumenting your code with our APM agents. Specifically, when CodeStream is connected to New Relic, you can to jump from a stack trace error in the New Relic UI directly to the offending line of code in your IDE. Once in your IDE, you can use all of CodeStream's collaboration tools to discuss the code, request feedback, and submit a pull request to resolve the issue and push up the fix to your repository. Preview release CodeStream's integration with New Relic One is a preview release limited to New Relic One accounts on our US data center, and your use is subject to the pre-release policy. (This does not apply to all other CodeStream functionality.) Connect CodeStream and New Relic Before you can take advantage of New Relic's observability features in CodeStream, you'll need to connect them. Requirements for connecting CodeStream and New Relic: New Relic account (If you don't have a New Relic account, sign up at newrelic.com/signup. It's free, forever!) New Relic user key If you don't have a user key or want to learn more about how you can use and manage them, see our doc on the New Relic user key. Once you have your New Relic user key, in CodeStream's Observability section click Connect to New Relic One, then paste your API key and click Connect. Caution New Relic users can share stacktrace errors on CodeStream. Once you've connected CodeStream to New Relic, any new users you add to your CodeStream organization can see those errors. See your errors and what's causing them After you connect CodeStream and New Relic, use workloads and errors inbox to jump to the offending code in your IDE. Requirements for opening stack trace errors in your IDE: New Relic account (If you don't have a New Relic account, sign up at newrelic.com/signup. It's free, forever!) New Relic user key CodeStream and New Relic connection Data being reported to New Relic via APM monitoring A workload for errors inbox An error For APM errors, your repository's commit hash and release tag New Relic errors inbox is a single place to proactively detect, prioritize, and take action on your errors before they impact customers. With CodeStream, you can jump from an error directly to the offending code in your IDE. Tip Limited to APM errors. How to go from errors inbox to your IDE From one.newrelic.com/, go to Errors Inbox, click a stack trace error, then click Open in IDE. APM errors and CodeStream To use CodeStream's Open in IDE with your APM stack trace errors, use environment variables to configure your APM agent with your application's commit sha and/or your release tag associated with the running version of your software. CodeStream only needs the first seven characters of your commit sha (for example, 734713b) to make this connection, but you can include the entire sha. Alternately, you can use a release tag (such as v0.1.209 or release-209) for CodeStream to find the correct version of your code. For New Relic APM, the commit and/or release tag (tags.commit and tags.releaseTag) are added as attributes on Transaction and TransactionError events. You can use APM environment variables to set these attributes. We recommend setting one or both of these variables as part of your build pipeline. NEW_RELIC_METADATA_COMMIT - The commit sha. You can include the whole thing or only the first seven characters. NEW_RELIC_METADATA_RELEASE_TAG - A release tag (such as v0.1.209 or release-209). This has the advantage of being human readable. For more on how to set these variables, here are specific configuration details for each language: Go Java .NET Node.js PHP Python Ruby Give us your repository's URL Once you've started monitoring for APM, mobile, browser, or Lambda, you can connect those things with your repository. In order to link your data in New Relic to your code, we need to know the URL for your repository. For example, the URL can be in either the SSH or HTTPS format: git@github.com:newrelic/beta-docs-site.git https://github.com/newrelic/beta-docs-site.git Caution It's possible to add the same GitHub repository more than once, if you're using different protocols to do so. The UI warns you about this, but won't prevent you from doing so. For example, https://github.com/tuna/repo and git@github.com:tuna/repo are the same repo, with different protocols. You can use any one of these methods to set up your repository: Use environment variable with APM (recommended) Set the environment variable NEW_RELIC_METADATA_REPOSITORY_URL. New Relic APM agents create the repository entity and associate it to your application entity automatically. This requires the SSH or HTTPS URL format. We recommend that these be set as part of your build pipeline. Use the UI Once you've started sending data to New Relic, use the UI to connect your related repository. For APM, mobile, browser, and Lambda monitoring, find the Connect repository button on the right-hand side. To connect your repository, click Connnect repository, then find an existing repository or add a new one. Use the NerdGraph API Use New Relic's NerdGraph APIsto create a repository and associate it with your application entities. Step 1: Create a repository entity To create a repository entity, use the referenceEntityCreateOrUpdateRepository API and make sure to save the GUID that's produced. The API takes the following parameters: accountId - the integer account ID for the account you want to add the repository to url - example https://github.com/newrelic/beta-docs-site.git name - example: newrelic/beta-docs-site mutation { referenceEntityCreateOrUpdateRepository(repositories: [{accountId: [YOUR_ACCOUNT_ID], name: \"[REPO_NAME]\", url: \"[REPO_URL]\"}]) { created failures { guid message type } } } Copy In order to find the entity you create, you can use a query like the following. Note that the URL you provided to referenceEntityCreateOrUpdateRepository gets saved as an entity tag. { actor { entitySearch(query: \"name = 'a name' OR tags.url = 'a url'\") { count query results { entities { guid name tags { key values } } } } } } Copy Step 2: Associate the repository entity to your application entity First, find the GUID for the application you want to associate your repository to. Parameters: sourceEntityGuid - the entity GUID of the application targetEntityGuid - the entity GUID of your repository type - always BUILT_FROM mutation { entityRelationshipUserDefinedCreateOrReplace(sourceEntityGuid: \"\", targetEntityGuid: \"\", type: BUILT_FROM) { errors { message type } } } Copy To see all entities related to your repository you can do a query like this: { actor { entity(guid: \"[YOUR_REPOSITORY_GUID]]\") { relatedEntities(filter: {direction: BOTH, relationshipTypes: {include: BUILT_FROM}}) { results { target { entity { name guid type } } type } } name type tags { values key } } } } Copy Step 3: Cleanup (if needed) Delete a repository with the following query: mutation DeleteRepository { entityDelete(guids: \"[ENTITY_GUID_HERE]]\") { deletedEntities failures { message guid } } } Copy Install APM agents with CodeStream Requirements for installing New Relic APM agents via CodeStream: New Relic account New Relic user key CodeStream and New Relic connection A supported language application codebase .NET Core Java Node.JS When you first connect CodeStream to New Relic, if you're working on an application's codebase that's not being monitored by New Relic, CodeStream will offer to instrument that application for you. Like New Relic's guided install, CodeStream will walk you through and automate all of the steps to installing the APM agent to start sending data to New Relic. This check only happens automatically when the initial connection is made. To do so later, in the CodeStream extension, click your username, then click New Relic Setup. Dynamic logging with Go and Pixie New Relic account New Relic user API key CodeStream and New Relic connection A Kubernetes cluster monitored by Pixie An application written in Go You can use CodeStream to enable dynamic logging for your Pixie-monitored Go applications. For relevant projects, you can use CodeStream to dynamically log your Go method names in your IDE.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 254.2622,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> and New Relic",
        "sections": "<em>CodeStream</em> and New Relic",
        "body": " features in <em>CodeStream</em>, you&#x27;ll need to connect them. Requirements for connecting <em>CodeStream</em> and New Relic: New Relic account (If you don&#x27;t have a New Relic account, sign up at newrelic.com&#x2F;signup. It&#x27;s free, forever!) New Relic <em>user</em> key If you don&#x27;t have a <em>user</em> key or want to learn more about how you"
      },
      "id": "6171e652196a67e9c92f0156"
    }
  ],
  "/docs/codestream/start-here/install-codestream": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/new-relic-codestream-quick-start/",
      "sections": [
        "New Relic and CodeStream quick start",
        "Preview release",
        "Start with a New Relic account",
        "Install CodeStream via New Relic",
        "Install CodeStream in your IDE",
        "Install New Relic"
      ],
      "published_at": "2021-10-24T21:20:26Z",
      "title": "New Relic and CodeStream quick start",
      "updated_at": "2021-10-23T17:07:51Z",
      "type": "docs",
      "external_id": "a033944a31b2a9b7c5c5dba553e592a856c41890",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these quick steps to get started with New Relic and CodeStream. Preview release CodeStream's integration with New Relic One is a preview release limited to New Relic One accounts on our US data center, and your use is subject to the pre-release policy. (This does not apply to all other CodeStream functionality.) Start with a New Relic account If you don't have a New Relic account, sign up at newrelic.com/signup. It's free, forever! Install CodeStream via New Relic Use our CodeStream quickstart to install it for your IDE. Install CodeStream in your IDE You can also install CodeStream via your Visual Studio Code and Visual Studio extensions menu or JetBrains plugins menu. Install New Relic Follow the steps in our Add your data UI page to get data flowing in. For your first install, we recommend using Guided install option, which will set up many integrations with a single command. (Go here for EU Guided install.)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1496.5002,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic and <em>CodeStream</em> quick start",
        "sections": "<em>Install</em> <em>CodeStream</em> via New Relic",
        "body": " <em>CodeStream</em> functionality.) Start with a New Relic account If you don&#x27;t have a New Relic account, sign up at newrelic.com&#x2F;signup. It&#x27;s free, forever! <em>Install</em> <em>CodeStream</em> via New Relic Use our <em>CodeStream</em> quickstart to <em>install</em> it for your IDE. <em>Install</em> <em>CodeStream</em> in your IDE You can also <em>install</em> <em>CodeStream</em>"
      },
      "id": "6174416728ccbc350fc6a7be"
    },
    {
      "image": "https://docs.newrelic.com/static/8945e0a9c512b8638ebf8165d47aee04/69902/QS-SignUp3.png",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/codestream-user-guide/",
      "sections": [
        "CodeStream user guide",
        "Quick Start",
        "1. Install the CodeStream extension in your IDE and sign up.",
        "2. Connect your tools",
        "3. Discuss any block of code, at any time",
        "4. Get feedback on your work in progress",
        "5. Create or review a pull request",
        "Help & Feedback"
      ],
      "published_at": "2021-10-24T21:19:37Z",
      "title": "CodeStream user guide",
      "updated_at": "2021-10-23T17:07:02Z",
      "type": "docs",
      "external_id": "fa9af0118a8872fea89fda91482c44fb69913ea2",
      "document_type": "page",
      "popularity": 1,
      "body": "Quick Start Use the navigation to the left to jump straight to any topic. Otherwise, read on to get started with CodeStream. 1. Install the CodeStream extension in your IDE and sign up. Install CodeStream for VS Code, Visual Studio or JetBrains. The CodeStream pane should automatically appear in the sidebar for VS Code, or in a tool window at the right side for a JetBrains IDE or Visual Studio. Click on \"Sign Up and Create a team\" if you are the first person from your team to join CodeStream, or paste in your invitation code if you were invited to a team already on CodeStream. Learn more about how to use CodeStream. 2. Connect your tools Create and review pull requests on GitHub, GitLab or Bitbucket. Create issues on Jira, Trello, and other issue trackers. Share code discussions on Slack or Microsoft Teams. CodeStream brings the tools you use every day together in your IDE. Click on your headshot at the top of the CodeStream pane and go to the Integrations page to get all of your tools connected. 3. Discuss any block of code, at any time Whether you're trying to understand someone else's code or getting help with some code you just wrote, just select the code and ask your question. Learn more about discussing code. 4. Get feedback on your work in progress Select \"Request Feedback\" from the \"+\" menu at any time in the development cycle, whether it’s a quick look over some work in progress (even uncommitted code!) or a formal review of a completed effort. Teammates can review your changes right in their IDE, with no need to switch branches or set aside their own work. Learn more about feedback requests. 5. Create or review a pull request Look for the Pull Requests section of the CodeStream sidebar to review an open pull request. Just click on a pull request (or load one from URL) to get a complete GitHub experience right in your IDE! Note that you can create a pull request in GitHub, GitLab or Bitbucket, but support for reviewing pull requests is currently only available for GitHub (cloud or Enterprise). Learn more about pull requests. Help & Feedback Report a bug or send a suggestion in GitHub issues. Contact us directly at support@codestream.com. Follow @teamcodestream for product updates and to share feedback and questions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1171.407,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> user guide",
        "sections": "1. <em>Install</em> the <em>CodeStream</em> extension in your IDE and sign up.",
        "body": "Quick Start Use the navigation to the left to jump straight to any topic. Otherwise, read on to get started with <em>CodeStream</em>. 1. <em>Install</em> the <em>CodeStream</em> extension in your IDE and sign up. <em>Install</em> <em>CodeStream</em> for VS <em>Code</em>, Visual Studio or JetBrains. The <em>CodeStream</em> pane should automatically appear"
      },
      "id": "61744137e7b9d2428b13c6a0"
    },
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-10-26T01:45:08Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1057.1816,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Install</em> the Android agent",
        "body": " by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in <em>CodeStream</em> You can also see your Android application&#x27;s directly in your IDE using <em>CodeStream</em> and errors inbox. To do this, <em>install</em> <em>CodeStream</em>, connect <em>CodeStream</em> and New Relic and create Git tags that match your appVersion."
      },
      "id": "6043a48f196a6784e6960f6d"
    }
  ],
  "/docs/codestream/start-here/new-relic-codestream-quick-start": [
    {
      "image": "https://docs.newrelic.com/static/8945e0a9c512b8638ebf8165d47aee04/69902/QS-SignUp3.png",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/codestream-user-guide/",
      "sections": [
        "CodeStream user guide",
        "Quick Start",
        "1. Install the CodeStream extension in your IDE and sign up.",
        "2. Connect your tools",
        "3. Discuss any block of code, at any time",
        "4. Get feedback on your work in progress",
        "5. Create or review a pull request",
        "Help & Feedback"
      ],
      "published_at": "2021-10-24T21:19:37Z",
      "title": "CodeStream user guide",
      "updated_at": "2021-10-23T17:07:02Z",
      "type": "docs",
      "external_id": "fa9af0118a8872fea89fda91482c44fb69913ea2",
      "document_type": "page",
      "popularity": 1,
      "body": "Quick Start Use the navigation to the left to jump straight to any topic. Otherwise, read on to get started with CodeStream. 1. Install the CodeStream extension in your IDE and sign up. Install CodeStream for VS Code, Visual Studio or JetBrains. The CodeStream pane should automatically appear in the sidebar for VS Code, or in a tool window at the right side for a JetBrains IDE or Visual Studio. Click on \"Sign Up and Create a team\" if you are the first person from your team to join CodeStream, or paste in your invitation code if you were invited to a team already on CodeStream. Learn more about how to use CodeStream. 2. Connect your tools Create and review pull requests on GitHub, GitLab or Bitbucket. Create issues on Jira, Trello, and other issue trackers. Share code discussions on Slack or Microsoft Teams. CodeStream brings the tools you use every day together in your IDE. Click on your headshot at the top of the CodeStream pane and go to the Integrations page to get all of your tools connected. 3. Discuss any block of code, at any time Whether you're trying to understand someone else's code or getting help with some code you just wrote, just select the code and ask your question. Learn more about discussing code. 4. Get feedback on your work in progress Select \"Request Feedback\" from the \"+\" menu at any time in the development cycle, whether it’s a quick look over some work in progress (even uncommitted code!) or a formal review of a completed effort. Teammates can review your changes right in their IDE, with no need to switch branches or set aside their own work. Learn more about feedback requests. 5. Create or review a pull request Look for the Pull Requests section of the CodeStream sidebar to review an open pull request. Just click on a pull request (or load one from URL) to get a complete GitHub experience right in your IDE! Note that you can create a pull request in GitHub, GitLab or Bitbucket, but support for reviewing pull requests is currently only available for GitHub (cloud or Enterprise). Learn more about pull requests. Help & Feedback Report a bug or send a suggestion in GitHub issues. Contact us directly at support@codestream.com. Follow @teamcodestream for product updates and to share feedback and questions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 288.68262,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> user guide",
        "sections": "1. Install the <em>CodeStream</em> extension in your IDE <em>and</em> sign up.",
        "body": "<em>Quick</em> <em>Start</em> Use the navigation to the left to jump straight to any topic. Otherwise, read on to get started with <em>CodeStream</em>. 1. Install the <em>CodeStream</em> extension in your IDE and sign up. Install <em>CodeStream</em> for VS <em>Code</em>, Visual Studio or JetBrains. The <em>CodeStream</em> pane should automatically appear"
      },
      "id": "61744137e7b9d2428b13c6a0"
    },
    {
      "image": "https://docs.newrelic.com/static/5c1d085b14abf961ca66b96285f0c0fa/69902/QS-Integrations.png",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/install-codestream/",
      "sections": [
        "Install CodeStream",
        "Tip",
        "Install with Instant Observability (I/O)",
        "Connect your tools",
        "Discuss any block of code, at any time",
        "Get feedback on your work in progress",
        "Create or review a pull request",
        "Help & Feedback"
      ],
      "published_at": "2021-10-24T21:19:37Z",
      "title": "Install CodeStream",
      "updated_at": "2021-10-23T17:01:57Z",
      "type": "docs",
      "external_id": "5d431c8f9a2690b64d26ac9fc173b18085153aac",
      "document_type": "page",
      "popularity": 1,
      "body": "CodeStream is a developer collaboration platform that makes it easy to discuss and review code in a more natural and contextual way. Install CodeStream Install CodeStream for Visual Studio Code, Visual Studio or JetBrains. You can also install the CodeStream extension directly via your Visual Studio Code/Visual Studio's extensions or JetBrains plugins menus. Tip Once you've installed CodeStream, if you want to connect it to New Relic, you'll need your New Relic user key. Go here to learn more about finding or creating your user key. Install with Instant Observability (I/O) You can also install CodeStream via an Instant Observability (I/O) quickstart. Connect your tools Create and review pull requests on GitHub, GitLab or Bitbucket. Create issues on Jira, Trello, and other issue trackers. Share code discussions on Slack or Microsoft Teams. CodeStream brings the tools you use every day together in your IDE. Click on your headshot at the top of the CodeStream pane and go to the Integrations page to get all of your tools connected. Discuss any block of code, at any time Whether you're trying to understand someone else's code or getting help with some code you just wrote, just select the code and ask your question. Learn more about discussing code. Get feedback on your work in progress Select \"Request Feedback\" from the \"+\" menu at any time in the development cycle, whether it’s a quick look over some work in progress (even uncommitted code!) or a formal review of a completed effort. Teammates can review your changes right in their IDE, with no need to switch branches or set aside their own work. Learn more about feedback requests. Create or review a pull request Look for the Pull Requests section of the CodeStream sidebar to review an open pull request. Just click on a pull request (or load one from URL) to get a complete GitHub experience right in your IDE! Note that you can create a pull request in GitHub, GitLab or Bitbucket, but support for reviewing pull requests is currently only available for GitHub (cloud or Enterprise). Learn more about pull requests. Help & Feedback Report a bug or send a suggestion in GitHub issues. Contact us directly at support@codestream.com. Follow @teamcodestream for product updates and to share feedback and questions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 255.56674,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>CodeStream</em>",
        "sections": "Install <em>CodeStream</em>",
        "body": " Studio <em>Code</em>&#x2F;Visual Studio&#x27;s extensions or JetBrains plugins menus. Tip Once you&#x27;ve installed <em>CodeStream</em>, if you want to connect it to <em>New</em> <em>Relic</em>, you&#x27;ll need your <em>New</em> <em>Relic</em> user key. Go here to learn more about finding or creating your user key. Install with Instant Observability (I&#x2F;O) You can also"
      },
      "id": "6174400564441ff1025fd832"
    },
    {
      "image": "https://docs.newrelic.com/static/30e00c292c5aa1c5d702d67be5021a45/f96db/CreateAnAccount6.png",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/sign-up-codestream/",
      "sections": [
        "Sign up for CodeStream",
        "Create an account",
        "CodeStream organizations [$organizations]",
        "Create or join an organization",
        "Invite your team"
      ],
      "published_at": "2021-10-24T21:21:10Z",
      "title": "Sign up for CodeStream",
      "updated_at": "2021-10-23T17:05:39Z",
      "type": "docs",
      "external_id": "2f8eda03703523f62844512a3b8ef005b624ebc2",
      "document_type": "page",
      "popularity": 1,
      "body": "To get the most out of CodeStream's collaboration tools, create an organization, and then invite your team members to it. Create an account If you already have the CodeStream extension installed in your IDE, you can start the signup process from the CodeStream pane. You can sign up by either creating a set of CodeStream credentials (such as, email address and password), or you can sign up using GitHub, GitLab or Bitbucket (cloud versions only). Signing up via your code host saves you from having to connect later, but if the email address you're using there isn't your work email you should create CodeStream credentials instead. If you sign up via CodeStream, your next step will be to confirm your email address by entering a code sent to you via email. Note that you can paste the code into any of the boxes rather than typing each number individually. CodeStream organizations [$organizations] An “organization” on CodeStream is where you and your teammates will discuss code. Similar to a Slack workspace, all of the developers in your company should be in the same CodeStream organization. This is true even for very large organizations as CodeStream's activity feed keeps things relevant for each member by showing just activity related to the code you have open in your IDE. The discussions about code build up a knowledge base that is a company-wide resource, so the only reason to have multiple organizations on CodeStream is if you truly need separation. For example, you might have an organization for your day job and another for an open-source project you work on. Or maybe you're a consultant that is a member of different CodeStream organizations for each of your clients. Create or join an organization If you were invited to join an organization on CodeStream, all you need to do is sign up using the same email address the invitation was sent to. You'll automatically be added to that organization. If you're the first person from your company to sign up for CodeStream you can go ahead and create a new organization. Otherwise, there may be existing CodeStream organizations available for you to join based on your email domain. If you think your company is already on CodeStream, but don't see an organization to join, make sure that you've signed up with your work email address. Click the link to change your email address if necessary. If you decide to create an organization you'll be asked to give it a name, and if you signed up with your work email address, you'll also be able to indicate that anyone else on that email domain can join the organization. Invite your team Collaboration is a team sport so invite your teammates to join you on CodeStream! CodeStream will offer up some suggestions based on the commit history of the repositories you have open in your IDE. Now you're ready to start using CodeStream.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 254.426,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Sign up for <em>CodeStream</em>",
        "sections": "Sign up for <em>CodeStream</em>",
        "body": "To get the most out of <em>CodeStream</em>&#x27;s collaboration tools, create an organization, and then invite your team members to it. Create an account If you already have the <em>CodeStream</em> extension installed in your IDE, you can <em>start</em> the signup process from the <em>CodeStream</em> pane. You can sign up by either"
      },
      "id": "617440e3196a6782592f011c"
    }
  ],
  "/docs/codestream/start-here/sign-up-codestream": [
    {
      "image": "https://docs.newrelic.com/static/490255cdad35ea9f73a5ec0877f086e6/f0991/MyOrgMenu.png",
      "url": "https://docs.newrelic.com/docs/codestream/how-use-codestream/my-organization/",
      "sections": [
        "Manage My Organization on CodeStream",
        "My Organization",
        "Invite Teammates",
        "Blame Map"
      ],
      "published_at": "2021-10-24T21:18:06Z",
      "title": "Manage My Organization on CodeStream",
      "updated_at": "2021-10-23T16:57:06Z",
      "type": "docs",
      "external_id": "a632afe14f3e14e73f7dca6f4e4fe64d4bfe14c5",
      "document_type": "page",
      "popularity": 1,
      "body": "The My Organization menu allows you to see who is in your CodeStream organization, invite new members, and create blame maps. My Organization Select \"My Organization\" to see a list of all members of your CodeStream organization. Admins will be identified in the list, and if you are an admin, you'll have a dropdown to assign or remove admin priviledges to any member. Invite Teammates Select \"Invite Teammates\" to invite new members to your organization. The \"Outstanding Invitations\" section lists all open invitations, and at the right side of each row are links to remove the invitation or to reinvite. Clicking \"reinvite\" will have CodeStream send another invitation via email, but you can also hover over the reinvite link for the option to generate an email yourself. The \"Suggested Teammates\" section, which is only available for admins, is a list of possible teammates derived from the commit history of your open repositories. At the right side of each row are links to remove the suggestion from the list or to invite the person. Blame Map Select \"Blame Map\" to add email addresses that you use for committing code that may be different from the email address you used to sign up for CodeStream. For example, your CodeStream email address might be dave@acme.com, but you might also commit code as dave@webmail.com. Click \"Add mapping\", enter your git email address, and then select your entry from the list of organization members. That way, when someone comments on code committed by dave@webmail.com, CodeStream will know to at-mention you (i.e., dave@acme.com). While non-admins can only create blame maps for themselves, admins can create blame maps for any member of the organization. This is useful for reassigning code ownership when people leave the organization.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1524.7305,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage My Organization on <em>CodeStream</em>",
        "sections": "Manage My Organization on <em>CodeStream</em>",
        "body": "The My Organization menu allows you to see who is in your <em>CodeStream</em> organization, invite new members, and create blame maps. My Organization Select &quot;My Organization&quot; to see a list of all members of your <em>CodeStream</em> organization. Admins will be identified in the list, and if you are an admin, you&#x27;ll"
      },
      "id": "61743ee2e7b9d25bc613c0e8"
    },
    {
      "image": "https://docs.newrelic.com/static/8945e0a9c512b8638ebf8165d47aee04/69902/QS-SignUp3.png",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/codestream-user-guide/",
      "sections": [
        "CodeStream user guide",
        "Quick Start",
        "1. Install the CodeStream extension in your IDE and sign up.",
        "2. Connect your tools",
        "3. Discuss any block of code, at any time",
        "4. Get feedback on your work in progress",
        "5. Create or review a pull request",
        "Help & Feedback"
      ],
      "published_at": "2021-10-24T21:19:37Z",
      "title": "CodeStream user guide",
      "updated_at": "2021-10-23T17:07:02Z",
      "type": "docs",
      "external_id": "fa9af0118a8872fea89fda91482c44fb69913ea2",
      "document_type": "page",
      "popularity": 1,
      "body": "Quick Start Use the navigation to the left to jump straight to any topic. Otherwise, read on to get started with CodeStream. 1. Install the CodeStream extension in your IDE and sign up. Install CodeStream for VS Code, Visual Studio or JetBrains. The CodeStream pane should automatically appear in the sidebar for VS Code, or in a tool window at the right side for a JetBrains IDE or Visual Studio. Click on \"Sign Up and Create a team\" if you are the first person from your team to join CodeStream, or paste in your invitation code if you were invited to a team already on CodeStream. Learn more about how to use CodeStream. 2. Connect your tools Create and review pull requests on GitHub, GitLab or Bitbucket. Create issues on Jira, Trello, and other issue trackers. Share code discussions on Slack or Microsoft Teams. CodeStream brings the tools you use every day together in your IDE. Click on your headshot at the top of the CodeStream pane and go to the Integrations page to get all of your tools connected. 3. Discuss any block of code, at any time Whether you're trying to understand someone else's code or getting help with some code you just wrote, just select the code and ask your question. Learn more about discussing code. 4. Get feedback on your work in progress Select \"Request Feedback\" from the \"+\" menu at any time in the development cycle, whether it’s a quick look over some work in progress (even uncommitted code!) or a formal review of a completed effort. Teammates can review your changes right in their IDE, with no need to switch branches or set aside their own work. Learn more about feedback requests. 5. Create or review a pull request Look for the Pull Requests section of the CodeStream sidebar to review an open pull request. Just click on a pull request (or load one from URL) to get a complete GitHub experience right in your IDE! Note that you can create a pull request in GitHub, GitLab or Bitbucket, but support for reviewing pull requests is currently only available for GitHub (cloud or Enterprise). Learn more about pull requests. Help & Feedback Report a bug or send a suggestion in GitHub issues. Contact us directly at support@codestream.com. Follow @teamcodestream for product updates and to share feedback and questions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1415.7942,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> user guide",
        "sections": "1. Install the <em>CodeStream</em> extension in your IDE and <em>sign</em> <em>up</em>.",
        "body": "Quick Start Use the navigation to the left to jump straight to any topic. Otherwise, read on to get started with <em>CodeStream</em>. 1. Install the <em>CodeStream</em> extension in your IDE and <em>sign</em> <em>up</em>. Install <em>CodeStream</em> for VS <em>Code</em>, Visual Studio or JetBrains. The <em>CodeStream</em> pane should automatically appear"
      },
      "id": "61744137e7b9d2428b13c6a0"
    },
    {
      "image": "https://docs.newrelic.com/static/0d940de4d107acece21b6e518f1a2c53/d10fb/OrganizationSettings.png",
      "url": "https://docs.newrelic.com/docs/codestream/codestream-settings/team-administration/",
      "sections": [
        "CodeStream organization settings and administration",
        "Managing People & Roles",
        "Organization Settings",
        "Onboarding Settings",
        "Feedback Request Assignment & Approval",
        "Change Organization Name",
        "Data Export"
      ],
      "published_at": "2021-10-24T21:15:45Z",
      "title": "CodeStream organization settings and administration",
      "updated_at": "2021-10-23T16:57:06Z",
      "type": "docs",
      "external_id": "643e62ff1fc920ca94e3bcd2e27e3a9be4317515",
      "document_type": "page",
      "popularity": 1,
      "body": "Managing People & Roles Select \"My Organization\" from the My Organization menu at the top of the CodeStream pane to invite people to the organization and assign or remove admin privileges. Select \"Blame Map\" to define code ownership with your organization. By default, when you comment on code, CodeStream mentions (or offers to email) the author(s) of the code you are commenting on. But if that person has left the company it might not be the right thing to do. Note that non-admins are able to set up blame maps for themselves to handle situations where the email address they use to commit code is different than the one they used to sign up for CodeStream. Organization Settings If you are an organization admin, look for the Organization Admin menu under the headshot menu at the top of the CodeStream pane. Onboarding Settings Domain-based joining allows anyone with email addresses on the specified domains to join your CodeStream organization without being first invited. Not only does this make it very easy to get your teammates on board, but it ensures that they'll be part of your organization (as opposed to accidentally creating their own). Feedback Request Assignment & Approval Admins can control how both feedback request assignments and approvals work for the organization. By default, the person requesting feedback can decide how approvals work, but you can, instead, set a default behavior for all feedback requests for the organization. Any reviewer can approve - Any one can approve the feedback request, regardless of how many reviewers are assigned. All reviewers must approve individually - Each assigned reviewer must individually approve the feedback request before it’s considered approved. You can also decide if and how CodeStream suggests reviewers. Round-robin will cycle through all developers in the organization. Random will randomly assign the feedback request to any developer in the organization. The Authorship options will suggest up to three reviewers based on the developers who wrote the lines of code impacted by the changes, as well as other developers who may have committed to the branch. Change Organization Name Update the name of your CodeStream organization at any time. Data Export A lightweight export facility for getting your organization's discussions out of CodeStream. Click the icon to copy all of the data to the clipboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1403.1697,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> organization settings and administration",
        "sections": "<em>CodeStream</em> organization settings and administration",
        "body": " is different than the one they used to <em>sign</em> <em>up</em> for <em>CodeStream</em>. Organization Settings If you are an organization admin, look for the Organization Admin menu under the headshot menu at the top of the <em>CodeStream</em> pane. Onboarding Settings Domain-based joining allows anyone with email addresses"
      },
      "id": "61743ee264441ff1025fd5b5"
    }
  ],
  "/docs/codestream/start-here/what-is-codestream": [
    {
      "sections": [
        "CodeStream licenses"
      ],
      "title": "CodeStream licenses",
      "type": "docs",
      "tags": [
        "Licenses",
        "Product or service licenses",
        "CodeStream"
      ],
      "external_id": "331f3d1cd0897f453f98bc054fda09a9ad2725c1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/codestream/codestream-licenses/",
      "published_at": "2021-10-24T17:53:35Z",
      "updated_at": "2021-10-23T17:05:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We love open-source software, and we use the following with CodeStream. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we've chosen to use. CodeStream license on GitHub CodeStream's third-party software notices on GitHub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 650.5486,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> licenses",
        "sections": "<em>CodeStream</em> licenses",
        "tags": "<em>CodeStream</em>",
        "body": "We love open-source software, and we use the following with <em>CodeStream</em>. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we&#x27;ve chosen to use. <em>CodeStream</em> license on GitHub <em>CodeStream</em>&#x27;s third-party software notices on GitHub"
      },
      "id": "617440e2196a677ea62f0193"
    },
    {
      "image": "https://docs.newrelic.com/static/80938a17dd570bd0f6c463ea41abafab/f96db/ProxySettings1.png",
      "url": "https://docs.newrelic.com/docs/codestream/troubleshooting/proxy-support/",
      "sections": [
        "CodeStream proxy support"
      ],
      "published_at": "2021-10-24T21:23:30Z",
      "title": "CodeStream proxy support",
      "updated_at": "2021-10-23T17:09:22Z",
      "type": "docs",
      "external_id": "0c1272602b2a6c485599bf738eba1eb42c6ebff6",
      "document_type": "page",
      "popularity": 1,
      "body": "If you are experiencing connectivity issues with the CodeStream extension it could be because you’re behind a network proxy and CodeStream is not configured to work with it. To find CodeStream’s settings in your IDE: VS Code - Go to Settings/Preferences and search for “CodeStream”. Visual Studio - Go to Tools > Options > CodeStream. JetBrains - Go to Settings/Preferences > Tools > CodeStream. Look for the “Proxy Support” setting and make sure it is set to “on”. You will also need to disable Strict SSL checking since your CodeStream extension won’t see the SSL/TLS certificates as coming from a legitimate Certificate Authority. Here's what these settings look like in VS Code. If you have proxy support configured in your IDE, CodeStream will first try to inherit those settings. Otherwise, CodeStream will inherit proxy settings from your operating system/environment. After changing your settings, restart your IDE.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 247.88974,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> proxy support",
        "sections": "<em>CodeStream</em> proxy support",
        "body": " a legitimate Certificate Authority. Here&#x27;s <em>what</em> these settings look like in VS <em>Code</em>. If you have proxy support configured in your IDE, <em>CodeStream</em> will first try to inherit those settings. Otherwise, <em>CodeStream</em> will inherit proxy settings from your operating system&#x2F;environment. After changing your settings, restart your IDE."
      },
      "id": "617441c328ccbc299dc6c449"
    },
    {
      "image": "https://docs.newrelic.com/static/74c274508fc745275751f72d3e01ea33/f96db/CodemarkAddRange1.png",
      "url": "https://docs.newrelic.com/docs/codestream/how-use-codestream/discuss-code/",
      "sections": [
        "Discuss code on CodeStream",
        "What is a codemark?",
        "Creating a codemark",
        "Comment Codemarks",
        "Issue Codemarks",
        "Bringing the right people into the discussion",
        "Different versions of the code?",
        "Resolving codemarks",
        "Advanced Features",
        "Multiple Ranges",
        "File Attachments",
        "Tagging",
        "Related codemarks",
        "Managing codemarks"
      ],
      "published_at": "2021-10-24T21:18:06Z",
      "title": "Discuss code on CodeStream",
      "updated_at": "2021-10-23T17:01:57Z",
      "type": "docs",
      "external_id": "9169c03142311fe838566856d0ff154df0e6d555",
      "document_type": "page",
      "popularity": 1,
      "body": "What is a codemark? Quite simply, a codemark is a discussion connected to the code. It could be a question, a suggestion, a bug report, or documentation. All of these discussions are saved, anchored to the blocks of code they refer to, so that they can be leveraged in the future. It could be a new developer joining the team, a developer trying to fix a bug in someone else’s code, or even just you trying to remember why you made that change six months ago… whatever the case, CodeStream helps you understand the code by surfacing the discussions in a contextual way. Even as a file changes over time, the codemarks will remain connected to the code. Add some new lines of code above the code block, make edits to the code, or even cut-and-paste the entire block to a different section of the file, and you’ll see the codemark move right along with the changes. Creating a codemark Create a codemark by selecting a block of code in your editor and then clicking on one of the icons that appears in the CodeStream pane next to your selection. If you're using a JetBrains IDE, such as IntelliJ, you can also create a codemark by using the \"+\" button that appears in the editor's gutter when you select a block of code. When you're viewing a diff, for either a feedback request or a pull request, the button will also appear when you hover in the gutter to make it easy to comment on a single line. Even when the CodeStream pane is closed or not in view, you can create a codemark via the CodeStream options in either the lightbulb or context menus. Lastly, you can also look for the \"+\" menu at the top of the CodeStream pane. Need to reach teammates that don’t spend a lot of time in the IDE? Or maybe some teammates that aren’t yet on CodeStream? You can optionally share a codemark out to Slack or Microsoft Teams. The Slack integration even allows your teammates to reply directly from Slack. Comment Codemarks The all-purpose codemark for linking any type of discussion to a block of code. Ask a question. Make a suggestion. Document some code. Make note of key sections of the codebase. The possibilities are endless! Issue Codemarks When something needs to get done there’s always a better chance of it happening if it’s captured as an issue, with someone’s name attached. Assign issues as a way of reporting bugs. Or manage your tech debt by capturing items as tracked issues instead of inline FIXMEs. If your team uses Asana, Azure DevOps, Bitbucket (cloud), Clubhouse, GitHub (cloud or Enterprise), GitLab (cloud or Self-Managed), Jira (cloud or Server), Linear, Trello, or YouTrack (cloud) for tracking issues, you can create an issue on one of those services directly from CodeStream. Just select the service you use from the dropdown at the top of the codemark form. After going through the authentication process with the selected service you'll now be able to select a destination for your issue. For example, with Jira you'll be able to select the appropriate issue type and project. Once the issue has been created on CodeStream, it will include a link to the issue that was created on the external service. In the example below you'll see the URL for the issue on Jira. And the issue on Jira includes a link to open the relevant code in your IDE. Bringing the right people into the discussion When you create a codemark, CodeStream automatically mentions the people that most recently touched of the code you are commenting on. They may be the best people to answer your question, but you can, of course, remove those mentions and manually mention someone else if appropriate. It may be the case that the people that have touched the code aren't yet on CodeStream, in which case CodeStream will provide checkboxes to have them notified via email. They can simply reply to the email to have their comment posted to CodeStream, and of course they can install CodeStream to participate from their IDE. Different versions of the code? Maybe you’re on a feature branch, have local changes, or simply haven’t pulled in a while. There are countless reasons why the code you’re looking at might be different than what a teammate is looking at, and as a result, there will be plenty of times when the code referenced in a codemark doesn’t match what you have locally. CodeStream recognizes these situations and includes the original version of the code block (i.e. at the time the codemark was created), the current version, and a diff. Keep in mind that with CodeStream you can discuss any line of code, in any source file, at any time, even if it’s code that you just typed into your editor and haven’t yet committed. CodeStream allows you to discuss code at the very earliest stages of the development process. Resolving codemarks Although not required, both comment and issue codemarks can be resolved. The Codemarks section of the CodeStream pane breaks out codemarks into Open, Resolved and Archived sections, and green, purple and gray icons are used to represent those different states. If you see a lot of Open/green codemarks in the codestream pane, that means that your teammates are being blocked by discussions and issues that haven't be resolved. You can add a comment at the same time your resolve the codemark, and you can also elect to archive the codemark at the same time. Advanced Features Multiple Ranges Many discussions about code involve more than just one block of code, and concepts are often best presented when you can refer to multiple code locations at once. Here are a few examples of multi-range codemark at work: A change to a function is being contemplated that will impact its name. Each instance of the function call can now be referenced in one discussion. A react component and its CSS styling aren’t interacting well, and you want to ask the team for input. You might select the div and the CSS rules you think should apply, so your teammates know exactly what you’re talking about. Clients which make API calls to the server might get an unexpected result. Select the code where you’re making the API call, and the handler in the API server, to connect the two actions together. To create a multi-range codemark, click on \"+ Add Code Block\". And then select another block of code from the same file, a different file, or even a different repo. You can intersperse the difference code blocks in your post by referring to each one as [#N] (or click the pin icon from one of the code blocks to insert the markdown for you), as in the following example. And here's how that example is rendered. Once you've created the codemark, you can easily jump between the different locations by clicking the Jump icon at the bottom-right of each code block. Note that when you edit a codemark you can add and remove code blocks, and you can change the location of any of the code blocks by clicking the dashed square icon. File Attachments Enrich your discussions about code by attaching files directly to code blocks. Think about how much more compelling your comments and documentation become when you... Attach a spec to guide the development of a new feature Attach a log file to help debug an issue in the code Attach a mockup to help clarify some UI work Attach a screenshot to highlight a problem When creating a code comment or issue, you can attach a file by dragging-and-dropping on the the description field, pasting from you clipboard, or by clicking the new paperclip icon. Images can even be displayed inline using markdown. Just click the pin icon to the right of the attachment, and CodeStream will insert the markdown for you. And now your teammate knows exactly what you’re looking for! You can click on files in the Attachments section to either download or open in the appropriate application. Tagging Look for the tag icon inside the codemark compose box to either select a tag or create a tag using any combination of color and text label. Tags are a great way to broadly organize and group your organization's codemarks, and the possibilities here are endless. Note that you can also filter by tag on the Filter & Search page. Related codemarks Click on the CodeStream icon in the codemark compose form to select other, related codemarks to “attach” to the current codemark. This allows you to easily establish a connection between different parts of a codebase. For example, when a change to one part of the codebase would require a change to another part, identify the dependency by creating two related codemarks. Once you’ve added the related codemarks they’ll be displayed in a “Related” section and you can click on any one to jump to that codemark and the corresponding section of the code. Managing codemarks Click on the ellipses menu for any codemark and you'll see options for managing the codemark. Share - In addition to sharing to Slack or Teams at the time you create a codemark, you can also share it anytime thereafter. Follow/Unfollow - Unfollow to stop receiving notifications for the codemark. Copy link - Get a permalink for the codemark to share it anywhere. Archive - If there’s a codemark that you don’t think is important enough to be on permanent display in a given file, but you don’t want to completely delete it, you can archive it instead. Settings in the codemarks section allow you to easily see all archived codemarks. Edit - Only the codemark's author can edit it. Delete - Only the codemark's author can delete it, but we encourage you to archive instead of delete unless you're positive the codemark won't have any future value. Inject as Inline Comment - If you'd like a specific codemark to become part of the repo use this option to have it added as an inline comment. You can select the appropriate format, and then indicate if you want to include timestamps, replies, or to have the comment wrapped at 80 characters. You can also elect to have the codemark archived once it's been added as an inline comment. Reposition codemark - In most cases, a codemark will automatically remain linked to the block of code it refers to as the file changes over time. For example, if you cut the block of code and paste it at a different location in the file, the codemark will move right along with it. There are some scenarios, however, that CodeStream isn't able to handle automatically. For example, if you pasted the block of code into a different file. In these cases, Reposition codemark allows you to select the new location of the block of code so that the codemark is displayed properly.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 242.0309,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Discuss <em>code</em> on <em>CodeStream</em>",
        "sections": "<em>What</em> <em>is</em> a <em>codemark</em>?",
        "body": " of times when the <em>code</em> referenced in a codemark doesn’t match <em>what</em> you have locally. <em>CodeStream</em> recognizes these situations and includes the original version of the <em>code</em> block (i.e. at the time the codemark was created), the current version, and a diff. Keep in mind that with <em>CodeStream</em> you can discuss any"
      },
      "id": "6174400564441fe8685fd746"
    }
  ],
  "/docs/codestream/troubleshooting/client-logs": [
    {
      "image": "https://docs.newrelic.com/static/490255cdad35ea9f73a5ec0877f086e6/f0991/MyOrgMenu.png",
      "url": "https://docs.newrelic.com/docs/codestream/how-use-codestream/my-organization/",
      "sections": [
        "Manage My Organization on CodeStream",
        "My Organization",
        "Invite Teammates",
        "Blame Map"
      ],
      "published_at": "2021-10-24T21:18:06Z",
      "title": "Manage My Organization on CodeStream",
      "updated_at": "2021-10-23T16:57:06Z",
      "type": "docs",
      "external_id": "a632afe14f3e14e73f7dca6f4e4fe64d4bfe14c5",
      "document_type": "page",
      "popularity": 1,
      "body": "The My Organization menu allows you to see who is in your CodeStream organization, invite new members, and create blame maps. My Organization Select \"My Organization\" to see a list of all members of your CodeStream organization. Admins will be identified in the list, and if you are an admin, you'll have a dropdown to assign or remove admin priviledges to any member. Invite Teammates Select \"Invite Teammates\" to invite new members to your organization. The \"Outstanding Invitations\" section lists all open invitations, and at the right side of each row are links to remove the invitation or to reinvite. Clicking \"reinvite\" will have CodeStream send another invitation via email, but you can also hover over the reinvite link for the option to generate an email yourself. The \"Suggested Teammates\" section, which is only available for admins, is a list of possible teammates derived from the commit history of your open repositories. At the right side of each row are links to remove the suggestion from the list or to invite the person. Blame Map Select \"Blame Map\" to add email addresses that you use for committing code that may be different from the email address you used to sign up for CodeStream. For example, your CodeStream email address might be dave@acme.com, but you might also commit code as dave@webmail.com. Click \"Add mapping\", enter your git email address, and then select your entry from the list of organization members. That way, when someone comments on code committed by dave@webmail.com, CodeStream will know to at-mention you (i.e., dave@acme.com). While non-admins can only create blame maps for themselves, admins can create blame maps for any member of the organization. This is useful for reassigning code ownership when people leave the organization.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 315.3247,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>My</em> Organization on <em>CodeStream</em>",
        "sections": "Manage <em>My</em> Organization on <em>CodeStream</em>",
        "body": " by dave@webmail.com, <em>CodeStream</em> will know to at-mention you (<em>i</em>.e., dave@acme.com). While non-admins <em>can</em> only create blame maps for themselves, admins <em>can</em> create blame maps for any member of the organization. This is useful for reassigning <em>code</em> ownership when people leave the organization."
      },
      "id": "61743ee2e7b9d25bc613c0e8"
    },
    {
      "image": "https://docs.newrelic.com/static/312277fba75be5f3ae8f05a44f15dd18/ca501/ActivityFeedWithBadge3.png",
      "url": "https://docs.newrelic.com/docs/codestream/codestream-ui-overview/activity-feed/",
      "sections": [
        "CodeStream activity feed"
      ],
      "published_at": "2021-10-24T21:15:03Z",
      "title": "CodeStream activity feed",
      "updated_at": "2021-10-23T16:59:55Z",
      "type": "docs",
      "external_id": "16df90f477047275dd5f52ce5ec427cff28a9cd9",
      "document_type": "page",
      "popularity": 1,
      "body": "The activity feed is the definitive place to find out about new comments, issues and feedback requests posted by your teammates, or new replies to existing discussions. When you’re not on the activity feed, you can always tell whether or not there’s anything new by looking for a badge on the Activity Feed icon. A blue badge with a white dot means that there are new discussions or replies, and a blue badge with a number inside means that there are new discussions or replies where you’ve been mentioned (with the number indicating the number of mentions). Note that CodeStream’s entry in your IDE’s status bar also let’s you know when there are new messages in the feed. A dot to the right of your username means there are new messages, and a number means there are new mentions. A filter at the top of the activity feed allows you to determine what you'll see in the feed. Activity from everyone in my organization - This option allows you to see all activity from your organization, and should only be used in very small organizations. Activity associated with code open in my IDE (default) - You'll only see discussions related to code in the repositories you have open in your IDE, although you'll always see posts where you're @mentioned even if it's associated with code from other repositories. Activity associated with code in selected folder - This option is geared towards those of you working with monorepos. You'll only see discussions related to code in the selected folder, although you'll always see posts where you're @mentioned even if it's associated with code from other folders. As you might expect, new stuff gets added to the top of the feed, even if it’s a new reply to a very old discussion. CodeStream makes it even easier to identify what’s new by adding a blue border on the left side. For example, here’s a new comment at the top of the feed. And here is a new reply to a comment. The fact that only the replies have the blue border means that you’ve previously seen the comment itself. Also note the “See 1 earlier reply”. That means that there's an earlier reply that you’ve already seen. Only new, unread replies are displayed in the main activity feed view, but you can click on that link to see the full discussion thread and add a new reply of your own. The activity feed goes all the way back to the beginning of time for your team, but if you’re looking for specific older codemarks you might be better off going to Filter & Search.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 288.79446,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> activity feed",
        "sections": "<em>CodeStream</em> activity feed",
        "body": " you&#x27;ll always see posts <em>where</em> you&#x27;re @mentioned even if it&#x27;s associated with <em>code</em> from other folders. As you might expect, new stuff gets added to the top of the feed, even if it’s a new reply to a very old discussion. <em>CodeStream</em> makes it even easier to identify what’s new by adding a blue border"
      },
      "id": "61743f8c28ccbc3b6cc6bea5"
    },
    {
      "image": "https://docs.newrelic.com/static/955e077a4753336027d003cec2388566/c5bb3/connect-repo.png",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/codestream-new-relic/",
      "sections": [
        "CodeStream and New Relic",
        "Preview release",
        "Connect CodeStream and New Relic",
        "Caution",
        "See your errors and what's causing them",
        "Tip",
        "How to go from errors inbox to your IDE",
        "APM errors and CodeStream",
        "Give us your repository's URL",
        "Use environment variable with APM (recommended)",
        "Use the UI",
        "Use the NerdGraph API",
        "Install APM agents with CodeStream",
        "Dynamic logging with Go and Pixie"
      ],
      "published_at": "2021-10-24T21:20:27Z",
      "title": "CodeStream and New Relic",
      "updated_at": "2021-10-23T16:54:24Z",
      "type": "docs",
      "external_id": "a6c04d95011d9150cb0798580c15695bb9f3bbda",
      "document_type": "page",
      "popularity": 1,
      "body": "CodeStream and New Relic work together in several ways to give you insight into your code's errors, as well as making it easier to get started instrumenting your code with our APM agents. Specifically, when CodeStream is connected to New Relic, you can to jump from a stack trace error in the New Relic UI directly to the offending line of code in your IDE. Once in your IDE, you can use all of CodeStream's collaboration tools to discuss the code, request feedback, and submit a pull request to resolve the issue and push up the fix to your repository. Preview release CodeStream's integration with New Relic One is a preview release limited to New Relic One accounts on our US data center, and your use is subject to the pre-release policy. (This does not apply to all other CodeStream functionality.) Connect CodeStream and New Relic Before you can take advantage of New Relic's observability features in CodeStream, you'll need to connect them. Requirements for connecting CodeStream and New Relic: New Relic account (If you don't have a New Relic account, sign up at newrelic.com/signup. It's free, forever!) New Relic user key If you don't have a user key or want to learn more about how you can use and manage them, see our doc on the New Relic user key. Once you have your New Relic user key, in CodeStream's Observability section click Connect to New Relic One, then paste your API key and click Connect. Caution New Relic users can share stacktrace errors on CodeStream. Once you've connected CodeStream to New Relic, any new users you add to your CodeStream organization can see those errors. See your errors and what's causing them After you connect CodeStream and New Relic, use workloads and errors inbox to jump to the offending code in your IDE. Requirements for opening stack trace errors in your IDE: New Relic account (If you don't have a New Relic account, sign up at newrelic.com/signup. It's free, forever!) New Relic user key CodeStream and New Relic connection Data being reported to New Relic via APM monitoring A workload for errors inbox An error For APM errors, your repository's commit hash and release tag New Relic errors inbox is a single place to proactively detect, prioritize, and take action on your errors before they impact customers. With CodeStream, you can jump from an error directly to the offending code in your IDE. Tip Limited to APM errors. How to go from errors inbox to your IDE From one.newrelic.com/, go to Errors Inbox, click a stack trace error, then click Open in IDE. APM errors and CodeStream To use CodeStream's Open in IDE with your APM stack trace errors, use environment variables to configure your APM agent with your application's commit sha and/or your release tag associated with the running version of your software. CodeStream only needs the first seven characters of your commit sha (for example, 734713b) to make this connection, but you can include the entire sha. Alternately, you can use a release tag (such as v0.1.209 or release-209) for CodeStream to find the correct version of your code. For New Relic APM, the commit and/or release tag (tags.commit and tags.releaseTag) are added as attributes on Transaction and TransactionError events. You can use APM environment variables to set these attributes. We recommend setting one or both of these variables as part of your build pipeline. NEW_RELIC_METADATA_COMMIT - The commit sha. You can include the whole thing or only the first seven characters. NEW_RELIC_METADATA_RELEASE_TAG - A release tag (such as v0.1.209 or release-209). This has the advantage of being human readable. For more on how to set these variables, here are specific configuration details for each language: Go Java .NET Node.js PHP Python Ruby Give us your repository's URL Once you've started monitoring for APM, mobile, browser, or Lambda, you can connect those things with your repository. In order to link your data in New Relic to your code, we need to know the URL for your repository. For example, the URL can be in either the SSH or HTTPS format: git@github.com:newrelic/beta-docs-site.git https://github.com/newrelic/beta-docs-site.git Caution It's possible to add the same GitHub repository more than once, if you're using different protocols to do so. The UI warns you about this, but won't prevent you from doing so. For example, https://github.com/tuna/repo and git@github.com:tuna/repo are the same repo, with different protocols. You can use any one of these methods to set up your repository: Use environment variable with APM (recommended) Set the environment variable NEW_RELIC_METADATA_REPOSITORY_URL. New Relic APM agents create the repository entity and associate it to your application entity automatically. This requires the SSH or HTTPS URL format. We recommend that these be set as part of your build pipeline. Use the UI Once you've started sending data to New Relic, use the UI to connect your related repository. For APM, mobile, browser, and Lambda monitoring, find the Connect repository button on the right-hand side. To connect your repository, click Connnect repository, then find an existing repository or add a new one. Use the NerdGraph API Use New Relic's NerdGraph APIsto create a repository and associate it with your application entities. Step 1: Create a repository entity To create a repository entity, use the referenceEntityCreateOrUpdateRepository API and make sure to save the GUID that's produced. The API takes the following parameters: accountId - the integer account ID for the account you want to add the repository to url - example https://github.com/newrelic/beta-docs-site.git name - example: newrelic/beta-docs-site mutation { referenceEntityCreateOrUpdateRepository(repositories: [{accountId: [YOUR_ACCOUNT_ID], name: \"[REPO_NAME]\", url: \"[REPO_URL]\"}]) { created failures { guid message type } } } Copy In order to find the entity you create, you can use a query like the following. Note that the URL you provided to referenceEntityCreateOrUpdateRepository gets saved as an entity tag. { actor { entitySearch(query: \"name = 'a name' OR tags.url = 'a url'\") { count query results { entities { guid name tags { key values } } } } } } Copy Step 2: Associate the repository entity to your application entity First, find the GUID for the application you want to associate your repository to. Parameters: sourceEntityGuid - the entity GUID of the application targetEntityGuid - the entity GUID of your repository type - always BUILT_FROM mutation { entityRelationshipUserDefinedCreateOrReplace(sourceEntityGuid: \"\", targetEntityGuid: \"\", type: BUILT_FROM) { errors { message type } } } Copy To see all entities related to your repository you can do a query like this: { actor { entity(guid: \"[YOUR_REPOSITORY_GUID]]\") { relatedEntities(filter: {direction: BOTH, relationshipTypes: {include: BUILT_FROM}}) { results { target { entity { name guid type } } type } } name type tags { values key } } } } Copy Step 3: Cleanup (if needed) Delete a repository with the following query: mutation DeleteRepository { entityDelete(guids: \"[ENTITY_GUID_HERE]]\") { deletedEntities failures { message guid } } } Copy Install APM agents with CodeStream Requirements for installing New Relic APM agents via CodeStream: New Relic account New Relic user key CodeStream and New Relic connection A supported language application codebase .NET Core Java Node.JS When you first connect CodeStream to New Relic, if you're working on an application's codebase that's not being monitored by New Relic, CodeStream will offer to instrument that application for you. Like New Relic's guided install, CodeStream will walk you through and automate all of the steps to installing the APM agent to start sending data to New Relic. This check only happens automatically when the initial connection is made. To do so later, in the CodeStream extension, click your username, then click New Relic Setup. Dynamic logging with Go and Pixie New Relic account New Relic user API key CodeStream and New Relic connection A Kubernetes cluster monitored by Pixie An application written in Go You can use CodeStream to enable dynamic logging for your Pixie-monitored Go applications. For relevant projects, you can use CodeStream to dynamically log your Go method names in your IDE.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 284.55817,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> and New Relic",
        "sections": "<em>Install</em> APM agents with <em>CodeStream</em>",
        "body": " or release-209) for <em>CodeStream</em> to <em>find</em> the correct version of your <em>code</em>. For New Relic APM, the commit and&#x2F;or release tag (tags.commit and tags.releaseTag) are added as attributes on Transaction and TransactionError events. You <em>can</em> use APM environment variables to set these attributes. We recommend setting"
      },
      "id": "6171e652196a67e9c92f0156"
    }
  ],
  "/docs/codestream/troubleshooting/git-issues": [
    {
      "sections": [
        "CodeStream licenses"
      ],
      "title": "CodeStream licenses",
      "type": "docs",
      "tags": [
        "Licenses",
        "Product or service licenses",
        "CodeStream"
      ],
      "external_id": "331f3d1cd0897f453f98bc054fda09a9ad2725c1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/codestream/codestream-licenses/",
      "published_at": "2021-10-24T17:53:35Z",
      "updated_at": "2021-10-23T17:05:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We love open-source software, and we use the following with CodeStream. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we've chosen to use. CodeStream license on GitHub CodeStream's third-party software notices on GitHub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 643.051,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> licenses",
        "sections": "<em>CodeStream</em> licenses",
        "tags": "<em>CodeStream</em>",
        "body": "We love open-source software, and we use the following with <em>CodeStream</em>. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we&#x27;ve chosen to use. <em>CodeStream</em> license on <em>Git</em>Hub <em>CodeStream</em>&#x27;s third-party software notices on <em>Git</em>Hub"
      },
      "id": "617440e2196a677ea62f0193"
    },
    {
      "image": "https://docs.newrelic.com/static/8945e0a9c512b8638ebf8165d47aee04/69902/QS-SignUp3.png",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/codestream-user-guide/",
      "sections": [
        "CodeStream user guide",
        "Quick Start",
        "1. Install the CodeStream extension in your IDE and sign up.",
        "2. Connect your tools",
        "3. Discuss any block of code, at any time",
        "4. Get feedback on your work in progress",
        "5. Create or review a pull request",
        "Help & Feedback"
      ],
      "published_at": "2021-10-24T21:19:37Z",
      "title": "CodeStream user guide",
      "updated_at": "2021-10-23T17:07:02Z",
      "type": "docs",
      "external_id": "fa9af0118a8872fea89fda91482c44fb69913ea2",
      "document_type": "page",
      "popularity": 1,
      "body": "Quick Start Use the navigation to the left to jump straight to any topic. Otherwise, read on to get started with CodeStream. 1. Install the CodeStream extension in your IDE and sign up. Install CodeStream for VS Code, Visual Studio or JetBrains. The CodeStream pane should automatically appear in the sidebar for VS Code, or in a tool window at the right side for a JetBrains IDE or Visual Studio. Click on \"Sign Up and Create a team\" if you are the first person from your team to join CodeStream, or paste in your invitation code if you were invited to a team already on CodeStream. Learn more about how to use CodeStream. 2. Connect your tools Create and review pull requests on GitHub, GitLab or Bitbucket. Create issues on Jira, Trello, and other issue trackers. Share code discussions on Slack or Microsoft Teams. CodeStream brings the tools you use every day together in your IDE. Click on your headshot at the top of the CodeStream pane and go to the Integrations page to get all of your tools connected. 3. Discuss any block of code, at any time Whether you're trying to understand someone else's code or getting help with some code you just wrote, just select the code and ask your question. Learn more about discussing code. 4. Get feedback on your work in progress Select \"Request Feedback\" from the \"+\" menu at any time in the development cycle, whether it’s a quick look over some work in progress (even uncommitted code!) or a formal review of a completed effort. Teammates can review your changes right in their IDE, with no need to switch branches or set aside their own work. Learn more about feedback requests. 5. Create or review a pull request Look for the Pull Requests section of the CodeStream sidebar to review an open pull request. Just click on a pull request (or load one from URL) to get a complete GitHub experience right in your IDE! Note that you can create a pull request in GitHub, GitLab or Bitbucket, but support for reviewing pull requests is currently only available for GitHub (cloud or Enterprise). Learn more about pull requests. Help & Feedback Report a bug or send a suggestion in GitHub issues. Contact us directly at support@codestream.com. Follow @teamcodestream for product updates and to share feedback and questions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.07468,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> user guide",
        "sections": "1. Install the <em>CodeStream</em> extension in your IDE <em>and</em> sign up.",
        "body": " about how to use <em>CodeStream</em>. 2. Connect your tools Create and review pull requests on <em>Git</em>Hub, <em>Git</em>Lab or Bitbucket. Create <em>issues</em> on Jira, Trello, and other issue trackers. Share <em>code</em> discussions on Slack or Microsoft Teams. <em>CodeStream</em> brings the tools you use every day together in your IDE. Click"
      },
      "id": "61744137e7b9d2428b13c6a0"
    },
    {
      "image": "https://docs.newrelic.com/static/5c1d085b14abf961ca66b96285f0c0fa/69902/QS-Integrations.png",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/install-codestream/",
      "sections": [
        "Install CodeStream",
        "Tip",
        "Install with Instant Observability (I/O)",
        "Connect your tools",
        "Discuss any block of code, at any time",
        "Get feedback on your work in progress",
        "Create or review a pull request",
        "Help & Feedback"
      ],
      "published_at": "2021-10-24T21:19:37Z",
      "title": "Install CodeStream",
      "updated_at": "2021-10-23T17:01:57Z",
      "type": "docs",
      "external_id": "5d431c8f9a2690b64d26ac9fc173b18085153aac",
      "document_type": "page",
      "popularity": 1,
      "body": "CodeStream is a developer collaboration platform that makes it easy to discuss and review code in a more natural and contextual way. Install CodeStream Install CodeStream for Visual Studio Code, Visual Studio or JetBrains. You can also install the CodeStream extension directly via your Visual Studio Code/Visual Studio's extensions or JetBrains plugins menus. Tip Once you've installed CodeStream, if you want to connect it to New Relic, you'll need your New Relic user key. Go here to learn more about finding or creating your user key. Install with Instant Observability (I/O) You can also install CodeStream via an Instant Observability (I/O) quickstart. Connect your tools Create and review pull requests on GitHub, GitLab or Bitbucket. Create issues on Jira, Trello, and other issue trackers. Share code discussions on Slack or Microsoft Teams. CodeStream brings the tools you use every day together in your IDE. Click on your headshot at the top of the CodeStream pane and go to the Integrations page to get all of your tools connected. Discuss any block of code, at any time Whether you're trying to understand someone else's code or getting help with some code you just wrote, just select the code and ask your question. Learn more about discussing code. Get feedback on your work in progress Select \"Request Feedback\" from the \"+\" menu at any time in the development cycle, whether it’s a quick look over some work in progress (even uncommitted code!) or a formal review of a completed effort. Teammates can review your changes right in their IDE, with no need to switch branches or set aside their own work. Learn more about feedback requests. Create or review a pull request Look for the Pull Requests section of the CodeStream sidebar to review an open pull request. Just click on a pull request (or load one from URL) to get a complete GitHub experience right in your IDE! Note that you can create a pull request in GitHub, GitLab or Bitbucket, but support for reviewing pull requests is currently only available for GitHub (cloud or Enterprise). Learn more about pull requests. Help & Feedback Report a bug or send a suggestion in GitHub issues. Contact us directly at support@codestream.com. Follow @teamcodestream for product updates and to share feedback and questions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 308.86356,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>CodeStream</em>",
        "sections": "Install <em>CodeStream</em>",
        "body": " install <em>CodeStream</em> via an Instant Observability (I&#x2F;O) quickstart. Connect your tools Create and review pull requests on <em>Git</em>Hub, <em>Git</em>Lab or Bitbucket. Create <em>issues</em> on Jira, Trello, and other issue trackers. Share <em>code</em> discussions on Slack or Microsoft Teams. <em>CodeStream</em> brings the tools you use every day"
      },
      "id": "6174400564441ff1025fd832"
    }
  ],
  "/docs/codestream/troubleshooting/github-org-repos": [
    {
      "image": "https://docs.newrelic.com/static/dd18b67123e9d4b7d40b56a8653a1f6b/f96db/OpenPullRequest1.png",
      "url": "https://docs.newrelic.com/docs/codestream/how-use-codestream/pull-requests/",
      "sections": [
        "Manage pull requests on CodeStream",
        "Creating a pull request",
        "Reviewing a pull request",
        "Leveraging pull request comments"
      ],
      "published_at": "2021-10-24T21:18:51Z",
      "title": "Manage pull requests on CodeStream",
      "updated_at": "2021-10-23T17:01:57Z",
      "type": "docs",
      "external_id": "7e35f2ff4f06799fe492ffb6b2fedbb52e898b69",
      "document_type": "page",
      "popularity": 1,
      "body": "For most development teams, the final step in the development process is a pull request. Even if your team has decided to use CodeStream's feedback requests as a replacement for, and not just a precursor to, your end-of-cycle PR-based code reviews, CodeStream allows you to keep all of that workflow right in your IDE. There are three elements of CodeStream's pull-request integration, and the following table outlines which code-hosting services are supported for each. Feature Supported Services Create a pull request GitHub, GitHub Enterprise, GitLab, GitLab Self-Managed, Bitbucket, Bitbucket Server Create a pull request across forks GitHub, GitHub Enterprise, GitLab, GitLab Self-Managed Review and edit a pull request GitHub, GitHub Enterprise, GitLab, GitLab Self-Managed Display pull request comments as code annotations GitHub, GitLab, Bitbucket Creating a pull request Open a pull request at any time by clicking on the \"+\" button at the top of the CodeStream pane, or the \"+\" button in the header of the Pull Requests section. You can also use a keyboard shortcut (ctlr+shift+/ p, or ctrl+/ p on a Mac... and you can use m if you're a GitLab user). CodeStream even provides you with different options (tree view, list view, diff hunks) for reviewing your changes before opening the pull request. With a single click you can name the pull request based on the last commit message, the branch name, or, if you started work by selecting a ticket, the ticket title. If you have a ticket selected, you can also explicitly tie the ticket to the pull request, and CodeStream will include a link to the ticket in the pull request's description. Before submitting the pull request you can even review your changes by clicking on any of the files listed below the form. To create a pull request across forks, click on the \"compare across forks\" link at the top of the page and the form will update to allow you to select both the base and head repositories. You can also create a pull request from within a CodeStream feedback request. Once the feedback request has been approved, you’ll see an option to open a pull request at the top. Before you can create a pull request you’ll need to make sure that any changes included in the feedback request have been committed and pushed. Also, if the feature branch you’re working on doesn’t have a remote tracking branch you’ll be given the option to set that as part of creating the pull request. When you create a pull request from a feedback request, CodeStream connect's the dots between the two by adding a link to the pull request to the feedback request. And by adding a link to the feedback request, along with information about who did the review and when, in the description of the pull request. Reviewing a pull request The ability to review pull requests is currently not available for Bitbucket. Regardless of where the pull request was created, you can edit, review, and even merge it, right from CodeStream. We've essentially brought GitHub and GitLab right into your IDE, so there's zero learning curve. If you know how to work with pull requests on GitHub or GitLab, you'll know how to do it in CodeStream as well. Edit a GitHub pull request's details, such as reviewers, assignees and labels. For a GitLab merge request, you can use edit mode (via the dropdown at the top of the page) or use the sidebar. By default, you can only add a single reviewer and a single assignee to a GitLab merge request. If your organization supports multiple reviewers and assignees, click the gear menu in the heading of the Merge Requests section of the CodeStream pane to enable this. Review the conversation and add comments, with the ability to @mention your collaborators. View the changes, add comments, and submit a review. Of course, we did improve upon the GitHub/GitLab experience in a couple of important ways. On GitHub and GitLab you can only view the changes as a series of \"diff hunks\". CodeStream provides that view as well, but if you'd prefer to see the changes in the context of the full file, and not just the lines that changed, you can use either List View or Tree View. Just select the code you want to comment on, and then click on the Comment button (or select Comment from the context menu). When commenting you can either add a single comment, or start a review. Another difference is that CodeStream allows you to comment on lines of code that haven't changed. You can select ANY lines of code in the diff, and not just those that are part of the changeset. Note that these comments are added as a \"single comment\" to the pull request and aren't part of any review you may have in progress. All the power of GitHub pull requests and GitLab merge requests, and then some, right in your IDE. Leveraging pull request comments Once the pull request has been approved and the code has been merged that's usually the end of life for any comments in that pull request. Although there is often useful information in those comments, that may have long-term value, they are rarely seen again. CodeStream gives those comments a second life by displaying them alongside the blocks of code that they refer to. To have pull request comments displayed as annotions in your codemarks, as well as in the Codemarks section of the CodeStream pane, click on the gear icon in that section and check the box to \"Show comments from pull requests\". When you first check that box, if you haven’t already authenticated with your code-hosting service you’ll be prompted to do so. Comments from merged PRs will appear next to the blocks of code they refer to. Comments from open PRs will also be included if you are on a relevant branch. For example, if the open PR is a request to merge the feature/some-name branch into main, you’ll see comments from that PR if you are checked out to either feature/some-name or main, but not when you’re on any other branch. As the code evolves, the location of each comment is automatically updated so that it remains linked to the block of code it refers to. Note that PR comments for a given file are updated roughly every 30 minutes, so new comments may not appear right away. You can force an update by restarting your IDE.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 606.2499,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage pull requests on <em>CodeStream</em>",
        "sections": "Manage pull requests on <em>CodeStream</em>",
        "body": " that are part of the changeset. Note that these comments are added as a &quot;single comment&quot; to the pull request and <em>aren&#x27;t</em> part of any review you may have in progress. <em>All</em> the power of <em>GitHub</em> pull requests and <em>Git</em>Lab merge requests, and then some, right in your IDE. Leveraging pull request comments"
      },
      "id": "61744006196a67ee542f0555"
    },
    {
      "image": "https://docs.newrelic.com/static/74c274508fc745275751f72d3e01ea33/f96db/CodemarkAddRange1.png",
      "url": "https://docs.newrelic.com/docs/codestream/how-use-codestream/discuss-code/",
      "sections": [
        "Discuss code on CodeStream",
        "What is a codemark?",
        "Creating a codemark",
        "Comment Codemarks",
        "Issue Codemarks",
        "Bringing the right people into the discussion",
        "Different versions of the code?",
        "Resolving codemarks",
        "Advanced Features",
        "Multiple Ranges",
        "File Attachments",
        "Tagging",
        "Related codemarks",
        "Managing codemarks"
      ],
      "published_at": "2021-10-24T21:18:06Z",
      "title": "Discuss code on CodeStream",
      "updated_at": "2021-10-23T17:01:57Z",
      "type": "docs",
      "external_id": "9169c03142311fe838566856d0ff154df0e6d555",
      "document_type": "page",
      "popularity": 1,
      "body": "What is a codemark? Quite simply, a codemark is a discussion connected to the code. It could be a question, a suggestion, a bug report, or documentation. All of these discussions are saved, anchored to the blocks of code they refer to, so that they can be leveraged in the future. It could be a new developer joining the team, a developer trying to fix a bug in someone else’s code, or even just you trying to remember why you made that change six months ago… whatever the case, CodeStream helps you understand the code by surfacing the discussions in a contextual way. Even as a file changes over time, the codemarks will remain connected to the code. Add some new lines of code above the code block, make edits to the code, or even cut-and-paste the entire block to a different section of the file, and you’ll see the codemark move right along with the changes. Creating a codemark Create a codemark by selecting a block of code in your editor and then clicking on one of the icons that appears in the CodeStream pane next to your selection. If you're using a JetBrains IDE, such as IntelliJ, you can also create a codemark by using the \"+\" button that appears in the editor's gutter when you select a block of code. When you're viewing a diff, for either a feedback request or a pull request, the button will also appear when you hover in the gutter to make it easy to comment on a single line. Even when the CodeStream pane is closed or not in view, you can create a codemark via the CodeStream options in either the lightbulb or context menus. Lastly, you can also look for the \"+\" menu at the top of the CodeStream pane. Need to reach teammates that don’t spend a lot of time in the IDE? Or maybe some teammates that aren’t yet on CodeStream? You can optionally share a codemark out to Slack or Microsoft Teams. The Slack integration even allows your teammates to reply directly from Slack. Comment Codemarks The all-purpose codemark for linking any type of discussion to a block of code. Ask a question. Make a suggestion. Document some code. Make note of key sections of the codebase. The possibilities are endless! Issue Codemarks When something needs to get done there’s always a better chance of it happening if it’s captured as an issue, with someone’s name attached. Assign issues as a way of reporting bugs. Or manage your tech debt by capturing items as tracked issues instead of inline FIXMEs. If your team uses Asana, Azure DevOps, Bitbucket (cloud), Clubhouse, GitHub (cloud or Enterprise), GitLab (cloud or Self-Managed), Jira (cloud or Server), Linear, Trello, or YouTrack (cloud) for tracking issues, you can create an issue on one of those services directly from CodeStream. Just select the service you use from the dropdown at the top of the codemark form. After going through the authentication process with the selected service you'll now be able to select a destination for your issue. For example, with Jira you'll be able to select the appropriate issue type and project. Once the issue has been created on CodeStream, it will include a link to the issue that was created on the external service. In the example below you'll see the URL for the issue on Jira. And the issue on Jira includes a link to open the relevant code in your IDE. Bringing the right people into the discussion When you create a codemark, CodeStream automatically mentions the people that most recently touched of the code you are commenting on. They may be the best people to answer your question, but you can, of course, remove those mentions and manually mention someone else if appropriate. It may be the case that the people that have touched the code aren't yet on CodeStream, in which case CodeStream will provide checkboxes to have them notified via email. They can simply reply to the email to have their comment posted to CodeStream, and of course they can install CodeStream to participate from their IDE. Different versions of the code? Maybe you’re on a feature branch, have local changes, or simply haven’t pulled in a while. There are countless reasons why the code you’re looking at might be different than what a teammate is looking at, and as a result, there will be plenty of times when the code referenced in a codemark doesn’t match what you have locally. CodeStream recognizes these situations and includes the original version of the code block (i.e. at the time the codemark was created), the current version, and a diff. Keep in mind that with CodeStream you can discuss any line of code, in any source file, at any time, even if it’s code that you just typed into your editor and haven’t yet committed. CodeStream allows you to discuss code at the very earliest stages of the development process. Resolving codemarks Although not required, both comment and issue codemarks can be resolved. The Codemarks section of the CodeStream pane breaks out codemarks into Open, Resolved and Archived sections, and green, purple and gray icons are used to represent those different states. If you see a lot of Open/green codemarks in the codestream pane, that means that your teammates are being blocked by discussions and issues that haven't be resolved. You can add a comment at the same time your resolve the codemark, and you can also elect to archive the codemark at the same time. Advanced Features Multiple Ranges Many discussions about code involve more than just one block of code, and concepts are often best presented when you can refer to multiple code locations at once. Here are a few examples of multi-range codemark at work: A change to a function is being contemplated that will impact its name. Each instance of the function call can now be referenced in one discussion. A react component and its CSS styling aren’t interacting well, and you want to ask the team for input. You might select the div and the CSS rules you think should apply, so your teammates know exactly what you’re talking about. Clients which make API calls to the server might get an unexpected result. Select the code where you’re making the API call, and the handler in the API server, to connect the two actions together. To create a multi-range codemark, click on \"+ Add Code Block\". And then select another block of code from the same file, a different file, or even a different repo. You can intersperse the difference code blocks in your post by referring to each one as [#N] (or click the pin icon from one of the code blocks to insert the markdown for you), as in the following example. And here's how that example is rendered. Once you've created the codemark, you can easily jump between the different locations by clicking the Jump icon at the bottom-right of each code block. Note that when you edit a codemark you can add and remove code blocks, and you can change the location of any of the code blocks by clicking the dashed square icon. File Attachments Enrich your discussions about code by attaching files directly to code blocks. Think about how much more compelling your comments and documentation become when you... Attach a spec to guide the development of a new feature Attach a log file to help debug an issue in the code Attach a mockup to help clarify some UI work Attach a screenshot to highlight a problem When creating a code comment or issue, you can attach a file by dragging-and-dropping on the the description field, pasting from you clipboard, or by clicking the new paperclip icon. Images can even be displayed inline using markdown. Just click the pin icon to the right of the attachment, and CodeStream will insert the markdown for you. And now your teammate knows exactly what you’re looking for! You can click on files in the Attachments section to either download or open in the appropriate application. Tagging Look for the tag icon inside the codemark compose box to either select a tag or create a tag using any combination of color and text label. Tags are a great way to broadly organize and group your organization's codemarks, and the possibilities here are endless. Note that you can also filter by tag on the Filter & Search page. Related codemarks Click on the CodeStream icon in the codemark compose form to select other, related codemarks to “attach” to the current codemark. This allows you to easily establish a connection between different parts of a codebase. For example, when a change to one part of the codebase would require a change to another part, identify the dependency by creating two related codemarks. Once you’ve added the related codemarks they’ll be displayed in a “Related” section and you can click on any one to jump to that codemark and the corresponding section of the code. Managing codemarks Click on the ellipses menu for any codemark and you'll see options for managing the codemark. Share - In addition to sharing to Slack or Teams at the time you create a codemark, you can also share it anytime thereafter. Follow/Unfollow - Unfollow to stop receiving notifications for the codemark. Copy link - Get a permalink for the codemark to share it anywhere. Archive - If there’s a codemark that you don’t think is important enough to be on permanent display in a given file, but you don’t want to completely delete it, you can archive it instead. Settings in the codemarks section allow you to easily see all archived codemarks. Edit - Only the codemark's author can edit it. Delete - Only the codemark's author can delete it, but we encourage you to archive instead of delete unless you're positive the codemark won't have any future value. Inject as Inline Comment - If you'd like a specific codemark to become part of the repo use this option to have it added as an inline comment. You can select the appropriate format, and then indicate if you want to include timestamps, replies, or to have the comment wrapped at 80 characters. You can also elect to have the codemark archived once it's been added as an inline comment. Reposition codemark - In most cases, a codemark will automatically remain linked to the block of code it refers to as the file changes over time. For example, if you cut the block of code and paste it at a different location in the file, the codemark will move right along with it. There are some scenarios, however, that CodeStream isn't able to handle automatically. For example, if you pasted the block of code into a different file. In these cases, Reposition codemark allows you to select the new location of the block of code so that the codemark is displayed properly.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 501.24084,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Discuss <em>code</em> on <em>CodeStream</em>",
        "sections": "Discuss <em>code</em> on <em>CodeStream</em>",
        "body": " of inline FIXMEs. If your team uses Asana, Azure DevOps, Bitbucket (cloud), Clubhouse, <em>GitHub</em> (cloud or Enterprise), <em>Git</em>Lab (cloud or Self-Managed), Jira (cloud or Server), Linear, Trello, or YouTrack (cloud) for tracking <em>issues</em>, you can create an issue on one of those services directly <em>from</em> <em>CodeStream</em>"
      },
      "id": "6174400564441fe8685fd746"
    },
    {
      "image": "https://docs.newrelic.com/static/8fc91276c7cb53b35f896fcac177247d/f96db/IssuesSection.png",
      "url": "https://docs.newrelic.com/docs/codestream/codestream-ui-overview/issues-section/",
      "sections": [
        "CodeStream issues"
      ],
      "published_at": "2021-10-24T21:16:34Z",
      "title": "CodeStream issues",
      "updated_at": "2021-10-23T16:59:55Z",
      "type": "docs",
      "external_id": "4c463e5a5ce0017a2496b90dd3f410cd711cef62",
      "document_type": "page",
      "popularity": 1,
      "body": "If you're not already connected to an issue tracking service, initially this section will list all available services. Asana Azure DevOps Bitbucket (cloud) Clubhouse GitHub (cloud or Enterprise) GitLab (cloud or Self-Managed) Jira (cloud or Server) Linear Trello YouTrack (cloud) Once you’ve connected to your team’s issue tracking service, all issues assigned to you will be listed in the Issues section of the CodeStream pane. Note that you can be connected to multiple services at once, simply by selecting them from the dropdown list. Click on an issue to start work by creating a feature branch, updating the ticket status, and even updating your status on Slack. When you hover over an issue's row you'll see an option to view the issue on your issue-tracking service toward the end of the row. For many services you can also filter the list. For example, if you’re connected to Trello, you can filter to see a specific list or set of lists. For Jira, Jira Server, GitHub, GitHub Enterprise, GitLab and GitLab Self-Managed you can even create custom filters. Note that there are some special guidelines when creating a custom query for GitHub and GitHub Enterprise or for GitLab and GitLab Self-Managed. Hover over the section's heading for more options. Click on the refresh button to update the list with any recently added tickets. Click “New issue\" (although it may be labelled differently based on the selected service) to create a issue in your issue tracking service right from CodeStream. You can even associate that ticket with a block of code in your editor! If you need to work on something that doesn’t have an associated ticket, you can click “Start ad-hoc Work” to get started without a ticket.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 468.10907,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> <em>issues</em>",
        "sections": "<em>CodeStream</em> <em>issues</em>",
        "body": " connected to your team’s issue tracking service, <em>all</em> <em>issues</em> assigned to you will be <em>listed</em> in the <em>Issues</em> section of the <em>CodeStream</em> pane. Note that you can be connected to multiple services at once, simply by selecting them <em>from</em> the dropdown <em>list</em>. Click on an issue to start work by creating a feature branch"
      },
      "id": "61743f8b64441f60375fdaf5"
    }
  ],
  "/docs/codestream/troubleshooting/glsm-version": [
    {
      "image": "https://docs.newrelic.com/static/8fc91276c7cb53b35f896fcac177247d/f96db/IssuesSection.png",
      "url": "https://docs.newrelic.com/docs/codestream/codestream-ui-overview/issues-section/",
      "sections": [
        "CodeStream issues"
      ],
      "published_at": "2021-10-24T21:16:34Z",
      "title": "CodeStream issues",
      "updated_at": "2021-10-23T16:59:55Z",
      "type": "docs",
      "external_id": "4c463e5a5ce0017a2496b90dd3f410cd711cef62",
      "document_type": "page",
      "popularity": 1,
      "body": "If you're not already connected to an issue tracking service, initially this section will list all available services. Asana Azure DevOps Bitbucket (cloud) Clubhouse GitHub (cloud or Enterprise) GitLab (cloud or Self-Managed) Jira (cloud or Server) Linear Trello YouTrack (cloud) Once you’ve connected to your team’s issue tracking service, all issues assigned to you will be listed in the Issues section of the CodeStream pane. Note that you can be connected to multiple services at once, simply by selecting them from the dropdown list. Click on an issue to start work by creating a feature branch, updating the ticket status, and even updating your status on Slack. When you hover over an issue's row you'll see an option to view the issue on your issue-tracking service toward the end of the row. For many services you can also filter the list. For example, if you’re connected to Trello, you can filter to see a specific list or set of lists. For Jira, Jira Server, GitHub, GitHub Enterprise, GitLab and GitLab Self-Managed you can even create custom filters. Note that there are some special guidelines when creating a custom query for GitHub and GitHub Enterprise or for GitLab and GitLab Self-Managed. Hover over the section's heading for more options. Click on the refresh button to update the list with any recently added tickets. Click “New issue\" (although it may be labelled differently based on the selected service) to create a issue in your issue tracking service right from CodeStream. You can even associate that ticket with a block of code in your editor! If you need to work on something that doesn’t have an associated ticket, you can click “Start ad-hoc Work” to get started without a ticket.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 788.93054,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> issues",
        "sections": "<em>CodeStream</em> issues",
        "body": "If you&#x27;re not already connected to an issue tracking service, initially this section will list all available services. Asana Azure DevOps Bitbucket (cloud) Clubhouse <em>Git</em>Hub (cloud or Enterprise) <em>GitLab</em> (cloud or <em>Self</em>-<em>Managed</em>) Jira (cloud or Server) Linear Trello YouTrack (cloud) Once you’ve"
      },
      "id": "61743f8b64441f60375fdaf5"
    },
    {
      "image": "https://docs.newrelic.com/static/dd18b67123e9d4b7d40b56a8653a1f6b/f96db/OpenPullRequest1.png",
      "url": "https://docs.newrelic.com/docs/codestream/how-use-codestream/pull-requests/",
      "sections": [
        "Manage pull requests on CodeStream",
        "Creating a pull request",
        "Reviewing a pull request",
        "Leveraging pull request comments"
      ],
      "published_at": "2021-10-24T21:18:51Z",
      "title": "Manage pull requests on CodeStream",
      "updated_at": "2021-10-23T17:01:57Z",
      "type": "docs",
      "external_id": "7e35f2ff4f06799fe492ffb6b2fedbb52e898b69",
      "document_type": "page",
      "popularity": 1,
      "body": "For most development teams, the final step in the development process is a pull request. Even if your team has decided to use CodeStream's feedback requests as a replacement for, and not just a precursor to, your end-of-cycle PR-based code reviews, CodeStream allows you to keep all of that workflow right in your IDE. There are three elements of CodeStream's pull-request integration, and the following table outlines which code-hosting services are supported for each. Feature Supported Services Create a pull request GitHub, GitHub Enterprise, GitLab, GitLab Self-Managed, Bitbucket, Bitbucket Server Create a pull request across forks GitHub, GitHub Enterprise, GitLab, GitLab Self-Managed Review and edit a pull request GitHub, GitHub Enterprise, GitLab, GitLab Self-Managed Display pull request comments as code annotations GitHub, GitLab, Bitbucket Creating a pull request Open a pull request at any time by clicking on the \"+\" button at the top of the CodeStream pane, or the \"+\" button in the header of the Pull Requests section. You can also use a keyboard shortcut (ctlr+shift+/ p, or ctrl+/ p on a Mac... and you can use m if you're a GitLab user). CodeStream even provides you with different options (tree view, list view, diff hunks) for reviewing your changes before opening the pull request. With a single click you can name the pull request based on the last commit message, the branch name, or, if you started work by selecting a ticket, the ticket title. If you have a ticket selected, you can also explicitly tie the ticket to the pull request, and CodeStream will include a link to the ticket in the pull request's description. Before submitting the pull request you can even review your changes by clicking on any of the files listed below the form. To create a pull request across forks, click on the \"compare across forks\" link at the top of the page and the form will update to allow you to select both the base and head repositories. You can also create a pull request from within a CodeStream feedback request. Once the feedback request has been approved, you’ll see an option to open a pull request at the top. Before you can create a pull request you’ll need to make sure that any changes included in the feedback request have been committed and pushed. Also, if the feature branch you’re working on doesn’t have a remote tracking branch you’ll be given the option to set that as part of creating the pull request. When you create a pull request from a feedback request, CodeStream connect's the dots between the two by adding a link to the pull request to the feedback request. And by adding a link to the feedback request, along with information about who did the review and when, in the description of the pull request. Reviewing a pull request The ability to review pull requests is currently not available for Bitbucket. Regardless of where the pull request was created, you can edit, review, and even merge it, right from CodeStream. We've essentially brought GitHub and GitLab right into your IDE, so there's zero learning curve. If you know how to work with pull requests on GitHub or GitLab, you'll know how to do it in CodeStream as well. Edit a GitHub pull request's details, such as reviewers, assignees and labels. For a GitLab merge request, you can use edit mode (via the dropdown at the top of the page) or use the sidebar. By default, you can only add a single reviewer and a single assignee to a GitLab merge request. If your organization supports multiple reviewers and assignees, click the gear menu in the heading of the Merge Requests section of the CodeStream pane to enable this. Review the conversation and add comments, with the ability to @mention your collaborators. View the changes, add comments, and submit a review. Of course, we did improve upon the GitHub/GitLab experience in a couple of important ways. On GitHub and GitLab you can only view the changes as a series of \"diff hunks\". CodeStream provides that view as well, but if you'd prefer to see the changes in the context of the full file, and not just the lines that changed, you can use either List View or Tree View. Just select the code you want to comment on, and then click on the Comment button (or select Comment from the context menu). When commenting you can either add a single comment, or start a review. Another difference is that CodeStream allows you to comment on lines of code that haven't changed. You can select ANY lines of code in the diff, and not just those that are part of the changeset. Note that these comments are added as a \"single comment\" to the pull request and aren't part of any review you may have in progress. All the power of GitHub pull requests and GitLab merge requests, and then some, right in your IDE. Leveraging pull request comments Once the pull request has been approved and the code has been merged that's usually the end of life for any comments in that pull request. Although there is often useful information in those comments, that may have long-term value, they are rarely seen again. CodeStream gives those comments a second life by displaying them alongside the blocks of code that they refer to. To have pull request comments displayed as annotions in your codemarks, as well as in the Codemarks section of the CodeStream pane, click on the gear icon in that section and check the box to \"Show comments from pull requests\". When you first check that box, if you haven’t already authenticated with your code-hosting service you’ll be prompted to do so. Comments from merged PRs will appear next to the blocks of code they refer to. Comments from open PRs will also be included if you are on a relevant branch. For example, if the open PR is a request to merge the feature/some-name branch into main, you’ll see comments from that PR if you are checked out to either feature/some-name or main, but not when you’re on any other branch. As the code evolves, the location of each comment is automatically updated so that it remains linked to the block of code it refers to. Note that PR comments for a given file are updated roughly every 30 minutes, so new comments may not appear right away. You can force an update by restarting your IDE.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 780.1598,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Manage</em> pull requests on <em>CodeStream</em>",
        "sections": "<em>Manage</em> pull requests on <em>CodeStream</em>",
        "body": " right in <em>your</em> IDE. There are three elements of <em>CodeStream</em>&#x27;s pull-request integration, and the following table outlines which <em>code</em>-hosting services are supported for each. Feature Supported Services Create a pull request <em>Git</em>Hub, <em>Git</em>Hub Enterprise, <em>GitLab</em>, <em>GitLab</em> <em>Self</em>-<em>Managed</em>, Bitbucket, Bitbucket"
      },
      "id": "61744006196a67ee542f0555"
    },
    {
      "image": "https://docs.newrelic.com/static/8945e0a9c512b8638ebf8165d47aee04/69902/QS-SignUp3.png",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/codestream-user-guide/",
      "sections": [
        "CodeStream user guide",
        "Quick Start",
        "1. Install the CodeStream extension in your IDE and sign up.",
        "2. Connect your tools",
        "3. Discuss any block of code, at any time",
        "4. Get feedback on your work in progress",
        "5. Create or review a pull request",
        "Help & Feedback"
      ],
      "published_at": "2021-10-24T21:19:37Z",
      "title": "CodeStream user guide",
      "updated_at": "2021-10-23T17:07:02Z",
      "type": "docs",
      "external_id": "fa9af0118a8872fea89fda91482c44fb69913ea2",
      "document_type": "page",
      "popularity": 1,
      "body": "Quick Start Use the navigation to the left to jump straight to any topic. Otherwise, read on to get started with CodeStream. 1. Install the CodeStream extension in your IDE and sign up. Install CodeStream for VS Code, Visual Studio or JetBrains. The CodeStream pane should automatically appear in the sidebar for VS Code, or in a tool window at the right side for a JetBrains IDE or Visual Studio. Click on \"Sign Up and Create a team\" if you are the first person from your team to join CodeStream, or paste in your invitation code if you were invited to a team already on CodeStream. Learn more about how to use CodeStream. 2. Connect your tools Create and review pull requests on GitHub, GitLab or Bitbucket. Create issues on Jira, Trello, and other issue trackers. Share code discussions on Slack or Microsoft Teams. CodeStream brings the tools you use every day together in your IDE. Click on your headshot at the top of the CodeStream pane and go to the Integrations page to get all of your tools connected. 3. Discuss any block of code, at any time Whether you're trying to understand someone else's code or getting help with some code you just wrote, just select the code and ask your question. Learn more about discussing code. 4. Get feedback on your work in progress Select \"Request Feedback\" from the \"+\" menu at any time in the development cycle, whether it’s a quick look over some work in progress (even uncommitted code!) or a formal review of a completed effort. Teammates can review your changes right in their IDE, with no need to switch branches or set aside their own work. Learn more about feedback requests. 5. Create or review a pull request Look for the Pull Requests section of the CodeStream sidebar to review an open pull request. Just click on a pull request (or load one from URL) to get a complete GitHub experience right in your IDE! Note that you can create a pull request in GitHub, GitLab or Bitbucket, but support for reviewing pull requests is currently only available for GitHub (cloud or Enterprise). Learn more about pull requests. Help & Feedback Report a bug or send a suggestion in GitHub issues. Contact us directly at support@codestream.com. Follow @teamcodestream for product updates and to share feedback and questions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 625.9658,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> user guide",
        "sections": "1. Install <em>the</em> <em>CodeStream</em> extension in <em>your</em> IDE and sign up.",
        "body": " about how to use <em>CodeStream</em>. 2. Connect <em>your</em> tools Create and review pull requests on <em>Git</em>Hub, <em>GitLab</em> or Bitbucket. Create issues on Jira, Trello, and other issue trackers. Share <em>code</em> discussions on Slack or Microsoft Teams. <em>CodeStream</em> brings the tools you use every day together in <em>your</em> IDE. Click"
      },
      "id": "61744137e7b9d2428b13c6a0"
    }
  ],
  "/docs/codestream/troubleshooting/jira-server-integration": [
    {
      "image": "https://docs.newrelic.com/static/74c274508fc745275751f72d3e01ea33/f96db/CodemarkAddRange1.png",
      "url": "https://docs.newrelic.com/docs/codestream/how-use-codestream/discuss-code/",
      "sections": [
        "Discuss code on CodeStream",
        "What is a codemark?",
        "Creating a codemark",
        "Comment Codemarks",
        "Issue Codemarks",
        "Bringing the right people into the discussion",
        "Different versions of the code?",
        "Resolving codemarks",
        "Advanced Features",
        "Multiple Ranges",
        "File Attachments",
        "Tagging",
        "Related codemarks",
        "Managing codemarks"
      ],
      "published_at": "2021-10-24T21:18:06Z",
      "title": "Discuss code on CodeStream",
      "updated_at": "2021-10-23T17:01:57Z",
      "type": "docs",
      "external_id": "9169c03142311fe838566856d0ff154df0e6d555",
      "document_type": "page",
      "popularity": 1,
      "body": "What is a codemark? Quite simply, a codemark is a discussion connected to the code. It could be a question, a suggestion, a bug report, or documentation. All of these discussions are saved, anchored to the blocks of code they refer to, so that they can be leveraged in the future. It could be a new developer joining the team, a developer trying to fix a bug in someone else’s code, or even just you trying to remember why you made that change six months ago… whatever the case, CodeStream helps you understand the code by surfacing the discussions in a contextual way. Even as a file changes over time, the codemarks will remain connected to the code. Add some new lines of code above the code block, make edits to the code, or even cut-and-paste the entire block to a different section of the file, and you’ll see the codemark move right along with the changes. Creating a codemark Create a codemark by selecting a block of code in your editor and then clicking on one of the icons that appears in the CodeStream pane next to your selection. If you're using a JetBrains IDE, such as IntelliJ, you can also create a codemark by using the \"+\" button that appears in the editor's gutter when you select a block of code. When you're viewing a diff, for either a feedback request or a pull request, the button will also appear when you hover in the gutter to make it easy to comment on a single line. Even when the CodeStream pane is closed or not in view, you can create a codemark via the CodeStream options in either the lightbulb or context menus. Lastly, you can also look for the \"+\" menu at the top of the CodeStream pane. Need to reach teammates that don’t spend a lot of time in the IDE? Or maybe some teammates that aren’t yet on CodeStream? You can optionally share a codemark out to Slack or Microsoft Teams. The Slack integration even allows your teammates to reply directly from Slack. Comment Codemarks The all-purpose codemark for linking any type of discussion to a block of code. Ask a question. Make a suggestion. Document some code. Make note of key sections of the codebase. The possibilities are endless! Issue Codemarks When something needs to get done there’s always a better chance of it happening if it’s captured as an issue, with someone’s name attached. Assign issues as a way of reporting bugs. Or manage your tech debt by capturing items as tracked issues instead of inline FIXMEs. If your team uses Asana, Azure DevOps, Bitbucket (cloud), Clubhouse, GitHub (cloud or Enterprise), GitLab (cloud or Self-Managed), Jira (cloud or Server), Linear, Trello, or YouTrack (cloud) for tracking issues, you can create an issue on one of those services directly from CodeStream. Just select the service you use from the dropdown at the top of the codemark form. After going through the authentication process with the selected service you'll now be able to select a destination for your issue. For example, with Jira you'll be able to select the appropriate issue type and project. Once the issue has been created on CodeStream, it will include a link to the issue that was created on the external service. In the example below you'll see the URL for the issue on Jira. And the issue on Jira includes a link to open the relevant code in your IDE. Bringing the right people into the discussion When you create a codemark, CodeStream automatically mentions the people that most recently touched of the code you are commenting on. They may be the best people to answer your question, but you can, of course, remove those mentions and manually mention someone else if appropriate. It may be the case that the people that have touched the code aren't yet on CodeStream, in which case CodeStream will provide checkboxes to have them notified via email. They can simply reply to the email to have their comment posted to CodeStream, and of course they can install CodeStream to participate from their IDE. Different versions of the code? Maybe you’re on a feature branch, have local changes, or simply haven’t pulled in a while. There are countless reasons why the code you’re looking at might be different than what a teammate is looking at, and as a result, there will be plenty of times when the code referenced in a codemark doesn’t match what you have locally. CodeStream recognizes these situations and includes the original version of the code block (i.e. at the time the codemark was created), the current version, and a diff. Keep in mind that with CodeStream you can discuss any line of code, in any source file, at any time, even if it’s code that you just typed into your editor and haven’t yet committed. CodeStream allows you to discuss code at the very earliest stages of the development process. Resolving codemarks Although not required, both comment and issue codemarks can be resolved. The Codemarks section of the CodeStream pane breaks out codemarks into Open, Resolved and Archived sections, and green, purple and gray icons are used to represent those different states. If you see a lot of Open/green codemarks in the codestream pane, that means that your teammates are being blocked by discussions and issues that haven't be resolved. You can add a comment at the same time your resolve the codemark, and you can also elect to archive the codemark at the same time. Advanced Features Multiple Ranges Many discussions about code involve more than just one block of code, and concepts are often best presented when you can refer to multiple code locations at once. Here are a few examples of multi-range codemark at work: A change to a function is being contemplated that will impact its name. Each instance of the function call can now be referenced in one discussion. A react component and its CSS styling aren’t interacting well, and you want to ask the team for input. You might select the div and the CSS rules you think should apply, so your teammates know exactly what you’re talking about. Clients which make API calls to the server might get an unexpected result. Select the code where you’re making the API call, and the handler in the API server, to connect the two actions together. To create a multi-range codemark, click on \"+ Add Code Block\". And then select another block of code from the same file, a different file, or even a different repo. You can intersperse the difference code blocks in your post by referring to each one as [#N] (or click the pin icon from one of the code blocks to insert the markdown for you), as in the following example. And here's how that example is rendered. Once you've created the codemark, you can easily jump between the different locations by clicking the Jump icon at the bottom-right of each code block. Note that when you edit a codemark you can add and remove code blocks, and you can change the location of any of the code blocks by clicking the dashed square icon. File Attachments Enrich your discussions about code by attaching files directly to code blocks. Think about how much more compelling your comments and documentation become when you... Attach a spec to guide the development of a new feature Attach a log file to help debug an issue in the code Attach a mockup to help clarify some UI work Attach a screenshot to highlight a problem When creating a code comment or issue, you can attach a file by dragging-and-dropping on the the description field, pasting from you clipboard, or by clicking the new paperclip icon. Images can even be displayed inline using markdown. Just click the pin icon to the right of the attachment, and CodeStream will insert the markdown for you. And now your teammate knows exactly what you’re looking for! You can click on files in the Attachments section to either download or open in the appropriate application. Tagging Look for the tag icon inside the codemark compose box to either select a tag or create a tag using any combination of color and text label. Tags are a great way to broadly organize and group your organization's codemarks, and the possibilities here are endless. Note that you can also filter by tag on the Filter & Search page. Related codemarks Click on the CodeStream icon in the codemark compose form to select other, related codemarks to “attach” to the current codemark. This allows you to easily establish a connection between different parts of a codebase. For example, when a change to one part of the codebase would require a change to another part, identify the dependency by creating two related codemarks. Once you’ve added the related codemarks they’ll be displayed in a “Related” section and you can click on any one to jump to that codemark and the corresponding section of the code. Managing codemarks Click on the ellipses menu for any codemark and you'll see options for managing the codemark. Share - In addition to sharing to Slack or Teams at the time you create a codemark, you can also share it anytime thereafter. Follow/Unfollow - Unfollow to stop receiving notifications for the codemark. Copy link - Get a permalink for the codemark to share it anywhere. Archive - If there’s a codemark that you don’t think is important enough to be on permanent display in a given file, but you don’t want to completely delete it, you can archive it instead. Settings in the codemarks section allow you to easily see all archived codemarks. Edit - Only the codemark's author can edit it. Delete - Only the codemark's author can delete it, but we encourage you to archive instead of delete unless you're positive the codemark won't have any future value. Inject as Inline Comment - If you'd like a specific codemark to become part of the repo use this option to have it added as an inline comment. You can select the appropriate format, and then indicate if you want to include timestamps, replies, or to have the comment wrapped at 80 characters. You can also elect to have the codemark archived once it's been added as an inline comment. Reposition codemark - In most cases, a codemark will automatically remain linked to the block of code it refers to as the file changes over time. For example, if you cut the block of code and paste it at a different location in the file, the codemark will move right along with it. There are some scenarios, however, that CodeStream isn't able to handle automatically. For example, if you pasted the block of code into a different file. In these cases, Reposition codemark allows you to select the new location of the block of code so that the codemark is displayed properly.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 331.28003,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Discuss <em>code</em> on <em>CodeStream</em>",
        "sections": "Discuss <em>code</em> on <em>CodeStream</em>",
        "body": " of inline FIXMEs. If your team uses Asana, Azure DevOps, Bitbucket (cloud), Clubhouse, GitHub (cloud or Enterprise), GitLab (cloud or Self-Managed), <em>Jira</em> (cloud or <em>Server</em>), Linear, Trello, or YouTrack (cloud) for tracking issues, you can create an issue on one of those services directly from <em>CodeStream</em>"
      },
      "id": "6174400564441fe8685fd746"
    },
    {
      "image": "https://docs.newrelic.com/static/8fc91276c7cb53b35f896fcac177247d/f96db/IssuesSection.png",
      "url": "https://docs.newrelic.com/docs/codestream/codestream-ui-overview/issues-section/",
      "sections": [
        "CodeStream issues"
      ],
      "published_at": "2021-10-24T21:16:34Z",
      "title": "CodeStream issues",
      "updated_at": "2021-10-23T16:59:55Z",
      "type": "docs",
      "external_id": "4c463e5a5ce0017a2496b90dd3f410cd711cef62",
      "document_type": "page",
      "popularity": 1,
      "body": "If you're not already connected to an issue tracking service, initially this section will list all available services. Asana Azure DevOps Bitbucket (cloud) Clubhouse GitHub (cloud or Enterprise) GitLab (cloud or Self-Managed) Jira (cloud or Server) Linear Trello YouTrack (cloud) Once you’ve connected to your team’s issue tracking service, all issues assigned to you will be listed in the Issues section of the CodeStream pane. Note that you can be connected to multiple services at once, simply by selecting them from the dropdown list. Click on an issue to start work by creating a feature branch, updating the ticket status, and even updating your status on Slack. When you hover over an issue's row you'll see an option to view the issue on your issue-tracking service toward the end of the row. For many services you can also filter the list. For example, if you’re connected to Trello, you can filter to see a specific list or set of lists. For Jira, Jira Server, GitHub, GitHub Enterprise, GitLab and GitLab Self-Managed you can even create custom filters. Note that there are some special guidelines when creating a custom query for GitHub and GitHub Enterprise or for GitLab and GitLab Self-Managed. Hover over the section's heading for more options. Click on the refresh button to update the list with any recently added tickets. Click “New issue\" (although it may be labelled differently based on the selected service) to create a issue in your issue tracking service right from CodeStream. You can even associate that ticket with a block of code in your editor! If you need to work on something that doesn’t have an associated ticket, you can click “Start ad-hoc Work” to get started without a ticket.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 315.7542,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> issues",
        "sections": "<em>CodeStream</em> issues",
        "body": " connected to your team’s issue tracking service, all issues assigned to you will be listed in the Issues section of the <em>CodeStream</em> pane. Note that you can be connected to multiple services at once, simply by selecting them from the dropdown list. Click on an issue to start work by creating a feature branch"
      },
      "id": "61743f8b64441f60375fdaf5"
    },
    {
      "image": "https://docs.newrelic.com/static/ea83ab725203cb798b1a7b6d3af88c2b/08a84/NewPermalink2.png",
      "url": "https://docs.newrelic.com/docs/codestream/codestream-ui-overview/permalinks/",
      "sections": [
        "CodeStream permalinks",
        "Permalinks for Sharing Anywhere",
        "Permalinks for Code Blocks"
      ],
      "published_at": "2021-10-24T21:18:06Z",
      "title": "CodeStream permalinks",
      "updated_at": "2021-10-23T16:59:55Z",
      "type": "docs",
      "external_id": "f609a0d15006e640832fd39bcfddcbc9bfaecde5",
      "document_type": "page",
      "popularity": 1,
      "body": "Permalinks for Sharing Anywhere CodeStream has built-in mechanisms for sharing to Slack, Microsoft Teams, or issue-tracking services, like Jira, Trello, etc., but you can also grab the link for any comment, issue or feedback request to share it elsewhere. An existing Jira ticket. A wiki. A thread in your messaging service. Whatever the case may be, just look for the “Copy link” option under the ellipses menu. Whenever someone clicks on the link, after authenticating with CodeStream they'll automatically be redirected through the web to their IDE, where the discussion will automatically be opened. In the case of a comment or issue, the source file will also be opened and scrolled to the corresponding block of code. CodeStream does its best to determine which IDE to open, largley based on the IDE that you last used to access CodeStream. However, you can always return to the web page that was opened and select any IDE. Your selection will be remembered for the next time you attempt to open a discussion associated with the same repository. Note that if you’re using a JetBrains IDE you’ll need to first install the Toolbox App so that CodeStream can deep link into the IDE. Permalinks for Code Blocks Sometimes you don’t necessarily want to comment on a block of code, but instead just want to easily share the code with a teammate. CodeStream's permalinks are \"living\" links that will always point to the code in question, even if it's moved to a different location in the file. Select the code in your editor and then click the button to get a permalink for that code. Decide whether you want the permalink to be public or private, with private permalinks requiring CodeStream authentication before the code can be viewed. Copy your permalink and paste anywhere you'd like to share the block of code. Just like with comments, issues and feedback requests, whenever someone clicks on the permalink they'll automatically be redirected through the web to their IDE, where the source file will be opened and scrolled to the corresponding block of code.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 308.443,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> permalinks",
        "sections": "<em>CodeStream</em> permalinks",
        "body": "Permalinks for Sharing Anywhere <em>CodeStream</em> has built-in mechanisms for sharing to Slack, Microsoft Teams, or issue-tracking services, like <em>Jira</em>, Trello, etc., but you can also grab the link for any comment, issue or feedback request to share it elsewhere. An existing <em>Jira</em> ticket. A wiki. A thread"
      },
      "id": "61743f8b196a6712f92f1ce1"
    }
  ],
  "/docs/codestream/troubleshooting/jira-server-version": [
    {
      "image": "https://docs.newrelic.com/static/13641ba13c10755096fdee8f67741a02/f96db/ConfigureJiraServer1.png",
      "url": "https://docs.newrelic.com/docs/codestream/troubleshooting/jira-server-integration/",
      "sections": [
        "Configure the Jira server CodeStream connection",
        "Generate a public/private key pair",
        "Create an application link",
        "Set up the integration in CodeStream"
      ],
      "published_at": "2021-10-24T21:22:45Z",
      "title": "Configure the Jira server CodeStream connection",
      "updated_at": "2021-10-23T17:10:17Z",
      "type": "docs",
      "external_id": "fa12660611b9120e3aace8e1abdfb74ff89d82be",
      "document_type": "page",
      "popularity": 1,
      "body": "NOTE #1: Recent versions of Jira Server (>=8.14.0) support the use of API Tokens to access the Jira Server REST API. We recommend you use API Tokens if possible to avoid the more complicated setup described here. Check your Jira Server version. NOTE #2: You must be a Jira administrator in order to configure this integration. To determine if you have the proper permissions in order to proceed, look for the Jira Settings menu (cog icon, mostly likely at the top-right next to your headshot) and make sure there's an \"Applications\" option there. If you don't have the Settings menu, or the Applications option, then you won't be able to configure the integration. NOTE #3: This integration requires that your Jira Server instance be at a publicly accessible URL. CodeStream can integrate with Jira Server using Atlassian’s published REST API. To enable CodeStream to integrate with your Jira Server installation, you will need to set up a CodeStream application link. This application link serves as a conduit for users to authenticate against their Jira Server account without ever having to enter their credentials in CodeStream. Jira Server uses the OAuth standard (version 1.0a) for client authorization. For reference, this page from Atlassian describes the process: https://developer.atlassian.com/server/jira/platform/oauth/. However, you do not need to follow the full instructions on that page; the relevant instructions are duplicated and simplified here for clarity. Note that you will need the openssl command-line tool to generate a public/private key pair for use with the application link. Generate a public/private key pair In a terminal, use openssl to generate your public/private key pair, following these steps carefully: Generate a 1024-bit private key: openssl genrsa -out jira_privatekey.pem 1024 Create an X509 certificate: openssl req -newkey rsa:1024 -x509 -key jira_privatekey.pem -out jira_publickey.cer -days 365 Enter whatever information you see fit to accompany the certificate. Extract the private key (PKCS8 format) to the jira_privatekey.pcks8 file: openssl pkcs8 -topk8 -nocrypt -in jira_privatekey.pem -out jira_privatekey.pcks8 Extract the public key from the certificate to the jira_publickey.pem file: openssl x509 -pubkey -noout -in jira_publickey.cer > jira_publickey.pem Create an application link Follow these steps to create your application link within Jira Server. In Jira, navigate to Jira settings (gear icon in upper-right), select Applications. Type in your Administrator password if needed. Then select Application links under \"Integrations\", in the left sidebar. Where it says Enter the URL of the application you want to link, enter any URL you want, for example, http://example.com/. Then click Create new link. You will likely see a warning starting with: No response was received from the URL you entered. You can ignore the warning; click Continue. Fill out the form as you see here, or as you like. None of the data entered here really matters, except to make sure that Create incoming link is checked. The Application Name can be whatever name works best for you to identify the link. Then click Continue. On the next dialog, enter any unique string you want for the Consumer Key. It does not need to be secure or encoded, just something fairly easy to remember. Make a note of what you enter here; it will be needed when you go to set up the integration with Jira Server from CodeStream. For Consumer Name, you can enter anything meaningful to you, like \"CodeStream app\". The important field to fill out correctly is Public Key; for this you will want to copy the full text of the contents of the jira_publickey.pem file you created in Step #1. Paste this into the Public Key field, then click Continue. The application link you created should now show like this: Set up the integration in CodeStream Now you are ready to set up the integration from CodeStream to Jira Server for your team, using the application link you just created. Assuming you have signed up for CodeStream and have the extension open in your IDE: In CodeStream, go to the Integrations panel by clicking the menu next to your username in the top-left. Then click Jira Server under \"Issue Providers\". Since you will not be using API Tokens with your Jira Server integration, you'll need to click at the top where it says \"Click here if you organization uses a version of Jira Server older than...\" to configure Jira Server using the OAuth method described herein. Fill out the form as follows. For Jira Server Base URL, enter the URL used to access your Jira Server installation as known to your internal network, in the form http(s)://host:port. For Consumer Key, use the \"consumer key\" you entered when created the application link, from Step #2, above. Then copy the full contents of the private key, in PCKS8 format, that you created in Step #1 above. The file should be called jira_privatekey.pcks8. Paste those contents into the Private Key field, then click Submit. You'll then be taken to your Jira Server instance, where you'll approve access to your account using the application link. When you are finished, return to your IDE and you should see something similar to this: Now that the integration has been set up for your organization, other users will NOT have to go through the process described above. Other users in your organization will see the integration with your Jira Server (specified by host) alongside other available integrations. Initiating this integration will only require your other users to allow the CodeStream application link to access their account, as you did in the final step.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 434.46814,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Configure the <em>Jira</em> <em>server</em> <em>CodeStream</em> connection",
        "sections": "Configure the <em>Jira</em> <em>server</em> <em>CodeStream</em> connection",
        "body": ", or the Applications option, then you won&#x27;t be able to configure the integration. NOTE #3: This integration requires that <em>your</em> <em>Jira</em> <em>Server</em> instance be at a publicly accessible URL. <em>CodeStream</em> can integrate with <em>Jira</em> <em>Server</em> using Atlassian’s published REST API. To enable <em>CodeStream</em> to integrate with <em>your</em> <em>Jira</em> <em>Server</em>"
      },
      "id": "617441f964441fa1775fe265"
    },
    {
      "image": "https://docs.newrelic.com/static/ea83ab725203cb798b1a7b6d3af88c2b/08a84/NewPermalink2.png",
      "url": "https://docs.newrelic.com/docs/codestream/codestream-ui-overview/permalinks/",
      "sections": [
        "CodeStream permalinks",
        "Permalinks for Sharing Anywhere",
        "Permalinks for Code Blocks"
      ],
      "published_at": "2021-10-24T21:18:06Z",
      "title": "CodeStream permalinks",
      "updated_at": "2021-10-23T16:59:55Z",
      "type": "docs",
      "external_id": "f609a0d15006e640832fd39bcfddcbc9bfaecde5",
      "document_type": "page",
      "popularity": 1,
      "body": "Permalinks for Sharing Anywhere CodeStream has built-in mechanisms for sharing to Slack, Microsoft Teams, or issue-tracking services, like Jira, Trello, etc., but you can also grab the link for any comment, issue or feedback request to share it elsewhere. An existing Jira ticket. A wiki. A thread in your messaging service. Whatever the case may be, just look for the “Copy link” option under the ellipses menu. Whenever someone clicks on the link, after authenticating with CodeStream they'll automatically be redirected through the web to their IDE, where the discussion will automatically be opened. In the case of a comment or issue, the source file will also be opened and scrolled to the corresponding block of code. CodeStream does its best to determine which IDE to open, largley based on the IDE that you last used to access CodeStream. However, you can always return to the web page that was opened and select any IDE. Your selection will be remembered for the next time you attempt to open a discussion associated with the same repository. Note that if you’re using a JetBrains IDE you’ll need to first install the Toolbox App so that CodeStream can deep link into the IDE. Permalinks for Code Blocks Sometimes you don’t necessarily want to comment on a block of code, but instead just want to easily share the code with a teammate. CodeStream's permalinks are \"living\" links that will always point to the code in question, even if it's moved to a different location in the file. Select the code in your editor and then click the button to get a permalink for that code. Decide whether you want the permalink to be public or private, with private permalinks requiring CodeStream authentication before the code can be viewed. Copy your permalink and paste anywhere you'd like to share the block of code. Just like with comments, issues and feedback requests, whenever someone clicks on the permalink they'll automatically be redirected through the web to their IDE, where the source file will be opened and scrolled to the corresponding block of code.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 372.6651,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> permalinks",
        "sections": "<em>CodeStream</em> permalinks",
        "body": "Permalinks for Sharing Anywhere <em>CodeStream</em> has built-in mechanisms for sharing to Slack, Microsoft Teams, or issue-tracking services, like <em>Jira</em>, Trello, etc., but you can also grab the link for any comment, issue or feedback request to share it elsewhere. An existing <em>Jira</em> ticket. A wiki. A thread"
      },
      "id": "61743f8b196a6712f92f1ce1"
    },
    {
      "image": "https://docs.newrelic.com/static/74c274508fc745275751f72d3e01ea33/f96db/CodemarkAddRange1.png",
      "url": "https://docs.newrelic.com/docs/codestream/how-use-codestream/discuss-code/",
      "sections": [
        "Discuss code on CodeStream",
        "What is a codemark?",
        "Creating a codemark",
        "Comment Codemarks",
        "Issue Codemarks",
        "Bringing the right people into the discussion",
        "Different versions of the code?",
        "Resolving codemarks",
        "Advanced Features",
        "Multiple Ranges",
        "File Attachments",
        "Tagging",
        "Related codemarks",
        "Managing codemarks"
      ],
      "published_at": "2021-10-24T21:18:06Z",
      "title": "Discuss code on CodeStream",
      "updated_at": "2021-10-23T17:01:57Z",
      "type": "docs",
      "external_id": "9169c03142311fe838566856d0ff154df0e6d555",
      "document_type": "page",
      "popularity": 1,
      "body": "What is a codemark? Quite simply, a codemark is a discussion connected to the code. It could be a question, a suggestion, a bug report, or documentation. All of these discussions are saved, anchored to the blocks of code they refer to, so that they can be leveraged in the future. It could be a new developer joining the team, a developer trying to fix a bug in someone else’s code, or even just you trying to remember why you made that change six months ago… whatever the case, CodeStream helps you understand the code by surfacing the discussions in a contextual way. Even as a file changes over time, the codemarks will remain connected to the code. Add some new lines of code above the code block, make edits to the code, or even cut-and-paste the entire block to a different section of the file, and you’ll see the codemark move right along with the changes. Creating a codemark Create a codemark by selecting a block of code in your editor and then clicking on one of the icons that appears in the CodeStream pane next to your selection. If you're using a JetBrains IDE, such as IntelliJ, you can also create a codemark by using the \"+\" button that appears in the editor's gutter when you select a block of code. When you're viewing a diff, for either a feedback request or a pull request, the button will also appear when you hover in the gutter to make it easy to comment on a single line. Even when the CodeStream pane is closed or not in view, you can create a codemark via the CodeStream options in either the lightbulb or context menus. Lastly, you can also look for the \"+\" menu at the top of the CodeStream pane. Need to reach teammates that don’t spend a lot of time in the IDE? Or maybe some teammates that aren’t yet on CodeStream? You can optionally share a codemark out to Slack or Microsoft Teams. The Slack integration even allows your teammates to reply directly from Slack. Comment Codemarks The all-purpose codemark for linking any type of discussion to a block of code. Ask a question. Make a suggestion. Document some code. Make note of key sections of the codebase. The possibilities are endless! Issue Codemarks When something needs to get done there’s always a better chance of it happening if it’s captured as an issue, with someone’s name attached. Assign issues as a way of reporting bugs. Or manage your tech debt by capturing items as tracked issues instead of inline FIXMEs. If your team uses Asana, Azure DevOps, Bitbucket (cloud), Clubhouse, GitHub (cloud or Enterprise), GitLab (cloud or Self-Managed), Jira (cloud or Server), Linear, Trello, or YouTrack (cloud) for tracking issues, you can create an issue on one of those services directly from CodeStream. Just select the service you use from the dropdown at the top of the codemark form. After going through the authentication process with the selected service you'll now be able to select a destination for your issue. For example, with Jira you'll be able to select the appropriate issue type and project. Once the issue has been created on CodeStream, it will include a link to the issue that was created on the external service. In the example below you'll see the URL for the issue on Jira. And the issue on Jira includes a link to open the relevant code in your IDE. Bringing the right people into the discussion When you create a codemark, CodeStream automatically mentions the people that most recently touched of the code you are commenting on. They may be the best people to answer your question, but you can, of course, remove those mentions and manually mention someone else if appropriate. It may be the case that the people that have touched the code aren't yet on CodeStream, in which case CodeStream will provide checkboxes to have them notified via email. They can simply reply to the email to have their comment posted to CodeStream, and of course they can install CodeStream to participate from their IDE. Different versions of the code? Maybe you’re on a feature branch, have local changes, or simply haven’t pulled in a while. There are countless reasons why the code you’re looking at might be different than what a teammate is looking at, and as a result, there will be plenty of times when the code referenced in a codemark doesn’t match what you have locally. CodeStream recognizes these situations and includes the original version of the code block (i.e. at the time the codemark was created), the current version, and a diff. Keep in mind that with CodeStream you can discuss any line of code, in any source file, at any time, even if it’s code that you just typed into your editor and haven’t yet committed. CodeStream allows you to discuss code at the very earliest stages of the development process. Resolving codemarks Although not required, both comment and issue codemarks can be resolved. The Codemarks section of the CodeStream pane breaks out codemarks into Open, Resolved and Archived sections, and green, purple and gray icons are used to represent those different states. If you see a lot of Open/green codemarks in the codestream pane, that means that your teammates are being blocked by discussions and issues that haven't be resolved. You can add a comment at the same time your resolve the codemark, and you can also elect to archive the codemark at the same time. Advanced Features Multiple Ranges Many discussions about code involve more than just one block of code, and concepts are often best presented when you can refer to multiple code locations at once. Here are a few examples of multi-range codemark at work: A change to a function is being contemplated that will impact its name. Each instance of the function call can now be referenced in one discussion. A react component and its CSS styling aren’t interacting well, and you want to ask the team for input. You might select the div and the CSS rules you think should apply, so your teammates know exactly what you’re talking about. Clients which make API calls to the server might get an unexpected result. Select the code where you’re making the API call, and the handler in the API server, to connect the two actions together. To create a multi-range codemark, click on \"+ Add Code Block\". And then select another block of code from the same file, a different file, or even a different repo. You can intersperse the difference code blocks in your post by referring to each one as [#N] (or click the pin icon from one of the code blocks to insert the markdown for you), as in the following example. And here's how that example is rendered. Once you've created the codemark, you can easily jump between the different locations by clicking the Jump icon at the bottom-right of each code block. Note that when you edit a codemark you can add and remove code blocks, and you can change the location of any of the code blocks by clicking the dashed square icon. File Attachments Enrich your discussions about code by attaching files directly to code blocks. Think about how much more compelling your comments and documentation become when you... Attach a spec to guide the development of a new feature Attach a log file to help debug an issue in the code Attach a mockup to help clarify some UI work Attach a screenshot to highlight a problem When creating a code comment or issue, you can attach a file by dragging-and-dropping on the the description field, pasting from you clipboard, or by clicking the new paperclip icon. Images can even be displayed inline using markdown. Just click the pin icon to the right of the attachment, and CodeStream will insert the markdown for you. And now your teammate knows exactly what you’re looking for! You can click on files in the Attachments section to either download or open in the appropriate application. Tagging Look for the tag icon inside the codemark compose box to either select a tag or create a tag using any combination of color and text label. Tags are a great way to broadly organize and group your organization's codemarks, and the possibilities here are endless. Note that you can also filter by tag on the Filter & Search page. Related codemarks Click on the CodeStream icon in the codemark compose form to select other, related codemarks to “attach” to the current codemark. This allows you to easily establish a connection between different parts of a codebase. For example, when a change to one part of the codebase would require a change to another part, identify the dependency by creating two related codemarks. Once you’ve added the related codemarks they’ll be displayed in a “Related” section and you can click on any one to jump to that codemark and the corresponding section of the code. Managing codemarks Click on the ellipses menu for any codemark and you'll see options for managing the codemark. Share - In addition to sharing to Slack or Teams at the time you create a codemark, you can also share it anytime thereafter. Follow/Unfollow - Unfollow to stop receiving notifications for the codemark. Copy link - Get a permalink for the codemark to share it anywhere. Archive - If there’s a codemark that you don’t think is important enough to be on permanent display in a given file, but you don’t want to completely delete it, you can archive it instead. Settings in the codemarks section allow you to easily see all archived codemarks. Edit - Only the codemark's author can edit it. Delete - Only the codemark's author can delete it, but we encourage you to archive instead of delete unless you're positive the codemark won't have any future value. Inject as Inline Comment - If you'd like a specific codemark to become part of the repo use this option to have it added as an inline comment. You can select the appropriate format, and then indicate if you want to include timestamps, replies, or to have the comment wrapped at 80 characters. You can also elect to have the codemark archived once it's been added as an inline comment. Reposition codemark - In most cases, a codemark will automatically remain linked to the block of code it refers to as the file changes over time. For example, if you cut the block of code and paste it at a different location in the file, the codemark will move right along with it. There are some scenarios, however, that CodeStream isn't able to handle automatically. For example, if you pasted the block of code into a different file. In these cases, Reposition codemark allows you to select the new location of the block of code so that the codemark is displayed properly.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 348.72327,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Discuss <em>code</em> on <em>CodeStream</em>",
        "sections": "Discuss <em>code</em> on <em>CodeStream</em>",
        "body": " of inline FIXMEs. If <em>your</em> team uses Asana, Azure DevOps, Bitbucket (cloud), Clubhouse, GitHub (cloud or Enterprise), GitLab (cloud or Self-Managed), <em>Jira</em> (cloud or <em>Server</em>), Linear, Trello, or YouTrack (cloud) for tracking issues, you can create an issue on one of those services directly from <em>CodeStream</em>"
      },
      "id": "6174400564441fe8685fd746"
    }
  ],
  "/docs/codestream/troubleshooting/keychain-issues": [
    {
      "image": "https://docs.newrelic.com/static/8945e0a9c512b8638ebf8165d47aee04/69902/QS-SignUp3.png",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/codestream-user-guide/",
      "sections": [
        "CodeStream user guide",
        "Quick Start",
        "1. Install the CodeStream extension in your IDE and sign up.",
        "2. Connect your tools",
        "3. Discuss any block of code, at any time",
        "4. Get feedback on your work in progress",
        "5. Create or review a pull request",
        "Help & Feedback"
      ],
      "published_at": "2021-10-24T21:19:37Z",
      "title": "CodeStream user guide",
      "updated_at": "2021-10-23T17:07:02Z",
      "type": "docs",
      "external_id": "fa9af0118a8872fea89fda91482c44fb69913ea2",
      "document_type": "page",
      "popularity": 1,
      "body": "Quick Start Use the navigation to the left to jump straight to any topic. Otherwise, read on to get started with CodeStream. 1. Install the CodeStream extension in your IDE and sign up. Install CodeStream for VS Code, Visual Studio or JetBrains. The CodeStream pane should automatically appear in the sidebar for VS Code, or in a tool window at the right side for a JetBrains IDE or Visual Studio. Click on \"Sign Up and Create a team\" if you are the first person from your team to join CodeStream, or paste in your invitation code if you were invited to a team already on CodeStream. Learn more about how to use CodeStream. 2. Connect your tools Create and review pull requests on GitHub, GitLab or Bitbucket. Create issues on Jira, Trello, and other issue trackers. Share code discussions on Slack or Microsoft Teams. CodeStream brings the tools you use every day together in your IDE. Click on your headshot at the top of the CodeStream pane and go to the Integrations page to get all of your tools connected. 3. Discuss any block of code, at any time Whether you're trying to understand someone else's code or getting help with some code you just wrote, just select the code and ask your question. Learn more about discussing code. 4. Get feedback on your work in progress Select \"Request Feedback\" from the \"+\" menu at any time in the development cycle, whether it’s a quick look over some work in progress (even uncommitted code!) or a formal review of a completed effort. Teammates can review your changes right in their IDE, with no need to switch branches or set aside their own work. Learn more about feedback requests. 5. Create or review a pull request Look for the Pull Requests section of the CodeStream sidebar to review an open pull request. Just click on a pull request (or load one from URL) to get a complete GitHub experience right in your IDE! Note that you can create a pull request in GitHub, GitLab or Bitbucket, but support for reviewing pull requests is currently only available for GitHub (cloud or Enterprise). Learn more about pull requests. Help & Feedback Report a bug or send a suggestion in GitHub issues. Contact us directly at support@codestream.com. Follow @teamcodestream for product updates and to share feedback and questions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 818.7363,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> user guide",
        "sections": "1. <em>Install</em> the <em>CodeStream</em> extension <em>in</em> your <em>IDE</em> and <em>sign</em> up.",
        "body": "Quick Start Use the navigation to the left to jump straight to any topic. Otherwise, read on to get started with <em>CodeStream</em>. 1. Install the <em>CodeStream</em> extension in your <em>IDE</em> and <em>sign</em> up. Install <em>CodeStream</em> for VS <em>Code</em>, Visual Studio or <em>JetBrains</em>. The <em>CodeStream</em> pane should automatically appear"
      },
      "id": "61744137e7b9d2428b13c6a0"
    },
    {
      "image": "https://docs.newrelic.com/static/ec73595e0bcde8b47ae3040cc556ddd1/f96db/NotificationSettings4.png",
      "url": "https://docs.newrelic.com/docs/codestream/codestream-integrations/notifications/",
      "sections": [
        "Notifications",
        "Other Notifications"
      ],
      "published_at": "2021-10-24T23:23:37Z",
      "title": "Notifications",
      "updated_at": "2021-10-23T17:03:49Z",
      "type": "docs",
      "external_id": "0af3b7458032e1b89f8e3cc7225d7c7b0272354a",
      "document_type": "page",
      "popularity": 1,
      "body": "CodeStream will notify you about comments, issues and feedback requests that you \"follow\", and you can choose whether you want to be notified via email, desktop (for the VS Code and JetBrains extensions only), or both. Look for the Notifications option under the headshot menu at the top of the CodeStream pane. By default, you are set to automatically follow any comment, issue or feedback request that you created, where you’ve been mentioned (either in the original post or in a subsequent reply), or to which you’ve replied. You can always elect to follow/unfollow any individual comment, issue or feedback request via its ellipses menu. Email notifications are sent immediately. You can participate in the discussion by simply replying to the email. Your reply will get added to CodeStream as reply to the appropriate comment, issue or feedback request. Be sure that when you reply you are doing so from the same email address to which the notification was sent (i.e., your email address on CodeStream). Also note that you can unfollow a codemark or code review by clicking the link at the bottom of the email. If you’re using CodeStream in VS Code or a JetBrains IDE you’ll also receive desktop notifications in the IDE for comment, issue or feedback request that you follow. Clicking on the Open button will open the discussion so that you can participate. Other Notifications CodeStream also offers the following notifications that can be turned on and off via the checkboxes at the bottom of the page. Notify me about outstanding feedback requests - You'll get an email reminder about open feedback requests assigned to you that you haven't responded to in the last 24 hours. Notify me about new unreviewed commits from teammates when I pull - Any time you pull, if there are new commits from a teammate on the current branch you'll get a toast notification. Click the \"Review\" button to start reviewing your teammate's changes and provide feedback. Send me weekly emails summarizing my activity - Sent every Monday with information about you and your organization's activity for the previous week. If you've connected to GitHub or GitHub Enterprise to leverage CodeStream's pull request integration you'll also be notified when a pull request is assigned to you or you are added as a reviewer. Clicking on the Open button will open the pull request right in your IDE where you can review the changes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 790.8076,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " are doing so from the same email address to which the notification was sent (<em>i</em>.e., your email address on <em>CodeStream</em>). Also note that you can unfollow a codemark or <em>code</em> review by clicking the link at the bottom of the email. If you’re using <em>CodeStream</em> in VS <em>Code</em> or a <em>JetBrains</em> <em>IDE</em> you’ll also receive"
      },
      "id": "6174407564441f5c515fcf66"
    },
    {
      "image": "https://docs.newrelic.com/static/5c1d085b14abf961ca66b96285f0c0fa/69902/QS-Integrations.png",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/install-codestream/",
      "sections": [
        "Install CodeStream",
        "Tip",
        "Install with Instant Observability (I/O)",
        "Connect your tools",
        "Discuss any block of code, at any time",
        "Get feedback on your work in progress",
        "Create or review a pull request",
        "Help & Feedback"
      ],
      "published_at": "2021-10-24T21:19:37Z",
      "title": "Install CodeStream",
      "updated_at": "2021-10-23T17:01:57Z",
      "type": "docs",
      "external_id": "5d431c8f9a2690b64d26ac9fc173b18085153aac",
      "document_type": "page",
      "popularity": 1,
      "body": "CodeStream is a developer collaboration platform that makes it easy to discuss and review code in a more natural and contextual way. Install CodeStream Install CodeStream for Visual Studio Code, Visual Studio or JetBrains. You can also install the CodeStream extension directly via your Visual Studio Code/Visual Studio's extensions or JetBrains plugins menus. Tip Once you've installed CodeStream, if you want to connect it to New Relic, you'll need your New Relic user key. Go here to learn more about finding or creating your user key. Install with Instant Observability (I/O) You can also install CodeStream via an Instant Observability (I/O) quickstart. Connect your tools Create and review pull requests on GitHub, GitLab or Bitbucket. Create issues on Jira, Trello, and other issue trackers. Share code discussions on Slack or Microsoft Teams. CodeStream brings the tools you use every day together in your IDE. Click on your headshot at the top of the CodeStream pane and go to the Integrations page to get all of your tools connected. Discuss any block of code, at any time Whether you're trying to understand someone else's code or getting help with some code you just wrote, just select the code and ask your question. Learn more about discussing code. Get feedback on your work in progress Select \"Request Feedback\" from the \"+\" menu at any time in the development cycle, whether it’s a quick look over some work in progress (even uncommitted code!) or a formal review of a completed effort. Teammates can review your changes right in their IDE, with no need to switch branches or set aside their own work. Learn more about feedback requests. Create or review a pull request Look for the Pull Requests section of the CodeStream sidebar to review an open pull request. Just click on a pull request (or load one from URL) to get a complete GitHub experience right in your IDE! Note that you can create a pull request in GitHub, GitLab or Bitbucket, but support for reviewing pull requests is currently only available for GitHub (cloud or Enterprise). Learn more about pull requests. Help & Feedback Report a bug or send a suggestion in GitHub issues. Contact us directly at support@codestream.com. Follow @teamcodestream for product updates and to share feedback and questions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 786.1643,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>CodeStream</em>",
        "sections": "<em>Install</em> <em>CodeStream</em>",
        "body": " Studio <em>Code</em>&#x2F;Visual Studio&#x27;s extensions or <em>JetBrains</em> plugins menus. Tip Once you&#x27;ve installed <em>CodeStream</em>, if you want to connect it to New Relic, you&#x27;ll need your New Relic user key. Go here to learn more about finding or creating your user key. Install with Instant Observability (<em>I</em>&#x2F;O) You can also"
      },
      "id": "6174400564441ff1025fd832"
    }
  ],
  "/docs/codestream/troubleshooting/proxy-support": [
    {
      "sections": [
        "CodeStream licenses"
      ],
      "title": "CodeStream licenses",
      "type": "docs",
      "tags": [
        "Licenses",
        "Product or service licenses",
        "CodeStream"
      ],
      "external_id": "331f3d1cd0897f453f98bc054fda09a9ad2725c1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/codestream/codestream-licenses/",
      "published_at": "2021-10-24T17:53:35Z",
      "updated_at": "2021-10-23T17:05:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We love open-source software, and we use the following with CodeStream. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we've chosen to use. CodeStream license on GitHub CodeStream's third-party software notices on GitHub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 643.0501,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>CodeStream</em> licenses",
        "sections": "<em>CodeStream</em> licenses",
        "tags": "<em>CodeStream</em>",
        "body": "We love open-source software, and we use the following with <em>CodeStream</em>. Thank you, open-source community, for making these fine tools! Some of these are listed under multiple software licenses, and in that case we have listed the license we&#x27;ve chosen to use. <em>CodeStream</em> license on GitHub <em>CodeStream</em>&#x27;s third-party software notices on GitHub"
      },
      "id": "617440e2196a677ea62f0193"
    },
    {
      "image": "https://docs.newrelic.com/static/c1b964985880261f094399e10af5773a/1efb2/MSTCSSigninPage.png",
      "url": "https://docs.newrelic.com/docs/codestream/codestream-integrations/msteams-integration/",
      "sections": [
        "Microsoft Teams and CodeStream",
        "Connecting to Microsoft Teams",
        "Participating from Microsoft Teams",
        "Open in IDE",
        "Open on GitHub (or Bitbucket or GitLab)"
      ],
      "published_at": "2021-10-24T21:15:03Z",
      "title": "Microsoft Teams and CodeStream",
      "updated_at": "2021-10-23T17:02:53Z",
      "type": "docs",
      "external_id": "6aa93f89e0a2de618a36e82930fcb23d72eb1321",
      "document_type": "page",
      "popularity": 1,
      "body": "When you post a codemark your teammates will get notified via the activity feed, and potentially via email. Sometimes, though, you might want to share to Microsoft Teams as well. This would allow you to reach people who haven’t yet joined CodeStream, or maybe don’t spend a lot of time in their IDE. Connecting to Microsoft Teams Click here to install the CodeStream app or go to \"Apps\" in your Teams sidebar and search for CodeStream. Once installed you should see the following popup for the CodeStream app, click on the Add button. Note, do not expand it and select the options to add to team or chat. Simply click Add. This will take you to your private chat with the CodeStream bot, and you’ll see the CodeStream logo appear in the Teams sidebar. Type signin in this chat and submit. A post from the bot will appear in the stream, along with a “Sign in” button. Click the button and you’ll be taken to the web and prompted to sign into CodeStream. After signing in you’ll be provided with a token that you’ll need to copy and paste into your chat with the CodeStream bot back in MS Teams. Paste the token into the chat and submit. Go to a channel in which you’d like to share, type @, and then select Get bots from the popup. Select the CodeStream bot from the list (and search for it if you need to), and then click \"Add\". Now return to the channel and @mention the CodeStream bot with the connect command. Repeat this in any channel that you'd like to share to. Once you get the following confirmation, you’re ready to share to Teams from CodeStream. When you return to CodeStream you'll now be able to share to the channels that you just connected. Participating from Microsoft Teams When you share to Teams, not only does it notify your teammates about the codemark, but they can use it to jump directly into their IDEs to participate in the conversation on CodeStream. Open in IDE Click “Open in IDE” to view both the code, and the discussion, right inside your IDE. You’ll be first taken through a CodeStream web page where you’ll specify which IDE to open, and CodeStream will remember this selection for the next time you view a discussion from the same repository. You’ll then be taken to the appropriate source file in your IDE, scrolled to the relevant block of code, with the discussion displayed in the CodeStream pane. If you don’t happen to have the given repository open in your IDE, CodeStream will automatically open the source file for you (assuming you’ve opened that repository previously, with CodeStream installed, so that we know where to find it). Note that if you’re using a JetBrains IDE you’ll need to first install the Toolbox App so that CodeStream can deep link into the IDE. Open on GitHub (or Bitbucket or GitLab) If the code block is from a repository hosted on GitHub, Bitbucket or GitLab, this button will take you to the corresponding block of code on that hosting service.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.70697,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Microsoft Teams and <em>CodeStream</em>",
        "sections": "Microsoft Teams and <em>CodeStream</em>",
        "body": "When you post a codemark your teammates will get notified via the activity feed, and potentially via email. Sometimes, though, you might want to share to Microsoft Teams as well. This would allow you to reach people who haven’t yet joined <em>CodeStream</em>, or maybe don’t spend a lot of time in their IDE"
      },
      "id": "6174403d196a678e4e2f271d"
    },
    {
      "image": "https://docs.newrelic.com/static/30e00c292c5aa1c5d702d67be5021a45/f96db/CreateAnAccount6.png",
      "url": "https://docs.newrelic.com/docs/codestream/start-here/sign-up-codestream/",
      "sections": [
        "Sign up for CodeStream",
        "Create an account",
        "CodeStream organizations [$organizations]",
        "Create or join an organization",
        "Invite your team"
      ],
      "published_at": "2021-10-24T21:21:10Z",
      "title": "Sign up for CodeStream",
      "updated_at": "2021-10-23T17:05:39Z",
      "type": "docs",
      "external_id": "2f8eda03703523f62844512a3b8ef005b624ebc2",
      "document_type": "page",
      "popularity": 1,
      "body": "To get the most out of CodeStream's collaboration tools, create an organization, and then invite your team members to it. Create an account If you already have the CodeStream extension installed in your IDE, you can start the signup process from the CodeStream pane. You can sign up by either creating a set of CodeStream credentials (such as, email address and password), or you can sign up using GitHub, GitLab or Bitbucket (cloud versions only). Signing up via your code host saves you from having to connect later, but if the email address you're using there isn't your work email you should create CodeStream credentials instead. If you sign up via CodeStream, your next step will be to confirm your email address by entering a code sent to you via email. Note that you can paste the code into any of the boxes rather than typing each number individually. CodeStream organizations [$organizations] An “organization” on CodeStream is where you and your teammates will discuss code. Similar to a Slack workspace, all of the developers in your company should be in the same CodeStream organization. This is true even for very large organizations as CodeStream's activity feed keeps things relevant for each member by showing just activity related to the code you have open in your IDE. The discussions about code build up a knowledge base that is a company-wide resource, so the only reason to have multiple organizations on CodeStream is if you truly need separation. For example, you might have an organization for your day job and another for an open-source project you work on. Or maybe you're a consultant that is a member of different CodeStream organizations for each of your clients. Create or join an organization If you were invited to join an organization on CodeStream, all you need to do is sign up using the same email address the invitation was sent to. You'll automatically be added to that organization. If you're the first person from your company to sign up for CodeStream you can go ahead and create a new organization. Otherwise, there may be existing CodeStream organizations available for you to join based on your email domain. If you think your company is already on CodeStream, but don't see an organization to join, make sure that you've signed up with your work email address. Click the link to change your email address if necessary. If you decide to create an organization you'll be asked to give it a name, and if you signed up with your work email address, you'll also be able to indicate that anyone else on that email domain can join the organization. Invite your team Collaboration is a team sport so invite your teammates to join you on CodeStream! CodeStream will offer up some suggestions based on the commit history of the repositories you have open in your IDE. Now you're ready to start using CodeStream.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.49017,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Sign up for <em>CodeStream</em>",
        "sections": "Sign up for <em>CodeStream</em>",
        "body": "To get the most out of <em>CodeStream</em>&#x27;s collaboration tools, create an organization, and then invite your team members to it. Create an account If you already have the <em>CodeStream</em> extension installed in your IDE, you can start the signup process from the <em>CodeStream</em> pane. You can sign up by either"
      },
      "id": "617440e3196a6782592f011c"
    }
  ],
  "/docs/data-apis/convert-to-metrics/analyze-monitor-data-trends-metrics": [
    {
      "sections": [
        "Create metrics from other data types",
        "Create a metrics rule",
        "Step 1. Create NRQL query rule",
        "Tip",
        "Step 2. Create API request",
        "Example NerdGraph API request",
        "Example NerdGraph API response",
        "Step 3. Create a metrics rule with API request",
        "Query and chart your metrics",
        "Summary metric example",
        "Count metric example",
        "Distribution metric example",
        "Troubleshooting"
      ],
      "title": "Create metrics from other data types",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Convert data to metrics"
      ],
      "external_id": "49b5860f405d53d1d9a630c2e031ab4331458005",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/convert-to-metrics/create-metrics-other-data-types/",
      "published_at": "2021-10-24T21:24:28Z",
      "updated_at": "2021-10-23T17:27:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use New Relic's metrics API service to define rules for creating metrics from your other types of data, such as events, logs, or spans. Recommendation: Before you begin, review our requirements and tips for creating rules. Create a metrics rule To create a rule for creating metrics from events, logs, or spans: Construct the metrics rule using NRQL. Construct a NerdGraph (GraphQL format) API request that contains your NRQL rule. Create the metric by making the API request. Once a metric is created, you can query and chart it using NRQL. Step 1. Create NRQL query rule The most important part of creating a metrics rule is constructing the NRQL query that defines the metric for your data from events, logs, or spans. You can create up to 10 metrics with a single NRQL query by following this procedure: Using New Relic's NRQL interface, construct a query for the metric you want to create. For example: FROM ProcessSample SELECT average(ioTotalReadBytes) WHERE nr.entityType = 'HOST' Copy Edit the query to use one of the three available metric types: summary: Use if the query's function is min, max, sum, count, or average. uniqueCount: Use if the query's function is uniqueCount. distribution: Use if the query's function is percentile or histogram. This example query uses average, so use summary: FROM ProcessSample SELECT summary (ioTotalReadBytes) WHERE nr.entityType = 'HOST' Copy This example query uses count on a non-numeric field: FROM ProcessSample SELECT count(hostname) WHERE hostname LIKE '%prod%' Copy For summary on a non-numeric field use summary(1): FROM ProcessSample SELECT summary(1) WHERE hostname LIKE '%prod%' Copy Tip For more detailed information on using these metric types in rules, see Creating metric rules: requirements and tips. Decide on the attributes you want to attach to the metric, following the limits on the cardinality of unique metric-name/attribute-value combinations. Recommendation: Run a separate query to ensure this count isn't over 50,000 for a 24-hour window. For example: FROM ProcessSample SELECT uniqueCount(awsRegion, awsAvailabilityZone, commandName) WHERE nr.entityType = 'HOST' SINCE 1 DAY AGO Copy To be able to aggregate and filter your metrics, add the attributes you want to attach to the metric using the FACET clause. For example: FROM ProcessSample SELECT summary(ioTotalReadBytes) WHERE nr.entityType = 'HOST' FACET awsRegion, awsAvailabilityZone, commandName Copy Set the name of the metric using the AS function. For example: FROM ProcessSample SELECT summary(ioTotalReadBytes) AS 'io.totalread.bytes' WHERE nr.entityType = 'HOST' FACET awsRegion, awsAvailabilityZone, commandName Copy Once your NRQL rule is complete, use it to create the API request. Step 2. Create API request After you build the NRQL rule to convert data from events, logs, or spans to metrics, continue with building the API request. You can use our NerdGraph API tool to explore the data structure and to construct and make your request. To check that the rule was created correctly, you can run a query to return that rule using its ID. For tips on querying the metrics you've created, see Query and chart your metrics. Example NerdGraph API request The following example NerdGraph API request uses the same NRQL rule from step 1. The IO Total Read Bytes Rule creates a metric named io.totalread.bytes. (The rule name can have spaces, which differs from the metric naming rules.) mutation { eventsToMetricsCreateRule(rules: { name: \"io.totalread.bytes for computeSample entities\", description:\"Created by Zach on March 27, 2019. Used by team Network.\", nrql:\"FROM ProcessSample SELECT summary(ioTotalReadBytes) AS 'io.totalread.bytes' WHERE nr.entityType = 'ComputeSample' FACET awsRegion, awsAvailabilityZone, commandName\", accountId: 123456 }) { successes { id name nrql enabled } failures { submitted { name nrql accountId } errors { reason description } } } } Copy In this request: Request elements Description mutation One of the basic API operation types. eventsToMetricsCreateRule The method being called to create a rule. rules Takes four parameters: name: The name of the rule. description: Optional. The description of the rule. We recommend you include information about who created the metric data and who will be using the data. accountId: The New Relic account ID where the events, logs, or spans live and the metrics will be created. nrql: The NRQL query that creates the rule. For more on this, see Create NRQL query. successes and submitted blocks Here you define the data returned by a successful or failed response. Available parameters for these blocks include: id (ruleId for submitted) name description nrql enabled (enabled/disabled status) accountId ruleId and accountId If a failure occurs, then the submitted ruleId and accountId will be returned along with the error reason and error description. Example NerdGraph API response Here's an example of a returned response: { \"data\": { \"eventsToMetricsCreateRule\": { \"failures\": [], \"successes\": [ { \"enabled\": true, \"id\": \"46\", \"name\": \"io.totalread.bytes for computeSample entities\", \"nrql\": \"FROM ProcessSample SELECT summary(ioTotalReadBytes) AS 'io.totalread.bytes' WHERE nr.entityType = 'ComputeSample' FACET awsRegion, awsAvailabilityZone, commandName\" } ] } } } Copy Step 3. Create a metrics rule with API request When your API request is ready, you can use the NerdGraph API to make the request, which will create the metrics. Query and chart your metrics After you create a metrics rule to convert data for your events, logs, or spans, you can view the new metric data in the New Relic UI. To view your data: Go to New Relic's NRQL query interface. Run the following query to see the name of all your metrics: SELECT uniques(metricName) FROM Metric Copy Pick the metric of interest, then run the following query to see the available attributes: SELECT * FROM Metric where metricName = 'yourMetric' Copy If you don't see expected data, follow the troubleshooting procedures. The available NRQL aggregator functions depend on the metric type you created. Here are some examples. Summary metric example If you created a summary metric type, you can use the count, sum, max, min, and average aggregator functions, as shown in the following query: SELECT count(appStartResponseTime), sum(appStartResponseTime), max(appStartResponseTime), min(appStartResponseTime), average(appStartResponseTime) FROM Metric Copy Count metric example If you created a uniqueCount metric type, you can only use the uniqueCount function, as shown in the following query: SELECT uniqueCount(playbackErrorStreamUniqueCount) * 100 / uniqueCount(streamUniqueCount) AS '% of Streams Impacted' FROM Metric Copy Distribution metric example If you created a distribution metric type, use the percentile or histogram functions, as shown in the following queries: SELECT percentile(service.responseTime, 95) FROM Metric Copy OR SELECT histogram(service.responseTime, 10, 20) FROM Metric Copy Troubleshooting If your NerdGraph call is not constructed correctly, you may receive a message like this: Cannot parse the unexpected character \"\\u201C” Copy Verify the quotes in the NerdGraph call are not smart quotes (curly quotes). Our NerdGraph API only accepts straight quotes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 389.39896,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create <em>metrics</em> from other <em>data</em> types",
        "sections": "Create <em>metrics</em> from other <em>data</em> types",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": " the NerdGraph API to make the request, which will create the <em>metrics</em>. Query and chart your <em>metrics</em> After you create a <em>metrics</em> rule to <em>convert</em> <em>data</em> for your events, logs, or spans, you can view the new <em>metric</em> <em>data</em> in the New Relic UI. To view your <em>data</em>: Go to New Relic&#x27;s NRQL query interface. Run the following"
      },
      "id": "603ebfc8196a67cab0a83d96"
    },
    {
      "sections": [
        "Creating metric rules: requirements and tips",
        "Metric aggregation",
        "Rule-creation limits",
        "Cardinality limits",
        "Multiple metrics from one rule",
        "Metric naming"
      ],
      "title": "Creating metric rules: requirements and tips",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Convert data to metrics"
      ],
      "external_id": "3724b0897ae63f6a25c4cf5eeaf5d2b49be15283",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/convert-to-metrics/creating-metric-rules-requirements-tips/",
      "published_at": "2021-10-24T19:35:32Z",
      "updated_at": "2021-10-23T17:28:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are some limits, requirements, and recommendations when you create metrics from events, logs, or spans. Metric aggregation Your NRQL query must use one of the following summary, uniqueCount, or distribution functions to aggregate metrics: Function Comments summary Creates a summary metric data point for each time window (currently 1 minute). Use this if your NRQL query uses aggregator functions supported by the summary metric type, such as average, sum, min, or max. Example rule-creation query: SELECT summary(duration) AS 'service.responseTime' FROM Transaction WHERE appName = 'Data Points Staging' FACET name, appName, host Copy uniqueCount Creates a uniqueCount metric data point for each 1-minute time window. Use this if your NRQL query uses the uniqueCount aggregator type. Example rule-creation query: FROM Transaction SELECT uniqueCount(request.headers.userAgent) AS 'server.request.header.userAgent.uniqueCount' WHERE appName = 'Browser Monitoring Router' FACET httpResponseCode, name, appName, host Copy distribution Creates a distribution metric data point for each 1-minute time window. Use this if your NRQL query uses aggregator functions such as percentile, histogram, min, max, average, sum, or count. Use only the attribute of interest as the argument, and discard the rest of the arguments from percentile or histogram. The generated metric supports any argument on percentile or histogram. Example of creating a distribution rule: SELECT distribution(duration) AS 'service.responseTime' FROM Transaction WHERE appName = 'Data Points Staging' FACET name, appName, host Copy Simple count: summary(1) and sum If you want a metric that's a simple count of the events, logs, or spans that match a particular WHERE clause, use the summary(1) metric. This metric type counts the number of specified events, logs, or spans per minute. When querying the created metric, use the sum method to see the result. Example: If you want to create a metric named foo.count that counts the transactions named foo, the NRQL would look like this: FROM Transaction SELECT summary(1) AS 'foo.count' WHERE name = 'foo' Copy Then, you would query it like this: FROM Metric SELECT sum(foo.count) SINCE 30 minutes ago Copy For more information about metrics, see our documentation about metric types. Rule-creation limits These limits affect metric rules creation: Limits Comments Account limits An account can have a maximum of 1,000 metric-creation rules. Metric rule limits A rule can: Create a maximum of 10 metrics. Use only one type of data (events, logs, or spans). Select a maximum of 20 attributes (facets) to include on a metric. Time window limits 50K limit on unique metric-name/attribute-value combinations for a single metric in a 24-hour time window. If this limit is exceeded, the rule is disabled and an NrIntegrationError event is created in that account that includes: The rule details A message about having too many facets A newRelicFeature attribute value of eventToMetric Limits on metric name and attribute value combinations The limit on total unique metric name/attribute value combinations in a 24-hour time window for an account is: Equal to three times the purchased monthly average data points per minute Up to a maximum of 10M Cardinality limits Rule-creation limits include limits on the number of unique combinations of metric name and attribute values. This limit exists because a large number of attributes and/or attribute values can lead to an exponential increase in the size of data reported. Example metric creation rule that attaches five attributes: FROM ProcessSample SELECT summary(ioTotalReadBytes) WHERE entityType = 'ComputeSample' FACET awsRegion, awsAvailabilityZone, commandName, entityName, processId Copy If each of the five attributes reported ten unique values within a one-minute time window, the number of unique metric-name/attribute combinations would theoretically have a maximum of 10x10x10x10x10, or 100,000. Multiple attributes with multiple unique values can lead to a large number of unique metric entries. In practice, this isn't usually the case, because attributes are often related. For example, if one attribute is hostname and another is awsRegion, when you see hostname A, it will always be in AWS region B; you'd never see hostname A and other AWS region values. This is why it's important, during the NRQL creation process, to use the uniqueCount function to verify how many unique metric-name/attribute-value combinations your NRQL query is generating. Multiple metrics from one rule A rule can create up to ten metrics. There are no functional differences between metrics created one at a time and those created with a single rule. Reasons for creating multiple metrics with a single rule: Less likely to reach rules-per-account limit. Easier to add the same attributes to multiple metrics. Example creating multiple metrics with a single rule: FROM Transaction SELECT uniqueCount(request.headers.userAgent) AS 'server.request.header.userAgent.uniqueCount', summary(duration) AS 'server.duration', summary(totalTime) AS 'server.totalTime' WHERE appName = 'Browser Monitoring Router' FACET httpResponseCode, name, appName, host Copy Metric naming A metric is given a name with the AS clause, as part of the NRQL rule-creation process. In the following NRQL example, the name of the metric is io.totalread.bytes: FROM ProcessSample SELECT summary(ioTotalReadBytes) AS 'io.totalread.bytes' WHERE entityType = 'ComputeSample' FACET awsRegion, awsAvailabilityZone, commandName Copy If there is no name assigned with the AS clause, the metric name is the name of the queried attribute. In this example, if no name was assigned, the metric name would be ioTotalReadBytes. Metric names Requirements and recommendations Requirements Requirements for naming a metric: Less than or equal to 255 (UTF-16) 16-bit code units. One way to ensure you are under the limit is to keep each string under 127 of whatever is easiest to count. No spaces. Start with a letter. Examples of strong metric names: rubyvm.memory.heap_used redis.container.cpu.percent memcached.process_virtual_memory.bytes Length and structure Decide on a name and structure that makes it easy for others to find, understand, and use this metric. We recommend keeping your metric name under 40 characters for ideal readability. Longer names can get cut off or overlap with other names. Your metric naming scheme will depend on your business logic. You may want to use namespaces to prefix your metric name, or your names may need to be more general. Components within the name If you want to create components within your metric name (like the source of metrics and the thing you’re measuring), we recommend going from broad to specific (left to right): Use a dot to separate those components in order to be consistent with our New Relic metric names. Then, use an underscore to separate words within the dots. Example: application.page_view.duration Copy Attributes Avoid putting attributes in your metric name. Attributes are qualities of your metric that you can use to filter or facet your data, like cluster or availability zone. Example: If you included availability zone in your metric name, it would mean, for that metric, you wouldn’t be able to see results across all availability zones. Changing metric names If you change a metric name, historical data will not be updated to that new name. To query or chart that historical data, you will need to specify the older metric name.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 313.1604,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Creating <em>metric</em> rules: requirements <em>and</em> tips",
        "sections": "Creating <em>metric</em> rules: requirements <em>and</em> tips",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": "Here are some limits, requirements, and recommendations when you create <em>metrics</em> from events, logs, or spans. <em>Metric</em> aggregation Your NRQL query must use one of the following summary, uniqueCount, or distribution functions to aggregate <em>metrics</em>: Function Comments summary Creates a summary <em>metric</em> <em>data</em>"
      },
      "id": "603e9b8164441fbcac4e88a6"
    },
    {
      "sections": [
        "Get data into New Relic",
        "New Relic-built agents and integrations",
        "Report custom data"
      ],
      "title": "Get data into New Relic",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Get started"
      ],
      "external_id": "016a25d46dedc5da1455b29d8557ce68a4345756",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/get-started/introduction-new-relic-data-ingest-apis-sdks/",
      "published_at": "2021-10-24T19:36:34Z",
      "updated_at": "2021-10-23T17:32:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are many ways to get data into your New Relic account. Any New Relic user can use any of our data ingest methods to report data to our platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure monitoring, or any of our wide array of integrations, by default you'll receive data from your monitored applications, hosts, services, or other entities. Some options for getting started: Log into one.newrelic.com and click Add more data to get some guidance on setting up New Relic solutions. To browse our solutions, see New Relic integrations. Report custom data If you need to report data that our agents and integrations don't provide, we have tools that will allow you to bring in any type of data you need. To learn more, see Intro to custom data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.02907,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get <em>data</em> into New Relic",
        "sections": "Get <em>data</em> into New Relic",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": "There are many ways to get <em>data</em> into your New Relic account. Any New Relic user can use any of our <em>data</em> <em>ingest</em> methods to report <em>data</em> to our platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure"
      },
      "id": "6174474328ccbcdff4c6b77e"
    }
  ],
  "/docs/data-apis/convert-to-metrics/create-metrics-other-data-types": [
    {
      "sections": [
        "Analyze and monitor data trends with metrics",
        "Why create metrics from other data types?",
        "Available operations",
        "Mutations",
        "Create a rule",
        "Delete a rule",
        "Important",
        "Enable or disable a rule",
        "Queries",
        "List all rules for a New Relic account",
        "List rule by rule ID",
        "Use the NerdGraph GraphiQL API tool"
      ],
      "title": "Analyze and monitor data trends with metrics",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Convert data to metrics"
      ],
      "external_id": "06073bcfec2679ac1bc402dfe305426bbd9e2182",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/convert-to-metrics/analyze-monitor-data-trends-metrics/",
      "published_at": "2021-10-24T23:24:43Z",
      "updated_at": "2021-10-23T17:28:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can generate metric-type data from other types of data in New Relic, including events, logs, and spans. Metrics are aggregates of your data and are optimal for analyzing and monitoring trends over long time periods. This document explains: Reasons to use this feature Available operations How to use our NerdGraph API tool to perform operations Why create metrics from other data types? Using metrics allows for more efficient data storage. This in turn allows you to query your data and build charts more easily. The difference between metrics and other types of data in New Relic is based on time. For more information, see Understand data types. Events, logs, spans: These types of data represent a single record at a specific moment in time. For example, you may have an event for every request to the system. This data is ideal for in-depth troubleshooting and analysis. Metrics: These provide an aggregated view of your events, logs, or spans. Metrics are better for showing trends over longer time ranges. For example, you can aggregate the total number of requests per service to one metric and then examine this information month over month. Why use metrics? Comments Flexibility Metrics are dimensional. You can choose what metadata (like host name or app name) is attached to them. Common metric measurements, like average, sum, minimum, and maximum, are already calculated. Data aggregation and retention The data has already been pre-aggregated into longer-period time buckets. Data retention is 13 months. Query capabilities You can query using the Metric data type. When you create metrics, this does not delete your events or other types of data. However, metrics are better for longer-range querying and charting. To get started converting your data to metrics, create a rule. Available operations To show, create, and delete rules for generating metrics from events, logs, or spans, use NerdGraph, our GraphQL-format API. Before performing any operation, we recommend reading Intro to NerdGraph and exploring your data with the GraphiQL API tool. These operations fall under two basic request types: Mutations, which are operations that make changes to existing rules or settings (for example, creating a new metrics rule). Queries, for fetching existing data (for example, fetching existing metrics rules). All operations are role-based in NerdGraph as the currently logged-in New Relic user. Mutations Mutation operations for events to metrics, logs to metrics, or spans to metrics include: Create a rule See Create metrics. Delete a rule Important This operation modifies production settings, so we recommend thoroughly reviewing your changes before you run the operation. To delete a rule, you need the rule ID and the New Relic account ID. Example request: mutation { eventsToMetricsDeleteRule(deletes: {ruleId: \"12\", accountId: 123456}) { successes { id name nrql } failures { errors { description reason } submitted { ruleId accountId } } } } Copy In this request: Element Description mutation One of the basic API operation types. eventsToMetricsDeleteRule The method being called to delete a rule. deletes This takes two parameters: ruleId: The ID of the rule for events to metrics, logs to metrics, or spans to metrics. accountId: The New Relic account ID. successes and submitted blocks Here you define the data returned by a success or failure. Available parameters for these blocks: id (or ruleId for submitted) name description nrql enabled accountId Example response for the request: { \"data\": { \"eventsToMetricsDeleteRule\": { \"failures\": [], \"successes\": [ { \"id\": \"12\", \"name\": \"Test Rule\", \"nrql\": \"select summary(duration) as 'server.responseTime' from Transaction where appName = 'Data Points Staging' facet name, appName, host\" } ] } } } Copy Enable or disable a rule Important This operation modifies production settings, so we recommend thoroughly reviewing your changes before you run the operation. To enable or disable an existing rule for events to metrics, logs to metrics, or spans to metrics, use the same eventsToMetricsUpdateRule operation. The only difference is whether enabled is set to true or false. Example request to enable an existing metrics rule: mutation { eventsToMetricsUpdateRule(updates: {ruleId: \"12\", accountId: 123456, enabled: true}) { successes { id name nrql } failures { errors { description reason } submitted { ruleId accountId } } } } Copy In this request: Element Description mutation One of the basic API operation types. eventsToMetricsUpdateRule The method being called to update an existing rule and either enable it or disable it. updates This takes three required parameters: ruleId: The ID of the rule for events to metrics, logs to metrics, or spans to metrics. accountId: The New Relic account ID. enabled: To enable a disabled rule, set this to true. To disable a rule, set this to false. successes and submitted blocks Here you define the data returned by a success or failure. Available parameters for these blocks: id (or ruleId for submitted) name description nrql enabled accountId Queries Query operations include: List all rules for a New Relic account You can list all rules in a New Relic account or return a specific rule. Example listing all rules for account 123456: query { actor { account(id:123456) { eventsToMetrics{ allRules{ rules{ id name enabled nrql description } } } } } } Copy In this request: Element Description query One of the basic API operation types. Used to query but not make changes. actor This specifies the current New Relic user. account(id: 123456) Specify the ID for the New Relic account where to retrieve data. eventsToMetrics Scope the data only for events-to-metrics, logs-to-metrics, or spans-to-metrics rules. allRules Returns all rules for that account. rules In the rules block, you can define what data you want returned. Available fields include: id name description nrql accountId enabled Example response: { \"data\": { \"actor\": { \"account\": { \"eventsToMetrics\": { \"allRules\": { \"rules\": [ { \"description\": \"Metric for total time\", \"enabled\": true, \"id\": \"1\", \"name\": \"Total Time Tx\", \"nrql\": \"select summary(totalTime) as 'server.totalTime' from Transaction where appName = 'Data Points Staging' facet name, appName, host\" }, { \"description\": \"Metric for duration\", \"enabled\": true, \"id\": \"2\", \"name\": \"Duration Rule\", \"nrql\": \"select summary(duration) as 'server.responseTime' from Transaction where appName = 'Data Points Staging' facet name, appName, host\" } ] } } } } } } Copy List rule by rule ID If you know the exact ID for a rule, then you can query for a specific rule. For example, you may have just created a rule and now you want to list its contents so you can review it. Example listing rule 36 for New Relic account 123456: query { actor { account(id: 123456) { eventsToMetrics { rulesById(ruleIds: \"36\") { rules { id name enabled nrql description accountId } } } } } } Copy For more details about the elements in this query, see List all rules. Example response: { \"data\": { \"actor\": { \"account\": { \"eventsToMetrics\": { \"rulesById\": { \"rules\": [ { \"accountId\": 123456, \"description\": \"Metric for total time\", \"enabled\": true, \"id\": \"36\", \"name\": \"Total Time Tx\", \"nrql\": \"select summary(totalTime) as 'server.totalTime' from Transaction where appName = 'Data Points Staging' facet name, appName, host\" } ] } } } } } } Copy Use the NerdGraph GraphiQL API tool You can use our GraphiQL tool to explore the data structure. You can also use it to build and run the operations to convert events, logs, and spans to metrics. To use this tool: Create the metrics operation's request with the required parameters. Go to api.newrelic.com/graphiql, and paste your query into the box. To execute the operation, press Play. Or, to get the cURL format, select Copy as cURL.) Validate the response in the response box. Optional: To verify that your rule-creation operation was performed successfully, run a list query for that rule ID.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 389.4101,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Analyze <em>and</em> monitor <em>data</em> trends with <em>metrics</em>",
        "sections": "Analyze <em>and</em> monitor <em>data</em> trends with <em>metrics</em>",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": "You can generate <em>metric</em>-type <em>data</em> from other types of <em>data</em> in New Relic, including events, logs, and spans. <em>Metrics</em> are aggregates of your <em>data</em> and are optimal for analyzing and monitoring trends over long time periods. This document explains: Reasons to use this feature Available operations How"
      },
      "id": "603eb239e7b9d2b99d2a07bb"
    },
    {
      "sections": [
        "Creating metric rules: requirements and tips",
        "Metric aggregation",
        "Rule-creation limits",
        "Cardinality limits",
        "Multiple metrics from one rule",
        "Metric naming"
      ],
      "title": "Creating metric rules: requirements and tips",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Convert data to metrics"
      ],
      "external_id": "3724b0897ae63f6a25c4cf5eeaf5d2b49be15283",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/convert-to-metrics/creating-metric-rules-requirements-tips/",
      "published_at": "2021-10-24T19:35:32Z",
      "updated_at": "2021-10-23T17:28:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are some limits, requirements, and recommendations when you create metrics from events, logs, or spans. Metric aggregation Your NRQL query must use one of the following summary, uniqueCount, or distribution functions to aggregate metrics: Function Comments summary Creates a summary metric data point for each time window (currently 1 minute). Use this if your NRQL query uses aggregator functions supported by the summary metric type, such as average, sum, min, or max. Example rule-creation query: SELECT summary(duration) AS 'service.responseTime' FROM Transaction WHERE appName = 'Data Points Staging' FACET name, appName, host Copy uniqueCount Creates a uniqueCount metric data point for each 1-minute time window. Use this if your NRQL query uses the uniqueCount aggregator type. Example rule-creation query: FROM Transaction SELECT uniqueCount(request.headers.userAgent) AS 'server.request.header.userAgent.uniqueCount' WHERE appName = 'Browser Monitoring Router' FACET httpResponseCode, name, appName, host Copy distribution Creates a distribution metric data point for each 1-minute time window. Use this if your NRQL query uses aggregator functions such as percentile, histogram, min, max, average, sum, or count. Use only the attribute of interest as the argument, and discard the rest of the arguments from percentile or histogram. The generated metric supports any argument on percentile or histogram. Example of creating a distribution rule: SELECT distribution(duration) AS 'service.responseTime' FROM Transaction WHERE appName = 'Data Points Staging' FACET name, appName, host Copy Simple count: summary(1) and sum If you want a metric that's a simple count of the events, logs, or spans that match a particular WHERE clause, use the summary(1) metric. This metric type counts the number of specified events, logs, or spans per minute. When querying the created metric, use the sum method to see the result. Example: If you want to create a metric named foo.count that counts the transactions named foo, the NRQL would look like this: FROM Transaction SELECT summary(1) AS 'foo.count' WHERE name = 'foo' Copy Then, you would query it like this: FROM Metric SELECT sum(foo.count) SINCE 30 minutes ago Copy For more information about metrics, see our documentation about metric types. Rule-creation limits These limits affect metric rules creation: Limits Comments Account limits An account can have a maximum of 1,000 metric-creation rules. Metric rule limits A rule can: Create a maximum of 10 metrics. Use only one type of data (events, logs, or spans). Select a maximum of 20 attributes (facets) to include on a metric. Time window limits 50K limit on unique metric-name/attribute-value combinations for a single metric in a 24-hour time window. If this limit is exceeded, the rule is disabled and an NrIntegrationError event is created in that account that includes: The rule details A message about having too many facets A newRelicFeature attribute value of eventToMetric Limits on metric name and attribute value combinations The limit on total unique metric name/attribute value combinations in a 24-hour time window for an account is: Equal to three times the purchased monthly average data points per minute Up to a maximum of 10M Cardinality limits Rule-creation limits include limits on the number of unique combinations of metric name and attribute values. This limit exists because a large number of attributes and/or attribute values can lead to an exponential increase in the size of data reported. Example metric creation rule that attaches five attributes: FROM ProcessSample SELECT summary(ioTotalReadBytes) WHERE entityType = 'ComputeSample' FACET awsRegion, awsAvailabilityZone, commandName, entityName, processId Copy If each of the five attributes reported ten unique values within a one-minute time window, the number of unique metric-name/attribute combinations would theoretically have a maximum of 10x10x10x10x10, or 100,000. Multiple attributes with multiple unique values can lead to a large number of unique metric entries. In practice, this isn't usually the case, because attributes are often related. For example, if one attribute is hostname and another is awsRegion, when you see hostname A, it will always be in AWS region B; you'd never see hostname A and other AWS region values. This is why it's important, during the NRQL creation process, to use the uniqueCount function to verify how many unique metric-name/attribute-value combinations your NRQL query is generating. Multiple metrics from one rule A rule can create up to ten metrics. There are no functional differences between metrics created one at a time and those created with a single rule. Reasons for creating multiple metrics with a single rule: Less likely to reach rules-per-account limit. Easier to add the same attributes to multiple metrics. Example creating multiple metrics with a single rule: FROM Transaction SELECT uniqueCount(request.headers.userAgent) AS 'server.request.header.userAgent.uniqueCount', summary(duration) AS 'server.duration', summary(totalTime) AS 'server.totalTime' WHERE appName = 'Browser Monitoring Router' FACET httpResponseCode, name, appName, host Copy Metric naming A metric is given a name with the AS clause, as part of the NRQL rule-creation process. In the following NRQL example, the name of the metric is io.totalread.bytes: FROM ProcessSample SELECT summary(ioTotalReadBytes) AS 'io.totalread.bytes' WHERE entityType = 'ComputeSample' FACET awsRegion, awsAvailabilityZone, commandName Copy If there is no name assigned with the AS clause, the metric name is the name of the queried attribute. In this example, if no name was assigned, the metric name would be ioTotalReadBytes. Metric names Requirements and recommendations Requirements Requirements for naming a metric: Less than or equal to 255 (UTF-16) 16-bit code units. One way to ensure you are under the limit is to keep each string under 127 of whatever is easiest to count. No spaces. Start with a letter. Examples of strong metric names: rubyvm.memory.heap_used redis.container.cpu.percent memcached.process_virtual_memory.bytes Length and structure Decide on a name and structure that makes it easy for others to find, understand, and use this metric. We recommend keeping your metric name under 40 characters for ideal readability. Longer names can get cut off or overlap with other names. Your metric naming scheme will depend on your business logic. You may want to use namespaces to prefix your metric name, or your names may need to be more general. Components within the name If you want to create components within your metric name (like the source of metrics and the thing you’re measuring), we recommend going from broad to specific (left to right): Use a dot to separate those components in order to be consistent with our New Relic metric names. Then, use an underscore to separate words within the dots. Example: application.page_view.duration Copy Attributes Avoid putting attributes in your metric name. Attributes are qualities of your metric that you can use to filter or facet your data, like cluster or availability zone. Example: If you included availability zone in your metric name, it would mean, for that metric, you wouldn’t be able to see results across all availability zones. Changing metric names If you change a metric name, historical data will not be updated to that new name. To query or chart that historical data, you will need to specify the older metric name.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 313.16028,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Creating <em>metric</em> rules: requirements <em>and</em> tips",
        "sections": "Creating <em>metric</em> rules: requirements <em>and</em> tips",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": "Here are some limits, requirements, and recommendations when you create <em>metrics</em> from events, logs, or spans. <em>Metric</em> aggregation Your NRQL query must use one of the following summary, uniqueCount, or distribution functions to aggregate <em>metrics</em>: Function Comments summary Creates a summary <em>metric</em> <em>data</em>"
      },
      "id": "603e9b8164441fbcac4e88a6"
    },
    {
      "sections": [
        "Get data into New Relic",
        "New Relic-built agents and integrations",
        "Report custom data"
      ],
      "title": "Get data into New Relic",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Get started"
      ],
      "external_id": "016a25d46dedc5da1455b29d8557ce68a4345756",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/get-started/introduction-new-relic-data-ingest-apis-sdks/",
      "published_at": "2021-10-24T19:36:34Z",
      "updated_at": "2021-10-23T17:32:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are many ways to get data into your New Relic account. Any New Relic user can use any of our data ingest methods to report data to our platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure monitoring, or any of our wide array of integrations, by default you'll receive data from your monitored applications, hosts, services, or other entities. Some options for getting started: Log into one.newrelic.com and click Add more data to get some guidance on setting up New Relic solutions. To browse our solutions, see New Relic integrations. Report custom data If you need to report data that our agents and integrations don't provide, we have tools that will allow you to bring in any type of data you need. To learn more, see Intro to custom data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.02896,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get <em>data</em> into New Relic",
        "sections": "Get <em>data</em> into New Relic",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": "There are many ways to get <em>data</em> into your New Relic account. Any New Relic user can use any of our <em>data</em> <em>ingest</em> methods to report <em>data</em> to our platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure"
      },
      "id": "6174474328ccbcdff4c6b77e"
    }
  ],
  "/docs/data-apis/convert-to-metrics/creating-metric-rules-requirements-tips": [
    {
      "sections": [
        "Analyze and monitor data trends with metrics",
        "Why create metrics from other data types?",
        "Available operations",
        "Mutations",
        "Create a rule",
        "Delete a rule",
        "Important",
        "Enable or disable a rule",
        "Queries",
        "List all rules for a New Relic account",
        "List rule by rule ID",
        "Use the NerdGraph GraphiQL API tool"
      ],
      "title": "Analyze and monitor data trends with metrics",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Convert data to metrics"
      ],
      "external_id": "06073bcfec2679ac1bc402dfe305426bbd9e2182",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/convert-to-metrics/analyze-monitor-data-trends-metrics/",
      "published_at": "2021-10-24T23:24:43Z",
      "updated_at": "2021-10-23T17:28:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can generate metric-type data from other types of data in New Relic, including events, logs, and spans. Metrics are aggregates of your data and are optimal for analyzing and monitoring trends over long time periods. This document explains: Reasons to use this feature Available operations How to use our NerdGraph API tool to perform operations Why create metrics from other data types? Using metrics allows for more efficient data storage. This in turn allows you to query your data and build charts more easily. The difference between metrics and other types of data in New Relic is based on time. For more information, see Understand data types. Events, logs, spans: These types of data represent a single record at a specific moment in time. For example, you may have an event for every request to the system. This data is ideal for in-depth troubleshooting and analysis. Metrics: These provide an aggregated view of your events, logs, or spans. Metrics are better for showing trends over longer time ranges. For example, you can aggregate the total number of requests per service to one metric and then examine this information month over month. Why use metrics? Comments Flexibility Metrics are dimensional. You can choose what metadata (like host name or app name) is attached to them. Common metric measurements, like average, sum, minimum, and maximum, are already calculated. Data aggregation and retention The data has already been pre-aggregated into longer-period time buckets. Data retention is 13 months. Query capabilities You can query using the Metric data type. When you create metrics, this does not delete your events or other types of data. However, metrics are better for longer-range querying and charting. To get started converting your data to metrics, create a rule. Available operations To show, create, and delete rules for generating metrics from events, logs, or spans, use NerdGraph, our GraphQL-format API. Before performing any operation, we recommend reading Intro to NerdGraph and exploring your data with the GraphiQL API tool. These operations fall under two basic request types: Mutations, which are operations that make changes to existing rules or settings (for example, creating a new metrics rule). Queries, for fetching existing data (for example, fetching existing metrics rules). All operations are role-based in NerdGraph as the currently logged-in New Relic user. Mutations Mutation operations for events to metrics, logs to metrics, or spans to metrics include: Create a rule See Create metrics. Delete a rule Important This operation modifies production settings, so we recommend thoroughly reviewing your changes before you run the operation. To delete a rule, you need the rule ID and the New Relic account ID. Example request: mutation { eventsToMetricsDeleteRule(deletes: {ruleId: \"12\", accountId: 123456}) { successes { id name nrql } failures { errors { description reason } submitted { ruleId accountId } } } } Copy In this request: Element Description mutation One of the basic API operation types. eventsToMetricsDeleteRule The method being called to delete a rule. deletes This takes two parameters: ruleId: The ID of the rule for events to metrics, logs to metrics, or spans to metrics. accountId: The New Relic account ID. successes and submitted blocks Here you define the data returned by a success or failure. Available parameters for these blocks: id (or ruleId for submitted) name description nrql enabled accountId Example response for the request: { \"data\": { \"eventsToMetricsDeleteRule\": { \"failures\": [], \"successes\": [ { \"id\": \"12\", \"name\": \"Test Rule\", \"nrql\": \"select summary(duration) as 'server.responseTime' from Transaction where appName = 'Data Points Staging' facet name, appName, host\" } ] } } } Copy Enable or disable a rule Important This operation modifies production settings, so we recommend thoroughly reviewing your changes before you run the operation. To enable or disable an existing rule for events to metrics, logs to metrics, or spans to metrics, use the same eventsToMetricsUpdateRule operation. The only difference is whether enabled is set to true or false. Example request to enable an existing metrics rule: mutation { eventsToMetricsUpdateRule(updates: {ruleId: \"12\", accountId: 123456, enabled: true}) { successes { id name nrql } failures { errors { description reason } submitted { ruleId accountId } } } } Copy In this request: Element Description mutation One of the basic API operation types. eventsToMetricsUpdateRule The method being called to update an existing rule and either enable it or disable it. updates This takes three required parameters: ruleId: The ID of the rule for events to metrics, logs to metrics, or spans to metrics. accountId: The New Relic account ID. enabled: To enable a disabled rule, set this to true. To disable a rule, set this to false. successes and submitted blocks Here you define the data returned by a success or failure. Available parameters for these blocks: id (or ruleId for submitted) name description nrql enabled accountId Queries Query operations include: List all rules for a New Relic account You can list all rules in a New Relic account or return a specific rule. Example listing all rules for account 123456: query { actor { account(id:123456) { eventsToMetrics{ allRules{ rules{ id name enabled nrql description } } } } } } Copy In this request: Element Description query One of the basic API operation types. Used to query but not make changes. actor This specifies the current New Relic user. account(id: 123456) Specify the ID for the New Relic account where to retrieve data. eventsToMetrics Scope the data only for events-to-metrics, logs-to-metrics, or spans-to-metrics rules. allRules Returns all rules for that account. rules In the rules block, you can define what data you want returned. Available fields include: id name description nrql accountId enabled Example response: { \"data\": { \"actor\": { \"account\": { \"eventsToMetrics\": { \"allRules\": { \"rules\": [ { \"description\": \"Metric for total time\", \"enabled\": true, \"id\": \"1\", \"name\": \"Total Time Tx\", \"nrql\": \"select summary(totalTime) as 'server.totalTime' from Transaction where appName = 'Data Points Staging' facet name, appName, host\" }, { \"description\": \"Metric for duration\", \"enabled\": true, \"id\": \"2\", \"name\": \"Duration Rule\", \"nrql\": \"select summary(duration) as 'server.responseTime' from Transaction where appName = 'Data Points Staging' facet name, appName, host\" } ] } } } } } } Copy List rule by rule ID If you know the exact ID for a rule, then you can query for a specific rule. For example, you may have just created a rule and now you want to list its contents so you can review it. Example listing rule 36 for New Relic account 123456: query { actor { account(id: 123456) { eventsToMetrics { rulesById(ruleIds: \"36\") { rules { id name enabled nrql description accountId } } } } } } Copy For more details about the elements in this query, see List all rules. Example response: { \"data\": { \"actor\": { \"account\": { \"eventsToMetrics\": { \"rulesById\": { \"rules\": [ { \"accountId\": 123456, \"description\": \"Metric for total time\", \"enabled\": true, \"id\": \"36\", \"name\": \"Total Time Tx\", \"nrql\": \"select summary(totalTime) as 'server.totalTime' from Transaction where appName = 'Data Points Staging' facet name, appName, host\" } ] } } } } } } Copy Use the NerdGraph GraphiQL API tool You can use our GraphiQL tool to explore the data structure. You can also use it to build and run the operations to convert events, logs, and spans to metrics. To use this tool: Create the metrics operation's request with the required parameters. Go to api.newrelic.com/graphiql, and paste your query into the box. To execute the operation, press Play. Or, to get the cURL format, select Copy as cURL.) Validate the response in the response box. Optional: To verify that your rule-creation operation was performed successfully, run a list query for that rule ID.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 389.4101,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Analyze <em>and</em> monitor <em>data</em> trends with <em>metrics</em>",
        "sections": "Analyze <em>and</em> monitor <em>data</em> trends with <em>metrics</em>",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": "You can generate <em>metric</em>-type <em>data</em> from other types of <em>data</em> in New Relic, including events, logs, and spans. <em>Metrics</em> are aggregates of your <em>data</em> and are optimal for analyzing and monitoring trends over long time periods. This document explains: Reasons to use this feature Available operations How"
      },
      "id": "603eb239e7b9d2b99d2a07bb"
    },
    {
      "sections": [
        "Create metrics from other data types",
        "Create a metrics rule",
        "Step 1. Create NRQL query rule",
        "Tip",
        "Step 2. Create API request",
        "Example NerdGraph API request",
        "Example NerdGraph API response",
        "Step 3. Create a metrics rule with API request",
        "Query and chart your metrics",
        "Summary metric example",
        "Count metric example",
        "Distribution metric example",
        "Troubleshooting"
      ],
      "title": "Create metrics from other data types",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Convert data to metrics"
      ],
      "external_id": "49b5860f405d53d1d9a630c2e031ab4331458005",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/convert-to-metrics/create-metrics-other-data-types/",
      "published_at": "2021-10-24T21:24:28Z",
      "updated_at": "2021-10-23T17:27:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use New Relic's metrics API service to define rules for creating metrics from your other types of data, such as events, logs, or spans. Recommendation: Before you begin, review our requirements and tips for creating rules. Create a metrics rule To create a rule for creating metrics from events, logs, or spans: Construct the metrics rule using NRQL. Construct a NerdGraph (GraphQL format) API request that contains your NRQL rule. Create the metric by making the API request. Once a metric is created, you can query and chart it using NRQL. Step 1. Create NRQL query rule The most important part of creating a metrics rule is constructing the NRQL query that defines the metric for your data from events, logs, or spans. You can create up to 10 metrics with a single NRQL query by following this procedure: Using New Relic's NRQL interface, construct a query for the metric you want to create. For example: FROM ProcessSample SELECT average(ioTotalReadBytes) WHERE nr.entityType = 'HOST' Copy Edit the query to use one of the three available metric types: summary: Use if the query's function is min, max, sum, count, or average. uniqueCount: Use if the query's function is uniqueCount. distribution: Use if the query's function is percentile or histogram. This example query uses average, so use summary: FROM ProcessSample SELECT summary (ioTotalReadBytes) WHERE nr.entityType = 'HOST' Copy This example query uses count on a non-numeric field: FROM ProcessSample SELECT count(hostname) WHERE hostname LIKE '%prod%' Copy For summary on a non-numeric field use summary(1): FROM ProcessSample SELECT summary(1) WHERE hostname LIKE '%prod%' Copy Tip For more detailed information on using these metric types in rules, see Creating metric rules: requirements and tips. Decide on the attributes you want to attach to the metric, following the limits on the cardinality of unique metric-name/attribute-value combinations. Recommendation: Run a separate query to ensure this count isn't over 50,000 for a 24-hour window. For example: FROM ProcessSample SELECT uniqueCount(awsRegion, awsAvailabilityZone, commandName) WHERE nr.entityType = 'HOST' SINCE 1 DAY AGO Copy To be able to aggregate and filter your metrics, add the attributes you want to attach to the metric using the FACET clause. For example: FROM ProcessSample SELECT summary(ioTotalReadBytes) WHERE nr.entityType = 'HOST' FACET awsRegion, awsAvailabilityZone, commandName Copy Set the name of the metric using the AS function. For example: FROM ProcessSample SELECT summary(ioTotalReadBytes) AS 'io.totalread.bytes' WHERE nr.entityType = 'HOST' FACET awsRegion, awsAvailabilityZone, commandName Copy Once your NRQL rule is complete, use it to create the API request. Step 2. Create API request After you build the NRQL rule to convert data from events, logs, or spans to metrics, continue with building the API request. You can use our NerdGraph API tool to explore the data structure and to construct and make your request. To check that the rule was created correctly, you can run a query to return that rule using its ID. For tips on querying the metrics you've created, see Query and chart your metrics. Example NerdGraph API request The following example NerdGraph API request uses the same NRQL rule from step 1. The IO Total Read Bytes Rule creates a metric named io.totalread.bytes. (The rule name can have spaces, which differs from the metric naming rules.) mutation { eventsToMetricsCreateRule(rules: { name: \"io.totalread.bytes for computeSample entities\", description:\"Created by Zach on March 27, 2019. Used by team Network.\", nrql:\"FROM ProcessSample SELECT summary(ioTotalReadBytes) AS 'io.totalread.bytes' WHERE nr.entityType = 'ComputeSample' FACET awsRegion, awsAvailabilityZone, commandName\", accountId: 123456 }) { successes { id name nrql enabled } failures { submitted { name nrql accountId } errors { reason description } } } } Copy In this request: Request elements Description mutation One of the basic API operation types. eventsToMetricsCreateRule The method being called to create a rule. rules Takes four parameters: name: The name of the rule. description: Optional. The description of the rule. We recommend you include information about who created the metric data and who will be using the data. accountId: The New Relic account ID where the events, logs, or spans live and the metrics will be created. nrql: The NRQL query that creates the rule. For more on this, see Create NRQL query. successes and submitted blocks Here you define the data returned by a successful or failed response. Available parameters for these blocks include: id (ruleId for submitted) name description nrql enabled (enabled/disabled status) accountId ruleId and accountId If a failure occurs, then the submitted ruleId and accountId will be returned along with the error reason and error description. Example NerdGraph API response Here's an example of a returned response: { \"data\": { \"eventsToMetricsCreateRule\": { \"failures\": [], \"successes\": [ { \"enabled\": true, \"id\": \"46\", \"name\": \"io.totalread.bytes for computeSample entities\", \"nrql\": \"FROM ProcessSample SELECT summary(ioTotalReadBytes) AS 'io.totalread.bytes' WHERE nr.entityType = 'ComputeSample' FACET awsRegion, awsAvailabilityZone, commandName\" } ] } } } Copy Step 3. Create a metrics rule with API request When your API request is ready, you can use the NerdGraph API to make the request, which will create the metrics. Query and chart your metrics After you create a metrics rule to convert data for your events, logs, or spans, you can view the new metric data in the New Relic UI. To view your data: Go to New Relic's NRQL query interface. Run the following query to see the name of all your metrics: SELECT uniques(metricName) FROM Metric Copy Pick the metric of interest, then run the following query to see the available attributes: SELECT * FROM Metric where metricName = 'yourMetric' Copy If you don't see expected data, follow the troubleshooting procedures. The available NRQL aggregator functions depend on the metric type you created. Here are some examples. Summary metric example If you created a summary metric type, you can use the count, sum, max, min, and average aggregator functions, as shown in the following query: SELECT count(appStartResponseTime), sum(appStartResponseTime), max(appStartResponseTime), min(appStartResponseTime), average(appStartResponseTime) FROM Metric Copy Count metric example If you created a uniqueCount metric type, you can only use the uniqueCount function, as shown in the following query: SELECT uniqueCount(playbackErrorStreamUniqueCount) * 100 / uniqueCount(streamUniqueCount) AS '% of Streams Impacted' FROM Metric Copy Distribution metric example If you created a distribution metric type, use the percentile or histogram functions, as shown in the following queries: SELECT percentile(service.responseTime, 95) FROM Metric Copy OR SELECT histogram(service.responseTime, 10, 20) FROM Metric Copy Troubleshooting If your NerdGraph call is not constructed correctly, you may receive a message like this: Cannot parse the unexpected character \"\\u201C” Copy Verify the quotes in the NerdGraph call are not smart quotes (curly quotes). Our NerdGraph API only accepts straight quotes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 389.39874,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create <em>metrics</em> from other <em>data</em> types",
        "sections": "Create <em>metrics</em> from other <em>data</em> types",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": " the NerdGraph API to make the request, which will create the <em>metrics</em>. Query and chart your <em>metrics</em> After you create a <em>metrics</em> rule to <em>convert</em> <em>data</em> for your events, logs, or spans, you can view the new <em>metric</em> <em>data</em> in the New Relic UI. To view your <em>data</em>: Go to New Relic&#x27;s NRQL query interface. Run the following"
      },
      "id": "603ebfc8196a67cab0a83d96"
    },
    {
      "sections": [
        "Get data into New Relic",
        "New Relic-built agents and integrations",
        "Report custom data"
      ],
      "title": "Get data into New Relic",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Get started"
      ],
      "external_id": "016a25d46dedc5da1455b29d8557ce68a4345756",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/get-started/introduction-new-relic-data-ingest-apis-sdks/",
      "published_at": "2021-10-24T19:36:34Z",
      "updated_at": "2021-10-23T17:32:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are many ways to get data into your New Relic account. Any New Relic user can use any of our data ingest methods to report data to our platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure monitoring, or any of our wide array of integrations, by default you'll receive data from your monitored applications, hosts, services, or other entities. Some options for getting started: Log into one.newrelic.com and click Add more data to get some guidance on setting up New Relic solutions. To browse our solutions, see New Relic integrations. Report custom data If you need to report data that our agents and integrations don't provide, we have tools that will allow you to bring in any type of data you need. To learn more, see Intro to custom data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.02896,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get <em>data</em> into New Relic",
        "sections": "Get <em>data</em> into New Relic",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": "There are many ways to get <em>data</em> into your New Relic account. Any New Relic user can use any of our <em>data</em> <em>ingest</em> methods to report <em>data</em> to our <em>platform</em>. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure"
      },
      "id": "6174474328ccbcdff4c6b77e"
    }
  ],
  "/docs/data-apis/custom-data/custom-events/apm-report-custom-events-attributes": [
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "65970eacbedb3360fd1c7394affc8cbc42f2ab0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 357.14447,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report mobile monitoring <em>custom</em> <em>events</em> and attributes",
        "sections": "Report mobile monitoring <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": "Mobile monitoring in New Relic sends some default <em>event</em> <em>data</em> from your mobile app to New Relic, such as <em>data</em> about interactions, sessions, crashes, and request errors. You can also create your own <em>custom</em> attributes and <em>events</em> for more detailed querying and analysis. Create <em>custom</em> attributes"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "17c97a462616f2b23ead796b62780a1ffeb3dfac",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Agent version Your browser monitoring agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute browser API call To add a custom attribute to the PageView event via the browser agent, use the setCustomAttribute browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 357.1443,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report browser monitoring <em>custom</em> <em>events</em> and attributes",
        "sections": "Report browser monitoring <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": "You can use browser monitoring in New Relic to add <em>custom</em> <em>events</em> and attributes. Page actions and views Use the browser API&#x27;s addPageAction call to capture <em>events</em>, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an <em>event</em> named PageAction"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    },
    {
      "sections": [
        "Data requirements and limits for custom event data",
        "General requirements",
        "Important",
        "Reserved words",
        "Event type limits"
      ],
      "title": "Data requirements and limits for custom event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "77720ef366038ba648a5fbf3cf34e8e48b38440a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/data-requirements-limits-custom-event-data/",
      "published_at": "2021-10-24T20:14:57Z",
      "updated_at": "2021-10-23T21:58:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. You can report custom events to New Relic in several ways, including: APM agent APIs Event API (There are additional requirements when using the Event API.) Browser monitoring agent APIs (There are additional requirements with the custom PageAction event.) Mobile monitoring SDK General requirements When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Important Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). If the name begins with anything other than an alphabetical character, enclose the name with backticks in your NRQL query. For example: FROM `0_hello` SELECT count(*) Copy Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. Important This is not a complete list. In general, avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Event type limits The current limit for total number of eventType values is 250 per child account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 357.1349,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Data</em> requirements and limits for <em>custom</em> <em>event</em> <em>data</em>",
        "sections": "<em>Data</em> requirements and limits for <em>custom</em> <em>event</em> <em>data</em>",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": " child account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop <em>data</em>. <em>Event</em> types include: Default <em>events</em> from New Relic agents <em>Custom</em> <em>events</em> from New Relic agents <em>Custom</em> <em>events</em> from <em>Insights</em> <em>custom</em> <em>event</em> inserter"
      },
      "id": "609fa5cfe7b9d2bf16c3eb69"
    }
  ],
  "/docs/data-apis/custom-data/custom-events/data-requirements-limits-custom-event-data": [
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "65970eacbedb3360fd1c7394affc8cbc42f2ab0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 357.14447,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report mobile monitoring <em>custom</em> <em>events</em> and attributes",
        "sections": "Report mobile monitoring <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": "Mobile monitoring in New Relic sends some default <em>event</em> <em>data</em> from your mobile app to New Relic, such as <em>data</em> about interactions, sessions, crashes, and request errors. You can also create your own <em>custom</em> attributes and <em>events</em> for more detailed querying and analysis. Create <em>custom</em> attributes"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "17c97a462616f2b23ead796b62780a1ffeb3dfac",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Agent version Your browser monitoring agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute browser API call To add a custom attribute to the PageView event via the browser agent, use the setCustomAttribute browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 357.1443,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report browser monitoring <em>custom</em> <em>events</em> and attributes",
        "sections": "Report browser monitoring <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": "You can use browser monitoring in New Relic to add <em>custom</em> <em>events</em> and attributes. Page actions and views Use the browser API&#x27;s addPageAction call to capture <em>events</em>, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an <em>event</em> named PageAction"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    },
    {
      "sections": [
        "APM: Report custom events and attributes",
        "Data considerations",
        "Tip",
        "Record custom events and attributes",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Timestamps",
        "Limits and restricted characters",
        "Reserved words"
      ],
      "title": "APM: Report custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "8731386e34fbced8d086795e273a1e2392b663ba",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/apm-report-custom-events-attributes/",
      "published_at": "2021-10-24T20:14:08Z",
      "updated_at": "2021-10-23T19:43:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have APM, you can report custom event data. You can then query and visualize your data in New Relic. Data considerations New Relic agents send event data to New Relic as part of the normal harvest cycle every five seconds for agent versions supporting real time streaming. Sending a lot of events can increase the memory overhead of the agent. New Relic enforces an upper limit of 833 custom events every 5 seconds. Additionally, posts greater than 1MB (10^6 bytes) in size will not be recorded, regardless of the custom event limit. You can also send custom events using the Event API (without need for APM). However, be aware that custom events sent with the agent APIs are not compatible with high security mode. Tip For more information, check out New Relic University’s tutorial Adding custom data with the APM agent API. Or, go directly to the full online course Custom data with APM. Record custom events and attributes You can add your own custom APM events and attributes, which you can then use for querying and charting. This is one of several ways to report custom data. To record a custom event, follow the procedures for your New Relic language agent. To add custom attributes to APM events, you must first enable them for your APM agent, and then make an API call to record the attribute. Follow the agent-specific custom attribute procedures. When creating your own custom events and attributes, follow data requirements for: Size limits Attribute types Reserved words C SDK To add a custom event to apps monitored by the C SDK, start a transaction and use the newrelic_create_custom_event and newrelic_record_custom_event functions. For more information, see the Guide to using the C SDK API. You can then add custom attributes for your C SDK app. Go To add a custom event to apps monitored by the Go agent, use RecordCustomEvent. You can then add custom attributes for your Go app. Java Custom event collection is enabled by default in Java agent version 3.13.0 or higher. To send custom events, call recordCustomEvent. For example: Map<String, Object> eventAttributes = new HashMap<String, Object>(); NewRelic.getAgent().getInsights().recordCustomEvent(\"MyCustomEvent\", eventAttributes); Copy The first argument defines the name of your event type, and the second argument is a map with the attributes for your custom event. Event attributes must be strings or numbers. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Java agent via a configuration parameter in newrelic.yml. Specify the maximum number of events to record per minute as an integer. For example, if you want to send less than the default of 10000 events: custom_insights_events: max_samples_stored: 5000 Copy To disable custom events entirely, add the following to your newrelic.yml: custom_insights_events: enabled: false Copy You can then add custom attributes for your Java app. For Java agent versions prior to 4.1.0, use the following YAML configuration: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy .NET Custom event collection is enabled by default in .NET agent version 4.6.29.0 or higher. To send custom events, simply call RecordCustomEvent(). For example: var eventAttributes = new Dictionary<String, Object>(); NewRelic.Api.Agent.NewRelic.RecordCustomEvent('MyCustomEvent', eventAttributes); Copy The first argument defines the name of your event type, and the second argument is an IEnumerable with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your .NET app. You can turn off custom events entirely by setting customEvents.enabled to false in newrelic.config. Node.js Custom event collection is enabled by default in Node.js agent version 1.15.0 or higher. To send custom events, simply call the relevant API. For example: recordCustomEvent(eventType, attributes) Copy Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your Node.js app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.js. PHP Custom event collection is enabled by default in PHP agent version 4.18 or higher. To send custom events, simply call the relevant API function. For example: newrelic_record_custom_event(\"WidgetSale\", array(\"color\"=>\"red\", \"weight\"=>12.5)); Copy The first argument defines the name of your event type, and the second argument is an array with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. By default, the maximum number of custom events recorded per minute is 10,000. This setting cannot be changed. You can then add custom attributes for your PHP app. To disable custom events entirely, add newrelic.custom_insights_events.enabled = false to your newrelic.ini and restart the agent. Python Custom event collection is enabled by default in Python agent version 2.60.0.46 or higher. To send custom events, simply call the relevant API. For example: newrelic.agent. record_custom_event (event_type, params, application=None) Copy The event_type defines the name (or type) of the custom event. Attributes of the custom event should be passed in as a dictionary via the params keyword argument. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For limits and restrictions on event_type and params, see our documentation about limits and restricted characters and reserved words If called outside of the context of a monitored web request or background task, the call will be ignored unless the application keyword argument is provided and an application object corresponding to the application against which the exception should be recorded is provided. A suitable application object can be obtained using the newrelic.agent.application() function. You can then add custom attributes for your Python app. To disable custom events entirely, set custom_insights_events.enabled to False in your newrelic.ini configuration file. Ruby Custom event collection is enabled by default in Ruby agent version 3.9.8.273 or higher. To send custom events, simply call the relevant API. For example: ::NewRelic::Agent.record_custom_event('WidgetSale', color: 'red', weight: 12.5) Copy The first argument defines the name of your event type, and the second argument is a hash with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Ruby agent via a configuration parameter in newrelic.yml: Add custom_insights_events.max_samples_stored: to your configuration file. Specify the maximum number of events to record per minute as an integer. For example, if you want to be able to send up to 5000 events per minute, add: custom_insights_events.max_samples_stored: 5000 Copy You can then add custom attributes for your Ruby app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.yml. Timestamps You may not specify a timestamp on events that are collected and recorded via the agent. The agent will automatically assign a timestamp to events based on when they are recorded via the API. Limits and restricted characters See Custom event data requirements for size limits, data types, and naming syntax requirements. Reserved words Before creating custom attributes, review New Relic's list of reserved terms used by NRQL. Otherwise unexpected results may occur.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 355.7111,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM: Report <em>custom</em> <em>events</em> and attributes",
        "sections": "APM: Report <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": ". Record <em>custom</em> <em>events</em> and attributes You can add your own <em>custom</em> APM <em>events</em> and attributes, which you can then use for querying and charting. This is one of several ways to report <em>custom</em> <em>data</em>. To record a <em>custom</em> <em>event</em>, follow the procedures for your New Relic language agent. To add <em>custom</em> attributes"
      },
      "id": "609fa629e7b9d2fa8dc3eb04"
    }
  ],
  "/docs/data-apis/custom-data/custom-events/report-browser-monitoring-custom-events-attributes": [
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "65970eacbedb3360fd1c7394affc8cbc42f2ab0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 357.14447,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report mobile monitoring <em>custom</em> <em>events</em> and attributes",
        "sections": "Report mobile monitoring <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": "Mobile monitoring in New Relic sends some default <em>event</em> <em>data</em> from your mobile app to New Relic, such as <em>data</em> about interactions, sessions, crashes, and request errors. You can also create your own <em>custom</em> attributes and <em>events</em> for more detailed querying and analysis. Create <em>custom</em> attributes"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    },
    {
      "sections": [
        "Data requirements and limits for custom event data",
        "General requirements",
        "Important",
        "Reserved words",
        "Event type limits"
      ],
      "title": "Data requirements and limits for custom event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "77720ef366038ba648a5fbf3cf34e8e48b38440a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/data-requirements-limits-custom-event-data/",
      "published_at": "2021-10-24T20:14:57Z",
      "updated_at": "2021-10-23T21:58:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. You can report custom events to New Relic in several ways, including: APM agent APIs Event API (There are additional requirements when using the Event API.) Browser monitoring agent APIs (There are additional requirements with the custom PageAction event.) Mobile monitoring SDK General requirements When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Important Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). If the name begins with anything other than an alphabetical character, enclose the name with backticks in your NRQL query. For example: FROM `0_hello` SELECT count(*) Copy Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. Important This is not a complete list. In general, avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Event type limits The current limit for total number of eventType values is 250 per child account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 357.1349,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Data</em> requirements and limits for <em>custom</em> <em>event</em> <em>data</em>",
        "sections": "<em>Data</em> requirements and limits for <em>custom</em> <em>event</em> <em>data</em>",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": " child account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop <em>data</em>. <em>Event</em> types include: Default <em>events</em> from New Relic agents <em>Custom</em> <em>events</em> from New Relic agents <em>Custom</em> <em>events</em> from <em>Insights</em> <em>custom</em> <em>event</em> inserter"
      },
      "id": "609fa5cfe7b9d2bf16c3eb69"
    },
    {
      "sections": [
        "APM: Report custom events and attributes",
        "Data considerations",
        "Tip",
        "Record custom events and attributes",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Timestamps",
        "Limits and restricted characters",
        "Reserved words"
      ],
      "title": "APM: Report custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "8731386e34fbced8d086795e273a1e2392b663ba",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/apm-report-custom-events-attributes/",
      "published_at": "2021-10-24T20:14:08Z",
      "updated_at": "2021-10-23T19:43:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have APM, you can report custom event data. You can then query and visualize your data in New Relic. Data considerations New Relic agents send event data to New Relic as part of the normal harvest cycle every five seconds for agent versions supporting real time streaming. Sending a lot of events can increase the memory overhead of the agent. New Relic enforces an upper limit of 833 custom events every 5 seconds. Additionally, posts greater than 1MB (10^6 bytes) in size will not be recorded, regardless of the custom event limit. You can also send custom events using the Event API (without need for APM). However, be aware that custom events sent with the agent APIs are not compatible with high security mode. Tip For more information, check out New Relic University’s tutorial Adding custom data with the APM agent API. Or, go directly to the full online course Custom data with APM. Record custom events and attributes You can add your own custom APM events and attributes, which you can then use for querying and charting. This is one of several ways to report custom data. To record a custom event, follow the procedures for your New Relic language agent. To add custom attributes to APM events, you must first enable them for your APM agent, and then make an API call to record the attribute. Follow the agent-specific custom attribute procedures. When creating your own custom events and attributes, follow data requirements for: Size limits Attribute types Reserved words C SDK To add a custom event to apps monitored by the C SDK, start a transaction and use the newrelic_create_custom_event and newrelic_record_custom_event functions. For more information, see the Guide to using the C SDK API. You can then add custom attributes for your C SDK app. Go To add a custom event to apps monitored by the Go agent, use RecordCustomEvent. You can then add custom attributes for your Go app. Java Custom event collection is enabled by default in Java agent version 3.13.0 or higher. To send custom events, call recordCustomEvent. For example: Map<String, Object> eventAttributes = new HashMap<String, Object>(); NewRelic.getAgent().getInsights().recordCustomEvent(\"MyCustomEvent\", eventAttributes); Copy The first argument defines the name of your event type, and the second argument is a map with the attributes for your custom event. Event attributes must be strings or numbers. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Java agent via a configuration parameter in newrelic.yml. Specify the maximum number of events to record per minute as an integer. For example, if you want to send less than the default of 10000 events: custom_insights_events: max_samples_stored: 5000 Copy To disable custom events entirely, add the following to your newrelic.yml: custom_insights_events: enabled: false Copy You can then add custom attributes for your Java app. For Java agent versions prior to 4.1.0, use the following YAML configuration: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy .NET Custom event collection is enabled by default in .NET agent version 4.6.29.0 or higher. To send custom events, simply call RecordCustomEvent(). For example: var eventAttributes = new Dictionary<String, Object>(); NewRelic.Api.Agent.NewRelic.RecordCustomEvent('MyCustomEvent', eventAttributes); Copy The first argument defines the name of your event type, and the second argument is an IEnumerable with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your .NET app. You can turn off custom events entirely by setting customEvents.enabled to false in newrelic.config. Node.js Custom event collection is enabled by default in Node.js agent version 1.15.0 or higher. To send custom events, simply call the relevant API. For example: recordCustomEvent(eventType, attributes) Copy Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your Node.js app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.js. PHP Custom event collection is enabled by default in PHP agent version 4.18 or higher. To send custom events, simply call the relevant API function. For example: newrelic_record_custom_event(\"WidgetSale\", array(\"color\"=>\"red\", \"weight\"=>12.5)); Copy The first argument defines the name of your event type, and the second argument is an array with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. By default, the maximum number of custom events recorded per minute is 10,000. This setting cannot be changed. You can then add custom attributes for your PHP app. To disable custom events entirely, add newrelic.custom_insights_events.enabled = false to your newrelic.ini and restart the agent. Python Custom event collection is enabled by default in Python agent version 2.60.0.46 or higher. To send custom events, simply call the relevant API. For example: newrelic.agent. record_custom_event (event_type, params, application=None) Copy The event_type defines the name (or type) of the custom event. Attributes of the custom event should be passed in as a dictionary via the params keyword argument. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For limits and restrictions on event_type and params, see our documentation about limits and restricted characters and reserved words If called outside of the context of a monitored web request or background task, the call will be ignored unless the application keyword argument is provided and an application object corresponding to the application against which the exception should be recorded is provided. A suitable application object can be obtained using the newrelic.agent.application() function. You can then add custom attributes for your Python app. To disable custom events entirely, set custom_insights_events.enabled to False in your newrelic.ini configuration file. Ruby Custom event collection is enabled by default in Ruby agent version 3.9.8.273 or higher. To send custom events, simply call the relevant API. For example: ::NewRelic::Agent.record_custom_event('WidgetSale', color: 'red', weight: 12.5) Copy The first argument defines the name of your event type, and the second argument is a hash with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Ruby agent via a configuration parameter in newrelic.yml: Add custom_insights_events.max_samples_stored: to your configuration file. Specify the maximum number of events to record per minute as an integer. For example, if you want to be able to send up to 5000 events per minute, add: custom_insights_events.max_samples_stored: 5000 Copy You can then add custom attributes for your Ruby app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.yml. Timestamps You may not specify a timestamp on events that are collected and recorded via the agent. The agent will automatically assign a timestamp to events based on when they are recorded via the API. Limits and restricted characters See Custom event data requirements for size limits, data types, and naming syntax requirements. Reserved words Before creating custom attributes, review New Relic's list of reserved terms used by NRQL. Otherwise unexpected results may occur.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 355.7111,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM: Report <em>custom</em> <em>events</em> and attributes",
        "sections": "APM: Report <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": ". Record <em>custom</em> <em>events</em> and attributes You can add your own <em>custom</em> APM <em>events</em> and attributes, which you can then use for querying and charting. This is one of several ways to report <em>custom</em> <em>data</em>. To record a <em>custom</em> <em>event</em>, follow the procedures for your New Relic language agent. To add <em>custom</em> attributes"
      },
      "id": "609fa629e7b9d2fa8dc3eb04"
    }
  ],
  "/docs/data-apis/custom-data/custom-events/report-custom-event-data": [
    {
      "sections": [
        "APM: Report custom events and attributes",
        "Data considerations",
        "Tip",
        "Record custom events and attributes",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Timestamps",
        "Limits and restricted characters",
        "Reserved words"
      ],
      "title": "APM: Report custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "8731386e34fbced8d086795e273a1e2392b663ba",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/apm-report-custom-events-attributes/",
      "published_at": "2021-10-24T20:14:08Z",
      "updated_at": "2021-10-23T19:43:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have APM, you can report custom event data. You can then query and visualize your data in New Relic. Data considerations New Relic agents send event data to New Relic as part of the normal harvest cycle every five seconds for agent versions supporting real time streaming. Sending a lot of events can increase the memory overhead of the agent. New Relic enforces an upper limit of 833 custom events every 5 seconds. Additionally, posts greater than 1MB (10^6 bytes) in size will not be recorded, regardless of the custom event limit. You can also send custom events using the Event API (without need for APM). However, be aware that custom events sent with the agent APIs are not compatible with high security mode. Tip For more information, check out New Relic University’s tutorial Adding custom data with the APM agent API. Or, go directly to the full online course Custom data with APM. Record custom events and attributes You can add your own custom APM events and attributes, which you can then use for querying and charting. This is one of several ways to report custom data. To record a custom event, follow the procedures for your New Relic language agent. To add custom attributes to APM events, you must first enable them for your APM agent, and then make an API call to record the attribute. Follow the agent-specific custom attribute procedures. When creating your own custom events and attributes, follow data requirements for: Size limits Attribute types Reserved words C SDK To add a custom event to apps monitored by the C SDK, start a transaction and use the newrelic_create_custom_event and newrelic_record_custom_event functions. For more information, see the Guide to using the C SDK API. You can then add custom attributes for your C SDK app. Go To add a custom event to apps monitored by the Go agent, use RecordCustomEvent. You can then add custom attributes for your Go app. Java Custom event collection is enabled by default in Java agent version 3.13.0 or higher. To send custom events, call recordCustomEvent. For example: Map<String, Object> eventAttributes = new HashMap<String, Object>(); NewRelic.getAgent().getInsights().recordCustomEvent(\"MyCustomEvent\", eventAttributes); Copy The first argument defines the name of your event type, and the second argument is a map with the attributes for your custom event. Event attributes must be strings or numbers. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Java agent via a configuration parameter in newrelic.yml. Specify the maximum number of events to record per minute as an integer. For example, if you want to send less than the default of 10000 events: custom_insights_events: max_samples_stored: 5000 Copy To disable custom events entirely, add the following to your newrelic.yml: custom_insights_events: enabled: false Copy You can then add custom attributes for your Java app. For Java agent versions prior to 4.1.0, use the following YAML configuration: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy .NET Custom event collection is enabled by default in .NET agent version 4.6.29.0 or higher. To send custom events, simply call RecordCustomEvent(). For example: var eventAttributes = new Dictionary<String, Object>(); NewRelic.Api.Agent.NewRelic.RecordCustomEvent('MyCustomEvent', eventAttributes); Copy The first argument defines the name of your event type, and the second argument is an IEnumerable with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your .NET app. You can turn off custom events entirely by setting customEvents.enabled to false in newrelic.config. Node.js Custom event collection is enabled by default in Node.js agent version 1.15.0 or higher. To send custom events, simply call the relevant API. For example: recordCustomEvent(eventType, attributes) Copy Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your Node.js app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.js. PHP Custom event collection is enabled by default in PHP agent version 4.18 or higher. To send custom events, simply call the relevant API function. For example: newrelic_record_custom_event(\"WidgetSale\", array(\"color\"=>\"red\", \"weight\"=>12.5)); Copy The first argument defines the name of your event type, and the second argument is an array with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. By default, the maximum number of custom events recorded per minute is 10,000. This setting cannot be changed. You can then add custom attributes for your PHP app. To disable custom events entirely, add newrelic.custom_insights_events.enabled = false to your newrelic.ini and restart the agent. Python Custom event collection is enabled by default in Python agent version 2.60.0.46 or higher. To send custom events, simply call the relevant API. For example: newrelic.agent. record_custom_event (event_type, params, application=None) Copy The event_type defines the name (or type) of the custom event. Attributes of the custom event should be passed in as a dictionary via the params keyword argument. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For limits and restrictions on event_type and params, see our documentation about limits and restricted characters and reserved words If called outside of the context of a monitored web request or background task, the call will be ignored unless the application keyword argument is provided and an application object corresponding to the application against which the exception should be recorded is provided. A suitable application object can be obtained using the newrelic.agent.application() function. You can then add custom attributes for your Python app. To disable custom events entirely, set custom_insights_events.enabled to False in your newrelic.ini configuration file. Ruby Custom event collection is enabled by default in Ruby agent version 3.9.8.273 or higher. To send custom events, simply call the relevant API. For example: ::NewRelic::Agent.record_custom_event('WidgetSale', color: 'red', weight: 12.5) Copy The first argument defines the name of your event type, and the second argument is a hash with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Ruby agent via a configuration parameter in newrelic.yml: Add custom_insights_events.max_samples_stored: to your configuration file. Specify the maximum number of events to record per minute as an integer. For example, if you want to be able to send up to 5000 events per minute, add: custom_insights_events.max_samples_stored: 5000 Copy You can then add custom attributes for your Ruby app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.yml. Timestamps You may not specify a timestamp on events that are collected and recorded via the agent. The agent will automatically assign a timestamp to events based on when they are recorded via the API. Limits and restricted characters See Custom event data requirements for size limits, data types, and naming syntax requirements. Reserved words Before creating custom attributes, review New Relic's list of reserved terms used by NRQL. Otherwise unexpected results may occur.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1421.67,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM: <em>Report</em> <em>custom</em> <em>events</em> <em>and</em> <em>attributes</em>",
        "sections": "APM: <em>Report</em> <em>custom</em> <em>events</em> <em>and</em> <em>attributes</em>",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": ". Record <em>custom</em> <em>events</em> and <em>attributes</em> You can add your own <em>custom</em> APM <em>events</em> and <em>attributes</em>, which you can then use for querying and charting. This is one of several ways to <em>report</em> <em>custom</em> data. To record a <em>custom</em> <em>event</em>, follow the procedures for your New Relic language agent. To add <em>custom</em> <em>attributes</em>"
      },
      "id": "609fa629e7b9d2fa8dc3eb04"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "65970eacbedb3360fd1c7394affc8cbc42f2ab0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 469.99426,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Report</em> mobile monitoring <em>custom</em> <em>events</em> <em>and</em> <em>attributes</em>",
        "sections": "<em>Report</em> mobile monitoring <em>custom</em> <em>events</em> <em>and</em> <em>attributes</em>",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": "Mobile monitoring in New Relic sends some default <em>event</em> data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own <em>custom</em> <em>attributes</em> and <em>events</em> for more detailed querying and analysis. Create <em>custom</em> <em>attributes</em>"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "17c97a462616f2b23ead796b62780a1ffeb3dfac",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Agent version Your browser monitoring agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute browser API call To add a custom attribute to the PageView event via the browser agent, use the setCustomAttribute browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 469.99402,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Report</em> browser monitoring <em>custom</em> <em>events</em> <em>and</em> <em>attributes</em>",
        "sections": "<em>Report</em> browser monitoring <em>custom</em> <em>events</em> <em>and</em> <em>attributes</em>",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": " to run and <em>report</em> relevant PageAction <em>events</em>. Run a NRQL query of the PageAction <em>event</em> that includes the actionName attribute you used to capture the <em>event</em> (and any associated <em>attributes</em> you sent along with the action). Add <em>custom</em> <em>attributes</em> to PageView <em>event</em> The PageView <em>event</em> is a default browser"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    }
  ],
  "/docs/data-apis/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes": [
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "17c97a462616f2b23ead796b62780a1ffeb3dfac",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Agent version Your browser monitoring agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute browser API call To add a custom attribute to the PageView event via the browser agent, use the setCustomAttribute browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 357.1441,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report browser monitoring <em>custom</em> <em>events</em> and attributes",
        "sections": "Report browser monitoring <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": "You can use browser monitoring in New Relic to add <em>custom</em> <em>events</em> and attributes. Page actions and views Use the browser API&#x27;s addPageAction call to capture <em>events</em>, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an <em>event</em> named PageAction"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    },
    {
      "sections": [
        "Data requirements and limits for custom event data",
        "General requirements",
        "Important",
        "Reserved words",
        "Event type limits"
      ],
      "title": "Data requirements and limits for custom event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "77720ef366038ba648a5fbf3cf34e8e48b38440a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/data-requirements-limits-custom-event-data/",
      "published_at": "2021-10-24T20:14:57Z",
      "updated_at": "2021-10-23T21:58:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. You can report custom events to New Relic in several ways, including: APM agent APIs Event API (There are additional requirements when using the Event API.) Browser monitoring agent APIs (There are additional requirements with the custom PageAction event.) Mobile monitoring SDK General requirements When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Important Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). If the name begins with anything other than an alphabetical character, enclose the name with backticks in your NRQL query. For example: FROM `0_hello` SELECT count(*) Copy Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. Important This is not a complete list. In general, avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Event type limits The current limit for total number of eventType values is 250 per child account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 357.1347,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Data</em> requirements and limits for <em>custom</em> <em>event</em> <em>data</em>",
        "sections": "<em>Data</em> requirements and limits for <em>custom</em> <em>event</em> <em>data</em>",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": " child account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop <em>data</em>. <em>Event</em> types include: Default <em>events</em> from New Relic agents <em>Custom</em> <em>events</em> from New Relic agents <em>Custom</em> <em>events</em> from <em>Insights</em> <em>custom</em> <em>event</em> inserter"
      },
      "id": "609fa5cfe7b9d2bf16c3eb69"
    },
    {
      "sections": [
        "APM: Report custom events and attributes",
        "Data considerations",
        "Tip",
        "Record custom events and attributes",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Timestamps",
        "Limits and restricted characters",
        "Reserved words"
      ],
      "title": "APM: Report custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "8731386e34fbced8d086795e273a1e2392b663ba",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/apm-report-custom-events-attributes/",
      "published_at": "2021-10-24T20:14:08Z",
      "updated_at": "2021-10-23T19:43:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have APM, you can report custom event data. You can then query and visualize your data in New Relic. Data considerations New Relic agents send event data to New Relic as part of the normal harvest cycle every five seconds for agent versions supporting real time streaming. Sending a lot of events can increase the memory overhead of the agent. New Relic enforces an upper limit of 833 custom events every 5 seconds. Additionally, posts greater than 1MB (10^6 bytes) in size will not be recorded, regardless of the custom event limit. You can also send custom events using the Event API (without need for APM). However, be aware that custom events sent with the agent APIs are not compatible with high security mode. Tip For more information, check out New Relic University’s tutorial Adding custom data with the APM agent API. Or, go directly to the full online course Custom data with APM. Record custom events and attributes You can add your own custom APM events and attributes, which you can then use for querying and charting. This is one of several ways to report custom data. To record a custom event, follow the procedures for your New Relic language agent. To add custom attributes to APM events, you must first enable them for your APM agent, and then make an API call to record the attribute. Follow the agent-specific custom attribute procedures. When creating your own custom events and attributes, follow data requirements for: Size limits Attribute types Reserved words C SDK To add a custom event to apps monitored by the C SDK, start a transaction and use the newrelic_create_custom_event and newrelic_record_custom_event functions. For more information, see the Guide to using the C SDK API. You can then add custom attributes for your C SDK app. Go To add a custom event to apps monitored by the Go agent, use RecordCustomEvent. You can then add custom attributes for your Go app. Java Custom event collection is enabled by default in Java agent version 3.13.0 or higher. To send custom events, call recordCustomEvent. For example: Map<String, Object> eventAttributes = new HashMap<String, Object>(); NewRelic.getAgent().getInsights().recordCustomEvent(\"MyCustomEvent\", eventAttributes); Copy The first argument defines the name of your event type, and the second argument is a map with the attributes for your custom event. Event attributes must be strings or numbers. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Java agent via a configuration parameter in newrelic.yml. Specify the maximum number of events to record per minute as an integer. For example, if you want to send less than the default of 10000 events: custom_insights_events: max_samples_stored: 5000 Copy To disable custom events entirely, add the following to your newrelic.yml: custom_insights_events: enabled: false Copy You can then add custom attributes for your Java app. For Java agent versions prior to 4.1.0, use the following YAML configuration: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy .NET Custom event collection is enabled by default in .NET agent version 4.6.29.0 or higher. To send custom events, simply call RecordCustomEvent(). For example: var eventAttributes = new Dictionary<String, Object>(); NewRelic.Api.Agent.NewRelic.RecordCustomEvent('MyCustomEvent', eventAttributes); Copy The first argument defines the name of your event type, and the second argument is an IEnumerable with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your .NET app. You can turn off custom events entirely by setting customEvents.enabled to false in newrelic.config. Node.js Custom event collection is enabled by default in Node.js agent version 1.15.0 or higher. To send custom events, simply call the relevant API. For example: recordCustomEvent(eventType, attributes) Copy Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your Node.js app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.js. PHP Custom event collection is enabled by default in PHP agent version 4.18 or higher. To send custom events, simply call the relevant API function. For example: newrelic_record_custom_event(\"WidgetSale\", array(\"color\"=>\"red\", \"weight\"=>12.5)); Copy The first argument defines the name of your event type, and the second argument is an array with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. By default, the maximum number of custom events recorded per minute is 10,000. This setting cannot be changed. You can then add custom attributes for your PHP app. To disable custom events entirely, add newrelic.custom_insights_events.enabled = false to your newrelic.ini and restart the agent. Python Custom event collection is enabled by default in Python agent version 2.60.0.46 or higher. To send custom events, simply call the relevant API. For example: newrelic.agent. record_custom_event (event_type, params, application=None) Copy The event_type defines the name (or type) of the custom event. Attributes of the custom event should be passed in as a dictionary via the params keyword argument. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For limits and restrictions on event_type and params, see our documentation about limits and restricted characters and reserved words If called outside of the context of a monitored web request or background task, the call will be ignored unless the application keyword argument is provided and an application object corresponding to the application against which the exception should be recorded is provided. A suitable application object can be obtained using the newrelic.agent.application() function. You can then add custom attributes for your Python app. To disable custom events entirely, set custom_insights_events.enabled to False in your newrelic.ini configuration file. Ruby Custom event collection is enabled by default in Ruby agent version 3.9.8.273 or higher. To send custom events, simply call the relevant API. For example: ::NewRelic::Agent.record_custom_event('WidgetSale', color: 'red', weight: 12.5) Copy The first argument defines the name of your event type, and the second argument is a hash with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Ruby agent via a configuration parameter in newrelic.yml: Add custom_insights_events.max_samples_stored: to your configuration file. Specify the maximum number of events to record per minute as an integer. For example, if you want to be able to send up to 5000 events per minute, add: custom_insights_events.max_samples_stored: 5000 Copy You can then add custom attributes for your Ruby app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.yml. Timestamps You may not specify a timestamp on events that are collected and recorded via the agent. The agent will automatically assign a timestamp to events based on when they are recorded via the API. Limits and restricted characters See Custom event data requirements for size limits, data types, and naming syntax requirements. Reserved words Before creating custom attributes, review New Relic's list of reserved terms used by NRQL. Otherwise unexpected results may occur.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 355.71094,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM: Report <em>custom</em> <em>events</em> and attributes",
        "sections": "APM: Report <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": ". Record <em>custom</em> <em>events</em> and attributes You can add your own <em>custom</em> APM <em>events</em> and attributes, which you can then use for querying and charting. This is one of several ways to report <em>custom</em> <em>data</em>. To record a <em>custom</em> <em>event</em>, follow the procedures for your New Relic language agent. To add <em>custom</em> attributes"
      },
      "id": "609fa629e7b9d2fa8dc3eb04"
    }
  ],
  "/docs/data-apis/custom-data/intro-custom-data": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-custom-event-data/",
      "sections": [
        "Report custom events and attributes",
        "Requirements",
        "Avoid rate limits",
        "Example use cases",
        "Using custom attributes",
        "Using custom events",
        "Send custom events and attributes",
        "Extend data retention"
      ],
      "published_at": "2021-10-24T14:59:18Z",
      "title": "Report custom events and attributes",
      "updated_at": "2021-10-23T21:59:19Z",
      "type": "docs",
      "external_id": "ff7b6544c9a15b49f77c4d86f69c66949c45cb87",
      "document_type": "page",
      "popularity": 1,
      "body": "One of the ways to report custom data to New Relic is with custom events and attributes. Have questions about why you'd use custom data? See Introduction to custom data. Requirements For event and attribute formatting requirements and best practices, see Limits and requirements. Avoid rate limits Reporting a large number of custom events and/or attributes can cause degraded query performance. It may also result in approaching or passing data collection rate limits. For optimal performance, first think about what data you want to analyze, and then create only the events and/or attributes necessary to meet these specific goals. Be aware of the following data and subscription requirements for inserting and accessing custom data: Ensure you follow limits and requirements around event/attribute data types, naming syntax, and size. The amount of data you have access to over time depends on your data retention policy. Example use cases Two popular custom data solutions are custom events and custom attributes. There are several ways to accomplish this (more on that later in this doc), depending on your New Relic implementation and tools. Here are some common use cases for implementing custom events and attributes. Using custom attributes Custom attributes are often used to add important business and operational context to existing events. Business context might include: Customer token Customer market segment Customer value classification Workflow control values not obvious in the URIStem User/product/account privilege context Operational context might include: Which feature flags were used What datastore was accessed What cache was accessed What errors were detected and ignored (fault partitioning) Using custom events Event data is one of New Relic's four core data types. We recommend reading that definition to understand what we mean by \"event\" and why that data type is most used for reporting specific types of activity. The use cases for custom events varies widely: basically they are used for any type of activity that an organization deems important and that is not already being monitored. A couple examples: An event might represent an activity involving multiple actions, like a customer purchasing a certain combination of products. An event might record backup activity. For example, they might set up reporting of events that represent production backups of their SOLR instances into an event table, with a timestamp of when it occurred, which cluster, and the duration. Send custom events and attributes Methods for sending custom events and attributes include: Source How to send custom data APM agent Use APM agent APIs to report custom events and custom attributes. Browser monitoring agent Add custom attributes to the PageView event via the browser API call addCustomAttribute. Send PageAction event and attributes via browser API. Forward APM agent custom attributes to PageView event. Event API To report custom events not associated with other New Relic products, use the Event API. Infrastructure monitoring agent Add custom attributes to default Infrastructure events. Use the Flex integration tool to report your own custom event data. Mobile monitoring agent Use the mobile agent API to send custom events and attributes. Synthetic monitoring Add custom attributes to the SyntheticCheck event via the $util.insights tools. For ways to report other types of custom data, see: Metric API Logs Trace API Extend data retention To learn how to extend how long events are retained in your account, see our documentation about event data retention.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 916.83966,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>custom</em> events and attributes",
        "sections": "Report <em>custom</em> events and attributes",
        "body": "One of the ways to report <em>custom</em> <em>data</em> to New Relic is with <em>custom</em> events and attributes. Have questions about why you&#x27;d use <em>custom</em> <em>data</em>? See <em>Introduction</em> to <em>custom</em> <em>data</em>. Requirements For event and attribute formatting requirements and best practices, see Limits and requirements. Avoid rate limits"
      },
      "id": "609fa5fb64441f9ebfd2a1db"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "65970eacbedb3360fd1c7394affc8cbc42f2ab0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.731026,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report mobile monitoring <em>custom</em> events and attributes",
        "sections": "Set the time <em>to</em> send <em>data</em>",
        "tags": "Event <em>data</em> sources",
        "body": "Mobile monitoring in New Relic sends some default event <em>data</em> from your mobile app to New Relic, such as <em>data</em> about interactions, sessions, crashes, and request errors. You can also create your own <em>custom</em> attributes and events for more detailed querying and analysis. Create <em>custom</em> attributes"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "17c97a462616f2b23ead796b62780a1ffeb3dfac",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Agent version Your browser monitoring agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute browser API call To add a custom attribute to the PageView event via the browser agent, use the setCustomAttribute browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.730965,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report browser monitoring <em>custom</em> events and attributes",
        "sections": "Forward <em>custom</em> attributes from APM <em>data</em>",
        "tags": "Event <em>data</em> sources",
        "body": " that contains the action name and any <em>custom</em> attribute names and values you capture along with it. The PageAction event also contains any <em>custom</em> attributes you added to the PageView event. Add <em>custom</em> attributes to the PageView event so you can query or filter your <em>data</em> to answer more questions about your"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    }
  ],
  "/docs/data-apis/get-started/introduction-new-relic-data-ingest-apis-sdks": [
    {
      "sections": [
        "NRDB: the horsepower under the hood",
        "Billions of data points per minute",
        "Scale, purpose, and equal access to resources",
        "The lifecycle of a query",
        "The result: flexibility, speed, accuracy, and efficiency",
        "What’s next?"
      ],
      "title": "NRDB: the horsepower under the hood",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Get started"
      ],
      "external_id": "73e784610bedcc1bf4ae777e5d6a7a426f37304a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/get-started/nrdb-horsepower-under-hood/",
      "published_at": "2021-10-24T23:24:43Z",
      "updated_at": "2021-10-23T17:32:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you’ve been reading our documentation, chances are you’ve already learned a bit about New Relic and the many tools and capabilities we offer. We’re very proud of the utility and design of our dashboards, alerts, and versatile programmability, but none of it would be possible without the computing power needed to make it all run smoothly. Just like a finely calibrated race car, what you see on the outside may be the most exciting features, and these are the parts you interact with to “drive.” But without an engine designed to win, elegant instrument panels, a responsive clutch, and a great paint job won’t get you anywhere. Under the hood of New Relic lies the engine powering it all: the New Relic Database (NRDB). In this resource, we explain how NRDB helps you succeed in your observability goals. Billions of data points per minute New Relic ingests billions of telemetry data points every minute, serving more than 180,000 accounts simultaneously. To run such a high-volume platform, the underlying database and query capabilities need to be fast, flexible, and scalable. They must also be equally effective for organizations of all sizes, supporting a wide spectrum of telemetry needs and business goals. NRDB provides the power, speed, and scalability you need to monitor your performance across your entire landscape quickly and effectively. Scale, purpose, and equal access to resources To meet the challenging demands for speed, efficiency, scalability, and reliability, we built NRDB with three key objectives. Unlimited scalability: Hosted in the cloud, NRDB's distributed architecture has the capacity for virtually unlimited scale. Monitoring and analysis: With this dual purpose in mind, NRDB handles operational monitoring and data analytics equally well. This means that NRDB can ingest massive amounts of data while also giving you real-time alerting, lightning-fast queries, and charting — all without sacrificing speed. Resources when you need them: As a multi-tenant system supporting tens of thousands of customers, NRDB gives you the resources you need when you need them (which single-tenant systems cannot match). The lifecycle of a query NRDB returns results for queries of all sizes astonishingly fast. To do this, we use parallel processing at massive scale. This architectural approach is equally effective for accelerating a single large query and for allowing numerous users to run small queries simultaneously without impacting speed. It works like this: A user enters a query using one of our tools, such as the query builder, or a dashboard or other type of instrumentation sends an automated query. NRDB starts by sending the query to a router, which in turn sends the query components to hundreds or even thousands of query workers. The query workers find the data, and the process is repeated in reverse, with data returning to populate dashboards, create alerts, or answer discrete queries, among other things. This process yields complete query results in a fraction of the time that other methods would require. To further improve efficiency, NRDB also caches recent queries, allowing it to send those results back to users nearly instantaneously. The result: flexibility, speed, accuracy, and efficiency How big is the difference? Because of NDRB's raw power and purposeful design, New Relic's telemetry products are able to analyze tens of billions of events per second while maintaining a median query response time of 45 milliseconds. We would say, “Your query results are just a heartbeat away,” but mathematically that’s more like a tenth of a heartbeat (unless you’re a mouse). What do these statistics mean for our customers? At the end of the day, NRDB's speed and unique capabilities enable you to identify, analyze, and fix performance problems much faster, reducing downtime so you can get back to business. What’s next? Want to know more? Here are a few recommendations for what to do next: Learn about NRDB's data model and flexible schema in our blog post and white paper. Get to know NRQL, our query language, with our Syntax, clauses, and functions page, or read about some of our favorite NRQL capabilities. Read about our query builder, which supports NRQL and PromQL-style queries. Check out UI options for dashboards and charting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 285.435,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Billions of <em>data</em> points per minute",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": " paint job won’t <em>get</em> you anywhere. Under the hood of New Relic lies the engine powering it all: the New Relic Database (NRDB). In this resource, we explain how NRDB helps you succeed in your observability goals. Billions of <em>data</em> points per minute New Relic ingests billions of telemetry <em>data</em> points"
      },
      "id": "61744743e7b9d212c413d95d"
    },
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "3d1e1c9bdb5d2cbf172eb055dc83020e39dbd16b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/metric-api/introduction-metric-api/",
      "published_at": "2021-10-24T20:15:16Z",
      "updated_at": "2021-10-23T17:26:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. Want to try out our Metric API? Create a New Relic account for free! No credit card required. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. You'll need a New Relic license key for the New Relic account you want to send data to. For information on limits and restricted attributes, see Metric API requirements and limits. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting See Troubleshoot an NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 233.85262,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Get</em> <em>started</em>",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": " on limits and restricted attributes, see Metric API requirements and limits. <em>Get</em> <em>started</em> If we don&#x27;t have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other <em>data</em>. Use"
      },
      "id": "6107858fe7b9d2f9dcfc108e"
    },
    {
      "sections": [
        "New Relic data types",
        "Get started",
        "Tip",
        "Metrics",
        "Metrics in the monitoring industry",
        "Metrics at New Relic",
        "Dimensional metrics (used by Metric API and many integrations)",
        "Metric timeslice data (used by APM, browser, mobile)",
        "Metric timeslice examples",
        "Metrics attached to events (used by Infrastructure, other products)",
        "Metrics as a computation of events (used in some charts and queries)",
        "Event data",
        "Events in the monitoring industry",
        "Events at New Relic",
        "Log data",
        "Logs in the monitoring industry",
        "Logs at New Relic",
        "Trace data",
        "Tracing in the monitoring industry",
        "Tracing at New Relic",
        "Query and send data",
        "Learn more"
      ],
      "title": "New Relic data types",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Understand data"
      ],
      "external_id": "8e4ab82bb58db47bc412f57231d4956c6068262b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/understand-data/new-relic-data-types/",
      "published_at": "2021-10-24T21:27:50Z",
      "updated_at": "2021-10-23T17:27:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic platform is built around the four fundamental telemetry data types we believe are necessary for complete and effective system monitoring: metrics, events, logs, and traces. Get started This doc will give you a fairly technical explanation of our core data types, their structure, and how they're used in our features. You can use most of our features without needing to understand the underlying data structure. But having a better understanding of this can help you get data into New Relic, understand the data you see in our UI, and query your data. For a simpler explanation of these data types using real-world examples, see Introduction to essential telemetry data types. Another good way to understand your data is to just start querying it. Tip Access your data easily on one.newrelic.com: Click the Browse data dropdown menu and select the data type (metrics, events, logs, and traces) you want to explore. Metrics First, we’ll explain the definition of metrics from a monitoring industry perspective, and then we’ll explain how New Relic handles metrics. For a list of the metrics we collect, see our documentation on metrics. Metrics in the monitoring industry In the software monitoring industry, a metric means a numeric measurement of an application or system. Metrics are typically reported on a regular schedule. Two major types of metrics are: Aggregated data. For example: a count of events over one minute’s time, or the rate of some event per minute. A numeric status at a moment in time. For example: a CPU temperature reading, or a “CPU% used” status. Metrics are relatively easy to report and store because a single record can represent a range of time. They can also be aggregated more and more over time. For example, per-minute data may be “rolled up” to per-hour aggregations after some amount of time, and eventually may be rolled up to a per-day aggregation. This approach is efficient for long-term data storage. Metrics are a strong solution for storing data long-term, and understanding trends over time. One potential downside is that it can be difficult to do detailed analysis of older data that has been aggregated over time; when high detail is required about specific important actions, event data can be used. Metrics at New Relic Conceptually, \"metrics\" is a broad, general category. There are various ways New Relic measures and reports metrics but, in practice, when using the New Relic UI, you usually won't have to understand how exactly this happens. In our documentation, we typically will just refer to \"metrics,\" regardless of how that data is reported, unless there's a reason you need to know more (like understanding how to query your data). Here are some of the ways metrics are reported and stored across the New Relic platform: Dimensional metrics (used by Metric API and many integrations) In the monitoring industry, \"dimensional\" metrics refer to metric data that has a variety of attributes (dimensions) attached, such as duration-related attributes (start time, end time), entity ID, region, host, etc. This amount of detail allows for in-depth analysis and querying. At New Relic, this metric data is attached to the Metric data type and is sent from several sources: Some open-source integrations, like our Prometheus and OpenCensus exporters Our Telemetry SDKs Infrastructure services The Metric API (the underlying API used by the above tools) The events-to-metrics service To query this data and see its attributes (\"dimensions\"), you could use a NRQL query like: Select * from Metric Copy As time passes, these metrics are increasingly aggregated into larger time buckets. This is done to optimize your ability to query data over a long period of time. For more details about the metric data type, see our docs. To learn how this data is ingested and stored, see the Metric API documentation. For tips on querying, see Metric query examples. Metric timeslice data (used by APM, browser, mobile) New Relic's APM, browser, and mobile report and display metrics in a simple data format that we refer to as metric timeslice data. A metric timeslice consists of three parts: a metric name, the segment of time the metric represents (the \"timeslice\"), and a numeric value (the measurement). For example: an APM metric timeslice for time spent in a particular transaction is named WebTransaction/URI/foo, and might have a response time of 0.793 for a one-minute time slice from 10:20am to 10:21am. These metrics usually follow a pattern like <category>/<class>/<method>. Our agents (APM, browser, and mobile) can collect thousands of metric timeslices per minute for a variety of performance metrics. For example: error rate, bandwidth usage, and garbage collection time. You also have the ability to create custom metrics. Metric timeslice data is a lightweight data type and lacks the detail that dimensional metrics have. Ways to explore and query metric timeslice data: For APM: metric timeslice data is converted to dimensional metrics and can be queried via NRQL Use the REST API If you want to learn more about the structure of metric timeslice data and see some examples, expand the collapser below. Metric timeslice examples Here are some common metric timeslice data examples, with a focus on common ones used by Ruby applications. ActiveMerchant New Relic tracks a variety of metrics on ActiveMerchant transactions which can be used for business analytics as well as performance monitoring. The metrics are summarized by operation as well as by gateway. regex sample metric legend name ActiveMerchant/. * ActiveMerchant/PayJunctionGateway ActiveMerchant/gateway/. * ActiveMerchant/gateway/PayJunctionGateway/purchase PayJunctionGateway ActiveMerchant/operation/. * ActiveMerchant/operation/purchase purchase For more information, see the ActiveMerchant website. ActiveRecord ActiveRecord is the Object-Relational Mapping API used by Ruby on Rails applications. The metrics shown here measure the performance of ActiveRecord's find and save methods. regex sample metric legend name ActiveRecord/. * /find ActiveRecord/User/find User#find ActiveRecord/. * /save ActiveRecord/Product/save Product#save For more information, see the API documentation for ActiveRecord. Apdex Apdex is a measure of user satisfaction with page load times. Controller In Ruby on Rails applications, HTTP requests are handled by Controller actions. A Rails application has many controllers, each of which has one or more actions. When your rails application receives an http request, that request is routed to the appropriate controller and action, based on the URL of that request. That action then does whatever processing is neccesary to generate an http response, which is most often a web page, but could also be a page fragment, an xml document, or any other kind of data that is requested by the client. The following metrics track the performance of controller actions, regardless of routing, and without taking into account any network or web server effects. regex sample metric legend name Controller/. * Controller/Users/show /Users/show Controller/. * /(?! \\ (other \\ )). * Controller/Users/show /Users/show Controller$ Controller All Controller Actions ControllerCPU/ ControllerCPU/Users/Show /Users/show For more information, see the API documentation for ActionController. Errors This metric tracks the number of errors or exceptions raised while processing requests. regex sample metric legend name Errors/all Errors/all External services External service instrumentation captures calls to out-of-process services such as web services, resources in the cloud and any other network calls. It does not include other first class back-end components such as MemCache and the database. In Ruby applications we instrument the Net::Http library to capture all HTTP services. regex sample metric legend name External/ [ ^/]+/all$ External/service.example.com/all All service.example.com calls External/ External/host.aws.com/Net::Http : :POST Net::Http : :POST [ host.aws.com] External/all$ External/all External Services External/ [ ^/]+/(?!all)/ External/service.example.com/all All service.example.com calls HTTP dispatcher This metric represents a summary of the throughput and response time of all web requests. regex sample metric legend name ^HttpDispatcher$ HttpDispatcher HttpDispatcher MemCache MemCache is a popular technology that enables applications to access shared memory provided by any number of physical machines as a global cache. Applications that heavily use the database often use MemCache for performance and scalability benefits. These metrics measure the frequency and response time of calls to MemCache to read and write data from the cache. Response times should be low (less than 5 ms) for a well performing MemCache deployment. regex sample metric legend name MemCache/. * MemCache/read MemCache read operations MemCache/read MemCache/read MemCache read operations MemCache/write MemCache/write MemCache write operations Mongrel This metric measures the length of the mongrel queue, which holds pending http requests to be processed by mongrel. The HTTP Activity graph overlays the maximimum queue length for a given period. The value is zero if mongrel is processing a request but has no other requests waiting in its queue. When looking at this value across an aggregate cluster of mongrels, the queue lengths of all mongrels is added together, showing the sum of all queue lengths. A mongrel queue length should be at or near zero; if it is consistently at a higher level, then it indicates that your rails application is having trouble keeping up with its load requirements. regex sample metric legend name Mongrel/Queue Length Mongrel/Queue Length Queue Length View ActionView is a package in Rails that is used to render the output that is the response to an http request, such as an html page or an xml document. The View is rendered by the controller that is handling the request. If View metrics represent a large portion of your controller's response time, it could mean you are doing a lot of database operations inside the view template itself. regex sample metric legend name View/. * View/Users/ _ child.html.erb/Partial Users/ _ child.html.erb View/. * /Partial View/Users/ _ child.html.erb/Partial Users/ _ child.html.erb View/. * /Rendering View/Users/show.html.erb/Rendering Users/show.html.erb For more information, see the API documentation for ActionView. Metrics attached to events (used by Infrastructure, other products) Because event-type data can have any type of key-value pair data attached to it, one way metrics can be reported is as attributes attached to an event. A couple examples of this at New Relic: Our infrastructure monitoring reports many metrics that are attached to events. For example, we report a ProcessSample event, which has various sample-based metrics attached to it, like CPU percentage. To learn more about infrastructure monitoring data, see Infrastructure data. In APM, the Transaction event has several metrics attached to it, including databaseDuration. To learn more about this data and how to query it, see Events. Metrics as a computation of events (used in some charts and queries) Metrics can be formed by counting New Relic events, or doing some other mathematical calculation on those events. For example, if you wanted to measure the total number of Transaction events over the last half hour, you might run this NRQL query: Select count(*) from Transaction since 30 minutes ago Copy Another example: if you wanted to compute the average response time for your service, you might run a query like: FROM Transaction SELECT average(duration) SINCE 30 minutes ago Copy Some New Relic charts are generated with these kinds of queries. The downside of this approach is that there are limits on how many events a monitoring system (including ours) can report. This means that sometimes, for high-throughput systems, the count may not accurately represent the total activity on that system. To learn more about how this can be addressed, see Event limits and sampling. Want to report custom metrics? See Get data into New Relic. Event data First, we’ll explain the definition of events from a monitoring industry perspective, and then we’ll explain some specifics about how New Relic handles event data. Events in the monitoring industry In the software industry, events can be thought of as simply “things that occur in a system.” For example, a server setting being changed would be an event. Another example: a website user clicking a mouse. Some events will generate a stored record, and that record is typically also called an event. Event data represents discrete occurrences and typically will have a high level of detail, so event data is suited for detailed analysis and querying. The downside to the use of event data is that there are typically so many events reported that it can become difficult to query that large dataset over longer time ranges. Events at New Relic At New Relic, we report events to data objects also called events. These events have multiple attributes (key-value pairs) attached. Event data is used in some UI charts and tables, and you can also query it. How long event data remains available is determined by data retention rules. One example of an event: APM reports an event type named Transaction, which represents a logical unit of work in an application. To see the attributes attached to this event, you could use a NRQL query like: Select * from Transaction Copy For examples of querying event data, see Introduction to NRQL. Other details about New Relic event data: Events can have any type of attributes attached. Some events have attributes that report metric data. You can report custom events. To increase the availability of your event data for querying/charting, you can turn events into metrics. Some systems generate a large number of events that exceeds collection limits and results in incomplete query results. For more on this, see Event sampling. Because event is a general term, in some New Relic contexts it will refer to any data type that can be queried via NRQL. For example, when you run a NRQL query, it returns a count of inspected events: this is a count of all data types queried. Log data First, we’ll explain the definition of logs from a monitoring industry perspective, and then we’ll explain some specifics about how New Relic handles log reporting. Logs in the monitoring industry A log is a message about a system used to understand the activity of the system and to diagnose problems. Logs at New Relic New Relic's Logs gives you a centralized log management platform that connects your log data with other New Relic-monitored data. For example, you can see logs alongside your APM data. In New Relic, log data is reported with multiple attributes (key-value data) attached. To query your log data, you could use a NRQL query like: Select * from Log Copy To report custom log data, see the Log API. Trace data First, we’ll explain the definition of traces from a monitoring industry perspective, and then we’ll explain some specifics about how New Relic handles tracing. Tracing in the monitoring industry In the application/infrastructure-monitoring world, tracing is a general term used to refer to various ways to report information about how a program or system is operating. For example, a stack trace provides in-depth information about a program’s subroutines. For large modern systems, which are often distributed across many services and micro-services, “tracing” often refers to distributed tracing, which is a way to monitor requests as they propagate through a complex, distributed environment. Tracing at New Relic New Relic offers a distributed tracing feature that tracks requests across a distributed system, and provides a dedicated UI for understanding and analyzing your traces. In New Relic, trace data is reported as Span objects, with multiple attributes (key-value pairs) attached. To query your tracing data, you could use a NRQL query like: Select * from Span Copy To learn more about how distributed tracing works, see Understand distributed tracing. To report custom distributed tracing data, see the Trace API. Query and send data Understanding New Relic data types can help you: Query data in New Relic Send data to New Relic Learn more For a simpler explanation of these data types using real-world examples, see Introduction to essential telemetry data types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 218.61777,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic <em>data</em> types",
        "sections": "<em>Get</em> <em>started</em>",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": "The New Relic platform is built around the four fundamental telemetry <em>data</em> types we believe are necessary for complete and effective system monitoring: metrics, events, logs, and traces. <em>Get</em> <em>started</em> This doc will give you a fairly technical explanation of our core <em>data</em> types, their structure"
      },
      "id": "6045280de7b9d266e1579a0f"
    }
  ],
  "/docs/data-apis/get-started/nrdb-horsepower-under-hood": [
    {
      "sections": [
        "Get data into New Relic",
        "New Relic-built agents and integrations",
        "Report custom data"
      ],
      "title": "Get data into New Relic",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Get started"
      ],
      "external_id": "016a25d46dedc5da1455b29d8557ce68a4345756",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/get-started/introduction-new-relic-data-ingest-apis-sdks/",
      "published_at": "2021-10-24T19:36:34Z",
      "updated_at": "2021-10-23T17:32:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are many ways to get data into your New Relic account. Any New Relic user can use any of our data ingest methods to report data to our platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure monitoring, or any of our wide array of integrations, by default you'll receive data from your monitored applications, hosts, services, or other entities. Some options for getting started: Log into one.newrelic.com and click Add more data to get some guidance on setting up New Relic solutions. To browse our solutions, see New Relic integrations. Report custom data If you need to report data that our agents and integrations don't provide, we have tools that will allow you to bring in any type of data you need. To learn more, see Intro to custom data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 285.43488,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> <em>data</em> into New Relic",
        "sections": "<em>Get</em> <em>data</em> into New Relic",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": "There are many ways to <em>get</em> <em>data</em> into your New Relic account. Any New Relic user can use any of our <em>data</em> <em>ingest</em> methods to report <em>data</em> to our platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure"
      },
      "id": "6174474328ccbcdff4c6b77e"
    },
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "3d1e1c9bdb5d2cbf172eb055dc83020e39dbd16b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/metric-api/introduction-metric-api/",
      "published_at": "2021-10-24T20:15:16Z",
      "updated_at": "2021-10-23T17:26:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. Want to try out our Metric API? Create a New Relic account for free! No credit card required. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. You'll need a New Relic license key for the New Relic account you want to send data to. For information on limits and restricted attributes, see Metric API requirements and limits. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting See Troubleshoot an NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 233.85251,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Get</em> <em>started</em>",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": " on limits and restricted attributes, see Metric API requirements and limits. <em>Get</em> <em>started</em> If we don&#x27;t have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other <em>data</em>. Use"
      },
      "id": "6107858fe7b9d2f9dcfc108e"
    },
    {
      "sections": [
        "New Relic data types",
        "Get started",
        "Tip",
        "Metrics",
        "Metrics in the monitoring industry",
        "Metrics at New Relic",
        "Dimensional metrics (used by Metric API and many integrations)",
        "Metric timeslice data (used by APM, browser, mobile)",
        "Metric timeslice examples",
        "Metrics attached to events (used by Infrastructure, other products)",
        "Metrics as a computation of events (used in some charts and queries)",
        "Event data",
        "Events in the monitoring industry",
        "Events at New Relic",
        "Log data",
        "Logs in the monitoring industry",
        "Logs at New Relic",
        "Trace data",
        "Tracing in the monitoring industry",
        "Tracing at New Relic",
        "Query and send data",
        "Learn more"
      ],
      "title": "New Relic data types",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Understand data"
      ],
      "external_id": "8e4ab82bb58db47bc412f57231d4956c6068262b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/understand-data/new-relic-data-types/",
      "published_at": "2021-10-24T21:27:50Z",
      "updated_at": "2021-10-23T17:27:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic platform is built around the four fundamental telemetry data types we believe are necessary for complete and effective system monitoring: metrics, events, logs, and traces. Get started This doc will give you a fairly technical explanation of our core data types, their structure, and how they're used in our features. You can use most of our features without needing to understand the underlying data structure. But having a better understanding of this can help you get data into New Relic, understand the data you see in our UI, and query your data. For a simpler explanation of these data types using real-world examples, see Introduction to essential telemetry data types. Another good way to understand your data is to just start querying it. Tip Access your data easily on one.newrelic.com: Click the Browse data dropdown menu and select the data type (metrics, events, logs, and traces) you want to explore. Metrics First, we’ll explain the definition of metrics from a monitoring industry perspective, and then we’ll explain how New Relic handles metrics. For a list of the metrics we collect, see our documentation on metrics. Metrics in the monitoring industry In the software monitoring industry, a metric means a numeric measurement of an application or system. Metrics are typically reported on a regular schedule. Two major types of metrics are: Aggregated data. For example: a count of events over one minute’s time, or the rate of some event per minute. A numeric status at a moment in time. For example: a CPU temperature reading, or a “CPU% used” status. Metrics are relatively easy to report and store because a single record can represent a range of time. They can also be aggregated more and more over time. For example, per-minute data may be “rolled up” to per-hour aggregations after some amount of time, and eventually may be rolled up to a per-day aggregation. This approach is efficient for long-term data storage. Metrics are a strong solution for storing data long-term, and understanding trends over time. One potential downside is that it can be difficult to do detailed analysis of older data that has been aggregated over time; when high detail is required about specific important actions, event data can be used. Metrics at New Relic Conceptually, \"metrics\" is a broad, general category. There are various ways New Relic measures and reports metrics but, in practice, when using the New Relic UI, you usually won't have to understand how exactly this happens. In our documentation, we typically will just refer to \"metrics,\" regardless of how that data is reported, unless there's a reason you need to know more (like understanding how to query your data). Here are some of the ways metrics are reported and stored across the New Relic platform: Dimensional metrics (used by Metric API and many integrations) In the monitoring industry, \"dimensional\" metrics refer to metric data that has a variety of attributes (dimensions) attached, such as duration-related attributes (start time, end time), entity ID, region, host, etc. This amount of detail allows for in-depth analysis and querying. At New Relic, this metric data is attached to the Metric data type and is sent from several sources: Some open-source integrations, like our Prometheus and OpenCensus exporters Our Telemetry SDKs Infrastructure services The Metric API (the underlying API used by the above tools) The events-to-metrics service To query this data and see its attributes (\"dimensions\"), you could use a NRQL query like: Select * from Metric Copy As time passes, these metrics are increasingly aggregated into larger time buckets. This is done to optimize your ability to query data over a long period of time. For more details about the metric data type, see our docs. To learn how this data is ingested and stored, see the Metric API documentation. For tips on querying, see Metric query examples. Metric timeslice data (used by APM, browser, mobile) New Relic's APM, browser, and mobile report and display metrics in a simple data format that we refer to as metric timeslice data. A metric timeslice consists of three parts: a metric name, the segment of time the metric represents (the \"timeslice\"), and a numeric value (the measurement). For example: an APM metric timeslice for time spent in a particular transaction is named WebTransaction/URI/foo, and might have a response time of 0.793 for a one-minute time slice from 10:20am to 10:21am. These metrics usually follow a pattern like <category>/<class>/<method>. Our agents (APM, browser, and mobile) can collect thousands of metric timeslices per minute for a variety of performance metrics. For example: error rate, bandwidth usage, and garbage collection time. You also have the ability to create custom metrics. Metric timeslice data is a lightweight data type and lacks the detail that dimensional metrics have. Ways to explore and query metric timeslice data: For APM: metric timeslice data is converted to dimensional metrics and can be queried via NRQL Use the REST API If you want to learn more about the structure of metric timeslice data and see some examples, expand the collapser below. Metric timeslice examples Here are some common metric timeslice data examples, with a focus on common ones used by Ruby applications. ActiveMerchant New Relic tracks a variety of metrics on ActiveMerchant transactions which can be used for business analytics as well as performance monitoring. The metrics are summarized by operation as well as by gateway. regex sample metric legend name ActiveMerchant/. * ActiveMerchant/PayJunctionGateway ActiveMerchant/gateway/. * ActiveMerchant/gateway/PayJunctionGateway/purchase PayJunctionGateway ActiveMerchant/operation/. * ActiveMerchant/operation/purchase purchase For more information, see the ActiveMerchant website. ActiveRecord ActiveRecord is the Object-Relational Mapping API used by Ruby on Rails applications. The metrics shown here measure the performance of ActiveRecord's find and save methods. regex sample metric legend name ActiveRecord/. * /find ActiveRecord/User/find User#find ActiveRecord/. * /save ActiveRecord/Product/save Product#save For more information, see the API documentation for ActiveRecord. Apdex Apdex is a measure of user satisfaction with page load times. Controller In Ruby on Rails applications, HTTP requests are handled by Controller actions. A Rails application has many controllers, each of which has one or more actions. When your rails application receives an http request, that request is routed to the appropriate controller and action, based on the URL of that request. That action then does whatever processing is neccesary to generate an http response, which is most often a web page, but could also be a page fragment, an xml document, or any other kind of data that is requested by the client. The following metrics track the performance of controller actions, regardless of routing, and without taking into account any network or web server effects. regex sample metric legend name Controller/. * Controller/Users/show /Users/show Controller/. * /(?! \\ (other \\ )). * Controller/Users/show /Users/show Controller$ Controller All Controller Actions ControllerCPU/ ControllerCPU/Users/Show /Users/show For more information, see the API documentation for ActionController. Errors This metric tracks the number of errors or exceptions raised while processing requests. regex sample metric legend name Errors/all Errors/all External services External service instrumentation captures calls to out-of-process services such as web services, resources in the cloud and any other network calls. It does not include other first class back-end components such as MemCache and the database. In Ruby applications we instrument the Net::Http library to capture all HTTP services. regex sample metric legend name External/ [ ^/]+/all$ External/service.example.com/all All service.example.com calls External/ External/host.aws.com/Net::Http : :POST Net::Http : :POST [ host.aws.com] External/all$ External/all External Services External/ [ ^/]+/(?!all)/ External/service.example.com/all All service.example.com calls HTTP dispatcher This metric represents a summary of the throughput and response time of all web requests. regex sample metric legend name ^HttpDispatcher$ HttpDispatcher HttpDispatcher MemCache MemCache is a popular technology that enables applications to access shared memory provided by any number of physical machines as a global cache. Applications that heavily use the database often use MemCache for performance and scalability benefits. These metrics measure the frequency and response time of calls to MemCache to read and write data from the cache. Response times should be low (less than 5 ms) for a well performing MemCache deployment. regex sample metric legend name MemCache/. * MemCache/read MemCache read operations MemCache/read MemCache/read MemCache read operations MemCache/write MemCache/write MemCache write operations Mongrel This metric measures the length of the mongrel queue, which holds pending http requests to be processed by mongrel. The HTTP Activity graph overlays the maximimum queue length for a given period. The value is zero if mongrel is processing a request but has no other requests waiting in its queue. When looking at this value across an aggregate cluster of mongrels, the queue lengths of all mongrels is added together, showing the sum of all queue lengths. A mongrel queue length should be at or near zero; if it is consistently at a higher level, then it indicates that your rails application is having trouble keeping up with its load requirements. regex sample metric legend name Mongrel/Queue Length Mongrel/Queue Length Queue Length View ActionView is a package in Rails that is used to render the output that is the response to an http request, such as an html page or an xml document. The View is rendered by the controller that is handling the request. If View metrics represent a large portion of your controller's response time, it could mean you are doing a lot of database operations inside the view template itself. regex sample metric legend name View/. * View/Users/ _ child.html.erb/Partial Users/ _ child.html.erb View/. * /Partial View/Users/ _ child.html.erb/Partial Users/ _ child.html.erb View/. * /Rendering View/Users/show.html.erb/Rendering Users/show.html.erb For more information, see the API documentation for ActionView. Metrics attached to events (used by Infrastructure, other products) Because event-type data can have any type of key-value pair data attached to it, one way metrics can be reported is as attributes attached to an event. A couple examples of this at New Relic: Our infrastructure monitoring reports many metrics that are attached to events. For example, we report a ProcessSample event, which has various sample-based metrics attached to it, like CPU percentage. To learn more about infrastructure monitoring data, see Infrastructure data. In APM, the Transaction event has several metrics attached to it, including databaseDuration. To learn more about this data and how to query it, see Events. Metrics as a computation of events (used in some charts and queries) Metrics can be formed by counting New Relic events, or doing some other mathematical calculation on those events. For example, if you wanted to measure the total number of Transaction events over the last half hour, you might run this NRQL query: Select count(*) from Transaction since 30 minutes ago Copy Another example: if you wanted to compute the average response time for your service, you might run a query like: FROM Transaction SELECT average(duration) SINCE 30 minutes ago Copy Some New Relic charts are generated with these kinds of queries. The downside of this approach is that there are limits on how many events a monitoring system (including ours) can report. This means that sometimes, for high-throughput systems, the count may not accurately represent the total activity on that system. To learn more about how this can be addressed, see Event limits and sampling. Want to report custom metrics? See Get data into New Relic. Event data First, we’ll explain the definition of events from a monitoring industry perspective, and then we’ll explain some specifics about how New Relic handles event data. Events in the monitoring industry In the software industry, events can be thought of as simply “things that occur in a system.” For example, a server setting being changed would be an event. Another example: a website user clicking a mouse. Some events will generate a stored record, and that record is typically also called an event. Event data represents discrete occurrences and typically will have a high level of detail, so event data is suited for detailed analysis and querying. The downside to the use of event data is that there are typically so many events reported that it can become difficult to query that large dataset over longer time ranges. Events at New Relic At New Relic, we report events to data objects also called events. These events have multiple attributes (key-value pairs) attached. Event data is used in some UI charts and tables, and you can also query it. How long event data remains available is determined by data retention rules. One example of an event: APM reports an event type named Transaction, which represents a logical unit of work in an application. To see the attributes attached to this event, you could use a NRQL query like: Select * from Transaction Copy For examples of querying event data, see Introduction to NRQL. Other details about New Relic event data: Events can have any type of attributes attached. Some events have attributes that report metric data. You can report custom events. To increase the availability of your event data for querying/charting, you can turn events into metrics. Some systems generate a large number of events that exceeds collection limits and results in incomplete query results. For more on this, see Event sampling. Because event is a general term, in some New Relic contexts it will refer to any data type that can be queried via NRQL. For example, when you run a NRQL query, it returns a count of inspected events: this is a count of all data types queried. Log data First, we’ll explain the definition of logs from a monitoring industry perspective, and then we’ll explain some specifics about how New Relic handles log reporting. Logs in the monitoring industry A log is a message about a system used to understand the activity of the system and to diagnose problems. Logs at New Relic New Relic's Logs gives you a centralized log management platform that connects your log data with other New Relic-monitored data. For example, you can see logs alongside your APM data. In New Relic, log data is reported with multiple attributes (key-value data) attached. To query your log data, you could use a NRQL query like: Select * from Log Copy To report custom log data, see the Log API. Trace data First, we’ll explain the definition of traces from a monitoring industry perspective, and then we’ll explain some specifics about how New Relic handles tracing. Tracing in the monitoring industry In the application/infrastructure-monitoring world, tracing is a general term used to refer to various ways to report information about how a program or system is operating. For example, a stack trace provides in-depth information about a program’s subroutines. For large modern systems, which are often distributed across many services and micro-services, “tracing” often refers to distributed tracing, which is a way to monitor requests as they propagate through a complex, distributed environment. Tracing at New Relic New Relic offers a distributed tracing feature that tracks requests across a distributed system, and provides a dedicated UI for understanding and analyzing your traces. In New Relic, trace data is reported as Span objects, with multiple attributes (key-value pairs) attached. To query your tracing data, you could use a NRQL query like: Select * from Span Copy To learn more about how distributed tracing works, see Understand distributed tracing. To report custom distributed tracing data, see the Trace API. Query and send data Understanding New Relic data types can help you: Query data in New Relic Send data to New Relic Learn more For a simpler explanation of these data types using real-world examples, see Introduction to essential telemetry data types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 218.61765,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic <em>data</em> types",
        "sections": "<em>Get</em> <em>started</em>",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": "The New Relic platform is built around the four fundamental telemetry <em>data</em> types we believe are necessary for complete and effective system monitoring: metrics, events, logs, and traces. <em>Get</em> <em>started</em> This doc will give you a fairly technical explanation of our core <em>data</em> types, their structure"
      },
      "id": "6045280de7b9d266e1579a0f"
    }
  ],
  "/docs/data-apis/ingest-apis/introduction-event-api": [
    {
      "sections": [
        "Telemetry SDKs: Report custom telemetry data",
        "Requirements and compatibility",
        "Tip",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one",
        "Integrations built with the Telemetry SDKs"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "d883a07b7ede4c3beaba4077c507b95f9a228435",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/telemetry-sdks-report-custom-telemetry-data/",
      "published_at": "2021-10-24T19:37:31Z",
      "updated_at": "2021-10-23T17:26:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the Metric API, Trace API, Log API, and Event API. We offer open-source integrations for telemetry tools like Prometheus, Istio, and OpenCensus that were created using our Telemetry SDKs. If those solutions (or our other integrations) don't meet your needs, you can use the Telemetry SDKs to create your own telemetry data solutions. Requirements and compatibility The Telemetry SDKs use our Metric API, Event API, Log API, and Trace API, which all require a license key, so you'll need a license key for the account you wish to send data to. Tip New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported New Relic data types Java Java library on GitHub Metrics Events Logs Traces Node/TypeScript NodeJS library on GitHub Metrics Traces Python Python library on GitHub Metrics Events Logs Traces Go Go library on Github Metrics Traces .NET .NET library on GitHub .NET package in NuGet Metrics Traces C C library on Github Traces Rust Rust library on Github Traces Ruby Ruby library on Github Gem on Rubygems Traces For more on the supported data types, see: An overview of New Relic data types Metrics: see the Metric API Logs: see the Log API Traces: see the Trace API Events: see the Event API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications. Integrations built with the Telemetry SDKs To see the integrations built using our Telemetry SDKs, see Open source telemetry integrations. For all monitoring solutions, see our integrations page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.4125,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Telemetry SDKs: Report custom telemetry <em>data</em>",
        "sections": "Telemetry SDKs: Report custom telemetry <em>data</em>",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": "Our Telemetry SDKs are an open source set of <em>API</em> client libraries that send <em>data</em> to the New Relic platform. Under the hood, these SDKs rely on our core <em>data</em> <em>ingest</em> <em>APIs</em>: the Metric <em>API</em>, Trace <em>API</em>, Log <em>API</em>, and Event <em>API</em>. We offer open-source integrations for telemetry tools like Prometheus, Istio"
      },
      "id": "603ea196196a670192a83d83"
    },
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "3d1e1c9bdb5d2cbf172eb055dc83020e39dbd16b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/metric-api/introduction-metric-api/",
      "published_at": "2021-10-24T20:15:16Z",
      "updated_at": "2021-10-23T17:26:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. Want to try out our Metric API? Create a New Relic account for free! No credit card required. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. You'll need a New Relic license key for the New Relic account you want to send data to. For information on limits and restricted attributes, see Metric API requirements and limits. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting See Troubleshoot an NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.4125,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the Metric <em>API</em>",
        "sections": "Find <em>and</em> use your <em>data</em>",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": ", OpenCensus, and Prometheus). The Metric <em>API</em> is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our <em>data</em>-<em>ingest</em> <em>APIs</em>. The Metric <em>API</em> can be used to: Report metric <em>data</em> to New Relic without a New Relic agent. Integrate metric <em>data</em> from an open source"
      },
      "id": "6107858fe7b9d2f9dcfc108e"
    },
    {
      "sections": [
        "Troubleshoot Metric API with NRIntegrationError events",
        "Problem",
        "Solution",
        "View error details",
        "Match errors to ingested payloads",
        "Programmatically retrieve NrIntegrationError events",
        "Tip"
      ],
      "title": "Troubleshoot Metric API with NRIntegrationError events",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "50ad21a895fc1f2644bdbfbadf85ecfd298b08d6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/metric-api/troubleshoot-nrintegrationerror-events/",
      "published_at": "2021-10-24T20:16:09Z",
      "updated_at": "2021-10-23T17:26:33Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You sent metric data points to the Metric API, and are not seeing what you expect when querying the data. Use the following checklist to determine the root cause: Make sure you are querying the data correctly. Check the HTTP status codes returned by the API. Issues like authorization failures can be diagnosed with HTTP status codes. If you are sending data from a Prometheus server via New Relic's remote_write endpoint, check your Prometheus server logs for errors or non-2xx HTTP responses from the New Relic endpoint. Query your account for NrIntegrationError events. New Relic's ingestion endpoints are asynchronous, meaning the endpoint verifies the payload after it returns the HTTP response. If any issues occur while verifying your payload, then an NrIntegrationError event will be created in your account. New Relic also uses NrIntegrationError events to notify customers when various rate limits have been reached. Solution View error details For an introduction to using the NrIntegrationError event, see NrIntegrationError. Here's an example NRQL for examining issues with Metric API ingest: SELECT count(*) FROM NrIntegrationError WHERE newRelicFeature = 'Metrics' facet category, message limit 100 since 24 hours ago Copy The category indicates the type of error and the message provides more detailed information about the error. If the category is rateLimit, then you should also examine the rateLimitType field for more information on the type of rate limiting. Category rateLimitType Description and solution BadRequest (not set) There is an issue with the JSON payload. These include JSON syntax errors, attribute names, or values that are too long. Check the message field to determine the exact issue. Then review the JSON payload, and update it to ensure it meets the proper semantic guidelines. RateLimit DatapointsPerMinute You are sending too many datapoints per minute. If you get this error, you can either send data less frequently, or request changes to your metric rate limits by contacting your New Relic account representative, or visiting our Support portal. RateLimit UniqueTimeseriesPerDay You have an attribute with a high number of unique values, like containerId or URI. To resolve this error, review any attributes that may be causing the issue and remove them. If desired, you can use a data dropping rule to remove attributes at ingest time. RateLimit UniquePrometheusTimeseries You have Prometheus servers reporting too many unique timeseries via New Relic's remote_write endpoint. Reduce the number of unique timeseries reported by modifying your Prometheus server configuration to reduce the number of targets being scraped, or by using relabel rules in the remote_write section of your server configuration to drop timeseries or highly unique labels. RateLimit RequestsPerMinute Too many requests per minute are being sent. To resolve this, put more datapoints in each request, and send them less frequently. RateLimit ErrorGroupsPerDay You have exceeded your daily error group limit. Incoming error groups will be dropped for the remainder of the day and will continue as normal after UTC midnight. To resolve this, reduce the amount of unique error messages collected by New Relic. Match errors to ingested payloads When an NrIntegrationError event is created as a result of a syntax issue with the HTTP request payload, then the event contains the attributes apiKeyPrefix and requestId. The apiKeyPrefix matches the first 6 characters of the API key used to send the data. The requestId matches the requestId sent in the HTTP response. To view these fields, run this NRQL query: SELECT message, apiKeyPrefix, requestId FROM NrIntegrationError limit 100 Copy To verify a specific requestId, run this NRQL query: SELECT * FROM NrIntegrationError where requestId ='REQUEST_ID' Copy Programmatically retrieve NrIntegrationError events To programmatically retrieve these errors: Ensure you have an Insights query API key (go to insights.newrelic.com > Manage data > API keys). Create an HTTP request as shown below: Tip If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. curl -H \"Accept: application/json\" -H \"X-Query-Key:YOUR_API_KEY_HERE\" \"https://insights-api.newrelic.com/v1/accounts/YOUR_ACCOUNT_HERE/query?nrql=SELECT%20*%20FROM%20NrIntegrationError%20where%20newRelicFeature='Metrics'\" Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.4125,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshoot Metric <em>API</em> with NRIntegrationError events",
        "sections": "Troubleshoot Metric <em>API</em> with NRIntegrationError events",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": " To programmatically retrieve these errors: Ensure you have an Insights query <em>API</em> key (go to insights.newrelic.com &gt; <em>Manage</em> <em>data</em> &gt; <em>API</em> keys). Create an HTTP request as shown below: Tip If your account hosts <em>data</em> in the EU <em>data</em> center, ensure you&#x27;re using the proper <em>API</em> endpoints for EU region accounts. curl -H"
      },
      "id": "610f2900196a678a5d38ad82"
    }
  ],
  "/docs/data-apis/ingest-apis/metric-api/NRQL-high-cardinality-metrics": [
    {
      "sections": [
        "Query infrastructure dimensional metrics with NRQL",
        "BETA FEATURE",
        "Why it matters",
        "Get started",
        "Where and how to query dimensional metrics",
        "Naming conventions for metrics and attributes",
        "Examples",
        "AWS EBS query example",
        "Azure Service bus query example",
        "Azure functions query example",
        "Azure VMs query example",
        "NGINX query example",
        "MySQL query example",
        "Known limitations"
      ],
      "title": "Query infrastructure dimensional metrics with NRQL",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "a131af1f3655ef8b78acfccf8be619c43cb2c51e",
      "image": "https://docs.newrelic.com/static/916ce526afc3e8c7d9ea1325f1fdb980/1b853/naming-convention.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/query-infrastructure-dimensional-metrics-nrql/",
      "published_at": "2021-10-24T18:44:23Z",
      "updated_at": "2021-09-14T20:46:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. Dimensional metrics are an industry standard for storing and querying metric data. All infrastructure metrics are stored as event data in New Relic, but you can also query them through dimensional metrics. In this page you can learn: The benefits of dimensional metrics. A few examples on how and where to use them. Known issues. Why it matters At New Relic we report metrics in several ways, including dimensional metrics, which are used by our metric API, Telemetry SDK, some open-source integrations, and our infrastructure services. This type of metric enables you to: Enjoy an improved query experience for Infrastructure data. Discover all your metrics in one place. Tap into more metric sources, such as Prometheus. For example, the query to get the maximum duration of your Lambda functions is simplified: Query with samples FROM ServerlessSample SELECT max(provider.duration.Maximum) WHERE provider = 'LambdaFunction' Copy Query with metrics FROM Metric SELECT max(aws.lambda.function.duration) Copy Get started No agent or integration updates are required to use these metrics. NRQL alerting based on dimensional metrics is also supported, except for data coming from cloud integrations (that is metrics from AWS polling integrations, GCP, and Azure). AWS CloudWatch Metric Streams metrics are ingested as dimensional metrics and NRQL alerts are recommended. Where and how to query dimensional metrics All current NRQL query features are supported. Queries can use WHERE, FACET, and time selection functions such as SINCE, UNTIL, and COMPARE WITH. The query builder in New Relic One supports metrics in both simple and advanced (NRQL) mode. Naming conventions for metrics and attributes All metric names and attributes for dimensional metrics follow the same naming convention in order to make them easy to find and use. Metric and attribute names are namespaced with dots: for example, the host. prefix is used for host metrics, the k8s. prefix is used for Kubernetes metrics, and aws. is used for AWS metrics. The graphic below shows how a ProcessSample that contains three metrics (cpuPercent, ioTotalReadBytes, and ioTotalWriteBytes) is split into three separate metrics. Note the updated naming of the metrics and the attributes. Dimensional metrics naming convention Examples Here are some examples of NQRL queries with and without dimensional metrics: AWS EBS query example Get the total write time by EBS Volume. Query with samples FROM BlockDeviceSample SELECT sum('provider.volumeTotalWriteTime.Sum') WHERE provider = 'EbsVolume' FACET entityName Copy Query with metrics FROM Metric SELECT sum(aws.ebs.volume.TotalWriteTime) FACET entity.name Copy Azure Service bus query example Maximum number of messages in an Azure Service Bus topic by resource group. Query with samples FROM AzureServiceBusTopicSample SELECT max(activeMessages.Maximum) FACET resourceGroupName Copy Query with metrics FROM Metric SELECT max(azure.servicebus.topic.activeMessages) FACET azure.resourceGroup Copy Azure functions query example Number of function executions Azure Functions over the past 6 hours by region over time. Query with samples FROM AzureFunctionsAppSample SELECT sum(functionExecutionCount.Total) FACET regionName TIMESERIES SINCE 6 hours ago Copy Query with metrics FROM Metric SELECT sum(azure.functions.app.functionExecutionCount) FACET azure.region TIMESERIES SINCE 6 hours ago Copy Azure VMs query example Compare the number of Azure VMs over the past thirty minutes with the same time a week ago. Query with samples FROM AzureVirtualMachineScaleSetSample SELECT uniqueCount(vMName) FACET name SINCE 30 MINUTES AGO COMPARE WITH 1 WEEK AGO Copy Query with metrics FROM Metric SELECT uniqueCount(azure.vms.vmName) FACET azure.resourceName WHERE azure.resourceType='Microsoft.Compute/virtualMachineScaleSets' SINCE 30 MINUTES AGO COMPARE WITH 1 WEEK AGO Copy NGINX query example The average number of NGINX requests per second over time. Query with samples FROM NginxSample SELECT average(net.requestsPerSecond) TIMESERIES Copy Query with metrics FROM Metric SELECT average(nginx.server.net.requestsPerSecond) TIMESERIES Copy MySQL query example The maximum number of used MySQL connections. Query with samples FROM MysqlSample SELECT max(net.maxUsedConnections) Copy Query with metrics FROM Metric SELECT max(mysql.node.net.maxUsedConnections) Copy Known limitations Metric queries with * do not return Infrastructure sample data (for example, SELECT * FROM Metric). In order to select attributes starting with tags. a metric name has to be provided. For example, SELECT uniques(tags.environment) FROM Metric WHERE metricName='aws.lambda.function.duration' does not work without the WHERE clause. Results may not be complete if the selection criteria matches too many samples. For example, SELECT uniqueCount(entity.guid) FROM Metric maps to all Infrastructure samples, and may return incomplete results. Initially there is no support for the newly introduced metric wildcarding feature (for example, SELECT average(host.swap%Bytes) FROM Metric).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 218.922,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Query</em> infrastructure dimensional metrics with <em>NRQL</em>",
        "sections": "<em>Query</em> infrastructure dimensional metrics with <em>NRQL</em>",
        "tags": "<em>NRQL</em>: <em>New</em> <em>Relic</em> <em>Query</em> <em>Language</em>",
        "body": "BETA FEATURE This feature is currently in beta. Dimensional metrics are an industry standard for storing and querying metric <em>data</em>. All infrastructure metrics are stored as event <em>data</em> in <em>New</em> <em>Relic</em>, but you can also <em>query</em> them through dimensional metrics. In this page you can learn: The benefits"
      },
      "id": "603e95e8e7b9d286642a07fa"
    },
    {
      "sections": [
        "NRQL query examples for mobile monitoring",
        "Mobile, MobileSession, and MobileCrash event query examples",
        "Interactions: Which interactions are most popular among my users?",
        "Location: Which regions of China have the most users?",
        "Device profile: How many users use the latest OS versions?",
        "App version: Have we seen an increase in session duration since yesterday's release?",
        "Performance: How much memory does my app use for sessions longer than 5 seconds?",
        "Crashes: What are my app's most common crashes?",
        "Crash rate: What is the crash rate for different versions of my app?",
        "MobileRequest event query examples",
        "Error rate by request domain",
        "Error rate for business-critical API",
        "Response time percentiles of important APIs",
        "Volume of network requests",
        "Slow response user impact",
        "Response time distribution by domain, carrier, ASN owner, country, etc.",
        "Percentile response time",
        "Requests per session",
        "MobileRequestError event query examples",
        "HTTP errors",
        "Network failures",
        "Error rate: Percentage of users impacted",
        "Errors by version",
        "Unique devices (by UUID)",
        "Historical HTTP error counts",
        "MobileHandledException event query examples",
        "App exceptions",
        "Top exception locations",
        "Most common interaction generating exceptions",
        "Most common exception message",
        "Most common method reporting exceptions",
        "Handled exception rate"
      ],
      "title": "NRQL query examples for mobile monitoring",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "2844422852b86681e69a3ef9333f2268deacbecb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nrql-query-examples-mobile-monitoring/",
      "published_at": "2021-10-24T20:11:53Z",
      "updated_at": "2021-08-03T00:46:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are several ways to query your data. This document will show you some example NRQL queries from mobile monitoring data. To see descriptions of the mobile-reported events and attributes available, see Mobile events. Mobile, MobileSession, and MobileCrash event query examples Mobile queries allow you to understand and compare a wide variety of mobile data, including interactions, location, device profile, app version, crashes, and performance. These examples use queries made on the Mobile, MobileSession, and MobileCrash event types: Interactions: Which interactions are most popular among my users? SELECT uniqueCount(uuid) FROM Mobile SINCE 1 day ago FACET name Copy Location: Which regions of China have the most users? SELECT uniqueCount(uuid) FROM MobileSession WHERE countryCode='CN' FACET regionCode SINCE 7 days ago Copy Device profile: How many users use the latest OS versions? SELECT uniqueCount(uuid) FROM MobileSession FACET osVersion SINCE 7 days ago Copy App version: Have we seen an increase in session duration since yesterday's release? SELECT percentile(sessionDuration, 90) FROM MobileSession since 1 day ago compare with 2 days ago Copy Performance: How much memory does my app use for sessions longer than 5 seconds? SELECT histogram(memUsageMb) FROM MobileSession WHERE sessionDuration > 5 Copy Crashes: What are my app's most common crashes? SELECT count(*) FROM MobileCrash FACET crashException Copy Crash rate: What is the crash rate for different versions of my app? SELECT percentage(uniqueCount(sessionId), WHERE category = 'Crash') as `Crash rate` FROM MobileSession, MobileCrash facet appVersion since 90 days ago Copy MobileRequest event query examples This feature requires mobile monitoring agent version 5.14.0 or higher. MobileRequest data is enabled by default for: Android version 5.15.2 or higher iOS version 6.0.0 or higher For earlier versions, starting with Android version 5.14.0 or iOS version 5.14.0, you must enable the feature. Upgrade to the latest Android or iOS version, or add the required feature flag to your app. Below are some NRQL queries that address common use cases. Use the MobileRequest attributes to make your own NRQL queries. The last two examples use MobileRequestError events in addition to MobileRequest to get an error rate. Error rate by request domain Which domains are prone to failure and error? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestDomain Copy Error rate for business-critical API What is the error rate seen by our mobile apps for the most business-critical API? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestPath where requestPath = '{MY_API_PATH}' Copy Response time percentiles of important APIs For important requests in the 90th percentile, what is the response time by URL? SELECT percentile(responseTime, 90), latest(requestUrl) as 'Latest URL' from MobileRequest facet cases(where requestUrl like '%{YOUR_CORE_API}%' as 'Core API', where requestUrl like '%{YOUR_FEATURE_API}%' as 'New Feature API') Copy Volume of network requests How much network traffic from the apps are backend services receiving? SELECT count(*) FROM MobileRequest FACET requestDomain since 3 days ago Copy Slow response user impact What % of users are impacted by http response times greater than 3 seconds? SELECT filter(uniqueCount(MobileRequest.uuid), WHERE responseTime > 3) / uniqueCount(MobileSession.uuid) * 100 as '% Users Impacted' FROM MobileRequest, MobileSession since 1 day ago timeseries compare with 2 days ago Copy Response time distribution by domain, carrier, ASN owner, country, etc. What is the distribution of response time and request count across domain, country, carrier, or ASN owner? SELECT histogram(responseTime, 20, 20) FROM MobileRequest since 3 days ago facet asnOwner Copy Percentile response time What is the breakdown of response time by different percentiles? SELECT percentile(responseTime, 98) as '98 percentile (sec)', percentile(responseTime, 90) as '90 percentile (sec)', percentile(responseTime, 50) as '50 percentile (sec)' from MobileRequest since 3 days ago Copy Requests per session How do requests per session compare across different apps or subsequent builds of those apps? SELECT count(*)/uniqueCount(sessionId) from MobileRequest, MobileSession facet appName timeseries Copy MobileRequestError event query examples Below are some NRQL queries that address common use cases. Use the MobileRequestError attributes to make your own NRQL queries. HTTP errors Which queries are causing the most errors? SELECT count(*) FROM MobileRequestError where errorType = 'HTTPError' FACET requestUrl Copy Network failures What network failures are most common for my application? SELECT count(*) FROM MobileRequestError where errorType = 'NetworkFailure' facet networkError Copy Error rate by request domain Which domains are prone to failure and error? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestDomain Copy Error rate for business-critical API What is the error rate in our mobile apps for the most business-critical API? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestPath where requestPath = '{MY_API_PATH}' Copy Error rate: Percentage of users impacted How many users are experiencing errors as compared to my total user count? SELECT filter(uniqueCount(MobileRequestError.uuid), WHERE errorType = 'HTTPError') / uniqueCount(MobileSession.uuid) * 100 as '% Users Impacted by Errors' FROM MobileRequestError, MobileSession COMPARE WITH 7 days AGO Copy Errors by version Which version(s) of my app are causing the most errors? SELECT count(*) FROM MobileRequestError FACET appVersion Copy Unique devices (by UUID) Which unique devices (by UUID) are having the most issues with my application? SELECT count(*), latest(device), latest(carrier), latest(asnOwner), latest(countryCode) FROM MobileRequestError FACET deviceUuid limit 100 SINCE 1 days ago Copy Historical HTTP error counts What does my historical HTTP Error count look like (by domain)? SELECT count(*) FROM MobileRequestError where errorType = 'HTTPError' FACET requestDomain timeseries Copy MobileHandledException event query examples Below are some NRQL queries for common handled exception use cases. Use the MobileHandledException attributes to make your own NRQL queries. App exceptions Which apps have reported the most number of handled exceptions? SELECT count(*) FROM MobileHandledException FACET appName SINCE 3 days ago Copy Top exception locations What are most common exception locations for my application? How many exceptions do we have, and where do they occur? SELECT count(*) FROM MobileHandledException FACET exceptionLocation SINCE 3 days ago Copy Most common interaction generating exceptions Which interaction produces the most exceptions? SELECT count(*) FROM MobileHandledException FACET lastInteraction SINCE 3 days ago Copy Most common exception message What are the most common reported exception messages? SELECT count(*) FROM MobileHandledException FACET exceptionMessage SINCE 3 days ago Copy Most common method reporting exceptions What are the most common methods reporting exceptions? SELECT count(*) FROM MobileHandledException FACET exceptionLocationMethod SINCE 3 days ago Copy Handled exception rate How often are handled exceptions encountered by our users? SELECT percentage(uniqueCount(sessionId), WHERE exceptionLocation IS NOT NULL) FROM MobileSession,MobileHandledException SINCE 3 days ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 200.95103,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NRQL</em> <em>query</em> examples for mobile monitoring",
        "sections": "<em>NRQL</em> <em>query</em> examples for mobile monitoring",
        "tags": "<em>NRQL</em>: <em>New</em> <em>Relic</em> <em>Query</em> <em>Language</em>",
        "body": "There are several ways to <em>query</em> <em>your</em> <em>data</em>. This document will show you some example <em>NRQL</em> queries from mobile monitoring <em>data</em>. To see descriptions of the mobile-reported events and attributes available, see Mobile events. Mobile, MobileSession, and MobileCrash event <em>query</em> examples Mobile queries"
      },
      "id": "60445a6128ccbc6b6a2c60ca"
    },
    {
      "sections": [
        "NRQL syntax, clauses, and functions",
        "Syntax",
        "Query components",
        "Required clauses",
        "Required: SELECT statement",
        "Avg response time since last week",
        "Required: FROM clause",
        "Query one data type",
        "Query multiple data types",
        "Optional clauses",
        "AS clause",
        "Query using math function and AS",
        "Query using funnel and AS",
        "COMPARE WITH clause",
        "EXTRAPOLATE clause",
        "Important",
        "Example of extrapolating throughput",
        "Example of extrapolating throughput as a time series",
        "FACET clause",
        "Faceted query using count()",
        "Faceted query using uniqueCount()",
        "Grouping results across time",
        "FACET ... AS clause",
        "FACET CASES clause",
        "Basic usage with WHERE",
        "Group based on multiple attributes",
        "Label groups with AS",
        "Facet non-matching data with OR",
        "FACET ... ORDER BY clause",
        "Tip",
        "LIMIT clause",
        "Query using LIMIT",
        "OFFSET clause",
        "ORDER BY clause",
        "SHOW EVENT TYPES clause",
        "Data types in the last day",
        "SINCE clause",
        "SLIDE BY clause",
        "Use SLIDE BY with MAX or AUTO interval",
        "TIMESERIES clause",
        "Use a set interval",
        "Use an automatically set interval",
        "Use MAX interval",
        "UNTIL clause",
        "WHERE clause",
        "Example query with three conditions",
        "WITH METRIC_FORMAT clause",
        "WITH TIMEZONE clause",
        "Query metric data",
        "Functions",
        "Aggregator functions",
        "aggregationendtime()",
        "apdex(attribute, t: )",
        "Get Apdex for specific customers",
        "Get Apdex for specific transaction",
        "Get overall Apdex for your app",
        "average(attribute)",
        "buckets(attribute, ceiling [,number of buckets])",
        "bucketPercentile(attribute)",
        "cardinality(attribute)",
        "count(*)",
        "derivative(attribute [,time interval])",
        "dimensions(include: {attributes}, exclude: {attributes})",
        "latestrate(attribute, time interval)",
        "Get the most recent rate of change of PageView Duration",
        "max(attribute)",
        "median(attribute)",
        "Median query",
        "min(attribute)",
        "minuteOf(attribute)",
        "mod(attribute, divisor)",
        "mod() within a WHERE clause condition",
        "mod() within a FACET clause",
        "percentage(function(attribute), WHERE condition)",
        "percentile(attribute [, percentile [, ...]])",
        "Basic percentile query",
        "predictLinear(attribute, [,time interval])",
        "rate(function(attribute) [,time interval])",
        "Basic rate query",
        "round(attribute)",
        "stddev(attribute)",
        "stdvar(attribute)",
        "sum(attribute)",
        "uniqueCount(attribute)",
        "uniques(attribute [,limit])",
        "Using tuple",
        "capture(attribute, regular expression)",
        "capture() within a SELECT clause condition",
        "capture() within a FACET clause condition",
        "capture() within a WHERE clause condition",
        "capture() with a numeric cast",
        "Non-aggregator functions",
        "earliest(attribute)",
        "Get earliest country per user agent from PageView",
        "eventType()",
        "Use eventType() in filter() function",
        "Use eventType() with FACET",
        "filter(function(attribute), WHERE condition)",
        "Analyze purchases that used offer codes",
        "funnel(attribute, steps)",
        "getField(attribute, field)",
        "histogram(attribute, ceiling [,number of buckets])",
        "Histogram of response times from PageView events",
        "Prometheus histogram buckets",
        "New Relic distribution metric",
        "Histogram with a FACET clause",
        "keyset()",
        "See all attributes for a data type",
        "latest(attribute)",
        "Get most recent country per user agent from PageView",
        "Type conversion"
      ],
      "title": "NRQL syntax, clauses, and functions",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "Get started"
      ],
      "external_id": "97c38ce7950d354d9f1d9efa5f432326f9bb4b00",
      "image": "https://docs.newrelic.com/static/507a44dd5750a7c536bee652e105179f/8c557/screen-apdex-function.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/",
      "published_at": "2021-10-25T01:00:47Z",
      "updated_at": "2021-09-27T14:48:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NRQL is a query language you can use to query the New Relic database. This document explains NRQL syntax, clauses, components, and functions. Syntax This document is a reference for the functions and clauses used in a NRQL query. Other resources for understanding NRQL: Intro to NRQL: explains what NRQL is used for, what data you can query with it, and basic NRQL syntax Examine NRQL queries used to build New Relic charts Learn how to query the Metric data type Use funnels to evaluate a series of related data Format NRQL for querying with the Event API Query components Every NRQL query will begin with a SELECT statement or a FROM clause. All other clauses are optional. The clause definitions below also contain example NRQL queries. Required clauses Required: SELECT statement SELECT attribute ... Copy SELECT function(attribute) ... Copy The SELECT specifies what portion of a data type you want to query by specifying an attribute or a function. It's followed by one or more arguments separated by commas. In each argument you can: Get the values of all available attributes by using * as a wildcard. For example: SELECT * from Transaction. Get values associated with a specified attribute or multiple attributes specified in a comma separated list. Get aggregated values from specified attributes by selecting an aggregator function. Label the results returned in each argument with the AS clause. You can also use SELECT with basic math functions. Avg response time since last week This query returns the average response time since last week. SELECT average(duration) FROM PageView SINCE 1 week ago Copy Required: FROM clause SELECT ... FROM data type ... Copy Use the FROM clause to specify the data type you wish to query. You can start your query with FROM or with SELECT. You can merge values for the same attributes across multiple data types in a comma separated list. Query one data type This query returns the count of all APM transactions over the last three days: SELECT count(*) FROM Transaction SINCE 3 days ago Copy Query multiple data types This query returns the count of all APM transactions and browser events over the last three days: SELECT count(*) FROM Transaction, PageView SINCE 3 days ago Copy Optional clauses AS clause SELECT ... AS 'label' ... Copy Use the AS clause to label an attribute, aggregator, step in a funnel, or the result of a math function with a string delimited by single quotes. The label is used in the resulting chart. Query using math function and AS This query returns the number of page views per session: SELECT count(*)/uniqueCount(session) AS 'Pageviews per Session' FROM PageView Copy Query using funnel and AS This query returns a count of people who have visited both the main page and the careers page of a site over the past week: SELECT funnel(SESSION, WHERE name='Controller/about/main' AS 'Step 1', WHERE name = 'Controller/about/careers' AS 'Step 2') FROM PageView SINCE 1 week ago Copy COMPARE WITH clause SELECT ... (SINCE or UNTIL) (integer units) AGO COMPARE WITH (integer units) AGO ... Copy Use the COMPARE WITH clause to compare the values for two different time ranges. COMPARE WITH requires a SINCE or UNTIL statement. The time specified by COMPARE WITH is relative to the time specified by SINCE or UNTIL. For example, SINCE 1 day ago COMPARE WITH 1 day ago compares yesterday with the day before. The time range for theCOMPARE WITH value is always the same as that specified by SINCE or UNTIL. For example, SINCE 2 hours ago COMPARE WITH 4 hours ago might compare 3:00pm through 5:00pm against 11:00am through 1:00pm. COMPARE WITH can be formatted as either a line chart or a billboard: With TIMESERIES, COMPARE WITH creates a line chart with the comparison mapped over time. Without TIMESERIES, COMPARE WITH generates a billboard with the current value and the percent change from the COMPARE WITH value. Example: This query returns data as a line chart showing the 95th percentile for the past hour compared to the same range one week ago. First as a single value, then as a line chart. SELECT percentile(duration) FROM PageView SINCE 1 week ago COMPARE WITH 1 week AGO SELECT percentile(duration) FROM PageView SINCE 1 week ago COMPARE WITH 1 week AGO TIMESERIES AUTO Copy EXTRAPOLATE clause You can use this clause with these data types: Transaction TransactionError Custom events reported via APM agent APIs The purpose of EXTRAPOLATE is to mathematically compensate for the effects of APM agent sampling of event data so that query results more closely represent the total activity in your system. This clause will be useful when a APM agent reports so many events that it often passes its harvest cycle reporting limits. When that occurs, the agent begins to sample events. When EXTRAPOLATE is used in a NRQL query that supports its use, the ratio between the reported events and the total events is used to extrapolate a close approximation of the total unsampled data. When it is used in a NRQL query that doesn’t support its use or that hasn’t used sampled data, it has no effect. Important Note that EXTRAPOLATE is most useful for homogenous data (like throughput or error rate). It's not effective when attempting to extrapolate a count of distinct things (like uniqueCount() or uniques()). This clause works only with NRQL queries that use one of the following aggregator functions: apdex average count histogram sum percentage (if function it takes as an argument supports EXTRAPOLATE) rate (if function it takes as an argument supports EXTRAPOLATE) stddev Example of extrapolating throughput A query that will show the extrapolated throughput of a service named interestingApplication. SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago EXTRAPOLATE Copy Example of extrapolating throughput as a time series A query that will show the extrapolated throughput of a service named interestingApplication by transaction name, displayed as a time series. SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago FACET name TIMESERIES 1 minute EXTRAPOLATE Copy FACET clause SELECT ... FACET attribute ... Copy Use FACET to separate and group your results by attribute values. For example, you could FACET your PageView data by deviceType to figure out what percentage of your traffic comes from mobile, tablet, and desktop devices. Use the LIMIT clause to specify how many facets appear (default is 10). For more complex grouping, use FACET CASES. FACET clauses support up to five attributes, separated by commas. The facets are sorted in descending order by the first field you provide in the SELECT clause. If you are faceting on attributes with more than 2,000 unique values, a subset of facet values is selected and sorted according to the query type. When selecting min(), max(), or count(), FACET uses those functions to determine how facets are picked and sorted. When selecting any other function, FACET uses the frequency of the attribute you are faceting on to determine how facets are picked and sorted. Faceted query using count() This query shows cities with the highest pageview counts. This query uses the total number of pageviews per city to determine how facets are picked and ordered. SELECT count(*) FROM PageView FACET city Copy Faceted query using uniqueCount() This query shows the cities that access the highest number of unique URLs. This query uses the total number of times a particular city appears in the results to determine how facets are picked and ordered. SELECT uniqueCount(pageUrl) FROM PageView FACET city Copy Grouping results across time Advanced segmentation and cohort analysis allow you to facet on bucket functions to more effectively break out your data. Cohort analysis is a way to group results together based on timestamps. You can separate them into buckets that cover a specified range of dates and times. FACET ... AS clause Use FACET ... AS to name facets using the AS keyword in queries. This clause is helpful for adding clearer or simplified names for facets in your results. It can also be used to rename facets in nested aggregation queries. FACET ... AS queries will change the facet names in results (when they appear as headers in tables, for example), but not the actual facet names themselves. FROM Transaction SELECT count(*) FACET response.headers.contentType AS 'content type' Copy FACET CASES clause SELECT ... FACET CASES ( WHERE attribute operator value, WHERE attribute operator value, ... ) ... Copy Use FACET CASES to break out your data by more complex conditions than possible with FACET. Separate multiple conditions with a comma ,. For example, you could query your PageView data and FACET CASES into categories like less than 1 second, from 1 to 10 seconds, and greater than 10 seconds. You can combine multiple attributes within your cases, and label the cases with the AS selector. Data points will be added to at most one facet case, the first facet case that they match. You may also use a time function with your attribute, and you can use the OR operator to facet results that don't match any of your specified cases. Basic usage with WHERE SELECT count(*) FROM PageView FACET CASES (WHERE duration < 1, WHERE duration > 1 and duration < 10, WHERE duration > 10) Copy Group based on multiple attributes This example groups results into one bucket where the transaction name contains login, and another where the URL contains login and a custom attribute indicates that the user was a paid user: SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%', WHERE name LIKE '%feature%' AND customer_type='Paid') Copy Label groups with AS This example uses the AS selector to give your results a human-readable name: SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%' AS 'Total Logins', WHERE name LIKE '%feature%' AND customer_type='Paid' AS 'Feature Visits from Paid Users') Copy Facet non-matching data with OR This example uses the OR operator to facet results that didn't match any of your cases: SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%', WHERE name LIKE '%feature%' AND customer_type='Paid') OR name Copy FACET ... ORDER BY clause In NRQL, the default is for the first aggregation in the SELECT clause to guide the selection of facets in a query. FACET ... ORDER BY allows you to override this default behavior by adding an aggregate function with the ORDER BY modifier to specify how facets are selected. Specifically, the clause will override the priority by which facets are chosen to be in the final result before being limited by the LIMIT clause. This clause can be used in querying but not for alerts or streaming. This example shows how to use FACET ... ORDER BY to find the average durations of app transactions, showing the top 10 (default limit) highest durations by apps which have the highest response size. In this case, if FACET ... ORDER BY is not used, the query results will instead show the top 10 by highest durations, with response size being irrelevant to the app selection. FROM Transaction SELECT average(duration) TIMESERIES FACET appName ORDER BY max(responseSize) Copy Tip Because the operations are performed before the LIMIT clause is applied, FACET ... ORDER BY does not impact the sort of the final query results, which will be particularly noticeable in the results for non-timeseries queries. Important The ORDER BY modifier in this case works differently than the ORDER BY clause. When parsing queries that follow the format FACET attribute1 ORDER BY attribute2, New Relic will read these as FACET ... ORDER BY queries, but only if ORDER BY appears immediately after FACET. Otherwise ORDER BY will be interpreted by New Relic as a clause. LIMIT clause SELECT ... LIMIT count ... Copy Use the LIMIT clause to control the maximum number of facet values returned by FACET queries or the maximum number of items returned by SELECT * queries. This clause takes a single integer value as an argument. If the LIMIT clause is not specified, or no value is provided, the limit defaults to 10 for FACET queries and 100 in the case of SELECT * queries. The maximum allowed value for the LIMIT clause is 2,000. Query using LIMIT This query shows the top 20 countries by session count and provides 95th percentile of response time for each country for Windows users only. SELECT uniqueCount(session), percentile(duration, 95) FROM PageView WHERE userAgentOS = 'Windows' FACET countryCode LIMIT 20 SINCE YESTERDAY Copy OFFSET clause SELECT ... LIMIT count OFFSET count ... Copy Use the OFFSET clause with LIMIT to control the portion of rows returned by SELECT * or SELECT column queries. Like the LIMIT clause, OFFSET takes a single integer value as an argument. OFFSET sets the number of rows to be skipped before the selected rows of your query are returned. This is constrained by LIMIT. OFFSET rows are skipped starting from the most recent record. For example, the query SELECT interestingValue FROM Minute_Report LIMIT 5 OFFSET 1 returns the last 5 values from Minute_Report except for the most recent one. ORDER BY clause The ORDER BY clause allows you to specify how you want to sort your query results in queries that select event attributes by row. This query orders transactions by duration. FROM Transaction SELECT appName, duration ORDER BY duration Copy The default sort order is ascending, but this can be changed by adding the ASC or DESC modifiers. SHOW EVENT TYPES clause SHOW EVENT TYPES... Copy SHOW EVENT TYPES will return a list of all the data types present in your account for a specific time range. It is used as the first clause in a query instead of SELECT. Important In this context, \"event types\" refers to the data types you can access with a NRQL query. Data types in the last day This query will return all the data types present over the past day: SHOW EVENT TYPES SINCE 1 day ago Copy SINCE clause SELECT ... SINCE [numerical units AGO | phrase] ... Copy The default value is 1 hour ago. Use the SINCE clause to define the beginning of a time range for the returned data. When using NRQL, you can set a UTC timestamp or relative time range. You can specify a timezone for the query but not for the results. NRQL results are based on your system time. SLIDE BY clause The SLIDE BY clause supports a feature known as sliding windows. With sliding windows,SLIDE BY data is gathered into \"windows\" of time that overlap with each other. These windows can help to smooth out line graphs with a lot of variation in cases where the rolling aggregate (such as a rolling mean) is more important than aggregates from narrow windows of time. To use SLIDE BY, place it in a query after the TIMESERIES clause. For example, this query pulls data in 5-minute windows with a 1-minute SLIDE BY interval, meaning that each window lasts 5 minutes, but window 1 starts at 0 minutes, window 2 starts at 1 minute, window 3 starts at 2 minutes, and so on. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY 1 minute Copy To learn more about how and when you can use SLIDE BY, see Create smoother charts with sliding windows. Use SLIDE BY with MAX or AUTO interval You can use sliding windows in combination with MAX or AUTO. However, MAX or AUTO may not be placed between TIMESERIES and SLIDE BY. This query will automatically decide a SLIDE BY window interval. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO Copy This query will set the SLIDE BY window to the maximum interval granularity. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX Copy Important The SLIDE BY value as determined by AUTO or MAX can produce a step interval greater than the window size, which can cause gaps and unexpected results. TIMESERIES clause SELECT ... TIMESERIES integer units ... Copy Use the TIMESERIES clause to return data as a time series broken out by a specified period of time. Since TIMESERIES is used to trigger certain charts, there is no default value. To indicate the time range, use integer units. For example: TIMESERIES 1 minute TIMESERIES 30 minutes TIMESERIES 1 hour TIMESERIES 30 seconds TIMESERIES can be combined with arguments such as MAX, AUTO, and SLIDE BY to further tailor query results, as shown in the examples below. Important For functions such as average( ) or percentile( ), a large aggregation window can have a significant smoothing effect on outliers. This is true whether or not the query makes use of sliding windows. Use a set interval The value provided indicates the units used to break out the graph. For example, to present a one-day graph showing 30 minute increments: SELECT ... SINCE 1 day AGO TIMESERIES 30 minutes Copy Use an automatically set interval TIMESERIES can also be set to AUTO, which will divide your graph into a reasonable number of divisions. For example, a daily chart will be divided into 30 minute intervals and a weekly chart will be divided into 6 hour intervals. This query returns data as a line chart showing the 50th and 90th percentile of client-side transaction time for one week with a data point every 6 hours. SELECT average(duration), percentile(duration, 50, 90) FROM PageView SINCE 1 week AGO TIMESERIES AUTO Copy Use MAX interval You can set TIMESERIES to MAX, which will automatically adjust your time window to the maximum number of intervals allowed for a given time period. This allows you to update your time windows without having to manually update your TIMESERIES buckets and ensures your time window is being split into the peak number of intervals allowed. The maximum number of TIMESERIES buckets that will be returned is 366. For example, the following query creates 4-minute intervals, which is the ceiling for a daily chart. SELECT average(duration) FROM Transaction since 1 day ago TIMESERIES MAX Copy UNTIL clause SELECT ... UNTIL integer units AGO ... Copy The default value is NOW. Only use UNTIL to specify an end point other than the default. Use the UNTIL clause to define the end of a time range across which to return data. Once a time range has been specified, the data will be preserved and can be reviewed after the time range has ended. See Use the time picker to adjust time settings for detailed information and examples. WHERE clause Use the WHERE clause to filter results. NRQL returns the results that fulfill the condition(s) you specify in the clause. SELECT function(attribute) ... WHERE attribute [operator 'value' | IN ('value' [, 'value]) | IS [NOT] NULL ] [AND|OR ...] ... Copy If you specify more than one condition, separate the conditions by the operators AND or OR. If you want to simulate a SQL join, use custom attributes in a WHERE or FACET clause. Operators that the WHERE clause accepts Description =, !=, <, <=, >, >= NRQL accepts standard comparison operators. Example: state = 'WA' AND Used to define an intersection of two conditions. OR Used to define a union of two conditions. IS NULL Determines if an attribute has a null value. IS NOT NULL Determines if an attribute does not have a null value. IN Determines if the string value of an attribute is in a specified set. Using this method yields better performance than stringing together multiple WHERE clauses. Example: animalType IN ('cat', 'dog', 'fish') NOT IN Determines if the string value of an attribute is not in a specified set. Using this method yields better performance than stringing together multiple WHERE clauses. Values must be in parentheses, separated by commas. For example: SELECT * FROM PageView WHERE countryCode NOT IN ('CA', 'WA') Copy LIKE Determines if an attribute contains a specified sub-string. The string argument for the LIKE operator accepts the percent sign (%) as a wildcard anywhere in the string. If the substring does not begin or end the string you are matching against, the wildcard must begin or end the string. Examples: userAgentName LIKE 'IE%' IE IE Mobile userAgentName LIKE 'o%a%' Opera Opera Mini userAgentName LIKE 'o%a' Opera userAgentName LIKE '%o%a%' Opera Opera Mini Mozilla Gecko NOT LIKE Determines if an attribute does not contain a specified sub-string. RLIKE Determines if an attribute contains a specified Regex sub-string. Uses RE2 syntax. Examples: appName RLIKE r'z.*|q.*'' hostname RLIKE r'ip-10-351-[0-2]?[0-9]-.*' z-app q-app ip-10-351-19-237 ip-10-351-2-41 ip-10-351-24-238 ip-10-351-14-15 Important Regex defaults to full-string matching, therefore ^ and $ are implicit and you do not need to add them. NOT RLIKE Determines if an attribute does not contain a specified Regex sub-string. Uses RE2 syntax. Example query with three conditions This query returns the browser response time for pages with checkout in the URL for Safari users in the United States and Canada over the past 24 hours. SELECT histogram(duration, 50, 20) FROM PageView WHERE countryCode IN ('CA', 'US') AND userAgentName='Safari' AND pageUrl LIKE '%checkout%' SINCE 1 day ago Copy WITH METRIC_FORMAT clause For information on querying metric data, see Query metrics. WITH TIMEZONE clause SELECT ... WITH TIMEZONE (selected zone) ... Copy By default, query results are displayed in the timezone of the browser you're using. Use the WITH TIMEZONE clause to select a time zone for a date or time in the query that hasn't already had a time zone specified for it. For example, the query clause SINCE Monday UNTIL Tuesday WITH TIMEZONE 'America/New_York' will return data recorded from Monday at midnight, Eastern Standard Time, until midnight Tuesday, Eastern Standard Time. Available Time Zone Selections Africa/Abidjan Africa/Addis_Ababa Africa/Algiers Africa/Blantyre Africa/Cairo Africa/Windhoek America/Adak America/Anchorage America/Araguaina America/Argentina/Buenos_Aires America/Belize America/Bogota America/Campo_Grande America/Cancun America/Caracas America/Chicago America/Chihuahua America/Dawson_Creek America/Denver America/Ensenada America/Glace_Bay America/Godthab America/Goose_Bay America/Havana America/La_Paz America/Los_Angeles America/Miquelon America/Montevideo America/New_York America/Noronha America/Santiago America/Sao_Paulo America/St_Johns Asia/Anadyr Asia/Bangkok Asia/Beirut Asia/Damascus Asia/Dhaka Asia/Dubai Asia/Gaza Asia/Hong_Kong Asia/Irkutsk Asia/Jerusalem Asia/Kabul Asia/Katmandu Asia/Kolkata Asia/Krasnoyarsk Asia/Magadan Asia/Novosibirsk Asia/Rangoon Asia/Seoul Asia/Tashkent Asia/Tehran Asia/Tokyo Asia/Vladivostok Asia/Yakutsk Asia/Yekaterinburg Asia/Yerevan Atlantic/Azores Atlantic/Cape_Verde Atlantic/Stanley Australia/Adelaide Australia/Brisbane Australia/Darwin Australia/Eucla Australia/Hobart Australia/Lord_Howe Australia/Perth Chile/EasterIsland Etc/GMT+10 Etc/GMT+8 Etc/GMT-11 Etc/GMT-12 Europe/Amsterdam Europe/Belfast Europe/Belgrade Europe/Brussels Europe/Dublin Europe/Lisbon Europe/London Europe/Minsk Europe/Moscow Pacific/Auckland Pacific/Chatham Pacific/Gambier Pacific/Kiritimati Pacific/Marquesas Pacific/Midway Pacific/Norfolk Pacific/Tongatapu UTC See Set time range on dashboards and charts for detailed information and examples. Query metric data Metric data is more complex than other types of data. There are specific tips for querying it well. We have two types of metric data, each with their own query guidelines: Query dimensional metrics, which are reported by our Metric API and by some of our tools that use that API, like our Telemetry SDKs and our open-source telemetry integrations (OpenTelemetry, Kamon, Micrometer, more). Query metric timeslice data, which is our original metric data type reported by our APM, mobile monitoring, and browser monitoring. For more on understanding these data types, see Metric data types. Functions In this section we explain NRQL functions, both aggregator functions and non-aggregator functions. Aggregator functions You can use aggregator functions to filter and aggregate data. Some tips for using these: See New Relic University tutorials for Filter queries, Apdex queries, and Percentile queries. Or, go to the full online course Writing NRQL queries. If you're using an aggregator function multiple times in the same query (e.g., SELECT median(one_metric</var>), median(another_metric)), it can cause problems in displaying results. To solve this, use the AS function. For example: SELECT median(one_metric) as 'med-a', median(another_metric) as 'med-b' Data type \"coercion\" is not supported. Read about available type conversion functions. For how to display results over time, see Group results over time. Examples: SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago Copy aggregationendtime() Use the aggregationendtime() function to return the time of the relevant aggregation. More specifically, for a given aggregate, the aggregationendtime() function provides the timestamp of the end of the time period of that aggregation. For example, in a timeseries query, for a data point that encompasses an hour’s worth of data, the function would return the timestamp of the end of that hour period. apdex(attribute, t: ) Use the apdex function to return an Apdex score for a single transaction or for all your transactions. The attribute can be any attribute based on response time, such as duration or backendDuration. The t: argument defines an Apdex T threshold in the same unit of time as the chosen attribute. For instance, if the attribute is measured in seconds, t will be a threshold in seconds. The Apdex score returned by the apdex( ) function is based only on execution time. It does not account for APM errors. If a transaction includes an error but completes in Apdex T or less, that transaction will be rated satisfying by the apdex ( ) function. Get Apdex for specific customers If you have defined custom attributes, you can filter based on those attributes. For example, you could monitor the Apdex for a particularly important customer: SELECT apdex(duration, t: 0.4) FROM Transaction WHERE customerName='ReallyImportantCustomer' SINCE 1 day ago Copy Get Apdex for specific transaction Use the name attribute to return a score for a specific transaction, or return an overall Apdex by omitting name. This query returns an Apdex score for the Controller/notes/index transaction over the last hour: The apdex function returns an Apdex score that measures user satisfaction with your site. Arguments are a response time attribute and an Apdex T threshold in seconds. SELECT apdex(duration, t: 0.5) from Transaction WHERE name='Controller/notes/index' SINCE 1 hour ago Copy Get overall Apdex for your app This example query returns an overall Apdex for the application over the last three weeks: SELECT apdex(duration, t: 0.08) FROM Transaction SINCE 3 week ago Copy average(attribute) Use the average( ) function to return the average value for an attribute. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. buckets(attribute, ceiling [,number of buckets]) Use the buckets() function to aggregate data split up by a FACET clause into buckets based on ranges. You can bucket by any attribute that is stored as a numerical value in the New Relic database. It takes three arguments: Attribute name Maximum value of the sample range. Any outliers will appear in the final bucket. Total number of buckets For more information and examples, see Split your data into buckets. bucketPercentile(attribute) The bucketPercentile( ) function is the NRQL equivalent of the histogram_quantile function in Prometheus. It is intended to be used with dimensional metric data. Instead of the quantile, New Relic returns the percentile, which is the quantile * 100. Use the bucketPercentile( ) function to calculate the quantile from the histogram data in a Prometheus format. It takes the bucket name as an argument and reports percentiles along the bucket's boundaries: SELECT bucketPercentile(duration_bucket) FROM Metric SINCE 1 day ago Copy Optionally, you can add percentile specifications as an argument: SELECT bucketPercentile(duration_bucket, 50, 75, 90) FROM Metric SINCE 1 day ago Copy Because multiple metrics are used to make up Prometheus histogram data, you must query for specific Prometheus metrics in terms of the associated <basename>. For example, to compute percentiles from a Prometheus histogram, with the <basename> prometheus_http_request_duration_seconds using NRQL, use bucketPercentile(prometheus_http_request_duration_seconds_bucket, 50). Note how _ bucket is added to the end of the <basename> as a suffix. See the Prometheus.io documentation for more information. cardinality(attribute) Use the cardinality( ) function to obtain the number of combinations of all the dimensions (attributes) on a metric. It takes three arguments, all optional: Metric name: if present, cardinality( ) only computes the metric specified. Include: if present, the include list restricts the cardinality computation to those attributes. Exclude: if present, the exclude list causes those attributes to be ignored in the cardinality computation. SELECT cardinality(metric_name, include:{attribute_list}, exclude:{attribute_list}) Copy count(*) Use the count( ) function to return a count of available records. It takes a single argument; either *, an attribute, or a constant value. Currently, it follows typical SQL behavior and counts all records that have values for its argument. Since count(*) does not name a specific attribute, the results will be formatted in the default \"humanize\" format. derivative(attribute [,time interval]) derivative() finds the rate of change for a given dataset. The rate of change is calculated using a linear least-squares regression to approximate the derivative. Since this calculation requires comparing more than one datapoint, if only one datapoint is included in the evaluation range, the calculation is indeterminate and won't work, resulting in a null value. The time interval is the period for which the rate of change is calculated. For example, derivative(attributeName, 1 minute) will return the rate of change per minute. dimensions(include: {attributes}, exclude: {attributes}) Use the dimensions( ) function to return all the dimensional values on a data type. You can explicitly include or exclude specific attributes using the optional arguments: Include: if present, the include list limits dimensions( ) to those attributes. Exclude: if present, the dimensions( ) calculation ignores those attributes. FROM Metric SELECT count(node_filesystem_size) TIMESERIES FACET dimensions() Copy When used with a FACET clause, dimensions( ) produces a unique timeseries for all facets available on the event type, similar to how Prometheus behaves with non-aggregated queries. latestrate(attribute, time interval) Use the latestrate( ) function to return the rate of change of a value based on the last 2 data points. It takes the attribute in question as the first argument and the unit of time for the resulting rate as the second argument. The function returns a result in units of change in attribute/time interval. This function can be useful to provide the most recent rate of change for an attribute in order to see leading-edge trends. Get the most recent rate of change of PageView Duration This query returns the rate of change of duration based on the last 2 data points. It will be returned in units of duration/second because of the 1 SECOND argument. SELECT latestrate(duration, 1 SECOND) FROM PageView Copy max(attribute) Use the max( ) function to return the maximum recorded value of a numeric attribute over the time range specified. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. median(attribute) Use the median( ) function to return an attribute's median, or 50th percentile. For more information about percentile queries, see percentile(). Tip The median( ) query is only available when using the query builder. Median query This query will generate a line chart for the median value. SELECT median(duration) FROM PageView TIMESERIES AUTO Copy min(attribute) Use the min( ) function to return the minimum recorded value of a numeric attribute over the time range specified. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. minuteOf(attribute) Use the minuteOf() function to extract only the minute portion (i.e. 0-59) of an attribute holding a valid timestamp value. mod(attribute, divisor) Use the mod( ) function to return the floor modulus after dividing the value of the provided numeric attribute (the first argument, or dividend) by a numeric value (the second argument, or divisor). This modulo operation can be used within a WHERE clause condition to filter to an arbitrary subset of results or within a FACET clause as a way to subdivide the result set. mod() within a WHERE clause condition FROM Transaction SELECT * WHERE mod(port, 2) = 1 Copy mod() within a FACET clause FROM NrDailyUsage SELECT uniques(hostId, 10000) SINCE 1 day AGO FACET mod(hostId, 10) Copy percentage(function(attribute), WHERE condition) Use the percentage( ) function to return the percentage of a target data set that matches some condition. The first argument requires an aggregator function against the desired attribute. Use exactly two arguments (arguments after the first two will be ignored). If the attribute is not numeric, this function returns a value of 100%. percentile(attribute [, percentile [, ...]]) Use the percentile( ) function to return an attribute's approximate value at a given percentile. It requires an attribute and can take any number of arguments representing percentile points. The percentile() function enables percentiles to displays with up to three digits after the decimal point, providing greater precision. Percentile thresholds may be specified as decimal values, but be aware that for most data sets, percentiles closer than 0.1 from each other will not be resolved. Percentile display examples Use TIMESERIES to generate a line chart with percentiles mapped over time. Omit TIMESERIES to generate a billboard and attribute sheet showing aggregate values for the percentiles. If no percentiles are listed, the default is the 95th percentile. To return only the 50th percentile value, the median, you can also use median(). Basic percentile query This query will generate a line chart with lines for the 5th, 50th, and 95th percentile. SELECT percentile(duration, 5, 50, 95) FROM PageView TIMESERIES AUTO Copy predictLinear(attribute, [,time interval]) predictLinear() is an extension of the derivative() function. It uses a similar method of least-squares linear regression to predict the future values for a dataset. The time interval is how far the query will look into the future. For example, predictLinear(attributeName, 1 hour) is a linear prediction 1 hour into the future of the query time window. Generally, predictLinear() is helpful for continuously growing values like disk space, or predictions on large trends. Since predictLinear() is a linear regression, familiarity with the dataset being queried helps to ensure accurate long-term predictions. Any dataset which grows exponentially, logarithmically, or by other nonlinear means will likely only be successful in very short-term predictions. New Relic recommends against using predictLinear in TIMESERIES queries. This is because each bucket will be making an individual prediction based on its relative timeframe within the query, meaning that such queries will not show predictions from the end of the timeseries forward. rate(function(attribute) [,time interval]) Use the rate( ) function to visualize the frequency or rate of a given query per time interval. For example, you might want to know the number of pageviews per minute over an hour-long period or the count of unique sessions on your site per hour over a day-long period. Use TIMESERIES to generate a line chart with rates mapped over time. Omit TIMESERIES to generate a billboard showing a single rate value averaged over time. Basic rate query This query will generate a line chart showing the rate of throughput for APM transactions per 10 minutes over the past 6 hours. SELECT rate(count(*), 10 minute) FROM Transaction SINCE 6 hours ago TIMESERIES Copy round(attribute) Use the round( ) function to return the rounded value of an attribute. Optionally round( ) can take a second argument, to_nearest, to round the first argument to the closest multiple of the second one. to_nearest can be fractional. SELECT round(n [, to_nearest]) Copy stddev(attribute) Use the stddev( ) function to return one standard deviation for a numeric attribute over the time range specified. It takes a single argument. If the attribute is not numeric, it will return a value of zero. stdvar(attribute) Use the stdvar( ) function to return the standard variance for a numeric attribute over the time range specified. It takes a single argument. If the attribute is not numeric, it will return a value of zero. sum(attribute) Use the sum( ) function to return the sum recorded values of a numeric attribute over the time range specified. It takes a single argument. Arguments after the first will be ignored. If the attribute is not numeric, it will return a value of zero. uniqueCount(attribute) Use the uniqueCount( ) function to return the number of unique values recorded for an attribute over the time range specified. Tip To optimize query performance, this function returns approximate results for queries that inspect more than 256 unique values. uniques(attribute [,limit]) Use the uniques( ) function to return a list of unique values recorded for an attribute over the time range specified. When used along with the facet clause, a list of unique attribute values will be returned per each facet value. The limit parameter is optional. When it is not provided, the default limit of 1,000 unique attribute values per facet is applied. You may specify a different limit value, up to a maximum of 10,000. The uniques( ) function will return the first set of unique attribute values discovered, until the limit is reached. Therefore, if you have 5,000 unique attribute values in your data set, and the limit is set to 1,000, the operator will return the first 1,000 unique values that it discovers, regardless of their frequency. The maximum number of values that can be returned in a query result is the product of the uniques( ) limit times the facet limit. In the following query, the theoretical maximum number of values that can be returned is 5 million (5,000 x 1,000). Depending on the data set being queried, and the complexity of the query, memory protection limits may prevent a very large query from being executed. From Transaction SELECT uniques(host,5000) FACET appName LIMIT 1000 Copy Using tuple If you'd like to know the unique combinations of a handful of attributes, you can structure a query in the format SELECT uniques(tuple(x, y, ... z)) ...` to get all the unique tuples of values, to maintain their relationship. In the following query, tuple is used on index and cellName together to find uniques where those two values occur in combination. FROM NodeStatus SELECT uniques(tuple(index, cellName), 5) Copy capture(attribute, regular expression) Use the capture() to extract values from an attribute using a regular expression. Uses RE2 syntax. It takes two arguments: Attribute name Regular expression with capture syntax. Regex expressions in NRQL use Python-like syntax, r'...'. When capturing, use the RE2 named-capture syntax ...(?P<name> pattern )... to capture the contained pattern, given the specified name. Currently, only 1 capture group is supported. Please see the examples below. capture() within a SELECT clause condition The following will select the domain name of the website, removing https:// and any paths following the .com SELECT capture(pageUrl, r'https://(?P<baseUrl>.*.com)/.+') FROM PageView SINCE 1 day ago Copy The following will capture only the first word of the error message. SELECT capture(errorMessage, r'(?P<firstWord>\\S+)\\s.+') FROM Transaction SINCE 1 hour ago where errorMessage is not null Copy capture() within a FACET clause condition The following will facet by the captured HTTP method. SELECT count(*) FROM Log WHERE message like '%HTTP%' FACET capture(message, r'.* \"(?P<httpMethod>[A-Z]+) .*') Copy capture() within a WHERE clause condition The following will filter the results based on Log events with message attribute that matches the regular expression where the captured job name is ExampleJob. SELECT message FROM Log WHERE capture(message, r'.*Job Failed: (?P<jobName>[A-Za-z]+),.*') = 'ExampleJob' SINCE 10 minutes ago Copy capture() with a numeric cast The following will capture sum of CPU Time from log lines. You must explicitly cast to numeric to do mathematical operations. SELECT sum(numeric(capture(message, r'.*CpuTime:\\s(?P<cpuTime>\\d+)'))) FROM Log WHERE message like '%CpuTime:%' SINCE 1 hour ago Copy Non-aggregator functions Use non-aggregator functions for non-numerical data in NRQL queries. earliest(attribute) Use the earliest( ) function to return the earliest value for an attribute over the specified time range. It takes a single argument. Arguments after the first will be ignored. If used in conjunction with a FACET it will return the most recent value for an attribute for each of the resulting facets. Get earliest country per user agent from PageView This query returns the earliest country code per each user agent from the PageView event. SELECT earliest(countryCode) FROM PageView FACET userAgentName Copy eventType() ...WHERE eventType() = 'EventNameHere'... ...FACET eventType()... Copy Use the eventType() function in a FACET clause to break out results by the selected data type or in a WHERE clause to filter results to a specific data type. This is particularly useful for targeting specific data types with the filter() and percentage() functions. Important In this context, \"event type\" refers to the types of data you can access with a NRQL query. Use eventType() in filter() function This query returns the percentage of total TransactionError results out of the total Transaction results. You can use the eventType() function to target specific types of data with the filter() function. SELECT 100 * filter(count(*), where eventType() = 'TransactionError') / filter(count(*), where eventType() = 'Transaction') FROM Transaction, TransactionError WHERE appName = 'App.Prod' TIMESERIES 2 Minutes SINCE 6 hours ago Copy Use eventType() with FACET This query displays a count of how many records each data type (Transaction and TransactionError) returns. SELECT count(*) FROM Transaction, TransactionError FACET eventType() TIMESERIES Copy filter(function(attribute), WHERE condition) Use the filter() function to limit the results for one of the aggregator functions in your SELECT statement. You can use filter() in conjunction with FACET or TIMESERIES. Filter is only useful when selecting multiple different aggregations such as SELECT filter(sum(x), WHERE attribute='a') AS 'A', filter(sum(x), WHERE attribute='b') AS 'B' .... Otherwise, it's better to just use the standard WHERE clause. Analyze purchases that used offer codes You could use filter() to compare the items bought in a set of transactions for those using an offer code versus those who aren't: Use the filter( ) function to limit the results for one of the aggregator functions in your SELECT statement. funnel(attribute, steps) Use the funnel() function to generate a funnel chart. It takes an attribute as its first argument. You then specify steps as WHERE clauses (with optional AS clauses for labels) separated by commas. For details and examples, see the funnels documentation. getField(attribute, field) Use the getField() function to extract a field from compound data types, such as metric data. It takes the following arguments: Metric type Supported fields summary count, total, max, min, type gauge count, total, max, min, latest, type distribution count, total, max, min, type counter count, type timeslice count, total, totalExclusive, min, and max Examples: SELECT max(getField(mySummary, count)) from Metric Copy SELECT sum(mySummary) from Metric where getField(mySummary, count) > 10 Copy histogram(attribute, ceiling [,number of buckets]) Use the histogram( ) function to generate histograms. It takes three arguments: Attribute name Maximum value of the sample range Total number of buckets (between 1 and 500, inclusive) Histogram of response times from PageView events This query results in a histogram of response times ranging up to 10 seconds over 20 buckets. SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago Copy Prometheus histogram buckets histogram( ) accepts Prometheus histogram buckets: SELECT histogram(duration_bucket, 10, 20) FROM Metric SINCE 1 week ago Copy New Relic distribution metric histogram( ) accepts Distribution metric as an input: SELECT histogram(myDistributionMetric, 10, 20) FROM Metric SINCE 1 week ago Copy Histogram with a FACET clause Use histogram( ) with a FACET clause to generate a heatmap chart: SELECT histogram(duration) FROM PageView FACET appName SINCE 1 week ago Copy keyset() Using keyset() will allow you to see all of the attributes for a given data type over a given time range. It takes no arguments. It returns a JSON structure containing groups of string-typed keys, numeric-typed keys, boolean-typed keys, and all keys. See all attributes for a data type This query returns the attributes found for PageView events from the last day: SELECT keyset() FROM PageView SINCE 1 day ago Copy latest(attribute) Use the latest( ) function to return the most recent value for an attribute over a specified time range. It takes a single argument. Arguments after the first will be ignored. If used in conjunction with a FACET it will return the most recent value for an attribute for each of the resulting facets. Get most recent country per user agent from PageView This query returns the most recent country code per each user agent from the PageView event. SELECT latest(countryCode) FROM PageView FACET userAgentName Copy Type conversion NRQL does not support \"coercion.\" This means that a float stored as a string is treated as a string and cannot be operated on by functions expecting float values. You can convert a string with a numeric value or a boolean with a string value to their numeric and boolean types with these functions: Use the numeric() function to convert a number with a string format to a numeric function. The function can be built into a query that uses math functions on query results or NRQL aggregator functions, such as average(). Use the boolean() function to convert a string value of \"true\" or \"false\" to the corresponding boolean value.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.82672,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NRQL</em> syntax, clauses, and functions",
        "sections": "<em>Query</em> one <em>data</em> type",
        "tags": "<em>NRQL</em>: <em>New</em> <em>Relic</em> <em>Query</em> <em>Language</em>",
        "body": "<em>NRQL</em> is a <em>query</em> <em>language</em> you can use to <em>query</em> the <em>New</em> <em>Relic</em> database. This document explains <em>NRQL</em> syntax, clauses, components, and functions. Syntax This document is a reference for the functions and clauses used in a <em>NRQL</em> <em>query</em>. Other resources for understanding <em>NRQL</em>: Intro to <em>NRQL</em>: explains what"
      },
      "id": "604456c1196a678db8960f41"
    }
  ],
  "/docs/data-apis/ingest-apis/metric-api/introduction-metric-api": [
    {
      "sections": [
        "Introduction to the Event API",
        "Requirements",
        "Basic workflow",
        "Tip",
        "Get the license key",
        "Format the JSON",
        "JSON format guidelines",
        "JSON example",
        "Limits and restricted characters",
        "Submit the custom event",
        "Linux/bash example",
        "Windows/PowerShell example",
        "Important",
        "Verify or troubleshoot request response",
        "Success response code",
        "Submission errors",
        "Parsing errors",
        "Query and alert with NrIntegrationError",
        "Find your data",
        "Limit on HTTP requests"
      ],
      "title": "Introduction to the Event API",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "eea369c63a48d26123e243ed4e8bff412b334146",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/introduction-event-api/",
      "published_at": "2021-10-24T21:24:29Z",
      "updated_at": "2021-10-23T17:26:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Event API is one way to report custom events to New Relic. The Event API lets you send custom event data to your New Relic account with a POST command. These events are then queryable and chartable using NRQL. Want to try out our Event API? Create a New Relic account for free! No credit card required. Related content: Learn about all options for reporting custom events. For details about how event data is retained, see Event data retention. For how to add attributes to existing events, see Add custom attributes. Check out New Relic University’s tutorial Adding custom events with the Event API (aka the Insights API). Or, go directly to the full online course Custom data. Requirements For Event API limits and restricted attributes, see Limits. Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name insights-collector.newrelic.com or insights-collector.eu01.nr-data.net. Basic workflow The Event API is an asynchronous endpoint. This allows you to send a very large volume of POSTS, reliably, with very low response latency. Tip If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. To send a custom event to a New Relic account: Get a license key for the account you want to report data to. Before creating custom events or attributes, review New Relic's list of reserved terms used by NRQL. Generate JSON for the event by instrumenting your application, querying an API, or some other method. Submit a compressed JSON payload (for example, gzip or deflate) to the HTTPS endpoint using curl in a POST request. Recommendation: Set up NRQL alert conditions to notify you when parsing errors occur. This method will send the events directly into your account, where they will be accessible from any NRQL interface or with the Query API. The Event API limits the size, rate, and characters allowed in custom events. Also, like other events available in NRQL, custom events cannot be updated or deleted after they are created. If you have problems with your custom event, follow the troubleshooting procedures or create a new custom event. Get the license key You'll need a license key. License keys are associated with an account, not a specific user. This means that anyone in the account with access to that key can use it. You can submit multiple event types to the same account with the same license key. However, to help ensure security, we recommend that you use different keys for different applications or data sources. Alternatively, you can use an Insights insert keyfor this API, but we recommend using a license key. Format the JSON The Event API accepts specific formats for attributes included in the payload. Only float or string values are allowed. JSON format guidelines When defining attributes for your custom events, follow these JSON format guidelines. Attributes JSON format guidelines eventType Required: The event's name. Float and string values Float value format: \"label\":value String value format: \"label\":\"value\" Data types The API only accepts key-value pairs, not map/object or array values. Supported data types for this API are strings and numbers (integers or floats). For more information, see Data requirements. Digits in strings For performance-related reasons, we do not cast values submitted to the API. For example, we treat 123 as a number and \"123\" as a string. The database will only store up to 64 bit numbers. Any numbers larger than 64 bits will be truncated. Dates For attributes that contain date information, use an unformatted Unix timestamp in the Insights data formatter. You can define the date attribute either in seconds or in milliseconds, both relative to the Unix epoch. Time Unless otherwise specified, the timestamp for a submitted event is the time it was submitted to New Relic. To specify a different time for the event, use the timestamp attribute. JSON example Here is an example of a typical JSON data set for sending with the API. This call sends two Purchase type events as a JSON array. You can add multiple events in a single HTTP call using a JSON array. [ { \"eventType\":\"Purchase\", \"account\":3, \"amount\":259.54 }, { \"eventType\":\"Purchase\", \"account\":5, \"amount\":12309, \"product\":\"Item\" } ] Copy When generating the JSON, make sure your attributes are properly formatted. Limits and restricted characters The following size and rate limits apply to events sent via the Event API: Max events per API call: 2K Payload total size: 1MB(10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. Number of attributes per event: 255 maximum Length of attribute name: 255 characters Length of attribute value: 4096 maximum character length There are rate limits on the number of HTTP requests per minute sent to the Event API. Some specific attributes have additional restrictions: accountId: This is a reserved attribute name. If it is included, it will be dropped during ingest. entity.guid, entity.name, and entity.type: These attributes are used internally to identify entities. Any values submitted with these keys in the attributes section of a metric data point may cause undefined behavior such as missing entities in the UI or telemetry not associating with the expected entities. For more information please refer to Entity synthesis. appId: Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType: Can be a combination of alphanumeric characters, _ underscores, and : colons. timestamp: Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. Submit the custom event Data submitted to the Event API uses a compressed JSON format in a simple HTTPS POST request. This example uses gzip, but you can also use deflate. Linux/bash example gzip -c example_events.json | curl -X POST -H \"Content-Type: application/json\" -H \"Api-Key: YOUR_LICENSE_KEY\" -H \"Content-Encoding: gzip\" https://insights-collector.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/events --data-binary @- Copy Windows/PowerShell example $accountId = \"YOUR_ACCOUNT_ID\" $insertkey = \"YOUR_LICENSE_KEY\" # Replace with your custom event for the body $body = '[{\"eventType\": \"powershell\", \"account\": 4, \"amount\": 123, \"fileLocation\": \"c:\\\\temp2\", \"zipped\": \"true\" }]' $headers = @{} $headers.Add(\"Api-Key\", \"$insertkey\") $headers.Add(\"Content-Encoding\", \"gzip\") $encoding = [System.Text.Encoding]::UTF8 $enc_data = $encoding.GetBytes($body) $output = [System.IO.MemoryStream]::new() $gzipStream = New-Object System.IO.Compression.GzipStream $output, ([IO.Compression.CompressionMode]::Compress) $gzipStream.Write($enc_data, 0, $enc_data.Length) $gzipStream.Close() $gzipBody = $output.ToArray() Invoke-WebRequest -Headers $headers -Method Post -Body $gzipBody \"https://insights-collector.newrelic.com/v1/accounts/$accountId/events\" Copy Important Always use compression with every payload. This allows you to send more data, and it saves resources during parsing. Before generating your HTTP request, make sure it is properly formatted, including: The Api-Key contains the correct license key. The Content-Type is application/json. The request uses POST only. The API does not accept PUT and GET requests. The API supports HTTP/1.1 persistent connections. This is helpful to manage client-side performance under heavy event loads. Verify or troubleshoot request response The Event API follows a two-step process to process requests: The Event API synchronously acknowledges or rejects the request based on validation of the headers and payload size. The Event API asynchronously parses the payload after a successful HTTP response is provided to the client. This may generate an error due to missing or malformed data. These are classified as submission errors or parsing errors. All successful submissions receive a 200 response, regardless of any data errors that may exist within the payload. The response includes a uuid, which is a unique ID created for each request. The uuid also appears in any error events created for the request. Other potential issues: 10-second timeout: API calls exceeding 10 seconds will time out. Large payloads: Payloads exceeding 100 KB may see increased response times. Recommendation: In addition to checking for a success message, create a NRQL query of your data to verify it's available. Success response code Success message Comments 200 {\"success\":true,\"uuid\":\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"} Copy Submission errors Payloads with submission errors are handled and returned to the sender through an HTTP response code. To troubleshoot payload submission errors, refer to these HTTP response codes. Submission errors Troubleshooting 400 Missing or invalid content length: Unable to process empty request. 403 Missing or invalid key: Invalid license key. Register a valid license key. 408 Request timed out: Request took too long to process. 413 Content too large: Request is too large to process. Refer to the limits and restricted characters to troubleshoot. 415 Invalid content type: Must be application/JSON. The Event API accepts any content type except multi-part/related and assumes it can be parsed to JSON. 429 Too many requests due to rate limiting. 503 Service temporarily unavailable: Retry request Parsing errors Parsing errors occur if: An event is sent within a payload, but it is either missing data or is exceeding maximum limits. New Relic will drop the individual event from the payload, generate an NrIntegrationError event, and process the rest. The JSON payload includes malformed JSON or missing required data. Payloads with parsing errors receive a 200 response to indicate a successful submission. To help resolve parsing errors, a new NrIntegrationError event type is created. All parsing errors are due to NRQL queries. For error messages related to dropped events, New Relic will include the number of events that were dropped as part of the message. To troubleshoot requests with parsing errors, refer to these error messages. Parsing errors Troubleshooting X event(s) rejected because attribute appId was not an integer An appId attribute has a non-integer value, such as a decimal value or string. X event(s) rejected because eventType cannot contain the following characters: [., \\] An eventType attributed included an invalid character, such as a period or backslash. X event(s) rejected because attribute is missing attribute name An attribute name was set to null or an empty string. X event(s) rejected because attribute name exceeded maximum length An attribute name has more than 255 characters. X event(s) rejected because attribute value exceeded maximum length An attribute value was longer than 4096 characters. X event(s) rejected because event exceeded maximum number of attributes An event has more than 255 attributes. X event(s) rejected because missing required attributes eventType The eventType attribute is required for the custom event. Error parsing JSON payload There was an error parsing the request JSON because of formatting problems or corrupted data. Query and alert with NrIntegrationError The NrIntegrationError event allows you to query and set alerts on custom data being sent to your New Relic account. Recommendation: To get alerts for parsing errors, create a NRQL alert condition for NrIntegrationError. Use this example NRQL query: SELECT message FROM NrIntegrationError WHERE newRelicFeature = 'Event API' AND category = 'EventApiException' Copy NrIntegrationError attributes Troubleshooting timestamp The timestamp when the request was received. The timestamp attribute takes a 64-bit integer Unix timestamp within the last 24 hours. You can define timestamps either in seconds or in milliseconds, both relative to the Unix epoch. Do not use a decimal for the timestamp. If a decimal is used, the attribute will default to the timestamp when the custom event was created. newRelicFeature The name of the feature experiencing errors. For all custom event parsing errors, this will be Event API. apiKeyPrefix The first six characters of the license key used for the request that generated an error. requestId The uuid returned by the the API for the request that generated an error. Category The category of the error. For custom events, this is EventApiException. Message Contents of the error message. Name The error's name. For custom events, this is always EventValidationException. eventTypeSample One of the event types that generated the error, when available. Find your data To find data sent via the Event API (and from integrations that use this API), you can query it. For example, to query a custom event using NRQL, you would run: SELECT * FROM YOUR_CUSTOM_EVENT Copy For more on how to query, see Query data. Limit on HTTP requests The Event API has a rate limit of 100,000 HTTP requests (POSTs) per minute, per account. (Note that this is not a limit on the number of events per minute; only on the number of POSTs per minute.) This limit helps ensure that large traffic spikes in accounts across our multi-tenant platform do not negatively affect how the service performs for you. If your API usage exceeds 100k POSTs in a 1-minute window, we will reject subsequent API requests with a 429 response code for the remainder of the 1-minute window. At the end of the 1-minute window, the counter will be reset and allow traffic to resume. This limit is intended to be an upper threshold that you shouldn't hit under normal scenarios. If you have a high number of 429 responses, consider using the API less. If you are expecting a higher-than-normal activity level in the near future and want to prepare for that, contact technical support.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.4125,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the Event <em>API</em>",
        "sections": "Introduction to the Event <em>API</em>",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": "The New Relic Event <em>API</em> is one way to report custom events to New Relic. The Event <em>API</em> lets you send custom event <em>data</em> to your New Relic account with a POST command. These events are then queryable and chartable using NRQL. Want to try out our Event <em>API</em>? Create a New Relic account for free"
      },
      "id": "609fa5fb64441f9d9fd2a1e2"
    },
    {
      "sections": [
        "Telemetry SDKs: Report custom telemetry data",
        "Requirements and compatibility",
        "Tip",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one",
        "Integrations built with the Telemetry SDKs"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "d883a07b7ede4c3beaba4077c507b95f9a228435",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/telemetry-sdks-report-custom-telemetry-data/",
      "published_at": "2021-10-24T19:37:31Z",
      "updated_at": "2021-10-23T17:26:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the Metric API, Trace API, Log API, and Event API. We offer open-source integrations for telemetry tools like Prometheus, Istio, and OpenCensus that were created using our Telemetry SDKs. If those solutions (or our other integrations) don't meet your needs, you can use the Telemetry SDKs to create your own telemetry data solutions. Requirements and compatibility The Telemetry SDKs use our Metric API, Event API, Log API, and Trace API, which all require a license key, so you'll need a license key for the account you wish to send data to. Tip New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported New Relic data types Java Java library on GitHub Metrics Events Logs Traces Node/TypeScript NodeJS library on GitHub Metrics Traces Python Python library on GitHub Metrics Events Logs Traces Go Go library on Github Metrics Traces .NET .NET library on GitHub .NET package in NuGet Metrics Traces C C library on Github Traces Rust Rust library on Github Traces Ruby Ruby library on Github Gem on Rubygems Traces For more on the supported data types, see: An overview of New Relic data types Metrics: see the Metric API Logs: see the Log API Traces: see the Trace API Events: see the Event API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications. Integrations built with the Telemetry SDKs To see the integrations built using our Telemetry SDKs, see Open source telemetry integrations. For all monitoring solutions, see our integrations page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.41235,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Telemetry SDKs: Report custom telemetry <em>data</em>",
        "sections": "Telemetry SDKs: Report custom telemetry <em>data</em>",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": "Our Telemetry SDKs are an open source set of <em>API</em> client libraries that send <em>data</em> to the New Relic platform. Under the hood, these SDKs rely on our core <em>data</em> <em>ingest</em> <em>APIs</em>: the Metric <em>API</em>, Trace <em>API</em>, Log <em>API</em>, and Event <em>API</em>. We offer open-source integrations for telemetry tools like Prometheus, Istio"
      },
      "id": "603ea196196a670192a83d83"
    },
    {
      "sections": [
        "Troubleshoot Metric API with NRIntegrationError events",
        "Problem",
        "Solution",
        "View error details",
        "Match errors to ingested payloads",
        "Programmatically retrieve NrIntegrationError events",
        "Tip"
      ],
      "title": "Troubleshoot Metric API with NRIntegrationError events",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "50ad21a895fc1f2644bdbfbadf85ecfd298b08d6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/metric-api/troubleshoot-nrintegrationerror-events/",
      "published_at": "2021-10-24T20:16:09Z",
      "updated_at": "2021-10-23T17:26:33Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You sent metric data points to the Metric API, and are not seeing what you expect when querying the data. Use the following checklist to determine the root cause: Make sure you are querying the data correctly. Check the HTTP status codes returned by the API. Issues like authorization failures can be diagnosed with HTTP status codes. If you are sending data from a Prometheus server via New Relic's remote_write endpoint, check your Prometheus server logs for errors or non-2xx HTTP responses from the New Relic endpoint. Query your account for NrIntegrationError events. New Relic's ingestion endpoints are asynchronous, meaning the endpoint verifies the payload after it returns the HTTP response. If any issues occur while verifying your payload, then an NrIntegrationError event will be created in your account. New Relic also uses NrIntegrationError events to notify customers when various rate limits have been reached. Solution View error details For an introduction to using the NrIntegrationError event, see NrIntegrationError. Here's an example NRQL for examining issues with Metric API ingest: SELECT count(*) FROM NrIntegrationError WHERE newRelicFeature = 'Metrics' facet category, message limit 100 since 24 hours ago Copy The category indicates the type of error and the message provides more detailed information about the error. If the category is rateLimit, then you should also examine the rateLimitType field for more information on the type of rate limiting. Category rateLimitType Description and solution BadRequest (not set) There is an issue with the JSON payload. These include JSON syntax errors, attribute names, or values that are too long. Check the message field to determine the exact issue. Then review the JSON payload, and update it to ensure it meets the proper semantic guidelines. RateLimit DatapointsPerMinute You are sending too many datapoints per minute. If you get this error, you can either send data less frequently, or request changes to your metric rate limits by contacting your New Relic account representative, or visiting our Support portal. RateLimit UniqueTimeseriesPerDay You have an attribute with a high number of unique values, like containerId or URI. To resolve this error, review any attributes that may be causing the issue and remove them. If desired, you can use a data dropping rule to remove attributes at ingest time. RateLimit UniquePrometheusTimeseries You have Prometheus servers reporting too many unique timeseries via New Relic's remote_write endpoint. Reduce the number of unique timeseries reported by modifying your Prometheus server configuration to reduce the number of targets being scraped, or by using relabel rules in the remote_write section of your server configuration to drop timeseries or highly unique labels. RateLimit RequestsPerMinute Too many requests per minute are being sent. To resolve this, put more datapoints in each request, and send them less frequently. RateLimit ErrorGroupsPerDay You have exceeded your daily error group limit. Incoming error groups will be dropped for the remainder of the day and will continue as normal after UTC midnight. To resolve this, reduce the amount of unique error messages collected by New Relic. Match errors to ingested payloads When an NrIntegrationError event is created as a result of a syntax issue with the HTTP request payload, then the event contains the attributes apiKeyPrefix and requestId. The apiKeyPrefix matches the first 6 characters of the API key used to send the data. The requestId matches the requestId sent in the HTTP response. To view these fields, run this NRQL query: SELECT message, apiKeyPrefix, requestId FROM NrIntegrationError limit 100 Copy To verify a specific requestId, run this NRQL query: SELECT * FROM NrIntegrationError where requestId ='REQUEST_ID' Copy Programmatically retrieve NrIntegrationError events To programmatically retrieve these errors: Ensure you have an Insights query API key (go to insights.newrelic.com > Manage data > API keys). Create an HTTP request as shown below: Tip If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. curl -H \"Accept: application/json\" -H \"X-Query-Key:YOUR_API_KEY_HERE\" \"https://insights-api.newrelic.com/v1/accounts/YOUR_ACCOUNT_HERE/query?nrql=SELECT%20*%20FROM%20NrIntegrationError%20where%20newRelicFeature='Metrics'\" Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.41235,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshoot Metric <em>API</em> with NRIntegrationError events",
        "sections": "Troubleshoot Metric <em>API</em> with NRIntegrationError events",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": " To programmatically retrieve these errors: Ensure you have an Insights query <em>API</em> key (go to insights.newrelic.com &gt; <em>Manage</em> <em>data</em> &gt; <em>API</em> keys). Create an HTTP request as shown below: Tip If your account hosts <em>data</em> in the EU <em>data</em> center, ensure you&#x27;re using the proper <em>API</em> endpoints for EU region accounts. curl -H"
      },
      "id": "610f2900196a678a5d38ad82"
    }
  ],
  "/docs/data-apis/ingest-apis/metric-api/metric-api-limits-restricted-attributes": [
    {
      "sections": [
        "Introduction to the Event API",
        "Requirements",
        "Basic workflow",
        "Tip",
        "Get the license key",
        "Format the JSON",
        "JSON format guidelines",
        "JSON example",
        "Limits and restricted characters",
        "Submit the custom event",
        "Linux/bash example",
        "Windows/PowerShell example",
        "Important",
        "Verify or troubleshoot request response",
        "Success response code",
        "Submission errors",
        "Parsing errors",
        "Query and alert with NrIntegrationError",
        "Find your data",
        "Limit on HTTP requests"
      ],
      "title": "Introduction to the Event API",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "eea369c63a48d26123e243ed4e8bff412b334146",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/introduction-event-api/",
      "published_at": "2021-10-24T21:24:29Z",
      "updated_at": "2021-10-23T17:26:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Event API is one way to report custom events to New Relic. The Event API lets you send custom event data to your New Relic account with a POST command. These events are then queryable and chartable using NRQL. Want to try out our Event API? Create a New Relic account for free! No credit card required. Related content: Learn about all options for reporting custom events. For details about how event data is retained, see Event data retention. For how to add attributes to existing events, see Add custom attributes. Check out New Relic University’s tutorial Adding custom events with the Event API (aka the Insights API). Or, go directly to the full online course Custom data. Requirements For Event API limits and restricted attributes, see Limits. Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name insights-collector.newrelic.com or insights-collector.eu01.nr-data.net. Basic workflow The Event API is an asynchronous endpoint. This allows you to send a very large volume of POSTS, reliably, with very low response latency. Tip If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. To send a custom event to a New Relic account: Get a license key for the account you want to report data to. Before creating custom events or attributes, review New Relic's list of reserved terms used by NRQL. Generate JSON for the event by instrumenting your application, querying an API, or some other method. Submit a compressed JSON payload (for example, gzip or deflate) to the HTTPS endpoint using curl in a POST request. Recommendation: Set up NRQL alert conditions to notify you when parsing errors occur. This method will send the events directly into your account, where they will be accessible from any NRQL interface or with the Query API. The Event API limits the size, rate, and characters allowed in custom events. Also, like other events available in NRQL, custom events cannot be updated or deleted after they are created. If you have problems with your custom event, follow the troubleshooting procedures or create a new custom event. Get the license key You'll need a license key. License keys are associated with an account, not a specific user. This means that anyone in the account with access to that key can use it. You can submit multiple event types to the same account with the same license key. However, to help ensure security, we recommend that you use different keys for different applications or data sources. Alternatively, you can use an Insights insert keyfor this API, but we recommend using a license key. Format the JSON The Event API accepts specific formats for attributes included in the payload. Only float or string values are allowed. JSON format guidelines When defining attributes for your custom events, follow these JSON format guidelines. Attributes JSON format guidelines eventType Required: The event's name. Float and string values Float value format: \"label\":value String value format: \"label\":\"value\" Data types The API only accepts key-value pairs, not map/object or array values. Supported data types for this API are strings and numbers (integers or floats). For more information, see Data requirements. Digits in strings For performance-related reasons, we do not cast values submitted to the API. For example, we treat 123 as a number and \"123\" as a string. The database will only store up to 64 bit numbers. Any numbers larger than 64 bits will be truncated. Dates For attributes that contain date information, use an unformatted Unix timestamp in the Insights data formatter. You can define the date attribute either in seconds or in milliseconds, both relative to the Unix epoch. Time Unless otherwise specified, the timestamp for a submitted event is the time it was submitted to New Relic. To specify a different time for the event, use the timestamp attribute. JSON example Here is an example of a typical JSON data set for sending with the API. This call sends two Purchase type events as a JSON array. You can add multiple events in a single HTTP call using a JSON array. [ { \"eventType\":\"Purchase\", \"account\":3, \"amount\":259.54 }, { \"eventType\":\"Purchase\", \"account\":5, \"amount\":12309, \"product\":\"Item\" } ] Copy When generating the JSON, make sure your attributes are properly formatted. Limits and restricted characters The following size and rate limits apply to events sent via the Event API: Max events per API call: 2K Payload total size: 1MB(10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. Number of attributes per event: 255 maximum Length of attribute name: 255 characters Length of attribute value: 4096 maximum character length There are rate limits on the number of HTTP requests per minute sent to the Event API. Some specific attributes have additional restrictions: accountId: This is a reserved attribute name. If it is included, it will be dropped during ingest. entity.guid, entity.name, and entity.type: These attributes are used internally to identify entities. Any values submitted with these keys in the attributes section of a metric data point may cause undefined behavior such as missing entities in the UI or telemetry not associating with the expected entities. For more information please refer to Entity synthesis. appId: Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType: Can be a combination of alphanumeric characters, _ underscores, and : colons. timestamp: Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. Submit the custom event Data submitted to the Event API uses a compressed JSON format in a simple HTTPS POST request. This example uses gzip, but you can also use deflate. Linux/bash example gzip -c example_events.json | curl -X POST -H \"Content-Type: application/json\" -H \"Api-Key: YOUR_LICENSE_KEY\" -H \"Content-Encoding: gzip\" https://insights-collector.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/events --data-binary @- Copy Windows/PowerShell example $accountId = \"YOUR_ACCOUNT_ID\" $insertkey = \"YOUR_LICENSE_KEY\" # Replace with your custom event for the body $body = '[{\"eventType\": \"powershell\", \"account\": 4, \"amount\": 123, \"fileLocation\": \"c:\\\\temp2\", \"zipped\": \"true\" }]' $headers = @{} $headers.Add(\"Api-Key\", \"$insertkey\") $headers.Add(\"Content-Encoding\", \"gzip\") $encoding = [System.Text.Encoding]::UTF8 $enc_data = $encoding.GetBytes($body) $output = [System.IO.MemoryStream]::new() $gzipStream = New-Object System.IO.Compression.GzipStream $output, ([IO.Compression.CompressionMode]::Compress) $gzipStream.Write($enc_data, 0, $enc_data.Length) $gzipStream.Close() $gzipBody = $output.ToArray() Invoke-WebRequest -Headers $headers -Method Post -Body $gzipBody \"https://insights-collector.newrelic.com/v1/accounts/$accountId/events\" Copy Important Always use compression with every payload. This allows you to send more data, and it saves resources during parsing. Before generating your HTTP request, make sure it is properly formatted, including: The Api-Key contains the correct license key. The Content-Type is application/json. The request uses POST only. The API does not accept PUT and GET requests. The API supports HTTP/1.1 persistent connections. This is helpful to manage client-side performance under heavy event loads. Verify or troubleshoot request response The Event API follows a two-step process to process requests: The Event API synchronously acknowledges or rejects the request based on validation of the headers and payload size. The Event API asynchronously parses the payload after a successful HTTP response is provided to the client. This may generate an error due to missing or malformed data. These are classified as submission errors or parsing errors. All successful submissions receive a 200 response, regardless of any data errors that may exist within the payload. The response includes a uuid, which is a unique ID created for each request. The uuid also appears in any error events created for the request. Other potential issues: 10-second timeout: API calls exceeding 10 seconds will time out. Large payloads: Payloads exceeding 100 KB may see increased response times. Recommendation: In addition to checking for a success message, create a NRQL query of your data to verify it's available. Success response code Success message Comments 200 {\"success\":true,\"uuid\":\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"} Copy Submission errors Payloads with submission errors are handled and returned to the sender through an HTTP response code. To troubleshoot payload submission errors, refer to these HTTP response codes. Submission errors Troubleshooting 400 Missing or invalid content length: Unable to process empty request. 403 Missing or invalid key: Invalid license key. Register a valid license key. 408 Request timed out: Request took too long to process. 413 Content too large: Request is too large to process. Refer to the limits and restricted characters to troubleshoot. 415 Invalid content type: Must be application/JSON. The Event API accepts any content type except multi-part/related and assumes it can be parsed to JSON. 429 Too many requests due to rate limiting. 503 Service temporarily unavailable: Retry request Parsing errors Parsing errors occur if: An event is sent within a payload, but it is either missing data or is exceeding maximum limits. New Relic will drop the individual event from the payload, generate an NrIntegrationError event, and process the rest. The JSON payload includes malformed JSON or missing required data. Payloads with parsing errors receive a 200 response to indicate a successful submission. To help resolve parsing errors, a new NrIntegrationError event type is created. All parsing errors are due to NRQL queries. For error messages related to dropped events, New Relic will include the number of events that were dropped as part of the message. To troubleshoot requests with parsing errors, refer to these error messages. Parsing errors Troubleshooting X event(s) rejected because attribute appId was not an integer An appId attribute has a non-integer value, such as a decimal value or string. X event(s) rejected because eventType cannot contain the following characters: [., \\] An eventType attributed included an invalid character, such as a period or backslash. X event(s) rejected because attribute is missing attribute name An attribute name was set to null or an empty string. X event(s) rejected because attribute name exceeded maximum length An attribute name has more than 255 characters. X event(s) rejected because attribute value exceeded maximum length An attribute value was longer than 4096 characters. X event(s) rejected because event exceeded maximum number of attributes An event has more than 255 attributes. X event(s) rejected because missing required attributes eventType The eventType attribute is required for the custom event. Error parsing JSON payload There was an error parsing the request JSON because of formatting problems or corrupted data. Query and alert with NrIntegrationError The NrIntegrationError event allows you to query and set alerts on custom data being sent to your New Relic account. Recommendation: To get alerts for parsing errors, create a NRQL alert condition for NrIntegrationError. Use this example NRQL query: SELECT message FROM NrIntegrationError WHERE newRelicFeature = 'Event API' AND category = 'EventApiException' Copy NrIntegrationError attributes Troubleshooting timestamp The timestamp when the request was received. The timestamp attribute takes a 64-bit integer Unix timestamp within the last 24 hours. You can define timestamps either in seconds or in milliseconds, both relative to the Unix epoch. Do not use a decimal for the timestamp. If a decimal is used, the attribute will default to the timestamp when the custom event was created. newRelicFeature The name of the feature experiencing errors. For all custom event parsing errors, this will be Event API. apiKeyPrefix The first six characters of the license key used for the request that generated an error. requestId The uuid returned by the the API for the request that generated an error. Category The category of the error. For custom events, this is EventApiException. Message Contents of the error message. Name The error's name. For custom events, this is always EventValidationException. eventTypeSample One of the event types that generated the error, when available. Find your data To find data sent via the Event API (and from integrations that use this API), you can query it. For example, to query a custom event using NRQL, you would run: SELECT * FROM YOUR_CUSTOM_EVENT Copy For more on how to query, see Query data. Limit on HTTP requests The Event API has a rate limit of 100,000 HTTP requests (POSTs) per minute, per account. (Note that this is not a limit on the number of events per minute; only on the number of POSTs per minute.) This limit helps ensure that large traffic spikes in accounts across our multi-tenant platform do not negatively affect how the service performs for you. If your API usage exceeds 100k POSTs in a 1-minute window, we will reject subsequent API requests with a 429 response code for the remainder of the 1-minute window. At the end of the 1-minute window, the counter will be reset and allow traffic to resume. This limit is intended to be an upper threshold that you shouldn't hit under normal scenarios. If you have a high number of 429 responses, consider using the API less. If you are expecting a higher-than-normal activity level in the near future and want to prepare for that, contact technical support.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.41235,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the Event <em>API</em>",
        "sections": "Introduction to the Event <em>API</em>",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": "The New Relic Event <em>API</em> is one way to report custom events to New Relic. The Event <em>API</em> lets you send custom event <em>data</em> to your New Relic account with a POST command. These events are then queryable and chartable using NRQL. Want to try out our Event <em>API</em>? Create a New Relic account for free"
      },
      "id": "609fa5fb64441f9d9fd2a1e2"
    },
    {
      "sections": [
        "Telemetry SDKs: Report custom telemetry data",
        "Requirements and compatibility",
        "Tip",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one",
        "Integrations built with the Telemetry SDKs"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "d883a07b7ede4c3beaba4077c507b95f9a228435",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/telemetry-sdks-report-custom-telemetry-data/",
      "published_at": "2021-10-24T19:37:31Z",
      "updated_at": "2021-10-23T17:26:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the Metric API, Trace API, Log API, and Event API. We offer open-source integrations for telemetry tools like Prometheus, Istio, and OpenCensus that were created using our Telemetry SDKs. If those solutions (or our other integrations) don't meet your needs, you can use the Telemetry SDKs to create your own telemetry data solutions. Requirements and compatibility The Telemetry SDKs use our Metric API, Event API, Log API, and Trace API, which all require a license key, so you'll need a license key for the account you wish to send data to. Tip New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported New Relic data types Java Java library on GitHub Metrics Events Logs Traces Node/TypeScript NodeJS library on GitHub Metrics Traces Python Python library on GitHub Metrics Events Logs Traces Go Go library on Github Metrics Traces .NET .NET library on GitHub .NET package in NuGet Metrics Traces C C library on Github Traces Rust Rust library on Github Traces Ruby Ruby library on Github Gem on Rubygems Traces For more on the supported data types, see: An overview of New Relic data types Metrics: see the Metric API Logs: see the Log API Traces: see the Trace API Events: see the Event API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications. Integrations built with the Telemetry SDKs To see the integrations built using our Telemetry SDKs, see Open source telemetry integrations. For all monitoring solutions, see our integrations page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.41223,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Telemetry SDKs: Report custom telemetry <em>data</em>",
        "sections": "Telemetry SDKs: Report custom telemetry <em>data</em>",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": "Our Telemetry SDKs are an open source set of <em>API</em> client libraries that send <em>data</em> to the New Relic platform. Under the hood, these SDKs rely on our core <em>data</em> <em>ingest</em> <em>APIs</em>: the Metric <em>API</em>, Trace <em>API</em>, Log <em>API</em>, and Event <em>API</em>. We offer open-source integrations for telemetry tools like Prometheus, Istio"
      },
      "id": "603ea196196a670192a83d83"
    },
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "3d1e1c9bdb5d2cbf172eb055dc83020e39dbd16b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/metric-api/introduction-metric-api/",
      "published_at": "2021-10-24T20:15:16Z",
      "updated_at": "2021-10-23T17:26:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. Want to try out our Metric API? Create a New Relic account for free! No credit card required. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. You'll need a New Relic license key for the New Relic account you want to send data to. For information on limits and restricted attributes, see Metric API requirements and limits. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting See Troubleshoot an NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.41223,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the Metric <em>API</em>",
        "sections": "Find <em>and</em> use your <em>data</em>",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": ", OpenCensus, and Prometheus). The Metric <em>API</em> is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our <em>data</em>-<em>ingest</em> <em>APIs</em>. The Metric <em>API</em> can be used to: Report metric <em>data</em> to New Relic without a New Relic agent. Integrate metric <em>data</em> from an open source"
      },
      "id": "6107858fe7b9d2f9dcfc108e"
    }
  ],
  "/docs/data-apis/ingest-apis/metric-api/report-metrics-metric-api": [
    {
      "sections": [
        "Introduction to the Event API",
        "Requirements",
        "Basic workflow",
        "Tip",
        "Get the license key",
        "Format the JSON",
        "JSON format guidelines",
        "JSON example",
        "Limits and restricted characters",
        "Submit the custom event",
        "Linux/bash example",
        "Windows/PowerShell example",
        "Important",
        "Verify or troubleshoot request response",
        "Success response code",
        "Submission errors",
        "Parsing errors",
        "Query and alert with NrIntegrationError",
        "Find your data",
        "Limit on HTTP requests"
      ],
      "title": "Introduction to the Event API",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "eea369c63a48d26123e243ed4e8bff412b334146",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/introduction-event-api/",
      "published_at": "2021-10-24T21:24:29Z",
      "updated_at": "2021-10-23T17:26:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Event API is one way to report custom events to New Relic. The Event API lets you send custom event data to your New Relic account with a POST command. These events are then queryable and chartable using NRQL. Want to try out our Event API? Create a New Relic account for free! No credit card required. Related content: Learn about all options for reporting custom events. For details about how event data is retained, see Event data retention. For how to add attributes to existing events, see Add custom attributes. Check out New Relic University’s tutorial Adding custom events with the Event API (aka the Insights API). Or, go directly to the full online course Custom data. Requirements For Event API limits and restricted attributes, see Limits. Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name insights-collector.newrelic.com or insights-collector.eu01.nr-data.net. Basic workflow The Event API is an asynchronous endpoint. This allows you to send a very large volume of POSTS, reliably, with very low response latency. Tip If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. To send a custom event to a New Relic account: Get a license key for the account you want to report data to. Before creating custom events or attributes, review New Relic's list of reserved terms used by NRQL. Generate JSON for the event by instrumenting your application, querying an API, or some other method. Submit a compressed JSON payload (for example, gzip or deflate) to the HTTPS endpoint using curl in a POST request. Recommendation: Set up NRQL alert conditions to notify you when parsing errors occur. This method will send the events directly into your account, where they will be accessible from any NRQL interface or with the Query API. The Event API limits the size, rate, and characters allowed in custom events. Also, like other events available in NRQL, custom events cannot be updated or deleted after they are created. If you have problems with your custom event, follow the troubleshooting procedures or create a new custom event. Get the license key You'll need a license key. License keys are associated with an account, not a specific user. This means that anyone in the account with access to that key can use it. You can submit multiple event types to the same account with the same license key. However, to help ensure security, we recommend that you use different keys for different applications or data sources. Alternatively, you can use an Insights insert keyfor this API, but we recommend using a license key. Format the JSON The Event API accepts specific formats for attributes included in the payload. Only float or string values are allowed. JSON format guidelines When defining attributes for your custom events, follow these JSON format guidelines. Attributes JSON format guidelines eventType Required: The event's name. Float and string values Float value format: \"label\":value String value format: \"label\":\"value\" Data types The API only accepts key-value pairs, not map/object or array values. Supported data types for this API are strings and numbers (integers or floats). For more information, see Data requirements. Digits in strings For performance-related reasons, we do not cast values submitted to the API. For example, we treat 123 as a number and \"123\" as a string. The database will only store up to 64 bit numbers. Any numbers larger than 64 bits will be truncated. Dates For attributes that contain date information, use an unformatted Unix timestamp in the Insights data formatter. You can define the date attribute either in seconds or in milliseconds, both relative to the Unix epoch. Time Unless otherwise specified, the timestamp for a submitted event is the time it was submitted to New Relic. To specify a different time for the event, use the timestamp attribute. JSON example Here is an example of a typical JSON data set for sending with the API. This call sends two Purchase type events as a JSON array. You can add multiple events in a single HTTP call using a JSON array. [ { \"eventType\":\"Purchase\", \"account\":3, \"amount\":259.54 }, { \"eventType\":\"Purchase\", \"account\":5, \"amount\":12309, \"product\":\"Item\" } ] Copy When generating the JSON, make sure your attributes are properly formatted. Limits and restricted characters The following size and rate limits apply to events sent via the Event API: Max events per API call: 2K Payload total size: 1MB(10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. Number of attributes per event: 255 maximum Length of attribute name: 255 characters Length of attribute value: 4096 maximum character length There are rate limits on the number of HTTP requests per minute sent to the Event API. Some specific attributes have additional restrictions: accountId: This is a reserved attribute name. If it is included, it will be dropped during ingest. entity.guid, entity.name, and entity.type: These attributes are used internally to identify entities. Any values submitted with these keys in the attributes section of a metric data point may cause undefined behavior such as missing entities in the UI or telemetry not associating with the expected entities. For more information please refer to Entity synthesis. appId: Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType: Can be a combination of alphanumeric characters, _ underscores, and : colons. timestamp: Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. Submit the custom event Data submitted to the Event API uses a compressed JSON format in a simple HTTPS POST request. This example uses gzip, but you can also use deflate. Linux/bash example gzip -c example_events.json | curl -X POST -H \"Content-Type: application/json\" -H \"Api-Key: YOUR_LICENSE_KEY\" -H \"Content-Encoding: gzip\" https://insights-collector.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/events --data-binary @- Copy Windows/PowerShell example $accountId = \"YOUR_ACCOUNT_ID\" $insertkey = \"YOUR_LICENSE_KEY\" # Replace with your custom event for the body $body = '[{\"eventType\": \"powershell\", \"account\": 4, \"amount\": 123, \"fileLocation\": \"c:\\\\temp2\", \"zipped\": \"true\" }]' $headers = @{} $headers.Add(\"Api-Key\", \"$insertkey\") $headers.Add(\"Content-Encoding\", \"gzip\") $encoding = [System.Text.Encoding]::UTF8 $enc_data = $encoding.GetBytes($body) $output = [System.IO.MemoryStream]::new() $gzipStream = New-Object System.IO.Compression.GzipStream $output, ([IO.Compression.CompressionMode]::Compress) $gzipStream.Write($enc_data, 0, $enc_data.Length) $gzipStream.Close() $gzipBody = $output.ToArray() Invoke-WebRequest -Headers $headers -Method Post -Body $gzipBody \"https://insights-collector.newrelic.com/v1/accounts/$accountId/events\" Copy Important Always use compression with every payload. This allows you to send more data, and it saves resources during parsing. Before generating your HTTP request, make sure it is properly formatted, including: The Api-Key contains the correct license key. The Content-Type is application/json. The request uses POST only. The API does not accept PUT and GET requests. The API supports HTTP/1.1 persistent connections. This is helpful to manage client-side performance under heavy event loads. Verify or troubleshoot request response The Event API follows a two-step process to process requests: The Event API synchronously acknowledges or rejects the request based on validation of the headers and payload size. The Event API asynchronously parses the payload after a successful HTTP response is provided to the client. This may generate an error due to missing or malformed data. These are classified as submission errors or parsing errors. All successful submissions receive a 200 response, regardless of any data errors that may exist within the payload. The response includes a uuid, which is a unique ID created for each request. The uuid also appears in any error events created for the request. Other potential issues: 10-second timeout: API calls exceeding 10 seconds will time out. Large payloads: Payloads exceeding 100 KB may see increased response times. Recommendation: In addition to checking for a success message, create a NRQL query of your data to verify it's available. Success response code Success message Comments 200 {\"success\":true,\"uuid\":\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"} Copy Submission errors Payloads with submission errors are handled and returned to the sender through an HTTP response code. To troubleshoot payload submission errors, refer to these HTTP response codes. Submission errors Troubleshooting 400 Missing or invalid content length: Unable to process empty request. 403 Missing or invalid key: Invalid license key. Register a valid license key. 408 Request timed out: Request took too long to process. 413 Content too large: Request is too large to process. Refer to the limits and restricted characters to troubleshoot. 415 Invalid content type: Must be application/JSON. The Event API accepts any content type except multi-part/related and assumes it can be parsed to JSON. 429 Too many requests due to rate limiting. 503 Service temporarily unavailable: Retry request Parsing errors Parsing errors occur if: An event is sent within a payload, but it is either missing data or is exceeding maximum limits. New Relic will drop the individual event from the payload, generate an NrIntegrationError event, and process the rest. The JSON payload includes malformed JSON or missing required data. Payloads with parsing errors receive a 200 response to indicate a successful submission. To help resolve parsing errors, a new NrIntegrationError event type is created. All parsing errors are due to NRQL queries. For error messages related to dropped events, New Relic will include the number of events that were dropped as part of the message. To troubleshoot requests with parsing errors, refer to these error messages. Parsing errors Troubleshooting X event(s) rejected because attribute appId was not an integer An appId attribute has a non-integer value, such as a decimal value or string. X event(s) rejected because eventType cannot contain the following characters: [., \\] An eventType attributed included an invalid character, such as a period or backslash. X event(s) rejected because attribute is missing attribute name An attribute name was set to null or an empty string. X event(s) rejected because attribute name exceeded maximum length An attribute name has more than 255 characters. X event(s) rejected because attribute value exceeded maximum length An attribute value was longer than 4096 characters. X event(s) rejected because event exceeded maximum number of attributes An event has more than 255 attributes. X event(s) rejected because missing required attributes eventType The eventType attribute is required for the custom event. Error parsing JSON payload There was an error parsing the request JSON because of formatting problems or corrupted data. Query and alert with NrIntegrationError The NrIntegrationError event allows you to query and set alerts on custom data being sent to your New Relic account. Recommendation: To get alerts for parsing errors, create a NRQL alert condition for NrIntegrationError. Use this example NRQL query: SELECT message FROM NrIntegrationError WHERE newRelicFeature = 'Event API' AND category = 'EventApiException' Copy NrIntegrationError attributes Troubleshooting timestamp The timestamp when the request was received. The timestamp attribute takes a 64-bit integer Unix timestamp within the last 24 hours. You can define timestamps either in seconds or in milliseconds, both relative to the Unix epoch. Do not use a decimal for the timestamp. If a decimal is used, the attribute will default to the timestamp when the custom event was created. newRelicFeature The name of the feature experiencing errors. For all custom event parsing errors, this will be Event API. apiKeyPrefix The first six characters of the license key used for the request that generated an error. requestId The uuid returned by the the API for the request that generated an error. Category The category of the error. For custom events, this is EventApiException. Message Contents of the error message. Name The error's name. For custom events, this is always EventValidationException. eventTypeSample One of the event types that generated the error, when available. Find your data To find data sent via the Event API (and from integrations that use this API), you can query it. For example, to query a custom event using NRQL, you would run: SELECT * FROM YOUR_CUSTOM_EVENT Copy For more on how to query, see Query data. Limit on HTTP requests The Event API has a rate limit of 100,000 HTTP requests (POSTs) per minute, per account. (Note that this is not a limit on the number of events per minute; only on the number of POSTs per minute.) This limit helps ensure that large traffic spikes in accounts across our multi-tenant platform do not negatively affect how the service performs for you. If your API usage exceeds 100k POSTs in a 1-minute window, we will reject subsequent API requests with a 429 response code for the remainder of the 1-minute window. At the end of the 1-minute window, the counter will be reset and allow traffic to resume. This limit is intended to be an upper threshold that you shouldn't hit under normal scenarios. If you have a high number of 429 responses, consider using the API less. If you are expecting a higher-than-normal activity level in the near future and want to prepare for that, contact technical support.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.41235,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the Event <em>API</em>",
        "sections": "Introduction to the Event <em>API</em>",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": "The New Relic Event <em>API</em> is one way to report custom events to New Relic. The Event <em>API</em> lets you send custom event <em>data</em> to your New Relic account with a POST command. These events are then queryable and chartable using NRQL. Want to try out our Event <em>API</em>? Create a New Relic account for free"
      },
      "id": "609fa5fb64441f9d9fd2a1e2"
    },
    {
      "sections": [
        "Telemetry SDKs: Report custom telemetry data",
        "Requirements and compatibility",
        "Tip",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one",
        "Integrations built with the Telemetry SDKs"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "d883a07b7ede4c3beaba4077c507b95f9a228435",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/telemetry-sdks-report-custom-telemetry-data/",
      "published_at": "2021-10-24T19:37:31Z",
      "updated_at": "2021-10-23T17:26:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the Metric API, Trace API, Log API, and Event API. We offer open-source integrations for telemetry tools like Prometheus, Istio, and OpenCensus that were created using our Telemetry SDKs. If those solutions (or our other integrations) don't meet your needs, you can use the Telemetry SDKs to create your own telemetry data solutions. Requirements and compatibility The Telemetry SDKs use our Metric API, Event API, Log API, and Trace API, which all require a license key, so you'll need a license key for the account you wish to send data to. Tip New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported New Relic data types Java Java library on GitHub Metrics Events Logs Traces Node/TypeScript NodeJS library on GitHub Metrics Traces Python Python library on GitHub Metrics Events Logs Traces Go Go library on Github Metrics Traces .NET .NET library on GitHub .NET package in NuGet Metrics Traces C C library on Github Traces Rust Rust library on Github Traces Ruby Ruby library on Github Gem on Rubygems Traces For more on the supported data types, see: An overview of New Relic data types Metrics: see the Metric API Logs: see the Log API Traces: see the Trace API Events: see the Event API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications. Integrations built with the Telemetry SDKs To see the integrations built using our Telemetry SDKs, see Open source telemetry integrations. For all monitoring solutions, see our integrations page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.41223,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Telemetry SDKs: Report custom telemetry <em>data</em>",
        "sections": "Telemetry SDKs: Report custom telemetry <em>data</em>",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": "Our Telemetry SDKs are an open source set of <em>API</em> client libraries that send <em>data</em> to the New Relic platform. Under the hood, these SDKs rely on our core <em>data</em> <em>ingest</em> <em>APIs</em>: the Metric <em>API</em>, Trace <em>API</em>, Log <em>API</em>, and Event <em>API</em>. We offer open-source integrations for telemetry tools like Prometheus, Istio"
      },
      "id": "603ea196196a670192a83d83"
    },
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "3d1e1c9bdb5d2cbf172eb055dc83020e39dbd16b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/metric-api/introduction-metric-api/",
      "published_at": "2021-10-24T20:15:16Z",
      "updated_at": "2021-10-23T17:26:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. Want to try out our Metric API? Create a New Relic account for free! No credit card required. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. You'll need a New Relic license key for the New Relic account you want to send data to. For information on limits and restricted attributes, see Metric API requirements and limits. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting See Troubleshoot an NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.41223,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the Metric <em>API</em>",
        "sections": "Find <em>and</em> use your <em>data</em>",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": ", OpenCensus, and Prometheus). The Metric <em>API</em> is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our <em>data</em>-<em>ingest</em> <em>APIs</em>. The Metric <em>API</em> can be used to: Report metric <em>data</em> to New Relic without a New Relic agent. Integrate metric <em>data</em> from an open source"
      },
      "id": "6107858fe7b9d2f9dcfc108e"
    }
  ],
  "/docs/data-apis/ingest-apis/metric-api/troubleshoot-nrintegrationerror-events": [
    {
      "sections": [
        "Introduction to the Event API",
        "Requirements",
        "Basic workflow",
        "Tip",
        "Get the license key",
        "Format the JSON",
        "JSON format guidelines",
        "JSON example",
        "Limits and restricted characters",
        "Submit the custom event",
        "Linux/bash example",
        "Windows/PowerShell example",
        "Important",
        "Verify or troubleshoot request response",
        "Success response code",
        "Submission errors",
        "Parsing errors",
        "Query and alert with NrIntegrationError",
        "Find your data",
        "Limit on HTTP requests"
      ],
      "title": "Introduction to the Event API",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "eea369c63a48d26123e243ed4e8bff412b334146",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/introduction-event-api/",
      "published_at": "2021-10-24T21:24:29Z",
      "updated_at": "2021-10-23T17:26:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Event API is one way to report custom events to New Relic. The Event API lets you send custom event data to your New Relic account with a POST command. These events are then queryable and chartable using NRQL. Want to try out our Event API? Create a New Relic account for free! No credit card required. Related content: Learn about all options for reporting custom events. For details about how event data is retained, see Event data retention. For how to add attributes to existing events, see Add custom attributes. Check out New Relic University’s tutorial Adding custom events with the Event API (aka the Insights API). Or, go directly to the full online course Custom data. Requirements For Event API limits and restricted attributes, see Limits. Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name insights-collector.newrelic.com or insights-collector.eu01.nr-data.net. Basic workflow The Event API is an asynchronous endpoint. This allows you to send a very large volume of POSTS, reliably, with very low response latency. Tip If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. To send a custom event to a New Relic account: Get a license key for the account you want to report data to. Before creating custom events or attributes, review New Relic's list of reserved terms used by NRQL. Generate JSON for the event by instrumenting your application, querying an API, or some other method. Submit a compressed JSON payload (for example, gzip or deflate) to the HTTPS endpoint using curl in a POST request. Recommendation: Set up NRQL alert conditions to notify you when parsing errors occur. This method will send the events directly into your account, where they will be accessible from any NRQL interface or with the Query API. The Event API limits the size, rate, and characters allowed in custom events. Also, like other events available in NRQL, custom events cannot be updated or deleted after they are created. If you have problems with your custom event, follow the troubleshooting procedures or create a new custom event. Get the license key You'll need a license key. License keys are associated with an account, not a specific user. This means that anyone in the account with access to that key can use it. You can submit multiple event types to the same account with the same license key. However, to help ensure security, we recommend that you use different keys for different applications or data sources. Alternatively, you can use an Insights insert keyfor this API, but we recommend using a license key. Format the JSON The Event API accepts specific formats for attributes included in the payload. Only float or string values are allowed. JSON format guidelines When defining attributes for your custom events, follow these JSON format guidelines. Attributes JSON format guidelines eventType Required: The event's name. Float and string values Float value format: \"label\":value String value format: \"label\":\"value\" Data types The API only accepts key-value pairs, not map/object or array values. Supported data types for this API are strings and numbers (integers or floats). For more information, see Data requirements. Digits in strings For performance-related reasons, we do not cast values submitted to the API. For example, we treat 123 as a number and \"123\" as a string. The database will only store up to 64 bit numbers. Any numbers larger than 64 bits will be truncated. Dates For attributes that contain date information, use an unformatted Unix timestamp in the Insights data formatter. You can define the date attribute either in seconds or in milliseconds, both relative to the Unix epoch. Time Unless otherwise specified, the timestamp for a submitted event is the time it was submitted to New Relic. To specify a different time for the event, use the timestamp attribute. JSON example Here is an example of a typical JSON data set for sending with the API. This call sends two Purchase type events as a JSON array. You can add multiple events in a single HTTP call using a JSON array. [ { \"eventType\":\"Purchase\", \"account\":3, \"amount\":259.54 }, { \"eventType\":\"Purchase\", \"account\":5, \"amount\":12309, \"product\":\"Item\" } ] Copy When generating the JSON, make sure your attributes are properly formatted. Limits and restricted characters The following size and rate limits apply to events sent via the Event API: Max events per API call: 2K Payload total size: 1MB(10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. Number of attributes per event: 255 maximum Length of attribute name: 255 characters Length of attribute value: 4096 maximum character length There are rate limits on the number of HTTP requests per minute sent to the Event API. Some specific attributes have additional restrictions: accountId: This is a reserved attribute name. If it is included, it will be dropped during ingest. entity.guid, entity.name, and entity.type: These attributes are used internally to identify entities. Any values submitted with these keys in the attributes section of a metric data point may cause undefined behavior such as missing entities in the UI or telemetry not associating with the expected entities. For more information please refer to Entity synthesis. appId: Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType: Can be a combination of alphanumeric characters, _ underscores, and : colons. timestamp: Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. Submit the custom event Data submitted to the Event API uses a compressed JSON format in a simple HTTPS POST request. This example uses gzip, but you can also use deflate. Linux/bash example gzip -c example_events.json | curl -X POST -H \"Content-Type: application/json\" -H \"Api-Key: YOUR_LICENSE_KEY\" -H \"Content-Encoding: gzip\" https://insights-collector.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/events --data-binary @- Copy Windows/PowerShell example $accountId = \"YOUR_ACCOUNT_ID\" $insertkey = \"YOUR_LICENSE_KEY\" # Replace with your custom event for the body $body = '[{\"eventType\": \"powershell\", \"account\": 4, \"amount\": 123, \"fileLocation\": \"c:\\\\temp2\", \"zipped\": \"true\" }]' $headers = @{} $headers.Add(\"Api-Key\", \"$insertkey\") $headers.Add(\"Content-Encoding\", \"gzip\") $encoding = [System.Text.Encoding]::UTF8 $enc_data = $encoding.GetBytes($body) $output = [System.IO.MemoryStream]::new() $gzipStream = New-Object System.IO.Compression.GzipStream $output, ([IO.Compression.CompressionMode]::Compress) $gzipStream.Write($enc_data, 0, $enc_data.Length) $gzipStream.Close() $gzipBody = $output.ToArray() Invoke-WebRequest -Headers $headers -Method Post -Body $gzipBody \"https://insights-collector.newrelic.com/v1/accounts/$accountId/events\" Copy Important Always use compression with every payload. This allows you to send more data, and it saves resources during parsing. Before generating your HTTP request, make sure it is properly formatted, including: The Api-Key contains the correct license key. The Content-Type is application/json. The request uses POST only. The API does not accept PUT and GET requests. The API supports HTTP/1.1 persistent connections. This is helpful to manage client-side performance under heavy event loads. Verify or troubleshoot request response The Event API follows a two-step process to process requests: The Event API synchronously acknowledges or rejects the request based on validation of the headers and payload size. The Event API asynchronously parses the payload after a successful HTTP response is provided to the client. This may generate an error due to missing or malformed data. These are classified as submission errors or parsing errors. All successful submissions receive a 200 response, regardless of any data errors that may exist within the payload. The response includes a uuid, which is a unique ID created for each request. The uuid also appears in any error events created for the request. Other potential issues: 10-second timeout: API calls exceeding 10 seconds will time out. Large payloads: Payloads exceeding 100 KB may see increased response times. Recommendation: In addition to checking for a success message, create a NRQL query of your data to verify it's available. Success response code Success message Comments 200 {\"success\":true,\"uuid\":\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"} Copy Submission errors Payloads with submission errors are handled and returned to the sender through an HTTP response code. To troubleshoot payload submission errors, refer to these HTTP response codes. Submission errors Troubleshooting 400 Missing or invalid content length: Unable to process empty request. 403 Missing or invalid key: Invalid license key. Register a valid license key. 408 Request timed out: Request took too long to process. 413 Content too large: Request is too large to process. Refer to the limits and restricted characters to troubleshoot. 415 Invalid content type: Must be application/JSON. The Event API accepts any content type except multi-part/related and assumes it can be parsed to JSON. 429 Too many requests due to rate limiting. 503 Service temporarily unavailable: Retry request Parsing errors Parsing errors occur if: An event is sent within a payload, but it is either missing data or is exceeding maximum limits. New Relic will drop the individual event from the payload, generate an NrIntegrationError event, and process the rest. The JSON payload includes malformed JSON or missing required data. Payloads with parsing errors receive a 200 response to indicate a successful submission. To help resolve parsing errors, a new NrIntegrationError event type is created. All parsing errors are due to NRQL queries. For error messages related to dropped events, New Relic will include the number of events that were dropped as part of the message. To troubleshoot requests with parsing errors, refer to these error messages. Parsing errors Troubleshooting X event(s) rejected because attribute appId was not an integer An appId attribute has a non-integer value, such as a decimal value or string. X event(s) rejected because eventType cannot contain the following characters: [., \\] An eventType attributed included an invalid character, such as a period or backslash. X event(s) rejected because attribute is missing attribute name An attribute name was set to null or an empty string. X event(s) rejected because attribute name exceeded maximum length An attribute name has more than 255 characters. X event(s) rejected because attribute value exceeded maximum length An attribute value was longer than 4096 characters. X event(s) rejected because event exceeded maximum number of attributes An event has more than 255 attributes. X event(s) rejected because missing required attributes eventType The eventType attribute is required for the custom event. Error parsing JSON payload There was an error parsing the request JSON because of formatting problems or corrupted data. Query and alert with NrIntegrationError The NrIntegrationError event allows you to query and set alerts on custom data being sent to your New Relic account. Recommendation: To get alerts for parsing errors, create a NRQL alert condition for NrIntegrationError. Use this example NRQL query: SELECT message FROM NrIntegrationError WHERE newRelicFeature = 'Event API' AND category = 'EventApiException' Copy NrIntegrationError attributes Troubleshooting timestamp The timestamp when the request was received. The timestamp attribute takes a 64-bit integer Unix timestamp within the last 24 hours. You can define timestamps either in seconds or in milliseconds, both relative to the Unix epoch. Do not use a decimal for the timestamp. If a decimal is used, the attribute will default to the timestamp when the custom event was created. newRelicFeature The name of the feature experiencing errors. For all custom event parsing errors, this will be Event API. apiKeyPrefix The first six characters of the license key used for the request that generated an error. requestId The uuid returned by the the API for the request that generated an error. Category The category of the error. For custom events, this is EventApiException. Message Contents of the error message. Name The error's name. For custom events, this is always EventValidationException. eventTypeSample One of the event types that generated the error, when available. Find your data To find data sent via the Event API (and from integrations that use this API), you can query it. For example, to query a custom event using NRQL, you would run: SELECT * FROM YOUR_CUSTOM_EVENT Copy For more on how to query, see Query data. Limit on HTTP requests The Event API has a rate limit of 100,000 HTTP requests (POSTs) per minute, per account. (Note that this is not a limit on the number of events per minute; only on the number of POSTs per minute.) This limit helps ensure that large traffic spikes in accounts across our multi-tenant platform do not negatively affect how the service performs for you. If your API usage exceeds 100k POSTs in a 1-minute window, we will reject subsequent API requests with a 429 response code for the remainder of the 1-minute window. At the end of the 1-minute window, the counter will be reset and allow traffic to resume. This limit is intended to be an upper threshold that you shouldn't hit under normal scenarios. If you have a high number of 429 responses, consider using the API less. If you are expecting a higher-than-normal activity level in the near future and want to prepare for that, contact technical support.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.41223,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the Event <em>API</em>",
        "sections": "Introduction to the Event <em>API</em>",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": "The New Relic Event <em>API</em> is one way to report custom events to New Relic. The Event <em>API</em> lets you send custom event <em>data</em> to your New Relic account with a POST command. These events are then queryable and chartable using NRQL. Want to try out our Event <em>API</em>? Create a New Relic account for free"
      },
      "id": "609fa5fb64441f9d9fd2a1e2"
    },
    {
      "sections": [
        "Telemetry SDKs: Report custom telemetry data",
        "Requirements and compatibility",
        "Tip",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one",
        "Integrations built with the Telemetry SDKs"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "d883a07b7ede4c3beaba4077c507b95f9a228435",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/telemetry-sdks-report-custom-telemetry-data/",
      "published_at": "2021-10-24T19:37:31Z",
      "updated_at": "2021-10-23T17:26:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the Metric API, Trace API, Log API, and Event API. We offer open-source integrations for telemetry tools like Prometheus, Istio, and OpenCensus that were created using our Telemetry SDKs. If those solutions (or our other integrations) don't meet your needs, you can use the Telemetry SDKs to create your own telemetry data solutions. Requirements and compatibility The Telemetry SDKs use our Metric API, Event API, Log API, and Trace API, which all require a license key, so you'll need a license key for the account you wish to send data to. Tip New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported New Relic data types Java Java library on GitHub Metrics Events Logs Traces Node/TypeScript NodeJS library on GitHub Metrics Traces Python Python library on GitHub Metrics Events Logs Traces Go Go library on Github Metrics Traces .NET .NET library on GitHub .NET package in NuGet Metrics Traces C C library on Github Traces Rust Rust library on Github Traces Ruby Ruby library on Github Gem on Rubygems Traces For more on the supported data types, see: An overview of New Relic data types Metrics: see the Metric API Logs: see the Log API Traces: see the Trace API Events: see the Event API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications. Integrations built with the Telemetry SDKs To see the integrations built using our Telemetry SDKs, see Open source telemetry integrations. For all monitoring solutions, see our integrations page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.41205,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Telemetry SDKs: Report custom telemetry <em>data</em>",
        "sections": "Telemetry SDKs: Report custom telemetry <em>data</em>",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": "Our Telemetry SDKs are an open source set of <em>API</em> client libraries that send <em>data</em> to the New Relic platform. Under the hood, these SDKs rely on our core <em>data</em> <em>ingest</em> <em>APIs</em>: the Metric <em>API</em>, Trace <em>API</em>, Log <em>API</em>, and Event <em>API</em>. We offer open-source integrations for telemetry tools like Prometheus, Istio"
      },
      "id": "603ea196196a670192a83d83"
    },
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "3d1e1c9bdb5d2cbf172eb055dc83020e39dbd16b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/metric-api/introduction-metric-api/",
      "published_at": "2021-10-24T20:15:16Z",
      "updated_at": "2021-10-23T17:26:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. Want to try out our Metric API? Create a New Relic account for free! No credit card required. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. You'll need a New Relic license key for the New Relic account you want to send data to. For information on limits and restricted attributes, see Metric API requirements and limits. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting See Troubleshoot an NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.41205,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the Metric <em>API</em>",
        "sections": "Find <em>and</em> use your <em>data</em>",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": ", OpenCensus, and Prometheus). The Metric <em>API</em> is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our <em>data</em>-<em>ingest</em> <em>APIs</em>. The Metric <em>API</em> can be used to: Report metric <em>data</em> to New Relic without a New Relic agent. Integrate metric <em>data</em> from an open source"
      },
      "id": "6107858fe7b9d2f9dcfc108e"
    }
  ],
  "/docs/data-apis/ingest-apis/telemetry-sdks-report-custom-telemetry-data": [
    {
      "sections": [
        "Introduction to the Event API",
        "Requirements",
        "Basic workflow",
        "Tip",
        "Get the license key",
        "Format the JSON",
        "JSON format guidelines",
        "JSON example",
        "Limits and restricted characters",
        "Submit the custom event",
        "Linux/bash example",
        "Windows/PowerShell example",
        "Important",
        "Verify or troubleshoot request response",
        "Success response code",
        "Submission errors",
        "Parsing errors",
        "Query and alert with NrIntegrationError",
        "Find your data",
        "Limit on HTTP requests"
      ],
      "title": "Introduction to the Event API",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "eea369c63a48d26123e243ed4e8bff412b334146",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/introduction-event-api/",
      "published_at": "2021-10-24T21:24:29Z",
      "updated_at": "2021-10-23T17:26:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Event API is one way to report custom events to New Relic. The Event API lets you send custom event data to your New Relic account with a POST command. These events are then queryable and chartable using NRQL. Want to try out our Event API? Create a New Relic account for free! No credit card required. Related content: Learn about all options for reporting custom events. For details about how event data is retained, see Event data retention. For how to add attributes to existing events, see Add custom attributes. Check out New Relic University’s tutorial Adding custom events with the Event API (aka the Insights API). Or, go directly to the full online course Custom data. Requirements For Event API limits and restricted attributes, see Limits. Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name insights-collector.newrelic.com or insights-collector.eu01.nr-data.net. Basic workflow The Event API is an asynchronous endpoint. This allows you to send a very large volume of POSTS, reliably, with very low response latency. Tip If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. To send a custom event to a New Relic account: Get a license key for the account you want to report data to. Before creating custom events or attributes, review New Relic's list of reserved terms used by NRQL. Generate JSON for the event by instrumenting your application, querying an API, or some other method. Submit a compressed JSON payload (for example, gzip or deflate) to the HTTPS endpoint using curl in a POST request. Recommendation: Set up NRQL alert conditions to notify you when parsing errors occur. This method will send the events directly into your account, where they will be accessible from any NRQL interface or with the Query API. The Event API limits the size, rate, and characters allowed in custom events. Also, like other events available in NRQL, custom events cannot be updated or deleted after they are created. If you have problems with your custom event, follow the troubleshooting procedures or create a new custom event. Get the license key You'll need a license key. License keys are associated with an account, not a specific user. This means that anyone in the account with access to that key can use it. You can submit multiple event types to the same account with the same license key. However, to help ensure security, we recommend that you use different keys for different applications or data sources. Alternatively, you can use an Insights insert keyfor this API, but we recommend using a license key. Format the JSON The Event API accepts specific formats for attributes included in the payload. Only float or string values are allowed. JSON format guidelines When defining attributes for your custom events, follow these JSON format guidelines. Attributes JSON format guidelines eventType Required: The event's name. Float and string values Float value format: \"label\":value String value format: \"label\":\"value\" Data types The API only accepts key-value pairs, not map/object or array values. Supported data types for this API are strings and numbers (integers or floats). For more information, see Data requirements. Digits in strings For performance-related reasons, we do not cast values submitted to the API. For example, we treat 123 as a number and \"123\" as a string. The database will only store up to 64 bit numbers. Any numbers larger than 64 bits will be truncated. Dates For attributes that contain date information, use an unformatted Unix timestamp in the Insights data formatter. You can define the date attribute either in seconds or in milliseconds, both relative to the Unix epoch. Time Unless otherwise specified, the timestamp for a submitted event is the time it was submitted to New Relic. To specify a different time for the event, use the timestamp attribute. JSON example Here is an example of a typical JSON data set for sending with the API. This call sends two Purchase type events as a JSON array. You can add multiple events in a single HTTP call using a JSON array. [ { \"eventType\":\"Purchase\", \"account\":3, \"amount\":259.54 }, { \"eventType\":\"Purchase\", \"account\":5, \"amount\":12309, \"product\":\"Item\" } ] Copy When generating the JSON, make sure your attributes are properly formatted. Limits and restricted characters The following size and rate limits apply to events sent via the Event API: Max events per API call: 2K Payload total size: 1MB(10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. Number of attributes per event: 255 maximum Length of attribute name: 255 characters Length of attribute value: 4096 maximum character length There are rate limits on the number of HTTP requests per minute sent to the Event API. Some specific attributes have additional restrictions: accountId: This is a reserved attribute name. If it is included, it will be dropped during ingest. entity.guid, entity.name, and entity.type: These attributes are used internally to identify entities. Any values submitted with these keys in the attributes section of a metric data point may cause undefined behavior such as missing entities in the UI or telemetry not associating with the expected entities. For more information please refer to Entity synthesis. appId: Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType: Can be a combination of alphanumeric characters, _ underscores, and : colons. timestamp: Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. Submit the custom event Data submitted to the Event API uses a compressed JSON format in a simple HTTPS POST request. This example uses gzip, but you can also use deflate. Linux/bash example gzip -c example_events.json | curl -X POST -H \"Content-Type: application/json\" -H \"Api-Key: YOUR_LICENSE_KEY\" -H \"Content-Encoding: gzip\" https://insights-collector.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/events --data-binary @- Copy Windows/PowerShell example $accountId = \"YOUR_ACCOUNT_ID\" $insertkey = \"YOUR_LICENSE_KEY\" # Replace with your custom event for the body $body = '[{\"eventType\": \"powershell\", \"account\": 4, \"amount\": 123, \"fileLocation\": \"c:\\\\temp2\", \"zipped\": \"true\" }]' $headers = @{} $headers.Add(\"Api-Key\", \"$insertkey\") $headers.Add(\"Content-Encoding\", \"gzip\") $encoding = [System.Text.Encoding]::UTF8 $enc_data = $encoding.GetBytes($body) $output = [System.IO.MemoryStream]::new() $gzipStream = New-Object System.IO.Compression.GzipStream $output, ([IO.Compression.CompressionMode]::Compress) $gzipStream.Write($enc_data, 0, $enc_data.Length) $gzipStream.Close() $gzipBody = $output.ToArray() Invoke-WebRequest -Headers $headers -Method Post -Body $gzipBody \"https://insights-collector.newrelic.com/v1/accounts/$accountId/events\" Copy Important Always use compression with every payload. This allows you to send more data, and it saves resources during parsing. Before generating your HTTP request, make sure it is properly formatted, including: The Api-Key contains the correct license key. The Content-Type is application/json. The request uses POST only. The API does not accept PUT and GET requests. The API supports HTTP/1.1 persistent connections. This is helpful to manage client-side performance under heavy event loads. Verify or troubleshoot request response The Event API follows a two-step process to process requests: The Event API synchronously acknowledges or rejects the request based on validation of the headers and payload size. The Event API asynchronously parses the payload after a successful HTTP response is provided to the client. This may generate an error due to missing or malformed data. These are classified as submission errors or parsing errors. All successful submissions receive a 200 response, regardless of any data errors that may exist within the payload. The response includes a uuid, which is a unique ID created for each request. The uuid also appears in any error events created for the request. Other potential issues: 10-second timeout: API calls exceeding 10 seconds will time out. Large payloads: Payloads exceeding 100 KB may see increased response times. Recommendation: In addition to checking for a success message, create a NRQL query of your data to verify it's available. Success response code Success message Comments 200 {\"success\":true,\"uuid\":\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"} Copy Submission errors Payloads with submission errors are handled and returned to the sender through an HTTP response code. To troubleshoot payload submission errors, refer to these HTTP response codes. Submission errors Troubleshooting 400 Missing or invalid content length: Unable to process empty request. 403 Missing or invalid key: Invalid license key. Register a valid license key. 408 Request timed out: Request took too long to process. 413 Content too large: Request is too large to process. Refer to the limits and restricted characters to troubleshoot. 415 Invalid content type: Must be application/JSON. The Event API accepts any content type except multi-part/related and assumes it can be parsed to JSON. 429 Too many requests due to rate limiting. 503 Service temporarily unavailable: Retry request Parsing errors Parsing errors occur if: An event is sent within a payload, but it is either missing data or is exceeding maximum limits. New Relic will drop the individual event from the payload, generate an NrIntegrationError event, and process the rest. The JSON payload includes malformed JSON or missing required data. Payloads with parsing errors receive a 200 response to indicate a successful submission. To help resolve parsing errors, a new NrIntegrationError event type is created. All parsing errors are due to NRQL queries. For error messages related to dropped events, New Relic will include the number of events that were dropped as part of the message. To troubleshoot requests with parsing errors, refer to these error messages. Parsing errors Troubleshooting X event(s) rejected because attribute appId was not an integer An appId attribute has a non-integer value, such as a decimal value or string. X event(s) rejected because eventType cannot contain the following characters: [., \\] An eventType attributed included an invalid character, such as a period or backslash. X event(s) rejected because attribute is missing attribute name An attribute name was set to null or an empty string. X event(s) rejected because attribute name exceeded maximum length An attribute name has more than 255 characters. X event(s) rejected because attribute value exceeded maximum length An attribute value was longer than 4096 characters. X event(s) rejected because event exceeded maximum number of attributes An event has more than 255 attributes. X event(s) rejected because missing required attributes eventType The eventType attribute is required for the custom event. Error parsing JSON payload There was an error parsing the request JSON because of formatting problems or corrupted data. Query and alert with NrIntegrationError The NrIntegrationError event allows you to query and set alerts on custom data being sent to your New Relic account. Recommendation: To get alerts for parsing errors, create a NRQL alert condition for NrIntegrationError. Use this example NRQL query: SELECT message FROM NrIntegrationError WHERE newRelicFeature = 'Event API' AND category = 'EventApiException' Copy NrIntegrationError attributes Troubleshooting timestamp The timestamp when the request was received. The timestamp attribute takes a 64-bit integer Unix timestamp within the last 24 hours. You can define timestamps either in seconds or in milliseconds, both relative to the Unix epoch. Do not use a decimal for the timestamp. If a decimal is used, the attribute will default to the timestamp when the custom event was created. newRelicFeature The name of the feature experiencing errors. For all custom event parsing errors, this will be Event API. apiKeyPrefix The first six characters of the license key used for the request that generated an error. requestId The uuid returned by the the API for the request that generated an error. Category The category of the error. For custom events, this is EventApiException. Message Contents of the error message. Name The error's name. For custom events, this is always EventValidationException. eventTypeSample One of the event types that generated the error, when available. Find your data To find data sent via the Event API (and from integrations that use this API), you can query it. For example, to query a custom event using NRQL, you would run: SELECT * FROM YOUR_CUSTOM_EVENT Copy For more on how to query, see Query data. Limit on HTTP requests The Event API has a rate limit of 100,000 HTTP requests (POSTs) per minute, per account. (Note that this is not a limit on the number of events per minute; only on the number of POSTs per minute.) This limit helps ensure that large traffic spikes in accounts across our multi-tenant platform do not negatively affect how the service performs for you. If your API usage exceeds 100k POSTs in a 1-minute window, we will reject subsequent API requests with a 429 response code for the remainder of the 1-minute window. At the end of the 1-minute window, the counter will be reset and allow traffic to resume. This limit is intended to be an upper threshold that you shouldn't hit under normal scenarios. If you have a high number of 429 responses, consider using the API less. If you are expecting a higher-than-normal activity level in the near future and want to prepare for that, contact technical support.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.41223,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the Event <em>API</em>",
        "sections": "Introduction to the Event <em>API</em>",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": "The New Relic Event <em>API</em> is one way to report custom events to New Relic. The Event <em>API</em> lets you send custom event <em>data</em> to your New Relic account with a POST command. These events are then queryable and chartable using NRQL. Want to try out our Event <em>API</em>? Create a New Relic account for free"
      },
      "id": "609fa5fb64441f9d9fd2a1e2"
    },
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "3d1e1c9bdb5d2cbf172eb055dc83020e39dbd16b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/metric-api/introduction-metric-api/",
      "published_at": "2021-10-24T20:15:16Z",
      "updated_at": "2021-10-23T17:26:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. Want to try out our Metric API? Create a New Relic account for free! No credit card required. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. You'll need a New Relic license key for the New Relic account you want to send data to. For information on limits and restricted attributes, see Metric API requirements and limits. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting See Troubleshoot an NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.41205,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the Metric <em>API</em>",
        "sections": "Find <em>and</em> use your <em>data</em>",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": ", OpenCensus, and Prometheus). The Metric <em>API</em> is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our <em>data</em>-<em>ingest</em> <em>APIs</em>. The Metric <em>API</em> can be used to: Report metric <em>data</em> to New Relic without a New Relic agent. Integrate metric <em>data</em> from an open source"
      },
      "id": "6107858fe7b9d2f9dcfc108e"
    },
    {
      "sections": [
        "Troubleshoot Metric API with NRIntegrationError events",
        "Problem",
        "Solution",
        "View error details",
        "Match errors to ingested payloads",
        "Programmatically retrieve NrIntegrationError events",
        "Tip"
      ],
      "title": "Troubleshoot Metric API with NRIntegrationError events",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "50ad21a895fc1f2644bdbfbadf85ecfd298b08d6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/metric-api/troubleshoot-nrintegrationerror-events/",
      "published_at": "2021-10-24T20:16:09Z",
      "updated_at": "2021-10-23T17:26:33Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You sent metric data points to the Metric API, and are not seeing what you expect when querying the data. Use the following checklist to determine the root cause: Make sure you are querying the data correctly. Check the HTTP status codes returned by the API. Issues like authorization failures can be diagnosed with HTTP status codes. If you are sending data from a Prometheus server via New Relic's remote_write endpoint, check your Prometheus server logs for errors or non-2xx HTTP responses from the New Relic endpoint. Query your account for NrIntegrationError events. New Relic's ingestion endpoints are asynchronous, meaning the endpoint verifies the payload after it returns the HTTP response. If any issues occur while verifying your payload, then an NrIntegrationError event will be created in your account. New Relic also uses NrIntegrationError events to notify customers when various rate limits have been reached. Solution View error details For an introduction to using the NrIntegrationError event, see NrIntegrationError. Here's an example NRQL for examining issues with Metric API ingest: SELECT count(*) FROM NrIntegrationError WHERE newRelicFeature = 'Metrics' facet category, message limit 100 since 24 hours ago Copy The category indicates the type of error and the message provides more detailed information about the error. If the category is rateLimit, then you should also examine the rateLimitType field for more information on the type of rate limiting. Category rateLimitType Description and solution BadRequest (not set) There is an issue with the JSON payload. These include JSON syntax errors, attribute names, or values that are too long. Check the message field to determine the exact issue. Then review the JSON payload, and update it to ensure it meets the proper semantic guidelines. RateLimit DatapointsPerMinute You are sending too many datapoints per minute. If you get this error, you can either send data less frequently, or request changes to your metric rate limits by contacting your New Relic account representative, or visiting our Support portal. RateLimit UniqueTimeseriesPerDay You have an attribute with a high number of unique values, like containerId or URI. To resolve this error, review any attributes that may be causing the issue and remove them. If desired, you can use a data dropping rule to remove attributes at ingest time. RateLimit UniquePrometheusTimeseries You have Prometheus servers reporting too many unique timeseries via New Relic's remote_write endpoint. Reduce the number of unique timeseries reported by modifying your Prometheus server configuration to reduce the number of targets being scraped, or by using relabel rules in the remote_write section of your server configuration to drop timeseries or highly unique labels. RateLimit RequestsPerMinute Too many requests per minute are being sent. To resolve this, put more datapoints in each request, and send them less frequently. RateLimit ErrorGroupsPerDay You have exceeded your daily error group limit. Incoming error groups will be dropped for the remainder of the day and will continue as normal after UTC midnight. To resolve this, reduce the amount of unique error messages collected by New Relic. Match errors to ingested payloads When an NrIntegrationError event is created as a result of a syntax issue with the HTTP request payload, then the event contains the attributes apiKeyPrefix and requestId. The apiKeyPrefix matches the first 6 characters of the API key used to send the data. The requestId matches the requestId sent in the HTTP response. To view these fields, run this NRQL query: SELECT message, apiKeyPrefix, requestId FROM NrIntegrationError limit 100 Copy To verify a specific requestId, run this NRQL query: SELECT * FROM NrIntegrationError where requestId ='REQUEST_ID' Copy Programmatically retrieve NrIntegrationError events To programmatically retrieve these errors: Ensure you have an Insights query API key (go to insights.newrelic.com > Manage data > API keys). Create an HTTP request as shown below: Tip If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. curl -H \"Accept: application/json\" -H \"X-Query-Key:YOUR_API_KEY_HERE\" \"https://insights-api.newrelic.com/v1/accounts/YOUR_ACCOUNT_HERE/query?nrql=SELECT%20*%20FROM%20NrIntegrationError%20where%20newRelicFeature='Metrics'\" Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.41205,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshoot Metric <em>API</em> with NRIntegrationError events",
        "sections": "Troubleshoot Metric <em>API</em> with NRIntegrationError events",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": " To programmatically retrieve these errors: Ensure you have an Insights query <em>API</em> key (go to insights.newrelic.com &gt; <em>Manage</em> <em>data</em> &gt; <em>API</em> keys). Create an HTTP request as shown below: Tip If your account hosts <em>data</em> in the EU <em>data</em> center, ensure you&#x27;re using the proper <em>API</em> endpoints for EU region accounts. curl -H"
      },
      "id": "610f2900196a678a5d38ad82"
    }
  ],
  "/docs/data-apis/manage-data/drop-data-using-nerdgraph": [
    {
      "sections": [
        "Manage your data",
        "Important",
        "Where to find the Data management hub",
        "Better cost, performance, and compliance",
        "Cost management",
        "Performance management",
        "Ingest and retention strategies"
      ],
      "title": "Manage your data",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Manage data"
      ],
      "external_id": "999fa6106dd47250e9a5d822aa2f92b6ea088c78",
      "image": "https://docs.newrelic.com/static/8a553ce9643c8513be3200af5d924250/c1b63/datamanagement_overview.png",
      "url": "https://docs.newrelic.com/docs/data-apis/manage-data/manage-your-data/",
      "published_at": "2021-10-24T21:25:18Z",
      "updated_at": "2021-10-23T17:30:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "At New Relic, we're super proud of NRDB, the New Relic database where we store your data. It gathers all your telemetry data in one place, gives you a connected view of all your data, and scales as your business grows. We invite you to send all your metrics, events, logs, and traces to NRDB, including those from third-party sources. We also recognize that some data might not be necessary for your business goals. You shouldn’t have to wade through data you don’t need to get to the data you do. And you definitely shouldn’t have to pay for it. That’s where our data management tools come in: they let you decide what data you send to New Relic and how long it should be stored. Data management hub: from the user profile drop down, select Manage your data. Coupled with user management tools, data management helps you get maximum value from your investment in New Relic, all while safeguarding your data. Important Not yet a New Relic customer? Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Where to find the Data management hub To locate the data management UI: From one.newrelic.com select the account dropdown, and select Manage your data. If you're on the New Relic One user model, you can also find the Data management hub by selecting Administration > Manage data. Better cost, performance, and compliance Collecting and storing data in New Relic allows you to analyze, visualize, and alert on all your metrics, events, logs, and traces from across all of your sources. However, it’s important to manage that data for cost, performance, and in some cases, compliance reasons. The data management hub provides the tools you need to understand and control where your data is coming from, and adjust what’s stored and for how long. Important If you're on our original product-based pricing plan, you'll see your data ingest, retention, and limits in the Data management hub. The primary difference is that you're not billed on ingest, as with our New Relic One pricing plan. Not sure which plan you're on? See Overview of pricing and user model. Cost management The cost of data storage continually decreases, but storage is still an expense. The amount of data you process and store is closely related to the value you receive from New Relic, because it’s a key component of how you’re charged. Our ingest process helps you hone your data. For example, data might arrive at our processing front door compressed and of varying quality. Through ingest, that data is uncompressed, decorated with queryable attributes, and evaluated. Elements are dropped or trimmed, all before we write it to NRDB. That way, the data you store is only the data you want most. Performance management While NRDB is a phenomenally scalable database, it’s also a reality that queries across huge datasets might not return results in a timely enough fashion for your needs. You get better performance if you limit the data we store, or convert it into a format that keeps it easily queryable. Drop data to improve performance by reducing the amount of data that’s stored. Ingest and retention strategies Depending on your goals, whether to reduce costs, increase specific retention rates, or pare down your data to what’s most essential, we have a strategy for you. Learn about reducing the amount of data that comes into NRDB in Manage data coming into New Relic. Learn about customizing storage so you only store the data you want, for the period you want in Manage data stored in New Relic. Learn about dropping data in Drop data using NerdGraph. And for dropping log data, see Drop data with drop filter rules.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2009.0057,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage your <em>data</em>",
        "sections": "Manage your <em>data</em>",
        "tags": "Ingest and manage <em>data</em>",
        "body": " have a strategy for you. Learn about reducing the amount of <em>data</em> that comes into NRDB in Manage <em>data</em> coming into New Relic. Learn about customizing storage so you only store the <em>data</em> you want, for the period you want in Manage <em>data</em> stored in New Relic. Learn about dropping <em>data</em> in <em>Drop</em> <em>data</em> <em>using</em> <em>NerdGraph</em>. And for dropping log <em>data</em>, see <em>Drop</em> <em>data</em> with <em>drop</em> filter rules."
      },
      "id": "603e96ff28ccbcf8bceba796"
    },
    {
      "sections": [
        "Security guide",
        "Tip",
        "Security Program",
        "Security Domains",
        "Security Certifications",
        "Data Control, Facilities, and Encryption",
        "Law Enforcement Request Report"
      ],
      "title": "Security guide",
      "type": "docs",
      "tags": [
        "Licenses",
        "License information",
        "Referenced policies"
      ],
      "external_id": "356f0d11ffcb62208a743a0a7c127f5f6da9c940",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/license-information/referenced-policies/security-guide/",
      "published_at": "2021-10-24T16:16:03Z",
      "updated_at": "2021-09-19T15:21:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Last updated September 17, 2021. This is supplement to our security policy and serves as a guide to New Relic’s description of its Services, functionalities, and features. Tip We may update the URLs in this document without notice. Security Program New Relic follows \"privacy by design\" principles as described here: https://docs.newrelic.com/docs/security/security-privacy/data-privacy/data-privacy-new-relic/. Security Domains New Relic’s policies and procedures cover industry-recognized security domains such as Endpoint Protection; Portable Media Security; Mobile Device Security; Wireless Security; Configuration Management; Vulnerability Management; Network Protection; Transmission Protection; Password Management; Access Control, Audit Logging & Monitoring; Education, Training, and Awareness; Third Party Assurance; Incident Management; Business Continuity and Disaster Recover; Risk Management; Data Protection & Privacy; and Service Management Systems. Security Certifications New Relic audits its Services against industry standards as described at https://docs.newrelic.com/docs/security/security-privacy/compliance/regulatory-audits-new-relic-services/. Data Control, Facilities, and Encryption New Relic's customers can send data to New Relic's APIs by (1) using New Relic's software, (2) using vendor-neutral software that is managed and maintained by a third-party such as via OpenTelemetry instrumentation provided by opentelemetry.io, or (3) from third-party systems that customer's manage and/or control. New Relic's customers can use New Relic's Services such as NerdGraph to filter out and drop data. See https://docs.newrelic.com/docs/telemetry-data-platform/manage-data/drop-data-using-nerdgraph/. New Relic's customers can adjust their data retention periods as appropriate for their needs. See https://docs.newrelic.com/docs/telemetry-data-platform/manage-data/manage-data-retention/#adjust-retention. New Relic Logs obfuscates numbers that match known patterns, such as bank card and social security numbers as described here: https://docs.newrelic.com/docs/logs/log-management/get-started/new-relics-log-management-security-privacy/. New Relic honors requests to delete personal data in accordance with applicable privacy laws. Please see https://docs.newrelic.com/docs/security/security-privacy/data-privacy/data-privacy-new-relic/. Customers may use New Relic's APIs to query data, such as NerdGraph described here, and New Relic Services to export the data to other cloud providers. Customers can configure its log forwarder [https://docs.newrelic.com/docs/logs/enable-log-management-new-relic/enable-log-monitoring-new-relic/forward-your-logs-using-infrastructure-agent/] before sending infrastructure logs to New Relic. For New Relic Customers in New Relic US, FedRAMP and HIPAA-enabled environments, Customer Data is replicated to the off-site backup system via Amazon Simple Storage Service (S3). Category of Customer Description FedRAMP HIPAA-enabled US Gen Pop EU Gen Pop Data is stored in Amazon Web Services (“AWS”). Limited Data is stored in IBM Data for New Relic Incident Intelligence is stored in Google Cloud New Relic regularly tests, assess, and evaluates its measures to ensure the security of processing using industry-recognized standards and uses independent third-party auditors as provided below: Annual SOC 2 Type 2 Annual FedRAMP assessment by an independent third-party pursuant to NIST 800-53 rev 4 Moderate authorization. Annual HITRUST-validated assessment by an independent third-party *Pursuing CY2021 Q4 ISO 27001 *Pursuing CY2021 TISAX *Pursuing CY2021 The Services that operate on Amazon Web Services (“AWS”) are protected by the security and environmental controls of AWS. Detailed information about AWS security is available at https://aws.amazon.com/security/ and http://aws.amazon.com/security/sharing-the-security-responsibility/. Data encryption at rest utilizes FIPS 140-2 compliant encryption methodology. For AWS SOC Reports, please see https://aws.amazon.com/compliance/soc-faqs/. The Services that operate on Google Cloud Platform (\"GCP\") are protected by the security and environmental controls of GCP. Detailed information about GCP security is available at https://cloud.google.com/docs/tutorials#security. For GCP reports, please see https://cloud.google.com/security/compliance/. IBM Deft Zayo QTS Law Enforcement Request Report New Relic has not to date received any request for customer data from a law enforcement or other government agency (including under any national security process), and has not made any corresponding disclosures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1324.978,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Data</em> Control, Facilities, and Encryption",
        "body": " that customer&#x27;s manage and&#x2F;or control. New Relic&#x27;s customers can <em>use</em> New Relic&#x27;s Services such as <em>NerdGraph</em> to filter out and <em>drop</em> <em>data</em>. See https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;telemetry-<em>data</em>-platform&#x2F;manage-<em>data</em>&#x2F;<em>drop</em>-<em>data</em>-<em>using</em>-<em>nerdgraph</em>&#x2F;. New Relic&#x27;s customers can adjust their <em>data</em> retention periods as appropriate"
      },
      "id": "6147558128ccbc973a56a863"
    },
    {
      "sections": [
        "Data privacy with New Relic",
        "Tip",
        "Personal data transfer (Privacy Shield and SCC)",
        "Compliance with legal requirements",
        "Privacy by design and by default",
        "Personal data requests (GDPR, CCPA, etc.)",
        "Events and attributes",
        "Dropping data at ingest",
        "Technical security controls",
        "Organizational security controls",
        "Account security",
        "Retention of your data",
        "New Relic account emails",
        "Account changes (NrAuditEvent)",
        "Account usage",
        "Security for products and services",
        "Alerts and Applied Intelligence",
        "APIs",
        "APM",
        "Browser monitoring",
        "Diagnostics",
        "Infrastructure monitoring",
        "Integrations and serverless monitoring",
        "Logs management",
        "Mobile monitoring",
        "Synthetic monitoring"
      ],
      "title": "Data privacy with New Relic",
      "type": "docs",
      "tags": [
        "Security",
        "Security and Privacy",
        "Data privacy"
      ],
      "external_id": "d46953520476285467540433180d483815efecc6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/security/security-privacy/data-privacy/data-privacy-new-relic/",
      "published_at": "2021-10-25T16:18:55Z",
      "updated_at": "2021-10-25T16:18:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic takes your data privacy seriously. Our principles-based approach aims to go beyond the legal requirements for consent. We understand your concerns when you entrust us with your data, and we always strive to embrace your expectations and preferences. This document provides links to detailed information about the privacy and security measures we take to protect you and your customers' data privacy. Our monitoring tools are data-agnostic; they don't require sensitive materials, and many of them don't require any personal data. You are responsible for ensuring that your systems are appropriately set up and configured so that they don't send inappropriate personal data or sensitive materials to New Relic monitoring tools. For additional information about policies, credentials, audits, and other resources, see our New Relic security website. Tip New Relic now offers the option of HIPPA-enabled accounts for customers meeting certain requirements. To learn more, see HIPAA readiness at New Relic. Personal data transfer (Privacy Shield and SCC) The Schrems case ruling invalidates Privacy Shield. However, it explicitly reaffirms the validity of Standard Contractual Clauses (SCC) as an appropriate legal mechanism to transfer personal data outside of the European Union. You can find more information in How the Demise of Privacy Shield Affects Your New Relic Account. If you want to send personal data from the EU, we offer an appropriate data processing agreement (DPA) with SCC to govern the transfer of that data in accordance with the Schrems decision. For more information, consult our Data Processing Addendum FAQ, or download our pre-signed DPA (PDF|697 KB). Compliance with legal requirements We always strive to comply with all applicable laws as they take effect. This includes the European Union's General Data Protection Regulation (GDPR) and all relevant US State laws, such as the California Consumer Privacy Act (CCPA). Our disk-based encryption provides additional security while your data is at rest (FIPS 140-2 compliant). In addition, we are authorized for Moderate Impact SaaS Services (FedRAMP Authorized Moderate) for accounts that meet specific criteria. For privacy-related details about New Relic's contractual and regulatory commitments for services, see: Terms of Service or Master Subscription Agreement Data Protection Agreement Services Privacy Notice For more information about annual audits, see Regulatory audits for New Relic services. Privacy by design and by default New Relic follows \"privacy by design\" principles as part of our overarching security program. For example, when New Relic agents capture a webpage or referrer URL, all query parameters are stripped by default. Here are examples of how we incorporate privacy considerations into our data and security practices. Personal data requests (GDPR, CCPA, etc.) New Relic strives to comply with all applicable laws as they take effect. This includes the European Union's GDPR and ePrivacy Directive and all applicable privacy laws, such as the California Consumer Privacy Act (CCPA) in the US. For more information about our process when responding to requests to access or delete personal data, see New Relic personal data requests. Events and attributes You can query events and attributes, as well as create charts and alert conditions about this data. For a complete list of all events and attributes tracked by New Relic agents, see our data dictionary. Events and attributes example: If you use the Infrastructure ProcessSample event's commandLine attribute, by default we strip options and arguments from the full command line to prevent accidental leakage of sensitive information. Dropping data at ingest Dropping data gives you control over the data that you send to New Relic, including any personal data that you configured to be collected. By dropping specific events or attributes from events, you determine what data New Relic ultimately stores so that you can query, alert on, and analyze it. For more information, see Drop data using NerdGraph. When our agents refer to data obfuscation, the agent actually removes the data before sending it to New Relic. The data cannot be recovered. For example, with APM queries, the Record SQL? value defaults to obfuscated. This strips the string literals and numeric sequences and then replaces them with the ? character. You can mask sensitive information in HTTP or HTTPS requests. For example, queries about distributed traces and transaction traces are obfuscated by default, in which case they cannot be recovered. For more information, see the documentation for specific New Relic services, including: APM transaction traces Distributed tracing Technical security controls We use a comprehensive set of technical controls to support general security needs as well as security for data we receive. For more information, see our documentation about data security, data encryption, and high security mode for APM agents. Organizational security controls New Relic maintains a number of internal policies and procedures to guide employees in privacy-related subjects such as data classification and handling, data retention, handling of personal data, fulfilling personal data requests, incident response, etc. All employees must complete the security and privacy training upon hiring and renew this training annually. Account security Our role-based account structure gives you direct control over who can access or change your account settings. For more information, see Users and roles. Retention of your data The New Relic One platform gives you a single source of truth for all your operational data, empowering you to ask and answer any question in milliseconds. This platform stores different types of data for different periods of time. The Data retention page in our UI provides information on how long your data will be stored in the New Relic database (NRDB). For more information, see Manage data retention. New Relic account emails By default, we communicate with you for a variety of purposes related to your status as New Relic subscribers. This includes product engagement, support, alert notifications, updates, billings, etc. Individual users can unsubscribe from certain communications. General email preferences are managed through the account user interface. For more information, see Account email settings. Alert notification emails are managed through the alerting UI. Account changes (NrAuditEvent) To view changes made to your account's users or to record configuration changes, query NrAuditEvent events. To be notified about account changes, create NRQL alert conditions. For more about available NrAuditEvent attributes, see our data dictionary. Account usage For more about usage, see Manage data. Security for products and services We publish security bulletins with detailed information about vulnerabilities, remediation strategies, and applicable updates for affected software. To receive notifications for future advisories, use either of these options: Subscribe to our security bulletins RSS feed. Select the Watching option in our Explorers Hub's Security notifications community channel to receive email alerts. The following summarizes how individual New Relic products and components ensure security, with links to additional details. Alerts and Applied Intelligence By default, our alerting services do not record any personal data. In addition, they automatically set default permissions for individual account users and access levels within account structures. For more information, see our documentation about Applied Intelligence, as well as our rules and limits for alerts. APIs APIs simply are interfaces for data exchange automation. APIs have no knowledge of the content being transferred. We require authorized users to provide their API keys to monitor subscription usage, manage account user permissions, query data, and perform other automated tasks. For more information, see Introduction to New Relic APIs. APM APM agents monitor your applications' performance. By default, APM agents do not record any personal data. For more information, see our APM security documentation. Browser monitoring Our browser monitoring agent allows you to monitor the performance of their websites. For more information, see: Browser security documentation Visitor's IP address New Relic cookies used by browser Enabling or disabling cookie collection for session tracking Diagnostics The New Relic Diagnostics service inspects relevant system information and any other necessary information (such as logs and config files) to perform diagnostic checks that assess configuration and operability. By default, this data is not transmitted to New Relic. You do have the option to upload this information to a support ticket over HTTPS. For more information, see the Diagnostics security documentation. Infrastructure monitoring The Infrastructure agent allows you to monitor the performance of components in your ecosystem, such as servers, platforms, operating systems, databases, etc. Infrastructure may record the userID and username of users connecting to Infrastructure resources. For more information, see the security documentation for infrastructure monitoring. Integrations and serverless monitoring Our integrations services allow you to retrieve and load data into the New Relic database from a variety of sources, including: Cloud-based integrations On-host integrations in containerized environments, such as Kubernetes On-host integrations built by New Relic On-host integrations built by the open-source community On-host integrations built by you Depending on the integration, different types of data may be recorded so that you can monitor the integrations in New Relic. The integration services are data agnostic. They will have no knowledge of whether the imported data contains any personal information. For more information, see the documentation for the specific integration, including: Amazon Web Services (AWS) Google Cloud Platform (GCP) Kubernetes Microsoft Azure On-host integrations Open source on-host integrations Serverless function monitoring Logs management Due to the nature of our logs management service, you have direct control over what data is reported to New Relic. To ensure data privacy and to limit the types of information New Relic receives, no customer data is captured except what you supply in your API calls or log forwarder configuration. All data for the logs service is then reported to New Relic over HTTPS. The logs service does mask number patterns that appear to be for items such as credit cards or Social Security numbers. For more information, see the Logs security documentation. Mobile monitoring By default, our mobile monitoring service collects two pieces of personal data: The IP address is used to derive high-level geographical data, and then is discarded. A device ID is generated by New Relic and is used for billing purposes. For more information, see our security documentation for mobile monitoring. Synthetic monitoring The synthetic monitoring service uses monitors distributed throughout data centers around the world. It captures what is essentially performance data of simulated traffic. By default, it does not capture any personal data. For more information, see the data privacy and security documentation for synthetic monitoring. If you configure the synthetic service to monitor areas of websites that are located behind a login page, take care to create a non-personal login dedicated to this purpose. This will reduce the risk of unintended personal data exposure. For example, to securely store sensitive information, such as passwords, API keys, and user names, you can use secured credentials for scripted browsers and API tests. The synthetic monitoring service also supports a variety of authentication mechanisms. Depending on the type of monitor you choose, this includes Basic, Digest, NTLM, and NTLMv2. You can also control which of your users can access your monitors and private locations. For more information, see our documentation about user role-based permissions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1190.1322,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Data</em> privacy with New Relic",
        "sections": "<em>Dropping</em> <em>data</em> at ingest",
        "tags": "<em>Data</em> privacy",
        "body": " or attributes from events, you determine what <em>data</em> New Relic ultimately stores so that you can query, alert on, and analyze it. For more information, see <em>Drop</em> <em>data</em> <em>using</em> <em>NerdGraph</em>. When our agents refer to <em>data</em> obfuscation, the agent actually removes the <em>data</em> before sending it to New Relic. The <em>data</em>"
      },
      "id": "603ec2d4e7b9d22fba2a07c6"
    }
  ],
  "/docs/data-apis/manage-data/manage-data-coming-new-relic": [
    {
      "sections": [
        "Know your data limits",
        "Responses to limit violations",
        "System limits UI",
        "Troubleshooting system limits",
        "Account-level limits",
        "Data ingest API limits",
        "Finding other agent and integration limits"
      ],
      "title": "Know your data limits",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Manage data"
      ],
      "external_id": "7c540d94a8b5e4f024d175ad53cab9fab343187c",
      "image": "https://docs.newrelic.com/static/8ee61e3091f6e044202cff92026afada/8c557/limits-graph.png",
      "url": "https://docs.newrelic.com/docs/data-apis/manage-data/view-system-limits/",
      "published_at": "2021-10-24T21:26:09Z",
      "updated_at": "2021-10-23T17:31:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To ensure our systems are always up and ready to support you, and to keep you from unintended use, we place limits on the amount of data you can send, query, and store. Responses to limit violations Limits are enforced per child account, and across our APIs. You might reach a limit if you start monitoring a new high-traffic application, or have a sudden data spike. When you do reach a limit, New Relic responds according to the type of data and the limit that’s reached. For example: We place a limit on the number of ingested requests per minute (RPM) per data type. When this limit is reached, we stop accepting data and return a 429 status code for the duration of the minute. For queries, we place limits on the number of queries per minute and the number of records inspected (see query limits). When the number of queries per minute limit is reached, New Relic will begin rejecting queries until the number of queries is below the limit. When the records inspected limit is reached, New Relic will reject traffic from the source scanning the largest number of records and attempt to allow traffic from other sources. For metrics, we place a limit on the number of unique timeseries (cardinality) per account and per metric. When this limit is reached, aggregated data is turned off for the rest of the UTC day. For every major limit violation, New Relic creates an NrIntegrationError event for that account, which has these limit-related attributes: Attribute Description category RateLimit or ApiLimit. The RateLimit category is used for limits based on a unit of time such as the number of requests ingested per minute. The ApiLimit is used for constant limits, such as the number of attributes on a record. limitName The name of the limit. message Describes the limit and the impact. limitValue The limit reached. System limits UI The system Limits page (from the account dropdown, click Manage your data and click Limits on the left) displays when your account has encountered a rate limit in the specified time period. The page displays a default period of 24 hours; you can set a custom range from the top-right of the page. Non-limit-related NrIntegrationError events are not displayed here. In addition, this page does not display information about limits you have not hit, or how close you are to reaching a limit. For more on creating queries and alerts for data ingest and billing metrics, see Query billing/usage data. one.newrelic.com > account dropdown > Manage your data > Limits: An example of a chart on the Limits UI page displaying a cardinality violation limit issue. To add more detail, or build a dashboard, click the View NRQL button on the chart to see the NRQL powering this view. The graph displays each unique limit type that was reached during the selected time-period. This can help you find any trends based on time. The Limits page also provides a table where you can find the limit name, the limit event message associated with it, and last occurrence time and date. If you click a limit in the table, you see more about what happened, and when. one.newrelic.com > account dropdown > Manage your data > Limits: An example of a limit events table on the Limits UI page. Troubleshooting system limits To troubleshoot limits when you reach them, click the limit info in the table, and then follow the docs link that's provided. Different limits have different solutions. Account-level limits The following table includes general max limits that apply across all New Relic accounts. Specific New Relic tools, like agents and integrations, have their own limits and configurations, and might be lower than these theoretical maximum limits. Limited condition Limit Rate of NRDB record * ingest 55 million per account per minute Max NRDB records * ingested per API call 1MB (10^6 bytes) Max attribute value size 1KB (10^3 bytes) Max payload size 1MB (10^6 bytes) Max total attributes per data type (including default attributes) 254 (less for some tools; for example, 64 for agents) Number of unique custom data types 250 per account per day (applies to custom events because that's source of new data types) APM limits Agent instances: 50K per account Agent instances per app: 10K APM apps/services: 10K per second Browser: number of page views 1M per minute per app Distributed tracing: Max age of span timestamp values 20 minutes. Timestamp must be within 20 minutes of current time at ingest or within 20 minutes from the time the last span with the same trace.id was received by New Relic. Distributed tracing: Max spans per minute per account Dependent on agreement. Max limit: 2M. Distributed tracing: Max spans per trace 50K Distributed tracing: Max attributes per span 200 Rate of metric timeslice data (used by APM, browser, mobile) Ingest: 2 million per minute Rate of names: 4 million per minute per account Number per monitored app: 300K Mobile monitoring: number of crashes reported 10K per hour Infrastructure agents, integrations Number of infrastructure agents and/or integrations: 5K per account Gross number of new monitored containers: 5K per hour per account Query limits NRDB records * inspected: 100 billion per account per hour Rate of queries: 20 per account per second See other query limits * NRDB records refers to database records for our core data types, which includes events, metrics (dimensional), logs, and distributed tracing (span) data, all stored in the New Relic database (NRDB). This does not include metric timeslice data. Data ingest API limits Our ingest APIs have additional limits that may override the more general account-level limits. Note that these limits also apply to our tools that use these APIs (like our Telemetry SDKs or our open source telemetry integrations). Metric API (dimensional metrics) Event API Log API Trace API Finding other agent and integration limits To find limits for our other agents and integrations, which will override more general account-level limits, see the docs for those tools: you can search our solutions here. Some default reporting limits are located in these tools' configuration docs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 333.76794,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Know your <em>data</em> limits",
        "sections": "<em>Data</em> <em>ingest</em> API limits",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": ". limitValue The limit reached. System limits UI The system Limits page (from the account dropdown, click <em>Manage</em> your <em>data</em> and click Limits on the left) displays when your account has encountered a rate limit in the specified time period. The page displays a default period of 24 hours; you can set"
      },
      "id": "60446a7c64441f48d7378f2b"
    },
    {
      "sections": [
        "Manage your data",
        "Important",
        "Where to find the Data management hub",
        "Better cost, performance, and compliance",
        "Cost management",
        "Performance management",
        "Ingest and retention strategies"
      ],
      "title": "Manage your data",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Manage data"
      ],
      "external_id": "999fa6106dd47250e9a5d822aa2f92b6ea088c78",
      "image": "https://docs.newrelic.com/static/8a553ce9643c8513be3200af5d924250/c1b63/datamanagement_overview.png",
      "url": "https://docs.newrelic.com/docs/data-apis/manage-data/manage-your-data/",
      "published_at": "2021-10-24T21:25:18Z",
      "updated_at": "2021-10-23T17:30:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "At New Relic, we're super proud of NRDB, the New Relic database where we store your data. It gathers all your telemetry data in one place, gives you a connected view of all your data, and scales as your business grows. We invite you to send all your metrics, events, logs, and traces to NRDB, including those from third-party sources. We also recognize that some data might not be necessary for your business goals. You shouldn’t have to wade through data you don’t need to get to the data you do. And you definitely shouldn’t have to pay for it. That’s where our data management tools come in: they let you decide what data you send to New Relic and how long it should be stored. Data management hub: from the user profile drop down, select Manage your data. Coupled with user management tools, data management helps you get maximum value from your investment in New Relic, all while safeguarding your data. Important Not yet a New Relic customer? Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Where to find the Data management hub To locate the data management UI: From one.newrelic.com select the account dropdown, and select Manage your data. If you're on the New Relic One user model, you can also find the Data management hub by selecting Administration > Manage data. Better cost, performance, and compliance Collecting and storing data in New Relic allows you to analyze, visualize, and alert on all your metrics, events, logs, and traces from across all of your sources. However, it’s important to manage that data for cost, performance, and in some cases, compliance reasons. The data management hub provides the tools you need to understand and control where your data is coming from, and adjust what’s stored and for how long. Important If you're on our original product-based pricing plan, you'll see your data ingest, retention, and limits in the Data management hub. The primary difference is that you're not billed on ingest, as with our New Relic One pricing plan. Not sure which plan you're on? See Overview of pricing and user model. Cost management The cost of data storage continually decreases, but storage is still an expense. The amount of data you process and store is closely related to the value you receive from New Relic, because it’s a key component of how you’re charged. Our ingest process helps you hone your data. For example, data might arrive at our processing front door compressed and of varying quality. Through ingest, that data is uncompressed, decorated with queryable attributes, and evaluated. Elements are dropped or trimmed, all before we write it to NRDB. That way, the data you store is only the data you want most. Performance management While NRDB is a phenomenally scalable database, it’s also a reality that queries across huge datasets might not return results in a timely enough fashion for your needs. You get better performance if you limit the data we store, or convert it into a format that keeps it easily queryable. Drop data to improve performance by reducing the amount of data that’s stored. Ingest and retention strategies Depending on your goals, whether to reduce costs, increase specific retention rates, or pare down your data to what’s most essential, we have a strategy for you. Learn about reducing the amount of data that comes into NRDB in Manage data coming into New Relic. Learn about customizing storage so you only store the data you want, for the period you want in Manage data stored in New Relic. Learn about dropping data in Drop data using NerdGraph. And for dropping log data, see Drop data with drop filter rules.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 333.75677,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Manage</em> your <em>data</em>",
        "sections": "<em>Manage</em> your <em>data</em>",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": " in: they let you decide what <em>data</em> you send to New Relic and how long it should be stored. <em>Data</em> management hub: from the user profile drop down, select <em>Manage</em> your <em>data</em>. Coupled with user management tools, <em>data</em> management helps you get maximum value from your investment in New Relic, all while safeguarding"
      },
      "id": "603e96ff28ccbcf8bceba796"
    },
    {
      "sections": [
        "Get data into New Relic",
        "New Relic-built agents and integrations",
        "Report custom data"
      ],
      "title": "Get data into New Relic",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Get started"
      ],
      "external_id": "016a25d46dedc5da1455b29d8557ce68a4345756",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/get-started/introduction-new-relic-data-ingest-apis-sdks/",
      "published_at": "2021-10-24T19:36:34Z",
      "updated_at": "2021-10-23T17:32:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are many ways to get data into your New Relic account. Any New Relic user can use any of our data ingest methods to report data to our platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure monitoring, or any of our wide array of integrations, by default you'll receive data from your monitored applications, hosts, services, or other entities. Some options for getting started: Log into one.newrelic.com and click Add more data to get some guidance on setting up New Relic solutions. To browse our solutions, see New Relic integrations. Report custom data If you need to report data that our agents and integrations don't provide, we have tools that will allow you to bring in any type of data you need. To learn more, see Intro to custom data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 301.60693,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get <em>data</em> into New Relic",
        "sections": "Get <em>data</em> into New Relic",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": "There are many ways to get <em>data</em> into your New Relic account. Any New Relic user can use any of our <em>data</em> <em>ingest</em> methods to report <em>data</em> to our platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure"
      },
      "id": "6174474328ccbcdff4c6b77e"
    }
  ],
  "/docs/data-apis/manage-data/manage-data-retention": [
    {
      "sections": [
        "Security guide",
        "Tip",
        "Security Program",
        "Security Domains",
        "Security Certifications",
        "Data Control, Facilities, and Encryption",
        "Law Enforcement Request Report"
      ],
      "title": "Security guide",
      "type": "docs",
      "tags": [
        "Licenses",
        "License information",
        "Referenced policies"
      ],
      "external_id": "356f0d11ffcb62208a743a0a7c127f5f6da9c940",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/license-information/referenced-policies/security-guide/",
      "published_at": "2021-10-24T16:16:03Z",
      "updated_at": "2021-09-19T15:21:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Last updated September 17, 2021. This is supplement to our security policy and serves as a guide to New Relic’s description of its Services, functionalities, and features. Tip We may update the URLs in this document without notice. Security Program New Relic follows \"privacy by design\" principles as described here: https://docs.newrelic.com/docs/security/security-privacy/data-privacy/data-privacy-new-relic/. Security Domains New Relic’s policies and procedures cover industry-recognized security domains such as Endpoint Protection; Portable Media Security; Mobile Device Security; Wireless Security; Configuration Management; Vulnerability Management; Network Protection; Transmission Protection; Password Management; Access Control, Audit Logging & Monitoring; Education, Training, and Awareness; Third Party Assurance; Incident Management; Business Continuity and Disaster Recover; Risk Management; Data Protection & Privacy; and Service Management Systems. Security Certifications New Relic audits its Services against industry standards as described at https://docs.newrelic.com/docs/security/security-privacy/compliance/regulatory-audits-new-relic-services/. Data Control, Facilities, and Encryption New Relic's customers can send data to New Relic's APIs by (1) using New Relic's software, (2) using vendor-neutral software that is managed and maintained by a third-party such as via OpenTelemetry instrumentation provided by opentelemetry.io, or (3) from third-party systems that customer's manage and/or control. New Relic's customers can use New Relic's Services such as NerdGraph to filter out and drop data. See https://docs.newrelic.com/docs/telemetry-data-platform/manage-data/drop-data-using-nerdgraph/. New Relic's customers can adjust their data retention periods as appropriate for their needs. See https://docs.newrelic.com/docs/telemetry-data-platform/manage-data/manage-data-retention/#adjust-retention. New Relic Logs obfuscates numbers that match known patterns, such as bank card and social security numbers as described here: https://docs.newrelic.com/docs/logs/log-management/get-started/new-relics-log-management-security-privacy/. New Relic honors requests to delete personal data in accordance with applicable privacy laws. Please see https://docs.newrelic.com/docs/security/security-privacy/data-privacy/data-privacy-new-relic/. Customers may use New Relic's APIs to query data, such as NerdGraph described here, and New Relic Services to export the data to other cloud providers. Customers can configure its log forwarder [https://docs.newrelic.com/docs/logs/enable-log-management-new-relic/enable-log-monitoring-new-relic/forward-your-logs-using-infrastructure-agent/] before sending infrastructure logs to New Relic. For New Relic Customers in New Relic US, FedRAMP and HIPAA-enabled environments, Customer Data is replicated to the off-site backup system via Amazon Simple Storage Service (S3). Category of Customer Description FedRAMP HIPAA-enabled US Gen Pop EU Gen Pop Data is stored in Amazon Web Services (“AWS”). Limited Data is stored in IBM Data for New Relic Incident Intelligence is stored in Google Cloud New Relic regularly tests, assess, and evaluates its measures to ensure the security of processing using industry-recognized standards and uses independent third-party auditors as provided below: Annual SOC 2 Type 2 Annual FedRAMP assessment by an independent third-party pursuant to NIST 800-53 rev 4 Moderate authorization. Annual HITRUST-validated assessment by an independent third-party *Pursuing CY2021 Q4 ISO 27001 *Pursuing CY2021 TISAX *Pursuing CY2021 The Services that operate on Amazon Web Services (“AWS”) are protected by the security and environmental controls of AWS. Detailed information about AWS security is available at https://aws.amazon.com/security/ and http://aws.amazon.com/security/sharing-the-security-responsibility/. Data encryption at rest utilizes FIPS 140-2 compliant encryption methodology. For AWS SOC Reports, please see https://aws.amazon.com/compliance/soc-faqs/. The Services that operate on Google Cloud Platform (\"GCP\") are protected by the security and environmental controls of GCP. Detailed information about GCP security is available at https://cloud.google.com/docs/tutorials#security. For GCP reports, please see https://cloud.google.com/security/compliance/. IBM Deft Zayo QTS Law Enforcement Request Report New Relic has not to date received any request for customer data from a law enforcement or other government agency (including under any national security process), and has not made any corresponding disclosures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 534.2781,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Data</em> Control, Facilities, and Encryption",
        "body": " that customer&#x27;s <em>manage</em> and&#x2F;or control. New Relic&#x27;s customers can use New Relic&#x27;s Services such as NerdGraph to filter out and drop <em>data</em>. See https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;telemetry-<em>data</em>-platform&#x2F;<em>manage</em>-<em>data</em>&#x2F;drop-<em>data</em>-using-nerdgraph&#x2F;. New Relic&#x27;s customers can adjust their <em>data</em> <em>retention</em> periods as appropriate"
      },
      "id": "6147558128ccbc973a56a863"
    },
    {
      "sections": [
        "Data privacy with New Relic",
        "Tip",
        "Personal data transfer (Privacy Shield and SCC)",
        "Compliance with legal requirements",
        "Privacy by design and by default",
        "Personal data requests (GDPR, CCPA, etc.)",
        "Events and attributes",
        "Dropping data at ingest",
        "Technical security controls",
        "Organizational security controls",
        "Account security",
        "Retention of your data",
        "New Relic account emails",
        "Account changes (NrAuditEvent)",
        "Account usage",
        "Security for products and services",
        "Alerts and Applied Intelligence",
        "APIs",
        "APM",
        "Browser monitoring",
        "Diagnostics",
        "Infrastructure monitoring",
        "Integrations and serverless monitoring",
        "Logs management",
        "Mobile monitoring",
        "Synthetic monitoring"
      ],
      "title": "Data privacy with New Relic",
      "type": "docs",
      "tags": [
        "Security",
        "Security and Privacy",
        "Data privacy"
      ],
      "external_id": "d46953520476285467540433180d483815efecc6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/security/security-privacy/data-privacy/data-privacy-new-relic/",
      "published_at": "2021-10-25T16:18:55Z",
      "updated_at": "2021-10-25T16:18:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic takes your data privacy seriously. Our principles-based approach aims to go beyond the legal requirements for consent. We understand your concerns when you entrust us with your data, and we always strive to embrace your expectations and preferences. This document provides links to detailed information about the privacy and security measures we take to protect you and your customers' data privacy. Our monitoring tools are data-agnostic; they don't require sensitive materials, and many of them don't require any personal data. You are responsible for ensuring that your systems are appropriately set up and configured so that they don't send inappropriate personal data or sensitive materials to New Relic monitoring tools. For additional information about policies, credentials, audits, and other resources, see our New Relic security website. Tip New Relic now offers the option of HIPPA-enabled accounts for customers meeting certain requirements. To learn more, see HIPAA readiness at New Relic. Personal data transfer (Privacy Shield and SCC) The Schrems case ruling invalidates Privacy Shield. However, it explicitly reaffirms the validity of Standard Contractual Clauses (SCC) as an appropriate legal mechanism to transfer personal data outside of the European Union. You can find more information in How the Demise of Privacy Shield Affects Your New Relic Account. If you want to send personal data from the EU, we offer an appropriate data processing agreement (DPA) with SCC to govern the transfer of that data in accordance with the Schrems decision. For more information, consult our Data Processing Addendum FAQ, or download our pre-signed DPA (PDF|697 KB). Compliance with legal requirements We always strive to comply with all applicable laws as they take effect. This includes the European Union's General Data Protection Regulation (GDPR) and all relevant US State laws, such as the California Consumer Privacy Act (CCPA). Our disk-based encryption provides additional security while your data is at rest (FIPS 140-2 compliant). In addition, we are authorized for Moderate Impact SaaS Services (FedRAMP Authorized Moderate) for accounts that meet specific criteria. For privacy-related details about New Relic's contractual and regulatory commitments for services, see: Terms of Service or Master Subscription Agreement Data Protection Agreement Services Privacy Notice For more information about annual audits, see Regulatory audits for New Relic services. Privacy by design and by default New Relic follows \"privacy by design\" principles as part of our overarching security program. For example, when New Relic agents capture a webpage or referrer URL, all query parameters are stripped by default. Here are examples of how we incorporate privacy considerations into our data and security practices. Personal data requests (GDPR, CCPA, etc.) New Relic strives to comply with all applicable laws as they take effect. This includes the European Union's GDPR and ePrivacy Directive and all applicable privacy laws, such as the California Consumer Privacy Act (CCPA) in the US. For more information about our process when responding to requests to access or delete personal data, see New Relic personal data requests. Events and attributes You can query events and attributes, as well as create charts and alert conditions about this data. For a complete list of all events and attributes tracked by New Relic agents, see our data dictionary. Events and attributes example: If you use the Infrastructure ProcessSample event's commandLine attribute, by default we strip options and arguments from the full command line to prevent accidental leakage of sensitive information. Dropping data at ingest Dropping data gives you control over the data that you send to New Relic, including any personal data that you configured to be collected. By dropping specific events or attributes from events, you determine what data New Relic ultimately stores so that you can query, alert on, and analyze it. For more information, see Drop data using NerdGraph. When our agents refer to data obfuscation, the agent actually removes the data before sending it to New Relic. The data cannot be recovered. For example, with APM queries, the Record SQL? value defaults to obfuscated. This strips the string literals and numeric sequences and then replaces them with the ? character. You can mask sensitive information in HTTP or HTTPS requests. For example, queries about distributed traces and transaction traces are obfuscated by default, in which case they cannot be recovered. For more information, see the documentation for specific New Relic services, including: APM transaction traces Distributed tracing Technical security controls We use a comprehensive set of technical controls to support general security needs as well as security for data we receive. For more information, see our documentation about data security, data encryption, and high security mode for APM agents. Organizational security controls New Relic maintains a number of internal policies and procedures to guide employees in privacy-related subjects such as data classification and handling, data retention, handling of personal data, fulfilling personal data requests, incident response, etc. All employees must complete the security and privacy training upon hiring and renew this training annually. Account security Our role-based account structure gives you direct control over who can access or change your account settings. For more information, see Users and roles. Retention of your data The New Relic One platform gives you a single source of truth for all your operational data, empowering you to ask and answer any question in milliseconds. This platform stores different types of data for different periods of time. The Data retention page in our UI provides information on how long your data will be stored in the New Relic database (NRDB). For more information, see Manage data retention. New Relic account emails By default, we communicate with you for a variety of purposes related to your status as New Relic subscribers. This includes product engagement, support, alert notifications, updates, billings, etc. Individual users can unsubscribe from certain communications. General email preferences are managed through the account user interface. For more information, see Account email settings. Alert notification emails are managed through the alerting UI. Account changes (NrAuditEvent) To view changes made to your account's users or to record configuration changes, query NrAuditEvent events. To be notified about account changes, create NRQL alert conditions. For more about available NrAuditEvent attributes, see our data dictionary. Account usage For more about usage, see Manage data. Security for products and services We publish security bulletins with detailed information about vulnerabilities, remediation strategies, and applicable updates for affected software. To receive notifications for future advisories, use either of these options: Subscribe to our security bulletins RSS feed. Select the Watching option in our Explorers Hub's Security notifications community channel to receive email alerts. The following summarizes how individual New Relic products and components ensure security, with links to additional details. Alerts and Applied Intelligence By default, our alerting services do not record any personal data. In addition, they automatically set default permissions for individual account users and access levels within account structures. For more information, see our documentation about Applied Intelligence, as well as our rules and limits for alerts. APIs APIs simply are interfaces for data exchange automation. APIs have no knowledge of the content being transferred. We require authorized users to provide their API keys to monitor subscription usage, manage account user permissions, query data, and perform other automated tasks. For more information, see Introduction to New Relic APIs. APM APM agents monitor your applications' performance. By default, APM agents do not record any personal data. For more information, see our APM security documentation. Browser monitoring Our browser monitoring agent allows you to monitor the performance of their websites. For more information, see: Browser security documentation Visitor's IP address New Relic cookies used by browser Enabling or disabling cookie collection for session tracking Diagnostics The New Relic Diagnostics service inspects relevant system information and any other necessary information (such as logs and config files) to perform diagnostic checks that assess configuration and operability. By default, this data is not transmitted to New Relic. You do have the option to upload this information to a support ticket over HTTPS. For more information, see the Diagnostics security documentation. Infrastructure monitoring The Infrastructure agent allows you to monitor the performance of components in your ecosystem, such as servers, platforms, operating systems, databases, etc. Infrastructure may record the userID and username of users connecting to Infrastructure resources. For more information, see the security documentation for infrastructure monitoring. Integrations and serverless monitoring Our integrations services allow you to retrieve and load data into the New Relic database from a variety of sources, including: Cloud-based integrations On-host integrations in containerized environments, such as Kubernetes On-host integrations built by New Relic On-host integrations built by the open-source community On-host integrations built by you Depending on the integration, different types of data may be recorded so that you can monitor the integrations in New Relic. The integration services are data agnostic. They will have no knowledge of whether the imported data contains any personal information. For more information, see the documentation for the specific integration, including: Amazon Web Services (AWS) Google Cloud Platform (GCP) Kubernetes Microsoft Azure On-host integrations Open source on-host integrations Serverless function monitoring Logs management Due to the nature of our logs management service, you have direct control over what data is reported to New Relic. To ensure data privacy and to limit the types of information New Relic receives, no customer data is captured except what you supply in your API calls or log forwarder configuration. All data for the logs service is then reported to New Relic over HTTPS. The logs service does mask number patterns that appear to be for items such as credit cards or Social Security numbers. For more information, see the Logs security documentation. Mobile monitoring By default, our mobile monitoring service collects two pieces of personal data: The IP address is used to derive high-level geographical data, and then is discarded. A device ID is generated by New Relic and is used for billing purposes. For more information, see our security documentation for mobile monitoring. Synthetic monitoring The synthetic monitoring service uses monitors distributed throughout data centers around the world. It captures what is essentially performance data of simulated traffic. By default, it does not capture any personal data. For more information, see the data privacy and security documentation for synthetic monitoring. If you configure the synthetic service to monitor areas of websites that are located behind a login page, take care to create a non-personal login dedicated to this purpose. This will reduce the risk of unintended personal data exposure. For example, to securely store sensitive information, such as passwords, API keys, and user names, you can use secured credentials for scripted browsers and API tests. The synthetic monitoring service also supports a variety of authentication mechanisms. Depending on the type of monitor you choose, this includes Basic, Digest, NTLM, and NTLMv2. You can also control which of your users can access your monitors and private locations. For more information, see our documentation about user role-based permissions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 459.25702,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Data</em> privacy with New Relic",
        "sections": "<em>Retention</em> of your <em>data</em>",
        "tags": "<em>Data</em> privacy",
        "body": " and answer any question in milliseconds. This platform stores different types of <em>data</em> for different periods of time. The <em>Data</em> <em>retention</em> page in our UI provides information on how long your <em>data</em> will be stored in the New Relic database (NRDB). For more information, see <em>Manage</em> <em>data</em> <em>retention</em>. New"
      },
      "id": "603ec2d4e7b9d22fba2a07c6"
    },
    {
      "sections": [
        "Introduction to New Relic NerdGraph, our GraphQL API",
        "What is NerdGraph?",
        "Important",
        "Use the GraphiQL explorer",
        "Requirements and endpoints",
        "What can you do with NerdGraph?",
        "NerdGraph terminology",
        "Tips on using the GraphiQL explorer",
        "Query accounts a New Relic user can access",
        "Query user, account, and NRQL in one request"
      ],
      "title": "Introduction to New Relic NerdGraph, our GraphQL API",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Get started"
      ],
      "external_id": "e8e96c16cd75f494ebfacb3bc53b4ee9ccf1c727",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph/",
      "published_at": "2021-10-24T20:33:46Z",
      "updated_at": "2021-08-27T08:50:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NerdGraph is our GraphQL-format API that lets you query New Relic data and configure some New Relic features. What is NerdGraph? New Relic has several APIs. NerdGraph is the API we recommend for querying New Relic data and for performing some specific configurations (learn more about features). NerdGraph provides a single API interface for returning data from New Relic’s various APIs and microservices. Over time, other configuration capabilities will be added to NerdGraph. Important NerdGraph isn’t used for data ingest. For that, you'd use our data ingest APIs. NerdGraph is built using GraphQL, which is an open source API format that allows you to request exactly the data needed, with no over-fetching or under-fetching. For a lesson in how to use NerdGraph, watch this 7-minute video: Want to watch more video tutorials? Go to the New Relic University’s Intro to NerdGraph. Or see the online course on New Relic APIs. Use the GraphiQL explorer To get started using GraphQL, we recommend playing around with our GraphiQL explorer (GraphiQL is an open source graphical interface for using GraphQL). You can use it to explore our data schema, to read built-in object definitions, and to build and execute queries. To use GraphQL, you’ll need a user-specific New Relic API key called a user key. You can generate one or find an existing one from the GraphiQL explorer’s API key dropdown. To find the GraphiQL explorer: If your New Relic account uses an EU data center, go to api.eu.newrelic.com/graphiql. Otherwise use api.newrelic.com/graphiql. For tips on how to build queries, see Build queries. Requirements and endpoints To use NerdGraph, you need a New Relic user key, which can be generated and accessed from the GraphiQL explorer. The endpoints are: Main endpoint: https://api.newrelic.com/graphql Endpoint for accounts using EU data center: https://api.eu.newrelic.com/graphql To access the endpoint, use the following cURL command: curl -X POST https://api.newrelic.com/graphql \\ -H 'Content-Type: application/json' \\ -H 'API-Key: YOUR_NEW_RELIC_USER_KEY' \\ -d '{ \"query\": \"{ requestContext { userId apiKey } }\" } ' Copy What can you do with NerdGraph? NerdGraph functionality can be broken down into two main categories: Querying New Relic data. You can fetch data for a variety of purposes, including using it in a programmatic workflow, or building a New Relic One app for custom data visualizations. Configuring New Relic features. There are a variety of configurations available and more will be added over time. You can do things like add tags, configure workloads, or customize \"golden metrics.\" You can use NerdGraph to return a wide range of New Relic data but we’ve created some tutorials for common use cases: Topic Tutorials Your monitored entities Get data about entities Understand entity relationships and dependencies (used to build service maps) Query and configure \"golden metrics\" (important entity metrics) Querying data Query using NRQL (our query language) Tags Add and manage tags Dashboards Create dashboards Export dashboards to other accounts Export dashboards as files Migrate from Insights Dashboard API to NerdGraph Alerts See all alert-related tutorials Applied Intelligence View and configure topology Workloads View and configure workloads Manage keys Create and manage keys (license keys used for data ingest, and user keys) Manage data Convert event data to metric data Drop data Distributed tracing Query distributed tracing data Configure Infinite Tracing New Relic One apps Build a New Relic One app Cloud integrations (AWS, Azure, GCP) Configure cloud integrations Partners and resellers Manage subscriptions (only for partners using original pricing plan) Data partitions Manage data partitions Date retention Manage data retention NerdGraph terminology The following are terms that originate with GraphQL (the API format NerdGraph uses). Term Definition Queries and mutations There are two classes of GraphQL operations: Queries are basic requests used only to fetch data. These queries are not static, meaning that you can ask for more data or less data, depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Mutations are requests that perform an action, such as creating a resource or changing configuration. Mutations require the keyword mutation, as well as the name of the mutation. Type Data in GraphQL is organized into types. Types can be scalars (like strings, numbers, or booleans) or object types. An object type is a custom type made up of a collection of fields. For example, an object type called User may represent a user in a system. Field A field represents a piece of information on an object type that can be queried. Fields can be scalars, lists, or objects. For example, a User object type could have a string field called name. Interface An interface is an abstract type that represents a collection of common fields that other object types can implement. Tips on using the GraphiQL explorer You can make queries with the NerdGraph GraphiQL explorer. The explorer provides built-in schema definitions and features, including auto-complete and query validation. Query accounts a New Relic user can access You can query for the name of an account that an actor (a New Relic authorized user) has access to: query { actor { account(id: YOUR_ACCOUNT_ID) { name } } } Copy The response will mirror the query structure you defined in the request, making it easy to ask for the specific data that you want. { \"data\": { \"actor\": { \"account\": { \"name\": \"Data Nerd\" } } } } Copy Query user, account, and NRQL in one request The graph structure shows its capabilities when queries become more complex. For example, you can query for user information, account information, and make a NRQL query with one request. With REST API, this would take three different requests to three different endpoints. query { actor { account(id: YOUR_ACCOUNT_ID) { name nrql(query: \"SELECT * FROM Transaction\") { results } } user { name id } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 433.8235,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " cloud integrations Partners and resellers <em>Manage</em> subscriptions (only for partners using original pricing plan) <em>Data</em> partitions <em>Manage</em> <em>data</em> partitions Date <em>retention</em> <em>Manage</em> <em>data</em> <em>retention</em> NerdGraph terminology The following are terms that originate with GraphQL (the API format NerdGraph uses). Term"
      },
      "id": "6043ff97196a67d0a0960f55"
    }
  ],
  "/docs/data-apis/manage-data/manage-your-data": [
    {
      "sections": [
        "Know your data limits",
        "Responses to limit violations",
        "System limits UI",
        "Troubleshooting system limits",
        "Account-level limits",
        "Data ingest API limits",
        "Finding other agent and integration limits"
      ],
      "title": "Know your data limits",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Manage data"
      ],
      "external_id": "7c540d94a8b5e4f024d175ad53cab9fab343187c",
      "image": "https://docs.newrelic.com/static/8ee61e3091f6e044202cff92026afada/8c557/limits-graph.png",
      "url": "https://docs.newrelic.com/docs/data-apis/manage-data/view-system-limits/",
      "published_at": "2021-10-24T21:26:09Z",
      "updated_at": "2021-10-23T17:31:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To ensure our systems are always up and ready to support you, and to keep you from unintended use, we place limits on the amount of data you can send, query, and store. Responses to limit violations Limits are enforced per child account, and across our APIs. You might reach a limit if you start monitoring a new high-traffic application, or have a sudden data spike. When you do reach a limit, New Relic responds according to the type of data and the limit that’s reached. For example: We place a limit on the number of ingested requests per minute (RPM) per data type. When this limit is reached, we stop accepting data and return a 429 status code for the duration of the minute. For queries, we place limits on the number of queries per minute and the number of records inspected (see query limits). When the number of queries per minute limit is reached, New Relic will begin rejecting queries until the number of queries is below the limit. When the records inspected limit is reached, New Relic will reject traffic from the source scanning the largest number of records and attempt to allow traffic from other sources. For metrics, we place a limit on the number of unique timeseries (cardinality) per account and per metric. When this limit is reached, aggregated data is turned off for the rest of the UTC day. For every major limit violation, New Relic creates an NrIntegrationError event for that account, which has these limit-related attributes: Attribute Description category RateLimit or ApiLimit. The RateLimit category is used for limits based on a unit of time such as the number of requests ingested per minute. The ApiLimit is used for constant limits, such as the number of attributes on a record. limitName The name of the limit. message Describes the limit and the impact. limitValue The limit reached. System limits UI The system Limits page (from the account dropdown, click Manage your data and click Limits on the left) displays when your account has encountered a rate limit in the specified time period. The page displays a default period of 24 hours; you can set a custom range from the top-right of the page. Non-limit-related NrIntegrationError events are not displayed here. In addition, this page does not display information about limits you have not hit, or how close you are to reaching a limit. For more on creating queries and alerts for data ingest and billing metrics, see Query billing/usage data. one.newrelic.com > account dropdown > Manage your data > Limits: An example of a chart on the Limits UI page displaying a cardinality violation limit issue. To add more detail, or build a dashboard, click the View NRQL button on the chart to see the NRQL powering this view. The graph displays each unique limit type that was reached during the selected time-period. This can help you find any trends based on time. The Limits page also provides a table where you can find the limit name, the limit event message associated with it, and last occurrence time and date. If you click a limit in the table, you see more about what happened, and when. one.newrelic.com > account dropdown > Manage your data > Limits: An example of a limit events table on the Limits UI page. Troubleshooting system limits To troubleshoot limits when you reach them, click the limit info in the table, and then follow the docs link that's provided. Different limits have different solutions. Account-level limits The following table includes general max limits that apply across all New Relic accounts. Specific New Relic tools, like agents and integrations, have their own limits and configurations, and might be lower than these theoretical maximum limits. Limited condition Limit Rate of NRDB record * ingest 55 million per account per minute Max NRDB records * ingested per API call 1MB (10^6 bytes) Max attribute value size 1KB (10^3 bytes) Max payload size 1MB (10^6 bytes) Max total attributes per data type (including default attributes) 254 (less for some tools; for example, 64 for agents) Number of unique custom data types 250 per account per day (applies to custom events because that's source of new data types) APM limits Agent instances: 50K per account Agent instances per app: 10K APM apps/services: 10K per second Browser: number of page views 1M per minute per app Distributed tracing: Max age of span timestamp values 20 minutes. Timestamp must be within 20 minutes of current time at ingest or within 20 minutes from the time the last span with the same trace.id was received by New Relic. Distributed tracing: Max spans per minute per account Dependent on agreement. Max limit: 2M. Distributed tracing: Max spans per trace 50K Distributed tracing: Max attributes per span 200 Rate of metric timeslice data (used by APM, browser, mobile) Ingest: 2 million per minute Rate of names: 4 million per minute per account Number per monitored app: 300K Mobile monitoring: number of crashes reported 10K per hour Infrastructure agents, integrations Number of infrastructure agents and/or integrations: 5K per account Gross number of new monitored containers: 5K per hour per account Query limits NRDB records * inspected: 100 billion per account per hour Rate of queries: 20 per account per second See other query limits * NRDB records refers to database records for our core data types, which includes events, metrics (dimensional), logs, and distributed tracing (span) data, all stored in the New Relic database (NRDB). This does not include metric timeslice data. Data ingest API limits Our ingest APIs have additional limits that may override the more general account-level limits. Note that these limits also apply to our tools that use these APIs (like our Telemetry SDKs or our open source telemetry integrations). Metric API (dimensional metrics) Event API Log API Trace API Finding other agent and integration limits To find limits for our other agents and integrations, which will override more general account-level limits, see the docs for those tools: you can search our solutions here. Some default reporting limits are located in these tools' configuration docs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 333.76776,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Know your <em>data</em> limits",
        "sections": "<em>Data</em> <em>ingest</em> API limits",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": ". limitValue The limit reached. System limits UI The system Limits page (from the account dropdown, click <em>Manage</em> your <em>data</em> and click Limits on the left) displays when your account has encountered a rate limit in the specified time period. The page displays a default period of 24 hours; you can set"
      },
      "id": "60446a7c64441f48d7378f2b"
    },
    {
      "sections": [
        "Manage data coming into New Relic",
        "Important",
        "Data ingestion sources",
        "Break down data to see what's contributing to your ingest",
        "How we break your ingest data down",
        "Set alerts for data use",
        "Adjust your data ingest"
      ],
      "title": "Manage data coming into New Relic",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Manage data"
      ],
      "external_id": "f1c46558041c874a2076f781fa975a21105f60e4",
      "image": "https://docs.newrelic.com/static/82d3c36157005ac0efe40cd6e10fe06b/b23ad/data-facet.png",
      "url": "https://docs.newrelic.com/docs/data-apis/manage-data/manage-data-coming-new-relic/",
      "published_at": "2021-10-24T19:37:31Z",
      "updated_at": "2021-10-23T17:30:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you connect your data to New Relic, we process what we receive and apply data dropping and transformation rules. Then we count the bytes needed to represent your data in a standard format, like JSON. If you're on our New Relic One pricing plan, you're charged by the number of bytes written to our database, above and beyond the standard amount that’s free. Important This doc is for accounts on our New Relic One pricing plan. If you're on our original product-based pricing plan, see Original data retention. Not sure which you're on? See Overview of pricing and user model. The Data ingestion page shows your ingest rates for a period you specify on the top-right of the Data management hub. Since 30 days ago is the default setting, but you can also set a custom date span. The page shows your daily average GBs, and the total for the range you set. You can toggle between an overall ingest view and an account view to identify which of your accounts are sending the most data. The page also provides the current month-to-date, and the projected end-of-month total ingest rates. With this information, you can proactively drop data or turn off agents in order to manage ingest and, therefore, costs. If you want to take a look at how we query the data, click the ellipsis icon (just above the chart) to slide out the chart query and open it in our query builder. And If you want to drill down further into your data usage, check out the sample queries in the usage docs. From the Login drop-down, select Manage your data, and then select Data ingestion. This is the Data ingestion page with data source and account views. Data ingestion sources The Data ingestion page describes which of your data sources provide the most data on average and during specific data ranges. The sources are described here. Billable data sources Description Timeslices (1-minute) and Metric:Raw Metrics are timeslices + MetricRaw Metric group: MetricsBytes Metric timeslice data averages to one-hour periods after eight days. After 90 days, the permanent metric data continues to be stored in one-hour periods. We currently store the raw metric data for 30 days. You are only billed for the initial ingest volume. You are not billed for subsequent rollups. APM (transactions and errors) APM events Metric group: ApmEventsBytes InfraSamples:Raw Includes multiple Infrastructure events Infrastructure host data Metric group:InfraHostBytes Information related to your servers and virtual machines coming from infrastructure agents, including storage and network data Infrastructure process data stored in ProcessSample. Metric group: InfraProcessBytes Data are metrics related to each process running on the hosts running the Infrastructure agent. This feature is turned off by default. Infrastructure integrations Metric group: InfraIntegrationBytes Performance data related to applications and services, typically managed by the customer, including data related to Docker containers, Windows services, Nagios checks, and cloud integrations such as managed services in AWS, Azure, and GCP. Logging Includes logs and any Log_<value> custom data partition created Metric group: LoggingBytes Log records are stored into the Log event type by default. Additional custom data partitions will create new event types, which are always prefixed with Log_ and will be counted as part of the overall set of log data stored. With LogExtendedRecord, log messages longer than 4KB are split into multiple events that, when needed, are stitched together to display the original message; this reduces the size of message data. As of September 2021, log storage as blobs replaces LogExtendedRecord. With blob storage, NRDB can store up to 128,000 bytes for any attribute, not just messages. For more information, see our blobs documentation for logs. Default Custom events Metric group: CustomEventsBytes Mobile error Mobile general Breadcrumb crash event trails Mobile session Mobile exception Mobile crash Mobile events Metric group: MobileEventsBytes Tracing Metric group: TracingBytes TracingBytes includes Span and OpenTelemetry's SpanEvent. You are not charged for DistributedTraceSummary events. Browser:EventLog Browser Browser:JSErrors PcvPerf (PageView timing) Browser events Metric group: BrowserEventsBytes Lambda Serverless Metric group: ServerlessBytes Break down data to see what's contributing to your ingest You can inspect your data ingest to gain more information about your ingest health. This way, you'll know your baselines, and can more easily spot an anomaly like an ingest spike, as well as its source. To break down your ingested data, start from the chart on the Data ingestion page. Think of the data source bands as the Y axis, and the dates as the X axis. Click on the band you want to inspect at the spot in the X axis that corresponds with the date you want to investigate. This image shows the Metrics band for June 15 right before it's clicked. A modal opens with the account, data source, and facet selected. You can do a handful of things on this page: Change the account, data source, or facet you want to drill down into. Change the date and time to investigate. Review the results of the query in chart form. The chart displays the top 15 results for the facet query. Open the NRQL query in the Query builder where you'll find additional facets that you can use. Learn more about NRQL queries here. How we break your ingest data down Some of the content in the UI is variable, depending on your account. This information is intended to help you understand how we're working with your ingest data. The chart on the Data ingestion page shows data usage for a little longer time frame than that covered by your retention settings for each data ingest source. If you choose a date outside of your designated retention period for an ingest source, you'll get the message that there's no chart data available. Select a more recent date to fix this problem. If you inspect a data source for an account that has less than a terrabyte of data, we compute the ingest volume over a 24 hour period; otherwise, we compute it for a 1 hour period. The ingest value provided on the main Data ingestion chart will be slightly different from that reflected during inspection. This is because our facet computation is an estimate. Set alerts for data use Query and alert on usage data describes how to set alerts to get notified if you're nearing data ingest limits you don't want to cross. For example, you might set an alert on logs, which can stack up quickly in an active system. Adjust your data ingest Drop data for lower retention costs and data compliance On ingest, we apply data dropping rules so you won't be charged for data that's not useful. Learn how to set additional data dropping rules yourself. Use NerdGraph to drop entire data types or drop data attributes from data types so they’re not written to NRDB. This enables you to focus on the data you want, reduces retention costs, and avoids writing sensitive data to the database. For dropping log data, see Drop data with drop filter rules. Turn off agents and integrations If you don’t need data from specific agents or integrations that you have installed, you can uninstall/delete those tools. For instructions, see the specific documentation for an agent or integration.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 333.7566,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Manage</em> <em>data</em> coming into New Relic",
        "sections": "<em>Manage</em> <em>data</em> coming into New Relic",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": " view and an account view to identify which of your accounts are sending the most <em>data</em>. The page also provides the current month-to-date, and the projected end-of-month total <em>ingest</em> rates. With this information, you can proactively drop <em>data</em> or turn off agents in order to <em>manage</em> <em>ingest</em>"
      },
      "id": "603e978228ccbc8984eba79e"
    },
    {
      "sections": [
        "Get data into New Relic",
        "New Relic-built agents and integrations",
        "Report custom data"
      ],
      "title": "Get data into New Relic",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Get started"
      ],
      "external_id": "016a25d46dedc5da1455b29d8557ce68a4345756",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/get-started/introduction-new-relic-data-ingest-apis-sdks/",
      "published_at": "2021-10-24T19:36:34Z",
      "updated_at": "2021-10-23T17:32:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are many ways to get data into your New Relic account. Any New Relic user can use any of our data ingest methods to report data to our platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure monitoring, or any of our wide array of integrations, by default you'll receive data from your monitored applications, hosts, services, or other entities. Some options for getting started: Log into one.newrelic.com and click Add more data to get some guidance on setting up New Relic solutions. To browse our solutions, see New Relic integrations. Report custom data If you need to report data that our agents and integrations don't provide, we have tools that will allow you to bring in any type of data you need. To learn more, see Intro to custom data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 301.60678,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get <em>data</em> into New Relic",
        "sections": "Get <em>data</em> into New Relic",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": "There are many ways to get <em>data</em> into your New Relic account. Any New Relic user can use any of our <em>data</em> <em>ingest</em> methods to report <em>data</em> to our platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure"
      },
      "id": "6174474328ccbcdff4c6b77e"
    }
  ],
  "/docs/data-apis/manage-data/nrintegrationerror": [
    {
      "sections": [
        "Troubleshoot Metric API with NRIntegrationError events",
        "Problem",
        "Solution",
        "View error details",
        "Match errors to ingested payloads",
        "Programmatically retrieve NrIntegrationError events",
        "Tip"
      ],
      "title": "Troubleshoot Metric API with NRIntegrationError events",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "50ad21a895fc1f2644bdbfbadf85ecfd298b08d6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/metric-api/troubleshoot-nrintegrationerror-events/",
      "published_at": "2021-10-24T20:16:09Z",
      "updated_at": "2021-10-23T17:26:33Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You sent metric data points to the Metric API, and are not seeing what you expect when querying the data. Use the following checklist to determine the root cause: Make sure you are querying the data correctly. Check the HTTP status codes returned by the API. Issues like authorization failures can be diagnosed with HTTP status codes. If you are sending data from a Prometheus server via New Relic's remote_write endpoint, check your Prometheus server logs for errors or non-2xx HTTP responses from the New Relic endpoint. Query your account for NrIntegrationError events. New Relic's ingestion endpoints are asynchronous, meaning the endpoint verifies the payload after it returns the HTTP response. If any issues occur while verifying your payload, then an NrIntegrationError event will be created in your account. New Relic also uses NrIntegrationError events to notify customers when various rate limits have been reached. Solution View error details For an introduction to using the NrIntegrationError event, see NrIntegrationError. Here's an example NRQL for examining issues with Metric API ingest: SELECT count(*) FROM NrIntegrationError WHERE newRelicFeature = 'Metrics' facet category, message limit 100 since 24 hours ago Copy The category indicates the type of error and the message provides more detailed information about the error. If the category is rateLimit, then you should also examine the rateLimitType field for more information on the type of rate limiting. Category rateLimitType Description and solution BadRequest (not set) There is an issue with the JSON payload. These include JSON syntax errors, attribute names, or values that are too long. Check the message field to determine the exact issue. Then review the JSON payload, and update it to ensure it meets the proper semantic guidelines. RateLimit DatapointsPerMinute You are sending too many datapoints per minute. If you get this error, you can either send data less frequently, or request changes to your metric rate limits by contacting your New Relic account representative, or visiting our Support portal. RateLimit UniqueTimeseriesPerDay You have an attribute with a high number of unique values, like containerId or URI. To resolve this error, review any attributes that may be causing the issue and remove them. If desired, you can use a data dropping rule to remove attributes at ingest time. RateLimit UniquePrometheusTimeseries You have Prometheus servers reporting too many unique timeseries via New Relic's remote_write endpoint. Reduce the number of unique timeseries reported by modifying your Prometheus server configuration to reduce the number of targets being scraped, or by using relabel rules in the remote_write section of your server configuration to drop timeseries or highly unique labels. RateLimit RequestsPerMinute Too many requests per minute are being sent. To resolve this, put more datapoints in each request, and send them less frequently. RateLimit ErrorGroupsPerDay You have exceeded your daily error group limit. Incoming error groups will be dropped for the remainder of the day and will continue as normal after UTC midnight. To resolve this, reduce the amount of unique error messages collected by New Relic. Match errors to ingested payloads When an NrIntegrationError event is created as a result of a syntax issue with the HTTP request payload, then the event contains the attributes apiKeyPrefix and requestId. The apiKeyPrefix matches the first 6 characters of the API key used to send the data. The requestId matches the requestId sent in the HTTP response. To view these fields, run this NRQL query: SELECT message, apiKeyPrefix, requestId FROM NrIntegrationError limit 100 Copy To verify a specific requestId, run this NRQL query: SELECT * FROM NrIntegrationError where requestId ='REQUEST_ID' Copy Programmatically retrieve NrIntegrationError events To programmatically retrieve these errors: Ensure you have an Insights query API key (go to insights.newrelic.com > Manage data > API keys). Create an HTTP request as shown below: Tip If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. curl -H \"Accept: application/json\" -H \"X-Query-Key:YOUR_API_KEY_HERE\" \"https://insights-api.newrelic.com/v1/accounts/YOUR_ACCOUNT_HERE/query?nrql=SELECT%20*%20FROM%20NrIntegrationError%20where%20newRelicFeature='Metrics'\" Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 492.25415,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshoot Metric API with <em>NRIntegrationError</em> <em>events</em>",
        "sections": "Troubleshoot Metric API with <em>NRIntegrationError</em> <em>events</em>",
        "tags": "<em>Ingest</em> and manage <em>data</em>",
        "body": " various rate limits have been reached. Solution View <em>error</em> details For an introduction to using the <em>NrIntegrationError</em> <em>event</em>, see <em>NrIntegrationError</em>. Here&#x27;s an example NRQL for examining issues with Metric API <em>ingest</em>: SELECT count(*) FROM <em>NrIntegrationError</em> WHERE newRelicFeature = &#x27;Metrics&#x27; facet"
      },
      "id": "610f2900196a678a5d38ad82"
    },
    {
      "sections": [
        "Introduction to the Event API",
        "Requirements",
        "Basic workflow",
        "Tip",
        "Get the license key",
        "Format the JSON",
        "JSON format guidelines",
        "JSON example",
        "Limits and restricted characters",
        "Submit the custom event",
        "Linux/bash example",
        "Windows/PowerShell example",
        "Important",
        "Verify or troubleshoot request response",
        "Success response code",
        "Submission errors",
        "Parsing errors",
        "Query and alert with NrIntegrationError",
        "Find your data",
        "Limit on HTTP requests"
      ],
      "title": "Introduction to the Event API",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "eea369c63a48d26123e243ed4e8bff412b334146",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/introduction-event-api/",
      "published_at": "2021-10-24T21:24:29Z",
      "updated_at": "2021-10-23T17:26:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Event API is one way to report custom events to New Relic. The Event API lets you send custom event data to your New Relic account with a POST command. These events are then queryable and chartable using NRQL. Want to try out our Event API? Create a New Relic account for free! No credit card required. Related content: Learn about all options for reporting custom events. For details about how event data is retained, see Event data retention. For how to add attributes to existing events, see Add custom attributes. Check out New Relic University’s tutorial Adding custom events with the Event API (aka the Insights API). Or, go directly to the full online course Custom data. Requirements For Event API limits and restricted attributes, see Limits. Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name insights-collector.newrelic.com or insights-collector.eu01.nr-data.net. Basic workflow The Event API is an asynchronous endpoint. This allows you to send a very large volume of POSTS, reliably, with very low response latency. Tip If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. To send a custom event to a New Relic account: Get a license key for the account you want to report data to. Before creating custom events or attributes, review New Relic's list of reserved terms used by NRQL. Generate JSON for the event by instrumenting your application, querying an API, or some other method. Submit a compressed JSON payload (for example, gzip or deflate) to the HTTPS endpoint using curl in a POST request. Recommendation: Set up NRQL alert conditions to notify you when parsing errors occur. This method will send the events directly into your account, where they will be accessible from any NRQL interface or with the Query API. The Event API limits the size, rate, and characters allowed in custom events. Also, like other events available in NRQL, custom events cannot be updated or deleted after they are created. If you have problems with your custom event, follow the troubleshooting procedures or create a new custom event. Get the license key You'll need a license key. License keys are associated with an account, not a specific user. This means that anyone in the account with access to that key can use it. You can submit multiple event types to the same account with the same license key. However, to help ensure security, we recommend that you use different keys for different applications or data sources. Alternatively, you can use an Insights insert keyfor this API, but we recommend using a license key. Format the JSON The Event API accepts specific formats for attributes included in the payload. Only float or string values are allowed. JSON format guidelines When defining attributes for your custom events, follow these JSON format guidelines. Attributes JSON format guidelines eventType Required: The event's name. Float and string values Float value format: \"label\":value String value format: \"label\":\"value\" Data types The API only accepts key-value pairs, not map/object or array values. Supported data types for this API are strings and numbers (integers or floats). For more information, see Data requirements. Digits in strings For performance-related reasons, we do not cast values submitted to the API. For example, we treat 123 as a number and \"123\" as a string. The database will only store up to 64 bit numbers. Any numbers larger than 64 bits will be truncated. Dates For attributes that contain date information, use an unformatted Unix timestamp in the Insights data formatter. You can define the date attribute either in seconds or in milliseconds, both relative to the Unix epoch. Time Unless otherwise specified, the timestamp for a submitted event is the time it was submitted to New Relic. To specify a different time for the event, use the timestamp attribute. JSON example Here is an example of a typical JSON data set for sending with the API. This call sends two Purchase type events as a JSON array. You can add multiple events in a single HTTP call using a JSON array. [ { \"eventType\":\"Purchase\", \"account\":3, \"amount\":259.54 }, { \"eventType\":\"Purchase\", \"account\":5, \"amount\":12309, \"product\":\"Item\" } ] Copy When generating the JSON, make sure your attributes are properly formatted. Limits and restricted characters The following size and rate limits apply to events sent via the Event API: Max events per API call: 2K Payload total size: 1MB(10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. Number of attributes per event: 255 maximum Length of attribute name: 255 characters Length of attribute value: 4096 maximum character length There are rate limits on the number of HTTP requests per minute sent to the Event API. Some specific attributes have additional restrictions: accountId: This is a reserved attribute name. If it is included, it will be dropped during ingest. entity.guid, entity.name, and entity.type: These attributes are used internally to identify entities. Any values submitted with these keys in the attributes section of a metric data point may cause undefined behavior such as missing entities in the UI or telemetry not associating with the expected entities. For more information please refer to Entity synthesis. appId: Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType: Can be a combination of alphanumeric characters, _ underscores, and : colons. timestamp: Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. Submit the custom event Data submitted to the Event API uses a compressed JSON format in a simple HTTPS POST request. This example uses gzip, but you can also use deflate. Linux/bash example gzip -c example_events.json | curl -X POST -H \"Content-Type: application/json\" -H \"Api-Key: YOUR_LICENSE_KEY\" -H \"Content-Encoding: gzip\" https://insights-collector.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/events --data-binary @- Copy Windows/PowerShell example $accountId = \"YOUR_ACCOUNT_ID\" $insertkey = \"YOUR_LICENSE_KEY\" # Replace with your custom event for the body $body = '[{\"eventType\": \"powershell\", \"account\": 4, \"amount\": 123, \"fileLocation\": \"c:\\\\temp2\", \"zipped\": \"true\" }]' $headers = @{} $headers.Add(\"Api-Key\", \"$insertkey\") $headers.Add(\"Content-Encoding\", \"gzip\") $encoding = [System.Text.Encoding]::UTF8 $enc_data = $encoding.GetBytes($body) $output = [System.IO.MemoryStream]::new() $gzipStream = New-Object System.IO.Compression.GzipStream $output, ([IO.Compression.CompressionMode]::Compress) $gzipStream.Write($enc_data, 0, $enc_data.Length) $gzipStream.Close() $gzipBody = $output.ToArray() Invoke-WebRequest -Headers $headers -Method Post -Body $gzipBody \"https://insights-collector.newrelic.com/v1/accounts/$accountId/events\" Copy Important Always use compression with every payload. This allows you to send more data, and it saves resources during parsing. Before generating your HTTP request, make sure it is properly formatted, including: The Api-Key contains the correct license key. The Content-Type is application/json. The request uses POST only. The API does not accept PUT and GET requests. The API supports HTTP/1.1 persistent connections. This is helpful to manage client-side performance under heavy event loads. Verify or troubleshoot request response The Event API follows a two-step process to process requests: The Event API synchronously acknowledges or rejects the request based on validation of the headers and payload size. The Event API asynchronously parses the payload after a successful HTTP response is provided to the client. This may generate an error due to missing or malformed data. These are classified as submission errors or parsing errors. All successful submissions receive a 200 response, regardless of any data errors that may exist within the payload. The response includes a uuid, which is a unique ID created for each request. The uuid also appears in any error events created for the request. Other potential issues: 10-second timeout: API calls exceeding 10 seconds will time out. Large payloads: Payloads exceeding 100 KB may see increased response times. Recommendation: In addition to checking for a success message, create a NRQL query of your data to verify it's available. Success response code Success message Comments 200 {\"success\":true,\"uuid\":\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"} Copy Submission errors Payloads with submission errors are handled and returned to the sender through an HTTP response code. To troubleshoot payload submission errors, refer to these HTTP response codes. Submission errors Troubleshooting 400 Missing or invalid content length: Unable to process empty request. 403 Missing or invalid key: Invalid license key. Register a valid license key. 408 Request timed out: Request took too long to process. 413 Content too large: Request is too large to process. Refer to the limits and restricted characters to troubleshoot. 415 Invalid content type: Must be application/JSON. The Event API accepts any content type except multi-part/related and assumes it can be parsed to JSON. 429 Too many requests due to rate limiting. 503 Service temporarily unavailable: Retry request Parsing errors Parsing errors occur if: An event is sent within a payload, but it is either missing data or is exceeding maximum limits. New Relic will drop the individual event from the payload, generate an NrIntegrationError event, and process the rest. The JSON payload includes malformed JSON or missing required data. Payloads with parsing errors receive a 200 response to indicate a successful submission. To help resolve parsing errors, a new NrIntegrationError event type is created. All parsing errors are due to NRQL queries. For error messages related to dropped events, New Relic will include the number of events that were dropped as part of the message. To troubleshoot requests with parsing errors, refer to these error messages. Parsing errors Troubleshooting X event(s) rejected because attribute appId was not an integer An appId attribute has a non-integer value, such as a decimal value or string. X event(s) rejected because eventType cannot contain the following characters: [., \\] An eventType attributed included an invalid character, such as a period or backslash. X event(s) rejected because attribute is missing attribute name An attribute name was set to null or an empty string. X event(s) rejected because attribute name exceeded maximum length An attribute name has more than 255 characters. X event(s) rejected because attribute value exceeded maximum length An attribute value was longer than 4096 characters. X event(s) rejected because event exceeded maximum number of attributes An event has more than 255 attributes. X event(s) rejected because missing required attributes eventType The eventType attribute is required for the custom event. Error parsing JSON payload There was an error parsing the request JSON because of formatting problems or corrupted data. Query and alert with NrIntegrationError The NrIntegrationError event allows you to query and set alerts on custom data being sent to your New Relic account. Recommendation: To get alerts for parsing errors, create a NRQL alert condition for NrIntegrationError. Use this example NRQL query: SELECT message FROM NrIntegrationError WHERE newRelicFeature = 'Event API' AND category = 'EventApiException' Copy NrIntegrationError attributes Troubleshooting timestamp The timestamp when the request was received. The timestamp attribute takes a 64-bit integer Unix timestamp within the last 24 hours. You can define timestamps either in seconds or in milliseconds, both relative to the Unix epoch. Do not use a decimal for the timestamp. If a decimal is used, the attribute will default to the timestamp when the custom event was created. newRelicFeature The name of the feature experiencing errors. For all custom event parsing errors, this will be Event API. apiKeyPrefix The first six characters of the license key used for the request that generated an error. requestId The uuid returned by the the API for the request that generated an error. Category The category of the error. For custom events, this is EventApiException. Message Contents of the error message. Name The error's name. For custom events, this is always EventValidationException. eventTypeSample One of the event types that generated the error, when available. Find your data To find data sent via the Event API (and from integrations that use this API), you can query it. For example, to query a custom event using NRQL, you would run: SELECT * FROM YOUR_CUSTOM_EVENT Copy For more on how to query, see Query data. Limit on HTTP requests The Event API has a rate limit of 100,000 HTTP requests (POSTs) per minute, per account. (Note that this is not a limit on the number of events per minute; only on the number of POSTs per minute.) This limit helps ensure that large traffic spikes in accounts across our multi-tenant platform do not negatively affect how the service performs for you. If your API usage exceeds 100k POSTs in a 1-minute window, we will reject subsequent API requests with a 429 response code for the remainder of the 1-minute window. At the end of the 1-minute window, the counter will be reset and allow traffic to resume. This limit is intended to be an upper threshold that you shouldn't hit under normal scenarios. If you have a high number of 429 responses, consider using the API less. If you are expecting a higher-than-normal activity level in the near future and want to prepare for that, contact technical support.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 447.9765,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction <em>to</em> the <em>Event</em> API",
        "sections": "Introduction <em>to</em> the <em>Event</em> API",
        "tags": "<em>Ingest</em> and manage <em>data</em>",
        "body": " <em>event</em>. <em>Error</em> parsing JSON payload There was an <em>error</em> parsing the request JSON because of formatting <em>problems</em> or corrupted <em>data</em>. Query and alert with <em>NrIntegrationError</em> The <em>NrIntegrationError</em> <em>event</em> allows you to query and set alerts on custom <em>data</em> being sent to your New Relic account. Recommendation"
      },
      "id": "609fa5fb64441f9d9fd2a1e2"
    },
    {
      "sections": [
        "Query system limits",
        "Important",
        "What happens when you reach a limit",
        "Tip",
        "Create a dashboard to view your limit status",
        "Resource Consumption Limits as a %",
        "Max % Consumption in an hour",
        "APM Agent API transaction events request per minute",
        "Trace API With limit line",
        "Impact FACET",
        "NrIntegrationError by limit",
        "Multi-Account limits (on time series charts only)",
        "Limit list and NrIntegrationError",
        "Limit metrics",
        "newrelic.resourceConsumption.limitValue",
        "newrelic.resourceConsumption.currentValue",
        "newrelic.resourceConsumption.impact",
        "Metric attributes",
        "Set alerts on resource metrics",
        "Limits faceted by LimitName and scoped by Timewindow",
        "Alert on a single limit",
        "Alert on limit impact faceted by dataType, impact, resource, and reason",
        "Alert on impact of a single dataType"
      ],
      "title": "Query system limits",
      "type": "docs",
      "tags": [
        "Ingest data manage data",
        "Manage data",
        "Resource metrics",
        "system limits"
      ],
      "external_id": "7ac33e47dfcfb91089e020a39097c9d648389f51",
      "image": "https://docs.newrelic.com/static/16cb17d5244a118d794df354f67bab81/c1b63/limits-dashboard.png",
      "url": "https://docs.newrelic.com/docs/data-apis/manage-data/query-limits/",
      "published_at": "2021-10-24T21:26:09Z",
      "updated_at": "2021-10-23T17:31:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic has resource limits in place to protect your experience, our systems, and our other customers. These limits range from the maximum number of characters you can have in a query, to API request rates, to how many events your queries inspect, and more. This page describes the limit metrics and NrIntegrationError events that enable you to view your limits, your current data usage and overall resource consumption as compared to those limits, and the impact of experiencing a limit event. We also provide a handful of queries that, when compiled into a dashboard, can give you consistent insight into your limits status. Important While NrIntegrationError events provide data on many limits types, resource limit metrics currently only cover request rate ingestion and API query rate limits. What happens when you reach a limit Our response to reaching a limit depends on a handful of factors: the type of limit that’s reached, as well as the duration, frequency, and amount at which you exceed the limit. Exceeding a limit doesn’t always mean you experience a limit event, such as dropped data, rejected traffic, or having your data turned off for the rest of the day. We sometimes allow a small buffer before enforcing a limit. That said, any resource consumed above 100% is at risk for limit impact at any time. Many of our rate limits apply proportionally. That means if you’re barely exceeding the limit, we will take less action than if you're exceeding by 200%. Limit metrics are only visible if you're sending data in to a corresponding dataType or limitName API. For example, if you send in data via the Metric API, you’ll see the Metric API resource metrics, but if you don't send any APM data in, you won't see APM resource metrics. Tip Impact metrics will be generated regardless of impact; if there's no impact, you’ll see a 0. An NrIntegrationError event is generated when you experience impact and is a good way to quickly see if you’re experiencing any limit events. See View System Limits for more information. Create a dashboard to view your limit status Using three limit metrics together on a dashboard, you can quickly see detailed visuals of your Ingest Resource Request Per Minute limits, and with NrIntegrationError get a view into more limits. Dashboard displaying limits status using a handful of queries. We used the following queries to create this dashboard. To make a dashboard like this in New Relic One, select Dashboards, and then Create a dashboard. Then, add a new chart for each query you want to regularly monitor. The three limits metrics included in these queries are described in a separate section, below. From left to right, top to bottom: Resource Consumption Limits as a % FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) /latest(newrelic.resourceConsumption.limitValue) * 100 facet limitName where limitTimeInterval = '1 minute' timeseries limit max Copy Max % Consumption in an hour SELECT max(`usage`) FROM (FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) / latest(newrelic.resourceConsumption.limitValue) * 100 as 'usage' facet limitName timeseries ) facet limitName limit max Copy APM Agent API transaction events request per minute FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) where limitName = 'APM Agent API transaction events requests per minute' TIMESERIES Copy Trace API With limit line FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) as 'usage', latest(newrelic.resourceConsumption.limitValue) as 'limit' where limitName = 'Trace API requests per minute' TIMESERIES Copy Impact FACET From Metric select rate(sum(newrelic.resourceConsumption.impact), 1 minute) facet dataType, impact, resource TIMESERIES 1 minute limit max Copy NrIntegrationError by limit FROM NrIntegrationError select count(*) facet limitName TIMESERIES MAX since 1 day ago limit max Copy Multi-Account limits (on time series charts only) If you want to see limits for multiple accounts on one chart: run this query from one of the accounts: FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) / latest(newrelic.resourceConsumption.limitValue) * 100 facet limitName, consumingAccountId where limitTimeInterval = '1 minute' timeseries limit max Copy Click Add another query. Select a different account. Then run this query again: FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) / latest(newrelic.resourceConsumption.limitValue) * 100 facet limitName, consumingAccountId where limitTimeInterval = '1 minute' timeseries limit max Copy Finally, save it. Limit list and NrIntegrationError FROM Metric, NrIntegrationError select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) as 'Per Minute Count',latest(newrelic.resourceConsumption.limitValue) as ' limit Value',(rate(sum(newrelic.resourceConsumption.currentValue), 1 minute)/latest(newrelic.resourceConsumption.limitValue)*100)as 'Percent Used', filter (count(*), where NrIntegrationError.limitValue is not null) as 'limit reached count' facet limitName limit 1000 Copy Limit metrics These metrics, used in the dashboard queries above, can hone in on a single limit or resource. Or, with the help of FACET limitName or resource provide a view across all your limits. newrelic.resourceConsumption.limitValue limitValue allows you to see the setting for a limit by limitName and understand more about what resource is linked to this limit. The following examples use the limit value metric in the query: Example for Metric API requests per minute. FROM Metric select latest(newrelic.resourceConsumption.limitValue) where limitName = 'Metric API requests per minute' Copy To show all limits, add FACET limitName and consider grouping by limitTimeInterval. FROM Metric select latest(newrelic.resourceConsumption.limitValue) WHERE limitTimeInterval = '1 minute' FACET limitName limit max Copy newrelic.resourceConsumption.currentValue currentValue shows you how much of a given resource you’re currently consuming. To get a better glimpse into how our systems are viewing your consumption, use a rate() function with the time period that aligns with the limitTimeInterval. Limit 200. Example for Metric API request per minute: FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue),1 minute) where limitName = 'Metric API requests per minute' Copy To show all limits, add FACET limitName and consider grouping by limitTimeInterval. FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue),1 minute) where limitTimeInterval = '1 minute' FACET limitName limit max Copy newrelic.resourceConsumption.impact impact lets you know for any given resource what impact limit events are having. Zeros mean you are not currently impacted. The most granular we have is dataType. It is possible for multiple instances of limitName to impact a single type, such as Metric RPM and DPM. If we know, we will display limitName. From Metric select rate(sum(newrelic.resourceConsumption.impact), 1 minute) facet dataType, resource, impact, limitName TIMESERIES limit max Copy Metric attributes Attributes on newrelic.resourceConsumption.limitValue and newrelic.resourceConsumption.currentValue: limitName - The Name of the limit for the metric data, i.e RPM Metric API. dataType - What kind of data the metric is tracking, i.e Metric, Log, or APM. Resource - What resource is being consumed, i.e. Requests, or DPM. limitTimeInterval - What time window this resource is evaluated for limiting. consumingAccountId - The New Relic account where the resource is being consumed. Attributes on newrelic.resourceConsumption.impact dataType - The kind of data that is being impacted, i.e Metric, Log, APM. Resource - What resource is being impacted, i.e Request Rate. Impact - A count of what is happening when resource has exceeded set limit, i.e dropped requests. consumingAccountId - The New Relic account where the resource is being consumed. Set alerts on resource metrics While building a dashboard to see all your limits is handy, being able to automate it is even better. You can set alerts on your limit metrics to provide updates on limits changes. Tip Because we currently only have metrics on 1 minute time windows, setting TimeWindow = 1 minute, will cover them all. Eventually, we make more metrics available, you might want to set separate alerts for limits that are enforced by different time windows. You can use the following NRQL queries to create alerts. Learn about creating alerts with NRQL queries here. Limits faceted by LimitName and scoped by Timewindow From Metric select (rate(sum(newrelic.resourceConsumption.currentValue), 1 minute)/latest(newrelic.resourceConsumption.limitValue))*100 facet limitName Copy Alert on a single limit From Metric select (rate(sum(newrelic.resourceConsumption.currentValue), 1 minute)/latest(newrelic.resourceConsumption.limitValue))*100 where limitName = 'my limit' Copy Alert on limit impact faceted by dataType, impact, resource, and reason From Metric select rate(sum(newrelic.resourceConsumption.impact), 1 minute) facet dataType, impact, resource, reason Copy Alert on impact of a single dataType From Metric select rate(sum(newrelic.resourceConsumption.impact), 1 minute) facet dataType, impact, resource, reason WHERE dataType = 'important things' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 428.005,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "APM Agent API transaction <em>events</em> request per minute",
        "tags": "<em>Ingest</em> <em>data</em> manage <em>data</em>",
        "body": " and <em>NrIntegrationError</em> events that enable you to view your limits, your current <em>data</em> usage and overall resource consumption as compared to those limits, and the impact of experiencing a limit <em>event</em>. We also provide a handful of queries that, when compiled into a dashboard, can give you consistent"
      },
      "id": "608abed9196a67a63064a7a6"
    }
  ],
  "/docs/data-apis/manage-data/query-limits": [
    {
      "sections": [
        "Know your data limits",
        "Responses to limit violations",
        "System limits UI",
        "Troubleshooting system limits",
        "Account-level limits",
        "Data ingest API limits",
        "Finding other agent and integration limits"
      ],
      "title": "Know your data limits",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Manage data"
      ],
      "external_id": "7c540d94a8b5e4f024d175ad53cab9fab343187c",
      "image": "https://docs.newrelic.com/static/8ee61e3091f6e044202cff92026afada/8c557/limits-graph.png",
      "url": "https://docs.newrelic.com/docs/data-apis/manage-data/view-system-limits/",
      "published_at": "2021-10-24T21:26:09Z",
      "updated_at": "2021-10-23T17:31:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To ensure our systems are always up and ready to support you, and to keep you from unintended use, we place limits on the amount of data you can send, query, and store. Responses to limit violations Limits are enforced per child account, and across our APIs. You might reach a limit if you start monitoring a new high-traffic application, or have a sudden data spike. When you do reach a limit, New Relic responds according to the type of data and the limit that’s reached. For example: We place a limit on the number of ingested requests per minute (RPM) per data type. When this limit is reached, we stop accepting data and return a 429 status code for the duration of the minute. For queries, we place limits on the number of queries per minute and the number of records inspected (see query limits). When the number of queries per minute limit is reached, New Relic will begin rejecting queries until the number of queries is below the limit. When the records inspected limit is reached, New Relic will reject traffic from the source scanning the largest number of records and attempt to allow traffic from other sources. For metrics, we place a limit on the number of unique timeseries (cardinality) per account and per metric. When this limit is reached, aggregated data is turned off for the rest of the UTC day. For every major limit violation, New Relic creates an NrIntegrationError event for that account, which has these limit-related attributes: Attribute Description category RateLimit or ApiLimit. The RateLimit category is used for limits based on a unit of time such as the number of requests ingested per minute. The ApiLimit is used for constant limits, such as the number of attributes on a record. limitName The name of the limit. message Describes the limit and the impact. limitValue The limit reached. System limits UI The system Limits page (from the account dropdown, click Manage your data and click Limits on the left) displays when your account has encountered a rate limit in the specified time period. The page displays a default period of 24 hours; you can set a custom range from the top-right of the page. Non-limit-related NrIntegrationError events are not displayed here. In addition, this page does not display information about limits you have not hit, or how close you are to reaching a limit. For more on creating queries and alerts for data ingest and billing metrics, see Query billing/usage data. one.newrelic.com > account dropdown > Manage your data > Limits: An example of a chart on the Limits UI page displaying a cardinality violation limit issue. To add more detail, or build a dashboard, click the View NRQL button on the chart to see the NRQL powering this view. The graph displays each unique limit type that was reached during the selected time-period. This can help you find any trends based on time. The Limits page also provides a table where you can find the limit name, the limit event message associated with it, and last occurrence time and date. If you click a limit in the table, you see more about what happened, and when. one.newrelic.com > account dropdown > Manage your data > Limits: An example of a limit events table on the Limits UI page. Troubleshooting system limits To troubleshoot limits when you reach them, click the limit info in the table, and then follow the docs link that's provided. Different limits have different solutions. Account-level limits The following table includes general max limits that apply across all New Relic accounts. Specific New Relic tools, like agents and integrations, have their own limits and configurations, and might be lower than these theoretical maximum limits. Limited condition Limit Rate of NRDB record * ingest 55 million per account per minute Max NRDB records * ingested per API call 1MB (10^6 bytes) Max attribute value size 1KB (10^3 bytes) Max payload size 1MB (10^6 bytes) Max total attributes per data type (including default attributes) 254 (less for some tools; for example, 64 for agents) Number of unique custom data types 250 per account per day (applies to custom events because that's source of new data types) APM limits Agent instances: 50K per account Agent instances per app: 10K APM apps/services: 10K per second Browser: number of page views 1M per minute per app Distributed tracing: Max age of span timestamp values 20 minutes. Timestamp must be within 20 minutes of current time at ingest or within 20 minutes from the time the last span with the same trace.id was received by New Relic. Distributed tracing: Max spans per minute per account Dependent on agreement. Max limit: 2M. Distributed tracing: Max spans per trace 50K Distributed tracing: Max attributes per span 200 Rate of metric timeslice data (used by APM, browser, mobile) Ingest: 2 million per minute Rate of names: 4 million per minute per account Number per monitored app: 300K Mobile monitoring: number of crashes reported 10K per hour Infrastructure agents, integrations Number of infrastructure agents and/or integrations: 5K per account Gross number of new monitored containers: 5K per hour per account Query limits NRDB records * inspected: 100 billion per account per hour Rate of queries: 20 per account per second See other query limits * NRDB records refers to database records for our core data types, which includes events, metrics (dimensional), logs, and distributed tracing (span) data, all stored in the New Relic database (NRDB). This does not include metric timeslice data. Data ingest API limits Our ingest APIs have additional limits that may override the more general account-level limits. Note that these limits also apply to our tools that use these APIs (like our Telemetry SDKs or our open source telemetry integrations). Metric API (dimensional metrics) Event API Log API Trace API Finding other agent and integration limits To find limits for our other agents and integrations, which will override more general account-level limits, see the docs for those tools: you can search our solutions here. Some default reporting limits are located in these tools' configuration docs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.14413,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Know your <em>data</em> <em>limits</em>",
        "sections": "<em>Data</em> <em>ingest</em> API <em>limits</em>",
        "tags": "<em>Ingest</em> and <em>manage</em> <em>data</em>",
        "body": ". <em>limit</em>Value The <em>limit</em> reached. <em>System</em> <em>limits</em> UI The <em>system</em> <em>Limits</em> page (from the account dropdown, click <em>Manage</em> your <em>data</em> and click <em>Limits</em> on the left) displays when your account has encountered a rate <em>limit</em> in the specified time period. The page displays a default period of 24 hours; you can set"
      },
      "id": "60446a7c64441f48d7378f2b"
    },
    {
      "sections": [
        "Manage data coming into New Relic",
        "Important",
        "Data ingestion sources",
        "Break down data to see what's contributing to your ingest",
        "How we break your ingest data down",
        "Set alerts for data use",
        "Adjust your data ingest"
      ],
      "title": "Manage data coming into New Relic",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Manage data"
      ],
      "external_id": "f1c46558041c874a2076f781fa975a21105f60e4",
      "image": "https://docs.newrelic.com/static/82d3c36157005ac0efe40cd6e10fe06b/b23ad/data-facet.png",
      "url": "https://docs.newrelic.com/docs/data-apis/manage-data/manage-data-coming-new-relic/",
      "published_at": "2021-10-24T19:37:31Z",
      "updated_at": "2021-10-23T17:30:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you connect your data to New Relic, we process what we receive and apply data dropping and transformation rules. Then we count the bytes needed to represent your data in a standard format, like JSON. If you're on our New Relic One pricing plan, you're charged by the number of bytes written to our database, above and beyond the standard amount that’s free. Important This doc is for accounts on our New Relic One pricing plan. If you're on our original product-based pricing plan, see Original data retention. Not sure which you're on? See Overview of pricing and user model. The Data ingestion page shows your ingest rates for a period you specify on the top-right of the Data management hub. Since 30 days ago is the default setting, but you can also set a custom date span. The page shows your daily average GBs, and the total for the range you set. You can toggle between an overall ingest view and an account view to identify which of your accounts are sending the most data. The page also provides the current month-to-date, and the projected end-of-month total ingest rates. With this information, you can proactively drop data or turn off agents in order to manage ingest and, therefore, costs. If you want to take a look at how we query the data, click the ellipsis icon (just above the chart) to slide out the chart query and open it in our query builder. And If you want to drill down further into your data usage, check out the sample queries in the usage docs. From the Login drop-down, select Manage your data, and then select Data ingestion. This is the Data ingestion page with data source and account views. Data ingestion sources The Data ingestion page describes which of your data sources provide the most data on average and during specific data ranges. The sources are described here. Billable data sources Description Timeslices (1-minute) and Metric:Raw Metrics are timeslices + MetricRaw Metric group: MetricsBytes Metric timeslice data averages to one-hour periods after eight days. After 90 days, the permanent metric data continues to be stored in one-hour periods. We currently store the raw metric data for 30 days. You are only billed for the initial ingest volume. You are not billed for subsequent rollups. APM (transactions and errors) APM events Metric group: ApmEventsBytes InfraSamples:Raw Includes multiple Infrastructure events Infrastructure host data Metric group:InfraHostBytes Information related to your servers and virtual machines coming from infrastructure agents, including storage and network data Infrastructure process data stored in ProcessSample. Metric group: InfraProcessBytes Data are metrics related to each process running on the hosts running the Infrastructure agent. This feature is turned off by default. Infrastructure integrations Metric group: InfraIntegrationBytes Performance data related to applications and services, typically managed by the customer, including data related to Docker containers, Windows services, Nagios checks, and cloud integrations such as managed services in AWS, Azure, and GCP. Logging Includes logs and any Log_<value> custom data partition created Metric group: LoggingBytes Log records are stored into the Log event type by default. Additional custom data partitions will create new event types, which are always prefixed with Log_ and will be counted as part of the overall set of log data stored. With LogExtendedRecord, log messages longer than 4KB are split into multiple events that, when needed, are stitched together to display the original message; this reduces the size of message data. As of September 2021, log storage as blobs replaces LogExtendedRecord. With blob storage, NRDB can store up to 128,000 bytes for any attribute, not just messages. For more information, see our blobs documentation for logs. Default Custom events Metric group: CustomEventsBytes Mobile error Mobile general Breadcrumb crash event trails Mobile session Mobile exception Mobile crash Mobile events Metric group: MobileEventsBytes Tracing Metric group: TracingBytes TracingBytes includes Span and OpenTelemetry's SpanEvent. You are not charged for DistributedTraceSummary events. Browser:EventLog Browser Browser:JSErrors PcvPerf (PageView timing) Browser events Metric group: BrowserEventsBytes Lambda Serverless Metric group: ServerlessBytes Break down data to see what's contributing to your ingest You can inspect your data ingest to gain more information about your ingest health. This way, you'll know your baselines, and can more easily spot an anomaly like an ingest spike, as well as its source. To break down your ingested data, start from the chart on the Data ingestion page. Think of the data source bands as the Y axis, and the dates as the X axis. Click on the band you want to inspect at the spot in the X axis that corresponds with the date you want to investigate. This image shows the Metrics band for June 15 right before it's clicked. A modal opens with the account, data source, and facet selected. You can do a handful of things on this page: Change the account, data source, or facet you want to drill down into. Change the date and time to investigate. Review the results of the query in chart form. The chart displays the top 15 results for the facet query. Open the NRQL query in the Query builder where you'll find additional facets that you can use. Learn more about NRQL queries here. How we break your ingest data down Some of the content in the UI is variable, depending on your account. This information is intended to help you understand how we're working with your ingest data. The chart on the Data ingestion page shows data usage for a little longer time frame than that covered by your retention settings for each data ingest source. If you choose a date outside of your designated retention period for an ingest source, you'll get the message that there's no chart data available. Select a more recent date to fix this problem. If you inspect a data source for an account that has less than a terrabyte of data, we compute the ingest volume over a 24 hour period; otherwise, we compute it for a 1 hour period. The ingest value provided on the main Data ingestion chart will be slightly different from that reflected during inspection. This is because our facet computation is an estimate. Set alerts for data use Query and alert on usage data describes how to set alerts to get notified if you're nearing data ingest limits you don't want to cross. For example, you might set an alert on logs, which can stack up quickly in an active system. Adjust your data ingest Drop data for lower retention costs and data compliance On ingest, we apply data dropping rules so you won't be charged for data that's not useful. Learn how to set additional data dropping rules yourself. Use NerdGraph to drop entire data types or drop data attributes from data types so they’re not written to NRDB. This enables you to focus on the data you want, reduces retention costs, and avoids writing sensitive data to the database. For dropping log data, see Drop data with drop filter rules. Turn off agents and integrations If you don’t need data from specific agents or integrations that you have installed, you can uninstall/delete those tools. For instructions, see the specific documentation for an agent or integration.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.66353,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Manage</em> <em>data</em> coming into New Relic",
        "sections": "<em>Manage</em> <em>data</em> coming into New Relic",
        "tags": "<em>Ingest</em> and <em>manage</em> <em>data</em>",
        "body": " computation is an estimate. Set alerts for <em>data</em> use Query and alert on usage <em>data</em> describes how to set alerts to get notified if you&#x27;re nearing <em>data</em> <em>ingest</em> <em>limits</em> you don&#x27;t want to cross. For example, you might set an alert on logs, which can stack up quickly in an active <em>system</em>. Adjust your <em>data</em> <em>ingest</em>"
      },
      "id": "603e978228ccbc8984eba79e"
    },
    {
      "sections": [
        "Manage your data",
        "Important",
        "Where to find the Data management hub",
        "Better cost, performance, and compliance",
        "Cost management",
        "Performance management",
        "Ingest and retention strategies"
      ],
      "title": "Manage your data",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Manage data"
      ],
      "external_id": "999fa6106dd47250e9a5d822aa2f92b6ea088c78",
      "image": "https://docs.newrelic.com/static/8a553ce9643c8513be3200af5d924250/c1b63/datamanagement_overview.png",
      "url": "https://docs.newrelic.com/docs/data-apis/manage-data/manage-your-data/",
      "published_at": "2021-10-24T21:25:18Z",
      "updated_at": "2021-10-23T17:30:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "At New Relic, we're super proud of NRDB, the New Relic database where we store your data. It gathers all your telemetry data in one place, gives you a connected view of all your data, and scales as your business grows. We invite you to send all your metrics, events, logs, and traces to NRDB, including those from third-party sources. We also recognize that some data might not be necessary for your business goals. You shouldn’t have to wade through data you don’t need to get to the data you do. And you definitely shouldn’t have to pay for it. That’s where our data management tools come in: they let you decide what data you send to New Relic and how long it should be stored. Data management hub: from the user profile drop down, select Manage your data. Coupled with user management tools, data management helps you get maximum value from your investment in New Relic, all while safeguarding your data. Important Not yet a New Relic customer? Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Where to find the Data management hub To locate the data management UI: From one.newrelic.com select the account dropdown, and select Manage your data. If you're on the New Relic One user model, you can also find the Data management hub by selecting Administration > Manage data. Better cost, performance, and compliance Collecting and storing data in New Relic allows you to analyze, visualize, and alert on all your metrics, events, logs, and traces from across all of your sources. However, it’s important to manage that data for cost, performance, and in some cases, compliance reasons. The data management hub provides the tools you need to understand and control where your data is coming from, and adjust what’s stored and for how long. Important If you're on our original product-based pricing plan, you'll see your data ingest, retention, and limits in the Data management hub. The primary difference is that you're not billed on ingest, as with our New Relic One pricing plan. Not sure which plan you're on? See Overview of pricing and user model. Cost management The cost of data storage continually decreases, but storage is still an expense. The amount of data you process and store is closely related to the value you receive from New Relic, because it’s a key component of how you’re charged. Our ingest process helps you hone your data. For example, data might arrive at our processing front door compressed and of varying quality. Through ingest, that data is uncompressed, decorated with queryable attributes, and evaluated. Elements are dropped or trimmed, all before we write it to NRDB. That way, the data you store is only the data you want most. Performance management While NRDB is a phenomenally scalable database, it’s also a reality that queries across huge datasets might not return results in a timely enough fashion for your needs. You get better performance if you limit the data we store, or convert it into a format that keeps it easily queryable. Drop data to improve performance by reducing the amount of data that’s stored. Ingest and retention strategies Depending on your goals, whether to reduce costs, increase specific retention rates, or pare down your data to what’s most essential, we have a strategy for you. Learn about reducing the amount of data that comes into NRDB in Manage data coming into New Relic. Learn about customizing storage so you only store the data you want, for the period you want in Manage data stored in New Relic. Learn about dropping data in Drop data using NerdGraph. And for dropping log data, see Drop data with drop filter rules.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.66353,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Manage</em> your <em>data</em>",
        "sections": "<em>Manage</em> your <em>data</em>",
        "tags": "<em>Ingest</em> and <em>manage</em> <em>data</em>",
        "body": ", and select <em>Manage</em> your <em>data</em>. If you&#x27;re on the New Relic One user model, you can also find the <em>Data</em> management hub by selecting Administration &gt; <em>Manage</em> <em>data</em>. Better cost, performance, and compliance Collecting and storing <em>data</em> in New Relic allows you to analyze, visualize, and alert on all your <em>metrics</em>"
      },
      "id": "603e96ff28ccbcf8bceba796"
    }
  ],
  "/docs/data-apis/manage-data/view-system-limits": [
    {
      "sections": [
        "Manage data coming into New Relic",
        "Important",
        "Data ingestion sources",
        "Break down data to see what's contributing to your ingest",
        "How we break your ingest data down",
        "Set alerts for data use",
        "Adjust your data ingest"
      ],
      "title": "Manage data coming into New Relic",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Manage data"
      ],
      "external_id": "f1c46558041c874a2076f781fa975a21105f60e4",
      "image": "https://docs.newrelic.com/static/82d3c36157005ac0efe40cd6e10fe06b/b23ad/data-facet.png",
      "url": "https://docs.newrelic.com/docs/data-apis/manage-data/manage-data-coming-new-relic/",
      "published_at": "2021-10-24T19:37:31Z",
      "updated_at": "2021-10-23T17:30:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you connect your data to New Relic, we process what we receive and apply data dropping and transformation rules. Then we count the bytes needed to represent your data in a standard format, like JSON. If you're on our New Relic One pricing plan, you're charged by the number of bytes written to our database, above and beyond the standard amount that’s free. Important This doc is for accounts on our New Relic One pricing plan. If you're on our original product-based pricing plan, see Original data retention. Not sure which you're on? See Overview of pricing and user model. The Data ingestion page shows your ingest rates for a period you specify on the top-right of the Data management hub. Since 30 days ago is the default setting, but you can also set a custom date span. The page shows your daily average GBs, and the total for the range you set. You can toggle between an overall ingest view and an account view to identify which of your accounts are sending the most data. The page also provides the current month-to-date, and the projected end-of-month total ingest rates. With this information, you can proactively drop data or turn off agents in order to manage ingest and, therefore, costs. If you want to take a look at how we query the data, click the ellipsis icon (just above the chart) to slide out the chart query and open it in our query builder. And If you want to drill down further into your data usage, check out the sample queries in the usage docs. From the Login drop-down, select Manage your data, and then select Data ingestion. This is the Data ingestion page with data source and account views. Data ingestion sources The Data ingestion page describes which of your data sources provide the most data on average and during specific data ranges. The sources are described here. Billable data sources Description Timeslices (1-minute) and Metric:Raw Metrics are timeslices + MetricRaw Metric group: MetricsBytes Metric timeslice data averages to one-hour periods after eight days. After 90 days, the permanent metric data continues to be stored in one-hour periods. We currently store the raw metric data for 30 days. You are only billed for the initial ingest volume. You are not billed for subsequent rollups. APM (transactions and errors) APM events Metric group: ApmEventsBytes InfraSamples:Raw Includes multiple Infrastructure events Infrastructure host data Metric group:InfraHostBytes Information related to your servers and virtual machines coming from infrastructure agents, including storage and network data Infrastructure process data stored in ProcessSample. Metric group: InfraProcessBytes Data are metrics related to each process running on the hosts running the Infrastructure agent. This feature is turned off by default. Infrastructure integrations Metric group: InfraIntegrationBytes Performance data related to applications and services, typically managed by the customer, including data related to Docker containers, Windows services, Nagios checks, and cloud integrations such as managed services in AWS, Azure, and GCP. Logging Includes logs and any Log_<value> custom data partition created Metric group: LoggingBytes Log records are stored into the Log event type by default. Additional custom data partitions will create new event types, which are always prefixed with Log_ and will be counted as part of the overall set of log data stored. With LogExtendedRecord, log messages longer than 4KB are split into multiple events that, when needed, are stitched together to display the original message; this reduces the size of message data. As of September 2021, log storage as blobs replaces LogExtendedRecord. With blob storage, NRDB can store up to 128,000 bytes for any attribute, not just messages. For more information, see our blobs documentation for logs. Default Custom events Metric group: CustomEventsBytes Mobile error Mobile general Breadcrumb crash event trails Mobile session Mobile exception Mobile crash Mobile events Metric group: MobileEventsBytes Tracing Metric group: TracingBytes TracingBytes includes Span and OpenTelemetry's SpanEvent. You are not charged for DistributedTraceSummary events. Browser:EventLog Browser Browser:JSErrors PcvPerf (PageView timing) Browser events Metric group: BrowserEventsBytes Lambda Serverless Metric group: ServerlessBytes Break down data to see what's contributing to your ingest You can inspect your data ingest to gain more information about your ingest health. This way, you'll know your baselines, and can more easily spot an anomaly like an ingest spike, as well as its source. To break down your ingested data, start from the chart on the Data ingestion page. Think of the data source bands as the Y axis, and the dates as the X axis. Click on the band you want to inspect at the spot in the X axis that corresponds with the date you want to investigate. This image shows the Metrics band for June 15 right before it's clicked. A modal opens with the account, data source, and facet selected. You can do a handful of things on this page: Change the account, data source, or facet you want to drill down into. Change the date and time to investigate. Review the results of the query in chart form. The chart displays the top 15 results for the facet query. Open the NRQL query in the Query builder where you'll find additional facets that you can use. Learn more about NRQL queries here. How we break your ingest data down Some of the content in the UI is variable, depending on your account. This information is intended to help you understand how we're working with your ingest data. The chart on the Data ingestion page shows data usage for a little longer time frame than that covered by your retention settings for each data ingest source. If you choose a date outside of your designated retention period for an ingest source, you'll get the message that there's no chart data available. Select a more recent date to fix this problem. If you inspect a data source for an account that has less than a terrabyte of data, we compute the ingest volume over a 24 hour period; otherwise, we compute it for a 1 hour period. The ingest value provided on the main Data ingestion chart will be slightly different from that reflected during inspection. This is because our facet computation is an estimate. Set alerts for data use Query and alert on usage data describes how to set alerts to get notified if you're nearing data ingest limits you don't want to cross. For example, you might set an alert on logs, which can stack up quickly in an active system. Adjust your data ingest Drop data for lower retention costs and data compliance On ingest, we apply data dropping rules so you won't be charged for data that's not useful. Learn how to set additional data dropping rules yourself. Use NerdGraph to drop entire data types or drop data attributes from data types so they’re not written to NRDB. This enables you to focus on the data you want, reduces retention costs, and avoids writing sensitive data to the database. For dropping log data, see Drop data with drop filter rules. Turn off agents and integrations If you don’t need data from specific agents or integrations that you have installed, you can uninstall/delete those tools. For instructions, see the specific documentation for an agent or integration.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 333.75644,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Manage</em> <em>data</em> coming into New Relic",
        "sections": "<em>Manage</em> <em>data</em> coming into New Relic",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": " view and an account view to identify which of your accounts are sending the most <em>data</em>. The page also provides the current month-to-date, and the projected end-of-month total <em>ingest</em> rates. With this information, you can proactively drop <em>data</em> or turn off agents in order to <em>manage</em> <em>ingest</em>"
      },
      "id": "603e978228ccbc8984eba79e"
    },
    {
      "sections": [
        "Manage your data",
        "Important",
        "Where to find the Data management hub",
        "Better cost, performance, and compliance",
        "Cost management",
        "Performance management",
        "Ingest and retention strategies"
      ],
      "title": "Manage your data",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Manage data"
      ],
      "external_id": "999fa6106dd47250e9a5d822aa2f92b6ea088c78",
      "image": "https://docs.newrelic.com/static/8a553ce9643c8513be3200af5d924250/c1b63/datamanagement_overview.png",
      "url": "https://docs.newrelic.com/docs/data-apis/manage-data/manage-your-data/",
      "published_at": "2021-10-24T21:25:18Z",
      "updated_at": "2021-10-23T17:30:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "At New Relic, we're super proud of NRDB, the New Relic database where we store your data. It gathers all your telemetry data in one place, gives you a connected view of all your data, and scales as your business grows. We invite you to send all your metrics, events, logs, and traces to NRDB, including those from third-party sources. We also recognize that some data might not be necessary for your business goals. You shouldn’t have to wade through data you don’t need to get to the data you do. And you definitely shouldn’t have to pay for it. That’s where our data management tools come in: they let you decide what data you send to New Relic and how long it should be stored. Data management hub: from the user profile drop down, select Manage your data. Coupled with user management tools, data management helps you get maximum value from your investment in New Relic, all while safeguarding your data. Important Not yet a New Relic customer? Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Where to find the Data management hub To locate the data management UI: From one.newrelic.com select the account dropdown, and select Manage your data. If you're on the New Relic One user model, you can also find the Data management hub by selecting Administration > Manage data. Better cost, performance, and compliance Collecting and storing data in New Relic allows you to analyze, visualize, and alert on all your metrics, events, logs, and traces from across all of your sources. However, it’s important to manage that data for cost, performance, and in some cases, compliance reasons. The data management hub provides the tools you need to understand and control where your data is coming from, and adjust what’s stored and for how long. Important If you're on our original product-based pricing plan, you'll see your data ingest, retention, and limits in the Data management hub. The primary difference is that you're not billed on ingest, as with our New Relic One pricing plan. Not sure which plan you're on? See Overview of pricing and user model. Cost management The cost of data storage continually decreases, but storage is still an expense. The amount of data you process and store is closely related to the value you receive from New Relic, because it’s a key component of how you’re charged. Our ingest process helps you hone your data. For example, data might arrive at our processing front door compressed and of varying quality. Through ingest, that data is uncompressed, decorated with queryable attributes, and evaluated. Elements are dropped or trimmed, all before we write it to NRDB. That way, the data you store is only the data you want most. Performance management While NRDB is a phenomenally scalable database, it’s also a reality that queries across huge datasets might not return results in a timely enough fashion for your needs. You get better performance if you limit the data we store, or convert it into a format that keeps it easily queryable. Drop data to improve performance by reducing the amount of data that’s stored. Ingest and retention strategies Depending on your goals, whether to reduce costs, increase specific retention rates, or pare down your data to what’s most essential, we have a strategy for you. Learn about reducing the amount of data that comes into NRDB in Manage data coming into New Relic. Learn about customizing storage so you only store the data you want, for the period you want in Manage data stored in New Relic. Learn about dropping data in Drop data using NerdGraph. And for dropping log data, see Drop data with drop filter rules.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 333.75644,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Manage</em> your <em>data</em>",
        "sections": "<em>Manage</em> your <em>data</em>",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": " in: they let you decide what <em>data</em> you send to New Relic and how long it should be stored. <em>Data</em> management hub: from the user profile drop down, select <em>Manage</em> your <em>data</em>. Coupled with user management tools, <em>data</em> management helps you get maximum value from your investment in New Relic, all while safeguarding"
      },
      "id": "603e96ff28ccbcf8bceba796"
    },
    {
      "sections": [
        "Get data into New Relic",
        "New Relic-built agents and integrations",
        "Report custom data"
      ],
      "title": "Get data into New Relic",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Get started"
      ],
      "external_id": "016a25d46dedc5da1455b29d8557ce68a4345756",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/get-started/introduction-new-relic-data-ingest-apis-sdks/",
      "published_at": "2021-10-24T19:36:34Z",
      "updated_at": "2021-10-23T17:32:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are many ways to get data into your New Relic account. Any New Relic user can use any of our data ingest methods to report data to our platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure monitoring, or any of our wide array of integrations, by default you'll receive data from your monitored applications, hosts, services, or other entities. Some options for getting started: Log into one.newrelic.com and click Add more data to get some guidance on setting up New Relic solutions. To browse our solutions, see New Relic integrations. Report custom data If you need to report data that our agents and integrations don't provide, we have tools that will allow you to bring in any type of data you need. To learn more, see Intro to custom data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 301.60663,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get <em>data</em> into New Relic",
        "sections": "Get <em>data</em> into New Relic",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": "There are many ways to get <em>data</em> into your New Relic account. Any New Relic user can use any of our <em>data</em> <em>ingest</em> methods to report <em>data</em> to our platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure"
      },
      "id": "6174474328ccbcdff4c6b77e"
    }
  ],
  "/docs/data-apis/understand-data/event-data/customized-security-settings-insights": [
    {
      "sections": [
        "Default events reported by New Relic products"
      ],
      "title": "Default events reported by New Relic products",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Default events"
      ],
      "external_id": "598dfde069ba5a8bbbd5834c44b9740d6b338cdc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/understand-data/event-data/default-events-reported-new-relic-products/",
      "published_at": "2021-10-24T20:16:50Z",
      "updated_at": "2021-10-23T17:29:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic products report different types of data. One type of data reported is event data. Events are displayed in UI charts and tables, and also made available for querying. To understand the types of data available, see Data available via NRQL. Learn more about the events reported by New Relic products: APM default events Browser default events Infrastructure default events Mobile default events Synthetics default events NrAuditEvent events for understanding changes to your account",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 393.36517,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Default</em> <em>events</em> reported by New Relic products",
        "sections": "<em>Default</em> <em>events</em> reported by New Relic products",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": "New Relic products report different types of <em>data</em>. One type of <em>data</em> reported is <em>event</em> <em>data</em>. <em>Events</em> are displayed in UI charts and tables, and also made available for querying. To understand the types of <em>data</em> available, see <em>Data</em> available via NRQL. Learn more about the <em>events</em> reported by New Relic"
      },
      "id": "609f8faf64441f8af9d2a1f0"
    },
    {
      "sections": [
        "Events reported by synthetic monitoring"
      ],
      "title": "Events reported by synthetic monitoring",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Default events"
      ],
      "external_id": "908d6d1bc27321c7d0c330318504e4681c25a400",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/understand-data/event-data/events-reported-synthetic-monitoring/",
      "published_at": "2021-10-24T20:20:00Z",
      "updated_at": "2021-10-23T17:25:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitoring in New Relic reports event data that is displayed in some UI displays and is also available for querying and charting. Select an event name in the following table to see its attributes. Event Description SyntheticCheck SyntheticCheck returns metrics from one run of a specific monitor. These metrics include duration information for the monitor, location of the monitor check, size of the request and response headers, the type of monitor, and a timestamp. Each time a synthetic monitor runs a check, details about the check are captured in theSyntheticCheck event type. SyntheticCheck events contain details specific to the check to provide visibility such as the status, type of monitor, and size of request and response headers. SyntheticRequest SyntheticRequest returns results from individual HTTP requests made during a check. The data gathered include job information, location, type of content for request, duration information, request size, and page load information. With each simple or scripted monitor check, we capture each individual HTTP request made during the check. The HTTP details are captured at a more granular level than the SyntheticCheck event type. SyntheticPrivateLocationStatus Every monitor check running on a private location triggers capacity details for that private location. These details are captured in a SyntheticPrivateLocationStatus event. This provides visibility into the capacity of a private location and whether additional minions are required to support the workload. SyntheticPrivateMinion If you have private locations, such as those inside your firewall, you can view information regarding those locations with the SyntheticPrivateMinion event. Each private minion running sends health details to SyntheticPrivateMinion every 30 seconds. This allows you to understand the health of the private minion running at the location. Related documentation: Report custom events Extend data retention See example NRQL queries",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 393.3213,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Events</em> reported by synthetic monitoring",
        "sections": "<em>Events</em> reported by synthetic monitoring",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": "Synthetic monitoring in New Relic reports <em>event</em> <em>data</em> that is displayed in some UI displays and is also available for querying and charting. Select an <em>event</em> name in the following table to see its attributes. <em>Event</em> Description SyntheticCheck SyntheticCheck returns metrics from one run of a specific"
      },
      "id": "609f8faf64441f8e99d2a1d5"
    },
    {
      "sections": [
        "Data requirements and limits for custom event data",
        "General requirements",
        "Important",
        "Reserved words",
        "Event type limits"
      ],
      "title": "Data requirements and limits for custom event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "77720ef366038ba648a5fbf3cf34e8e48b38440a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/data-requirements-limits-custom-event-data/",
      "published_at": "2021-10-24T20:14:57Z",
      "updated_at": "2021-10-23T21:58:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. You can report custom events to New Relic in several ways, including: APM agent APIs Event API (There are additional requirements when using the Event API.) Browser monitoring agent APIs (There are additional requirements with the custom PageAction event.) Mobile monitoring SDK General requirements When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Important Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). If the name begins with anything other than an alphabetical character, enclose the name with backticks in your NRQL query. For example: FROM `0_hello` SELECT count(*) Copy Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. Important This is not a complete list. In general, avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Event type limits The current limit for total number of eventType values is 250 per child account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 266.74493,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Data</em> requirements and limits for custom <em>event</em> <em>data</em>",
        "sections": "<em>Data</em> requirements and limits for custom <em>event</em> <em>data</em>",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": " child account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop <em>data</em>. <em>Event</em> types include: <em>Default</em> <em>events</em> from New Relic agents Custom <em>events</em> from New Relic agents Custom <em>events</em> from <em>Insights</em> custom <em>event</em> inserter"
      },
      "id": "609fa5cfe7b9d2bf16c3eb69"
    }
  ],
  "/docs/data-apis/understand-data/event-data/default-events-reported-new-relic-products": [
    {
      "sections": [
        "Security for New Relic-reported events and attributes",
        "Default events and attributes",
        "Adjust the data reported"
      ],
      "title": "Security for New Relic-reported events and attributes ",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Default events"
      ],
      "external_id": "446305a7d17c6dfb44e9e87520a1c08b79f5bcf9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/understand-data/event-data/customized-security-settings-insights/",
      "published_at": "2021-10-24T20:16:50Z",
      "updated_at": "2021-10-23T17:29:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "By default, New Relic products report a variety of data used in our UI charts and that is available for querying. Our products will not transmit sensitive information without being explicitly instrumented to do so. Default events and attributes Our products report a set of default events and attributes. We will never send request parameters or any other attributes that are not in the default set, unless someone has explicitly enabled this via configuration. Adjust the data reported When evaluating security settings for a New Relic product, review the default events and attributes. The default attributes don't contain sensitive data. In general, it's simply the data needed for effective performance monitoring. Our products don't send other data unless you change the default security settings. Depending on your requirements, either or both of these situations may apply: If the default list contains data you're concerned about, you can disable those attributes from being collected. For how to edit that, see the documentation for the product you're using. If you need to send attributes not reported by default, you can enable those attributes to be reported. In that case, do not use high security mode: this will disable the ability to collect custom attributes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 393.365,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Security for New Relic-reported <em>events</em> and attributes ",
        "sections": "<em>Default</em> <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": "By <em>default</em>, New Relic products report a variety of <em>data</em> used in our UI charts and that is available for querying. Our products will not transmit sensitive information without being explicitly instrumented to do so. <em>Default</em> <em>events</em> and attributes Our products report a set of <em>default</em> <em>events</em>"
      },
      "id": "60a8ea67e7b9d25ec7aeabfe"
    },
    {
      "sections": [
        "Events reported by synthetic monitoring"
      ],
      "title": "Events reported by synthetic monitoring",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Default events"
      ],
      "external_id": "908d6d1bc27321c7d0c330318504e4681c25a400",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/understand-data/event-data/events-reported-synthetic-monitoring/",
      "published_at": "2021-10-24T20:20:00Z",
      "updated_at": "2021-10-23T17:25:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitoring in New Relic reports event data that is displayed in some UI displays and is also available for querying and charting. Select an event name in the following table to see its attributes. Event Description SyntheticCheck SyntheticCheck returns metrics from one run of a specific monitor. These metrics include duration information for the monitor, location of the monitor check, size of the request and response headers, the type of monitor, and a timestamp. Each time a synthetic monitor runs a check, details about the check are captured in theSyntheticCheck event type. SyntheticCheck events contain details specific to the check to provide visibility such as the status, type of monitor, and size of request and response headers. SyntheticRequest SyntheticRequest returns results from individual HTTP requests made during a check. The data gathered include job information, location, type of content for request, duration information, request size, and page load information. With each simple or scripted monitor check, we capture each individual HTTP request made during the check. The HTTP details are captured at a more granular level than the SyntheticCheck event type. SyntheticPrivateLocationStatus Every monitor check running on a private location triggers capacity details for that private location. These details are captured in a SyntheticPrivateLocationStatus event. This provides visibility into the capacity of a private location and whether additional minions are required to support the workload. SyntheticPrivateMinion If you have private locations, such as those inside your firewall, you can view information regarding those locations with the SyntheticPrivateMinion event. Each private minion running sends health details to SyntheticPrivateMinion every 30 seconds. This allows you to understand the health of the private minion running at the location. Related documentation: Report custom events Extend data retention See example NRQL queries",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 393.32108,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Events</em> reported by synthetic monitoring",
        "sections": "<em>Events</em> reported by synthetic monitoring",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": "Synthetic monitoring in New Relic reports <em>event</em> <em>data</em> that is displayed in some UI displays and is also available for querying and charting. Select an <em>event</em> name in the following table to see its attributes. <em>Event</em> Description SyntheticCheck SyntheticCheck returns metrics from one run of a specific"
      },
      "id": "609f8faf64441f8e99d2a1d5"
    },
    {
      "sections": [
        "Data requirements and limits for custom event data",
        "General requirements",
        "Important",
        "Reserved words",
        "Event type limits"
      ],
      "title": "Data requirements and limits for custom event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "77720ef366038ba648a5fbf3cf34e8e48b38440a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/data-requirements-limits-custom-event-data/",
      "published_at": "2021-10-24T20:14:57Z",
      "updated_at": "2021-10-23T21:58:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. You can report custom events to New Relic in several ways, including: APM agent APIs Event API (There are additional requirements when using the Event API.) Browser monitoring agent APIs (There are additional requirements with the custom PageAction event.) Mobile monitoring SDK General requirements When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Important Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). If the name begins with anything other than an alphabetical character, enclose the name with backticks in your NRQL query. For example: FROM `0_hello` SELECT count(*) Copy Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. Important This is not a complete list. In general, avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Event type limits The current limit for total number of eventType values is 250 per child account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 266.7448,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Data</em> requirements and limits for custom <em>event</em> <em>data</em>",
        "sections": "<em>Data</em> requirements and limits for custom <em>event</em> <em>data</em>",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": " child account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop <em>data</em>. <em>Event</em> types include: <em>Default</em> <em>events</em> from New Relic agents Custom <em>events</em> from New Relic agents Custom <em>events</em> from <em>Insights</em> custom <em>event</em> inserter"
      },
      "id": "609fa5cfe7b9d2bf16c3eb69"
    }
  ],
  "/docs/data-apis/understand-data/event-data/events-reported-apm": [
    {
      "sections": [
        "Default events reported by New Relic products"
      ],
      "title": "Default events reported by New Relic products",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Default events"
      ],
      "external_id": "598dfde069ba5a8bbbd5834c44b9740d6b338cdc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/understand-data/event-data/default-events-reported-new-relic-products/",
      "published_at": "2021-10-24T20:16:50Z",
      "updated_at": "2021-10-23T17:29:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic products report different types of data. One type of data reported is event data. Events are displayed in UI charts and tables, and also made available for querying. To understand the types of data available, see Data available via NRQL. Learn more about the events reported by New Relic products: APM default events Browser default events Infrastructure default events Mobile default events Synthetics default events NrAuditEvent events for understanding changes to your account",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 539.4053,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Default <em>events</em> <em>reported</em> <em>by</em> New Relic products",
        "sections": "Default <em>events</em> <em>reported</em> <em>by</em> New Relic products",
        "tags": "Default <em>events</em>",
        "body": "New Relic products <em>report</em> different types of data. One type of data <em>reported</em> is <em>event</em> data. <em>Events</em> are displayed in UI charts and tables, and also made available for querying. To understand the types of data available, see Data available via NRQL. Learn more about the <em>events</em> <em>reported</em> by New Relic"
      },
      "id": "609f8faf64441f8af9d2a1f0"
    },
    {
      "sections": [
        "Manage error data",
        "Error data types: events and trace details",
        "Events",
        "Trace details",
        "Caps on error reporting",
        "Charting error rates and counts",
        "Report custom errors",
        "Ignore errors",
        "Reduce noise with expected errors",
        "Disable error traces",
        "Delete error traces",
        "Caution"
      ],
      "title": "Manage error data",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Error analytics"
      ],
      "external_id": "29a2ebdc7b91029a1fada50791b90e9dc548f17e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/error-analytics/manage-error-data/",
      "published_at": "2021-10-25T00:52:13Z",
      "updated_at": "2021-09-08T19:58:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's APM Errors page helps you identify, triage, and fix errors in your services. The Errors page uses data collected by the APM agent to display stack traces, transaction attributes such as HTTP header values, and any other custom attributes, so you can understand the context of the error and fix it. Error data types: events and trace details By default, our APM agents collect two type of error data: Events Trace details Events The error event data type includes default attributes, as well as any custom attributes instrumented in your service. It doesn't include a stack trace. Find your events data in the Errors UI as follows: The Errors column in the Error traces table. The Top 5 errors chart. When you’ve drilled into a grouping of errors, those errors not displaying a stack trace are based on this type of data. You can disable Show only errors with stack trace to show errors that have this type of data collected, but no associated trace details. Events are subject to sampling (see Caps on error reporting and Charting error rates and counts). For more on error event data, see Events reported by APM. Trace details The trace details error data type includes stack traces and attributes, and supplements events with more data. It's expected that more events will be reported than trace details--see Caps on error reporting. Find your trace details data in the Errors UI as follows: The “Stack traces” column of the Error traces table. When you’ve drilled into a grouping of errors, those errors with a stack trace use this type of data: Show only errors with stack trace is enabled by default, to constrain the errors shown to just those that have this type of data collected. This data is governed by specific retention rules for Error details. Caps on error reporting New Relic caps error reporting at: 100 events per minute per agent instance 20 trace details per minute per agent instance These caps prevent error reporting from negatively impacting application performance. Examples: App running across five EC2 instances, one JVM each. New Relic caps error reporting at: 100 events per minute x 5 instances = 500 events per minute 20 trace details per minute x 5 instances = 100 trace details per minute App running on one host with ten instances. New Relic caps error reporting at: 100 events per minute x 10 instances = 1000 events per minute 20 trace details per minute x 10 instances = 200 events per minute Charting error rates and counts The Error rate chart is driven by a query on metric timeslice data, which is an unsampled aggregate data type that is accurate but has very limited dimensionality. This data can't be faceted or filtered as flexibly as error event data. You can reproduce this chart in a dashboard, or explore the metric timeslice data further by clicking the ... menu on the Error rate chart, and then using the View query or Add to dashboard options. To chart faceted error counts using event data, as in the Top 5 errors chart, use an NRQL event query. Click the ... menu on the Top 5 errors chart and choose View query for a starting point in creating your chart. Since event data can be sampled (see Caps on error reporting), you can use the EXTRAPOLATE keyword to get an accurate error count, even if sampling is occurring. Report custom errors You can report errors not collected by default with our agents using our agent APIs. For more, see the documentation on the API. Ignore errors You can prevent certain errors that would normally be reported to New Relic from being collected using our agent APIs or the server-side configuration UI. For more details, see Manage errors in APM. Reduce noise with expected errors Sometimes you want to collect error data, but not have those errors wake you up through alerts. Using the agent API, you can mark such errors as “expected”. They’ll still be visible in the Errors page, but won’t affect your service’s error rate or Apdex metrics. Disable error traces To prevent certain errors from being reported to New Relic, disable them in your agent's configuration file. For most agents, you can ignore certain error codes or disable errors completely. For more information, see your specific agent's configuration documentation: C SDK Go (not applicable; the agent only reports errors when configured to do so) Java .NET Node.js PHP Python Ruby Delete error traces Caution You cannot recover error traces after you delete them. Deleting errors is currently only available in the legacy Errors Classic UI. If you want to... Do this... Delete all error traces for your app If you have permissions to delete all error traces for an app: Go to one.newrelic.com > APM > (select an app) > More views > Errors (classic). Select Delete all errors. Delete all error traces for your account To delete all error traces for your New Relic account, get support at support.newrelic.com. Delete individual error traces To delete individual error traces, use APM's Errors (classic) page. Drill into an error from the table of errors, then click Delete this error. In addition to deleting error traces, you may also want to delete transaction traces or database/slow SQL traces. This will remove potentially sensitive data while retaining your other application data (such as Apdex, deployment information, etc.).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 275.1423,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Error data types: <em>events</em> and trace details",
        "tags": "<em>APM</em>",
        "body": " that have this type of data collected, but no associated trace details. <em>Events</em> are subject to sampling (see Caps on error reporting and Charting error rates and counts). For more on error <em>event</em> data, see <em>Events</em> <em>reported</em> by <em>APM</em>. Trace details The trace details error data type includes stack traces"
      },
      "id": "6044077e28ccbcab752c60d1"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/manage-data/drop-data-using-nerdgraph/",
      "sections": [
        "Drop data using NerdGraph",
        "Tip",
        "Requirements",
        "Create drop data rule",
        "Caution",
        "NRQL restrictions",
        "Example drop rules",
        "Drop two event types",
        "Drop events meeting certain criteria",
        "Drop sensitive attributes while maintaining the rest of the data",
        "Verify your drop rule works",
        "View rules",
        "Delete drop rules",
        "Audit drop rule history",
        "Cautions when dropping data",
        "Learn more"
      ],
      "published_at": "2021-10-24T21:24:28Z",
      "title": "Drop data using NerdGraph",
      "updated_at": "2021-10-23T17:31:36Z",
      "type": "docs",
      "external_id": "4a400ac08bcc55060e9d037de79c012af6b618e9",
      "document_type": "page",
      "popularity": 1,
      "body": "You might find that you ingest data you don't need or want. You can drop some types of data, which enables you: To filter out unimportant low-value data To filter out potentially sensitive data If you choose to drop data, only new data will be affected. Existing data cannot be edited or deleted. Tip If you are sending data to New Relic using Prometheus remote write, you can also drop data by changing the remote_write section of your YAML config file. For more information, see Drop data using Prometheus remote write. Requirements You must have a user role with permissions for dropping data. Currently the following data types can be targeted for data dropping: APM-reported events Browser-reported events Mobile-reported events Synthetics-reported events Custom events (like those generated by the APM agent APIs or the Event API) Log data Trace spans Default infrastructure monitoring events and infrastructure integrations events, with this exception: Downsampled SystemSample, ProcessSample, NetworkSample and StorageSample with time windows longer than 59 minutes can't be dropped. This data doesn't count towards your data ingest. Dimensional metrics, with these caveats: Billing impacts: for New Relic One pricing, dropped data is not billable. For original pricing, dropped data is billable. For metrics generated by the events-to-metrics service: drop rules won't work but these metrics can be stopped or attributes pruned by disabling or re-configuring the events-to-metric rule. Support for additional types are planned for the future. Create drop data rule Caution Use caution when deciding to drop data. The data you drop is not recoverable. Before using this feature, please review caution information below. To drop data, create a NerdGraph-format drop rule that includes: A NRQL string that specifies what data types to drop An action type specifying how to apply the NRQL string You can form and make the call in the NerdGraph explorer. There are two ways to drop data: Drop entire data types or a data subset (with optional filter). This uses the DROP_DATA action type and uses NRQL of the form: SELECT * FROM DATA_TYPE_1, DATA_TYPE_2 (WHERE OPTIONAL_FILTER) Copy For this type of drop rule, you cannot use anything other than * in the SELECT clause. Drop attributes from data types (with optional filter). This uses the DROP_ATTRIBUTES action type and uses NRQL of the form: SELECT dropAttr1, dropAttr2 FROM DATA_TYPE (WHERE OPTIONAL_FILTER) Copy For this type of drop rule, you must pass in a non-empty list of raw attributes names. NRQL restrictions Not all NRQL clauses make sense for generating drop rules. You can provide a WHERE clause to select data with specific attributes. Other features such as TIMESERIES, COMPARE WITH, FACET, and other clauses cannot be used. The two action types have these restrictions: DROP_DATA can use only SELECT *. DROP_ATTRIBUTES requires use of SELECT with \"raw\" attributes (attributes with no aggregator function applied). This also means you cannot use SELECT *. Additionally, there are some attributes that are integral to their data type and cannot be dropped (such as timestamp on event data). If you include them, registration will fail. Example drop rules Here are some example drop rules: Drop two event types Let's say you notice you have some event types being sent to New Relic that are not important to you. Also, stopping the source from sending those event types quickly is unrealistic, requiring changes to agents and/or API instrumentation. Using a drop rule is an easier way to accomplish the same goal. Here is an example NerdGraph call that drops two event types: Event1 and Event2. mutation { nrqlDropRulesCreate(accountId: YOUR_ACCOUNT_ID, rules: [ { action: DROP_DATA nrql: \"SELECT * FROM Event1, Event2\" description: \"Drops all data for Event1 and Event2.\" } ]) { successes { id } failures { submitted { nrql } error { reason description } } } } Copy Drop events meeting certain criteria Let’s say you have a high volume custom event type that arrives from multiple sources. If you don't find all of that data important, you can use a drop rule. Here is an example of a drop rule that filters out events based on specific criteria. mutation { nrqlDropRulesCreate(accountId: YOUR_ACCOUNT_ID, rules: [ { action: DROP_DATA nrql: \"SELECT * FROM MyCustomEvent WHERE appName='LoadGeneratingApp' AND environment='development'\" description: \"Drops all data for MyCustomEvent that comes from the LoadGeneratingApp in the dev environment, because there is too much and we don’t look at it.\" } ]) { successes { id } failures { submitted { nrql } error { reason description } } } } Copy Drop sensitive attributes while maintaining the rest of the data Let's say you noticed an event has attributes that contain Personally Identifiable Information (PII). You are working to update your services to stop sending the data, but until then, you need to cease storing further PII in New Relic. Although you could drop all of the data as it comes in the door with a DROP_DATA rule, the rest of the data still provides value. Therefore, you can register a drop rule to remove only the offending PII from your data: mutation { nrqlDropRulesCreate(accountId: YOUR_ACCOUNT_ID, rules: [ { action: DROP_ATTRIBUTES nrql: \"SELECT userEmail, userName FROM MyCustomEvent description: \"Removes the user name and email fields from MyCustomEvent\" } ]) { successes { id } failures { submitted { nrql } error { reason description } } } } Copy Verify your drop rule works After you create a drop rule, verify that it is working as expected. The rule should take effect quickly after a successful registration, so try running a TIMESERIES version of the query you registered to see that the data drops off. Drop rule type NRQL DROP_DATA Drop rule NRQL: SELECT * FROM MyEvent WHERE foo = bar Copy Validation NRQL: SELECT count(*) FROM MyEvent WHERE foo = bar TIMESERIES Copy This should drop to 0. To verify that it did not affect any thing else, invert the WHERE clause. DROP_ATTRIBUTES Drop rule NRQL: SELECT dropAttr1, dropAttr2 FROM MyEvent WHERE foo = bar Copy Validation NRQL: SELECT count(dropAttr1), count(dropAttr2) FROM MyEvent WHERE foo = bar TIMESERIES Copy Both lines should drop to 0. To verify that it did not affect events that contained these attributes and still should, invert the WHERE clause. View rules Here is an example NerdGraph call that returns the drop rules set on an account: { actor { account(id: YOUR_ACCOUNT_ID) { nrqlDropRules { list { rules { id nrql accountId action createdBy createdAt description } error { reason description } } } } } } Copy Delete drop rules Here is an example NerdGraph call deleting two specific drop rules: mutation { nrqlDropRulesDelete(accountId: YOUR_ACCOUNT_ID, ruleIds: [\"48\", \"98\"]) { successes { id nrql accountId action description } failures { error { reason description } submitted { ruleId accountId } } } } Copy Audit drop rule history To see who created and deleted drop rules, query your account audit logs. The list endpoint also includes the user ID of the person who created the rule. Cautions when dropping data When creating drop rules, you are responsible for ensuring that the rules accurately identify and discard the data that meets the conditions that you have established. You are also responsible for monitoring the rule, as well as the data you disclose to New Relic. New Relic cannot guarantee that this functionality will completely resolve data disclosure concerns you may have. New Relic does not review or monitor how effective the rules you develop are. Creating rules about sensitive data can leak information about what kinds of data you maintain, including the format of your data or systems (for example, through referencing email addresses or specific credit card numbers). Rules you create, including all information in those rules, can be viewed and edited by any user with the relevant role-based access control permissions. Only new data will be dropped. Existing data cannot be edited or deleted. Learn more Recommendations for learning more: NerdGraph basics and terminology NRQL basics Browse the Explorers Hub for community discussions about NRQL drop rules.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.54645,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Drop <em>events</em> meeting certain criteria",
        "body": ". Currently the following data types can be targeted for data dropping: <em>APM</em>-<em>reported</em> <em>events</em> Browser-<em>reported</em> <em>events</em> Mobile-<em>reported</em> <em>events</em> Synthetics-<em>reported</em> <em>events</em> Custom <em>events</em> (like those generated by the <em>APM</em> agent APIs or the <em>Event</em> API) Log data Trace spans Default infrastructure monitoring <em>events</em>"
      },
      "id": "617446f828ccbcdc29c6ae13"
    }
  ],
  "/docs/data-apis/understand-data/event-data/events-reported-browser-monitoring": [
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "New Relic One: a programmable platform",
        "Tip"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-10-24T16:39:15Z",
      "updated_at": "2021-07-27T13:37:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic's browser monitoring. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 409.6489,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " a highly detailed analysis of a website, using the PageView <em>events</em> <em>reported</em> from New Relic&#x27;s <em>browser</em> <em>monitoring</em>. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Introduction to browser monitoring",
        "More than Real User Monitoring (RUM)",
        "Examine user perceptions",
        "Improve interactive app performance",
        "Correlate front-end and back-end problems",
        "Get started with browser monitoring"
      ],
      "title": "Introduction to browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "4928b2a5981bd2d6263f04b4b882d65adef22779",
      "image": "https://docs.newrelic.com/static/98ad878ffa7b586b779178656f19ec58/c1b63/browser_intro_0.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/introduction-browser-monitoring/",
      "published_at": "2021-10-24T19:11:37Z",
      "updated_at": "2021-10-24T19:11:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your end-user experience depends on your entire technology stack. You need to quickly understand what's causing a customer complaint or issue. Did the problem come from your infrastructure, your application, or the browsers that ultimately render it? Is it the result of a problematic internet provider, a problem in your own data center with failing CPU or memory, or something else? More than Real User Monitoring (RUM) Many websites contain dynamic content that is loaded after the initial page has finished loading, and complex JavaScript code increases the need for error reporting. Browser monitoring in New Relic One provides a Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. With browser monitoring in New Relic One, you see actionable data about your end users' experience with your app. But browser monitoring in New Relic goes far beyond the initial page load to measure full page life cycle data. For example, our browser UI shows you: Actual performance data, such as by page view popularity and user satisfaction (Apdex) scores Perceived performance data that measures how quickly your async or dynamic visuals and interactive page contents display JavaScript error analytics, stack traces, and line-of-code visibility, to show you the end-user steps leading up to an error itself Session performance with a detailed timeline and heat map of the load and interaction events during a webpage's full life cycle AJAX requests indicating problems with timing, end points, and specific locations in the webpage Hash-based route changes in apps with single-page application (SPA) architectures These tools (and more!) help your teams optimize your end users' page load experience, eliminate bugs, and troubleshoot faster across your full stack. Examine user perceptions Real user data gives insights into actual page performance, but you also need to look into your users' perception of your site's performance. Pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser monitoring agent. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. Additional metrics include: First paint, first contentful paint, and largest contentful paint First input delay First interaction This helps you understand how users experience your site, both from visual and responsiveness standpoints. Improve interactive app performance Our single-page app (SPA) monitoring automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during browser interactions. You can also use our browser agent and SPA API to monitor virtually anything that executes inside the browser. If you are a developer, SPA monitoring can help you: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query and visualize the data to assist with business decisions. Bring better apps to the marketplace more quickly. Correlate front-end and back-end problems With New Relic One, you can instrument any type of data you need, such as metrics, events, logs, and traces. This helps you find actionable data about your end users' experience across the stack. For example: Type of data Comments Locations or domains Limit browser monitoring to focus on specific geographical locations or specific types of end-user activity. You can also monitor or block specific domains. Trends in interactions Use our comparative charting feature for a direct page load time comparison between real user (browser) interactions and trends appearing in Synthetic monitors. Distributed tracing Isolate latency from the web browser through back-end services with distributed tracing. The UI helps you see the connection across across a full transaction, from browser activity, to time spent in network, to back-end activity. Browser types Explore your end users' experience with your app segmented by any types of browsers they use, including: Top browsers by throughput Average page load time by platform type (mobile, desktop, and other) Selected browser type by version (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Get started with browser monitoring Follow these basic steps, and you'll quickly be up and running in New Relic with browser monitoring! Review the compatibility details and basic requirements for browser monitoring. Install the browser agent. Go to [one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. View summary data from your Browser summary page, then drill down into page load timing details and other UI data. Configure your alerts for key performance data, or use our Applied Intelligence solutions to reduce alert noise, correlate incidents, and automatically detect anomalies. Query and visualize your default data (or customize your own), then analyze what that data says about your business. Customize and share your own charts and dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.27322,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>browser</em> <em>monitoring</em>",
        "sections": "Introduction to <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the <em>browser</em> <em>monitoring</em> agent. The PageViewTiming <em>event</em> provides a more real-time delivery mechanism that does"
      },
      "id": "604429a9e7b9d2bde7579a04"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "17c97a462616f2b23ead796b62780a1ffeb3dfac",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Agent version Your browser monitoring agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute browser API call To add a custom attribute to the PageView event via the browser agent, use the setCustomAttribute browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.8517,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Report</em> <em>browser</em> <em>monitoring</em> custom <em>events</em> and attributes",
        "sections": "<em>Report</em> <em>browser</em> <em>monitoring</em> custom <em>events</em> and attributes",
        "tags": "Custom <em>events</em>",
        "body": "You can use <em>browser</em> <em>monitoring</em> in New Relic to add custom <em>events</em> and attributes. Page actions and views Use the <em>browser</em> API&#x27;s addPageAction call to capture <em>events</em>, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an <em>event</em> named PageAction"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    }
  ],
  "/docs/data-apis/understand-data/event-data/events-reported-mobile-monitoring": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/attribute-dictionary/",
      "sections": [
        "New Relic data dictionary",
        "AjaxRequest",
        "AwsLambdaInvocation",
        "AwsLambdaInvocationError",
        "BrowserInteraction",
        "BrowserTiming",
        "ContainerSample",
        "DistributedTraceSummary",
        "InfrastructureEvent",
        "JavaScriptError",
        "Metric",
        "Mobile",
        "MobileCrash",
        "MobileHandledException",
        "MobileRequest",
        "MobileRequestError",
        "MobileSession",
        "NetworkSample",
        "NrAiIncident",
        "NrAuditEvent",
        "NrConsumption",
        "NrDailyUsage",
        "NrIntegrationError",
        "NrMTDConsumption",
        "NrUsage",
        "PageAction",
        "PageView",
        "PageViewTiming",
        "ProcessSample",
        "Span",
        "StorageSample",
        "SyntheticCheck",
        "SyntheticRequest",
        "SyntheticsPrivateLocationStatus",
        "SyntheticsPrivateMinion",
        "SystemSample",
        "Transaction",
        "TransactionError",
        "WorkloadStatus"
      ],
      "published_at": "2021-10-27T01:37:31Z",
      "title": "New Relic data dictionary",
      "updated_at": "2021-10-27T01:37:30Z",
      "type": "docs",
      "external_id": "cbca3a897621bcbb31159067d6d4ec27c5178fe4",
      "document_type": "views_page_content",
      "popularity": 1,
      "body": "AjaxRequest Data source : Browser agent An AjaxRequest event is created automatically when an Ajax request occurs during a BrowserInteraction event. The event attributes track geographic and browser info. Attribute name Definition Data types appId ID The ID of your application, as recorded by New Relic. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequestError PageAction PageView PageViewTiming Span MobileRequest MobileSession asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserInteractionName The name of the interaction. This is either the targetGroupedUrl or the custom name set via the API. AjaxRequest BrowserInteraction BrowserTiming city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException PageAction PageView PageViewTiming MobileSession countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView eventId ID A value that you can link to multiple BrowserInteraction events so you can view the interactions that occurred surrounding a specific event. For example, you can see the browser interactions that occurred prior to a JS error. AjaxRequest BrowserInteraction BrowserTiming groupedPageURL The grouped URL of the view that made the AJAX request. For example: myapp.com/acct/*/dash. AjaxRequest BrowserTiming groupedRequestUrl The grouped URL of the AJAX request. For example: myapp.com/acct/*/ajax. AjaxRequest Span hostname The fully qualified domain name (FQDN) of the request URL. AjaxRequest httpMethod enum The HTTP method of the AJAX request. Example: POST. AjaxRequest httpResponseCode enum The HTTP response code. Example: 200. AjaxRequest jsDuration seconds (s) The total duration, in seconds, spent on JavaScript execution. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. This attribute doesn't exist for initial page load events. AjaxRequest BrowserInteraction BrowserTiming pageUrl The URL of the page that was loaded for the PageView. For example: http://www.newrelic.com. This URL does not include query parameters. AjaxRequest BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError port enum The request port. AjaxRequest Span priority Likelihood this event will be saved. AjaxRequest regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming requestBodySize bytes (B) The payload size of the request body, in bytes. AjaxRequest requestUrl The URL of the AJAX request. For example: myapp.com/acct/1/ajax. AjaxRequest responseBodySize bytes (B) The payload size of the response body, in bytes. AjaxRequest session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span timeSinceBrowserInteractionStart seconds (s) The time in seconds between the start of the BrowserInteraction and the start of the request. AjaxRequest BrowserTiming timeToLastCallbackEnd seconds (s) The duration, in seconds, from the start of the request (timestamp) to the end of the last callback. This is not just an additive function; the callback time can overlap with the wait time. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserInteraction BrowserTiming timeToLoadEventStart seconds (s) The time, in seconds, from the start of the AJAX request to the start of its load event. This value represents the duration of the AJAX request with single page app (SPA) monitoring. For more information, see the Mozilla developer documentation about XMLHttpRequest load events. AjaxRequest timeToSettle seconds (s) The time, in seconds, from the start of the request to when all resulting callbacks (including callbacks of subsequent AJAX requests) are complete. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserTiming timestamp The time (date, hour, minute, second) at which the interaction occurred. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming Span userAgentName The browser’s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browser’s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browser’s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming AwsLambdaInvocation Data source : AWS Lambda This event is reported by New Relic monitoring for AWS Lambda. This event captures overall function timing and associated metadata. A single AwsLambdaInvocation event is generated for each invocation. Attribute name Definition Data types aws.lambda.arn The Amazon Resource Name (ARN) of the instrumented Lambda function. AwsLambdaInvocation AwsLambdaInvocationError aws.lambda.coldStart A Boolean indicating if the AWS Lambda invocation is a cold start. AwsLambdaInvocation AwsLambdaInvocationError aws.lambda.eventSource.arn The Amazon Resource Name (ARN) of the entity that invoked the instrumented Lambda function. AwsLambdaInvocation AwsLambdaInvocationError aws.requestId ID AWS identifier of the invocation. AwsLambdaInvocation AwsLambdaInvocationError databaseCallCount count The number of database calls made by this transaction. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError databaseDuration seconds (s) The database response time in seconds. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError duration seconds (s) The total invocation time for the transaction, in seconds. (Data source: AWS Lambda) AwsLambdaInvocation AwsLambdaInvocationError externalCallCount count The number of external calls made by this transaction. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError externalDuration seconds (s) The total response time of all external (out-of-process) services, in seconds. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError newRelic.ingestPoint Where the data point entered the platform (such as browser.spans, or api.traces). AwsLambdaInvocation AwsLambdaInvocationError Span parent.account ID If a distributed tracing payload is received, this is the account identifier for the transaction's upstream caller. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.app ID If a distributed tracing payload is received, this is the application identifier. APM agents retrieve this value in the connect response under the key primary_application_id. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.transportType When a distributed tracing payload is received, the method of transport for the payload. Example values: Unknown, HTTP, HTTPS, Kafka, JMS, IronMQ, AMQP, Queue, or Other. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.type If a distributed trace payload was received, the parent's data source type. Example values: App, Browser, Mobile. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.accept The types as read from the HTTP Accept request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.contentLength bytes (B) Incoming request size in bytes as read from the Content-Length HTTP request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.contentType Incoming request content-type as read from the HTTP request header Content-Type. Example value: application/octet-stream. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.host The name from the HTTP host request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.referer The incoming request referer as read from the Referer request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.userAgent The contents of the User-Agent HTTP header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.method The HTTP request method used. Example values: POST, GET. AwsLambdaInvocation AwsLambdaInvocationError Span Transaction TransactionError response.headers.contentLength bytes (B) The outgoing response size in bytes as read from the Content-Length response header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError response.headers.contentType For an HTTP response, the data type of the returned response. Example values: text/html, application/json. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError response.status bytes (B) The response code for an HTTP request AwsLambdaInvocation totalTime seconds (s) The sum of all async components' duration, in seconds. An async component is a method or function where there is no instrumented encapsulating method or function. AwsLambdaInvocation Transaction traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocation AwsLambdaInvocationError MobileRequestError Span MobileRequest type The New Relic event type. Example values: Transaction, Span. AwsLambdaInvocation AwsLambdaInvocationError AwsLambdaInvocationError Data source : AWS Lambda This event is reported by New Relic monitoring for AWS Lambda. It's generated when an error occurs during a Lambda function invocation. Attribute name Definition Data types aws.lambda.arn The Amazon Resource Name (ARN) of the instrumented Lambda function. AwsLambdaInvocation AwsLambdaInvocationError aws.lambda.coldStart A Boolean indicating if the AWS Lambda invocation is a cold start. AwsLambdaInvocation AwsLambdaInvocationError aws.lambda.eventSource.arn The Amazon Resource Name (ARN) of the entity that invoked the instrumented Lambda function. AwsLambdaInvocation AwsLambdaInvocationError aws.requestId ID AWS identifier of the invocation. AwsLambdaInvocation AwsLambdaInvocationError databaseCallCount count The number of database calls made by this transaction. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError databaseDuration seconds (s) The database response time in seconds. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError duration seconds (s) The total invocation time for the transaction, in seconds. (Data source: AWS Lambda) AwsLambdaInvocation AwsLambdaInvocationError error.class The class name or type for the error. This will be server and platform specific. AwsLambdaInvocationError TransactionError error.message The error message for the transaction. This will be server and platform specific. AwsLambdaInvocationError TransactionError externalCallCount count The number of external calls made by this transaction. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError externalDuration seconds (s) The total response time of all external (out-of-process) services, in seconds. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError newRelic.ingestPoint Where the data point entered the platform (such as browser.spans, or api.traces). AwsLambdaInvocation AwsLambdaInvocationError Span parent.account ID If a distributed tracing payload is received, this is the account identifier for the transaction's upstream caller. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.app ID If a distributed tracing payload is received, this is the application identifier. APM agents retrieve this value in the connect response under the key primary_application_id. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.transportType When a distributed tracing payload is received, the method of transport for the payload. Example values: Unknown, HTTP, HTTPS, Kafka, JMS, IronMQ, AMQP, Queue, or Other. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.type If a distributed trace payload was received, the parent's data source type. Example values: App, Browser, Mobile. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.accept The types as read from the HTTP Accept request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.contentLength bytes (B) Incoming request size in bytes as read from the Content-Length HTTP request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.contentType Incoming request content-type as read from the HTTP request header Content-Type. Example value: application/octet-stream. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.host The name from the HTTP host request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.referer The incoming request referer as read from the Referer request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.userAgent The contents of the User-Agent HTTP header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.method The HTTP request method used. Example values: POST, GET. AwsLambdaInvocation AwsLambdaInvocationError Span Transaction TransactionError response.headers.contentLength bytes (B) The outgoing response size in bytes as read from the Content-Length response header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError response.headers.contentType For an HTTP response, the data type of the returned response. Example values: text/html, application/json. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError stackTrace The error stack trace. The format will be different depending on the agent language. AwsLambdaInvocationError traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocation AwsLambdaInvocationError MobileRequestError Span MobileRequest transactionName Name of the transaction in which the error occurred. Example value: Controller/customers/show. Value may be 'Unknown' if an error occurs outside of a transaction. AwsLambdaInvocationError TransactionError type The New Relic event type. Example values: Transaction, Span. AwsLambdaInvocation AwsLambdaInvocationError BrowserInteraction Data source : Browser agent A BrowserInteraction represents a unit of work in a browser session, triggered by a user interacting with the webpage. It captures information about the session, AJAX calls and custom JavaScript timing that occurred as a result of the interaction. Initial load and route changes are captured as special types of browser interactions, and are used for SPA monitoring. Attribute name Definition Data types actionText The text of the HTML element that was clicked when a browser interaction started. BrowserInteraction ajaxCount count A count of all XHRs included in the timing of a SPA interaction. BrowserInteraction appId ID The ID of your application, as recorded by New Relic. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequestError PageAction PageView PageViewTiming Span MobileRequest MobileSession asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming backendTransactionName The name of the backend transaction that served the initial page load. BrowserInteraction browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserInteractionName The name of the interaction. This is either the targetGroupedUrl or the custom name set via the API. AjaxRequest BrowserInteraction BrowserTiming category The type of interaction; either initial page load, route change, or custom. BrowserInteraction city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException PageAction PageView PageViewTiming MobileSession countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView domain The domain portion of the request URL. BrowserInteraction JavaScriptError PageView PageViewTiming duration seconds (s) The total time elapsed of the interaction event BrowserInteraction eventId ID A value that you can link to multiple BrowserInteraction events so you can view the interactions that occurred surrounding a specific event. For example, you can see the browser interactions that occurred prior to a JS error. AjaxRequest BrowserInteraction BrowserTiming firstContentfulPaint firstContentfulPaint is the point when the browser renders the first bit of content from the DOM, which may be text, an image, SVG, or a <canvas> element. Google's User-centric Performance Metrics contains detailed information about its Paint Timing API and firstContentfulPaint. See Compatibility and requirements for New Relic Browser for additional information about firstContentfulPaint browser compatibility. BrowserInteraction PageView firstPaint firstPaint marks the point when the browser renders anything that is visually different from what was on the screen prior to navigation. This includes non-default background paint and the enclosing box of an iframe. Google's User-centric Performance Metrics contains detailed information about its Paint Timing API and firstPaint. See Compatibility and requirements for New Relic Browser for additional information about firstPaint browser compatibility. BrowserInteraction PageView jsDuration seconds (s) The total duration, in seconds, spent on JavaScript execution. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. This attribute doesn't exist for initial page load events. AjaxRequest BrowserInteraction BrowserTiming monitorAccountId The Synthetics account from which you are running the monitor. BrowserInteraction JavaScriptError monitorId ID A unique number identifying a particular monitor. BrowserInteraction JavaScriptError SyntheticCheck monitorJobId ID The ID of a single Synthetics monitor run, which began at a specific time and originated from a specific location. BrowserInteraction JavaScriptError parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError previousGroupedUrl The grouped version of the URL in the browser at the start of the interaction. BrowserInteraction previousRouteName The route name of the page at the start of the interaction. This is the last value passed by setCurrentRouteName before the start of the interaction. BrowserInteraction previousURL The ungrouped URL in the browser at the start of the interaction. BrowserInteraction regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span targetGroupedUrl The grouped version of the URL in the browser at the end of the interaction. BrowserInteraction targetRouteName The route name for the page at the end of the interaction. The last value passed by setCurrentRouteName before the end of the interaction. BrowserInteraction targetUrl The ungrouped URL in the browser at the end of the interaction. BrowserInteraction timeToConnectEnd seconds (s) The time, in seconds, from the start of the interaction to the connectEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToConnectStart seconds (s) The time, in seconds, from the start of the interaction to the connectStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomComplete seconds (s) The time, in seconds, from the start of the interaction to the domComplete, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomContentLoadedEventEnd seconds (s) The time, in seconds, from the start of the interaction to the domContentLoadedEventEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomContentLoadedEventStart seconds (s) The time, in seconds, from the start of the interaction to the domContentLoadedEventStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomInteractive seconds (s) The time, in seconds, from the start of the interaction to the domInteractive, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomLoading seconds (s) The time, in seconds, from the start of the interaction to the domLoading, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomainLookupEnd seconds (s) The time, in seconds, from the start of the interaction to the domainLookupEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomainLookupStart seconds (s) The time, in seconds, from the start of the interaction to the domainLookupStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToFetchStart seconds (s) The time, in seconds, from the start of the interaction to the fetchStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToLastCallbackEnd seconds (s) The duration, in seconds, from the start of the request (timestamp) to the end of the last callback. This is not just an additive function; the callback time can overlap with the wait time. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserInteraction BrowserTiming timeToLoadEventEnd seconds (s) The time, in seconds, from the start of the interaction to the loadEventEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToLoadEventStart seconds (s) The time, in seconds, from the start of the interaction to the loadEventStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information, see our documentation about instrumentation for the Navigation Timing API. BrowserInteraction timeToRedirectEnd seconds (s) The time, in seconds, from the start of the interaction to the redirectEnd, as defined by the Navigation Timing API. This attribute exists only for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToRedirectStart seconds (s) The time, in seconds, from the start of the interaction to the redirectStart, as defined by the Navigation Timing API. This attribute exists only for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToRequestStart seconds (s) The time, in seconds, from the start of the interaction to the requestStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToResponseEnd seconds (s) The time, in seconds, from the start of the interaction to the responseEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToResponseStart seconds (s) The time, in seconds, from the start of the interaction to the responseStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToSecureConnectionStart seconds (s) The time, in seconds, from the start of the interaction to the secureConnectionStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToUnloadEventEnd seconds (s) The time, in seconds, from the start of the interaction to the unloadEventEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToUnloadEventStart seconds (s) The time, in seconds, from the start of the interaction to the unloadEventStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timestamp The time (date, hour, minute, second) at which the interaction occurred. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming Span trigger The cause of the route change or page load. The default values are click, submit, popstate, or initial page load. For a custom event created with the API, the default value for trigger will be api. This value can also be set via the API. BrowserInteraction userAgentName The browser’s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browser’s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browser’s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming BrowserTiming Data source : Browser agent BrowserTiming is a custom event that captures SPA timing data for browser interactions started using the custom createTracer SPA API method. BrowserTiming contains many of the same attributes used by other events, especially AjaxRequest. Attribute name Definition Data types appId ID The ID of your application, as recorded by New Relic. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequestError PageAction PageView PageViewTiming Span MobileRequest MobileSession asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserInteractionName The name of the interaction. This is either the targetGroupedUrl or the custom name set via the API. AjaxRequest BrowserInteraction BrowserTiming browserTimingName The name of the event. This is taken from the name argument of createTracer. BrowserTiming city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException PageAction PageView PageViewTiming MobileSession countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView eventId ID A value that you can link to multiple BrowserInteraction events so you can view the interactions that occurred surrounding a specific event. For example, you can see the browser interactions that occurred prior to a JS error. AjaxRequest BrowserInteraction BrowserTiming groupedPageURL The grouped URL of the view that made the AJAX request. For example: myapp.com/acct/*/dash. AjaxRequest BrowserTiming jsDuration seconds (s) The total duration, in seconds, spent on JavaScript execution. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. This attribute doesn't exist for initial page load events. AjaxRequest BrowserInteraction BrowserTiming pageUrl The URL of the page that was loaded for the PageView. For example: http://www.newrelic.com. This URL does not include query parameters. AjaxRequest BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span timeSinceBrowserInteractionStart seconds (s) The time in seconds between the start of the BrowserInteraction and the start of the request. AjaxRequest BrowserTiming timeToLastCallbackEnd seconds (s) The duration, in seconds, from the start of the request (timestamp) to the end of the last callback. This is not just an additive function; the callback time can overlap with the wait time. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserInteraction BrowserTiming timeToSettle seconds (s) The time, in seconds, from the start of the request to when all resulting callbacks (including callbacks of subsequent AJAX requests) are complete. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserTiming timeToTracedCallbackStart seconds (s) The time in seconds from the start of the custom tracer until the start of the traced callback. This attribute is unique to the BrowserTiming event. BrowserTiming timestamp The time (date, hour, minute, second) at which the interaction occurred. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming Span tracedCallbackDuration seconds (s) The duration in seconds of the traced callback. This attribute is unique to the BrowserTiming event. BrowserTiming userAgentName The browser’s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browser’s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browser’s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming ContainerSample Data source : Infrastructure This event is reported by the New Relic Infrastructure agent. It collects data from all the Docker containers on the host (which may or may not be running). It includes the container's ID, name, image, image name, and metrics about CPU, memory and networking. We take a snapshot of this data every 15 seconds for each container and package it into this event, which is then sent to New Relic. This data appears on the Containers UI page. Attribute name Definition Data types StorageDataAvailableBytes bytes (B) Data space available in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageDataTotalBytes bytes (B) Total Data space in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageDataUsagePercent percentage (%) Percent of Data space used in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageDataUsedBytes bytes (B) Data space used by the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataAvailableBytes bytes (B) Metadata space available in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataTotalBytes bytes (B) Total Metadata space in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataUsagePercent percentage (%) Percent of Metadata space used in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataUsedBytes bytes (B) Metadata space used by the Storage Driver. Only Device Mapper driver is supported. ContainerSample commandLine The command line used in the container. ContainerSample containerId ID The unique Docker container ID. ContainerSample cpuKernelPercent percentage (%) CPU time percentage used in kernel space. ContainerSample cpuLimitCores count Number of cores available for the container. ContainerSample cpuPercent percentage (%) CPU usage percentage used. ContainerSample cpuShares count Number of CPU shares assigned to the container. ContainerSample cpuThrottlePeriods count Total number of periods throttled. ContainerSample cpuThrottleTimeMs milliseconds (ms) Total throttling time in milliseconds. ContainerSample cpuUsedCores percentage (%) CPU usage per core. ContainerSample cpuUsedCoresPercent percentage (%) CPU usage percentage per core. ContainerSample cpuUserPercent percentage (%) CPU time percentage used in user space. ContainerSample criticalViolationCount count The number of times that alert conditions violated critical thresholds, causing critical violations and opening incidents. If this attribute does not exist on the sample, it has zero violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample image ID The Docker image ID for the image the container is based on. ContainerSample imageName The Docker image name for the container. ContainerSample label_KEY Docker labels associated with this container (where KEY represents a custom label's key value). ContainerSample memoryCacheBytes count The amount of memory used by the container that can be associated precisely with a block on a block device. ContainerSample memoryKernelUsageBytes bytes (B) The amount of current kernel memory allocation. ContainerSample memoryResidentSizeBytes bytes (B) The amount of memory that doesn't correspond to anything on disk: stacks, heaps, and anonymous memory maps. ContainerSample memorySizeLimitBytes bytes (B) The total amount of memory the container is allowed to use. ContainerSample memorySoftLimitBytes bytes (B) The soft limit of memory usage equivalent to the memory reservation of the container. ContainerSample memorySwapLimitBytes bytes (B) The total amount of memory the container is using, including swap. ContainerSample memorySwapLimitUsagePercent percentage (%) This metric is calculated as the percentage of memorySwapUsageBytes over memorySwapLimitBytes, if the limit exists. ContainerSample memorySwapOnlyUsageBytes bytes (B) The amount of swap memory the container is using. This memory doesn't include non-swap memory. ContainerSample memorySwapUsageBytes bytes (B) The amount of memory swap the container is using, including swap. ContainerSample memoryUsageBytes bytes (B) This metric doesn't account for swap usage. ContainerSample memoryUsageLimitPercent percentage (%) This metric is calculated as the memoryUsageBytes percentage over memorySizeLimitBytes, if the limit exists. ContainerSample name The Docker container name. ContainerSample networkRxBytes bytes (B) Total number of received bytes. ContainerSample networkRxBytesPerSecond rate Number of received bytes per second. ContainerSample networkRxDropped count Total number of received packets dropped. ContainerSample networkRxDroppedPerSecond rate Number of received packets dropped per second. ContainerSample networkRxError count Total number of received packets with error. ContainerSample networkRxErrorsPerSecond rate Number of received packets with error per second. ContainerSample networkRxPackets count Total number of received packets. ContainerSample networkRxPacketsPerSecond rate Number of received packets with error per second. ContainerSample networkTxBytesPerSecond rate Number of transmitted bytes per second. ContainerSample networkTxDropped count Total number of transmitted packets dropped. ContainerSample networkTxDroppedPerSecond rate Number of transmitted packets dropped per second. ContainerSample networkTxErrors count Total number of transmitted packets with error. ContainerSample networkTxErrorsPerSecond rate Number of transmitted packets with error per second. ContainerSample networkTxPackets count Total number of transmitted packets. ContainerSample networkTxPacketsPerSecond rate Number of transmitted packets per second. ContainerSample networksTxBytes count Total number of bytes transmitted. ContainerSample restartCount count The number of times the container was restarted. ContainerSample state It can be: created, restarting, running, removing, paused, exited, or dead. ContainerSample status Holds the current container state. ContainerSample warningViolationCount count The number of times that alert conditions violated warning thresholds, causing warning violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample DistributedTraceSummary Data source : Distributed Tracing This event contains summary data about a distributed trace and provides an aggregated view of distributed tracing data. DistributedTraceSummary events are generated by New Relic and are triggered by distributed tracing data from agents or the Trace API. Attribute name Definition Data types accountIds A comma delimited list of newrelic accountIds that took part in this trace. DistributedTraceSummary backend.duration.ms milliseconds (ms) The total elapsed time in milliseconds of all backend services in this trace. DistributedTraceSummary backend.timestamp milliseconds (ms) The timestamp of the first span in this trace from a backend entity. In distributed tracing, any events that are not from client-side applications contributed to the backend duration. DistributedTraceSummary duration.ms The duration of the entire distributed trace, including both backend and client-side entities. the earliest span to the latest. DistributedTraceSummary entityCount count The number of unique entities that took part in this trace. DistributedTraceSummary entityGuids A comma delimited list of entity GUIDs for entities that participated in this trace. These GUIDs are assigned by New Relic for the New Relic-monitored entity (host, application, etc.). Each GUID is stored as a Base64 encoded value. DistributedTraceSummary errorCount count The number of events in this distributed trace that were identified as errors. DistributedTraceSummary newRelic.traceFilter.type The name of the trace filter used by the Infinite Tracing trace observer to select this trace. DistributedTraceSummary Span root.entity.accountId The New Relic account ID that the root entity of this trace reports data to. DistributedTraceSummary root.entity.guid The entity GUID associated with the root entity of this trace. DistributedTraceSummary root.entity.name The name of the root entity of this trace. DistributedTraceSummary root.span.duration.ms milliseconds (ms) The elapsed time in milliseconds of the root span of this trace. The root of a distributed trace is the first span, and will have a null value for parent.id. DistributedTraceSummary root.span.id The unique identifier of the root span of this trace. The root of a distributed trace is the first span, and it has a null value for parent.id. DistributedTraceSummary root.span.name The name of the root span of this trace. DistributedTraceSummary root.span.timestamp milliseconds (ms) The timestamp of the root span of this trace. The root of a distributed trace is the first span, and will have a null value for parent.id. DistributedTraceSummary spanCount count The number of events in this distributed trace. Events in a distributed trace can have several event types, including Span, Transaction, and TransactionError. DistributedTraceSummary timestamp milliseconds (ms) The timestamp of the root span in this distributed trace. DistributedTraceSummary trace.id ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. DistributedTraceSummary MobileRequestError Span Transaction TransactionError MobileRequest InfrastructureEvent Data sources : InfrastructureCloudTrail InfrastructureEvent describes changes (deltas) that occur in a system's live state. When an inventory or system state is added, removed, or changed, Infrastructure will produce an InfrastructureEvent that logs that activity. Attribute name Definition Data types category A New Relic category used to organize events in the UI. For example: automation, notification, and service. InfrastructureEvent changeType A simple classification of the type of change made to the entity: added, modified, or removed. InfrastructureEvent changedPath The fully specified name of the item that changed. This is constructed by taking the source and adding one or more additional path elements that uniquely identify the item that changed. InfrastructureEvent deltaId Delta refers to a recorded change in the system. The deltaId is a number used by New Relic to organize incoming inventory change data. InfrastructureEvent eventId The unique ID of the event, generated by New Relic. InfrastructureEvent format The type of infrastructure event. Each format type includes attributes that may be used to render the event in the UI. InfrastructureEvent newStatus The new agent status: disconnected or connected. InfrastructureEvent newValue If a change is made to the entity, this attribute contains the new value of the inventory that was changed. This will have no value if no change has been made. The value will display approximately 4K bytes of data. InfrastructureEvent oldValue If a change is made to the entity, this attribute contains the old value of the inventory that was changed. This will be blank if no change has been made. InfrastructureEvent provider For integrations that use generic event types (like the DatastoreSample event), the provider value specifies the source of the data (the service, or a sub-category of data from that service). Some Insights events are generic and are used by several integrations. For example, the DatastoreSample event is used by several integrations, including the AWS DynamoDB integration and the AWS RDS integration. In these cases, the provider attribute value represents the source of that attribute. This will usually be the service that data comes from or, for integrations that use several provider values, a certain sub-category of data from that service. When a provider value is present for a generic event, that event will have additional integration-specific attributes attached to it. Here’s an example of an Insights NRQL query that returns the attributes present for a DatastoreSample event reported by the AWS RDS integration: SELECT * from DatastoreSample where provider = 'RdsDbCluster' InfrastructureEvent source The fully specified origin of this inventory item. This is typically in the form category/plugin, where plugin is the generic word used for the tool that gathered this data. InfrastructureEvent summary A summary of the change that happened. Uses a human-friendly string, such as Agent disconnected. InfrastructureEvent violationUpdateType The type of change to the violation: For example: open or closed. InfrastructureEvent JavaScriptError Data source : Browser agent As JavaScript errors are triggered, we capture details as events. The JavaScriptError event contains information to help you segment errors to understand how they impact performance. Attribute name Definition Data types appId ID The identification number for the reporting browser agent. JavaScriptError appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequestError PageAction PageView PageViewTiming Span MobileRequest MobileSession asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserStackHash ID An unique identifier generated for a stack trace. The browserStackHash for a stack trace is different across different browsers. An identical stack trace will generate the same identifier. JavaScriptError city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException PageAction PageView PageViewTiming MobileSession countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView domain The domain portion of the request URL. BrowserInteraction JavaScriptError PageView PageViewTiming entityGuid The unique identifier of the monitor referenced in New Relic One. JavaScriptError SyntheticCheck SyntheticRequest errorClass The error type of the JavaScript Error object. Examples: ReferenceError, SyntaxError, and UncaughtException. JavaScriptError errorMessage The error message that was delivered. JavaScriptError firstErrorInSession A value to indicate whether or not this was the first JS error in the session. Example: true. JavaScriptError monitorAccountId The Synthetics account from which you are running the monitor. BrowserInteraction JavaScriptError monitorId ID A unique number identifying a particular monitor. BrowserInteraction JavaScriptError SyntheticCheck monitorJobId ID The ID of a single Synthetics monitor run, which began at a specific time and originated from a specific location. BrowserInteraction JavaScriptError pageUrl The URL of the page that was loaded for the PageView. For example: http://www.newrelic.com. This URL does not include query parameters. AjaxRequest BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming releaseIds ID The releases in which the app was updated. Example: {\\\"jQuery\\\":\\\"v3.1.1\\\",\\\"multiverse\\\":\\\"96e9ac7\\\"}. JavaScriptError requestUri The URI of the requested resource. JavaScriptError session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span stackHash ID A unique identifier generated by the Browser agent for a stack trace. The stackHash for a stack trace is the same across different browsers. An identical stack trace will generate the same identifier. JavaScriptError stackTrace A collection of the active stack frames when the error occurred. JavaScriptError stackTraceGzip A compressed version of the stackTrace attribute. JavaScriptError timestamp The time that the error occurred, in Unix time. JavaScriptError transactionName The full metric name of the transaction in which the error occurred, or Unknown if the error occurs outside of a transaction. JavaScriptError userAgentName The browser’s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browser’s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browser’s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Metric Data source : Metrics Represents a metric data point (e.g., a measurement over a range of time, or a sample at a specific point in time) with multiple attributes attached, which allow for in-depth analysis and querying. This metric data comes from our Metric API, our Telemetry SDKs, and some of our open-source exporters/integrations. Attribute name Definition Data types endTimestamp milliseconds (ms) The end of the time range associated with the metric, in Unix time, in milliseconds. This is calculated by adding the metric interval to the timestamp of the metric (timestamp + interval.ms). Metric interval.ms milliseconds (ms) The length of the time window. Metric metricName Name of the metric. Metric newrelic.source The source of this data. For example: metricAPI. Metric timestamp milliseconds (ms) The start time for the metric, in Unix time. Metric Mobile Data source : Mobile A Mobile event is created when a crash occurs, when an interaction ends or has run for 1 second, or if a session completes after the app is closed, backgrounded, or has run for 10 minutes. Mobile events were once the only event type and were generated for every event, but now there are several specialized event types. Recommendation: Upgrade to the most recent mobile monitoring agent version to take full advantage of the new event types. Attribute name Definition Data types category The type of data, either session or interaction. Mobile MobileSession interactionDuration For interaction category events only. This is the total time for the interaction to render on the device. In addition to render time, this usually includes all external calls associated with the interaction. Currently, this attribute is measured in seconds for Android devices and in milliseconds for iOS devices. Mobile name For interaction category events only. This is the label of the interaction associated with the event. It is by default assigned by New Relic. For example: ApplicationsListFragment or Display iOS_Example.MasterViewController. Mobile reportedTimestampMs For interaction category events only. The UTC based timestamp for when the event was sent to New Relic. This is different from the attribute ‘timestamp’, which is when the event began. Mobile MobileCrash Data source : Mobile The MobileCrash event is created when an app crashes. MobileCrash includes attributes such as crash line number, class, and crash message. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession appToken The mobile application license token. MobileCrash appVersion The version number of the monitored app. For example: 2.2.9. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession architecture The processor architecture of the device. For example: armv7 or arm64. MobileCrash asnOwner The telecom owner of the ASN. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession bundleId ID The unique string used to identify the application. MobileCrash MobileSession carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession crashException The exception associated with the crash, if one is present. For example: java.lang.NullPointerException. MobileCrash crashFingerprint ID The New Relic-generated fingerprint used to uniquely identify the crash and other crashes identical to this one. MobileCrash crashLocationFile The file in which the crash occurred. MobileCrash crashMessage The message associated with the crash, if one is present. MobileCrash deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession deviceName The device's name. MobileCrash deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession diskAvailable bytes (B) Space available on the device, in bytes. MobileCrash interactionHistory The client interactions with the application that led to the crash. MobileCrash isFirstOccurrence A boolean value indicating whether or not this was the first occurrence of the crash. MobileCrash lastInteraction The last interaction before a crash or harvest event, if one is present. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession modelNumber The model of the device. This is the same as the session-level deviceModel attribute. MobileCrash networkStatus The type of network that the device was on at the time of crash, such as wifi or LTE. MobileCrash newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession occurrenceId ID The ID for this instance of the crash. MobileCrash orientation The orientation of the device, such as landscape or portrait. MobileCrash osBuild For Android only. The specific build of the Android OS. MobileHandledException MobileCrash osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession parentProcess The parent process that launched the crashing process. MobileCrash parentProcessId ID The parent identification number (PID) of the parent process. MobileCrash platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession processId ID The PID of the previously running process on the device. MobileCrash processName The name of the previously running process. MobileCrash processPath The path to the binary. MobileCrash reportedTimestampMs The UTC timestamp for when the event was received by New Relic. (This is different from timestamp, which is when the MobileSession event began that crashed.) MobileCrash runTime For Android only. The Android Runtime version where the exception/crash was generated. MobileHandledException MobileCrash sessionCrashed A boolean value indicating whether or not that session crashed. MobileCrash MobileSession sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession symbolicated A boolean value indicating whether or not the crash was properly symbolicated. MobileCrash timeSinceLastInteraction milliseconds (ms) The time, in milliseconds, since the interaction before a crash event. MobileCrash userImageUuids ID The array of build UUIDs for applications and libraries. MobileCrash uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession MobileHandledException Data source : Mobile MobileHandledException is sent when an exception is caught and is used for non-fatal exceptions reported to New Relic using the recordHandledException API for Android or iOS. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequestError PageAction PageView PageViewTiming Span MobileRequest MobileSession asnOwner The telecom owner of the ASN. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException PageAction PageView PageViewTiming MobileSession countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequestError MobileRequest MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequestError MobileRequest MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequestError MobileRequest MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession exceptionAppBuildUuid ID The build uuid of the application binary in which the exception was caught. MobileHandledException exceptionCause The unsymbolicated, platform-specific cause of the exception. MobileHandledException exceptionLocation New Relic defined location of an exception. Contains a combination of exception file name, class, line number, and method. MobileHandledException exceptionLocationClass The class that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionLocationFile The class that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionLocationLibraryOffset For XCFramework agent only. The library offset of the library that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionLocationLine Comes from the exception: The line number where the exception was generated. Only present if symbolication succeeded. MobileHandledException exceptionLocationMethod The method that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionMessage The unsymbolicated message from the exception. It can be user-generated or a generic system message. For Android, this is the Throwable message. MobileHandledException exceptionName The unsymbolicated exception type. MobileHandledException fingerprint ID The New Relic-generated identifier used to group like exceptions. MobileHandledException handledExceptionUuid ID The unique ID of the exception event. MobileHandledException lastInteraction The last interaction before a crash or harvest event, if one is present. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession libraryName For XCFramework agent only. The library name where the exception was generated. MobileHandledException libraryStartAddr For XCFramework agent only. The library start address where the exception was generated. MobileHandledException memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession occurrenceTimestamp Agent-reported epoch timestamp of the handled exception. MobileHandledException osBuild For Android only. The specific build of the Android OS. MobileHandledException MobileCrash osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequestError MobileRequest MobileSession runTime For Android only. The Android Runtime version where the exception/crash was generated. MobileHandledException MobileCrash sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession timestamp Epoch timestamp of the handled exception. This exception timestamp represents the time New Relic created the event, if it's older than two days or some other unexpected time. MobileHandledException uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession MobileRequest Data source : Mobile A MobileRequest event is created when an HTTP request successfully completes, resulting in a response code below 400. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequestError PageAction PageView PageViewTiming Span MobileRequest MobileSession asnOwner The telecom owner of the ASN. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession bytesReceived bytes (B) Optional: If the application received a response from the requestUrl, the size of that response in bytes. MobileRequestError MobileRequest bytesSent bytes (B) Optional: If the application sent a request to the requestUrl, the size of that request in bytes. MobileRequestError MobileRequest carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession connectionType The type of connection which the device was using, such as 2G or 3G. MobileRequestError MobileRequest countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequestError MobileRequest MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequestError MobileRequest MobileSession deviceGroup The category of the device, such as iPhone or Tablet. MobileRequestError MobileRequest MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession deviceSize The display size of the device: Small, normal, large, xlarge. MobileRequestError MobileRequest deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequestError MobileRequest MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession duration seconds (s) Optional: The time to complete the request, measured in fractional seconds. MobileRequestError MobileRequest guid ID The unique identifier for the segment. This is equivalent to spanID in OpenTracing semantics. MobileRequestError Span MobileRequest lastInteraction The last interaction before a crash or harvest event, if one is present. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequestError MobileRequest MobileSession requestDomain The domain that the application attempted to access when the event occurred. MobileRequestError MobileRequest requestFingerprint ID The New Relic-generated identifier used to group like request events. MobileRequest requestMethod The REST method (GET, PUT, POST, etc.) that the application attempted when the event occurred. MobileRequestError MobileRequest requestPath The path that the application attempted to access when the event occurred. MobileRequestError MobileRequest requestUrl The URL that the application attempted to access when the event occurred. MobileRequestError MobileRequest requestUuid ID A unique identifer for the request event. MobileRequestError MobileRequest responseTime seconds (s) The time between the request and the response in fractional seconds. MobileRequestError MobileRequest sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession statusCode Optional: The HTTP status code for the HTTP event. MobileRequestError MobileRequest timestamp The UTC epoch time at which an event began. MobileRequestError MobileRequest MobileSession trace.id ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. DistributedTraceSummary MobileRequestError Span Transaction TransactionError MobileRequest traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocation AwsLambdaInvocationError MobileRequestError Span MobileRequest uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession MobileRequestError Data source : Mobile A MobileRequestError is used for HTTP errors or network failures. HTTP errors are HTTP requests that have a status code greater than 400. A network failure is a HTTP request that results in no response. The event is sent when the HTTP request completes. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequestError PageAction PageView PageViewTiming Span MobileRequest MobileSession asnOwner The telecom owner of the ASN. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession bytesReceived bytes (B) Optional: If the application received a response from the requestUrl, the size of that response in bytes. MobileRequestError MobileRequest bytesSent bytes (B) Optional: If the application sent a request to the requestUrl, the size of that request in bytes. MobileRequestError MobileRequest carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession connectionType The type of connection which the device was using, such as 2G or 3G. MobileRequestError MobileRequest countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequestError MobileRequest MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequestError MobileRequest MobileSession deviceGroup The category of the device, such as iPhone or Tablet. MobileRequestError MobileRequest MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession deviceSize The display size of the device: Small, normal, large, xlarge. MobileRequestError MobileRequest deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequestError MobileRequest MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession duration seconds (s) Optional: The time to complete the request, measured in fractional seconds. MobileRequestError MobileRequest errorType Either HTTPError or NetworkFailure, depending on whether the error is a result of a failed request to a host or a failure on the cellular network. MobileRequestError guid ID The unique identifier for the segment. This is equivalent to spanID in OpenTracing semantics. MobileRequestError Span MobileRequest lastInteraction The last interaction before a crash or harvest event, if one is present. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession networkError The error message associated with the iOS NSURL Error code. See networkErrorCode for more information. MobileRequestError networkErrorCode If the error is a network error, this is the iOS network error code. For Android applications, this is the mapped value. MobileRequestError newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequestError MobileRequest MobileSession requestDomain The domain that the application attempted to access when the event occurred. MobileRequestError MobileRequest requestErrorFingerprint ID The New Relic-generated identifier used to group like request error events. MobileRequestError requestMethod The REST method (GET, PUT, POST, etc.) that the application attempted when the event occurred. MobileRequestError MobileRequest requestPath The path that the application attempted to access when the event occurred. MobileRequestError MobileRequest requestUrl The URL that the application attempted to access when the event occurred. MobileRequestError MobileRequest requestUuid ID A unique identifer for the request event. MobileRequestError MobileRequest responseBody Optional: The response that is sent from the requestDomain for the HTTP error, up to 4096 bytes. MobileRequestError responseTime seconds (s) The time between the request and the response in fractional seconds. MobileRequestError MobileRequest sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession statusCode Optional: The HTTP status code for the HTTP event. MobileRequestError MobileRequest timestamp The UTC epoch time at which an event began. MobileRequestError MobileRequest MobileSession trace.id ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. DistributedTraceSummary MobileRequestError Span Transaction TransactionError MobileRequest traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocation AwsLambdaInvocationError MobileRequestError Span MobileRequest uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession MobileSession Data source : Mobile A MobileSession event is sent when an app is closed, backgrounded, or when 10 minutes of active use has elapsed. This is the source of the general session data used by the other mobile monitoring events. MobileSession captures attributes such as device type, device OS, and geographical information. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequestError PageAction PageView PageViewTiming Span MobileRequest MobileSession asnOwner The telecom owner of the ASN. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession bundleId ID The unique string used to identify the application. MobileCrash MobileSession carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession category The type of data, either session or interaction. Mobile MobileSession city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException PageAction PageView PageViewTiming MobileSession countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequestError MobileRequest MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequestError MobileRequest MobileSession deviceGroup The category of the device, such as iPhone or Tablet. MobileRequestError MobileRequest MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequestError MobileRequest MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession install Indicates true only if the current session is the first session after app install. MobileSession lastInteraction The last interaction before a crash or harvest event, if one is present. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession newRelicAgent The New Relic agent running on the application. For example: the iOSAgent or the androidAgent. MobileSession newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequestError MobileRequest MobileSession sessionCrashed A boolean value indicating whether or not that session crashed. MobileCrash MobileSession sessionDuration seconds (s) The length of time for which the user used the application in seconds. If the session crashes, sessionDuration is not captured (although other events and attributes are still recorded). For sessions longer than 10 minutes, events in the Interaction and Custom event categories are sent to Insights while the session is ongoing, and therefore do not have sessionDuration attributes. Events recorded near the end of the session will include the duration, as will the Session event category. MobileSession sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession timeSinceLoad seconds (s) The time, in seconds, from the beginning of the mobile session to the time the event occurred. MobileSession timestamp The UTC epoch time at which an event began. MobileRequestError MobileRequest MobileSession upgradeFrom Indictates previous version number only if this is the first launch after app upgrade. MobileSession uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileHandledException MobileRequestError MobileCrash MobileRequest MobileSession NetworkSample Data source : Infrastructure NetworkSample event captures the descriptive and state information for each network device associated with a server. It includes the device's interface and address information, as well as current usage data. New Relic samples this data every 10 seconds for each attached network interface and packages it into a NetworkSample event, then sends the raw data to New Relic's collectors every 60 seconds. Attribute name Definition Data types agentName The name of the agent (Infrastructure). NetworkSample ProcessSample StorageSample SystemSample agentVersion The version of the New Relic Infrastructure agent. NetworkSample ProcessSample StorageSample SystemSample criticalViolationCount count The number of times that alert conditions violated critical thresholds, causing critical violations and opening incidents. If this attribute does not exist on the sample, it has zero violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample entityID ID New Relic's unique ID number for the entity that is reporting data. This is used by New Relic to distinguish between customers and their entities. NetworkSample ProcessSample StorageSample SystemSample fullHostname The fully qualified (DNS) hostname. NetworkSample ProcessSample StorageSample SystemSample hardwareAddress The unique hardware address of the interface. NetworkSample hostname The short version of the entity's name. NetworkSample ProcessSample StorageSample SystemSample interfaceName The interface name as reported by the operating system. NetworkSample ipV4Address The IP version 4 address. NetworkSample ipV6Address The IP version 6 address. NetworkSample kernelVersion The Linux kernel version, in string format. This attribute is available only for systems on a Linux platform. NetworkSample ProcessSample StorageSample SystemSample linuxDistribution The name of the Linux distribution the server is using. This attribute is available only for systems on a Linux platform. NetworkSample ProcessSample StorageSample SystemSample operatingSystem The operating system on which the agent is installed. NetworkSample ProcessSample StorageSample SystemSample receiveBytesPerSecond bytes (B) The number of bytes per second received during the sampling period. NetworkSample receiveDroppedPerSecond count The number of received packets per second dropped during the sampling period. NetworkSample receiveErrorsPerSecond count The number of receive errors per second on the interface during the sampling period. NetworkSample receivePacketsPerSecond count The number of packets per second (",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.471436,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Mobile</em>",
        "body": ". AwsLambdaInvocation AwsLambdaInvocationError <em>Mobile</em>RequestError Span <em>Mobile</em>Request type The New Relic <em>event</em> type. Example values: Transaction, Span. AwsLambdaInvocation AwsLambdaInvocationError AwsLambdaInvocationError Data source : AWS Lambda This <em>event</em> is <em>reported</em> by New Relic <em>monitoring</em> for AWS Lambda. It&#x27;s"
      },
      "id": "603f53b164441f41894e8875"
    },
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-10-26T01:45:08Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.909065,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to Android <em>monitoring</em>",
        "sections": "Introduction to Android <em>monitoring</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": ". As part of the installation process, <em>mobile</em> <em>monitoring</em> automatically generates an application token. This is a 40-character hexadecimal string for authenticating each <em>mobile</em> app that you <em>monitor</em>. Follow the Android installation and configuration procedures for your environment as applicable. If you have"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "65970eacbedb3360fd1c7394affc8cbc42f2ab0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.691605,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Report</em> <em>mobile</em> <em>monitoring</em> custom <em>events</em> and attributes",
        "sections": "<em>Report</em> <em>mobile</em> <em>monitoring</em> custom <em>events</em> and attributes",
        "tags": "Custom <em>events</em>",
        "body": "<em>Mobile</em> <em>monitoring</em> in New Relic sends some default <em>event</em> data from your <em>mobile</em> app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and <em>events</em> for more detailed querying and analysis. Create custom attributes"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    }
  ],
  "/docs/data-apis/understand-data/event-data/events-reported-synthetic-monitoring": [
    {
      "sections": [
        "Security for New Relic-reported events and attributes",
        "Default events and attributes",
        "Adjust the data reported"
      ],
      "title": "Security for New Relic-reported events and attributes ",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Default events"
      ],
      "external_id": "446305a7d17c6dfb44e9e87520a1c08b79f5bcf9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/understand-data/event-data/customized-security-settings-insights/",
      "published_at": "2021-10-24T20:16:50Z",
      "updated_at": "2021-10-23T17:29:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "By default, New Relic products report a variety of data used in our UI charts and that is available for querying. Our products will not transmit sensitive information without being explicitly instrumented to do so. Default events and attributes Our products report a set of default events and attributes. We will never send request parameters or any other attributes that are not in the default set, unless someone has explicitly enabled this via configuration. Adjust the data reported When evaluating security settings for a New Relic product, review the default events and attributes. The default attributes don't contain sensitive data. In general, it's simply the data needed for effective performance monitoring. Our products don't send other data unless you change the default security settings. Depending on your requirements, either or both of these situations may apply: If the default list contains data you're concerned about, you can disable those attributes from being collected. For how to edit that, see the documentation for the product you're using. If you need to send attributes not reported by default, you can enable those attributes to be reported. In that case, do not use high security mode: this will disable the ability to collect custom attributes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 393.3646,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Security for New Relic-reported <em>events</em> and attributes ",
        "sections": "<em>Default</em> <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": "By <em>default</em>, New Relic products report a variety of <em>data</em> used in our UI charts and that is available for querying. Our products will not transmit sensitive information without being explicitly instrumented to do so. <em>Default</em> <em>events</em> and attributes Our products report a set of <em>default</em> <em>events</em>"
      },
      "id": "60a8ea67e7b9d25ec7aeabfe"
    },
    {
      "sections": [
        "Default events reported by New Relic products"
      ],
      "title": "Default events reported by New Relic products",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Default events"
      ],
      "external_id": "598dfde069ba5a8bbbd5834c44b9740d6b338cdc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/understand-data/event-data/default-events-reported-new-relic-products/",
      "published_at": "2021-10-24T20:16:50Z",
      "updated_at": "2021-10-23T17:29:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic products report different types of data. One type of data reported is event data. Events are displayed in UI charts and tables, and also made available for querying. To understand the types of data available, see Data available via NRQL. Learn more about the events reported by New Relic products: APM default events Browser default events Infrastructure default events Mobile default events Synthetics default events NrAuditEvent events for understanding changes to your account",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 393.3646,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Default</em> <em>events</em> reported by New Relic products",
        "sections": "<em>Default</em> <em>events</em> reported by New Relic products",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": "New Relic products report different types of <em>data</em>. One type of <em>data</em> reported is <em>event</em> <em>data</em>. <em>Events</em> are displayed in UI charts and tables, and also made available for querying. To understand the types of <em>data</em> available, see <em>Data</em> available via NRQL. Learn more about the <em>events</em> reported by New Relic"
      },
      "id": "609f8faf64441f8af9d2a1f0"
    },
    {
      "sections": [
        "Data requirements and limits for custom event data",
        "General requirements",
        "Important",
        "Reserved words",
        "Event type limits"
      ],
      "title": "Data requirements and limits for custom event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "77720ef366038ba648a5fbf3cf34e8e48b38440a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/data-requirements-limits-custom-event-data/",
      "published_at": "2021-10-24T20:14:57Z",
      "updated_at": "2021-10-23T21:58:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. You can report custom events to New Relic in several ways, including: APM agent APIs Event API (There are additional requirements when using the Event API.) Browser monitoring agent APIs (There are additional requirements with the custom PageAction event.) Mobile monitoring SDK General requirements When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Important Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). If the name begins with anything other than an alphabetical character, enclose the name with backticks in your NRQL query. For example: FROM `0_hello` SELECT count(*) Copy Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. Important This is not a complete list. In general, avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Event type limits The current limit for total number of eventType values is 250 per child account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 266.74457,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Data</em> requirements and limits for custom <em>event</em> <em>data</em>",
        "sections": "<em>Data</em> requirements and limits for custom <em>event</em> <em>data</em>",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": " child account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop <em>data</em>. <em>Event</em> types include: <em>Default</em> <em>events</em> from New Relic agents Custom <em>events</em> from New Relic agents Custom <em>events</em> from <em>Insights</em> custom <em>event</em> inserter"
      },
      "id": "609fa5cfe7b9d2bf16c3eb69"
    }
  ],
  "/docs/data-apis/understand-data/event-data/nrauditevent-event-data-query-examples": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/understand-data/event-data/query-account-audit-logs-nrauditevent/",
      "sections": [
        "Query account audit logs (NrAuditEvent)",
        "Account data security and retention",
        "Run NrAuditEvent query"
      ],
      "published_at": "2021-10-24T20:20:00Z",
      "title": "Query account audit logs (NrAuditEvent)",
      "updated_at": "2021-10-23T17:28:33Z",
      "type": "docs",
      "external_id": "8f0c9b883a2146792abb47c7a7245f97dea51525",
      "document_type": "page",
      "popularity": 1,
      "body": "As an additional security measure for managing your New Relic account, you can use the NrAuditEvent event to view audit logs that show changes in your New Relic account. This includes: Individuals added or deleted Role changes Account changes made via API Synthetic monitor changes Dashboard deletion Workload configuration changes You can also use alerts to be notified about changes in your New Relic account. Account data security and retention All New Relic accounts can query up to 13 months of account changes. To ensure account security, the audit logging NRQL query only tracks changes in your currently selected account. It does not show audit log events for any associated child accounts. To query changes in another account or sub-account, select the account and run a NRQL query there. Audit logging is different than configuring audit mode for your APM agent. APM audit mode records information about all data being transmitted from your app. Run NrAuditEvent query To track and view changes in your New Relic account: At any NRQL interface, run the following query, adjusting the time frame as needed up to thirteen months: SELECT * from NrAuditEvent SINCE 1 day ago Copy To customize your query, use any of the available NrAuditEvent attributes. To be notified about account changes, create NRQL conditions with New Relic Alerts. To query changes in another account, select the account and run a separate NRQL query for that account.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 530.98865,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Query</em> account <em>audit</em> logs (<em>NrAuditEvent</em>)",
        "sections": "<em>Query</em> account <em>audit</em> logs (<em>NrAuditEvent</em>)",
        "body": " information about all <em>data</em> being transmitted from your app. Run <em>NrAuditEvent</em> <em>query</em> To track and view changes in your New Relic account: At any NRQL interface, run the following <em>query</em>, adjusting the time frame as needed up to thirteen months: SELECT * from <em>NrAuditEvent</em> SINCE 1 day ago Copy To customize"
      },
      "id": "60a8eb1fe7b9d202f1aeac03"
    },
    {
      "sections": [
        "Default events reported by New Relic products"
      ],
      "title": "Default events reported by New Relic products",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Default events"
      ],
      "external_id": "598dfde069ba5a8bbbd5834c44b9740d6b338cdc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/understand-data/event-data/default-events-reported-new-relic-products/",
      "published_at": "2021-10-24T20:16:50Z",
      "updated_at": "2021-10-23T17:29:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic products report different types of data. One type of data reported is event data. Events are displayed in UI charts and tables, and also made available for querying. To understand the types of data available, see Data available via NRQL. Learn more about the events reported by New Relic products: APM default events Browser default events Infrastructure default events Mobile default events Synthetics default events NrAuditEvent events for understanding changes to your account",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 430.82584,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Default <em>events</em> reported by New Relic products",
        "sections": "Default <em>events</em> reported by New Relic products",
        "tags": "<em>Event</em> <em>data</em> sources",
        "body": " products: APM default events Browser default events Infrastructure default events Mobile default events Synthetics default events <em>NrAuditEvent</em> events for understanding changes to your account"
      },
      "id": "609f8faf64441f8af9d2a1f0"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/manage-data/nrintegrationerror/",
      "sections": [
        "Use NrIntegrationError event to understand data ingest problems",
        "Troubleshoot data ingest with NrIntegrationError",
        "Query and alert",
        "Query of Event API issues",
        "Query of Metric API issues",
        "Limit-related queries",
        "Query of distributed tracing issues",
        "Query of issues over time",
        "Tutorials and examples",
        "Ingest APIs",
        "Data limits",
        "Specific agents and integrations",
        "Programmatically use NrIntegrationError events",
        "Understand changes to your account"
      ],
      "published_at": "2021-10-24T21:26:09Z",
      "title": "Use NrIntegrationError event to understand data ingest problems",
      "updated_at": "2021-10-23T17:31:37Z",
      "type": "docs",
      "external_id": "cf863ac793109ad0484d5c220912308e8c54e41a",
      "document_type": "page",
      "popularity": 1,
      "body": "Use New Relic's NrIntegrationError event to understand problems related to data ingest, limits, and feature configuration. Troubleshoot data ingest with NrIntegrationError Our NrIntegrationError event is used to capture issues related to: Exceeding of our data ingest limits Exceeding of our query limits Malformed data Configuration issues You can run NRQL queries to analyze NrIntegrationError error messages. You can also set up alerts to be notified when specific types of errors, or certain quantities of errors, occur. NrIntegrationError events are primarily categorized by the feature that is sending them, as indicated by the newRelicFeature attribute. Values include: Metrics indicates an issue with Metric API ingest. Event API indicates an issue with Event API ingest. Logs indicates an issue with logs ingest. Distributed Tracing indicates an issue with distributed tracing (Span) data. For attribute definitions, see the data dictionary. Query and alert You can query NrIntegrationError events using NRQL, and set up NRQL alert conditions to get notified when issues happen. Here are some examples of queries: Query of Event API issues Here's a simple query of NrIntegrationError. This one shows Event API ingest issues from the last week, with up to 100 results: SELECT message FROM NrIntegrationError WHERE newRelicFeature = 'Event API' SINCE 1 WEEK AGO LIMIT 100 Copy For more detailed queries, see Example queries. Query of Metric API issues Here's a simple query of issues with the Metric API: SELECT message FROM NrIntegrationError WHERE newRelicFeature = 'Metrics' SINCE 1 WEEK AGO LIMIT 100 Copy For more detailed queries, see Example queries. Limit-related queries See Data limits. Query of distributed tracing issues Here's a simple query of issues with distributed tracing data: SELECT message FROM NrIntegrationError WHERE newRelicFeature = 'Distributed Tracing' SINCE 1 WEEK AGO LIMIT 100 Copy For more detailed queries, see Example queries. Query of issues over time Here's a query showing a count of NrIntegrationError events over time: SELECT count(*) FROM NrIntegrationError WHERE newRelicFeature = 'Metrics' TIMESERIES Copy For more detailed queries, see Example queries. If you want to examine the structure of this event and see what attributes are attached, you can use a keyset() query, like this: FROM NrIntegrationError SELECT keyset() Copy Tutorials and examples Here are links to docs that go into more detail about how to use NrIntegrationError. Ingest APIs Below are NrIntegrationError-related docs for our core ingest APIs. NrIntegrationError events are generated not just for direct use of these APIs but for any New Relic tools that rely on those API endpoints for reporting data: Metric API: see Troubleshoot Metric API ingest Event API: see parsing errors and tips for troubleshooting event reporting. Log API: See No log data appears. Trace API: see Response validation and Troubleshoot missing data. Data limits Limit-related docs: View the limits UI (NrIntegrationError is used to create these charts) Limit-related query examples Specific agents and integrations APM agent: Config mismatch StatsD Prometheus: OpenMetrics errors | Remote write errors Programmatically use NrIntegrationError events If you're interested in manipulating these events via API, see Programmatically use NrIntegrationError. Understand changes to your account If you're trying to understand changes that have been made in your New Relic account (like when a user made a change), see NrAuditEvent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 429.44086,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>NrIntegrationError</em> <em>event</em> to understand <em>data</em> ingest problems",
        "sections": "Use <em>NrIntegrationError</em> <em>event</em> to understand <em>data</em> ingest problems",
        "body": ". For attribute definitions, see the <em>data</em> dictionary. <em>Query</em> and alert You can <em>query</em> <em>Nr</em>IntegrationError events using NRQL, and set up NRQL alert conditions to get notified when issues happen. Here are some <em>examples</em> of queries: <em>Query</em> of <em>Event</em> API issues Here&#x27;s a simple <em>query</em> of <em>Nr</em>"
      },
      "id": "610f1e9564441f259347ac11"
    }
  ],
  "/docs/data-apis/understand-data/event-data/query-account-audit-logs-nrauditevent": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/understand-data/event-data/nrauditevent-event-data-query-examples/",
      "sections": [
        "NrAuditEvent event data and query examples",
        "Available events and attributes",
        "Example queries",
        "General account changes",
        "What changes have been made to the New Relic account?",
        "What type of account change was made the most?",
        "What trends appear in account changes?",
        "What user management changes have been done?",
        "Synthetics: What changes have been made to a monitor?",
        "Workloads: What changes were made to any workload configuration?",
        "Changes made by specific users",
        "What account changes have been made by any user?",
        "What account changes have been made by a specific user?",
        "Who made the most changes to the account?",
        "Synthetics: What monitors were created by a specific user?",
        "Changes made using the API",
        "What account changes have been made using an API key?"
      ],
      "published_at": "2021-10-24T20:19:59Z",
      "title": "NrAuditEvent event data and query examples",
      "updated_at": "2021-10-23T17:27:33Z",
      "type": "docs",
      "external_id": "3619285ba0ba23c989f4abdd90607e4b8ba6aa13",
      "document_type": "page",
      "popularity": 1,
      "body": "To view changes made in your New Relic account, you can query NrAuditEvent events. Available events and attributes The NrAuditEvent is created to record configuration changes made in our products. The data gathered for this event includes the type of account change, actor (user or API key) that made the change, a human-readable description of the action taken, and a timestamp for the change. To see all the attributes attached to this event, see NrAuditEvent. Example queries These examples show some of the ways you can run NRQL queries of the NrAuditEvent event. General account changes What changes have been made to the New Relic account? To view all changes to your New Relic account for a specific time frame, run this basic NRQL query: SELECT * from NrAuditEvent SINCE 1 day ago Copy What type of account change was made the most? To query what type of change to the account users was made the most frequently during a specific time frame, include the actionIdentifier attribute in your query. For example: SELECT count(*) AS Actions FROM NrAuditEvent FACET actionIdentifier SINCE 1 week ago Copy What trends appear in account changes? When you include TIMESERIES in a NRQL query, the results are shown as a line graph. For example: SELECT count(*) from NrAuditEvent TIMESERIES facet actionIdentifier since 1 week ago Copy What user management changes have been done? Note that your users' user model will impact these queries. If your users are on our original user model, you can only query per account. If your users are on the New Relic One user model, you should query the top-level account in your New Relic organization. To see all the changes made to users, you could use: SELECT * FROM NrAuditEvent WHERE targetType = 'user' SINCE this month Copy If you wanted to narrow that down to see changes to user type (full user vs basic user), you could use: SELECT * FROM NrAuditEvent WHERE targetType = 'user' AND actionIdentifier IN ('user.self_upgrade', 'user.change_type') SINCE this month Copy Synthetics: What changes have been made to a monitor? To query Synthetics monitor updates during a specific time frame, include the actionIdentifier attribute in your query. For example: SELECT count(*) FROM NrAuditEvent WHERE actionIdentifier = 'synthetics_monitor.update_script' FACET actionIdentifier, description, actorEmail SINCE 1 week ago LIMIT 1000 Copy For more information about this Synthetics feature, see Synthetics audit log. Workloads: What changes were made to any workload configuration? To query what configuration changes were made to any workload, use the query below. The targetId attribute contains the GUID of the workload that was modified, which you can use for searches. Since changes on workloads are often automated, you might want to include the actorType attribute to know if the change was done directly by a user through the UI or through the API. SELECT timestamp, actorEmail, actorType, description, targetId FROM NrAuditEvent WHERE targetType = 'workload' SINCE 1 week ago LIMIT MAX Copy Changes made by specific users What account changes have been made by any user? To see detailed information about any user who made changes to the account during a specific time frame, include actorType = 'user' in the query. For example: SELECT actionIdentifier, description, actorEmail, actorId, targetType, targetId FROM NrAuditEvent WHERE actorType = 'user' SINCE 1 week ago Copy What account changes have been made by a specific user? To query account activities made by a specific person during the selected time frame, you must know their actorId. For example: SELECT actionIdentifier FROM NrAuditEvent WHERE actorId = 829034 SINCE 1 week ago Copy Who made the most changes to the account? To identify who (actorType) has made the most changes to the account, include the actorEmail attribute in your query. For example: SELECT count(*) as Users FROM NrAuditEvent WHERE actorType = 'user' FACET actorEmail SINCE 1 week ago Copy Synthetics: What monitors were created by a specific user? To query Synthetics monitor updates made by a specific user, include the actionIdentifier and actorEmail attribute in your query. For example: SELECT count(*) FROM NrAuditEvent WHERE actionIdentifier = 'synthetics_monitor.update_script' FACET actorEmail, actionIdentifier, description SINCE 1 week ago LIMIT 1000 Copy Changes made using the API What account changes have been made using an API key? To see detailed information about changes to the account that were made using an API key during a specific time frame, include actorType = 'api_key' in the query. For example: SELECT actionIdentifier, description, targetType, targetId, actorAPIKey, actorId, actorEmail FROM NrAuditEvent WHERE actorType = 'api_key' SINCE 1 week ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 623.18054,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NrAuditEvent</em> <em>event</em> data and <em>query</em> examples",
        "sections": "<em>NrAuditEvent</em> <em>event</em> data and <em>query</em> examples",
        "body": "To view changes made in your New Relic <em>account</em>, you can <em>query</em> <em>NrAuditEvent</em> events. Available events and attributes The <em>NrAuditEvent</em> is created to record configuration changes made in our products. The data gathered for this <em>event</em> includes the type of <em>account</em> change, actor (user or API key"
      },
      "id": "60a8e35ce7b9d2b07caeabdd"
    },
    {
      "sections": [
        "Default events reported by New Relic products"
      ],
      "title": "Default events reported by New Relic products",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Default events"
      ],
      "external_id": "598dfde069ba5a8bbbd5834c44b9740d6b338cdc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/understand-data/event-data/default-events-reported-new-relic-products/",
      "published_at": "2021-10-24T20:16:50Z",
      "updated_at": "2021-10-23T17:29:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic products report different types of data. One type of data reported is event data. Events are displayed in UI charts and tables, and also made available for querying. To understand the types of data available, see Data available via NRQL. Learn more about the events reported by New Relic products: APM default events Browser default events Infrastructure default events Mobile default events Synthetics default events NrAuditEvent events for understanding changes to your account",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 493.62262,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Default <em>events</em> reported by New Relic products",
        "sections": "Default <em>events</em> reported by New Relic products",
        "tags": "<em>Event</em> data sources",
        "body": " products: APM default events Browser default events Infrastructure default events Mobile default events Synthetics default events <em>NrAuditEvent</em> events for understanding changes to your <em>account</em>"
      },
      "id": "609f8faf64441f8af9d2a1f0"
    },
    {
      "sections": [
        "Data privacy with New Relic",
        "Tip",
        "Personal data transfer (Privacy Shield and SCC)",
        "Compliance with legal requirements",
        "Privacy by design and by default",
        "Personal data requests (GDPR, CCPA, etc.)",
        "Events and attributes",
        "Dropping data at ingest",
        "Technical security controls",
        "Organizational security controls",
        "Account security",
        "Retention of your data",
        "New Relic account emails",
        "Account changes (NrAuditEvent)",
        "Account usage",
        "Security for products and services",
        "Alerts and Applied Intelligence",
        "APIs",
        "APM",
        "Browser monitoring",
        "Diagnostics",
        "Infrastructure monitoring",
        "Integrations and serverless monitoring",
        "Logs management",
        "Mobile monitoring",
        "Synthetic monitoring"
      ],
      "title": "Data privacy with New Relic",
      "type": "docs",
      "tags": [
        "Security",
        "Security and Privacy",
        "Data privacy"
      ],
      "external_id": "d46953520476285467540433180d483815efecc6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/security/security-privacy/data-privacy/data-privacy-new-relic/",
      "published_at": "2021-10-25T16:18:55Z",
      "updated_at": "2021-10-25T16:18:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic takes your data privacy seriously. Our principles-based approach aims to go beyond the legal requirements for consent. We understand your concerns when you entrust us with your data, and we always strive to embrace your expectations and preferences. This document provides links to detailed information about the privacy and security measures we take to protect you and your customers' data privacy. Our monitoring tools are data-agnostic; they don't require sensitive materials, and many of them don't require any personal data. You are responsible for ensuring that your systems are appropriately set up and configured so that they don't send inappropriate personal data or sensitive materials to New Relic monitoring tools. For additional information about policies, credentials, audits, and other resources, see our New Relic security website. Tip New Relic now offers the option of HIPPA-enabled accounts for customers meeting certain requirements. To learn more, see HIPAA readiness at New Relic. Personal data transfer (Privacy Shield and SCC) The Schrems case ruling invalidates Privacy Shield. However, it explicitly reaffirms the validity of Standard Contractual Clauses (SCC) as an appropriate legal mechanism to transfer personal data outside of the European Union. You can find more information in How the Demise of Privacy Shield Affects Your New Relic Account. If you want to send personal data from the EU, we offer an appropriate data processing agreement (DPA) with SCC to govern the transfer of that data in accordance with the Schrems decision. For more information, consult our Data Processing Addendum FAQ, or download our pre-signed DPA (PDF|697 KB). Compliance with legal requirements We always strive to comply with all applicable laws as they take effect. This includes the European Union's General Data Protection Regulation (GDPR) and all relevant US State laws, such as the California Consumer Privacy Act (CCPA). Our disk-based encryption provides additional security while your data is at rest (FIPS 140-2 compliant). In addition, we are authorized for Moderate Impact SaaS Services (FedRAMP Authorized Moderate) for accounts that meet specific criteria. For privacy-related details about New Relic's contractual and regulatory commitments for services, see: Terms of Service or Master Subscription Agreement Data Protection Agreement Services Privacy Notice For more information about annual audits, see Regulatory audits for New Relic services. Privacy by design and by default New Relic follows \"privacy by design\" principles as part of our overarching security program. For example, when New Relic agents capture a webpage or referrer URL, all query parameters are stripped by default. Here are examples of how we incorporate privacy considerations into our data and security practices. Personal data requests (GDPR, CCPA, etc.) New Relic strives to comply with all applicable laws as they take effect. This includes the European Union's GDPR and ePrivacy Directive and all applicable privacy laws, such as the California Consumer Privacy Act (CCPA) in the US. For more information about our process when responding to requests to access or delete personal data, see New Relic personal data requests. Events and attributes You can query events and attributes, as well as create charts and alert conditions about this data. For a complete list of all events and attributes tracked by New Relic agents, see our data dictionary. Events and attributes example: If you use the Infrastructure ProcessSample event's commandLine attribute, by default we strip options and arguments from the full command line to prevent accidental leakage of sensitive information. Dropping data at ingest Dropping data gives you control over the data that you send to New Relic, including any personal data that you configured to be collected. By dropping specific events or attributes from events, you determine what data New Relic ultimately stores so that you can query, alert on, and analyze it. For more information, see Drop data using NerdGraph. When our agents refer to data obfuscation, the agent actually removes the data before sending it to New Relic. The data cannot be recovered. For example, with APM queries, the Record SQL? value defaults to obfuscated. This strips the string literals and numeric sequences and then replaces them with the ? character. You can mask sensitive information in HTTP or HTTPS requests. For example, queries about distributed traces and transaction traces are obfuscated by default, in which case they cannot be recovered. For more information, see the documentation for specific New Relic services, including: APM transaction traces Distributed tracing Technical security controls We use a comprehensive set of technical controls to support general security needs as well as security for data we receive. For more information, see our documentation about data security, data encryption, and high security mode for APM agents. Organizational security controls New Relic maintains a number of internal policies and procedures to guide employees in privacy-related subjects such as data classification and handling, data retention, handling of personal data, fulfilling personal data requests, incident response, etc. All employees must complete the security and privacy training upon hiring and renew this training annually. Account security Our role-based account structure gives you direct control over who can access or change your account settings. For more information, see Users and roles. Retention of your data The New Relic One platform gives you a single source of truth for all your operational data, empowering you to ask and answer any question in milliseconds. This platform stores different types of data for different periods of time. The Data retention page in our UI provides information on how long your data will be stored in the New Relic database (NRDB). For more information, see Manage data retention. New Relic account emails By default, we communicate with you for a variety of purposes related to your status as New Relic subscribers. This includes product engagement, support, alert notifications, updates, billings, etc. Individual users can unsubscribe from certain communications. General email preferences are managed through the account user interface. For more information, see Account email settings. Alert notification emails are managed through the alerting UI. Account changes (NrAuditEvent) To view changes made to your account's users or to record configuration changes, query NrAuditEvent events. To be notified about account changes, create NRQL alert conditions. For more about available NrAuditEvent attributes, see our data dictionary. Account usage For more about usage, see Manage data. Security for products and services We publish security bulletins with detailed information about vulnerabilities, remediation strategies, and applicable updates for affected software. To receive notifications for future advisories, use either of these options: Subscribe to our security bulletins RSS feed. Select the Watching option in our Explorers Hub's Security notifications community channel to receive email alerts. The following summarizes how individual New Relic products and components ensure security, with links to additional details. Alerts and Applied Intelligence By default, our alerting services do not record any personal data. In addition, they automatically set default permissions for individual account users and access levels within account structures. For more information, see our documentation about Applied Intelligence, as well as our rules and limits for alerts. APIs APIs simply are interfaces for data exchange automation. APIs have no knowledge of the content being transferred. We require authorized users to provide their API keys to monitor subscription usage, manage account user permissions, query data, and perform other automated tasks. For more information, see Introduction to New Relic APIs. APM APM agents monitor your applications' performance. By default, APM agents do not record any personal data. For more information, see our APM security documentation. Browser monitoring Our browser monitoring agent allows you to monitor the performance of their websites. For more information, see: Browser security documentation Visitor's IP address New Relic cookies used by browser Enabling or disabling cookie collection for session tracking Diagnostics The New Relic Diagnostics service inspects relevant system information and any other necessary information (such as logs and config files) to perform diagnostic checks that assess configuration and operability. By default, this data is not transmitted to New Relic. You do have the option to upload this information to a support ticket over HTTPS. For more information, see the Diagnostics security documentation. Infrastructure monitoring The Infrastructure agent allows you to monitor the performance of components in your ecosystem, such as servers, platforms, operating systems, databases, etc. Infrastructure may record the userID and username of users connecting to Infrastructure resources. For more information, see the security documentation for infrastructure monitoring. Integrations and serverless monitoring Our integrations services allow you to retrieve and load data into the New Relic database from a variety of sources, including: Cloud-based integrations On-host integrations in containerized environments, such as Kubernetes On-host integrations built by New Relic On-host integrations built by the open-source community On-host integrations built by you Depending on the integration, different types of data may be recorded so that you can monitor the integrations in New Relic. The integration services are data agnostic. They will have no knowledge of whether the imported data contains any personal information. For more information, see the documentation for the specific integration, including: Amazon Web Services (AWS) Google Cloud Platform (GCP) Kubernetes Microsoft Azure On-host integrations Open source on-host integrations Serverless function monitoring Logs management Due to the nature of our logs management service, you have direct control over what data is reported to New Relic. To ensure data privacy and to limit the types of information New Relic receives, no customer data is captured except what you supply in your API calls or log forwarder configuration. All data for the logs service is then reported to New Relic over HTTPS. The logs service does mask number patterns that appear to be for items such as credit cards or Social Security numbers. For more information, see the Logs security documentation. Mobile monitoring By default, our mobile monitoring service collects two pieces of personal data: The IP address is used to derive high-level geographical data, and then is discarded. A device ID is generated by New Relic and is used for billing purposes. For more information, see our security documentation for mobile monitoring. Synthetic monitoring The synthetic monitoring service uses monitors distributed throughout data centers around the world. It captures what is essentially performance data of simulated traffic. By default, it does not capture any personal data. For more information, see the data privacy and security documentation for synthetic monitoring. If you configure the synthetic service to monitor areas of websites that are located behind a login page, take care to create a non-personal login dedicated to this purpose. This will reduce the risk of unintended personal data exposure. For example, to securely store sensitive information, such as passwords, API keys, and user names, you can use secured credentials for scripted browsers and API tests. The synthetic monitoring service also supports a variety of authentication mechanisms. Depending on the type of monitor you choose, this includes Basic, Digest, NTLM, and NTLMv2. You can also control which of your users can access your monitors and private locations. For more information, see our documentation about user role-based permissions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 454.11566,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Account</em> changes (<em>NrAuditEvent</em>)",
        "body": " preferences are managed through the <em>account</em> user interface. For more information, see <em>Account</em> email settings. Alert notification emails are managed through the alerting UI. <em>Account</em> changes (<em>NrAuditEvent</em>) To view changes made to your <em>account</em>&#x27;s users or to record configuration changes, <em>query</em> <em>NrAuditEvent</em>"
      },
      "id": "603ec2d4e7b9d22fba2a07c6"
    }
  ],
  "/docs/data-apis/understand-data/metric-data/metric-data-type": [
    {
      "sections": [
        "New Relic data types",
        "Get started",
        "Tip",
        "Metrics",
        "Metrics in the monitoring industry",
        "Metrics at New Relic",
        "Dimensional metrics (used by Metric API and many integrations)",
        "Metric timeslice data (used by APM, browser, mobile)",
        "Metric timeslice examples",
        "Metrics attached to events (used by Infrastructure, other products)",
        "Metrics as a computation of events (used in some charts and queries)",
        "Event data",
        "Events in the monitoring industry",
        "Events at New Relic",
        "Log data",
        "Logs in the monitoring industry",
        "Logs at New Relic",
        "Trace data",
        "Tracing in the monitoring industry",
        "Tracing at New Relic",
        "Query and send data",
        "Learn more"
      ],
      "title": "New Relic data types",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Understand data"
      ],
      "external_id": "8e4ab82bb58db47bc412f57231d4956c6068262b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/understand-data/new-relic-data-types/",
      "published_at": "2021-10-24T21:27:50Z",
      "updated_at": "2021-10-23T17:27:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic platform is built around the four fundamental telemetry data types we believe are necessary for complete and effective system monitoring: metrics, events, logs, and traces. Get started This doc will give you a fairly technical explanation of our core data types, their structure, and how they're used in our features. You can use most of our features without needing to understand the underlying data structure. But having a better understanding of this can help you get data into New Relic, understand the data you see in our UI, and query your data. For a simpler explanation of these data types using real-world examples, see Introduction to essential telemetry data types. Another good way to understand your data is to just start querying it. Tip Access your data easily on one.newrelic.com: Click the Browse data dropdown menu and select the data type (metrics, events, logs, and traces) you want to explore. Metrics First, we’ll explain the definition of metrics from a monitoring industry perspective, and then we’ll explain how New Relic handles metrics. For a list of the metrics we collect, see our documentation on metrics. Metrics in the monitoring industry In the software monitoring industry, a metric means a numeric measurement of an application or system. Metrics are typically reported on a regular schedule. Two major types of metrics are: Aggregated data. For example: a count of events over one minute’s time, or the rate of some event per minute. A numeric status at a moment in time. For example: a CPU temperature reading, or a “CPU% used” status. Metrics are relatively easy to report and store because a single record can represent a range of time. They can also be aggregated more and more over time. For example, per-minute data may be “rolled up” to per-hour aggregations after some amount of time, and eventually may be rolled up to a per-day aggregation. This approach is efficient for long-term data storage. Metrics are a strong solution for storing data long-term, and understanding trends over time. One potential downside is that it can be difficult to do detailed analysis of older data that has been aggregated over time; when high detail is required about specific important actions, event data can be used. Metrics at New Relic Conceptually, \"metrics\" is a broad, general category. There are various ways New Relic measures and reports metrics but, in practice, when using the New Relic UI, you usually won't have to understand how exactly this happens. In our documentation, we typically will just refer to \"metrics,\" regardless of how that data is reported, unless there's a reason you need to know more (like understanding how to query your data). Here are some of the ways metrics are reported and stored across the New Relic platform: Dimensional metrics (used by Metric API and many integrations) In the monitoring industry, \"dimensional\" metrics refer to metric data that has a variety of attributes (dimensions) attached, such as duration-related attributes (start time, end time), entity ID, region, host, etc. This amount of detail allows for in-depth analysis and querying. At New Relic, this metric data is attached to the Metric data type and is sent from several sources: Some open-source integrations, like our Prometheus and OpenCensus exporters Our Telemetry SDKs Infrastructure services The Metric API (the underlying API used by the above tools) The events-to-metrics service To query this data and see its attributes (\"dimensions\"), you could use a NRQL query like: Select * from Metric Copy As time passes, these metrics are increasingly aggregated into larger time buckets. This is done to optimize your ability to query data over a long period of time. For more details about the metric data type, see our docs. To learn how this data is ingested and stored, see the Metric API documentation. For tips on querying, see Metric query examples. Metric timeslice data (used by APM, browser, mobile) New Relic's APM, browser, and mobile report and display metrics in a simple data format that we refer to as metric timeslice data. A metric timeslice consists of three parts: a metric name, the segment of time the metric represents (the \"timeslice\"), and a numeric value (the measurement). For example: an APM metric timeslice for time spent in a particular transaction is named WebTransaction/URI/foo, and might have a response time of 0.793 for a one-minute time slice from 10:20am to 10:21am. These metrics usually follow a pattern like <category>/<class>/<method>. Our agents (APM, browser, and mobile) can collect thousands of metric timeslices per minute for a variety of performance metrics. For example: error rate, bandwidth usage, and garbage collection time. You also have the ability to create custom metrics. Metric timeslice data is a lightweight data type and lacks the detail that dimensional metrics have. Ways to explore and query metric timeslice data: For APM: metric timeslice data is converted to dimensional metrics and can be queried via NRQL Use the REST API If you want to learn more about the structure of metric timeslice data and see some examples, expand the collapser below. Metric timeslice examples Here are some common metric timeslice data examples, with a focus on common ones used by Ruby applications. ActiveMerchant New Relic tracks a variety of metrics on ActiveMerchant transactions which can be used for business analytics as well as performance monitoring. The metrics are summarized by operation as well as by gateway. regex sample metric legend name ActiveMerchant/. * ActiveMerchant/PayJunctionGateway ActiveMerchant/gateway/. * ActiveMerchant/gateway/PayJunctionGateway/purchase PayJunctionGateway ActiveMerchant/operation/. * ActiveMerchant/operation/purchase purchase For more information, see the ActiveMerchant website. ActiveRecord ActiveRecord is the Object-Relational Mapping API used by Ruby on Rails applications. The metrics shown here measure the performance of ActiveRecord's find and save methods. regex sample metric legend name ActiveRecord/. * /find ActiveRecord/User/find User#find ActiveRecord/. * /save ActiveRecord/Product/save Product#save For more information, see the API documentation for ActiveRecord. Apdex Apdex is a measure of user satisfaction with page load times. Controller In Ruby on Rails applications, HTTP requests are handled by Controller actions. A Rails application has many controllers, each of which has one or more actions. When your rails application receives an http request, that request is routed to the appropriate controller and action, based on the URL of that request. That action then does whatever processing is neccesary to generate an http response, which is most often a web page, but could also be a page fragment, an xml document, or any other kind of data that is requested by the client. The following metrics track the performance of controller actions, regardless of routing, and without taking into account any network or web server effects. regex sample metric legend name Controller/. * Controller/Users/show /Users/show Controller/. * /(?! \\ (other \\ )). * Controller/Users/show /Users/show Controller$ Controller All Controller Actions ControllerCPU/ ControllerCPU/Users/Show /Users/show For more information, see the API documentation for ActionController. Errors This metric tracks the number of errors or exceptions raised while processing requests. regex sample metric legend name Errors/all Errors/all External services External service instrumentation captures calls to out-of-process services such as web services, resources in the cloud and any other network calls. It does not include other first class back-end components such as MemCache and the database. In Ruby applications we instrument the Net::Http library to capture all HTTP services. regex sample metric legend name External/ [ ^/]+/all$ External/service.example.com/all All service.example.com calls External/ External/host.aws.com/Net::Http : :POST Net::Http : :POST [ host.aws.com] External/all$ External/all External Services External/ [ ^/]+/(?!all)/ External/service.example.com/all All service.example.com calls HTTP dispatcher This metric represents a summary of the throughput and response time of all web requests. regex sample metric legend name ^HttpDispatcher$ HttpDispatcher HttpDispatcher MemCache MemCache is a popular technology that enables applications to access shared memory provided by any number of physical machines as a global cache. Applications that heavily use the database often use MemCache for performance and scalability benefits. These metrics measure the frequency and response time of calls to MemCache to read and write data from the cache. Response times should be low (less than 5 ms) for a well performing MemCache deployment. regex sample metric legend name MemCache/. * MemCache/read MemCache read operations MemCache/read MemCache/read MemCache read operations MemCache/write MemCache/write MemCache write operations Mongrel This metric measures the length of the mongrel queue, which holds pending http requests to be processed by mongrel. The HTTP Activity graph overlays the maximimum queue length for a given period. The value is zero if mongrel is processing a request but has no other requests waiting in its queue. When looking at this value across an aggregate cluster of mongrels, the queue lengths of all mongrels is added together, showing the sum of all queue lengths. A mongrel queue length should be at or near zero; if it is consistently at a higher level, then it indicates that your rails application is having trouble keeping up with its load requirements. regex sample metric legend name Mongrel/Queue Length Mongrel/Queue Length Queue Length View ActionView is a package in Rails that is used to render the output that is the response to an http request, such as an html page or an xml document. The View is rendered by the controller that is handling the request. If View metrics represent a large portion of your controller's response time, it could mean you are doing a lot of database operations inside the view template itself. regex sample metric legend name View/. * View/Users/ _ child.html.erb/Partial Users/ _ child.html.erb View/. * /Partial View/Users/ _ child.html.erb/Partial Users/ _ child.html.erb View/. * /Rendering View/Users/show.html.erb/Rendering Users/show.html.erb For more information, see the API documentation for ActionView. Metrics attached to events (used by Infrastructure, other products) Because event-type data can have any type of key-value pair data attached to it, one way metrics can be reported is as attributes attached to an event. A couple examples of this at New Relic: Our infrastructure monitoring reports many metrics that are attached to events. For example, we report a ProcessSample event, which has various sample-based metrics attached to it, like CPU percentage. To learn more about infrastructure monitoring data, see Infrastructure data. In APM, the Transaction event has several metrics attached to it, including databaseDuration. To learn more about this data and how to query it, see Events. Metrics as a computation of events (used in some charts and queries) Metrics can be formed by counting New Relic events, or doing some other mathematical calculation on those events. For example, if you wanted to measure the total number of Transaction events over the last half hour, you might run this NRQL query: Select count(*) from Transaction since 30 minutes ago Copy Another example: if you wanted to compute the average response time for your service, you might run a query like: FROM Transaction SELECT average(duration) SINCE 30 minutes ago Copy Some New Relic charts are generated with these kinds of queries. The downside of this approach is that there are limits on how many events a monitoring system (including ours) can report. This means that sometimes, for high-throughput systems, the count may not accurately represent the total activity on that system. To learn more about how this can be addressed, see Event limits and sampling. Want to report custom metrics? See Get data into New Relic. Event data First, we’ll explain the definition of events from a monitoring industry perspective, and then we’ll explain some specifics about how New Relic handles event data. Events in the monitoring industry In the software industry, events can be thought of as simply “things that occur in a system.” For example, a server setting being changed would be an event. Another example: a website user clicking a mouse. Some events will generate a stored record, and that record is typically also called an event. Event data represents discrete occurrences and typically will have a high level of detail, so event data is suited for detailed analysis and querying. The downside to the use of event data is that there are typically so many events reported that it can become difficult to query that large dataset over longer time ranges. Events at New Relic At New Relic, we report events to data objects also called events. These events have multiple attributes (key-value pairs) attached. Event data is used in some UI charts and tables, and you can also query it. How long event data remains available is determined by data retention rules. One example of an event: APM reports an event type named Transaction, which represents a logical unit of work in an application. To see the attributes attached to this event, you could use a NRQL query like: Select * from Transaction Copy For examples of querying event data, see Introduction to NRQL. Other details about New Relic event data: Events can have any type of attributes attached. Some events have attributes that report metric data. You can report custom events. To increase the availability of your event data for querying/charting, you can turn events into metrics. Some systems generate a large number of events that exceeds collection limits and results in incomplete query results. For more on this, see Event sampling. Because event is a general term, in some New Relic contexts it will refer to any data type that can be queried via NRQL. For example, when you run a NRQL query, it returns a count of inspected events: this is a count of all data types queried. Log data First, we’ll explain the definition of logs from a monitoring industry perspective, and then we’ll explain some specifics about how New Relic handles log reporting. Logs in the monitoring industry A log is a message about a system used to understand the activity of the system and to diagnose problems. Logs at New Relic New Relic's Logs gives you a centralized log management platform that connects your log data with other New Relic-monitored data. For example, you can see logs alongside your APM data. In New Relic, log data is reported with multiple attributes (key-value data) attached. To query your log data, you could use a NRQL query like: Select * from Log Copy To report custom log data, see the Log API. Trace data First, we’ll explain the definition of traces from a monitoring industry perspective, and then we’ll explain some specifics about how New Relic handles tracing. Tracing in the monitoring industry In the application/infrastructure-monitoring world, tracing is a general term used to refer to various ways to report information about how a program or system is operating. For example, a stack trace provides in-depth information about a program’s subroutines. For large modern systems, which are often distributed across many services and micro-services, “tracing” often refers to distributed tracing, which is a way to monitor requests as they propagate through a complex, distributed environment. Tracing at New Relic New Relic offers a distributed tracing feature that tracks requests across a distributed system, and provides a dedicated UI for understanding and analyzing your traces. In New Relic, trace data is reported as Span objects, with multiple attributes (key-value pairs) attached. To query your tracing data, you could use a NRQL query like: Select * from Span Copy To learn more about how distributed tracing works, see Understand distributed tracing. To report custom distributed tracing data, see the Trace API. Query and send data Understanding New Relic data types can help you: Query data in New Relic Send data to New Relic Learn more For a simpler explanation of these data types using real-world examples, see Introduction to essential telemetry data types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 319.6871,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic <em>data</em> types",
        "sections": "Query <em>and</em> send <em>data</em>",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": ", and how they&#x27;re used in our features. You can use most of our features without needing to <em>understand</em> the underlying <em>data</em> structure. But having a better understanding of this can help you get <em>data</em> into New Relic, <em>understand</em> the <em>data</em> you see in our UI, and query your <em>data</em>. For a simpler explanation"
      },
      "id": "6045280de7b9d266e1579a0f"
    },
    {
      "sections": [
        "Get data into New Relic",
        "New Relic-built agents and integrations",
        "Report custom data"
      ],
      "title": "Get data into New Relic",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Get started"
      ],
      "external_id": "016a25d46dedc5da1455b29d8557ce68a4345756",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/get-started/introduction-new-relic-data-ingest-apis-sdks/",
      "published_at": "2021-10-24T19:36:34Z",
      "updated_at": "2021-10-23T17:32:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are many ways to get data into your New Relic account. Any New Relic user can use any of our data ingest methods to report data to our platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure monitoring, or any of our wide array of integrations, by default you'll receive data from your monitored applications, hosts, services, or other entities. Some options for getting started: Log into one.newrelic.com and click Add more data to get some guidance on setting up New Relic solutions. To browse our solutions, see New Relic integrations. Report custom data If you need to report data that our agents and integrations don't provide, we have tools that will allow you to bring in any type of data you need. To learn more, see Intro to custom data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.0275,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get <em>data</em> into New Relic",
        "sections": "Get <em>data</em> into New Relic",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": "There are many ways to get <em>data</em> into your New Relic account. Any New Relic user can use any of our <em>data</em> <em>ingest</em> methods to report <em>data</em> to our platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure"
      },
      "id": "6174474328ccbcdff4c6b77e"
    },
    {
      "sections": [
        "NRDB: the horsepower under the hood",
        "Billions of data points per minute",
        "Scale, purpose, and equal access to resources",
        "The lifecycle of a query",
        "The result: flexibility, speed, accuracy, and efficiency",
        "What’s next?"
      ],
      "title": "NRDB: the horsepower under the hood",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Get started"
      ],
      "external_id": "73e784610bedcc1bf4ae777e5d6a7a426f37304a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/get-started/nrdb-horsepower-under-hood/",
      "published_at": "2021-10-24T23:24:43Z",
      "updated_at": "2021-10-23T17:32:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you’ve been reading our documentation, chances are you’ve already learned a bit about New Relic and the many tools and capabilities we offer. We’re very proud of the utility and design of our dashboards, alerts, and versatile programmability, but none of it would be possible without the computing power needed to make it all run smoothly. Just like a finely calibrated race car, what you see on the outside may be the most exciting features, and these are the parts you interact with to “drive.” But without an engine designed to win, elegant instrument panels, a responsive clutch, and a great paint job won’t get you anywhere. Under the hood of New Relic lies the engine powering it all: the New Relic Database (NRDB). In this resource, we explain how NRDB helps you succeed in your observability goals. Billions of data points per minute New Relic ingests billions of telemetry data points every minute, serving more than 180,000 accounts simultaneously. To run such a high-volume platform, the underlying database and query capabilities need to be fast, flexible, and scalable. They must also be equally effective for organizations of all sizes, supporting a wide spectrum of telemetry needs and business goals. NRDB provides the power, speed, and scalability you need to monitor your performance across your entire landscape quickly and effectively. Scale, purpose, and equal access to resources To meet the challenging demands for speed, efficiency, scalability, and reliability, we built NRDB with three key objectives. Unlimited scalability: Hosted in the cloud, NRDB's distributed architecture has the capacity for virtually unlimited scale. Monitoring and analysis: With this dual purpose in mind, NRDB handles operational monitoring and data analytics equally well. This means that NRDB can ingest massive amounts of data while also giving you real-time alerting, lightning-fast queries, and charting — all without sacrificing speed. Resources when you need them: As a multi-tenant system supporting tens of thousands of customers, NRDB gives you the resources you need when you need them (which single-tenant systems cannot match). The lifecycle of a query NRDB returns results for queries of all sizes astonishingly fast. To do this, we use parallel processing at massive scale. This architectural approach is equally effective for accelerating a single large query and for allowing numerous users to run small queries simultaneously without impacting speed. It works like this: A user enters a query using one of our tools, such as the query builder, or a dashboard or other type of instrumentation sends an automated query. NRDB starts by sending the query to a router, which in turn sends the query components to hundreds or even thousands of query workers. The query workers find the data, and the process is repeated in reverse, with data returning to populate dashboards, create alerts, or answer discrete queries, among other things. This process yields complete query results in a fraction of the time that other methods would require. To further improve efficiency, NRDB also caches recent queries, allowing it to send those results back to users nearly instantaneously. The result: flexibility, speed, accuracy, and efficiency How big is the difference? Because of NDRB's raw power and purposeful design, New Relic's telemetry products are able to analyze tens of billions of events per second while maintaining a median query response time of 45 milliseconds. We would say, “Your query results are just a heartbeat away,” but mathematically that’s more like a tenth of a heartbeat (unless you’re a mouse). What do these statistics mean for our customers? At the end of the day, NRDB's speed and unique capabilities enable you to identify, analyze, and fix performance problems much faster, reducing downtime so you can get back to business. What’s next? Want to know more? Here are a few recommendations for what to do next: Learn about NRDB's data model and flexible schema in our blog post and white paper. Get to know NRQL, our query language, with our Syntax, clauses, and functions page, or read about some of our favorite NRQL capabilities. Read about our query builder, which supports NRQL and PromQL-style queries. Check out UI options for dashboards and charting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.0275,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Billions of <em>data</em> points per minute",
        "tags": "<em>Ingest</em> <em>and</em> <em>manage</em> <em>data</em>",
        "body": " that NRDB can <em>ingest</em> massive amounts of <em>data</em> while also giving you real-time alerting, lightning-fast queries, and charting — all without sacrificing speed. Resources when you need them: As a multi-tenant system supporting tens of thousands of customers, NRDB gives you the resources you need when you need"
      },
      "id": "61744743e7b9d212c413d95d"
    }
  ],
  "/docs/data-apis/understand-data/metric-data/query-apm-metric-timeslice-data-nrql": [
    {
      "sections": [
        "Extract metric timeslice data",
        "Time based data",
        "Time range considerations",
        "Important",
        "Tip",
        "Controlling time period output",
        "Data retention",
        "Extracting non-existent metric timeslice data"
      ],
      "title": "Extract metric timeslice data",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Basic functions"
      ],
      "external_id": "2a144a4b775dd2332592a5d92c199a07c08f49fa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/basic-functions/extract-metric-timeslice-data/",
      "published_at": "2021-10-24T19:58:41Z",
      "updated_at": "2021-03-13T01:07:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "One type of New Relic data is metric timeslice data. There are several ways to query metric timeslice data: You can query APM metric timeslice data via NRQL (and therefore via our NerdGraph API). You can query any metric timeslice data via the REST API This doc explains how to do this with the REST API. Note that the API is not intended for bulk data extraction of minute-by-minute data points. Time based data All time values returned by the REST API and the API Explorer are UTC (Universal Time Coordinated). Be sure to adjust the time values for data collection as necessary. Time range considerations Important The minimum time range for data requests is one minute (60 seconds). Requests for anything less will result in a 422 status code and no data will be returned. New Relic only collects data at one minute intervals. The API uses the same mechanism for requesting data as the UI: it depends on the time range for the data you request. The objective is to optimize the number of data points returned and provide an easily digestible graph and report. For example: If you request data from a time range of three hours or less, the API returns the one-minute data values originally collected. If you increase the time range to greater than three hours, the data values returned will be an average for two minutes. If you increase the time range to over six hours, the data values returned will be an average for five minutes, and so on. Tip If the initial time for a requested time range is older than eight days, ten evenly spaced data points will be returned for any time range less than four days in length. Here is a summary of the metric value retrieval for the time ranges available. Between this time range... and this time range Granularity of collected data data age ≤ 8 days data age > 8 days ≤ 3 hours 1 minute 10 evenly spaced data points > 3 hour ≤ 6 hours 2 minutes > 6 hours ≤ 14 hours 5 minutes > 14 hours ≤ 24 hours 10 minutes > 1 day (24 hrs) ≤ 4 days (96 hrs) 30 minutes > 4 days ≤ 7 days 1 hour 1 hour > 7 days ≤ 3 weeks 3 hours 3 hours > 3 weeks ≤ 6 weeks 6 hours 6 hours > 6 weeks ≤ 9 weeks 12 hours 12 hours > 63 days 3 days 3 days When the start time for a requested time range is older than eight days, data has been aggregated or averaged to one hour periods due to the data aggregation schedule. This means that for any one hour period, only a single data value is available. Obtaining data at less than an hourly period in the time range would cause oversampling, resulting in duplicate values being returned. Returning only ten values prevents oversampling and presents a smoother chart, which eliminates a possibly misleading \"plateau\" effect. Controlling time period output Sometimes the output data's granularity may be too fine, or the time period for the data returned may be too short. To control this, include the period= parameter in the query command as the number of seconds you want each time period to report. Make sure your specifications follow New Relic's data aggregation schedules. Example #1: Following New Relic's table summarizing granularity of collected data, the following API call would normally return data in 30-minute periods, since the request is for 4 days (from=2018-02-13 and to=2018-02-17). By adding period=3600, the data will be returned as 60-minute periods. curl -X GET 'https://api.newrelic.com/v2/applications/$APPID/metrics/data.xml' \\ -H 'Api-Key:$API_KEY' -i \\ -d'names[]=CPU/User+Time&from=2018-02-13T04:00:00+00:00&to=2018-02-17T04:00:00+00:00&period=3600' Copy You cannot specify a period smaller than the default for the time range you are requesting. For example: In the command example above, you can request 1-hour periods, since that is greater than the default (half hour) granularity for the time range. In the command example above, you cannot request 1-minute periods, since that is less than the default (half hour) granularity for the time range. Example #2: If you request a range > 7 days but ≤ 3 weeks, where the default period is 3 hours, you can specify periods such as 6, 12, or 24 hours. However, you cannot request 1-hour periods, because that is less than the default (3 hours). Data retention How long data is available depends on the data retention for specific types of data. Extracting non-existent metric timeslice data Situations may arise where non-existent metric names are requested. For example: The metric timeslice data has not been created for one application, but exists for another. When the same metric extraction query is used on both of these applications, it will not be located for one. The metric name was incorrectly specified. Important Metric values that have existed in the past, but are no longer collected, will return a zero value. A successful response will include a 200 status code and metadata about the request. The metadata will contain the names of the metrics requested and the status of the request for those names. Response Metadata Description Response Metric Data metrics_not_found Lists all metric names for which matching data was not found in the requested time period. Metric timeslice data will not be returned for these metrics metrics_found Lists all metric names for which matching data was found in the requested time period. Metric timeslice data will be returned for these metrics Here is an example of output for a valid metric name, HttpDispatcher. HTTP/1.1 200 OK etag: \"0dc87c63d8dff6b1a9714bdf7531ec09\" Content-Type: application/json cache-control: max-age=0, private, must-revalidate {   \"metric_data\": {     \"from\": \"2016-01-28T18:06:06+00:00\",     \"to\": \"2016-01-28T18:36:06+00:00\",     \"metrics_not_found\": [], <---<<< INDICATES NO INVALID METRIC NAMES REQUESTED     \"metrics_found\": [       \"HttpDispatcher\" <---<<< INDICATES THIS METRIC NAME WAS VALID     ],     \"metrics\": [ <---<<< DATA RETURNED       {         \"name\": \"HttpDispatcher\",         \"timeslices\": [           {             \"from\": \"2016-01-28T18:03:00+00:00\",             \"to\": \"2016-01-28T18:04:00+00:00\",             \"values\": {               \"average_response_time\": 364,               \"calls_per_minute\": 99800,               \"call_count\": 99770,               \"min_response_time\": 3.5,               \"max_response_time\": 85000,               \"average_exclusive_time\": 0,               \"average_value\": 0.364,               \"total_call_time_per_minute\": 36300,               \"requests_per_minute\": 99800,               \"standard_deviation\": 1900,               \"average_call_time\": 364 ... Copy Here is an example of output for a invalid metric name, Foo. HTTP/1.1 200 OK etag: \"e51782cf7c5a5596139a7f5340c3de23\" Content-Type: application/json cache-control: max-age=0, private, must-revalidate {   \"metric_data\": {     \"from\": \"2016-01-28T18:06:33+00:00\",     \"to\": \"2016-01-28T18:36:33+00:00\",     \"metrics_not_found\": [       \"Foo\" <---<<< INDICATES THIS METRIC NAME WAS INVALID     ],     \"metrics_found\": [], <---<<< INDICATES NO VALID METRIC NAMES FOUND     \"metrics\": [] <---<<< NO DATA RETURNED   } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1178.8671,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Extract <em>metric</em> <em>timeslice</em> <em>data</em>",
        "sections": "Extract <em>metric</em> <em>timeslice</em> <em>data</em>",
        "body": "One type of New Relic <em>data</em> is <em>metric</em> <em>timeslice</em> <em>data</em>. There are several ways to <em>query</em> <em>metric</em> <em>timeslice</em> <em>data</em>: You can <em>query</em> <em>APM</em> <em>metric</em> <em>timeslice</em> <em>data</em> via <em>NRQL</em> (and therefore via our NerdGraph API). You can <em>query</em> any <em>metric</em> <em>timeslice</em> <em>data</em> via the REST API This doc explains how to do this with the REST"
      },
      "id": "60440691e7b9d201b8579a00"
    },
    {
      "sections": [
        "New Relic data types",
        "Get started",
        "Tip",
        "Metrics",
        "Metrics in the monitoring industry",
        "Metrics at New Relic",
        "Dimensional metrics (used by Metric API and many integrations)",
        "Metric timeslice data (used by APM, browser, mobile)",
        "Metric timeslice examples",
        "Metrics attached to events (used by Infrastructure, other products)",
        "Metrics as a computation of events (used in some charts and queries)",
        "Event data",
        "Events in the monitoring industry",
        "Events at New Relic",
        "Log data",
        "Logs in the monitoring industry",
        "Logs at New Relic",
        "Trace data",
        "Tracing in the monitoring industry",
        "Tracing at New Relic",
        "Query and send data",
        "Learn more"
      ],
      "title": "New Relic data types",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Understand data"
      ],
      "external_id": "8e4ab82bb58db47bc412f57231d4956c6068262b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/understand-data/new-relic-data-types/",
      "published_at": "2021-10-24T21:27:50Z",
      "updated_at": "2021-10-23T17:27:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic platform is built around the four fundamental telemetry data types we believe are necessary for complete and effective system monitoring: metrics, events, logs, and traces. Get started This doc will give you a fairly technical explanation of our core data types, their structure, and how they're used in our features. You can use most of our features without needing to understand the underlying data structure. But having a better understanding of this can help you get data into New Relic, understand the data you see in our UI, and query your data. For a simpler explanation of these data types using real-world examples, see Introduction to essential telemetry data types. Another good way to understand your data is to just start querying it. Tip Access your data easily on one.newrelic.com: Click the Browse data dropdown menu and select the data type (metrics, events, logs, and traces) you want to explore. Metrics First, we’ll explain the definition of metrics from a monitoring industry perspective, and then we’ll explain how New Relic handles metrics. For a list of the metrics we collect, see our documentation on metrics. Metrics in the monitoring industry In the software monitoring industry, a metric means a numeric measurement of an application or system. Metrics are typically reported on a regular schedule. Two major types of metrics are: Aggregated data. For example: a count of events over one minute’s time, or the rate of some event per minute. A numeric status at a moment in time. For example: a CPU temperature reading, or a “CPU% used” status. Metrics are relatively easy to report and store because a single record can represent a range of time. They can also be aggregated more and more over time. For example, per-minute data may be “rolled up” to per-hour aggregations after some amount of time, and eventually may be rolled up to a per-day aggregation. This approach is efficient for long-term data storage. Metrics are a strong solution for storing data long-term, and understanding trends over time. One potential downside is that it can be difficult to do detailed analysis of older data that has been aggregated over time; when high detail is required about specific important actions, event data can be used. Metrics at New Relic Conceptually, \"metrics\" is a broad, general category. There are various ways New Relic measures and reports metrics but, in practice, when using the New Relic UI, you usually won't have to understand how exactly this happens. In our documentation, we typically will just refer to \"metrics,\" regardless of how that data is reported, unless there's a reason you need to know more (like understanding how to query your data). Here are some of the ways metrics are reported and stored across the New Relic platform: Dimensional metrics (used by Metric API and many integrations) In the monitoring industry, \"dimensional\" metrics refer to metric data that has a variety of attributes (dimensions) attached, such as duration-related attributes (start time, end time), entity ID, region, host, etc. This amount of detail allows for in-depth analysis and querying. At New Relic, this metric data is attached to the Metric data type and is sent from several sources: Some open-source integrations, like our Prometheus and OpenCensus exporters Our Telemetry SDKs Infrastructure services The Metric API (the underlying API used by the above tools) The events-to-metrics service To query this data and see its attributes (\"dimensions\"), you could use a NRQL query like: Select * from Metric Copy As time passes, these metrics are increasingly aggregated into larger time buckets. This is done to optimize your ability to query data over a long period of time. For more details about the metric data type, see our docs. To learn how this data is ingested and stored, see the Metric API documentation. For tips on querying, see Metric query examples. Metric timeslice data (used by APM, browser, mobile) New Relic's APM, browser, and mobile report and display metrics in a simple data format that we refer to as metric timeslice data. A metric timeslice consists of three parts: a metric name, the segment of time the metric represents (the \"timeslice\"), and a numeric value (the measurement). For example: an APM metric timeslice for time spent in a particular transaction is named WebTransaction/URI/foo, and might have a response time of 0.793 for a one-minute time slice from 10:20am to 10:21am. These metrics usually follow a pattern like <category>/<class>/<method>. Our agents (APM, browser, and mobile) can collect thousands of metric timeslices per minute for a variety of performance metrics. For example: error rate, bandwidth usage, and garbage collection time. You also have the ability to create custom metrics. Metric timeslice data is a lightweight data type and lacks the detail that dimensional metrics have. Ways to explore and query metric timeslice data: For APM: metric timeslice data is converted to dimensional metrics and can be queried via NRQL Use the REST API If you want to learn more about the structure of metric timeslice data and see some examples, expand the collapser below. Metric timeslice examples Here are some common metric timeslice data examples, with a focus on common ones used by Ruby applications. ActiveMerchant New Relic tracks a variety of metrics on ActiveMerchant transactions which can be used for business analytics as well as performance monitoring. The metrics are summarized by operation as well as by gateway. regex sample metric legend name ActiveMerchant/. * ActiveMerchant/PayJunctionGateway ActiveMerchant/gateway/. * ActiveMerchant/gateway/PayJunctionGateway/purchase PayJunctionGateway ActiveMerchant/operation/. * ActiveMerchant/operation/purchase purchase For more information, see the ActiveMerchant website. ActiveRecord ActiveRecord is the Object-Relational Mapping API used by Ruby on Rails applications. The metrics shown here measure the performance of ActiveRecord's find and save methods. regex sample metric legend name ActiveRecord/. * /find ActiveRecord/User/find User#find ActiveRecord/. * /save ActiveRecord/Product/save Product#save For more information, see the API documentation for ActiveRecord. Apdex Apdex is a measure of user satisfaction with page load times. Controller In Ruby on Rails applications, HTTP requests are handled by Controller actions. A Rails application has many controllers, each of which has one or more actions. When your rails application receives an http request, that request is routed to the appropriate controller and action, based on the URL of that request. That action then does whatever processing is neccesary to generate an http response, which is most often a web page, but could also be a page fragment, an xml document, or any other kind of data that is requested by the client. The following metrics track the performance of controller actions, regardless of routing, and without taking into account any network or web server effects. regex sample metric legend name Controller/. * Controller/Users/show /Users/show Controller/. * /(?! \\ (other \\ )). * Controller/Users/show /Users/show Controller$ Controller All Controller Actions ControllerCPU/ ControllerCPU/Users/Show /Users/show For more information, see the API documentation for ActionController. Errors This metric tracks the number of errors or exceptions raised while processing requests. regex sample metric legend name Errors/all Errors/all External services External service instrumentation captures calls to out-of-process services such as web services, resources in the cloud and any other network calls. It does not include other first class back-end components such as MemCache and the database. In Ruby applications we instrument the Net::Http library to capture all HTTP services. regex sample metric legend name External/ [ ^/]+/all$ External/service.example.com/all All service.example.com calls External/ External/host.aws.com/Net::Http : :POST Net::Http : :POST [ host.aws.com] External/all$ External/all External Services External/ [ ^/]+/(?!all)/ External/service.example.com/all All service.example.com calls HTTP dispatcher This metric represents a summary of the throughput and response time of all web requests. regex sample metric legend name ^HttpDispatcher$ HttpDispatcher HttpDispatcher MemCache MemCache is a popular technology that enables applications to access shared memory provided by any number of physical machines as a global cache. Applications that heavily use the database often use MemCache for performance and scalability benefits. These metrics measure the frequency and response time of calls to MemCache to read and write data from the cache. Response times should be low (less than 5 ms) for a well performing MemCache deployment. regex sample metric legend name MemCache/. * MemCache/read MemCache read operations MemCache/read MemCache/read MemCache read operations MemCache/write MemCache/write MemCache write operations Mongrel This metric measures the length of the mongrel queue, which holds pending http requests to be processed by mongrel. The HTTP Activity graph overlays the maximimum queue length for a given period. The value is zero if mongrel is processing a request but has no other requests waiting in its queue. When looking at this value across an aggregate cluster of mongrels, the queue lengths of all mongrels is added together, showing the sum of all queue lengths. A mongrel queue length should be at or near zero; if it is consistently at a higher level, then it indicates that your rails application is having trouble keeping up with its load requirements. regex sample metric legend name Mongrel/Queue Length Mongrel/Queue Length Queue Length View ActionView is a package in Rails that is used to render the output that is the response to an http request, such as an html page or an xml document. The View is rendered by the controller that is handling the request. If View metrics represent a large portion of your controller's response time, it could mean you are doing a lot of database operations inside the view template itself. regex sample metric legend name View/. * View/Users/ _ child.html.erb/Partial Users/ _ child.html.erb View/. * /Partial View/Users/ _ child.html.erb/Partial Users/ _ child.html.erb View/. * /Rendering View/Users/show.html.erb/Rendering Users/show.html.erb For more information, see the API documentation for ActionView. Metrics attached to events (used by Infrastructure, other products) Because event-type data can have any type of key-value pair data attached to it, one way metrics can be reported is as attributes attached to an event. A couple examples of this at New Relic: Our infrastructure monitoring reports many metrics that are attached to events. For example, we report a ProcessSample event, which has various sample-based metrics attached to it, like CPU percentage. To learn more about infrastructure monitoring data, see Infrastructure data. In APM, the Transaction event has several metrics attached to it, including databaseDuration. To learn more about this data and how to query it, see Events. Metrics as a computation of events (used in some charts and queries) Metrics can be formed by counting New Relic events, or doing some other mathematical calculation on those events. For example, if you wanted to measure the total number of Transaction events over the last half hour, you might run this NRQL query: Select count(*) from Transaction since 30 minutes ago Copy Another example: if you wanted to compute the average response time for your service, you might run a query like: FROM Transaction SELECT average(duration) SINCE 30 minutes ago Copy Some New Relic charts are generated with these kinds of queries. The downside of this approach is that there are limits on how many events a monitoring system (including ours) can report. This means that sometimes, for high-throughput systems, the count may not accurately represent the total activity on that system. To learn more about how this can be addressed, see Event limits and sampling. Want to report custom metrics? See Get data into New Relic. Event data First, we’ll explain the definition of events from a monitoring industry perspective, and then we’ll explain some specifics about how New Relic handles event data. Events in the monitoring industry In the software industry, events can be thought of as simply “things that occur in a system.” For example, a server setting being changed would be an event. Another example: a website user clicking a mouse. Some events will generate a stored record, and that record is typically also called an event. Event data represents discrete occurrences and typically will have a high level of detail, so event data is suited for detailed analysis and querying. The downside to the use of event data is that there are typically so many events reported that it can become difficult to query that large dataset over longer time ranges. Events at New Relic At New Relic, we report events to data objects also called events. These events have multiple attributes (key-value pairs) attached. Event data is used in some UI charts and tables, and you can also query it. How long event data remains available is determined by data retention rules. One example of an event: APM reports an event type named Transaction, which represents a logical unit of work in an application. To see the attributes attached to this event, you could use a NRQL query like: Select * from Transaction Copy For examples of querying event data, see Introduction to NRQL. Other details about New Relic event data: Events can have any type of attributes attached. Some events have attributes that report metric data. You can report custom events. To increase the availability of your event data for querying/charting, you can turn events into metrics. Some systems generate a large number of events that exceeds collection limits and results in incomplete query results. For more on this, see Event sampling. Because event is a general term, in some New Relic contexts it will refer to any data type that can be queried via NRQL. For example, when you run a NRQL query, it returns a count of inspected events: this is a count of all data types queried. Log data First, we’ll explain the definition of logs from a monitoring industry perspective, and then we’ll explain some specifics about how New Relic handles log reporting. Logs in the monitoring industry A log is a message about a system used to understand the activity of the system and to diagnose problems. Logs at New Relic New Relic's Logs gives you a centralized log management platform that connects your log data with other New Relic-monitored data. For example, you can see logs alongside your APM data. In New Relic, log data is reported with multiple attributes (key-value data) attached. To query your log data, you could use a NRQL query like: Select * from Log Copy To report custom log data, see the Log API. Trace data First, we’ll explain the definition of traces from a monitoring industry perspective, and then we’ll explain some specifics about how New Relic handles tracing. Tracing in the monitoring industry In the application/infrastructure-monitoring world, tracing is a general term used to refer to various ways to report information about how a program or system is operating. For example, a stack trace provides in-depth information about a program’s subroutines. For large modern systems, which are often distributed across many services and micro-services, “tracing” often refers to distributed tracing, which is a way to monitor requests as they propagate through a complex, distributed environment. Tracing at New Relic New Relic offers a distributed tracing feature that tracks requests across a distributed system, and provides a dedicated UI for understanding and analyzing your traces. In New Relic, trace data is reported as Span objects, with multiple attributes (key-value pairs) attached. To query your tracing data, you could use a NRQL query like: Select * from Span Copy To learn more about how distributed tracing works, see Understand distributed tracing. To report custom distributed tracing data, see the Trace API. Query and send data Understanding New Relic data types can help you: Query data in New Relic Send data to New Relic Learn more For a simpler explanation of these data types using real-world examples, see Introduction to essential telemetry data types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.15604,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic <em>data</em> types",
        "sections": "<em>Metric</em> <em>timeslice</em> <em>data</em> (used by <em>APM</em>, browser, mobile)",
        "tags": "Ingest and manage <em>data</em>",
        "body": ". <em>Metric</em> <em>timeslice</em> <em>data</em> is a lightweight <em>data</em> type and lacks the detail that dimensional metrics have. Ways to explore and <em>query</em> <em>metric</em> <em>timeslice</em> <em>data</em>: For <em>APM</em>: <em>metric</em> <em>timeslice</em> <em>data</em> is converted to dimensional metrics and can be queried via <em>NRQL</em> Use the REST API If you want to learn more about"
      },
      "id": "6045280de7b9d266e1579a0f"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/understand-data/metric-data/query-metric-data-type/",
      "sections": [
        "Query the Metric data type",
        "Query APM metric timeslice data",
        "View and query your metrics",
        "View example metric queries",
        "Chart multiple metrics",
        "Perform mathematical operations on metric data",
        "Use filters to select specific time series",
        "View the raw metric data points",
        "Query multiple metrics with wildcards",
        "Chart multiple metrics with wildcards",
        "Perform mathematical operations on metric data with wildcards",
        "Return results for invidual fields using getField()",
        "List of gauge metrics",
        "List all metric names for a particular host",
        "Explore metric data",
        "List all metric names in an account",
        "Show the attribute keys for a specific metric"
      ],
      "published_at": "2021-10-24T20:20:56Z",
      "title": "Query the Metric data type",
      "updated_at": "2021-10-23T17:29:27Z",
      "type": "docs",
      "external_id": "60ee492db79e59620ac1346f86d5273acd997efd",
      "document_type": "page",
      "popularity": 1,
      "body": "When metrics are reported to New Relic via the Metric API (including from integrations that use that API), the data is reported as the Metric data type and is available for querying. This document contains: How to view and query your metrics Example metric queries How to query multiple metrics with wildcards How to explore metric data Query APM metric timeslice data APM reports a specific type of data that we call metric timeslice data. For how to query that, see Query metric timeslice data. For information about other types of metrics, see Metric data types. View and query your metrics You can use NRQL to query your metric data in the New Relic One query builder or using our NerdGraph API. To query a metric, use the following query format: FROM Metric SELECT function(metric_name) WHERE attribute=value FACET attribute TIMESERIES Copy Below are the functions supported for each metric type: Metric type Supported functions Summary count, sum, min, max, and average Count sum Gauge count, sum, min, max, average, and latest Add the names of the metrics you want to chart with the appropriate value functions in the SELECT clause. The WHERE and FACET clauses can be used with attribute values. Remember to include the keyword TIMESERIES if you want to chart the data. This example demonstrates how you could chart the CPU usage in seconds for cluster foo . This query breaks down CPU usage by container, given a count metric named container_cpu_usage_seconds_total with the attributes containerName and clusterName: FROM Metric select sum(container_cpu_usage_seconds_total) WHERE clusterName = 'foo' FACET containerName TIMESERIES Copy If you want the CPU usage per minute (the rate of change), then you can add the rate function to the query above. FROM Metric select rate(sum(container_cpu_usage_seconds_total), 1 minute) WHERE clusterName = 'foo' FACET containerName TIMESERIES Copy View example metric queries The previous examples demonstrate basic forms of metric queries, but NRQL can also be used to chart, explore, and analyze metric data. Chart multiple metrics Chart multiple metrics using a single query by providing a comma-separated list of metrics in the SELECT clause. For example, to chart the memory usage for a container along with the memory limit metric, use the following query: FROM Metric SELECT latest(container_memory_usage_bytes), latest(container_spec_memory_limit_bytes) WHERE containerName = 'inventory' TIMESERIES Copy You can also do this using wildcards, as explained below. Perform mathematical operations on metric data Perform math operations on one or more metrics to compute a new, derived metric. To monitor available memory, you can calculate the percentage of available memory from the two metrics used in the previous example: FROM Metric SELECT (latest(container_spec_memory_limit_bytes) - latest(container_memory_usage_bytes)) / latest(container_spec_memory_limit_bytes) * 100 AS '% Memory Available' WHERE containerName = 'inventory' TIMESERIES Copy You can also do this using wildcards, as explained below. Use filters to select specific time series In addition to using a WHERE clause which applies to everything in SELECT, NRQL provides another aggregation function called filter which can be used to select a specific time series to be charted or operated on. The following example charts a memory usage metric labeled \"Total (k8s)\" which is computed by adding together the memory usage of two specific containers within a pod: FROM Metric SELECT filter( latest( container_memory_usage_bytes), WHERE containerName = 'discovery') + filter( latest( container_memory_usage_bytes), WHERE containerName = 'istio-proxy') AS 'Total (k8s)' WHERE clusterName = 'my-cluster' AND podName LIKE 'istio-pilot-%' TIMESERIES Copy View the raw metric data points When querying metric data using FROM Metric, New Relic automatically selects the specific aggregate to use in the query, depending on the length of the query window and any bucket size specified as an argument to the TIMESERIES keyword. This ensures efficient querying and chart resolution. If you want to override this behavior to view or operate on the raw metric data points, use the optional RAW keyword in your query. When querying these raw metric data points, there is a query time window limit of 48 hours. Any query attempting to access more than 48 hours of raw metric data will result in a query error. This example shows how to list the last 20 data points received for a particular metric: FROM Metric SELECT * WHERE metricName = 'container_fs_usage_bytes' LIMIT 20 RAW Copy Query multiple metrics with wildcards Wildcards are represented in NRQL by the % character. If you want to query multiple metrics that use a standard naming convention, you can use the wildcard feature to return results for all of them without having to specify each metric name individually. Wildcards can help you: Aggregate metrics together and chart the results FACET results by metric name in a chart Find and chart all metrics matching a given naming convention Wildcards are particularly helpful if you later add new metrics matching an existing naming convention. By using % instead of writing out each metric name in your query, you won't have to rewrite the query when you add new metrics. Let's say you have multiple algorithms that perform a similar task. You can define the following metrics, which show the duration of the different algorithms: myNeatProcess.algorithm1.duration myNeatProcess.algorithm2.duration myNeatProcess.algorithm3.duration If used in a query, myNeatProcess.%.duration will return results for all three of the algorithms above. If you later create new algorithms named algorithm4, algorithm5, and algorithm6, the same query will return results for all six algorithms. Chart multiple metrics with wildcards You can chart multiple metrics using a single query by using wildcards (%) in the SELECT clause. For example, to query all the algorithms in the example above and plot a line on the chart for each algorithm's average duration, use the following query: FROM Metric SELECT average(myNeatProcess.%.duration) FACET metricName TIMESERIES Copy Perform mathematical operations on metric data with wildcards You can also use wildcards to perform math operations on multiple metrics and compute a new metric. You can calculate the mean duration for all algorithms listed in the example above: FROM Metric SELECT average(myNeatProcess.%.duration) TIMESERIES Copy You can calculate what percentage of overall runtime a single algorithm takes: FROM Metric SELECT myNeatProcess.algorithm1.duration / sum(myNeatProcess.%.duration) TIMESERIES Copy Return results for invidual fields using getField() Metrics have multiple fields associated with them, and each field contains its own unique values. If you would like to extract one of those values using a query, you can do that with getField(). For example, if you want to use a single value within a metric to do a comparison in a WHERE clause, you can use getField(metricName, field) or metricName[field]. List of gauge metrics This example query returns a list of gauge metrics: FROM Metric SELECT uniques(metricName) WHERE %[type] = 'gauge' Copy List all metric names for a particular host The average value of a metric is computed as total over count, so the following query returns metric data where the result of the average() value function is greater than 2. FROM Metric SELECT average(apm.service.transaction.duration) WHERE appName = 'MyApp' AND apm.service.transaction.duration[total] / apm.service.transaction.duration[count] > 2 Copy Explore metric data The NRQL keyset and uniques functions can be used together with the metricName attribute (available on all metrics) to perform tasks like listing all the available metrics in your account or discovering the attributes available on a particular metric. List all metric names in an account FROM Metric SELECT uniques(metricName) Copy List all metric names for a particular host FROM Metric SELECT uniques(metricName) WHERE hostname = 'host1.mycompany.com' Copy Show the attribute keys for a specific metric FROM Metric SELECT keyset() WHERE metricName = METRIC_NAME Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.12802,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Query</em> the <em>Metric</em> <em>data</em> type",
        "sections": "<em>Query</em> <em>APM</em> <em>metric</em> <em>timeslice</em> <em>data</em>",
        "body": " with wildcards How to explore <em>metric</em> <em>data</em> <em>Query</em> <em>APM</em> <em>metric</em> <em>timeslice</em> <em>data</em> <em>APM</em> reports a specific type of <em>data</em> that we call <em>metric</em> <em>timeslice</em> <em>data</em>. For how to <em>query</em> that, see <em>Query</em> <em>metric</em> <em>timeslice</em> <em>data</em>. For information about other types of metrics, see <em>Metric</em> <em>data</em> types. View and <em>query</em> your metrics You"
      },
      "id": "60a8eb54e7b9d23e1aaeabc1"
    }
  ],
  "/docs/data-apis/understand-data/metric-data/query-metric-data-type": [
    {
      "sections": [
        "StatsD monitoring integration",
        "Requirements",
        "Install",
        "Install for Kubernetes",
        "Kubernetes manifest examples",
        "Configure",
        "Tip",
        "Example of custom configuration",
        "Docker: overwrite default configuration",
        "Kubernetes: overwrite default configuration",
        "Metric format",
        "Metric types",
        "Counter",
        "Gauge",
        "Timer",
        "Add tags (attributes)",
        "Add default tags that apply to all metrics",
        "Add metric-level tags",
        "Create alerts",
        "Alert example",
        "Find and use data",
        "Check the source code"
      ],
      "title": "StatsD monitoring integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "On-host integrations",
        "On-host integrations list"
      ],
      "external_id": "48ab117ae50533224877d767224d85edd939db42",
      "image": "https://docs.newrelic.com/static/9c86375ad0ec12433df78b2116819aab/c1b63/statsd-nrql-alert-condition-example.png",
      "url": "https://docs.newrelic.com/docs/infrastructure/host-integrations/host-integrations-list/statsd-monitoring-integration-version-2/",
      "published_at": "2021-10-24T21:10:05Z",
      "updated_at": "2021-10-24T00:56:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our StatsD integration lets you easily get StatsD-format data into New Relic. You can also add any arbitrary tags (key-value pairs) to your data. Once your metrics are in New Relic, you can query your data and create custom charts and dashboards. Want to try out our StatsD integration? Create a New Relic account for free! No credit card required. Requirements This integration uses our Metric API and our Event API to ingest data. To use these APIs, you'll need a license key. The integration adheres to the Metric API requirements and data limits. The default rate limit is 100,000 data points per minute (DPM). If you think you're missing metrics or sending more than 100K DPM, see Request data changes. To see if your account is hitting the rate limit, run the following NRQL query of the NrIntegrationError event: SELECT count(*) FROM NrIntegrationError WHERE newRelicFeature ='Metrics' FACET category, message LIMIT 100 since 1 day ago Copy Install This section will explain how to do a standard install. If you want to run StatsD in Kubernetes, see Kubernetes install. To install the StatsD integration, run the following command and include your New Relic account ID and New Relic license key. This generates a TOML configuration file used by gostatsd. docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=NEW_RELIC_LICENSE_KEY \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 Copy If your account is in the EU data center region, add this to the above command: -e NR_EU_REGION=true \\ Copy After installing, you can: Do optional additional configuration Define your metrics Add custom tags to your data Create alerts Install for Kubernetes Here are examples of Kubernetes manifests for deployment and service objects: Kubernetes manifest examples Below are examples of Kubernetes manifests to deploy StatsD in a Kubernetes environment and create a StatsD service named newrelic-statsd. You need to insert your account ID and your license key. deployment.yml: apiVersion: apps/v1 kind: Deployment metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: selector: matchLabels: app: newrelic-statsd replicas: 2 revisionHistoryLimit: 2 template: metadata: labels: app: newrelic-statsd spec: containers: - name: newrelic-statsd image: newrelic/nri-statsd:2.0.0 env: - name: NR_ACCOUNT_ID value: \"NEW_RELIC_ACCOUNT_ID\" - name: NR_API_KEY value: \"NEW_RELIC_LICENSE_KEY\" Copy service.yml: apiVersion: v1 kind: Service metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: type: ClusterIP ports: - name: newrelic-statsd port: 80 targetPort: 8125 protocol: UDP selector: app: newrelic-statsd Copy For configuration details, see Kubernetes configuration. Configure In the install procedure, you run nri-statsd with environment variables, and this generates a TOML configuration file. Additionally, you can set these configuration options: Configuration options Description expiry-interval string If a metric is not updated for this amount of time, we stop reporting that metric. Default is 5m. If you want to send the metrics only if the value was updated between the flush intervals, configure this to 1ms. To never expire metrics, set it to 0. percent-threshold list of integers Specifies the percentiles used for metrics aggregation. Default: 90. metrics-addr string Indicates address on which to listen for metrics. Default: :8125. Tip To ensure FedRAMP compliance when using the StatsD integration you must define the following endpoints in the custom configuration: address = 'https://gov-insights-collector.newrelic.com/v1/accounts/ $NR_ACCOUNT_ID/events' Copy address-metrics = 'https://gov-infra-api.newrelic.com/metric/v1' Copy Here are some examples of customizing configuration by overwriting the default configuration: Example of custom configuration # Specify after how long do we expire metrics, default:5m expiry-interval = '1ms' # percent-threshold specify a list of percentiles for metrics aggregation, default:90 percent-threshold = [90, 99] backends='newrelic' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://insights-collector.newrelic.com/v1/accounts/$NR_ACCOUNT_ID/events' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_LICENSE_KEY' Copy Disable timer sub-metrics: By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. If you want to disable those metrics you can do it by adding a disabled-sub-metrics configuration section and set true for the ones you want disabled. Here's an example: # disabled-sub-metrics configuration section allows disabling timer sub-metrics [disabled-sub-metrics] # Regular metrics count=false count-per-second=false mean=false median=false lower=false upper=false stddev=false sum=false sum-squares=false # Percentile metrics count-pct=false mean-pct=false sum-pct=false sum-squares-pct=false lower-pct=false upper-pct=false Copy Docker: overwrite default configuration To overwrite the default nri-statsd configuration while running in a container, you can mount a configuration file inside the container. You can adopt the following template as needed for your situation. Example: backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_LICENSE_KEY' Copy To run the container with the file mounted in the appropriate path: docker run \\ ... -v ${PWD}/nri-statsd.toml:/etc/opt/newrelic/nri-statsd.toml \\ ... newrelic/nri-statsd:2.0.0 Copy Kubernetes: overwrite default configuration The best approach to configure nri-statsd running in Kubernetes is to use a configMap and mount the configMap into the container. (This is a similar process to mounting the configuration file in Docker.) Example: apiVersion: v1 kind: ConfigMap metadata: name: nri-statsd-config namespace: default data: nri-statsd.toml: | backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://metric-api.newrelic.com/metric/v1' api-key = '$NEW_RELIC_LICENSE_KEY' Copy To use the configMap, declare a volume on your deployment spec template and then declare a volumeMount on your container spec. Example: apiVersion: apps/v1 kind: Deployment spec: template: spec: containers: .... volumeMounts: - mountPath: /etc/opt/newrelic/ name: nri-statsd-config volumes: - name: nri-statsd-config configMap: name: nri-statsd-config Copy Metric format The integration receives metrics using the StatsD protocol. Optionally, the sample rate can be configured and tags can be added. Here's the metric data format we use: <metric name>:<value>|<type>|@<sample rate>|#<tags> Copy Here are explanations of these fields: Field name Description < metric name> string Required. Name of the metric. < value> string Required. The metric type: c = counter g = gauge ms = timer @ < sample rate> float Optional for simple counters or timer counters. When many metrics must be sent, you can use sampling to reduce network traffic. The downside is a reduction in the resolution of the data. An example of how this would work for sample rates below 1: If you set this to 0.1, the counter would send a measurement one out of every 10 times. # < tags> string Optional. Tags attached to your metrics are converted into attributes (key-value pairs). For more on tagging options, see Tags. Metric types Here are the types of metrics and how to format them: Counter A counter measures the number of occurrences of an event. Examples include cache hits per reporting interval and the number of threads created per reporting interval. A counter can be incremented or decremented during the same flush interval by adding a sign to the value. In the following example, the counter value will be 2: counter:4|c counter:-2|c Copy At each flush, the current count is sent and reset to 0. If the count is not updated, at the next flush it will send the value 0. You can opt to disable this behavior by setting expiry-interval to 1ms. Here’s an example of a counter that is being sampled 1 out of 10 times: counter:4|c@0.1 Copy Gauge A gauge represents a value that can increase or decrease with time. Examples of gauges include temperature, CPU usage, and memory. Here's an example: temperature:40|g Copy If the gauge is not updated, at the next flush it will send the previous value. You can opt to disable this behavior by setting expiry-interval to 1ms. Timer The timer metric type measures timing data. By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. These are sent as sub-metrics in the following format: <metric_base_name>.std_dev <metric_base_name>.median <metric_base_name>.summary <metric_base_name>.sum_squares <metric_base_name>.mean <metric_base_name>.per_second Copy The configured percentiles will generate the following metrics. The percentile threshold value will be attached as a tag. <metric_base_name>.sum_squares.percentiles <metric_base_name>.sum.percentiles <metric_base_name>.count.percentiles <metric_base_name>.upper.percentiles <metric_base_name>.mean.percentiles Copy The percentile threshold can be tweaked with the percent-threshold config option. These can be controlled through the disabled-sub-metrics configuration section. Add tags (attributes) You can add tags to your data, which we save as attributes (key-value pairs). There are two options for adding tags: Add default tags that apply to all metrics: These apply to all metrics. They are fixed and don't change over time. Add metric-level tags: These apply to specific metrics and allow the value to be changed between two submits. Add default tags that apply to all metrics Add tags to metrics and events by defining an environment variable in the startup command. Here's an example that would create two tags: -e TAGS=\"environment:production region:us\" Copy Here's that environment variable used in the startup command: docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=NEW_RELIC_LICENSE_KEY \\ -e TAGS=\"environment:production region:us\" \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 Copy Add metric-level tags When defining the metric format, you can add tags using this format: <bucket name>:<value>|<type>|#<tags> Copy In this example, <tags> is a comma-separated list of tags. Tags format is: simple or key:value. Here's an example NRQL query that includes a custom tag: SELECT count(*) FROM Metric WHERE environment = 'production' Copy Create alerts You can alert on StatsD data using NRQL alert conditions. Alert example This procedure walks you through sending some sample data and then creating an alert condition using that data. First, send this data to New Relic’s StatsD container: echo \"prod.test.num:32|g\" | nc -v -w 1 -u localhost 8125 Copy Next, create a NRQL alert condition using this query: SELECT latest(prod.test.num) FROM Metric WHERE metricName = 'prod.test.num' Copy Here's an image showing creating this NRQL alert condition. Notice that the sample data sent in is represented by the blue dot on the upper right of the chart. Now we can create the alert condition with these settings: When you create the NRQL alert condition, be sure to set the Condition name. If a metric with a value above 50 is sent, then an incident is created and notified. The incident is closed automatically after 24 hours. To test that the alert is working, run this command: echo \"prod.test.num:60|g\" | nc -v -w 1 -u localhost 8125 Copy Find and use data To query your data, you'd use any New Relic query option. For example, you might run a NRQL query like: SELECT count(*) FROM Metric WHERE metricName = 'myMetric' and environment = 'production' Copy For more on how to query the Metric data type, see Query metric data. Check the source code This integration is open source software. That means you can browse its source code and send improvements, or create your own fork and build it.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 694.046,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Metric</em> <em>types</em>",
        "body": " <em>query</em> option. For example, you might run a NRQL <em>query</em> like: SELECT count(*) FROM <em>Metric</em> WHERE <em>metric</em>Name = &#x27;my<em>Metric</em>&#x27; and environment = &#x27;production&#x27; Copy For more on how to <em>query</em> the <em>Metric</em> <em>data</em> <em>type</em>, see <em>Query</em> <em>metric</em> <em>data</em>. Check the source code This integration is open source software. That means you can browse its source code and send improvements, or create your own fork and build it."
      },
      "id": "6174af22e7b9d253c613b73d"
    },
    {
      "sections": [
        "Analyze and monitor data trends with metrics",
        "Why create metrics from other data types?",
        "Available operations",
        "Mutations",
        "Create a rule",
        "Delete a rule",
        "Important",
        "Enable or disable a rule",
        "Queries",
        "List all rules for a New Relic account",
        "List rule by rule ID",
        "Use the NerdGraph GraphiQL API tool"
      ],
      "title": "Analyze and monitor data trends with metrics",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Convert data to metrics"
      ],
      "external_id": "06073bcfec2679ac1bc402dfe305426bbd9e2182",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/convert-to-metrics/analyze-monitor-data-trends-metrics/",
      "published_at": "2021-10-24T23:24:43Z",
      "updated_at": "2021-10-23T17:28:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can generate metric-type data from other types of data in New Relic, including events, logs, and spans. Metrics are aggregates of your data and are optimal for analyzing and monitoring trends over long time periods. This document explains: Reasons to use this feature Available operations How to use our NerdGraph API tool to perform operations Why create metrics from other data types? Using metrics allows for more efficient data storage. This in turn allows you to query your data and build charts more easily. The difference between metrics and other types of data in New Relic is based on time. For more information, see Understand data types. Events, logs, spans: These types of data represent a single record at a specific moment in time. For example, you may have an event for every request to the system. This data is ideal for in-depth troubleshooting and analysis. Metrics: These provide an aggregated view of your events, logs, or spans. Metrics are better for showing trends over longer time ranges. For example, you can aggregate the total number of requests per service to one metric and then examine this information month over month. Why use metrics? Comments Flexibility Metrics are dimensional. You can choose what metadata (like host name or app name) is attached to them. Common metric measurements, like average, sum, minimum, and maximum, are already calculated. Data aggregation and retention The data has already been pre-aggregated into longer-period time buckets. Data retention is 13 months. Query capabilities You can query using the Metric data type. When you create metrics, this does not delete your events or other types of data. However, metrics are better for longer-range querying and charting. To get started converting your data to metrics, create a rule. Available operations To show, create, and delete rules for generating metrics from events, logs, or spans, use NerdGraph, our GraphQL-format API. Before performing any operation, we recommend reading Intro to NerdGraph and exploring your data with the GraphiQL API tool. These operations fall under two basic request types: Mutations, which are operations that make changes to existing rules or settings (for example, creating a new metrics rule). Queries, for fetching existing data (for example, fetching existing metrics rules). All operations are role-based in NerdGraph as the currently logged-in New Relic user. Mutations Mutation operations for events to metrics, logs to metrics, or spans to metrics include: Create a rule See Create metrics. Delete a rule Important This operation modifies production settings, so we recommend thoroughly reviewing your changes before you run the operation. To delete a rule, you need the rule ID and the New Relic account ID. Example request: mutation { eventsToMetricsDeleteRule(deletes: {ruleId: \"12\", accountId: 123456}) { successes { id name nrql } failures { errors { description reason } submitted { ruleId accountId } } } } Copy In this request: Element Description mutation One of the basic API operation types. eventsToMetricsDeleteRule The method being called to delete a rule. deletes This takes two parameters: ruleId: The ID of the rule for events to metrics, logs to metrics, or spans to metrics. accountId: The New Relic account ID. successes and submitted blocks Here you define the data returned by a success or failure. Available parameters for these blocks: id (or ruleId for submitted) name description nrql enabled accountId Example response for the request: { \"data\": { \"eventsToMetricsDeleteRule\": { \"failures\": [], \"successes\": [ { \"id\": \"12\", \"name\": \"Test Rule\", \"nrql\": \"select summary(duration) as 'server.responseTime' from Transaction where appName = 'Data Points Staging' facet name, appName, host\" } ] } } } Copy Enable or disable a rule Important This operation modifies production settings, so we recommend thoroughly reviewing your changes before you run the operation. To enable or disable an existing rule for events to metrics, logs to metrics, or spans to metrics, use the same eventsToMetricsUpdateRule operation. The only difference is whether enabled is set to true or false. Example request to enable an existing metrics rule: mutation { eventsToMetricsUpdateRule(updates: {ruleId: \"12\", accountId: 123456, enabled: true}) { successes { id name nrql } failures { errors { description reason } submitted { ruleId accountId } } } } Copy In this request: Element Description mutation One of the basic API operation types. eventsToMetricsUpdateRule The method being called to update an existing rule and either enable it or disable it. updates This takes three required parameters: ruleId: The ID of the rule for events to metrics, logs to metrics, or spans to metrics. accountId: The New Relic account ID. enabled: To enable a disabled rule, set this to true. To disable a rule, set this to false. successes and submitted blocks Here you define the data returned by a success or failure. Available parameters for these blocks: id (or ruleId for submitted) name description nrql enabled accountId Queries Query operations include: List all rules for a New Relic account You can list all rules in a New Relic account or return a specific rule. Example listing all rules for account 123456: query { actor { account(id:123456) { eventsToMetrics{ allRules{ rules{ id name enabled nrql description } } } } } } Copy In this request: Element Description query One of the basic API operation types. Used to query but not make changes. actor This specifies the current New Relic user. account(id: 123456) Specify the ID for the New Relic account where to retrieve data. eventsToMetrics Scope the data only for events-to-metrics, logs-to-metrics, or spans-to-metrics rules. allRules Returns all rules for that account. rules In the rules block, you can define what data you want returned. Available fields include: id name description nrql accountId enabled Example response: { \"data\": { \"actor\": { \"account\": { \"eventsToMetrics\": { \"allRules\": { \"rules\": [ { \"description\": \"Metric for total time\", \"enabled\": true, \"id\": \"1\", \"name\": \"Total Time Tx\", \"nrql\": \"select summary(totalTime) as 'server.totalTime' from Transaction where appName = 'Data Points Staging' facet name, appName, host\" }, { \"description\": \"Metric for duration\", \"enabled\": true, \"id\": \"2\", \"name\": \"Duration Rule\", \"nrql\": \"select summary(duration) as 'server.responseTime' from Transaction where appName = 'Data Points Staging' facet name, appName, host\" } ] } } } } } } Copy List rule by rule ID If you know the exact ID for a rule, then you can query for a specific rule. For example, you may have just created a rule and now you want to list its contents so you can review it. Example listing rule 36 for New Relic account 123456: query { actor { account(id: 123456) { eventsToMetrics { rulesById(ruleIds: \"36\") { rules { id name enabled nrql description accountId } } } } } } Copy For more details about the elements in this query, see List all rules. Example response: { \"data\": { \"actor\": { \"account\": { \"eventsToMetrics\": { \"rulesById\": { \"rules\": [ { \"accountId\": 123456, \"description\": \"Metric for total time\", \"enabled\": true, \"id\": \"36\", \"name\": \"Total Time Tx\", \"nrql\": \"select summary(totalTime) as 'server.totalTime' from Transaction where appName = 'Data Points Staging' facet name, appName, host\" } ] } } } } } } Copy Use the NerdGraph GraphiQL API tool You can use our GraphiQL tool to explore the data structure. You can also use it to build and run the operations to convert events, logs, and spans to metrics. To use this tool: Create the metrics operation's request with the required parameters. Go to api.newrelic.com/graphiql, and paste your query into the box. To execute the operation, press Play. Or, to get the cURL format, select Copy as cURL.) Validate the response in the response box. Optional: To verify that your rule-creation operation was performed successfully, run a list query for that rule ID.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 561.3854,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Analyze and monitor <em>data</em> trends with <em>metrics</em>",
        "sections": "Why create <em>metrics</em> from other <em>data</em> <em>types</em>?",
        "tags": "Convert <em>data</em> to <em>metrics</em>",
        "body": " retention is 13 months. <em>Query</em> capabilities You can <em>query</em> using the <em>Metric</em> <em>data</em> <em>type</em>. When you create metrics, this does not delete your events or other types of <em>data</em>. However, metrics are better for longer-range querying and charting. To get started converting your <em>data</em> to metrics, create a rule"
      },
      "id": "603eb239e7b9d2b99d2a07bb"
    },
    {
      "sections": [
        "Transition to New Relic One from Insights",
        "Important",
        "Features",
        "Improved query abilities",
        "Improved visualizations",
        "Steps for a successful transition"
      ],
      "title": "Transition to New Relic One from Insights",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "4af99cd8030909a71d21a359a60af5ac93b93a66",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/transition-new-relic-one-insights/",
      "published_at": "2021-10-24T16:40:00Z",
      "updated_at": "2021-07-21T20:51:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we're upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. Released in 2014, New Relic Insights was our original way to create custom queries, charts, and dashboards. With New Relic One, we have modernized the experience for you to access, analyze, and visualize your data. New Relic One offers an improved charts and dashboards experience, and it provides a platform where we can more rapidly bring new innovations to you. This transition guide can help you understand: What are some of the new and improved features you get with New Relic One charts, dashboards, and queries Why it's easy to transition to New Relic One What to know and considerations when you make the switch How to get the most out of using New Relic One Features You can scroll down to the transition details, but first here are some features we've added that show how New Relic One dashboards are a clear improvement over Insights dashboards. Improved query abilities With New Relic One, you get: Ability to query many accounts from the same widget: New Relic One lets you query across all your associated accounts in one place. Better querying and charting experiences: Query access is available globally, no matter where you are in New Relic One. Learn how to browse and query data in New Relic. Improved query experience: You can query both the Metric data type and metric timeslice data. Easy customization: Every visualization now has the query accessible. You can augment any curated chart just by changing the NRQL query. Improved visualizations Not only can you select a wide range of visualization options, you can also add more to your dashboards: Better display options: Make your data easier to understand by using visualizations other than dense, line-heavy charts. New Relic One also offers a better TV mode. Facet linking: You can filter your dashboards by faceted attributes, making your dashboards more interactive and easy to use. There's also support for cases. Learn more. More charts or widgets in an area: Insights restricted you to a 3-across limit. Now you can display up to 12 across your dashboard, providing increased data density along with improved tooltips and tracking across charts. Easier creation of multi-page dashboards: Insights referred to these as data apps. Your Insights data apps are preserved as multi-page dashboards in New Relic One. Chart consistency and flexibility: Dashboards include facet color consistency across widgets and faster loading times for more performant dashboards. Also, you can add any chart type to a dashboard in New Relic One! The New Relic Insights UI has served our users well for many years, but it's time to give you an even better experience. Join us and make the switch to New Relic One! Steps for a successful transition The transition to New Relic One has two parts: the UI and mobile app experience (April 12, 2021) and the Dashboard API (July 2021). Insights functionality Transition to New Relic One UI We have already taken care of your transition from Insights to New Relic One for you! As of April 12, 2021, your old Insights URLs redirect automatically to New Relic One. We recommend that you familiarize yourself with the new UI features available to you, as described in this transition guide. If you need to view any Insights charts embedded in other websites, go to one.newrelic.com > More > Manage Data. (These older embedded charts will continue to function as expected.) Mobile apps The Insights mobile app is deprecated as of April 11, 2021. Go to the Google Play Store 2 or Apple App store. Delete your old Insights mobile app, and download the New Relic One mobile app. tvOS apps and large displays New Relic's tvOS app is still available. No action is needed by you at this time. Some New Relic customers with the original pricing model may have set up dashboards on wall screens for restricted users with kiosk mode. No action is required for you to continue to view these dashboards. APIs In July of 2021, the Insights Dashboard API will be deprecated and replaced with NerdGraph functionality. For more on this change, and tips on how to migrate, see NerdGraph API for dashboards. Partnership accounts This applies only if your account is one of the few using our partnership account structure to deliver New Relic services to your direct customers. In this situation, the Insights EOL will not affect your customers’ pricing. This is simply an EOL for the UI, not an EOL for the account type. Questions If you have questions about the transition, please comment in our Explorers Hub post. Or, if you work with an account team, they will be happy to help you.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 388.1686,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Improved <em>query</em> abilities",
        "body": " to browse and <em>query</em> <em>data</em> in New Relic. Improved <em>query</em> experience: You can <em>query</em> both the <em>Metric</em> <em>data</em> <em>type</em> and <em>metric</em> timeslice <em>data</em>. Easy customization: Every visualization now has the <em>query</em> accessible. You can augment any curated chart just by changing the NRQL <em>query</em>. Improved visualizations Not only"
      },
      "id": "6044171164441f454a378ee2"
    }
  ]
}