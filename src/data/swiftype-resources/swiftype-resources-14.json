{
  "/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/map-page-mobile-apps-deprecated": [
    {
      "sections": [
        "HTTP requests page",
        "Find and use HTTP requests page",
        "Understand HTTP request data",
        "Response time chart",
        "HTTP errors and network failures chart",
        "Total requests",
        "Group, sort, and filter HTTP requests",
        "View and share HTTP request data",
        "View legacy HTTP requests UI page",
        "View legacy HTTP requests UI",
        "View legacy drill-down details",
        "Important",
        "View legacy request data"
      ],
      "title": "HTTP requests page",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "56c27e3a1cad7439b752d38b4d00a60ab98f0e10",
      "image": "https://docs.newrelic.com/static/44339db3414bda429d69b74258ab64e8/8c557/screen-http-requests-details_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-requests-page/",
      "published_at": "2021-09-14T10:00:54Z",
      "updated_at": "2021-07-09T12:28:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring has an HTTP requests UI page that helps you better understand HTTP requests associated with your mobile app and how those network calls are affecting performance. This document describes the Enterprise-level HTTP requests page. Non-Enterprise accounts will see the legacy HTTP requests page. Find and use HTTP requests page To view mobile monitoring's HTTP requests page: Go to one.newrelic.com > Mobile > (select an app) > Network > HTTP requests. Use our standard page functions to look for trends in the HTTP analysis charts. Target specific request and response attributes by grouping, sorting, and filtering the data. Understand HTTP request data Here are some places to find the most important HTTP request information: Response time chart The response time chart shows how your app's network calls are performing across percentiles. Use it to compare the average response time to the 1st, 50th, and 99th percentile. Percentiles let you filter out outliers that may be making your average response time higher than expected. HTTP errors and network failures chart This chart shows the unsuccessful network calls your app is experiencing. Select the chart title to go to the HTTP errors page for more detail on the errors and failures. Total requests Sort by Total requests to identify which network requests are being used most frequently. The reason this can be helpful is because your slowest network calls may be only infrequently used, while more frequently used requests might be more worthy of optimization even if they are not the slowest. For a description of the non-Enterprise HTTP requests UI page, see Legacy HTTP requests. Group, sort, and filter HTTP requests If you want to... Do this... Group and sort HTTP requests in different ways Make selections from the Group by and Sort by dropdowns. By default, the HTTP requests page is grouped by request domain and sorted by average response time. Filter for specific HTTP requests Select an HTTP request from the Errors and failures list and/or select multiple filters from the Filter dropdown. See or remove applied filters The filters you select are displayed next to the filter dropdown. To clear filters, select the X icon on the filter you want to clear. Change the time window Select a new time period from the time picker dropdown. View information for a specific app version Using the Versions dropdown, select the version for which you want to see charts and lists. View and share HTTP request data To view any HTTP requests chart in Insights: Select for any chart. Select View query > View in Insights. Optional: Add the data to a dashboard, or share it by using a permalink. To delve deeper into your request data, query MobileRequest events and attributes. View legacy HTTP requests UI page Accounts that do not have an Enterprise-level subscription see a different HTTP requests UI page: View legacy HTTP requests UI To view your top five domains or drill down into details about specific HTTP requests: Go to one.newrelic.com > (select an app) > Network > HTTP requests. Optional: Select the Sort by and Hide < 1% throughput options. To view or hide all requests made by your app, select Expand all or Collapse all. To view details for a specific host or HTTP request (including request time, average throughput, and data transfer), select its name. View legacy drill-down details Use any of New Relic's standard page functions to drill down into detailed information. In addition, from the HTTP requests page, you can drill down into detailed information about specific requests, including: Top five HTTP request times Average throughput Average data transfer one.newrelic.com > Mobile > (select an app) > Network > HTTP requests > (select a request): Here is an example of a selected HTTP request for an app monitored with mobile. To view details for the transaction, select App server drill-down. If you want to... Do this View information to a specific version of your app Select Versions from the side bar (if applicable). Change the time period Use the time picker below the New Relic menu bar. View the related app's transaction Important This feature is not available when the related app has distributed tracing enabled. To view the related app's transaction: Select App server drill-down, then view the Transactions page for the app associated with this HTTP request. To return to the HTTP requests page, select your browser's Back function. View legacy request data You can dig deeper into your request data by querying and charting the MobileRequest event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.57875,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "HTTP requests <em>page</em>",
        "sections": "View legacy HTTP requests <em>UI</em> <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em> has an HTTP requests <em>UI</em> <em>page</em> that helps you better understand HTTP requests associated with your <em>mobile</em> app and how those <em>network</em> calls are affecting performance. This document describes the Enterprise-level HTTP requests <em>page</em>. Non-Enterprise accounts will see the legacy HTTP"
      },
      "id": "60450de028ccbc42662c6083"
    },
    {
      "sections": [
        "Geography page for mobile apps",
        "Tip",
        "Viewing the Geography page",
        "Viewing drill-down details"
      ],
      "title": "Geography page for mobile apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "ec64765f7b48034c3c6e666cd8f553b28be7ca06",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/geography-page-mobile-apps/",
      "published_at": "2021-09-14T09:59:45Z",
      "updated_at": "2021-07-09T12:27:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Geography page shows your mobile users' experience as a world view, including: Color-coded response times Network requests (calls per minute) Data transfer size Active devices Network failure rates You can also drill down to detailed information about each country. Tip The Geography feature is not the same as the Map feature. The Map page shows an architectural view of the relationship between a mobile app and its related services. Viewing the Geography page To view or sort the mobile response time by country: Go to one.newrelic.com > Mobile > (select an app) > Network > Geography. To change the information that appears (including response time, requests per minute, total transfer size, active devices, or network failure rate), select your choice from the Sort by menu. To adjust the amount of information that appears, select Hide < 1% throughput. To view summary information about a location, mouse over any area in color on the map, or mouse over the country's name on the list. Use any of our standard user interface functions and page functions to drill down into detailed information. Viewing drill-down details To view detailed information about a specific location (including average response time, calls per minute, active devices, and network failure by type), select its location on the Geography page's map, or select its name on the list.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.57861,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Geography <em>page</em> for <em>mobile</em> apps",
        "sections": "Geography <em>page</em> for <em>mobile</em> apps",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "The Geography <em>page</em> shows your <em>mobile</em> users&#x27; experience as a world view, including: Color-coded response times <em>Network</em> requests (calls per minute) Data transfer size Active devices <em>Network</em> failure rates You can also drill down to detailed information about each country. Tip The Geography feature"
      },
      "id": "6044165a196a67660d960f44"
    },
    {
      "sections": [
        "HTTP errors: Network failure analysis",
        "Find and use the HTTP errors page",
        "Group, sort, and filter errors and failures",
        "HTTP error profiles",
        "View more details about a specific error",
        "View and share error data with query builder",
        "View legacy HTTP errors UI page",
        "View the Errors page",
        "Error trace details",
        "View error data in query builder",
        "Unknown errors or URL errors"
      ],
      "title": "HTTP errors: Network failure analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "04631e122b061663c6fd261b605202654aadcf96",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-errors-network-failure-analysis/",
      "published_at": "2021-09-14T10:00:53Z",
      "updated_at": "2021-07-09T12:27:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring's HTTP errors page helps you to better understand HTTP errors and network failures associated with your mobile app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager See a list of errors and failures so you can coordinate mobile app teams with backend teams and share the data they need to fix issues. QA engineer Make sure that a new version of your app does not cause a spike in errors compared to a previous version. DevOps engineer See a list of domains and URLs associated with HTTP errors and network failures, so you can focus on the ones that are causing errors and filter out status codes that are too noisy for your alerts. Mobile developer Find out if there are frontend or backend problems affecting your mobile app (even without an error alert going off) so that you can address them in a new version. Support engineer View the errors and session attributes (geography, connection type, device, app version) associated with an error so that you can help customers with their issues. Find and use the HTTP errors page There are two ways to get to the HTTP errors page: Go to one.newrelic.com > Mobile > (select an app) > Network > Network errors. From a mobile app's Overview page in mobile monitoring, select the HTTP errors/network failures chart title link. From the HTTP errors page, investigate HTTP request and network failures: Use any standard page functions to look for trends in Errors and failures charts. Target specific types of errors and failures by grouping, sorting, and filtering the data. Find anomalies in your request errors with HTTP error profiles. Select an error or failure to view details for it. You can also define NRQL alerts that are focused on error types for your critical services or query your app data. Group, sort, and filter errors and failures If you want to do this... Do this... Change how the page groups and sorts errors and network failures Make selections from the Group by and Sort by dropdowns. By default, the Network errors page is grouped by request domain and sorted by errors and failures. Filter for specific errors and network failures Select an error or failure from the Errors and failures list and/or select multiple filters from the Filter dropdown. See which filters you applied or remove filters The filters you select display next to the filter dropdown. To clear filters, select the X next to the filter you want to clear. Change the time window Select a new time period from the Time picker dropdown. View information for one specific app version Select the version that you want to see charts and lists for in the Versions dropdown. HTTP error profiles Error profiles provide visual details about significant differences in the frequency of different values for HTTP error events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of other errors This helps you take more of the guesswork out of resolving your mobile application's HTTP errors. You can more easily determine if you safely ignore the error, or if you should attempt to resolve the error with a new deployment, code change, customer communication or other actions. View more details about a specific error To view details about an error or failure, select the Request URL link to be directed to the Error summary page. From the Error summary page, you can view the version information, request attributes, and Response body, as well as get a breakdown of error types for the request URL. View and share error data with query builder To explore the data behind any of the charts or lists on the HTTP errors/requests page: Select for any chart. Select View query and then View in Insights. This will open the query builder. From the query builder, you can add the error data to a dashboard and share it via a permalink. To dig deeper into the error data, query your data for the following events and attributes: MobileRequestError events and attributes MobileRequest events and attributes View legacy HTTP errors UI page Accounts that do not have an Enterprise-level subscription see a different HTTP Errors UI page: The Errors page includes details about HTTP errors (403, 404, 422, 500, 502, etc.) and network failures for your hosts; for example: Secure connection failed Timed out Cannot find host Not connected to Internet Cannot connect to host View the Errors page To view HTTP errors or network failures for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Network > Errors. To change the view to errors or failures, select the Sort by option. To hide low-usage hosts, select the Hide < 1% throughput option. To limit information to a specific version of your app, or to change the time period, select your choice from the Versions menu or the time picker below the menu bar. To view details for a specific host, HTTP status error, or network failure, select its name. Use any of our standard user interface functions to drill down into detailed information. Error trace details Mobile monitoring will capture the response details from HTTP requests that return a 400 or 500 level status code. In addition, error messages generated from Android apps will include a stack trace. To view details about an error trace on the Errors page, select its request URL link. From here you can: View the response body. Share the error details with others by email. File a ticket about it through a ticketing system integrated with New Relic. Delete or hide the error. The errors chart also appears on the selected mobile app's Overview page. If the chart shows errors, you can select its HTTP errors/network failures title or select anywhere on the Overview page's chart to go directly to this Errors page. View error data in query builder To dig deeper into your request data, use the query builder to query and chart the MobileRequest events and attributes. Unknown errors or URL errors The mobile agents maintain a list of exception types. In some cases, custom exceptions thrown by applications fall outside of this list. When this happens, Unknown may appear in the mobile Errors page. If you find Unknown in your list of errors and need assistance in researching which exception types are being missed, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.57861,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "HTTP errors: <em>Network</em> failure analysis",
        "sections": "View legacy HTTP errors <em>UI</em> <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em>&#x27;s HTTP errors <em>page</em> helps you to better understand HTTP errors and <em>network</em> failures associated with your <em>mobile</em> app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors <em>page</em> to... Manager"
      },
      "id": "603e8eb428ccbcd174eba791"
    }
  ],
  "/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/mobile-http-error-profiles-find-error-causes": [
    {
      "sections": [
        "Map page for mobile apps (deprecated)",
        "Important",
        "View a map of your mobile app services"
      ],
      "title": "Map page for mobile apps (deprecated)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "a082467948ce481c9ecb544d26a802e8d5f3894b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/map-page-mobile-apps-deprecated/",
      "published_at": "2021-09-14T20:45:24Z",
      "updated_at": "2021-09-14T20:45:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important The mobile Maps UI is deprecated since December 22, 2020. Service maps are available in New Relic One's left navigation for each mobile entity, and they are a better way to visualize and customize representations of your architecture. For more information, see our Explorers Hub post. Maps help you find performance problems for a mobile app or its services. This gives you a clear picture of your app's relationships to other services and the influence of each service on the others. If one service fails, you can see at a glance which other services are affected. View a map of your mobile app services To view your mobile app and its related services as an architectural map, go to one.newrelic.com > Mobile > (select a mobile app) > Monitor > Service map. For more information, see the service maps documentation. If you need to use the deprecated mobile Map page, follow these steps: Go to one.newrelic.com > Mobile > (select an app) > Network > Map. To view HTTP request details for a service, select its name. To view details for an app monitored by APM that is related to the service, select the service's name below the associated hostname. To view throughput details as a chart, select the icon or the cpm bar below the service's name. To view detailed metrics for a service, mouse over the throughput chart. The Map page for mobile monitoring gives an architectural view of your mobile app and the services it uses,",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 340.28143,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Map <em>page</em> for <em>mobile</em> apps (deprecated)",
        "sections": "Map <em>page</em> for <em>mobile</em> apps (deprecated)",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": " <em>mobile</em> app services To view your <em>mobile</em> app and its related services as an architectural map, go to one.newrelic.com &gt; <em>Mobile</em> &gt; (select a <em>mobile</em> app) &gt; <em>Monitor</em> &gt; Service map. For more information, see the service maps documentation. If you need to use the deprecated <em>mobile</em> Map <em>page</em>, follow these steps"
      },
      "id": "6044141828ccbc0f862c60ae"
    },
    {
      "sections": [
        "HTTP requests page",
        "Find and use HTTP requests page",
        "Understand HTTP request data",
        "Response time chart",
        "HTTP errors and network failures chart",
        "Total requests",
        "Group, sort, and filter HTTP requests",
        "View and share HTTP request data",
        "View legacy HTTP requests UI page",
        "View legacy HTTP requests UI",
        "View legacy drill-down details",
        "Important",
        "View legacy request data"
      ],
      "title": "HTTP requests page",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "56c27e3a1cad7439b752d38b4d00a60ab98f0e10",
      "image": "https://docs.newrelic.com/static/44339db3414bda429d69b74258ab64e8/8c557/screen-http-requests-details_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-requests-page/",
      "published_at": "2021-09-14T10:00:54Z",
      "updated_at": "2021-07-09T12:28:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring has an HTTP requests UI page that helps you better understand HTTP requests associated with your mobile app and how those network calls are affecting performance. This document describes the Enterprise-level HTTP requests page. Non-Enterprise accounts will see the legacy HTTP requests page. Find and use HTTP requests page To view mobile monitoring's HTTP requests page: Go to one.newrelic.com > Mobile > (select an app) > Network > HTTP requests. Use our standard page functions to look for trends in the HTTP analysis charts. Target specific request and response attributes by grouping, sorting, and filtering the data. Understand HTTP request data Here are some places to find the most important HTTP request information: Response time chart The response time chart shows how your app's network calls are performing across percentiles. Use it to compare the average response time to the 1st, 50th, and 99th percentile. Percentiles let you filter out outliers that may be making your average response time higher than expected. HTTP errors and network failures chart This chart shows the unsuccessful network calls your app is experiencing. Select the chart title to go to the HTTP errors page for more detail on the errors and failures. Total requests Sort by Total requests to identify which network requests are being used most frequently. The reason this can be helpful is because your slowest network calls may be only infrequently used, while more frequently used requests might be more worthy of optimization even if they are not the slowest. For a description of the non-Enterprise HTTP requests UI page, see Legacy HTTP requests. Group, sort, and filter HTTP requests If you want to... Do this... Group and sort HTTP requests in different ways Make selections from the Group by and Sort by dropdowns. By default, the HTTP requests page is grouped by request domain and sorted by average response time. Filter for specific HTTP requests Select an HTTP request from the Errors and failures list and/or select multiple filters from the Filter dropdown. See or remove applied filters The filters you select are displayed next to the filter dropdown. To clear filters, select the X icon on the filter you want to clear. Change the time window Select a new time period from the time picker dropdown. View information for a specific app version Using the Versions dropdown, select the version for which you want to see charts and lists. View and share HTTP request data To view any HTTP requests chart in Insights: Select for any chart. Select View query > View in Insights. Optional: Add the data to a dashboard, or share it by using a permalink. To delve deeper into your request data, query MobileRequest events and attributes. View legacy HTTP requests UI page Accounts that do not have an Enterprise-level subscription see a different HTTP requests UI page: View legacy HTTP requests UI To view your top five domains or drill down into details about specific HTTP requests: Go to one.newrelic.com > (select an app) > Network > HTTP requests. Optional: Select the Sort by and Hide < 1% throughput options. To view or hide all requests made by your app, select Expand all or Collapse all. To view details for a specific host or HTTP request (including request time, average throughput, and data transfer), select its name. View legacy drill-down details Use any of New Relic's standard page functions to drill down into detailed information. In addition, from the HTTP requests page, you can drill down into detailed information about specific requests, including: Top five HTTP request times Average throughput Average data transfer one.newrelic.com > Mobile > (select an app) > Network > HTTP requests > (select a request): Here is an example of a selected HTTP request for an app monitored with mobile. To view details for the transaction, select App server drill-down. If you want to... Do this View information to a specific version of your app Select Versions from the side bar (if applicable). Change the time period Use the time picker below the New Relic menu bar. View the related app's transaction Important This feature is not available when the related app has distributed tracing enabled. To view the related app's transaction: Select App server drill-down, then view the Transactions page for the app associated with this HTTP request. To return to the HTTP requests page, select your browser's Back function. View legacy request data You can dig deeper into your request data by querying and charting the MobileRequest event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.57875,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "HTTP requests <em>page</em>",
        "sections": "View legacy HTTP requests <em>UI</em> <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em> has an HTTP requests <em>UI</em> <em>page</em> that helps you better understand HTTP requests associated with your <em>mobile</em> app and how those <em>network</em> calls are affecting performance. This document describes the Enterprise-level HTTP requests <em>page</em>. Non-Enterprise accounts will see the legacy HTTP"
      },
      "id": "60450de028ccbc42662c6083"
    },
    {
      "sections": [
        "Geography page for mobile apps",
        "Tip",
        "Viewing the Geography page",
        "Viewing drill-down details"
      ],
      "title": "Geography page for mobile apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "ec64765f7b48034c3c6e666cd8f553b28be7ca06",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/geography-page-mobile-apps/",
      "published_at": "2021-09-14T09:59:45Z",
      "updated_at": "2021-07-09T12:27:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Geography page shows your mobile users' experience as a world view, including: Color-coded response times Network requests (calls per minute) Data transfer size Active devices Network failure rates You can also drill down to detailed information about each country. Tip The Geography feature is not the same as the Map feature. The Map page shows an architectural view of the relationship between a mobile app and its related services. Viewing the Geography page To view or sort the mobile response time by country: Go to one.newrelic.com > Mobile > (select an app) > Network > Geography. To change the information that appears (including response time, requests per minute, total transfer size, active devices, or network failure rate), select your choice from the Sort by menu. To adjust the amount of information that appears, select Hide < 1% throughput. To view summary information about a location, mouse over any area in color on the map, or mouse over the country's name on the list. Use any of our standard user interface functions and page functions to drill down into detailed information. Viewing drill-down details To view detailed information about a specific location (including average response time, calls per minute, active devices, and network failure by type), select its location on the Geography page's map, or select its name on the list.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.57861,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Geography <em>page</em> for <em>mobile</em> apps",
        "sections": "Geography <em>page</em> for <em>mobile</em> apps",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "The Geography <em>page</em> shows your <em>mobile</em> users&#x27; experience as a world view, including: Color-coded response times <em>Network</em> requests (calls per minute) Data transfer size Active devices <em>Network</em> failure rates You can also drill down to detailed information about each country. Tip The Geography feature"
      },
      "id": "6044165a196a67660d960f44"
    }
  ],
  "/docs/mobile-monitoring/mobile-monitoring-ui/usage-pages/monthly-uniques-report": [
    {
      "sections": [
        "Map page for mobile apps (deprecated)",
        "Important",
        "View a map of your mobile app services"
      ],
      "title": "Map page for mobile apps (deprecated)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "a082467948ce481c9ecb544d26a802e8d5f3894b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/map-page-mobile-apps-deprecated/",
      "published_at": "2021-09-14T20:45:24Z",
      "updated_at": "2021-09-14T20:45:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important The mobile Maps UI is deprecated since December 22, 2020. Service maps are available in New Relic One's left navigation for each mobile entity, and they are a better way to visualize and customize representations of your architecture. For more information, see our Explorers Hub post. Maps help you find performance problems for a mobile app or its services. This gives you a clear picture of your app's relationships to other services and the influence of each service on the others. If one service fails, you can see at a glance which other services are affected. View a map of your mobile app services To view your mobile app and its related services as an architectural map, go to one.newrelic.com > Mobile > (select a mobile app) > Monitor > Service map. For more information, see the service maps documentation. If you need to use the deprecated mobile Map page, follow these steps: Go to one.newrelic.com > Mobile > (select an app) > Network > Map. To view HTTP request details for a service, select its name. To view details for an app monitored by APM that is related to the service, select the service's name below the associated hostname. To view throughput details as a chart, select the icon or the cpm bar below the service's name. To view detailed metrics for a service, mouse over the throughput chart. The Map page for mobile monitoring gives an architectural view of your mobile app and the services it uses,",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.2661,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Map <em>page</em> for <em>mobile</em> apps (deprecated)",
        "sections": "Map <em>page</em> for <em>mobile</em> apps (deprecated)",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": " <em>mobile</em> app services To view your <em>mobile</em> app and its related services as an architectural map, go to one.newrelic.com &gt; <em>Mobile</em> &gt; (select a <em>mobile</em> app) &gt; <em>Monitor</em> &gt; Service map. For more information, see the service maps documentation. If you need to use the deprecated <em>mobile</em> Map <em>page</em>, follow these steps"
      },
      "id": "6044141828ccbc0f862c60ae"
    },
    {
      "sections": [
        "Versions analysis",
        "Versions analysis details",
        "Viewing drill-down details",
        "How version numbers are obtained",
        "Android",
        "iOS"
      ],
      "title": "Versions analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Usage pages"
      ],
      "external_id": "3906aba3231864c2adb43694636f085ae5332d0e",
      "image": "https://docs.newrelic.com/static/f359bb98f6fbf2a5c90dd604778a5dcd/c1b63/screen-versions_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/usage-pages/versions-analysis/",
      "published_at": "2021-09-14T10:02:04Z",
      "updated_at": "2021-07-09T12:29:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring includes a comparative analysis of adoption and performance between versions of your application, including top versions by: Interaction time Active sessions Error rate The Versions page also includes a table comparing each version by date created, average memory, average CPU, average sessions per minute, and average requests per minute (RPM) per active app. You can also drill down into additional details about a specific version. Versions analysis details one.newrelic.com > Mobile > (select an app) > Usage > Versions: The Versions analysis includes color-coded charts of mobile app usage, plus a table that summarizes mobile app versions and their averages for memory, CPU, active users, and network RPM (requests per minute). The Versions page provides a list of all versions of your app that have been detected, plus overview information on all versions active in the last seven days. To view the comparative analysis: Go to one.newrelic.com > Mobile > (select an app) > Usage > Versions. To select the time period, use the time picker below the New Relic menu bar. Optional: Select the Sort by options. To view details only for a specific version, select its name. The Versions page provides a list of all versions of your app that have been active in the selected time window. Use any of New Relic's standard user interface functions and page functions to drill down into detailed information. Viewing drill-down details one.newrelic.com > Mobile > (select an app) > Usage > Versions > (selected version): Here is an example of details for a selected version. The details page provides further insight into how the selected version compares to a reference version (a recent or popular version), and the average of other versions of your app. Time series show the comparison across error rate, response time, active sessions, and memory usage. To exit the details page, select the Close (X) button. How version numbers are obtained The way that mobile monitoring obtains the version number varies by platform: Android The Android agent obtains the version information from the android:versionName property in the manifest. iOS The iOS agent uses both CFBundleShortVersionString and CFBundleVersion properties to obtain the app version. The agent accesses those properties through iOS APIs. It does not obtain them by reading the info.plist file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.74843,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": " the comparison across error rate, response time, active sessions, and memory <em>usage</em>. To exit the details <em>page</em>, select the Close (X) button. How version numbers are obtained The way that <em>mobile</em> <em>monitoring</em> obtains the version number varies by platform: Android The Android agent obtains the version information"
      },
      "id": "603eaeeae7b9d262be2a080c"
    },
    {
      "sections": [
        "Mobile apps index",
        "View your list of mobile apps",
        "Standard menu functions"
      ],
      "title": "Mobile apps index",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Mobile app pages"
      ],
      "external_id": "38ff00ca55b0ca25a0ad534b57e02b01f4040c97",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/mobile-apps-index/",
      "published_at": "2021-09-14T14:24:51Z",
      "updated_at": "2021-08-27T07:51:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring UI includes a mobile app index that shows a list of your monitored apps and important summary information about them. View your list of mobile apps To see the mobile apps index, go to [one.newrelic.com > Explorer > Mobile applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. Alternatively, go to one.newrelic.com > Mobile. The index of available mobile apps includes a colored health status indicating: Green = Normal Yellow = Warning Red = Critical Gray = Not reporting data Standard menu functions To view details for a specific app, select it from the index. Here are some other functions available from the index: If you want to... Do this... View the app's status Mouse over the mobile app's colored health status indicator. If the health status indicator is gray and no data is being reported, you likely need to finish installing mobile monitoring. Monitor another app Select Add more. See the app's metadata To see the app's metadata, including its app ID, entity GUID, and more, click the icon next to the application name. For more about UI functions, see Basic UI functions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.66281,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Mobile</em> apps index",
        "sections": "<em>Mobile</em> apps index",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": " status indicator is gray and no data is being reported, you likely need to finish installing <em>mobile</em> <em>monitoring</em>. <em>Monitor</em> another app Select Add more. See the app&#x27;s metadata To see the app&#x27;s metadata, including its app ID, entity GUID, and more, click the icon next to the application name. For more about <em>UI</em> functions, see Basic <em>UI</em> functions."
      },
      "id": "604537fc64441f7903378f35"
    }
  ],
  "/docs/mobile-monitoring/mobile-monitoring-ui/usage-pages/versions-analysis": [
    {
      "sections": [
        "Map page for mobile apps (deprecated)",
        "Important",
        "View a map of your mobile app services"
      ],
      "title": "Map page for mobile apps (deprecated)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "a082467948ce481c9ecb544d26a802e8d5f3894b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/map-page-mobile-apps-deprecated/",
      "published_at": "2021-09-14T20:45:24Z",
      "updated_at": "2021-09-14T20:45:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important The mobile Maps UI is deprecated since December 22, 2020. Service maps are available in New Relic One's left navigation for each mobile entity, and they are a better way to visualize and customize representations of your architecture. For more information, see our Explorers Hub post. Maps help you find performance problems for a mobile app or its services. This gives you a clear picture of your app's relationships to other services and the influence of each service on the others. If one service fails, you can see at a glance which other services are affected. View a map of your mobile app services To view your mobile app and its related services as an architectural map, go to one.newrelic.com > Mobile > (select a mobile app) > Monitor > Service map. For more information, see the service maps documentation. If you need to use the deprecated mobile Map page, follow these steps: Go to one.newrelic.com > Mobile > (select an app) > Network > Map. To view HTTP request details for a service, select its name. To view details for an app monitored by APM that is related to the service, select the service's name below the associated hostname. To view throughput details as a chart, select the icon or the cpm bar below the service's name. To view detailed metrics for a service, mouse over the throughput chart. The Map page for mobile monitoring gives an architectural view of your mobile app and the services it uses,",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.2661,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Map <em>page</em> for <em>mobile</em> apps (deprecated)",
        "sections": "Map <em>page</em> for <em>mobile</em> apps (deprecated)",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": " <em>mobile</em> app services To view your <em>mobile</em> app and its related services as an architectural map, go to one.newrelic.com &gt; <em>Mobile</em> &gt; (select a <em>mobile</em> app) &gt; <em>Monitor</em> &gt; Service map. For more information, see the service maps documentation. If you need to use the deprecated <em>mobile</em> Map <em>page</em>, follow these steps"
      },
      "id": "6044141828ccbc0f862c60ae"
    },
    {
      "sections": [
        "Monthly uniques report",
        "Monthly uniques report details",
        "Device tracking"
      ],
      "title": "Monthly uniques report",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Usage pages"
      ],
      "external_id": "8865375eef0e6bab4c0b40fa9edde33da93a752c",
      "image": "https://docs.newrelic.com/static/14ffff087d1c8f0d7c26b59739057f07/c1b63/screen-mobile-monthly-uniques.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/usage-pages/monthly-uniques-report/",
      "published_at": "2021-09-14T07:35:54Z",
      "updated_at": "2021-07-09T12:29:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring includes a monthly report with a bar chart tracking the number of devices running your app for each month over the last year. To view the report: Go to one.newrelic.com > Mobile > (select an app) > Usage > Monthly uniques. Monthly uniques report details To see the total number of unique devices for any month, mouse over the month's bar in the chart. The current month's device count is a month-to-date value and does not indicate the full month's usage. one.newrelic.com > Mobile > (select an app) > Usage > Monthly uniques: This report provides a bar chart tracking the number of devices running your app for each month over the last year. Use any of New Relic's standard user interface functions and page functions to drill down into detailed information. Unique users are used to calculate your monthly usage, which is used to calculate your subscription level. Device tracking Mobile monitoring does not use hardware identifiers for unique install tracking. On iOS we use the IdentifierForVendor property. (Versions 5.3.4 and lower used the SecureUDID library.) On Android we generate a unique GUID when the application is installed.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.74843,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em> includes a monthly report with a bar chart tracking the number of devices running your app for each month over the last year. To view the report: Go to one.newrelic.com &gt; <em>Mobile</em> &gt; (select an app) &gt; <em>Usage</em> &gt; Monthly uniques. Monthly uniques report details To see the total number"
      },
      "id": "6044141964441f5cb1378f32"
    },
    {
      "sections": [
        "Mobile apps index",
        "View your list of mobile apps",
        "Standard menu functions"
      ],
      "title": "Mobile apps index",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Mobile app pages"
      ],
      "external_id": "38ff00ca55b0ca25a0ad534b57e02b01f4040c97",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/mobile-apps-index/",
      "published_at": "2021-09-14T14:24:51Z",
      "updated_at": "2021-08-27T07:51:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring UI includes a mobile app index that shows a list of your monitored apps and important summary information about them. View your list of mobile apps To see the mobile apps index, go to [one.newrelic.com > Explorer > Mobile applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. Alternatively, go to one.newrelic.com > Mobile. The index of available mobile apps includes a colored health status indicating: Green = Normal Yellow = Warning Red = Critical Gray = Not reporting data Standard menu functions To view details for a specific app, select it from the index. Here are some other functions available from the index: If you want to... Do this... View the app's status Mouse over the mobile app's colored health status indicator. If the health status indicator is gray and no data is being reported, you likely need to finish installing mobile monitoring. Monitor another app Select Add more. See the app's metadata To see the app's metadata, including its app ID, entity GUID, and more, click the icon next to the application name. For more about UI functions, see Basic UI functions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.66281,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Mobile</em> apps index",
        "sections": "<em>Mobile</em> apps index",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": " status indicator is gray and no data is being reported, you likely need to finish installing <em>mobile</em> <em>monitoring</em>. <em>Monitor</em> another app Select Add more. See the app&#x27;s metadata To see the app&#x27;s metadata, including its app ID, entity GUID, and more, click the icon next to the application name. For more about <em>UI</em> functions, see Basic <em>UI</em> functions."
      },
      "id": "604537fc64441f7903378f35"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile/get-started/introduction-mobile-monitoring": [
    {
      "sections": [
        "Introduction to iOS mobile app",
        "Features",
        "Time range",
        "Synthetic monitoring",
        "Alerts",
        "Mobile monitoring",
        "Data privacy"
      ],
      "title": "Introduction to iOS mobile app",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "iOS app"
      ],
      "external_id": "371077582a50dfd2a1e7c57cfbbf9eeaf8013e1c",
      "image": "https://docs.newrelic.com/static/630c7a9a486540073ab96a2c9926e303/442cb/device-ios-synthetics-view-monitor.png",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/ios-app/introduction-ios-mobile-app/",
      "published_at": "2021-09-14T07:29:48Z",
      "updated_at": "2021-09-14T07:29:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The user interface for New Relic's iPhone and iPad app provides functionality similar to New Relic's standard user interface, with customized details for mobile users. The New Relic iOS apps show near real-time information about your apps, hosts, and more. Features New Relic's iOS app includes these New Relic products and features: New Relic's iOS app for iPhone and iPad includes these New Relic products and features: APM (iPhone and iPad). Includes real-time and historical data. Select the icon to see transaction details. Select Overview Charts to view summary charts of your top five transactions. Browser monitoring (iPhone and iPad). Provide overview dashboard, including average page load time, browser Apdex, average throughput, and more. Infrastructure monitoring (iPhone only). Alerts (iPhone and iPad). Get alert and deployment notifications. Synthetic monitoring (iPhone only). Mobile monitoring (iPhone and iPad). Includes crash reports, network errors, API calls, and active user count. New Relic's iOS app does not have all the features of the New Relic web application. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the clock icon in the top right of the page. This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth across the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). For iPads: to specify an end time other than now, slide the toggle from Ending Now to Custom Date. Synthetic monitoring You can use the iOS app to view your synthetic monitoring data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you connect the iOS app to your New Relic account, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For iOS alerts, notifications appear on your lock screen and can be viewed by swiping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile monitoring If you have a mobile application and have installed mobile monitoring, you can monitor its performance directly from your iPhone or iPad. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. Data privacy New Relic's mobile apps only record information needed to help authenticate and troubleshoot: User's email address associated with your New Relic account, including first and last name (for authentication purposes only) IP address Device ID For more information, see our Mobile data privacy and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.55981,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to iOS <em>mobile</em> app",
        "sections": "<em>Mobile</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> apps",
        "body": " sends a push notification when a colleague acknowledges an open event. Then, <em>New</em> <em>Relic</em> sends a final, closing notification when all Critical events end. <em>Mobile</em> <em>monitoring</em> If you have a <em>mobile</em> application and have installed <em>mobile</em> <em>monitoring</em>, you can <em>monitor</em> its performance directly from your iPhone"
      },
      "id": "6044161628ccbc96b62c6092"
    },
    {
      "sections": [
        "Android app UI",
        "Pages",
        "Time range",
        "New Relic Synthetics",
        "Alerts",
        "Mobile apps",
        "For more help"
      ],
      "title": "Android app UI",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Android app"
      ],
      "external_id": "8918a5a2454491a91421c55e26501a0e3f64cd3a",
      "image": "https://docs.newrelic.com/static/fc97ade0bbdbdef58b89495a0d91b734/edd00/deployment-markers_nexus.jpg",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/android-app/android-app-ui/",
      "published_at": "2021-09-14T07:28:15Z",
      "updated_at": "2021-09-14T07:28:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The UI for the New Relic Android app provides functionality similar to the standard user interface, with customized details for mobile users. Pages To view details of your New Relic apps, hosts, Synthetics monitors, Alerts, plugins, and key transactions, select a product from the main menu. The New Relic Android app includes: APM metrics, both real-time and historical data, including health maps. And, select the transaction icon for detailed transaction metrics, or an Overview Charts to view summary charts of your top five transactions. New Relic Infrastructure utilization. New Relic Plugins, including a list of their components or instances, and their charts and current values from the plugin's Summary. Mobile monitoring, including crash reports, network errors, API calls, and active user count. Select the filter icon to filter by labels and categories. Event notifications, including mobile alerts wherever you are, plus deployment notifications and notes. Note: New Relic's Android app does not have the full feature set of the New Relic web interface. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the time picker icon in the top right of the page (the 7D in the screenshot). This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth in the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). New Relic Synthetics You can use the Android app to view your New Relic Synthetics data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you log in to your New Relic account from the Android app, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For Android alerts, notifications appear on your lock screen and can be viewed by tapping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile apps If you have a mobile application and have installed mobile monitoring, you can monitor its performance directly from your Android device. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. For more help Additional documentation resources include: New Relic Android app (compatibility, requirements, installation) Android authentication (procedures to add or remove users, and for the users to authenticate with their Android device)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.34201,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> Synthetics",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> apps",
        "body": ". Then, <em>New</em> <em>Relic</em> sends a final, closing notification when all Critical events end. <em>Mobile</em> apps If you have a <em>mobile</em> application and have installed <em>mobile</em> <em>monitoring</em>, you can <em>monitor</em> its performance directly from your Android device. <em>Mobile</em> <em>monitoring</em> includes network errors, API calls, and number"
      },
      "id": "6044181d28ccbc9a522c60a5"
    },
    {
      "sections": [
        "Introduction to New Relic Android app",
        "Requirements",
        "Install New Relic's mobile app",
        "View New Relic data",
        "New Relic product details",
        "Synthetics data",
        "Alerts",
        "Mobile app monitoring",
        "Details on setting time range",
        "Data privacy"
      ],
      "title": "Introduction to New Relic Android app",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Android app"
      ],
      "external_id": "ff8415c00363a49eaa062f4b0b13c795b4717ea5",
      "image": "https://docs.newrelic.com/static/ea914fce17844b32fdabefd60efc457e/e5166/navigation_nexus.jpg",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/android-app/introduction-new-relic-android-app/",
      "published_at": "2021-09-14T07:28:16Z",
      "updated_at": "2021-09-14T07:28:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The user interface for New Relic's Android app provides functionality similar to New Relic's standard user interface, with customized details for mobile users. Requirements Requirements include: Android 4.0 (Ice Cream Sandwich) or higher Screen size of 7 inches or less Install New Relic's mobile app You can install the New Relic Android app from the Google Play Store or learn more from the New Relic website. Follow standard procedures to install any Android app, then sign in with your New Relic user name (account email) and password if applicable. Depending on your New Relic account, additional installation or user authentication steps may be required. View New Relic data To view details of your apps monitored by New Relic, select a product from the app's main menu. See below for details on how to use specific features of the app: New Relic product details The New Relic Android app includes data about these features: APM metrics, both real-time and historical data, including health maps. Select the transaction icon to see detailed transaction metrics, or an Overview chart to view summary charts of your top five transactions. Select the icon to filter by labels and categories. Browser monitoring metrics, including average page load time, Apdex, average throughput, and more. Infrastructure monitoring. Mobile monitoring, including crash reports, network errors, API calls, and active user count. Event notifications, including mobile alerts wherever you are, plus deployment notifications and notes. New Relic's Android app does not have the full feature set of the New Relic web interface. For more detailed analysis, sign in to your New Relic account with a web browser. Synthetics data You can use the Android app to view your synthetic monitoring data, including charts of your monitor's availability, load times, and load sizes. To view more detailed charts, select the caret icon. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you log in to your New Relic account from the Android app, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For Android alerts, notifications appear on your lock screen. To view them, tap the alert event. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile app monitoring If you have installed mobile monitoring, you can monitor its performance directly from your Android device. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. Details on setting time range When viewing an application or host, you can change the visible time frame with the time picker. To move back and forth across the timeline, scrub the New Relic charts. To change the duration of the visible time slice, select the clock icon. To specify an end time other than now, slide the toggle from Ending Now to Custom Date. To save your changes and refresh the chart data, select the clock icon again. Data privacy New Relic's mobile apps only record information needed to help authenticate and troubleshoot: User's email address associated with your New Relic account, including first and last name (for authentication purposes only) IP address Device ID For more information, see our Mobile data privacy and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.82385,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> Android app",
        "sections": "Install <em>New</em> <em>Relic&#x27;s</em> <em>mobile</em> app",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> apps",
        "body": " details or acknowledge the alert. <em>New</em> <em>Relic</em> also sends a push notification when a colleague acknowledges an open event. Then, <em>New</em> <em>Relic</em> sends a final, closing notification when all Critical events end. <em>Mobile</em> app <em>monitoring</em> If you have installed <em>mobile</em> <em>monitoring</em>, you can <em>monitor</em> its performance directly"
      },
      "id": "604415e0196a67ff23960f46"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile/get-started/mobile-monitoring-alert-information": [
    {
      "sections": [
        "Introduction to iOS mobile app",
        "Features",
        "Time range",
        "Synthetic monitoring",
        "Alerts",
        "Mobile monitoring",
        "Data privacy"
      ],
      "title": "Introduction to iOS mobile app",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "iOS app"
      ],
      "external_id": "371077582a50dfd2a1e7c57cfbbf9eeaf8013e1c",
      "image": "https://docs.newrelic.com/static/630c7a9a486540073ab96a2c9926e303/442cb/device-ios-synthetics-view-monitor.png",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/ios-app/introduction-ios-mobile-app/",
      "published_at": "2021-09-14T07:29:48Z",
      "updated_at": "2021-09-14T07:29:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The user interface for New Relic's iPhone and iPad app provides functionality similar to New Relic's standard user interface, with customized details for mobile users. The New Relic iOS apps show near real-time information about your apps, hosts, and more. Features New Relic's iOS app includes these New Relic products and features: New Relic's iOS app for iPhone and iPad includes these New Relic products and features: APM (iPhone and iPad). Includes real-time and historical data. Select the icon to see transaction details. Select Overview Charts to view summary charts of your top five transactions. Browser monitoring (iPhone and iPad). Provide overview dashboard, including average page load time, browser Apdex, average throughput, and more. Infrastructure monitoring (iPhone only). Alerts (iPhone and iPad). Get alert and deployment notifications. Synthetic monitoring (iPhone only). Mobile monitoring (iPhone and iPad). Includes crash reports, network errors, API calls, and active user count. New Relic's iOS app does not have all the features of the New Relic web application. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the clock icon in the top right of the page. This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth across the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). For iPads: to specify an end time other than now, slide the toggle from Ending Now to Custom Date. Synthetic monitoring You can use the iOS app to view your synthetic monitoring data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you connect the iOS app to your New Relic account, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For iOS alerts, notifications appear on your lock screen and can be viewed by swiping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile monitoring If you have a mobile application and have installed mobile monitoring, you can monitor its performance directly from your iPhone or iPad. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. Data privacy New Relic's mobile apps only record information needed to help authenticate and troubleshoot: User's email address associated with your New Relic account, including first and last name (for authentication purposes only) IP address Device ID For more information, see our Mobile data privacy and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.55981,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to iOS <em>mobile</em> app",
        "sections": "<em>Mobile</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> apps",
        "body": " sends a push notification when a colleague acknowledges an open event. Then, <em>New</em> <em>Relic</em> sends a final, closing notification when all Critical events end. <em>Mobile</em> <em>monitoring</em> If you have a <em>mobile</em> application and have installed <em>mobile</em> <em>monitoring</em>, you can <em>monitor</em> its performance directly from your iPhone"
      },
      "id": "6044161628ccbc96b62c6092"
    },
    {
      "sections": [
        "Android app UI",
        "Pages",
        "Time range",
        "New Relic Synthetics",
        "Alerts",
        "Mobile apps",
        "For more help"
      ],
      "title": "Android app UI",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Android app"
      ],
      "external_id": "8918a5a2454491a91421c55e26501a0e3f64cd3a",
      "image": "https://docs.newrelic.com/static/fc97ade0bbdbdef58b89495a0d91b734/edd00/deployment-markers_nexus.jpg",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/android-app/android-app-ui/",
      "published_at": "2021-09-14T07:28:15Z",
      "updated_at": "2021-09-14T07:28:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The UI for the New Relic Android app provides functionality similar to the standard user interface, with customized details for mobile users. Pages To view details of your New Relic apps, hosts, Synthetics monitors, Alerts, plugins, and key transactions, select a product from the main menu. The New Relic Android app includes: APM metrics, both real-time and historical data, including health maps. And, select the transaction icon for detailed transaction metrics, or an Overview Charts to view summary charts of your top five transactions. New Relic Infrastructure utilization. New Relic Plugins, including a list of their components or instances, and their charts and current values from the plugin's Summary. Mobile monitoring, including crash reports, network errors, API calls, and active user count. Select the filter icon to filter by labels and categories. Event notifications, including mobile alerts wherever you are, plus deployment notifications and notes. Note: New Relic's Android app does not have the full feature set of the New Relic web interface. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the time picker icon in the top right of the page (the 7D in the screenshot). This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth in the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). New Relic Synthetics You can use the Android app to view your New Relic Synthetics data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you log in to your New Relic account from the Android app, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For Android alerts, notifications appear on your lock screen and can be viewed by tapping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile apps If you have a mobile application and have installed mobile monitoring, you can monitor its performance directly from your Android device. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. For more help Additional documentation resources include: New Relic Android app (compatibility, requirements, installation) Android authentication (procedures to add or remove users, and for the users to authenticate with their Android device)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.34201,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> Synthetics",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> apps",
        "body": ". Then, <em>New</em> <em>Relic</em> sends a final, closing notification when all Critical events end. <em>Mobile</em> apps If you have a <em>mobile</em> application and have installed <em>mobile</em> <em>monitoring</em>, you can <em>monitor</em> its performance directly from your Android device. <em>Mobile</em> <em>monitoring</em> includes network errors, API calls, and number"
      },
      "id": "6044181d28ccbc9a522c60a5"
    },
    {
      "sections": [
        "Introduction to New Relic Android app",
        "Requirements",
        "Install New Relic's mobile app",
        "View New Relic data",
        "New Relic product details",
        "Synthetics data",
        "Alerts",
        "Mobile app monitoring",
        "Details on setting time range",
        "Data privacy"
      ],
      "title": "Introduction to New Relic Android app",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Android app"
      ],
      "external_id": "ff8415c00363a49eaa062f4b0b13c795b4717ea5",
      "image": "https://docs.newrelic.com/static/ea914fce17844b32fdabefd60efc457e/e5166/navigation_nexus.jpg",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/android-app/introduction-new-relic-android-app/",
      "published_at": "2021-09-14T07:28:16Z",
      "updated_at": "2021-09-14T07:28:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The user interface for New Relic's Android app provides functionality similar to New Relic's standard user interface, with customized details for mobile users. Requirements Requirements include: Android 4.0 (Ice Cream Sandwich) or higher Screen size of 7 inches or less Install New Relic's mobile app You can install the New Relic Android app from the Google Play Store or learn more from the New Relic website. Follow standard procedures to install any Android app, then sign in with your New Relic user name (account email) and password if applicable. Depending on your New Relic account, additional installation or user authentication steps may be required. View New Relic data To view details of your apps monitored by New Relic, select a product from the app's main menu. See below for details on how to use specific features of the app: New Relic product details The New Relic Android app includes data about these features: APM metrics, both real-time and historical data, including health maps. Select the transaction icon to see detailed transaction metrics, or an Overview chart to view summary charts of your top five transactions. Select the icon to filter by labels and categories. Browser monitoring metrics, including average page load time, Apdex, average throughput, and more. Infrastructure monitoring. Mobile monitoring, including crash reports, network errors, API calls, and active user count. Event notifications, including mobile alerts wherever you are, plus deployment notifications and notes. New Relic's Android app does not have the full feature set of the New Relic web interface. For more detailed analysis, sign in to your New Relic account with a web browser. Synthetics data You can use the Android app to view your synthetic monitoring data, including charts of your monitor's availability, load times, and load sizes. To view more detailed charts, select the caret icon. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you log in to your New Relic account from the Android app, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For Android alerts, notifications appear on your lock screen. To view them, tap the alert event. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile app monitoring If you have installed mobile monitoring, you can monitor its performance directly from your Android device. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. Details on setting time range When viewing an application or host, you can change the visible time frame with the time picker. To move back and forth across the timeline, scrub the New Relic charts. To change the duration of the visible time slice, select the clock icon. To specify an end time other than now, slide the toggle from Ending Now to Custom Date. To save your changes and refresh the chart data, select the clock icon again. Data privacy New Relic's mobile apps only record information needed to help authenticate and troubleshoot: User's email address associated with your New Relic account, including first and last name (for authentication purposes only) IP address Device ID For more information, see our Mobile data privacy and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.82385,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> Android app",
        "sections": "Install <em>New</em> <em>Relic&#x27;s</em> <em>mobile</em> app",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> apps",
        "body": " details or acknowledge the alert. <em>New</em> <em>Relic</em> also sends a push notification when a colleague acknowledges an open event. Then, <em>New</em> <em>Relic</em> sends a final, closing notification when all Critical events end. <em>Mobile</em> app <em>monitoring</em> If you have installed <em>mobile</em> <em>monitoring</em>, you can <em>monitor</em> its performance directly"
      },
      "id": "604415e0196a67ff23960f46"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile/get-started/security-mobile-apps": [
    {
      "sections": [
        "Introduction to iOS mobile app",
        "Features",
        "Time range",
        "Synthetic monitoring",
        "Alerts",
        "Mobile monitoring",
        "Data privacy"
      ],
      "title": "Introduction to iOS mobile app",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "iOS app"
      ],
      "external_id": "371077582a50dfd2a1e7c57cfbbf9eeaf8013e1c",
      "image": "https://docs.newrelic.com/static/630c7a9a486540073ab96a2c9926e303/442cb/device-ios-synthetics-view-monitor.png",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/ios-app/introduction-ios-mobile-app/",
      "published_at": "2021-09-14T07:29:48Z",
      "updated_at": "2021-09-14T07:29:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The user interface for New Relic's iPhone and iPad app provides functionality similar to New Relic's standard user interface, with customized details for mobile users. The New Relic iOS apps show near real-time information about your apps, hosts, and more. Features New Relic's iOS app includes these New Relic products and features: New Relic's iOS app for iPhone and iPad includes these New Relic products and features: APM (iPhone and iPad). Includes real-time and historical data. Select the icon to see transaction details. Select Overview Charts to view summary charts of your top five transactions. Browser monitoring (iPhone and iPad). Provide overview dashboard, including average page load time, browser Apdex, average throughput, and more. Infrastructure monitoring (iPhone only). Alerts (iPhone and iPad). Get alert and deployment notifications. Synthetic monitoring (iPhone only). Mobile monitoring (iPhone and iPad). Includes crash reports, network errors, API calls, and active user count. New Relic's iOS app does not have all the features of the New Relic web application. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the clock icon in the top right of the page. This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth across the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). For iPads: to specify an end time other than now, slide the toggle from Ending Now to Custom Date. Synthetic monitoring You can use the iOS app to view your synthetic monitoring data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you connect the iOS app to your New Relic account, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For iOS alerts, notifications appear on your lock screen and can be viewed by swiping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile monitoring If you have a mobile application and have installed mobile monitoring, you can monitor its performance directly from your iPhone or iPad. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. Data privacy New Relic's mobile apps only record information needed to help authenticate and troubleshoot: User's email address associated with your New Relic account, including first and last name (for authentication purposes only) IP address Device ID For more information, see our Mobile data privacy and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.5597,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to iOS <em>mobile</em> app",
        "sections": "<em>Mobile</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> apps",
        "body": " sends a push notification when a colleague acknowledges an open event. Then, <em>New</em> <em>Relic</em> sends a final, closing notification when all Critical events end. <em>Mobile</em> <em>monitoring</em> If you have a <em>mobile</em> application and have installed <em>mobile</em> <em>monitoring</em>, you can <em>monitor</em> its performance directly from your iPhone"
      },
      "id": "6044161628ccbc96b62c6092"
    },
    {
      "sections": [
        "Android app UI",
        "Pages",
        "Time range",
        "New Relic Synthetics",
        "Alerts",
        "Mobile apps",
        "For more help"
      ],
      "title": "Android app UI",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Android app"
      ],
      "external_id": "8918a5a2454491a91421c55e26501a0e3f64cd3a",
      "image": "https://docs.newrelic.com/static/fc97ade0bbdbdef58b89495a0d91b734/edd00/deployment-markers_nexus.jpg",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/android-app/android-app-ui/",
      "published_at": "2021-09-14T07:28:15Z",
      "updated_at": "2021-09-14T07:28:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The UI for the New Relic Android app provides functionality similar to the standard user interface, with customized details for mobile users. Pages To view details of your New Relic apps, hosts, Synthetics monitors, Alerts, plugins, and key transactions, select a product from the main menu. The New Relic Android app includes: APM metrics, both real-time and historical data, including health maps. And, select the transaction icon for detailed transaction metrics, or an Overview Charts to view summary charts of your top five transactions. New Relic Infrastructure utilization. New Relic Plugins, including a list of their components or instances, and their charts and current values from the plugin's Summary. Mobile monitoring, including crash reports, network errors, API calls, and active user count. Select the filter icon to filter by labels and categories. Event notifications, including mobile alerts wherever you are, plus deployment notifications and notes. Note: New Relic's Android app does not have the full feature set of the New Relic web interface. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the time picker icon in the top right of the page (the 7D in the screenshot). This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth in the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). New Relic Synthetics You can use the Android app to view your New Relic Synthetics data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you log in to your New Relic account from the Android app, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For Android alerts, notifications appear on your lock screen and can be viewed by tapping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile apps If you have a mobile application and have installed mobile monitoring, you can monitor its performance directly from your Android device. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. For more help Additional documentation resources include: New Relic Android app (compatibility, requirements, installation) Android authentication (procedures to add or remove users, and for the users to authenticate with their Android device)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.34192,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> Synthetics",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> apps",
        "body": ". Then, <em>New</em> <em>Relic</em> sends a final, closing notification when all Critical events end. <em>Mobile</em> apps If you have a <em>mobile</em> application and have installed <em>mobile</em> <em>monitoring</em>, you can <em>monitor</em> its performance directly from your Android device. <em>Mobile</em> <em>monitoring</em> includes network errors, API calls, and number"
      },
      "id": "6044181d28ccbc9a522c60a5"
    },
    {
      "sections": [
        "Introduction to New Relic Android app",
        "Requirements",
        "Install New Relic's mobile app",
        "View New Relic data",
        "New Relic product details",
        "Synthetics data",
        "Alerts",
        "Mobile app monitoring",
        "Details on setting time range",
        "Data privacy"
      ],
      "title": "Introduction to New Relic Android app",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Android app"
      ],
      "external_id": "ff8415c00363a49eaa062f4b0b13c795b4717ea5",
      "image": "https://docs.newrelic.com/static/ea914fce17844b32fdabefd60efc457e/e5166/navigation_nexus.jpg",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/android-app/introduction-new-relic-android-app/",
      "published_at": "2021-09-14T07:28:16Z",
      "updated_at": "2021-09-14T07:28:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The user interface for New Relic's Android app provides functionality similar to New Relic's standard user interface, with customized details for mobile users. Requirements Requirements include: Android 4.0 (Ice Cream Sandwich) or higher Screen size of 7 inches or less Install New Relic's mobile app You can install the New Relic Android app from the Google Play Store or learn more from the New Relic website. Follow standard procedures to install any Android app, then sign in with your New Relic user name (account email) and password if applicable. Depending on your New Relic account, additional installation or user authentication steps may be required. View New Relic data To view details of your apps monitored by New Relic, select a product from the app's main menu. See below for details on how to use specific features of the app: New Relic product details The New Relic Android app includes data about these features: APM metrics, both real-time and historical data, including health maps. Select the transaction icon to see detailed transaction metrics, or an Overview chart to view summary charts of your top five transactions. Select the icon to filter by labels and categories. Browser monitoring metrics, including average page load time, Apdex, average throughput, and more. Infrastructure monitoring. Mobile monitoring, including crash reports, network errors, API calls, and active user count. Event notifications, including mobile alerts wherever you are, plus deployment notifications and notes. New Relic's Android app does not have the full feature set of the New Relic web interface. For more detailed analysis, sign in to your New Relic account with a web browser. Synthetics data You can use the Android app to view your synthetic monitoring data, including charts of your monitor's availability, load times, and load sizes. To view more detailed charts, select the caret icon. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you log in to your New Relic account from the Android app, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For Android alerts, notifications appear on your lock screen. To view them, tap the alert event. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile app monitoring If you have installed mobile monitoring, you can monitor its performance directly from your Android device. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. Details on setting time range When viewing an application or host, you can change the visible time frame with the time picker. To move back and forth across the timeline, scrub the New Relic charts. To change the duration of the visible time slice, select the clock icon. To specify an end time other than now, slide the toggle from Ending Now to Custom Date. To save your changes and refresh the chart data, select the clock icon again. Data privacy New Relic's mobile apps only record information needed to help authenticate and troubleshoot: User's email address associated with your New Relic account, including first and last name (for authentication purposes only) IP address Device ID For more information, see our Mobile data privacy and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.82376,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> Android app",
        "sections": "Install <em>New</em> <em>Relic&#x27;s</em> <em>mobile</em> app",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> apps",
        "body": " details or acknowledge the alert. <em>New</em> <em>Relic</em> also sends a push notification when a colleague acknowledges an open event. Then, <em>New</em> <em>Relic</em> sends a final, closing notification when all Critical events end. <em>Mobile</em> app <em>monitoring</em> If you have installed <em>mobile</em> <em>monitoring</em>, you can <em>monitor</em> its performance directly"
      },
      "id": "604415e0196a67ff23960f46"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile/maintenance/add-custom-data-new-relic-mobile": [
    {
      "sections": [
        "Introduction to iOS mobile app",
        "Features",
        "Time range",
        "Synthetic monitoring",
        "Alerts",
        "Mobile monitoring",
        "Data privacy"
      ],
      "title": "Introduction to iOS mobile app",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "iOS app"
      ],
      "external_id": "371077582a50dfd2a1e7c57cfbbf9eeaf8013e1c",
      "image": "https://docs.newrelic.com/static/630c7a9a486540073ab96a2c9926e303/442cb/device-ios-synthetics-view-monitor.png",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/ios-app/introduction-ios-mobile-app/",
      "published_at": "2021-09-14T07:29:48Z",
      "updated_at": "2021-09-14T07:29:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The user interface for New Relic's iPhone and iPad app provides functionality similar to New Relic's standard user interface, with customized details for mobile users. The New Relic iOS apps show near real-time information about your apps, hosts, and more. Features New Relic's iOS app includes these New Relic products and features: New Relic's iOS app for iPhone and iPad includes these New Relic products and features: APM (iPhone and iPad). Includes real-time and historical data. Select the icon to see transaction details. Select Overview Charts to view summary charts of your top five transactions. Browser monitoring (iPhone and iPad). Provide overview dashboard, including average page load time, browser Apdex, average throughput, and more. Infrastructure monitoring (iPhone only). Alerts (iPhone and iPad). Get alert and deployment notifications. Synthetic monitoring (iPhone only). Mobile monitoring (iPhone and iPad). Includes crash reports, network errors, API calls, and active user count. New Relic's iOS app does not have all the features of the New Relic web application. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the clock icon in the top right of the page. This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth across the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). For iPads: to specify an end time other than now, slide the toggle from Ending Now to Custom Date. Synthetic monitoring You can use the iOS app to view your synthetic monitoring data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you connect the iOS app to your New Relic account, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For iOS alerts, notifications appear on your lock screen and can be viewed by swiping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile monitoring If you have a mobile application and have installed mobile monitoring, you can monitor its performance directly from your iPhone or iPad. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. Data privacy New Relic's mobile apps only record information needed to help authenticate and troubleshoot: User's email address associated with your New Relic account, including first and last name (for authentication purposes only) IP address Device ID For more information, see our Mobile data privacy and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.78897,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to iOS <em>mobile</em> app",
        "sections": "<em>Mobile</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> apps",
        "body": " sends a push notification when a colleague acknowledges an open event. Then, <em>New</em> <em>Relic</em> sends a final, closing notification when all Critical events end. <em>Mobile</em> <em>monitoring</em> If you have a <em>mobile</em> application and have installed <em>mobile</em> <em>monitoring</em>, you can <em>monitor</em> its performance directly from your iPhone"
      },
      "id": "6044161628ccbc96b62c6092"
    },
    {
      "sections": [
        "Android app UI",
        "Pages",
        "Time range",
        "New Relic Synthetics",
        "Alerts",
        "Mobile apps",
        "For more help"
      ],
      "title": "Android app UI",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Android app"
      ],
      "external_id": "8918a5a2454491a91421c55e26501a0e3f64cd3a",
      "image": "https://docs.newrelic.com/static/fc97ade0bbdbdef58b89495a0d91b734/edd00/deployment-markers_nexus.jpg",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/android-app/android-app-ui/",
      "published_at": "2021-09-14T07:28:15Z",
      "updated_at": "2021-09-14T07:28:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The UI for the New Relic Android app provides functionality similar to the standard user interface, with customized details for mobile users. Pages To view details of your New Relic apps, hosts, Synthetics monitors, Alerts, plugins, and key transactions, select a product from the main menu. The New Relic Android app includes: APM metrics, both real-time and historical data, including health maps. And, select the transaction icon for detailed transaction metrics, or an Overview Charts to view summary charts of your top five transactions. New Relic Infrastructure utilization. New Relic Plugins, including a list of their components or instances, and their charts and current values from the plugin's Summary. Mobile monitoring, including crash reports, network errors, API calls, and active user count. Select the filter icon to filter by labels and categories. Event notifications, including mobile alerts wherever you are, plus deployment notifications and notes. Note: New Relic's Android app does not have the full feature set of the New Relic web interface. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the time picker icon in the top right of the page (the 7D in the screenshot). This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth in the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). New Relic Synthetics You can use the Android app to view your New Relic Synthetics data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you log in to your New Relic account from the Android app, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For Android alerts, notifications appear on your lock screen and can be viewed by tapping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile apps If you have a mobile application and have installed mobile monitoring, you can monitor its performance directly from your Android device. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. For more help Additional documentation resources include: New Relic Android app (compatibility, requirements, installation) Android authentication (procedures to add or remove users, and for the users to authenticate with their Android device)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.7284,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> Synthetics",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> apps",
        "body": ". Then, <em>New</em> <em>Relic</em> sends a final, closing notification when all Critical events end. <em>Mobile</em> apps If you have a <em>mobile</em> application and have installed <em>mobile</em> <em>monitoring</em>, you can <em>monitor</em> its performance directly from your Android device. <em>Mobile</em> <em>monitoring</em> includes network errors, API calls, and number"
      },
      "id": "6044181d28ccbc9a522c60a5"
    },
    {
      "sections": [
        "Introduction to New Relic Android app",
        "Requirements",
        "Install New Relic's mobile app",
        "View New Relic data",
        "New Relic product details",
        "Synthetics data",
        "Alerts",
        "Mobile app monitoring",
        "Details on setting time range",
        "Data privacy"
      ],
      "title": "Introduction to New Relic Android app",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Android app"
      ],
      "external_id": "ff8415c00363a49eaa062f4b0b13c795b4717ea5",
      "image": "https://docs.newrelic.com/static/ea914fce17844b32fdabefd60efc457e/e5166/navigation_nexus.jpg",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/android-app/introduction-new-relic-android-app/",
      "published_at": "2021-09-14T07:28:16Z",
      "updated_at": "2021-09-14T07:28:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The user interface for New Relic's Android app provides functionality similar to New Relic's standard user interface, with customized details for mobile users. Requirements Requirements include: Android 4.0 (Ice Cream Sandwich) or higher Screen size of 7 inches or less Install New Relic's mobile app You can install the New Relic Android app from the Google Play Store or learn more from the New Relic website. Follow standard procedures to install any Android app, then sign in with your New Relic user name (account email) and password if applicable. Depending on your New Relic account, additional installation or user authentication steps may be required. View New Relic data To view details of your apps monitored by New Relic, select a product from the app's main menu. See below for details on how to use specific features of the app: New Relic product details The New Relic Android app includes data about these features: APM metrics, both real-time and historical data, including health maps. Select the transaction icon to see detailed transaction metrics, or an Overview chart to view summary charts of your top five transactions. Select the icon to filter by labels and categories. Browser monitoring metrics, including average page load time, Apdex, average throughput, and more. Infrastructure monitoring. Mobile monitoring, including crash reports, network errors, API calls, and active user count. Event notifications, including mobile alerts wherever you are, plus deployment notifications and notes. New Relic's Android app does not have the full feature set of the New Relic web interface. For more detailed analysis, sign in to your New Relic account with a web browser. Synthetics data You can use the Android app to view your synthetic monitoring data, including charts of your monitor's availability, load times, and load sizes. To view more detailed charts, select the caret icon. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you log in to your New Relic account from the Android app, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For Android alerts, notifications appear on your lock screen. To view them, tap the alert event. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile app monitoring If you have installed mobile monitoring, you can monitor its performance directly from your Android device. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. Details on setting time range When viewing an application or host, you can change the visible time frame with the time picker. To move back and forth across the timeline, scrub the New Relic charts. To change the duration of the visible time slice, select the clock icon. To specify an end time other than now, slide the toggle from Ending Now to Custom Date. To save your changes and refresh the chart data, select the clock icon again. Data privacy New Relic's mobile apps only record information needed to help authenticate and troubleshoot: User's email address associated with your New Relic account, including first and last name (for authentication purposes only) IP address Device ID For more information, see our Mobile data privacy and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.3297,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> Android app",
        "sections": "Install <em>New</em> <em>Relic&#x27;s</em> <em>mobile</em> app",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> apps",
        "body": " details or acknowledge the alert. <em>New</em> <em>Relic</em> also sends a push notification when a colleague acknowledges an open event. Then, <em>New</em> <em>Relic</em> sends a final, closing notification when all Critical events end. <em>Mobile</em> app <em>monitoring</em> If you have installed <em>mobile</em> <em>monitoring</em>, you can <em>monitor</em> its performance directly"
      },
      "id": "604415e0196a67ff23960f46"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile/maintenance/customizing-your-mobile-app-settings": [
    {
      "sections": [
        "Introduction to iOS mobile app",
        "Features",
        "Time range",
        "Synthetic monitoring",
        "Alerts",
        "Mobile monitoring",
        "Data privacy"
      ],
      "title": "Introduction to iOS mobile app",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "iOS app"
      ],
      "external_id": "371077582a50dfd2a1e7c57cfbbf9eeaf8013e1c",
      "image": "https://docs.newrelic.com/static/630c7a9a486540073ab96a2c9926e303/442cb/device-ios-synthetics-view-monitor.png",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/ios-app/introduction-ios-mobile-app/",
      "published_at": "2021-09-14T07:29:48Z",
      "updated_at": "2021-09-14T07:29:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The user interface for New Relic's iPhone and iPad app provides functionality similar to New Relic's standard user interface, with customized details for mobile users. The New Relic iOS apps show near real-time information about your apps, hosts, and more. Features New Relic's iOS app includes these New Relic products and features: New Relic's iOS app for iPhone and iPad includes these New Relic products and features: APM (iPhone and iPad). Includes real-time and historical data. Select the icon to see transaction details. Select Overview Charts to view summary charts of your top five transactions. Browser monitoring (iPhone and iPad). Provide overview dashboard, including average page load time, browser Apdex, average throughput, and more. Infrastructure monitoring (iPhone only). Alerts (iPhone and iPad). Get alert and deployment notifications. Synthetic monitoring (iPhone only). Mobile monitoring (iPhone and iPad). Includes crash reports, network errors, API calls, and active user count. New Relic's iOS app does not have all the features of the New Relic web application. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the clock icon in the top right of the page. This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth across the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). For iPads: to specify an end time other than now, slide the toggle from Ending Now to Custom Date. Synthetic monitoring You can use the iOS app to view your synthetic monitoring data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you connect the iOS app to your New Relic account, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For iOS alerts, notifications appear on your lock screen and can be viewed by swiping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile monitoring If you have a mobile application and have installed mobile monitoring, you can monitor its performance directly from your iPhone or iPad. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. Data privacy New Relic's mobile apps only record information needed to help authenticate and troubleshoot: User's email address associated with your New Relic account, including first and last name (for authentication purposes only) IP address Device ID For more information, see our Mobile data privacy and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.78886,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to iOS <em>mobile</em> app",
        "sections": "<em>Mobile</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> apps",
        "body": " sends a push notification when a colleague acknowledges an open event. Then, <em>New</em> <em>Relic</em> sends a final, closing notification when all Critical events end. <em>Mobile</em> <em>monitoring</em> If you have a <em>mobile</em> application and have installed <em>mobile</em> <em>monitoring</em>, you can <em>monitor</em> its performance directly from your iPhone"
      },
      "id": "6044161628ccbc96b62c6092"
    },
    {
      "sections": [
        "Android app UI",
        "Pages",
        "Time range",
        "New Relic Synthetics",
        "Alerts",
        "Mobile apps",
        "For more help"
      ],
      "title": "Android app UI",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Android app"
      ],
      "external_id": "8918a5a2454491a91421c55e26501a0e3f64cd3a",
      "image": "https://docs.newrelic.com/static/fc97ade0bbdbdef58b89495a0d91b734/edd00/deployment-markers_nexus.jpg",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/android-app/android-app-ui/",
      "published_at": "2021-09-14T07:28:15Z",
      "updated_at": "2021-09-14T07:28:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The UI for the New Relic Android app provides functionality similar to the standard user interface, with customized details for mobile users. Pages To view details of your New Relic apps, hosts, Synthetics monitors, Alerts, plugins, and key transactions, select a product from the main menu. The New Relic Android app includes: APM metrics, both real-time and historical data, including health maps. And, select the transaction icon for detailed transaction metrics, or an Overview Charts to view summary charts of your top five transactions. New Relic Infrastructure utilization. New Relic Plugins, including a list of their components or instances, and their charts and current values from the plugin's Summary. Mobile monitoring, including crash reports, network errors, API calls, and active user count. Select the filter icon to filter by labels and categories. Event notifications, including mobile alerts wherever you are, plus deployment notifications and notes. Note: New Relic's Android app does not have the full feature set of the New Relic web interface. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the time picker icon in the top right of the page (the 7D in the screenshot). This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth in the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). New Relic Synthetics You can use the Android app to view your New Relic Synthetics data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you log in to your New Relic account from the Android app, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For Android alerts, notifications appear on your lock screen and can be viewed by tapping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile apps If you have a mobile application and have installed mobile monitoring, you can monitor its performance directly from your Android device. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. For more help Additional documentation resources include: New Relic Android app (compatibility, requirements, installation) Android authentication (procedures to add or remove users, and for the users to authenticate with their Android device)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.7283,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> Synthetics",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> apps",
        "body": ". Then, <em>New</em> <em>Relic</em> sends a final, closing notification when all Critical events end. <em>Mobile</em> apps If you have a <em>mobile</em> application and have installed <em>mobile</em> <em>monitoring</em>, you can <em>monitor</em> its performance directly from your Android device. <em>Mobile</em> <em>monitoring</em> includes network errors, API calls, and number"
      },
      "id": "6044181d28ccbc9a522c60a5"
    },
    {
      "sections": [
        "Introduction to New Relic Android app",
        "Requirements",
        "Install New Relic's mobile app",
        "View New Relic data",
        "New Relic product details",
        "Synthetics data",
        "Alerts",
        "Mobile app monitoring",
        "Details on setting time range",
        "Data privacy"
      ],
      "title": "Introduction to New Relic Android app",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Android app"
      ],
      "external_id": "ff8415c00363a49eaa062f4b0b13c795b4717ea5",
      "image": "https://docs.newrelic.com/static/ea914fce17844b32fdabefd60efc457e/e5166/navigation_nexus.jpg",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/android-app/introduction-new-relic-android-app/",
      "published_at": "2021-09-14T07:28:16Z",
      "updated_at": "2021-09-14T07:28:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The user interface for New Relic's Android app provides functionality similar to New Relic's standard user interface, with customized details for mobile users. Requirements Requirements include: Android 4.0 (Ice Cream Sandwich) or higher Screen size of 7 inches or less Install New Relic's mobile app You can install the New Relic Android app from the Google Play Store or learn more from the New Relic website. Follow standard procedures to install any Android app, then sign in with your New Relic user name (account email) and password if applicable. Depending on your New Relic account, additional installation or user authentication steps may be required. View New Relic data To view details of your apps monitored by New Relic, select a product from the app's main menu. See below for details on how to use specific features of the app: New Relic product details The New Relic Android app includes data about these features: APM metrics, both real-time and historical data, including health maps. Select the transaction icon to see detailed transaction metrics, or an Overview chart to view summary charts of your top five transactions. Select the icon to filter by labels and categories. Browser monitoring metrics, including average page load time, Apdex, average throughput, and more. Infrastructure monitoring. Mobile monitoring, including crash reports, network errors, API calls, and active user count. Event notifications, including mobile alerts wherever you are, plus deployment notifications and notes. New Relic's Android app does not have the full feature set of the New Relic web interface. For more detailed analysis, sign in to your New Relic account with a web browser. Synthetics data You can use the Android app to view your synthetic monitoring data, including charts of your monitor's availability, load times, and load sizes. To view more detailed charts, select the caret icon. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you log in to your New Relic account from the Android app, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For Android alerts, notifications appear on your lock screen. To view them, tap the alert event. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile app monitoring If you have installed mobile monitoring, you can monitor its performance directly from your Android device. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. Details on setting time range When viewing an application or host, you can change the visible time frame with the time picker. To move back and forth across the timeline, scrub the New Relic charts. To change the duration of the visible time slice, select the clock icon. To specify an end time other than now, slide the toggle from Ending Now to Custom Date. To save your changes and refresh the chart data, select the clock icon again. Data privacy New Relic's mobile apps only record information needed to help authenticate and troubleshoot: User's email address associated with your New Relic account, including first and last name (for authentication purposes only) IP address Device ID For more information, see our Mobile data privacy and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.32959,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> Android app",
        "sections": "Install <em>New</em> <em>Relic&#x27;s</em> <em>mobile</em> app",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> apps",
        "body": " details or acknowledge the alert. <em>New</em> <em>Relic</em> also sends a push notification when a colleague acknowledges an open event. Then, <em>New</em> <em>Relic</em> sends a final, closing notification when all Critical events end. <em>Mobile</em> app <em>monitoring</em> If you have installed <em>mobile</em> <em>monitoring</em>, you can <em>monitor</em> its performance directly"
      },
      "id": "604415e0196a67ff23960f46"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile/maintenance/viewing-your-application-token": [
    {
      "sections": [
        "Introduction to iOS mobile app",
        "Features",
        "Time range",
        "Synthetic monitoring",
        "Alerts",
        "Mobile monitoring",
        "Data privacy"
      ],
      "title": "Introduction to iOS mobile app",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "iOS app"
      ],
      "external_id": "371077582a50dfd2a1e7c57cfbbf9eeaf8013e1c",
      "image": "https://docs.newrelic.com/static/630c7a9a486540073ab96a2c9926e303/442cb/device-ios-synthetics-view-monitor.png",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/ios-app/introduction-ios-mobile-app/",
      "published_at": "2021-09-14T07:29:48Z",
      "updated_at": "2021-09-14T07:29:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The user interface for New Relic's iPhone and iPad app provides functionality similar to New Relic's standard user interface, with customized details for mobile users. The New Relic iOS apps show near real-time information about your apps, hosts, and more. Features New Relic's iOS app includes these New Relic products and features: New Relic's iOS app for iPhone and iPad includes these New Relic products and features: APM (iPhone and iPad). Includes real-time and historical data. Select the icon to see transaction details. Select Overview Charts to view summary charts of your top five transactions. Browser monitoring (iPhone and iPad). Provide overview dashboard, including average page load time, browser Apdex, average throughput, and more. Infrastructure monitoring (iPhone only). Alerts (iPhone and iPad). Get alert and deployment notifications. Synthetic monitoring (iPhone only). Mobile monitoring (iPhone and iPad). Includes crash reports, network errors, API calls, and active user count. New Relic's iOS app does not have all the features of the New Relic web application. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the clock icon in the top right of the page. This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth across the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). For iPads: to specify an end time other than now, slide the toggle from Ending Now to Custom Date. Synthetic monitoring You can use the iOS app to view your synthetic monitoring data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you connect the iOS app to your New Relic account, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For iOS alerts, notifications appear on your lock screen and can be viewed by swiping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile monitoring If you have a mobile application and have installed mobile monitoring, you can monitor its performance directly from your iPhone or iPad. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. Data privacy New Relic's mobile apps only record information needed to help authenticate and troubleshoot: User's email address associated with your New Relic account, including first and last name (for authentication purposes only) IP address Device ID For more information, see our Mobile data privacy and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.78886,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to iOS <em>mobile</em> app",
        "sections": "<em>Mobile</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> apps",
        "body": " sends a push notification when a colleague acknowledges an open event. Then, <em>New</em> <em>Relic</em> sends a final, closing notification when all Critical events end. <em>Mobile</em> <em>monitoring</em> If you have a <em>mobile</em> application and have installed <em>mobile</em> <em>monitoring</em>, you can <em>monitor</em> its performance directly from your iPhone"
      },
      "id": "6044161628ccbc96b62c6092"
    },
    {
      "sections": [
        "Android app UI",
        "Pages",
        "Time range",
        "New Relic Synthetics",
        "Alerts",
        "Mobile apps",
        "For more help"
      ],
      "title": "Android app UI",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Android app"
      ],
      "external_id": "8918a5a2454491a91421c55e26501a0e3f64cd3a",
      "image": "https://docs.newrelic.com/static/fc97ade0bbdbdef58b89495a0d91b734/edd00/deployment-markers_nexus.jpg",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/android-app/android-app-ui/",
      "published_at": "2021-09-14T07:28:15Z",
      "updated_at": "2021-09-14T07:28:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The UI for the New Relic Android app provides functionality similar to the standard user interface, with customized details for mobile users. Pages To view details of your New Relic apps, hosts, Synthetics monitors, Alerts, plugins, and key transactions, select a product from the main menu. The New Relic Android app includes: APM metrics, both real-time and historical data, including health maps. And, select the transaction icon for detailed transaction metrics, or an Overview Charts to view summary charts of your top five transactions. New Relic Infrastructure utilization. New Relic Plugins, including a list of their components or instances, and their charts and current values from the plugin's Summary. Mobile monitoring, including crash reports, network errors, API calls, and active user count. Select the filter icon to filter by labels and categories. Event notifications, including mobile alerts wherever you are, plus deployment notifications and notes. Note: New Relic's Android app does not have the full feature set of the New Relic web interface. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the time picker icon in the top right of the page (the 7D in the screenshot). This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth in the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). New Relic Synthetics You can use the Android app to view your New Relic Synthetics data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you log in to your New Relic account from the Android app, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For Android alerts, notifications appear on your lock screen and can be viewed by tapping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile apps If you have a mobile application and have installed mobile monitoring, you can monitor its performance directly from your Android device. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. For more help Additional documentation resources include: New Relic Android app (compatibility, requirements, installation) Android authentication (procedures to add or remove users, and for the users to authenticate with their Android device)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.7283,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> Synthetics",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> apps",
        "body": ". Then, <em>New</em> <em>Relic</em> sends a final, closing notification when all Critical events end. <em>Mobile</em> apps If you have a <em>mobile</em> application and have installed <em>mobile</em> <em>monitoring</em>, you can <em>monitor</em> its performance directly from your Android device. <em>Mobile</em> <em>monitoring</em> includes network errors, API calls, and number"
      },
      "id": "6044181d28ccbc9a522c60a5"
    },
    {
      "sections": [
        "Introduction to New Relic Android app",
        "Requirements",
        "Install New Relic's mobile app",
        "View New Relic data",
        "New Relic product details",
        "Synthetics data",
        "Alerts",
        "Mobile app monitoring",
        "Details on setting time range",
        "Data privacy"
      ],
      "title": "Introduction to New Relic Android app",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Android app"
      ],
      "external_id": "ff8415c00363a49eaa062f4b0b13c795b4717ea5",
      "image": "https://docs.newrelic.com/static/ea914fce17844b32fdabefd60efc457e/e5166/navigation_nexus.jpg",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/android-app/introduction-new-relic-android-app/",
      "published_at": "2021-09-14T07:28:16Z",
      "updated_at": "2021-09-14T07:28:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The user interface for New Relic's Android app provides functionality similar to New Relic's standard user interface, with customized details for mobile users. Requirements Requirements include: Android 4.0 (Ice Cream Sandwich) or higher Screen size of 7 inches or less Install New Relic's mobile app You can install the New Relic Android app from the Google Play Store or learn more from the New Relic website. Follow standard procedures to install any Android app, then sign in with your New Relic user name (account email) and password if applicable. Depending on your New Relic account, additional installation or user authentication steps may be required. View New Relic data To view details of your apps monitored by New Relic, select a product from the app's main menu. See below for details on how to use specific features of the app: New Relic product details The New Relic Android app includes data about these features: APM metrics, both real-time and historical data, including health maps. Select the transaction icon to see detailed transaction metrics, or an Overview chart to view summary charts of your top five transactions. Select the icon to filter by labels and categories. Browser monitoring metrics, including average page load time, Apdex, average throughput, and more. Infrastructure monitoring. Mobile monitoring, including crash reports, network errors, API calls, and active user count. Event notifications, including mobile alerts wherever you are, plus deployment notifications and notes. New Relic's Android app does not have the full feature set of the New Relic web interface. For more detailed analysis, sign in to your New Relic account with a web browser. Synthetics data You can use the Android app to view your synthetic monitoring data, including charts of your monitor's availability, load times, and load sizes. To view more detailed charts, select the caret icon. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you log in to your New Relic account from the Android app, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For Android alerts, notifications appear on your lock screen. To view them, tap the alert event. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile app monitoring If you have installed mobile monitoring, you can monitor its performance directly from your Android device. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. Details on setting time range When viewing an application or host, you can change the visible time frame with the time picker. To move back and forth across the timeline, scrub the New Relic charts. To change the duration of the visible time slice, select the clock icon. To specify an end time other than now, slide the toggle from Ending Now to Custom Date. To save your changes and refresh the chart data, select the clock icon again. Data privacy New Relic's mobile apps only record information needed to help authenticate and troubleshoot: User's email address associated with your New Relic account, including first and last name (for authentication purposes only) IP address Device ID For more information, see our Mobile data privacy and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.32959,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> Android app",
        "sections": "Install <em>New</em> <em>Relic&#x27;s</em> <em>mobile</em> app",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> apps",
        "body": " details or acknowledge the alert. <em>New</em> <em>Relic</em> also sends a push notification when a colleague acknowledges an open event. Then, <em>New</em> <em>Relic</em> sends a final, closing notification when all Critical events end. <em>Mobile</em> app <em>monitoring</em> If you have installed <em>mobile</em> <em>monitoring</em>, you can <em>monitor</em> its performance directly"
      },
      "id": "604415e0196a67ff23960f46"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/crashnow-android-sdk-api": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-09-14T07:43:31Z",
      "updated_at": "2021-07-08T02:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.28036,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-09-14T10:06:20Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.89563,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    },
    {
      "sections": [
        "noticeHttpTransaction (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record HTTP transaction"
      ],
      "title": "noticeHttpTransaction (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "3232e4a19b883d229a9611a2a5cc7b4a002c9f84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-http-transaction/",
      "published_at": "2021-09-14T08:04:55Z",
      "updated_at": "2021-07-09T15:31:23Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeHttpTransaction(string $url, string $httpMethod, int $statusCode, long $startTime, long $endTime, long $bytesSent, long $bytesReceived [, string $responseBody]) Copy Tracks networks requests. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests and network failures. You can use noticeHttpTransaction to record HTTP transactions, with an option to also send a response body. If a network request fails, you can record details about the failure with noticeNetworkFailure(). For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK. $startTime int Required. The start time of the request in milliseconds since the epoch. $endTime int Required. The end time of the request in milliseconds since the epoch. $bytesSent int Required. The number of bytes sent in the request. $bytesReceived int Required. The number of bytes received in the response. $responseBody string Optional. The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. Examples Record HTTP transaction An example of tracking an HTTP transaction: public class CustomHttpMetricsLogger implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); //collect request start time long t1 = System.nanoTime(); //get the size of the request body long requestSize = null == request.body() ? 0 : request.body().contentLength(); //proceed with the request Response response = chain.proceed(request); //capture the time when response returns long t2 = System.nanoTime(); long responseSize = null == response.body() ? 0 : response.body().contentLength(); //tell New Relic to notice this request NewRelic.noticeHttpTransaction(request.urlString(), request.method(), response.code(), t1, t2, requestSize, responseSize); //return response for processing return response; } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.88034,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " info on using the <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em>, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK"
      },
      "id": "6044e8b6e7b9d26e235799e9"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/currentsessionid-android-sdk-api": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-09-14T07:43:31Z",
      "updated_at": "2021-07-08T02:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.28036,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-09-14T10:06:20Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.89563,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    },
    {
      "sections": [
        "noticeHttpTransaction (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record HTTP transaction"
      ],
      "title": "noticeHttpTransaction (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "3232e4a19b883d229a9611a2a5cc7b4a002c9f84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-http-transaction/",
      "published_at": "2021-09-14T08:04:55Z",
      "updated_at": "2021-07-09T15:31:23Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeHttpTransaction(string $url, string $httpMethod, int $statusCode, long $startTime, long $endTime, long $bytesSent, long $bytesReceived [, string $responseBody]) Copy Tracks networks requests. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests and network failures. You can use noticeHttpTransaction to record HTTP transactions, with an option to also send a response body. If a network request fails, you can record details about the failure with noticeNetworkFailure(). For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK. $startTime int Required. The start time of the request in milliseconds since the epoch. $endTime int Required. The end time of the request in milliseconds since the epoch. $bytesSent int Required. The number of bytes sent in the request. $bytesReceived int Required. The number of bytes received in the response. $responseBody string Optional. The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. Examples Record HTTP transaction An example of tracking an HTTP transaction: public class CustomHttpMetricsLogger implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); //collect request start time long t1 = System.nanoTime(); //get the size of the request body long requestSize = null == request.body() ? 0 : request.body().contentLength(); //proceed with the request Response response = chain.proceed(request); //capture the time when response returns long t2 = System.nanoTime(); long responseSize = null == response.body() ? 0 : response.body().contentLength(); //tell New Relic to notice this request NewRelic.noticeHttpTransaction(request.urlString(), request.method(), response.code(), t1, t2, requestSize, responseSize); //return response for processing return response; } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.88034,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " info on using the <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em>, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK"
      },
      "id": "6044e8b6e7b9d26e235799e9"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/end-interaction": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-09-14T07:43:31Z",
      "updated_at": "2021-07-08T02:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.28036,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-09-14T10:06:20Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.89563,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    },
    {
      "sections": [
        "noticeHttpTransaction (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record HTTP transaction"
      ],
      "title": "noticeHttpTransaction (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "3232e4a19b883d229a9611a2a5cc7b4a002c9f84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-http-transaction/",
      "published_at": "2021-09-14T08:04:55Z",
      "updated_at": "2021-07-09T15:31:23Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeHttpTransaction(string $url, string $httpMethod, int $statusCode, long $startTime, long $endTime, long $bytesSent, long $bytesReceived [, string $responseBody]) Copy Tracks networks requests. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests and network failures. You can use noticeHttpTransaction to record HTTP transactions, with an option to also send a response body. If a network request fails, you can record details about the failure with noticeNetworkFailure(). For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK. $startTime int Required. The start time of the request in milliseconds since the epoch. $endTime int Required. The end time of the request in milliseconds since the epoch. $bytesSent int Required. The number of bytes sent in the request. $bytesReceived int Required. The number of bytes received in the response. $responseBody string Optional. The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. Examples Record HTTP transaction An example of tracking an HTTP transaction: public class CustomHttpMetricsLogger implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); //collect request start time long t1 = System.nanoTime(); //get the size of the request body long requestSize = null == request.body() ? 0 : request.body().contentLength(); //proceed with the request Response response = chain.proceed(request); //capture the time when response returns long t2 = System.nanoTime(); long responseSize = null == response.body() ? 0 : response.body().contentLength(); //tell New Relic to notice this request NewRelic.noticeHttpTransaction(request.urlString(), request.method(), response.code(), t1, t2, requestSize, responseSize); //return response for processing return response; } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.88034,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " info on using the <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em>, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK"
      },
      "id": "6044e8b6e7b9d26e235799e9"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/increment-attribute": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-09-14T07:43:31Z",
      "updated_at": "2021-07-08T02:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.28036,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-09-14T10:06:20Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.89563,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    },
    {
      "sections": [
        "noticeHttpTransaction (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record HTTP transaction"
      ],
      "title": "noticeHttpTransaction (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "3232e4a19b883d229a9611a2a5cc7b4a002c9f84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-http-transaction/",
      "published_at": "2021-09-14T08:04:55Z",
      "updated_at": "2021-07-09T15:31:23Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeHttpTransaction(string $url, string $httpMethod, int $statusCode, long $startTime, long $endTime, long $bytesSent, long $bytesReceived [, string $responseBody]) Copy Tracks networks requests. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests and network failures. You can use noticeHttpTransaction to record HTTP transactions, with an option to also send a response body. If a network request fails, you can record details about the failure with noticeNetworkFailure(). For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK. $startTime int Required. The start time of the request in milliseconds since the epoch. $endTime int Required. The end time of the request in milliseconds since the epoch. $bytesSent int Required. The number of bytes sent in the request. $bytesReceived int Required. The number of bytes received in the response. $responseBody string Optional. The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. Examples Record HTTP transaction An example of tracking an HTTP transaction: public class CustomHttpMetricsLogger implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); //collect request start time long t1 = System.nanoTime(); //get the size of the request body long requestSize = null == request.body() ? 0 : request.body().contentLength(); //proceed with the request Response response = chain.proceed(request); //capture the time when response returns long t2 = System.nanoTime(); long responseSize = null == response.body() ? 0 : response.body().contentLength(); //tell New Relic to notice this request NewRelic.noticeHttpTransaction(request.urlString(), request.method(), response.code(), t1, t2, requestSize, responseSize); //return response for processing return response; } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.88034,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " info on using the <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em>, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK"
      },
      "id": "6044e8b6e7b9d26e235799e9"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/index": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-09-14T07:43:31Z",
      "updated_at": "2021-07-08T02:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 836.55927,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> monitoring",
        "sections": "Introduction to <em>Android</em> monitoring",
        "tags": "New Relic Mobile <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-09-14T10:06:20Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 833.35535,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>Android</em> <em>SDK</em> <em>API</em>",
        "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    },
    {
      "sections": [
        "noticeHttpTransaction (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record HTTP transaction"
      ],
      "title": "noticeHttpTransaction (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "3232e4a19b883d229a9611a2a5cc7b4a002c9f84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-http-transaction/",
      "published_at": "2021-09-14T08:04:55Z",
      "updated_at": "2021-07-09T15:31:23Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeHttpTransaction(string $url, string $httpMethod, int $statusCode, long $startTime, long $endTime, long $bytesSent, long $bytesReceived [, string $responseBody]) Copy Tracks networks requests. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests and network failures. You can use noticeHttpTransaction to record HTTP transactions, with an option to also send a response body. If a network request fails, you can record details about the failure with noticeNetworkFailure(). For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK. $startTime int Required. The start time of the request in milliseconds since the epoch. $endTime int Required. The end time of the request in milliseconds since the epoch. $bytesSent int Required. The number of bytes sent in the request. $bytesReceived int Required. The number of bytes received in the response. $responseBody string Optional. The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. Examples Record HTTP transaction An example of tracking an HTTP transaction: public class CustomHttpMetricsLogger implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); //collect request start time long t1 = System.nanoTime(); //get the size of the request body long requestSize = null == request.body() ? 0 : request.body().contentLength(); //proceed with the request Response response = chain.proceed(request); //capture the time when response returns long t2 = System.nanoTime(); long responseSize = null == response.body() ? 0 : response.body().contentLength(); //tell New Relic to notice this request NewRelic.noticeHttpTransaction(request.urlString(), request.method(), response.code(), t1, t2, requestSize, responseSize); //return response for processing return response; } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 797.2179,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>Android</em> <em>SDK</em> <em>API</em>",
        "body": " info on using the New Relic <em>Android</em> <em>SDK</em> <em>API</em>, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK"
      },
      "id": "6044e8b6e7b9d26e235799e9"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-http-transaction": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-09-14T07:43:31Z",
      "updated_at": "2021-07-08T02:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.28036,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-09-14T10:06:20Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.89563,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    },
    {
      "sections": [
        "withInteractionTracing (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Important",
        "Parameters",
        "Examples",
        "Disable interactions"
      ],
      "title": "withInteractionTracing (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "6d1a07a30d8f136d1155ab478bd83c35343e69de",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/with-interaction-tracing/",
      "published_at": "2021-09-14T07:40:37Z",
      "updated_at": "2021-07-09T14:56:27Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.withInteractionTracing(boolean $tracingFlag) Copy Globally disable/enable interaction tracing. Requirements Agent version 5.4.0 or higher. Description Use withInteractionTracing() to globally enable or disable interaction traces, which appear on the Interactions page. Ensure you call this before the New Relic agent start call. Important Interaction tracing will be disabled after the agent has started. Interactions for any activity or methods executed prior to starting the agent may still appear in the Interactions page. For general info on using this API, see the Android SDK API usage guide. Parameters Parameter Description tracingFlag boolean Required. Use false to disable interaction tracing. Use true to enable tracing. Tracing is on by default. Examples Disable interactions To turn off all interaction traces collected by the Android agent: NewRelic.withInteractionTracing(false) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.20572,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "withInteractionTracing (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "withInteractionTracing (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " call this before the <em>New</em> <em>Relic</em> agent start call. Important Interaction tracing will be disabled after the agent has started. Interactions for any activity or methods executed prior to starting the agent may still appear in the Interactions page. For general info on using this <em>API</em>, see the <em>Android</em> <em>SDK</em>"
      },
      "id": "6044e9c3e7b9d22fc05799cb"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-09-14T07:43:31Z",
      "updated_at": "2021-07-08T02:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.28036,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "noticeHttpTransaction (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record HTTP transaction"
      ],
      "title": "noticeHttpTransaction (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "3232e4a19b883d229a9611a2a5cc7b4a002c9f84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-http-transaction/",
      "published_at": "2021-09-14T08:04:55Z",
      "updated_at": "2021-07-09T15:31:23Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeHttpTransaction(string $url, string $httpMethod, int $statusCode, long $startTime, long $endTime, long $bytesSent, long $bytesReceived [, string $responseBody]) Copy Tracks networks requests. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests and network failures. You can use noticeHttpTransaction to record HTTP transactions, with an option to also send a response body. If a network request fails, you can record details about the failure with noticeNetworkFailure(). For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK. $startTime int Required. The start time of the request in milliseconds since the epoch. $endTime int Required. The end time of the request in milliseconds since the epoch. $bytesSent int Required. The number of bytes sent in the request. $bytesReceived int Required. The number of bytes received in the response. $responseBody string Optional. The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. Examples Record HTTP transaction An example of tracking an HTTP transaction: public class CustomHttpMetricsLogger implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); //collect request start time long t1 = System.nanoTime(); //get the size of the request body long requestSize = null == request.body() ? 0 : request.body().contentLength(); //proceed with the request Response response = chain.proceed(request); //capture the time when response returns long t2 = System.nanoTime(); long responseSize = null == response.body() ? 0 : response.body().contentLength(); //tell New Relic to notice this request NewRelic.noticeHttpTransaction(request.urlString(), request.method(), response.code(), t1, t2, requestSize, responseSize); //return response for processing return response; } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.88034,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " info on using the <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em>, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK"
      },
      "id": "6044e8b6e7b9d26e235799e9"
    },
    {
      "sections": [
        "withInteractionTracing (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Important",
        "Parameters",
        "Examples",
        "Disable interactions"
      ],
      "title": "withInteractionTracing (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "6d1a07a30d8f136d1155ab478bd83c35343e69de",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/with-interaction-tracing/",
      "published_at": "2021-09-14T07:40:37Z",
      "updated_at": "2021-07-09T14:56:27Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.withInteractionTracing(boolean $tracingFlag) Copy Globally disable/enable interaction tracing. Requirements Agent version 5.4.0 or higher. Description Use withInteractionTracing() to globally enable or disable interaction traces, which appear on the Interactions page. Ensure you call this before the New Relic agent start call. Important Interaction tracing will be disabled after the agent has started. Interactions for any activity or methods executed prior to starting the agent may still appear in the Interactions page. For general info on using this API, see the Android SDK API usage guide. Parameters Parameter Description tracingFlag boolean Required. Use false to disable interaction tracing. Use true to enable tracing. Tracing is on by default. Examples Disable interactions To turn off all interaction traces collected by the Android agent: NewRelic.withInteractionTracing(false) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.20572,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "withInteractionTracing (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "withInteractionTracing (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " call this before the <em>New</em> <em>Relic</em> agent start call. Important Interaction tracing will be disabled after the agent has started. Interactions for any activity or methods executed prior to starting the agent may still appear in the Interactions page. For general info on using this <em>API</em>, see the <em>Android</em> <em>SDK</em>"
      },
      "id": "6044e9c3e7b9d22fc05799cb"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/recordbreadcrumb": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-09-14T07:43:31Z",
      "updated_at": "2021-07-08T02:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.28036,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-09-14T10:06:20Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.89561,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    },
    {
      "sections": [
        "noticeHttpTransaction (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record HTTP transaction"
      ],
      "title": "noticeHttpTransaction (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "3232e4a19b883d229a9611a2a5cc7b4a002c9f84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-http-transaction/",
      "published_at": "2021-09-14T08:04:55Z",
      "updated_at": "2021-07-09T15:31:23Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeHttpTransaction(string $url, string $httpMethod, int $statusCode, long $startTime, long $endTime, long $bytesSent, long $bytesReceived [, string $responseBody]) Copy Tracks networks requests. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests and network failures. You can use noticeHttpTransaction to record HTTP transactions, with an option to also send a response body. If a network request fails, you can record details about the failure with noticeNetworkFailure(). For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK. $startTime int Required. The start time of the request in milliseconds since the epoch. $endTime int Required. The end time of the request in milliseconds since the epoch. $bytesSent int Required. The number of bytes sent in the request. $bytesReceived int Required. The number of bytes received in the response. $responseBody string Optional. The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. Examples Record HTTP transaction An example of tracking an HTTP transaction: public class CustomHttpMetricsLogger implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); //collect request start time long t1 = System.nanoTime(); //get the size of the request body long requestSize = null == request.body() ? 0 : request.body().contentLength(); //proceed with the request Response response = chain.proceed(request); //capture the time when response returns long t2 = System.nanoTime(); long responseSize = null == response.body() ? 0 : response.body().contentLength(); //tell New Relic to notice this request NewRelic.noticeHttpTransaction(request.urlString(), request.method(), response.code(), t1, t2, requestSize, responseSize); //return response for processing return response; } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.88034,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " info on using the <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em>, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK"
      },
      "id": "6044e8b6e7b9d26e235799e9"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/recordcustomevent-android-sdk-api": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-09-14T07:43:31Z",
      "updated_at": "2021-07-08T02:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.28036,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-09-14T10:06:20Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.89561,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    },
    {
      "sections": [
        "noticeHttpTransaction (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record HTTP transaction"
      ],
      "title": "noticeHttpTransaction (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "3232e4a19b883d229a9611a2a5cc7b4a002c9f84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-http-transaction/",
      "published_at": "2021-09-14T08:04:55Z",
      "updated_at": "2021-07-09T15:31:23Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeHttpTransaction(string $url, string $httpMethod, int $statusCode, long $startTime, long $endTime, long $bytesSent, long $bytesReceived [, string $responseBody]) Copy Tracks networks requests. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests and network failures. You can use noticeHttpTransaction to record HTTP transactions, with an option to also send a response body. If a network request fails, you can record details about the failure with noticeNetworkFailure(). For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK. $startTime int Required. The start time of the request in milliseconds since the epoch. $endTime int Required. The end time of the request in milliseconds since the epoch. $bytesSent int Required. The number of bytes sent in the request. $bytesReceived int Required. The number of bytes received in the response. $responseBody string Optional. The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. Examples Record HTTP transaction An example of tracking an HTTP transaction: public class CustomHttpMetricsLogger implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); //collect request start time long t1 = System.nanoTime(); //get the size of the request body long requestSize = null == request.body() ? 0 : request.body().contentLength(); //proceed with the request Response response = chain.proceed(request); //capture the time when response returns long t2 = System.nanoTime(); long responseSize = null == response.body() ? 0 : response.body().contentLength(); //tell New Relic to notice this request NewRelic.noticeHttpTransaction(request.urlString(), request.method(), response.code(), t1, t2, requestSize, responseSize); //return response for processing return response; } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.88034,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " info on using the <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em>, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK"
      },
      "id": "6044e8b6e7b9d26e235799e9"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/recordhandledexception-android-sdk-api": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-09-14T07:43:31Z",
      "updated_at": "2021-07-08T02:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.28035,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-09-14T10:06:20Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.89561,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    },
    {
      "sections": [
        "noticeHttpTransaction (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record HTTP transaction"
      ],
      "title": "noticeHttpTransaction (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "3232e4a19b883d229a9611a2a5cc7b4a002c9f84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-http-transaction/",
      "published_at": "2021-09-14T08:04:55Z",
      "updated_at": "2021-07-09T15:31:23Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeHttpTransaction(string $url, string $httpMethod, int $statusCode, long $startTime, long $endTime, long $bytesSent, long $bytesReceived [, string $responseBody]) Copy Tracks networks requests. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests and network failures. You can use noticeHttpTransaction to record HTTP transactions, with an option to also send a response body. If a network request fails, you can record details about the failure with noticeNetworkFailure(). For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK. $startTime int Required. The start time of the request in milliseconds since the epoch. $endTime int Required. The end time of the request in milliseconds since the epoch. $bytesSent int Required. The number of bytes sent in the request. $bytesReceived int Required. The number of bytes received in the response. $responseBody string Optional. The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. Examples Record HTTP transaction An example of tracking an HTTP transaction: public class CustomHttpMetricsLogger implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); //collect request start time long t1 = System.nanoTime(); //get the size of the request body long requestSize = null == request.body() ? 0 : request.body().contentLength(); //proceed with the request Response response = chain.proceed(request); //capture the time when response returns long t2 = System.nanoTime(); long responseSize = null == response.body() ? 0 : response.body().contentLength(); //tell New Relic to notice this request NewRelic.noticeHttpTransaction(request.urlString(), request.method(), response.code(), t1, t2, requestSize, responseSize); //return response for processing return response; } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.88034,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " info on using the <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em>, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK"
      },
      "id": "6044e8b6e7b9d26e235799e9"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/recordmetric-android-sdk-api": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-09-14T07:43:31Z",
      "updated_at": "2021-07-08T02:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.28035,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-09-14T10:06:20Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.89561,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    },
    {
      "sections": [
        "noticeHttpTransaction (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record HTTP transaction"
      ],
      "title": "noticeHttpTransaction (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "3232e4a19b883d229a9611a2a5cc7b4a002c9f84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-http-transaction/",
      "published_at": "2021-09-14T08:04:55Z",
      "updated_at": "2021-07-09T15:31:23Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeHttpTransaction(string $url, string $httpMethod, int $statusCode, long $startTime, long $endTime, long $bytesSent, long $bytesReceived [, string $responseBody]) Copy Tracks networks requests. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests and network failures. You can use noticeHttpTransaction to record HTTP transactions, with an option to also send a response body. If a network request fails, you can record details about the failure with noticeNetworkFailure(). For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK. $startTime int Required. The start time of the request in milliseconds since the epoch. $endTime int Required. The end time of the request in milliseconds since the epoch. $bytesSent int Required. The number of bytes sent in the request. $bytesReceived int Required. The number of bytes received in the response. $responseBody string Optional. The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. Examples Record HTTP transaction An example of tracking an HTTP transaction: public class CustomHttpMetricsLogger implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); //collect request start time long t1 = System.nanoTime(); //get the size of the request body long requestSize = null == request.body() ? 0 : request.body().contentLength(); //proceed with the request Response response = chain.proceed(request); //capture the time when response returns long t2 = System.nanoTime(); long responseSize = null == response.body() ? 0 : response.body().contentLength(); //tell New Relic to notice this request NewRelic.noticeHttpTransaction(request.urlString(), request.method(), response.code(), t1, t2, requestSize, responseSize); //return response for processing return response; } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.88034,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " info on using the <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em>, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK"
      },
      "id": "6044e8b6e7b9d26e235799e9"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/remove-all-attributes": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-09-14T07:43:31Z",
      "updated_at": "2021-07-08T02:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.28035,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-09-14T10:06:20Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.89561,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    },
    {
      "sections": [
        "noticeHttpTransaction (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record HTTP transaction"
      ],
      "title": "noticeHttpTransaction (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "3232e4a19b883d229a9611a2a5cc7b4a002c9f84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-http-transaction/",
      "published_at": "2021-09-14T08:04:55Z",
      "updated_at": "2021-07-09T15:31:23Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeHttpTransaction(string $url, string $httpMethod, int $statusCode, long $startTime, long $endTime, long $bytesSent, long $bytesReceived [, string $responseBody]) Copy Tracks networks requests. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests and network failures. You can use noticeHttpTransaction to record HTTP transactions, with an option to also send a response body. If a network request fails, you can record details about the failure with noticeNetworkFailure(). For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK. $startTime int Required. The start time of the request in milliseconds since the epoch. $endTime int Required. The end time of the request in milliseconds since the epoch. $bytesSent int Required. The number of bytes sent in the request. $bytesReceived int Required. The number of bytes received in the response. $responseBody string Optional. The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. Examples Record HTTP transaction An example of tracking an HTTP transaction: public class CustomHttpMetricsLogger implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); //collect request start time long t1 = System.nanoTime(); //get the size of the request body long requestSize = null == request.body() ? 0 : request.body().contentLength(); //proceed with the request Response response = chain.proceed(request); //capture the time when response returns long t2 = System.nanoTime(); long responseSize = null == response.body() ? 0 : response.body().contentLength(); //tell New Relic to notice this request NewRelic.noticeHttpTransaction(request.urlString(), request.method(), response.code(), t1, t2, requestSize, responseSize); //return response for processing return response; } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.88033,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " info on using the <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em>, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK"
      },
      "id": "6044e8b6e7b9d26e235799e9"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/remove-attribute": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-09-14T07:43:31Z",
      "updated_at": "2021-07-08T02:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.28035,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-09-14T10:06:20Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.89561,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    },
    {
      "sections": [
        "noticeHttpTransaction (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record HTTP transaction"
      ],
      "title": "noticeHttpTransaction (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "3232e4a19b883d229a9611a2a5cc7b4a002c9f84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-http-transaction/",
      "published_at": "2021-09-14T08:04:55Z",
      "updated_at": "2021-07-09T15:31:23Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeHttpTransaction(string $url, string $httpMethod, int $statusCode, long $startTime, long $endTime, long $bytesSent, long $bytesReceived [, string $responseBody]) Copy Tracks networks requests. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests and network failures. You can use noticeHttpTransaction to record HTTP transactions, with an option to also send a response body. If a network request fails, you can record details about the failure with noticeNetworkFailure(). For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK. $startTime int Required. The start time of the request in milliseconds since the epoch. $endTime int Required. The end time of the request in milliseconds since the epoch. $bytesSent int Required. The number of bytes sent in the request. $bytesReceived int Required. The number of bytes received in the response. $responseBody string Optional. The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. Examples Record HTTP transaction An example of tracking an HTTP transaction: public class CustomHttpMetricsLogger implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); //collect request start time long t1 = System.nanoTime(); //get the size of the request body long requestSize = null == request.body() ? 0 : request.body().contentLength(); //proceed with the request Response response = chain.proceed(request); //capture the time when response returns long t2 = System.nanoTime(); long responseSize = null == response.body() ? 0 : response.body().contentLength(); //tell New Relic to notice this request NewRelic.noticeHttpTransaction(request.urlString(), request.method(), response.code(), t1, t2, requestSize, responseSize); //return response for processing return response; } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.88033,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " info on using the <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em>, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK"
      },
      "id": "6044e8b6e7b9d26e235799e9"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/set-attribute": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-09-14T07:43:31Z",
      "updated_at": "2021-07-08T02:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.28035,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-09-14T10:06:20Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.89561,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    },
    {
      "sections": [
        "noticeHttpTransaction (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record HTTP transaction"
      ],
      "title": "noticeHttpTransaction (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "3232e4a19b883d229a9611a2a5cc7b4a002c9f84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-http-transaction/",
      "published_at": "2021-09-14T08:04:55Z",
      "updated_at": "2021-07-09T15:31:23Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeHttpTransaction(string $url, string $httpMethod, int $statusCode, long $startTime, long $endTime, long $bytesSent, long $bytesReceived [, string $responseBody]) Copy Tracks networks requests. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests and network failures. You can use noticeHttpTransaction to record HTTP transactions, with an option to also send a response body. If a network request fails, you can record details about the failure with noticeNetworkFailure(). For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK. $startTime int Required. The start time of the request in milliseconds since the epoch. $endTime int Required. The end time of the request in milliseconds since the epoch. $bytesSent int Required. The number of bytes sent in the request. $bytesReceived int Required. The number of bytes received in the response. $responseBody string Optional. The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. Examples Record HTTP transaction An example of tracking an HTTP transaction: public class CustomHttpMetricsLogger implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); //collect request start time long t1 = System.nanoTime(); //get the size of the request body long requestSize = null == request.body() ? 0 : request.body().contentLength(); //proceed with the request Response response = chain.proceed(request); //capture the time when response returns long t2 = System.nanoTime(); long responseSize = null == response.body() ? 0 : response.body().contentLength(); //tell New Relic to notice this request NewRelic.noticeHttpTransaction(request.urlString(), request.method(), response.code(), t1, t2, requestSize, responseSize); //return response for processing return response; } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.88033,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " info on using the <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em>, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK"
      },
      "id": "6044e8b6e7b9d26e235799e9"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/set-interaction-name": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-09-14T07:43:31Z",
      "updated_at": "2021-07-08T02:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.28035,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-09-14T10:06:20Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.89561,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    },
    {
      "sections": [
        "noticeHttpTransaction (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record HTTP transaction"
      ],
      "title": "noticeHttpTransaction (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "3232e4a19b883d229a9611a2a5cc7b4a002c9f84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-http-transaction/",
      "published_at": "2021-09-14T08:04:55Z",
      "updated_at": "2021-07-09T15:31:23Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeHttpTransaction(string $url, string $httpMethod, int $statusCode, long $startTime, long $endTime, long $bytesSent, long $bytesReceived [, string $responseBody]) Copy Tracks networks requests. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests and network failures. You can use noticeHttpTransaction to record HTTP transactions, with an option to also send a response body. If a network request fails, you can record details about the failure with noticeNetworkFailure(). For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK. $startTime int Required. The start time of the request in milliseconds since the epoch. $endTime int Required. The end time of the request in milliseconds since the epoch. $bytesSent int Required. The number of bytes sent in the request. $bytesReceived int Required. The number of bytes received in the response. $responseBody string Optional. The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. Examples Record HTTP transaction An example of tracking an HTTP transaction: public class CustomHttpMetricsLogger implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); //collect request start time long t1 = System.nanoTime(); //get the size of the request body long requestSize = null == request.body() ? 0 : request.body().contentLength(); //proceed with the request Response response = chain.proceed(request); //capture the time when response returns long t2 = System.nanoTime(); long responseSize = null == response.body() ? 0 : response.body().contentLength(); //tell New Relic to notice this request NewRelic.noticeHttpTransaction(request.urlString(), request.method(), response.code(), t1, t2, requestSize, responseSize); //return response for processing return response; } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.88033,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " info on using the <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em>, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK"
      },
      "id": "6044e8b6e7b9d26e235799e9"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/set-max-event-buffer-time": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-09-14T07:43:31Z",
      "updated_at": "2021-07-08T02:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.28033,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-09-14T10:06:20Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.8956,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    },
    {
      "sections": [
        "noticeHttpTransaction (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record HTTP transaction"
      ],
      "title": "noticeHttpTransaction (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "3232e4a19b883d229a9611a2a5cc7b4a002c9f84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-http-transaction/",
      "published_at": "2021-09-14T08:04:55Z",
      "updated_at": "2021-07-09T15:31:23Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeHttpTransaction(string $url, string $httpMethod, int $statusCode, long $startTime, long $endTime, long $bytesSent, long $bytesReceived [, string $responseBody]) Copy Tracks networks requests. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests and network failures. You can use noticeHttpTransaction to record HTTP transactions, with an option to also send a response body. If a network request fails, you can record details about the failure with noticeNetworkFailure(). For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK. $startTime int Required. The start time of the request in milliseconds since the epoch. $endTime int Required. The end time of the request in milliseconds since the epoch. $bytesSent int Required. The number of bytes sent in the request. $bytesReceived int Required. The number of bytes received in the response. $responseBody string Optional. The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. Examples Record HTTP transaction An example of tracking an HTTP transaction: public class CustomHttpMetricsLogger implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); //collect request start time long t1 = System.nanoTime(); //get the size of the request body long requestSize = null == request.body() ? 0 : request.body().contentLength(); //proceed with the request Response response = chain.proceed(request); //capture the time when response returns long t2 = System.nanoTime(); long responseSize = null == response.body() ? 0 : response.body().contentLength(); //tell New Relic to notice this request NewRelic.noticeHttpTransaction(request.urlString(), request.method(), response.code(), t1, t2, requestSize, responseSize); //return response for processing return response; } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.88033,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " info on using the <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em>, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK"
      },
      "id": "6044e8b6e7b9d26e235799e9"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/set-max-event-pool-size": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-09-14T07:43:31Z",
      "updated_at": "2021-07-08T02:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.28033,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-09-14T10:06:20Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.8956,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    },
    {
      "sections": [
        "noticeHttpTransaction (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record HTTP transaction"
      ],
      "title": "noticeHttpTransaction (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "3232e4a19b883d229a9611a2a5cc7b4a002c9f84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-http-transaction/",
      "published_at": "2021-09-14T08:04:55Z",
      "updated_at": "2021-07-09T15:31:23Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeHttpTransaction(string $url, string $httpMethod, int $statusCode, long $startTime, long $endTime, long $bytesSent, long $bytesReceived [, string $responseBody]) Copy Tracks networks requests. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests and network failures. You can use noticeHttpTransaction to record HTTP transactions, with an option to also send a response body. If a network request fails, you can record details about the failure with noticeNetworkFailure(). For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK. $startTime int Required. The start time of the request in milliseconds since the epoch. $endTime int Required. The end time of the request in milliseconds since the epoch. $bytesSent int Required. The number of bytes sent in the request. $bytesReceived int Required. The number of bytes received in the response. $responseBody string Optional. The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. Examples Record HTTP transaction An example of tracking an HTTP transaction: public class CustomHttpMetricsLogger implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); //collect request start time long t1 = System.nanoTime(); //get the size of the request body long requestSize = null == request.body() ? 0 : request.body().contentLength(); //proceed with the request Response response = chain.proceed(request); //capture the time when response returns long t2 = System.nanoTime(); long responseSize = null == response.body() ? 0 : response.body().contentLength(); //tell New Relic to notice this request NewRelic.noticeHttpTransaction(request.urlString(), request.method(), response.code(), t1, t2, requestSize, responseSize); //return response for processing return response; } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.88033,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " info on using the <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em>, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK"
      },
      "id": "6044e8b6e7b9d26e235799e9"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/set-user-id": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-09-14T07:43:31Z",
      "updated_at": "2021-07-08T02:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.28033,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-09-14T10:06:20Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.8956,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    },
    {
      "sections": [
        "noticeHttpTransaction (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record HTTP transaction"
      ],
      "title": "noticeHttpTransaction (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "3232e4a19b883d229a9611a2a5cc7b4a002c9f84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-http-transaction/",
      "published_at": "2021-09-14T08:04:55Z",
      "updated_at": "2021-07-09T15:31:23Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeHttpTransaction(string $url, string $httpMethod, int $statusCode, long $startTime, long $endTime, long $bytesSent, long $bytesReceived [, string $responseBody]) Copy Tracks networks requests. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests and network failures. You can use noticeHttpTransaction to record HTTP transactions, with an option to also send a response body. If a network request fails, you can record details about the failure with noticeNetworkFailure(). For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK. $startTime int Required. The start time of the request in milliseconds since the epoch. $endTime int Required. The end time of the request in milliseconds since the epoch. $bytesSent int Required. The number of bytes sent in the request. $bytesReceived int Required. The number of bytes received in the response. $responseBody string Optional. The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. Examples Record HTTP transaction An example of tracking an HTTP transaction: public class CustomHttpMetricsLogger implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); //collect request start time long t1 = System.nanoTime(); //get the size of the request body long requestSize = null == request.body() ? 0 : request.body().contentLength(); //proceed with the request Response response = chain.proceed(request); //capture the time when response returns long t2 = System.nanoTime(); long responseSize = null == response.body() ? 0 : response.body().contentLength(); //tell New Relic to notice this request NewRelic.noticeHttpTransaction(request.urlString(), request.method(), response.code(), t1, t2, requestSize, responseSize); //return response for processing return response; } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.88033,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " info on using the <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em>, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK"
      },
      "id": "6044e8b6e7b9d26e235799e9"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/start-interaction": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-09-14T07:43:31Z",
      "updated_at": "2021-07-08T02:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.28033,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-09-14T10:06:20Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.8956,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    },
    {
      "sections": [
        "noticeHttpTransaction (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record HTTP transaction"
      ],
      "title": "noticeHttpTransaction (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "3232e4a19b883d229a9611a2a5cc7b4a002c9f84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-http-transaction/",
      "published_at": "2021-09-14T08:04:55Z",
      "updated_at": "2021-07-09T15:31:23Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeHttpTransaction(string $url, string $httpMethod, int $statusCode, long $startTime, long $endTime, long $bytesSent, long $bytesReceived [, string $responseBody]) Copy Tracks networks requests. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests and network failures. You can use noticeHttpTransaction to record HTTP transactions, with an option to also send a response body. If a network request fails, you can record details about the failure with noticeNetworkFailure(). For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK. $startTime int Required. The start time of the request in milliseconds since the epoch. $endTime int Required. The end time of the request in milliseconds since the epoch. $bytesSent int Required. The number of bytes sent in the request. $bytesReceived int Required. The number of bytes received in the response. $responseBody string Optional. The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. Examples Record HTTP transaction An example of tracking an HTTP transaction: public class CustomHttpMetricsLogger implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); //collect request start time long t1 = System.nanoTime(); //get the size of the request body long requestSize = null == request.body() ? 0 : request.body().contentLength(); //proceed with the request Response response = chain.proceed(request); //capture the time when response returns long t2 = System.nanoTime(); long responseSize = null == response.body() ? 0 : response.body().contentLength(); //tell New Relic to notice this request NewRelic.noticeHttpTransaction(request.urlString(), request.method(), response.code(), t1, t2, requestSize, responseSize); //return response for processing return response; } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.88033,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " info on using the <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em>, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK"
      },
      "id": "6044e8b6e7b9d26e235799e9"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/with-application-build": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-09-14T07:43:31Z",
      "updated_at": "2021-07-08T02:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.28033,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-09-14T10:06:20Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.8956,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    },
    {
      "sections": [
        "noticeHttpTransaction (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record HTTP transaction"
      ],
      "title": "noticeHttpTransaction (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "3232e4a19b883d229a9611a2a5cc7b4a002c9f84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-http-transaction/",
      "published_at": "2021-09-14T08:04:55Z",
      "updated_at": "2021-07-09T15:31:23Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeHttpTransaction(string $url, string $httpMethod, int $statusCode, long $startTime, long $endTime, long $bytesSent, long $bytesReceived [, string $responseBody]) Copy Tracks networks requests. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests and network failures. You can use noticeHttpTransaction to record HTTP transactions, with an option to also send a response body. If a network request fails, you can record details about the failure with noticeNetworkFailure(). For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK. $startTime int Required. The start time of the request in milliseconds since the epoch. $endTime int Required. The end time of the request in milliseconds since the epoch. $bytesSent int Required. The number of bytes sent in the request. $bytesReceived int Required. The number of bytes received in the response. $responseBody string Optional. The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. Examples Record HTTP transaction An example of tracking an HTTP transaction: public class CustomHttpMetricsLogger implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); //collect request start time long t1 = System.nanoTime(); //get the size of the request body long requestSize = null == request.body() ? 0 : request.body().contentLength(); //proceed with the request Response response = chain.proceed(request); //capture the time when response returns long t2 = System.nanoTime(); long responseSize = null == response.body() ? 0 : response.body().contentLength(); //tell New Relic to notice this request NewRelic.noticeHttpTransaction(request.urlString(), request.method(), response.code(), t1, t2, requestSize, responseSize); //return response for processing return response; } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.88031,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " info on using the <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em>, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK"
      },
      "id": "6044e8b6e7b9d26e235799e9"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/with-application-version": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-09-14T07:43:31Z",
      "updated_at": "2021-07-08T02:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.28033,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-09-14T10:06:20Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.8956,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    },
    {
      "sections": [
        "noticeHttpTransaction (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record HTTP transaction"
      ],
      "title": "noticeHttpTransaction (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "3232e4a19b883d229a9611a2a5cc7b4a002c9f84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-http-transaction/",
      "published_at": "2021-09-14T08:04:55Z",
      "updated_at": "2021-07-09T15:31:23Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeHttpTransaction(string $url, string $httpMethod, int $statusCode, long $startTime, long $endTime, long $bytesSent, long $bytesReceived [, string $responseBody]) Copy Tracks networks requests. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests and network failures. You can use noticeHttpTransaction to record HTTP transactions, with an option to also send a response body. If a network request fails, you can record details about the failure with noticeNetworkFailure(). For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK. $startTime int Required. The start time of the request in milliseconds since the epoch. $endTime int Required. The end time of the request in milliseconds since the epoch. $bytesSent int Required. The number of bytes sent in the request. $bytesReceived int Required. The number of bytes received in the response. $responseBody string Optional. The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. Examples Record HTTP transaction An example of tracking an HTTP transaction: public class CustomHttpMetricsLogger implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); //collect request start time long t1 = System.nanoTime(); //get the size of the request body long requestSize = null == request.body() ? 0 : request.body().contentLength(); //proceed with the request Response response = chain.proceed(request); //capture the time when response returns long t2 = System.nanoTime(); long responseSize = null == response.body() ? 0 : response.body().contentLength(); //tell New Relic to notice this request NewRelic.noticeHttpTransaction(request.urlString(), request.method(), response.code(), t1, t2, requestSize, responseSize); //return response for processing return response; } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.88031,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " info on using the <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em>, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK"
      },
      "id": "6044e8b6e7b9d26e235799e9"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/with-interaction-tracing": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-09-14T07:43:31Z",
      "updated_at": "2021-07-08T02:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.28033,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-09-14T10:06:20Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.8956,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    },
    {
      "sections": [
        "noticeHttpTransaction (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record HTTP transaction"
      ],
      "title": "noticeHttpTransaction (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "3232e4a19b883d229a9611a2a5cc7b4a002c9f84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-http-transaction/",
      "published_at": "2021-09-14T08:04:55Z",
      "updated_at": "2021-07-09T15:31:23Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeHttpTransaction(string $url, string $httpMethod, int $statusCode, long $startTime, long $endTime, long $bytesSent, long $bytesReceived [, string $responseBody]) Copy Tracks networks requests. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests and network failures. You can use noticeHttpTransaction to record HTTP transactions, with an option to also send a response body. If a network request fails, you can record details about the failure with noticeNetworkFailure(). For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK. $startTime int Required. The start time of the request in milliseconds since the epoch. $endTime int Required. The end time of the request in milliseconds since the epoch. $bytesSent int Required. The number of bytes sent in the request. $bytesReceived int Required. The number of bytes received in the response. $responseBody string Optional. The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. Examples Record HTTP transaction An example of tracking an HTTP transaction: public class CustomHttpMetricsLogger implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); //collect request start time long t1 = System.nanoTime(); //get the size of the request body long requestSize = null == request.body() ? 0 : request.body().contentLength(); //proceed with the request Response response = chain.proceed(request); //capture the time when response returns long t2 = System.nanoTime(); long responseSize = null == response.body() ? 0 : response.body().contentLength(); //tell New Relic to notice this request NewRelic.noticeHttpTransaction(request.urlString(), request.method(), response.code(), t1, t2, requestSize, responseSize); //return response for processing return response; } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.88031,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " info on using the <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em>, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK"
      },
      "id": "6044e8b6e7b9d26e235799e9"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/api-guides/android-agent-configuration-feature-flags": [
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "9a99f7acf96c5dece74c728c21248eb322d58ddc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/api-guides/android-sdk-api-guide/",
      "published_at": "2021-09-14T07:40:38Z",
      "updated_at": "2021-07-09T14:58:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.49663,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> SDK <em>API</em> <em>guide</em>",
        "sections": "<em>Android</em> SDK <em>API</em> <em>guide</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " instrumentation for <em>monitoring</em> your application. The <em>API</em> gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your <em>mobile</em> app. Record custom metrics. Send custom attributes and events to <em>New</em> <em>Relic</em> Insights. Track networking from libraries not supported"
      },
      "id": "603ea2bc64441f11ee4e889b"
    },
    {
      "sections": [
        "Configure ProGuard or DexGuard for Android apps",
        "Configure ProGuard",
        "Network library support",
        "Configure DexGuard"
      ],
      "title": "Configure ProGuard or DexGuard for Android apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "8a8df969c4099f75cb214354cef311dfa2ab50e2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/configure-proguard-or-dexguard-android-apps/",
      "published_at": "2021-09-14T07:45:07Z",
      "updated_at": "2021-08-21T09:16:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to support ProGuard or DexGuard with the Android agent. Check our Android compatibility and requirements, and if you have previously installed the Android agent SDK, follow the steps before upgrading to the latest version with ProGuard or DexGuard. Configure ProGuard To add support for ProGuard: Add an exclusion to your app; for example: To support New Relic instrumentation, add keep class. To disable warnings related to unresolved problems, add dont warn. To preserve line numbers for crash reporting, add LineNumberTable. To preserve stack information for handled exceptions, add SourceFile and EnclosingMethod. Add the following to your ProGuard config file (proguard.cfg, proguard-android.txt, proguard-rules.pro, etc.): -keep class com.newrelic.** { *; } -dontwarn com.newrelic.** -keepattributes Exceptions, Signature, InnerClasses, LineNumberTable, SourceFile, EnclosingMethod Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors. Network library support New Relic instrumentation happens before ProGuard obfuscates your code. In order for these libraries to be properly instrumented, their classes must not be obfuscated by ProGuard. Here are examples of rules to be applied to preserve these classes. This is not a complete list. Different rules will be needed depending on your library or version. Library Rules Apache Http -keep class org.apache.http.** { *; } -dontwarn org.apache.http.** Copy OkHttp 2 -keep class com.squareup.okhttp.* { *; } -dontwarn com.squareup.okhttp.** -dontwarn okio.** Copy OkHttp 3 -keep class okhttp3.** { *; } -dontwarn okhttp3.** -dontwarn okio.** Copy Retrofit 2 -keep class retrofit2.** { *; } -dontwarn retrofit2.** Copy Configure DexGuard DexGuard uses the same configuration options as ProGuard, and it can read any pre-existing ProGuard configuration files. DexGuard also has its own set of additional configuration options and provides sample configurations for many common app frameworks. To add support for DexGuard: Add DexGuard to your app and set up the Gradle plugin according to the directions from DexGuard. Create a dexguard-project.txt file to hold specific DexGuard configuration options, and add: -dontnote com.newrelic.agent.android.NewRelic -dontnote com.newrelic.agent.android.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app's buildTypes configuration is similar to this: buildTypes { release { minifyEnabled true proguardFile getDefaultDexGuardFile('dexguard-release.pro') proguardFile 'proguard-rules.pro' proguardFile 'dexguard-project.txt' } ... Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.15111,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Configure ProGuard or DexGuard for <em>Android</em> apps",
        "sections": "Configure ProGuard or DexGuard for <em>Android</em> apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": ", and add: -dontnote com.newrelic.agent.<em>android.NewRelic</em> -dontnote com.newrelic.agent.<em>android</em>.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app&#x27;s buildTypes configuration is similar to this: buildTypes { release { minifyEnabled"
      },
      "id": "604418de196a6770e7960f6c"
    },
    {
      "sections": [
        "Install Android apps with Gradle and Android Studio",
        "Install your Android app",
        "Configure with Gradle and Android Studio",
        "Project level build.gradle file:",
        "App level build.gradle file:",
        "Important",
        "Update your Android installation",
        "Android 4.x: Multidex support",
        "New Relic Gradle Plugin configuration"
      ],
      "title": "Install Android apps with Gradle and Android Studio",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "51fab3eba87ddee949cd4729de8b5f64534de9c7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-android-apps-gradle-android-studio/",
      "published_at": "2021-09-14T08:10:37Z",
      "updated_at": "2021-07-27T17:09:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Gradle or Android Studio, follow these instructions to install New Relic's mobile monitoring for the first time. If you have previously installed the Android agent SDK for mobile monitoring, follow the steps before upgrading to the latest version with Gradle and Android Studio. Install your Android app As part of the installation process for mobile monitoring, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. Go to one.newrelic.com > Mobile. If applicable: From the Mobile apps index, select Add a new app. From the Get started page, select Android as the platform for mobile monitoring. Type a meaningful name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring with Gradle and Android Studio. OR: To complete the configuration process for a new mobile app later: Go to one.newrelic.com > Mobile, then select See instructions next to your mobile app name. To upgrade an existing Android installation: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Configure with Gradle and Android Studio These procedures to configure your Android app with Gradle and Android Studio also appear on the Get started page in New Relic. Merge New Relic's mobile monitoring code in the Gradle & Android Studio tab to your build.gradle file. Project level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. buildscript { repositories { mavenCentral() } dependencies { classpath \"com.newrelic.agent.android:agent-gradle-plugin:AGENT_VERSION\" } } Copy App level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. repositories { mavenCentral() } apply plugin: 'android' apply plugin: 'newrelic' dependencies { compile 'com.newrelic.agent.android:android-agent:AGENT_VERSION' } Copy ProGuard or DexGuard: In your project’s root directory (projectname/app), add a newrelic.properties file with the following line: com.newrelic.application_token=GENERATED_TOKEN Copy Follow the additional, required configuration steps for using ProGuard or DexGuard with New Relic. Set app permissions: Ensure that your Android app requests INTERNET and ACCESS_NETWORK_STATE permissions by adding these lines to your AndroidManifest.xml file: <uses-permission android:name=\"android.permission.INTERNET\" /> <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /> Copy To start New Relic's mobile monitoring agent: In your Default Activity (as defined in your Manifest), import the NewRelic class: import com.newrelic.agent.android.NewRelic; Copy Important We do not support starting the mobile monitoring agent in other classes, as that can cause unexpected or unstable behavior. To initialize mobile monitoring: In the onCreate() method, add this call: NewRelic.withApplicationToken(\"GENERATED_TOKEN\").start(this.getApplication()); Copy Optional: Change the logging level. To build and run your application: Clean your project, then run your app in an emulator or device to generate traffic. Wait a few minutes, then view data for your Android app from the Overview page: Go to one.newrelic.com > Mobile > (select an app). If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI, follow the troubleshooting procedures. Update your Android installation To keep your Android agent up to date, follow the procedures to upgrade the Android agent SDK for New Relic. To install the latest Android version for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Android 4.x: Multidex support New Relic's mobile monitoring for Android versions prior to Android 5.0 (API level 21) use the Dalvik runtime to execute app code. By default, Dalvik limits apps to a single classes.dex bytecode file per APK. In order to get around this limitation, you must enable multidex support. Then you can use the multidex support library, which becomes part of the primary DEX file of your app and then manages access to the additional DEX files and the code they contain. When building each DEX file for a multidex app, the build tools perform complex decision making to determine which classes are needed in the primary DEX file so that your app can start successfully. If any class required during startup is not provided in the primary DEX file, then your app crashes with the error java.lang.NoClassDefFoundError. If you see the java.lang.NoClassDefFoundError error, then you must manually specify these additional classes as required in the primary DEX file: Create a proguard.multidex.config file within the /app folder of your project. Update mypackage to reflect your package name. #################### # keep class names # #################### #Keep New Relic in the main dex -keep class com.newrelic.** { *; } -keep class com.mypackage.activities.** { *; } Copy Merge the following code into the app-level build.gradle file: android { defaultConfig{ … multiDexKeepProguard file(\"proguard.multidex.config\") } } Copy For more information, see the Android Developers documentation on declaring classes required in the primary DEX file. New Relic Gradle Plugin configuration For details on how to configure the behavior of the mobile monitoring agent plugin during Gradle builds, see the New Relic Gradle plugin extension guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.07198,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "sections": "<em>New</em> <em>Relic</em> Gradle Plugin configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " your <em>Android</em> app As part of the installation process for <em>mobile</em> <em>monitoring</em>, <em>New</em> <em>Relic</em> automatically generates an application token. This is a 40-character hexadecimal string for authenticating each <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. Go to one.newrelic.com &gt; <em>Mobile</em>. If applicable: From the <em>Mobile</em>"
      },
      "id": "603ea70128ccbc59c2eba74e"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/api-guides/android-sdk-api-guide": [
    {
      "sections": [
        "Android agent configuration and feature flags",
        "Change configuration settings",
        "Analytics settings",
        "withAnalyticsEvents",
        "FeatureFlag.AnalyticsEvents",
        "Application settings",
        "withApplicationVersion",
        "withApplicationBuild",
        "Crash and error reporting settings",
        "withCrashReportingEnabledFeatureFlag.CrashReportingEnabled",
        "FeatureFlag.HandledExceptions",
        "Distributed tracing",
        "FeatureFlag.DistributedTracing",
        "Interaction settings",
        "withInteractionTracingFeatureFlag.InteractionTracing",
        "withDefaultInteractionsFeatureFlag.DefaultInteractions",
        "Networking settings",
        "FeatureFlag.NetworkRequests",
        "FeatureFlag.NetworkErrorRequests",
        "withHttpResponseBodyCaptureEnabledFeatureFlag.HttpResponseBodyCaptureEnabled",
        "Logging settings",
        "withLoggingEnabled",
        "withLogLevel",
        "Data endpoint settings",
        "usingCollectorAddress",
        "usingCrashCollectorAddress"
      ],
      "title": "Android agent configuration and feature flags",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "68c34002aa50d0a945d604f984bd3a64257b4f6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/api-guides/android-agent-configuration-feature-flags/",
      "published_at": "2021-09-14T07:40:40Z",
      "updated_at": "2021-07-09T14:57:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Android agent provides configuration settings to change the default behavior of the agent. For an explanation of mobile custom data types, see Add custom data to mobile monitoring. Change configuration settings All settings, including the call to invoke the agent, are called in the onCreate method of the MainActivity class. To change settings, call the setting in one of two ways (if the setting supports it): Change the setting on its own line for each specific condition: NewRelic. disableFeature(FeatureFlag.DefaultInteractions) ; NewRelic. enableFeature(FeatureFlag.CrashReporting) ; NewRelic.withApplicationToken(<NEW_RELIC_TOKEN>).start(this.getApplication()); Copy OR Change the setting as part of the agent start call using the .with method: NewRelic.withApplicationToken(<NEW_RELIC_TOKEN>) .withDefaultInteractions(false) .withCrashReportingEnabled(true) .start(this.getApplication()); Copy Analytics settings withAnalyticsEvents Enable or disable collection of event data. These events are reported to Insights and used in the Crash analysis page. Type Boolean Default true FeatureFlag.AnalyticsEvents Enable or disable the reporting of event data. Event collection will still occur; the events will just not be sent to our collector. You might decide to use this instead of withAnalyticsEvents if you wanted to disable collection but still be able to see what the agent was collecting. Type Boolean Default true Application settings withApplicationVersion Set custom application version strings. Type String Default Defaults to version number set in AndroidManifest.xml withApplicationBuild Set custom application build strings. Type String Default Defaults to build ID set in AndroidManifest.xml Crash and error reporting settings withCrashReportingEnabled FeatureFlag.CrashReportingEnabled Enable or disable crash reporting. Type Boolean Default true FeatureFlag.HandledExceptions Enable or disable recording handled exceptions events, which appear on the Handled exception page. Type Boolean Default true Distributed tracing FeatureFlag.DistributedTracing Enable or disable the adding of distributed tracing headers to network requests. Refer to How New Relic distributed tracing works for more information on distributed tracing in mobile apps. Type Boolean Default true Interaction settings withInteractionTracing FeatureFlag.InteractionTracing Enable or disable interaction tracing. Trace instrumentation still occurs, but no traces are harvested. This will disable default and custom interactions. Available for Android agent version 5.4.0 or higher. Type Boolean Default true withDefaultInteractions FeatureFlag.DefaultInteractions Enable or disable default interactions. Trace instrumentation still occurs, but no traces are harvested. This will enable or disable default interactions only while custom interactions remain enabled. Type Boolean Default true Networking settings FeatureFlag.NetworkRequests Enable or disable reporting successful HTTP requests to the MobileRequest event type in Insights. Available for Android agent version 5.14.0 or higher. Type Boolean Default true Enabled by default as of agent version 5.15.2 FeatureFlag.NetworkErrorRequests Enable or disable reporting network and Http request errors to MobileRequestError event type in Insights. Available for Android agent version 5.11.0 or higher. Type Boolean Default true withHttpResponseBodyCaptureEnabled FeatureFlag.HttpResponseBodyCaptureEnabled Enable or disable capture of HTTP response bodies for HTTP error traces, and MobileRequestError events. Type Boolean Default true Logging settings withLoggingEnabled Enable or disable agent logging. Type Boolean Default true withLogLevel Specifies the log level. Options include: ERROR (least verbose) WARNING INFO (default) VERBOSE DEBUG AUDIT (most verbose) Type String Default AgentLog.INFO To increase your logging level in the app, add .withLogLevel to your NewRelic.withApplicationToken() method call. For example: NewRelic.withApplicationToken(\"YOUR_APP_TOKEN\") .withLogLevel(AgentLog.DEBUG) .start(this.getApplication()); Copy Data endpoint settings usingCollectorAddress Specifies the URI authority component of the harvest data upload endpoint. Type Boolean Default mobile-collector.newrelic.com To replace data endpoint the agent will use when reporting data harvests, add .usingCollectorAddress() to your NewRelic.withApplicationToken() method call. For example: NewRelic.withApplicationToken(\"YOUR_APP_TOKEN\") .usingCollectorAddress(\"harvest-upload-delegate.domain.com\") .start(this.getApplication()); Copy This endpoint is also used for handled exception uploads. usingCrashCollectorAddress Specifies the authority component of the crash data upload URI. Type String Default mobile-crash.newrelic.com To replace data endpoint the agent will use when reporting crashes, add .usingCrashCollectorAddress() to your NewRelic.withApplicationToken() method call. For example: NewRelic.withApplicationToken(\"YOUR_APP_TOKEN\") .usingCrashCollectorAddress(\"crash-upload-delegate.domain.com\") .start(this.getApplication()); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.49647,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> agent configuration and feature flags",
        "sections": "<em>Android</em> agent configuration and feature flags",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "The <em>Android</em> agent provides configuration settings to change the default behavior of the agent. For an explanation of <em>mobile</em> custom data types, see Add custom data to <em>mobile</em> <em>monitoring</em>. Change configuration settings All settings, including the call to invoke the agent, are called in the onCreate"
      },
      "id": "603ed80e28ccbc0cfceba773"
    },
    {
      "sections": [
        "Configure ProGuard or DexGuard for Android apps",
        "Configure ProGuard",
        "Network library support",
        "Configure DexGuard"
      ],
      "title": "Configure ProGuard or DexGuard for Android apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "8a8df969c4099f75cb214354cef311dfa2ab50e2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/configure-proguard-or-dexguard-android-apps/",
      "published_at": "2021-09-14T07:45:07Z",
      "updated_at": "2021-08-21T09:16:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to support ProGuard or DexGuard with the Android agent. Check our Android compatibility and requirements, and if you have previously installed the Android agent SDK, follow the steps before upgrading to the latest version with ProGuard or DexGuard. Configure ProGuard To add support for ProGuard: Add an exclusion to your app; for example: To support New Relic instrumentation, add keep class. To disable warnings related to unresolved problems, add dont warn. To preserve line numbers for crash reporting, add LineNumberTable. To preserve stack information for handled exceptions, add SourceFile and EnclosingMethod. Add the following to your ProGuard config file (proguard.cfg, proguard-android.txt, proguard-rules.pro, etc.): -keep class com.newrelic.** { *; } -dontwarn com.newrelic.** -keepattributes Exceptions, Signature, InnerClasses, LineNumberTable, SourceFile, EnclosingMethod Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors. Network library support New Relic instrumentation happens before ProGuard obfuscates your code. In order for these libraries to be properly instrumented, their classes must not be obfuscated by ProGuard. Here are examples of rules to be applied to preserve these classes. This is not a complete list. Different rules will be needed depending on your library or version. Library Rules Apache Http -keep class org.apache.http.** { *; } -dontwarn org.apache.http.** Copy OkHttp 2 -keep class com.squareup.okhttp.* { *; } -dontwarn com.squareup.okhttp.** -dontwarn okio.** Copy OkHttp 3 -keep class okhttp3.** { *; } -dontwarn okhttp3.** -dontwarn okio.** Copy Retrofit 2 -keep class retrofit2.** { *; } -dontwarn retrofit2.** Copy Configure DexGuard DexGuard uses the same configuration options as ProGuard, and it can read any pre-existing ProGuard configuration files. DexGuard also has its own set of additional configuration options and provides sample configurations for many common app frameworks. To add support for DexGuard: Add DexGuard to your app and set up the Gradle plugin according to the directions from DexGuard. Create a dexguard-project.txt file to hold specific DexGuard configuration options, and add: -dontnote com.newrelic.agent.android.NewRelic -dontnote com.newrelic.agent.android.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app's buildTypes configuration is similar to this: buildTypes { release { minifyEnabled true proguardFile getDefaultDexGuardFile('dexguard-release.pro') proguardFile 'proguard-rules.pro' proguardFile 'dexguard-project.txt' } ... Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.1511,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Configure ProGuard or DexGuard for <em>Android</em> apps",
        "sections": "Configure ProGuard or DexGuard for <em>Android</em> apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": ", and add: -dontnote com.newrelic.agent.<em>android.NewRelic</em> -dontnote com.newrelic.agent.<em>android</em>.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app&#x27;s buildTypes configuration is similar to this: buildTypes { release { minifyEnabled"
      },
      "id": "604418de196a6770e7960f6c"
    },
    {
      "sections": [
        "Install Android apps with Gradle and Android Studio",
        "Install your Android app",
        "Configure with Gradle and Android Studio",
        "Project level build.gradle file:",
        "App level build.gradle file:",
        "Important",
        "Update your Android installation",
        "Android 4.x: Multidex support",
        "New Relic Gradle Plugin configuration"
      ],
      "title": "Install Android apps with Gradle and Android Studio",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "51fab3eba87ddee949cd4729de8b5f64534de9c7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-android-apps-gradle-android-studio/",
      "published_at": "2021-09-14T08:10:37Z",
      "updated_at": "2021-07-27T17:09:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Gradle or Android Studio, follow these instructions to install New Relic's mobile monitoring for the first time. If you have previously installed the Android agent SDK for mobile monitoring, follow the steps before upgrading to the latest version with Gradle and Android Studio. Install your Android app As part of the installation process for mobile monitoring, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. Go to one.newrelic.com > Mobile. If applicable: From the Mobile apps index, select Add a new app. From the Get started page, select Android as the platform for mobile monitoring. Type a meaningful name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring with Gradle and Android Studio. OR: To complete the configuration process for a new mobile app later: Go to one.newrelic.com > Mobile, then select See instructions next to your mobile app name. To upgrade an existing Android installation: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Configure with Gradle and Android Studio These procedures to configure your Android app with Gradle and Android Studio also appear on the Get started page in New Relic. Merge New Relic's mobile monitoring code in the Gradle & Android Studio tab to your build.gradle file. Project level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. buildscript { repositories { mavenCentral() } dependencies { classpath \"com.newrelic.agent.android:agent-gradle-plugin:AGENT_VERSION\" } } Copy App level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. repositories { mavenCentral() } apply plugin: 'android' apply plugin: 'newrelic' dependencies { compile 'com.newrelic.agent.android:android-agent:AGENT_VERSION' } Copy ProGuard or DexGuard: In your project’s root directory (projectname/app), add a newrelic.properties file with the following line: com.newrelic.application_token=GENERATED_TOKEN Copy Follow the additional, required configuration steps for using ProGuard or DexGuard with New Relic. Set app permissions: Ensure that your Android app requests INTERNET and ACCESS_NETWORK_STATE permissions by adding these lines to your AndroidManifest.xml file: <uses-permission android:name=\"android.permission.INTERNET\" /> <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /> Copy To start New Relic's mobile monitoring agent: In your Default Activity (as defined in your Manifest), import the NewRelic class: import com.newrelic.agent.android.NewRelic; Copy Important We do not support starting the mobile monitoring agent in other classes, as that can cause unexpected or unstable behavior. To initialize mobile monitoring: In the onCreate() method, add this call: NewRelic.withApplicationToken(\"GENERATED_TOKEN\").start(this.getApplication()); Copy Optional: Change the logging level. To build and run your application: Clean your project, then run your app in an emulator or device to generate traffic. Wait a few minutes, then view data for your Android app from the Overview page: Go to one.newrelic.com > Mobile > (select an app). If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI, follow the troubleshooting procedures. Update your Android installation To keep your Android agent up to date, follow the procedures to upgrade the Android agent SDK for New Relic. To install the latest Android version for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Android 4.x: Multidex support New Relic's mobile monitoring for Android versions prior to Android 5.0 (API level 21) use the Dalvik runtime to execute app code. By default, Dalvik limits apps to a single classes.dex bytecode file per APK. In order to get around this limitation, you must enable multidex support. Then you can use the multidex support library, which becomes part of the primary DEX file of your app and then manages access to the additional DEX files and the code they contain. When building each DEX file for a multidex app, the build tools perform complex decision making to determine which classes are needed in the primary DEX file so that your app can start successfully. If any class required during startup is not provided in the primary DEX file, then your app crashes with the error java.lang.NoClassDefFoundError. If you see the java.lang.NoClassDefFoundError error, then you must manually specify these additional classes as required in the primary DEX file: Create a proguard.multidex.config file within the /app folder of your project. Update mypackage to reflect your package name. #################### # keep class names # #################### #Keep New Relic in the main dex -keep class com.newrelic.** { *; } -keep class com.mypackage.activities.** { *; } Copy Merge the following code into the app-level build.gradle file: android { defaultConfig{ … multiDexKeepProguard file(\"proguard.multidex.config\") } } Copy For more information, see the Android Developers documentation on declaring classes required in the primary DEX file. New Relic Gradle Plugin configuration For details on how to configure the behavior of the mobile monitoring agent plugin during Gradle builds, see the New Relic Gradle plugin extension guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.07198,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "sections": "<em>New</em> <em>Relic</em> Gradle Plugin configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " your <em>Android</em> app As part of the installation process for <em>mobile</em> <em>monitoring</em>, <em>New</em> <em>Relic</em> automatically generates an application token. This is a 40-character hexadecimal string for authenticating each <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. Go to one.newrelic.com &gt; <em>Mobile</em>. If applicable: From the <em>Mobile</em>"
      },
      "id": "603ea70128ccbc59c2eba74e"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android": [
    {
      "sections": [
        "Android agent compatibility and requirements",
        "Foreground monitoring",
        "Android compatibility",
        "Important",
        "Agent and Gradle compatibility",
        "Kotlin and Kotlin DSL",
        "Kotlin DSL support by Android agent version",
        "Kotlin DSL support by AGP version",
        "Unit testing not supported"
      ],
      "title": "Android agent compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "fdae9b0d2971ed33098e8c7cf6152654e45cca69",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/new-relic-android-compatibility-requirements/",
      "published_at": "2021-09-14T07:42:04Z",
      "updated_at": "2021-08-08T20:44:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring is compliant with standard application stores, including Google Play Store, Amazon Appstore, and others. Before you install and configure the mobile agent with your Android applications, follow these guidelines for compatibility and other requirements. Foreground monitoring The Android agent only monitors your app while it is in the foreground. The agent does not monitor background services while the app is closed. For more information, see our Mobile data privacy and security documentation. Android compatibility Make sure your Android app meets these requirements: Component Application requirements Operating system Android 2.3 or higher API/SDK HttpURLConnection, OkHttp2 (except versions 2.0 and 2.4), OkHttp (versions 2.8, 3.5+, 4.0+), OkIO (version 1.11), AndroidHttpClient, Volley (version 1.0.0), and Apache HTTP Client networking APIs Build with Android SDK Tools version 21 or higher and the following as appropriate: Android Studio Gradle 3.3 Gradle plugin 3.4 Proguard 5.0 DexGuard 7.2.04 through 8.x Important As of January 2021, our Android agent discontinued support for Android Gradle Plugin version 2. For more information, see our Explorers Hub post. Upgrade to the most recent version before installing the Android agent. Languages Java 1.7 through Java 9. JDK 11 is supported in version 6.2.0 and higher. Devices Any Android compatible device (smartphones, tablets, etc.) File sizes The agent adds less than 500KB to your release APK. Architectures ARM, Intel Atom Signature validation The agent cannot instrument JARs that use signature validation during signing. JARs with manifests containing SHA1-Digest or SHA-256-Digest attributes will not be modified. Agent and Gradle compatibility The following are compatible versions of the New Relic Android agent, Gradle, and the Android Gradle plugin. Important As of March 2021, our Android agent discontinued support for Android Gradle Plugin version 2. For more information, see our Explorers Hub post. Android Gradle plugin New Relic Android agent compatibility 2.3 No longer supported in versions 6.0 and higher. 5.25 - 5.26 are not supported 3.0 - 3.3 No longer supported in versions 6.0 and higher. 3.4 5.25 and higher 4.+ 5.26 and higher Kotlin and Kotlin DSL You can also use Kotlin projects with Gradle and New Relic's Android agent. Kotlin DSL support by Android agent version With the exception of incompatibilities noted with Android Gradle, New Relic's Android agent is compatible with versions 1.3 - 1.4 of the Kotlin Gradle Plugin. Kotlin DSL version New Relic Android agent compatibility 1.2 Unsupported 1.3 5.24 and lower: Requires Kotlin Gradle Plugin version 1.3.10 or higher 5.25: Requires Kotlin Gradle Plugin version 1.3.10 or higher 5.26: Unsupported in Android agent versions 5.26.0 through 5.28.0 1.4 5.24 and lower: Requires Kotlin Gradle Plugin version 1.3.10 or higher 5.25: Supported 5.26: Unsupported in Android agent versions 5.26.0 through 5.28.0 Kotlin DSL support by AGP version Kotlin DSL support was officially added to Android Gradle Plugin in version 4.1, but many developers are already using it in place of Groovy. Kotlin DSL version Android Gradle Plugin and Android Gradle compatibility 1.3 3.2 (AGP), 4.6 (Gradle) : Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.3 (AGP), (5.1.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.4 (AGP), 5.1.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.5 (AGP), 5.4.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.6 (AGP), 5.6.4 Gradle): Requires Kotlin Gradle Plugin version 1.3.40 or higher 4.0 (AGP), 6.1.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.40 or higher 4.1 (AGP), 6.5 Gradle): Requires Kotlin Gradle Plugin version 1.3.40 or higher 1.4 3.2 (AGP), 4.6 (Gradle) : Requires Gradle 5.3 3.3 (AGP), (5.1.1 Gradle): Requires Gradle 5.3 3.4 (AGP), 5.1.1 Gradle): Supported 3.5 (AGP), 5.4.1 Gradle): Supported 3.6 (AGP), 5.6.4 Gradle): Supported 4.0 (AGP), 6.1.1 Gradle): Supported 4.1 (AGP), 6.5 Gradle): Supported Unit testing not supported Our New Relic mobile agents are designed and tested to work in a normal app lifecycle. We do not support running any testing environment on applications with the agent. Testing can cause conflicts and unpredictable behavior.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.33223,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> agent compatibility and requirements",
        "sections": "Foreground <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "<em>Mobile</em> <em>monitoring</em> is compliant with standard application stores, including Google Play Store, Amazon Appstore, and others. Before you install and configure the <em>mobile</em> agent with your <em>Android</em> applications, follow these guidelines for compatibility and other requirements. Foreground <em>monitoring</em>"
      },
      "id": "604418abe7b9d2d1015799cc"
    },
    {
      "sections": [
        "Install Android apps with Gradle and Android Studio",
        "Install your Android app",
        "Configure with Gradle and Android Studio",
        "Project level build.gradle file:",
        "App level build.gradle file:",
        "Important",
        "Update your Android installation",
        "Android 4.x: Multidex support",
        "New Relic Gradle Plugin configuration"
      ],
      "title": "Install Android apps with Gradle and Android Studio",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "51fab3eba87ddee949cd4729de8b5f64534de9c7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-android-apps-gradle-android-studio/",
      "published_at": "2021-09-14T08:10:37Z",
      "updated_at": "2021-07-27T17:09:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Gradle or Android Studio, follow these instructions to install New Relic's mobile monitoring for the first time. If you have previously installed the Android agent SDK for mobile monitoring, follow the steps before upgrading to the latest version with Gradle and Android Studio. Install your Android app As part of the installation process for mobile monitoring, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. Go to one.newrelic.com > Mobile. If applicable: From the Mobile apps index, select Add a new app. From the Get started page, select Android as the platform for mobile monitoring. Type a meaningful name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring with Gradle and Android Studio. OR: To complete the configuration process for a new mobile app later: Go to one.newrelic.com > Mobile, then select See instructions next to your mobile app name. To upgrade an existing Android installation: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Configure with Gradle and Android Studio These procedures to configure your Android app with Gradle and Android Studio also appear on the Get started page in New Relic. Merge New Relic's mobile monitoring code in the Gradle & Android Studio tab to your build.gradle file. Project level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. buildscript { repositories { mavenCentral() } dependencies { classpath \"com.newrelic.agent.android:agent-gradle-plugin:AGENT_VERSION\" } } Copy App level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. repositories { mavenCentral() } apply plugin: 'android' apply plugin: 'newrelic' dependencies { compile 'com.newrelic.agent.android:android-agent:AGENT_VERSION' } Copy ProGuard or DexGuard: In your project’s root directory (projectname/app), add a newrelic.properties file with the following line: com.newrelic.application_token=GENERATED_TOKEN Copy Follow the additional, required configuration steps for using ProGuard or DexGuard with New Relic. Set app permissions: Ensure that your Android app requests INTERNET and ACCESS_NETWORK_STATE permissions by adding these lines to your AndroidManifest.xml file: <uses-permission android:name=\"android.permission.INTERNET\" /> <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /> Copy To start New Relic's mobile monitoring agent: In your Default Activity (as defined in your Manifest), import the NewRelic class: import com.newrelic.agent.android.NewRelic; Copy Important We do not support starting the mobile monitoring agent in other classes, as that can cause unexpected or unstable behavior. To initialize mobile monitoring: In the onCreate() method, add this call: NewRelic.withApplicationToken(\"GENERATED_TOKEN\").start(this.getApplication()); Copy Optional: Change the logging level. To build and run your application: Clean your project, then run your app in an emulator or device to generate traffic. Wait a few minutes, then view data for your Android app from the Overview page: Go to one.newrelic.com > Mobile > (select an app). If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI, follow the troubleshooting procedures. Update your Android installation To keep your Android agent up to date, follow the procedures to upgrade the Android agent SDK for New Relic. To install the latest Android version for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Android 4.x: Multidex support New Relic's mobile monitoring for Android versions prior to Android 5.0 (API level 21) use the Dalvik runtime to execute app code. By default, Dalvik limits apps to a single classes.dex bytecode file per APK. In order to get around this limitation, you must enable multidex support. Then you can use the multidex support library, which becomes part of the primary DEX file of your app and then manages access to the additional DEX files and the code they contain. When building each DEX file for a multidex app, the build tools perform complex decision making to determine which classes are needed in the primary DEX file so that your app can start successfully. If any class required during startup is not provided in the primary DEX file, then your app crashes with the error java.lang.NoClassDefFoundError. If you see the java.lang.NoClassDefFoundError error, then you must manually specify these additional classes as required in the primary DEX file: Create a proguard.multidex.config file within the /app folder of your project. Update mypackage to reflect your package name. #################### # keep class names # #################### #Keep New Relic in the main dex -keep class com.newrelic.** { *; } -keep class com.mypackage.activities.** { *; } Copy Merge the following code into the app-level build.gradle file: android { defaultConfig{ … multiDexKeepProguard file(\"proguard.multidex.config\") } } Copy For more information, see the Android Developers documentation on declaring classes required in the primary DEX file. New Relic Gradle Plugin configuration For details on how to configure the behavior of the mobile monitoring agent plugin during Gradle builds, see the New Relic Gradle plugin extension guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.8395,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "sections": "<em>New</em> <em>Relic</em> Gradle Plugin configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " These procedures to configure your <em>Android</em> app with Gradle and <em>Android</em> Studio also appear on the <em>Get</em> <em>started</em> page in <em>New</em> <em>Relic</em>. Merge <em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> code in the Gradle &amp; <em>Android</em> Studio tab to your build.gradle file. Project level build.gradle file: In this example, AGENT_VERSION represents your"
      },
      "id": "603ea70128ccbc59c2eba74e"
    },
    {
      "sections": [
        "Configure ProGuard or DexGuard for Android apps",
        "Configure ProGuard",
        "Network library support",
        "Configure DexGuard"
      ],
      "title": "Configure ProGuard or DexGuard for Android apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "8a8df969c4099f75cb214354cef311dfa2ab50e2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/configure-proguard-or-dexguard-android-apps/",
      "published_at": "2021-09-14T07:45:07Z",
      "updated_at": "2021-08-21T09:16:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to support ProGuard or DexGuard with the Android agent. Check our Android compatibility and requirements, and if you have previously installed the Android agent SDK, follow the steps before upgrading to the latest version with ProGuard or DexGuard. Configure ProGuard To add support for ProGuard: Add an exclusion to your app; for example: To support New Relic instrumentation, add keep class. To disable warnings related to unresolved problems, add dont warn. To preserve line numbers for crash reporting, add LineNumberTable. To preserve stack information for handled exceptions, add SourceFile and EnclosingMethod. Add the following to your ProGuard config file (proguard.cfg, proguard-android.txt, proguard-rules.pro, etc.): -keep class com.newrelic.** { *; } -dontwarn com.newrelic.** -keepattributes Exceptions, Signature, InnerClasses, LineNumberTable, SourceFile, EnclosingMethod Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors. Network library support New Relic instrumentation happens before ProGuard obfuscates your code. In order for these libraries to be properly instrumented, their classes must not be obfuscated by ProGuard. Here are examples of rules to be applied to preserve these classes. This is not a complete list. Different rules will be needed depending on your library or version. Library Rules Apache Http -keep class org.apache.http.** { *; } -dontwarn org.apache.http.** Copy OkHttp 2 -keep class com.squareup.okhttp.* { *; } -dontwarn com.squareup.okhttp.** -dontwarn okio.** Copy OkHttp 3 -keep class okhttp3.** { *; } -dontwarn okhttp3.** -dontwarn okio.** Copy Retrofit 2 -keep class retrofit2.** { *; } -dontwarn retrofit2.** Copy Configure DexGuard DexGuard uses the same configuration options as ProGuard, and it can read any pre-existing ProGuard configuration files. DexGuard also has its own set of additional configuration options and provides sample configurations for many common app frameworks. To add support for DexGuard: Add DexGuard to your app and set up the Gradle plugin according to the directions from DexGuard. Create a dexguard-project.txt file to hold specific DexGuard configuration options, and add: -dontnote com.newrelic.agent.android.NewRelic -dontnote com.newrelic.agent.android.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app's buildTypes configuration is similar to this: buildTypes { release { minifyEnabled true proguardFile getDefaultDexGuardFile('dexguard-release.pro') proguardFile 'proguard-rules.pro' proguardFile 'dexguard-project.txt' } ... Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.1511,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Configure ProGuard or DexGuard for <em>Android</em> apps",
        "sections": "Configure ProGuard or DexGuard for <em>Android</em> apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " true proguardFile <em>get</em>DefaultDexGuardFile(&#x27;dexguard-release.pro&#x27;) proguardFile &#x27;proguard-rules.pro&#x27; proguardFile &#x27;dexguard-project.txt&#x27; } ... Copy Clean and rebuild your project. Run your app in an emulator or device to <em>start</em> seeing data on your <em>mobile</em> app&#x27;s Overview page. Optional: Use the <em>mobile</em> <em>monitoring</em> Settings page to customize your <em>mobile</em> app. If no data appears, review your logcat output for errors."
      },
      "id": "604418de196a6770e7960f6c"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/get-started/new-relic-android-compatibility-requirements": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-09-14T07:43:31Z",
      "updated_at": "2021-07-08T02:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.4041,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": ". As part of the installation process, <em>mobile</em> <em>monitoring</em> automatically generates an application token. This is a 40-character hexadecimal string for authenticating each <em>mobile</em> app that you <em>monitor</em>. Follow the <em>Android</em> installation and configuration procedures for your environment as applicable. If you have"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Install Android apps with Gradle and Android Studio",
        "Install your Android app",
        "Configure with Gradle and Android Studio",
        "Project level build.gradle file:",
        "App level build.gradle file:",
        "Important",
        "Update your Android installation",
        "Android 4.x: Multidex support",
        "New Relic Gradle Plugin configuration"
      ],
      "title": "Install Android apps with Gradle and Android Studio",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "51fab3eba87ddee949cd4729de8b5f64534de9c7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-android-apps-gradle-android-studio/",
      "published_at": "2021-09-14T08:10:37Z",
      "updated_at": "2021-07-27T17:09:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Gradle or Android Studio, follow these instructions to install New Relic's mobile monitoring for the first time. If you have previously installed the Android agent SDK for mobile monitoring, follow the steps before upgrading to the latest version with Gradle and Android Studio. Install your Android app As part of the installation process for mobile monitoring, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. Go to one.newrelic.com > Mobile. If applicable: From the Mobile apps index, select Add a new app. From the Get started page, select Android as the platform for mobile monitoring. Type a meaningful name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring with Gradle and Android Studio. OR: To complete the configuration process for a new mobile app later: Go to one.newrelic.com > Mobile, then select See instructions next to your mobile app name. To upgrade an existing Android installation: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Configure with Gradle and Android Studio These procedures to configure your Android app with Gradle and Android Studio also appear on the Get started page in New Relic. Merge New Relic's mobile monitoring code in the Gradle & Android Studio tab to your build.gradle file. Project level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. buildscript { repositories { mavenCentral() } dependencies { classpath \"com.newrelic.agent.android:agent-gradle-plugin:AGENT_VERSION\" } } Copy App level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. repositories { mavenCentral() } apply plugin: 'android' apply plugin: 'newrelic' dependencies { compile 'com.newrelic.agent.android:android-agent:AGENT_VERSION' } Copy ProGuard or DexGuard: In your project’s root directory (projectname/app), add a newrelic.properties file with the following line: com.newrelic.application_token=GENERATED_TOKEN Copy Follow the additional, required configuration steps for using ProGuard or DexGuard with New Relic. Set app permissions: Ensure that your Android app requests INTERNET and ACCESS_NETWORK_STATE permissions by adding these lines to your AndroidManifest.xml file: <uses-permission android:name=\"android.permission.INTERNET\" /> <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /> Copy To start New Relic's mobile monitoring agent: In your Default Activity (as defined in your Manifest), import the NewRelic class: import com.newrelic.agent.android.NewRelic; Copy Important We do not support starting the mobile monitoring agent in other classes, as that can cause unexpected or unstable behavior. To initialize mobile monitoring: In the onCreate() method, add this call: NewRelic.withApplicationToken(\"GENERATED_TOKEN\").start(this.getApplication()); Copy Optional: Change the logging level. To build and run your application: Clean your project, then run your app in an emulator or device to generate traffic. Wait a few minutes, then view data for your Android app from the Overview page: Go to one.newrelic.com > Mobile > (select an app). If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI, follow the troubleshooting procedures. Update your Android installation To keep your Android agent up to date, follow the procedures to upgrade the Android agent SDK for New Relic. To install the latest Android version for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Android 4.x: Multidex support New Relic's mobile monitoring for Android versions prior to Android 5.0 (API level 21) use the Dalvik runtime to execute app code. By default, Dalvik limits apps to a single classes.dex bytecode file per APK. In order to get around this limitation, you must enable multidex support. Then you can use the multidex support library, which becomes part of the primary DEX file of your app and then manages access to the additional DEX files and the code they contain. When building each DEX file for a multidex app, the build tools perform complex decision making to determine which classes are needed in the primary DEX file so that your app can start successfully. If any class required during startup is not provided in the primary DEX file, then your app crashes with the error java.lang.NoClassDefFoundError. If you see the java.lang.NoClassDefFoundError error, then you must manually specify these additional classes as required in the primary DEX file: Create a proguard.multidex.config file within the /app folder of your project. Update mypackage to reflect your package name. #################### # keep class names # #################### #Keep New Relic in the main dex -keep class com.newrelic.** { *; } -keep class com.mypackage.activities.** { *; } Copy Merge the following code into the app-level build.gradle file: android { defaultConfig{ … multiDexKeepProguard file(\"proguard.multidex.config\") } } Copy For more information, see the Android Developers documentation on declaring classes required in the primary DEX file. New Relic Gradle Plugin configuration For details on how to configure the behavior of the mobile monitoring agent plugin during Gradle builds, see the New Relic Gradle plugin extension guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.83949,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "sections": "<em>New</em> <em>Relic</em> Gradle Plugin configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " These procedures to configure your <em>Android</em> app with Gradle and <em>Android</em> Studio also appear on the <em>Get</em> <em>started</em> page in <em>New</em> <em>Relic</em>. Merge <em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> code in the Gradle &amp; <em>Android</em> Studio tab to your build.gradle file. Project level build.gradle file: In this example, AGENT_VERSION represents your"
      },
      "id": "603ea70128ccbc59c2eba74e"
    },
    {
      "sections": [
        "Configure ProGuard or DexGuard for Android apps",
        "Configure ProGuard",
        "Network library support",
        "Configure DexGuard"
      ],
      "title": "Configure ProGuard or DexGuard for Android apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "8a8df969c4099f75cb214354cef311dfa2ab50e2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/configure-proguard-or-dexguard-android-apps/",
      "published_at": "2021-09-14T07:45:07Z",
      "updated_at": "2021-08-21T09:16:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to support ProGuard or DexGuard with the Android agent. Check our Android compatibility and requirements, and if you have previously installed the Android agent SDK, follow the steps before upgrading to the latest version with ProGuard or DexGuard. Configure ProGuard To add support for ProGuard: Add an exclusion to your app; for example: To support New Relic instrumentation, add keep class. To disable warnings related to unresolved problems, add dont warn. To preserve line numbers for crash reporting, add LineNumberTable. To preserve stack information for handled exceptions, add SourceFile and EnclosingMethod. Add the following to your ProGuard config file (proguard.cfg, proguard-android.txt, proguard-rules.pro, etc.): -keep class com.newrelic.** { *; } -dontwarn com.newrelic.** -keepattributes Exceptions, Signature, InnerClasses, LineNumberTable, SourceFile, EnclosingMethod Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors. Network library support New Relic instrumentation happens before ProGuard obfuscates your code. In order for these libraries to be properly instrumented, their classes must not be obfuscated by ProGuard. Here are examples of rules to be applied to preserve these classes. This is not a complete list. Different rules will be needed depending on your library or version. Library Rules Apache Http -keep class org.apache.http.** { *; } -dontwarn org.apache.http.** Copy OkHttp 2 -keep class com.squareup.okhttp.* { *; } -dontwarn com.squareup.okhttp.** -dontwarn okio.** Copy OkHttp 3 -keep class okhttp3.** { *; } -dontwarn okhttp3.** -dontwarn okio.** Copy Retrofit 2 -keep class retrofit2.** { *; } -dontwarn retrofit2.** Copy Configure DexGuard DexGuard uses the same configuration options as ProGuard, and it can read any pre-existing ProGuard configuration files. DexGuard also has its own set of additional configuration options and provides sample configurations for many common app frameworks. To add support for DexGuard: Add DexGuard to your app and set up the Gradle plugin according to the directions from DexGuard. Create a dexguard-project.txt file to hold specific DexGuard configuration options, and add: -dontnote com.newrelic.agent.android.NewRelic -dontnote com.newrelic.agent.android.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app's buildTypes configuration is similar to this: buildTypes { release { minifyEnabled true proguardFile getDefaultDexGuardFile('dexguard-release.pro') proguardFile 'proguard-rules.pro' proguardFile 'dexguard-project.txt' } ... Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.15109,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Configure ProGuard or DexGuard for <em>Android</em> apps",
        "sections": "Configure ProGuard or DexGuard for <em>Android</em> apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " true proguardFile <em>get</em>DefaultDexGuardFile(&#x27;dexguard-release.pro&#x27;) proguardFile &#x27;proguard-rules.pro&#x27; proguardFile &#x27;dexguard-project.txt&#x27; } ... Copy Clean and rebuild your project. Run your app in an emulator or device to <em>start</em> seeing data on your <em>mobile</em> app&#x27;s Overview page. Optional: Use the <em>mobile</em> <em>monitoring</em> Settings page to customize your <em>mobile</em> app. If no data appears, review your logcat output for errors."
      },
      "id": "604418de196a6770e7960f6c"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/get-started/new-relic-mobile-and-dt": [
    {
      "sections": [
        "Language agents and distributed tracing",
        "Tip",
        "Quick start for standard distributed tracing (recommended):",
        "Step 1. Identify services",
        "Step 2. Instrument each service with an APM agent",
        "Step 3. View traces",
        "View traces that include a specific service",
        "View traces across accounts",
        "Set up Infinite Tracing (advanced option)",
        "Step 1. Complete the instrumentation for standard distributed tracing in the quick start above",
        "Step 2. Set up the trace observer",
        "Step 3: Configure the agent for Infinite Tracing",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Step 4. (Optional) Customize Infinite Tracing",
        "Options for older APM agents",
        "Compatibility guide",
        "Important",
        "Configure standard distributed tracing for your older agents",
        "Manual instrumentation (If automatic instrumentation doesn't work)",
        "Instrument the calling service",
        "Instrument the called service"
      ],
      "title": "Language agents and distributed tracing",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Distributed tracing",
        "Enable and configure"
      ],
      "external_id": "b87eacf981bfae09990c95604ba3b7fc19741a40",
      "image": "",
      "url": "https://docs.newrelic.com/docs/distributed-tracing/enable-configure/language-agents-enable-distributed-tracing/",
      "published_at": "2021-09-14T09:14:47Z",
      "updated_at": "2021-09-14T09:14:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic has APM language agents for C, Go, Java, Node.js, .NET, PHP, Python, and Ruby. Each of these offers several ways to leverage the power of distributed tracing: Quick start for standard distributed tracing (recommended): A fast way to get started Infinite Tracing: An advanced alternative to standard distributed tracing Older APM agents: Tracing options if you have older APM agents Manual instrumentation: Tips if automatic instrumentation doesn't work Tip If you want to get more background before getting started, check out these topics: How span sampling works explains distributed tracing options. Impacts to APM tells you what to expect if you are a current APM user but haven't set up distributed tracing. Quick start for standard distributed tracing (recommended): This is the best approach to set up standard distributed tracing if you haven't installed any APM agents for your services yet, or if you want to instrument additional services. Tip You'll need a New Relic account to set up distributed tracing. If you don't already have one, you can quickly create a free account. Step 1. Identify services Figure out which services you want to instrument so they each send trace data to New Relic. Step 2. Instrument each service with an APM agent We have installation assistants for a variety of languages to help you instrument each service. You should run the installation assistant for each service you want to instrument to ensure that each installation has a unique application name. To start the assistant, click the link for your language: APM: C APM: Golang APM: Java APM: .NET APM: Node.js APM: PHP APM: Python APM: Ruby Tip This quick-start approach with the installation assistant automatically enables distributed tracing for each service you run it on, but if you already have a APM agent that you want to participate in distributed tracing, you'll need to manually enable distributed tracing. See Options for older APM agents. Step 3. View traces After you instrument each of your services with APM agents, generate some traffic in your application so we can capture some traces. Here are two ways to view your traces in the UI: View traces that include a specific service Here's one way you can see traces for a particular service: Go to one.newrelic.com. Click APM in the top menu bar. Click your service. In the left navigation's Monitor section, click Distributed tracing. If you don't see the traces you want, you can filter by the trace.id. View traces across accounts This option allows you to search all traces across all New Relic accounts in your organization that you have access to. Go to one.newrelic.com. Click Browse data in the top menu bar, and then click Traces. Select your entity in the left pane. If you don't see the traces you want, you can filter by the trace.id. For more help finding your traces in the UI: Understand and use the distributed tracing UI Query distributed trace data Set up Infinite Tracing (advanced option) Standard distributed tracing for APM agents (above) captures up to 10% of your traces, but if you want us to analyze all your data and find the most relevant traces, you can set up Infinite Tracing. This alternative to standard distributed tracing is available for all APM language agents except C SDK. Tip To learn more about this feature, see Infinite Tracing. Before beginning, first ensure you meet the requirements. Step 1. Complete the instrumentation for standard distributed tracing in the quick start above The Infinite Tracing setup builds on the instrumentation step from the Quick start for standard distributed tracing. Step 2. Set up the trace observer The trace observer is a New Relic AWS-based service that collects and analyzes all your traces. Follow the instructions in Set up trace observer. When you're done, return here with your trace observer information and continue with the next step to configure the agent. Step 3: Configure the agent for Infinite Tracing Infinite Tracing configuration settings include the standard distributed tracing plus information about the trace observer. Find the settings for your language agent below: C SDK Infinite tracing is not available for C SDK. Go Here's an overview of the settings. For more help with configuration, see Enable distributed tracing for your Go applications. Type Required configuration Infinite Tracing Configuration options: newrelic.Config structure: app, err := newrelic.NewApplication( newrelic.ConfigAppName(YOUR_APP_NAME), newrelic.ConfigLicense(YOUR_LICENSE_KEY), func(cfg *newrelic.Config) { cfg.DistributedTracer.Enabled = true cfg.InfiniteTracing.TraceObserver.Host = YOUR_TRACE_OBSERVER_HOST }, ) Copy Environment variables: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST=YOUR_TRACE_OBSERVER_HOST Copy Java Here's an overview of the settings. For more help with configuration, see Java agent configuration: Config file. Type Required configuration Infinite Tracing Configuration options: Configuration file (newrelic.yml) (indented 2 spaces under the common stanza): distributed_tracing: enabled: true infinite_tracing: trace_observer: host: \"YOUR_TRACE_OBSERVER_HOST\" Copy Java system property: -Dnewrelic.config.distributed_tracing.enabled=true -Dnewrelic.config.infinite_tracing.trace_observer.host=\"YOUR_TRACE_OBSERVER_HOST\" Copy Environment variables: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST=\"YOUR_TRACE_OBSERVER_HOST\" Copy .NET Here's an overview of the settings. For more help with configuration, see .NET agent configuration. Type Required configuration Infinite Tracing Configuration options: Configuration file (newrelic.config): <configuration . . . > <distributedTracing enabled=\"true\" /> <infiniteTracing> <trace_observer host=\"YOUR_TRACE_OBSERVER_HOST\" /> </infiniteTracing> </configuration> Copy Environment variables: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST=\"YOUR_TRACE_OBSERVER_HOST\" Copy Node.js Here's an overview of the settings. For more help with configuration, see Node.js agent configuration. Type Required configuration Infinite Tracing Configuration options: Configuration file (newrelic.js): distributed_tracing: { enabled: true } infinite_tracing: { trace_observer: { host: 'YOUR_TRACE_OBSERVER_HOST' } } Copy Environment variables: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST=\"YOUR_TRACE_OBSERVER_HOST\" Copy PHP Here's an overview of the settings. For more help with configuration, see Distributed tracing for the PHP agent Type Required configuration Infinite Tracing Configuration options: Configuration file (newrelic.ini): newrelic.distributed_tracing_enabled = true newrelic.span_events_enabled = true newrelic.infinite_tracing.trace_observer.host= \"YOUR_TRACE_OBSERVER_HOST\" Copy Python Here's an overview of the settings. For more help with configuration, see Python agent configuration Type Required configuration Infinite Tracing Pull down the libraries with this installation command, and then set up the configuration file or environment variables: pip install newrelic[infinite-tracing] Copy Configuration options: Configuration file (newrelic.ini): distributed_tracing.enabled = true infinite_tracing.trace_observer_host= YOUR_TRACE_OBSERVER_HOST Copy Environment variables: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST=\"YOUR_TRACE_OBSERVER_HOST\" Copy Ruby Here's an overview of the settings. For more help with configuration, see Ruby agent configuration. To set up Infinite Tracing, you need to install the Infinite Tracing gem. The gem is available in rubygems.org. For applications using Bundler, additionally include the Infinite Tracing gem in the Gemfile: gem 'newrelic-infinite_tracing' Copy If you're using Rails 3 or higher, or Rails 2.3 in the recommended configuration, Rails will automatically call Bundler.require and cause newrelic-infinite_tracing to be required during startup of your application. If you're using Sinatra or another framework, you must manually call require 'newrelic/infinite_tracing' or manually call Bundler.require. Type Required configuration Infinite Tracing Configuration options: Configuration file (newrelic.yml): distributed_tracing: enabled: true infinite_tracing: trace_observer: host: 'YOUR_TRACE_OBSERVER_HOST' Copy Environment variables: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST=\"YOUR_TRACE_OBSERVER_HOST\" Copy Step 4. (Optional) Customize Infinite Tracing After you add the agent configuration settings, you should start seeing data in the New Relic UI. After you spend some time analyzing your data, you may want to adjust some of the features of Infinite Tracing: Configure trace observer monitoring Configure span attribute trace filter Configure random trace filter Options for older APM agents If you have older APM agents, use this section to figure out if the distributed tracing features you want are supported. Following the compatibility information is a section showing the basic configuration settings to turn on standard distributed tracing. If your older agent supports Infinite Tracing and you want to set it up, see the steps above. Compatibility guide Find your language agents below to confirm if you can use your existing agents with distributed tracing: C SDK Install (compile) or update to the required C SDK version. For best results, update to the latest C SDK version. Option C SDK version Standard distributed tracing 1.1.0 or higher (W3C Trace Context not available) Infinite Tracing Not available Go Install or update to the required Go agent version. For best results, update to the latest Go agent version. Option Go agent version Standard distributed tracing 2.1.0 or higher With W3C Trace Context: 3.1.0 or higher Infinite Tracing v3.5.0 (includes W3C Trace Context) Supported environments: Go 1.9 or higher Java Install or update to the required Java agent version. For best results, update to the latest Java agent version. Important Your JVM's networkaddress.cache.ttl security setting must not be set to forever (i.e. -1). For more information about this networking property, please visit the Oracle Network Properties docs. Type Java agent version Standard distributed tracing 4.3.0 or higher With W3C Trace Context: 5.10 or higher Infinite Tracing 5.12.1 or higher (includes W3C Trace Context) Supported environments: Java 8: Update 252 or higher All versions of Java 9 or higher Tip For special considerations, see Infinite Tracing: Configuring SSL for Java 7 and 8. .NET Install or update to the required .NET agent version. For best results, update to the latest .NET agent version. Option .NET agent version Standard distributed tracing 8.6.45.0 or higher With W3C Trace Context: 8.27.139.0 or higher Infinite Tracing 8.30.0 (includes W3C Trace Context) Supported environments: .NET Framework 4.5 or higher .NET Core 2.0 or higher Node.js Install or update to the required Node.js agent version. For best results, update to the latest Node.js agent version. Option Node.js agent version Standard distributed tracing 4.7.0 or higher With W3C Trace Context: 6.4 or higher Infinite Tracing 7.3.0 (includes W3C Trace Context) Supported environments: Node version 10.10.0 or higher PHP Install or update to the required PHP agent version. For best results, update to the latest PHP agent version. Option PHP agent version Standard distributed tracing 8.4 or higher With W3C Trace Context: 9.8 or higher Infinite Tracing 9.12.0.268 or higher Python Install or update to the required Python agent version. For best results, update to the latest Python agent version. Option Python agent version Standard distributed tracing 4.2.0.100 or higher With W3C Trace Context: 5.6 or higher Infinite Tracing 5.12.0.140 (includes W3C Trace Context) Supported environments: CPython only (pypy is unsupported) Ruby Install or update to the required Ruby agent version. For Infinite Tracing, you also need to install the Infinite Tracing gem. For best results, update to the latest Ruby agent version and Infinite Tracing gem version, if applicable. Option Ruby agent version Standard distributed tracing newrelic_rpm 5.3.0.346 or higher With W3C Trace Context: newrelic_rpm 6.9 or higher Infinite Tracing newrelic_rpm 7.0.0 or higher (includes W3C Trace Context) newrelic-infinite_tracing 7.0.0 or higher Supported environments: Ruby 2.5 or higher Configure standard distributed tracing for your older agents Distributed tracing is enabled through configuration settings. Review the following agent-specific sections. For general help with agent configurations, see Configure the agent. Important Server-side configuration is not available for Infinite Tracing. C SDK Here's an overview of the settings. For more help with configuration, see Enable distributed tracing for your C applications. Type Required configuration Standard distributed tracing Configuration options: newrelic_app_config_t structure: newrelic_app_config_t* config; config = newrelic_create_app_config(app_name, license_key); config->distributed_tracing.enabled = true; Copy Go Here's an overview of the settings. For more help with configuration, see Enable distributed tracing for your Go applications. Type Required configuration Standard distributed tracing Configuration options: ConfigOption structure: newrelic.NewApplication( newrelic.ConfigAppName(\"Example App\"), newrelic.ConfigLicense(os.Getenv(\"NEW_RELIC_LICENSE_KEY\")), newrelic.ConfigDistributedTracerEnabled(true), ) Copy Environment variable: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true Copy Java Here's an overview of the settings. For more help with configuration, see Java agent configuration: Config file. Type Required configuration Standard distributed tracing Configuration options: Configuration file (newrelic.yml) (indented 2 spaces under the common stanza): distributed_tracing: enabled: true Copy Java system property: -Dnewrelic.config.distributed_tracing.enabled=true Copy Environment variable: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true Copy Infinite Tracing Configuration options: Configuration file (newrelic.yml) (indented 2 spaces under the common stanza): distributed_tracing: enabled: true infinite_tracing: trace_observer: host: \"YOUR_TRACE_OBSERVER_HOST\" Copy Java system property: -Dnewrelic.config.distributed_tracing.enabled=true -Dnewrelic.config.infinite_tracing.trace_observer.host=\"YOUR_TRACE_OBSERVER_HOST\" Copy Environment variable: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST=\"YOUR_TRACE_OBSERVER_HOST\" Copy .NET Here's an overview of the settings. For more help with configuration, see .NET agent configuration. Type Required configuration Standard distributed tracing Configuration options: Configuration file (newrelic.config): <configuration . . . > <distributedTracing enabled=\"true\" /> </configuration> Copy Environment variable: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true Copy Node.js Here's an overview of the settings. For more help with configuration, see Node.js agent configuration. Type Required configuration Standard distributed tracing Configuration options: Configuration file (newrelic.js): distributed_tracing: { enabled: true } Copy Environment variable: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true Copy PHP Here's an overview of the settings. For more help with configuration, see Distributed tracing for the PHP agent Type Required configuration Standard distributed tracing Configuration options: Configuration file (newrelic.ini): newrelic.distributed_tracing_enabled = true Copy Python Here's an overview of the settings. For more help with configuration, see Python agent configuration Type Required configuration Standard distributed tracing Configuration file (newrelic.ini): distributed_tracing.enabled = true Copy Environment variable: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true Copy Ruby Here's an overview of the settings. For more help with configuration, see Ruby agent configuration. Type Required configuration Standard distributed tracing Configuration options: Configuration file (newrelic.yml): distributed_tracing: enabled: true Copy Environment variable: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true Copy Tip If you need help with proxy configuration, see Proxy support. Manual instrumentation (If automatic instrumentation doesn't work) Recommendation: Before performing any custom instrumentation, read: How distributed tracing works Troubleshoot missing data If a service is not passing the trace header to other services, you can use the distributed tracing payload APIs to instrument the calling service and the called service. The calling service uses an API call to generate a payload, which is accepted by the called service. Instrument the calling service To instrument the calling service: Ensure the version of the APM agent that monitors the calling service supports distributed tracing. Invoke the agent API call for generating a distributed trace payload: C SDK | Go | Java | .NET | Node.js | PHP | Python | Ruby. Important To maintain proper ordering of spans in a trace, ensure you generate the payload in the context of the span that sends it. Add that payload to the call made to the destination service (for example, in a header). (Optional) Identify the call as an external call: C SDK Go Java .NET: n/a Node.js PHP: n/a Python Ruby Instrument the called service To instrument the called service: Ensure the version of the APM agent that monitors the called service supports distributed tracing. If the New Relic agent on the called service does not identify a New Relic transaction, use the agent API to declare a transaction: C SDK One way to tell that a transaction is not in progress: when newrelic_create_distributed_trace_payload() is called, a NULL pointer is returned. To solve this problem, follow the procedures to create a transaction with the C SDK. Go One way to tell that a transaction is not in progress: when Transaction.InsertDistributedTraceHeaders(h http.Header) is called, no headers are inserted. To create a transaction, see Instrument Go transactions. Java One way to tell that a transaction is not in progress: when Transaction.insertDistributedTraceHeaders(Headers) is called, no headers are inserted (this API requires agent 6.4.0+). To create a transaction, see Java agent transaction-related APIs. .NET One way to tell that a transaction is not in progress: CreateDistributedTracePayload() returns an empty payload. To create a transaction, see Introduction to .NET custom instrumentation. Node.js One way to tell that a transaction is not in progress: the Node.js agent logs will report an error similar to this: No transaction found when calling Transaction.acceptDistributedTracePayload. Copy Use startWebTransaction to create a web transaction or startBackgroundTransaction to capture a non-web transaction. PHP One way to tell that a transaction is not in progress: newrelic_insert_distributed_trace_headers() returns false. To create a transaction, see newrelic_start_transaction. Python To tell that a transaction is not in progress: when transaction = current_transaction() is run, transaction is None. Or, if result = accept_distributed_trace_payload(payload) is run, then the result is False. Use background_task to report a non-web transaction. For more on Python instrumentation, see Monitor transactions and segments. Ruby If you are using a Rack-based web framework and have enabled New Relic's Rack instrumentation, the Ruby agent will handle starting a transaction for you. For other use cases, see the add_transaction_tracer API method. Extract the payload from the call that you received (for example, in a header). Invoke the call for accepting the payload: C SDK | Go | Java | .NET | PHP | Node.js | Python | Ruby.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 186.3069,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Language agents and <em>distributed</em> <em>tracing</em>",
        "sections": "Language agents and <em>distributed</em> <em>tracing</em>",
        "tags": "<em>Distributed</em> <em>tracing</em>",
        "body": " services yet, or if you want to instrument additional services. Tip You&#x27;ll need a <em>New</em> <em>Relic</em> account to set up <em>distributed</em> <em>tracing</em>. If you don&#x27;t already have one, you can quickly create a free account. Step 1. Identify services Figure out which services you want to instrument so they each send <em>trace</em>"
      },
      "id": "6072a66564441fb28e9d8595"
    },
    {
      "sections": [
        "Understand and use the distributed tracing UI",
        "Open the distributed tracing UI",
        "View traces for a specific service",
        "View traces across all accounts",
        "Tip",
        "Find traces that are useful",
        "Filter using the query bar",
        "Find traces that touch two services",
        "Find error spans using the like operator",
        "Trace groups",
        "Filter using the scatter plot",
        "Filters",
        "Trace histograms",
        "Important",
        "Trace details UI page",
        "Trace map",
        "Span properties",
        "Span details pane",
        "View related logs",
        "Additional UI details",
        "How to understand span errors",
        "Anomalous spans",
        "Client span duration: time differences between client and server spans",
        "Fragmented traces",
        "Trace details obfuscated based on account access",
        "Span limits and sampling",
        "Incomplete span names in waterfall view",
        "Missing spans and span/service count discrepancies"
      ],
      "title": "Understand and use the distributed tracing UI",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Distributed tracing",
        "UI and data"
      ],
      "external_id": "f5b66e03583e42613810f1390b4e5adab4ed2caa",
      "image": "https://docs.newrelic.com/static/ec08996f31e6586bb257c6f89b3c8f99/e5166/new-relic-distributed-tracing-client-span-time.jpg",
      "url": "https://docs.newrelic.com/docs/distributed-tracing/ui-data/understand-use-distributed-tracing-ui/",
      "published_at": "2021-09-13T22:02:23Z",
      "updated_at": "2021-09-13T22:02:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Distributed tracing helps you monitor and analyze the behavior of your distributed system. After you enable distributed tracing, you can use our UI tools to search for traces and analyze them. For example, let's say you are an engineer troubleshooting errors in a complex transaction spanning many services. Here's what you can do in our UI: Open the distributed tracing UI page. Sort through your traces using a filter to find that specific request and show only traces containing errors. On the trace details page, you review the span along the request route that originated the error. Noting the error class and message, navigate to the service from its span in the trace so you can see that the error is occurring at a high rate. Read on to explore the options in the distributed tracing UI. Open the distributed tracing UI Here's how you can access the distributed tracing UI, depending on the type of search you want to do: View traces for a specific service The New Relic Explorer and APM are two menu options that help you navigate to a specific service so you can see traces that include that service. Go to one.newrelic.com. Click Explorer or APM in the top menu bar. Filter to the service you enabled for distributed tracing by typing the service name, and then press Enter. In the left navigation's Monitor section, click Distributed tracing. View traces across all accounts If you want to view traces from across all accounts you have access to, go to one.newrelic.com, click Browse data, and then Traces. Tip If you don't have access to accounts for some services in a trace, we'll obfuscate some details for those services. Find traces that are useful We have a variety of tools to help you find traces and spans so you can resolve issues. The opening distributed tracing page is populated with a default list of traces, and you can quickly refine this list using these tools: Query bar Trace groups Scatter plot chart Filters Interactive histograms Tip In addition to these tools, you can also use other options mentioned in Query distributed trace data. Filter using the query bar The Find traces query bar is a quick way to narrow your search for traces. You can either start typing in the query bar or use the dropdown to create a compound query. Query returns are based on span attributes, not on trace attributes. You define spans that have certain criteria, and the search displays traces that contain those spans. If you use a multi-attribute filter, it is affected by first attribute selected. Distributed tracing reports on two types of data: transaction events and spans. When you select an attribute in the filter, the data type that attribute is attached to dictates the available attributes. For example, if you filter on an attribute that is attached to a transaction event, only transaction event attributes are available when you attempt to add filter on additional attribute values. Queries for traces are similar to NRQL (our query language). Here are the main exceptions: String values don't require quote marks (for example, you can use either appName = MyApp or appName = 'MyApp') The like operator doesn’t require % (for example, you can use either appName like product or appName like %product%). Tip Some queries that return a large number of results may return false positives. The trace list limits these incorrect results to 10% of the returned results. False positives may also result in histogram chart results that are not displayed in the trace list. Here are two query bar examples: Find traces that touch two services The query in the image below finds traces that: Pass through both WebPortal and Inventory Service applications Have an Inventory Service datastore call that takes longer than 500 ms Contains an error in any span. Go to one.newrelic.com > Apps > Distributed tracing Find error spans using the like operator The query in the image below finds traces that: Contain spans that pass through the WebPortal application and where an error occurred on any span in the WebPortal application Contain spans where the customer_user_email attribute contains a value ending with hotmail.com anywhere in the trace. Go to one.newrelic.com > Apps > Distributed tracing Trace groups The default view of distributed tracing shows traces grouped by the same root entry span. In other words, traces are grouped by the span where New Relic began recording the request. You can slide the toggle Group similar traces to turn this on and off. With trace groups you get a high-level view of traces so you can understand request behavior for groups of similar traces. This helps you understand dips or spikes in trace count, duration, and errors. When you click on one of the trace groups, you get all the standard details in context of the specific trace group you selected. Filter using the scatter plot The trace scatter plot is a quick way to search for outlying traces. This is available on the opening page of distributed tracing if you turn off the Group similar traces toggle at the top of the page. In the scatter plot, you can move the cursor across the chart to view trace details and you can click individual points to get details: Here's how you can control what's displayed in the scatter plot: In the View by dropdown, select the duration type: Back-end duration Root span duration Trace duration In Group traces by, select one of these options: Errors: Group by whether or not traces contain errors. Root service: Group by the name of the first service in traces. In a trace where Service A calls Service B and Service B calls Service C, the root service would be Service A. Root entry span: Group by the root transaction, which is the root service's endpoint. In a trace where Service A calls Service B and Service B calls Service C, the root entry span is Service A's endpoint. For example: \"Service A - GET /user/%\". Service entry span: Group by the span name of the service currently being viewed in APM. For example, for a trace where Service A calls Service B and Service B calls Service C, if you're viewing Service B in APM and select this grouping, the traces will be represented by their Service B span names. If a service has multiple spans in a trace, this grouping option will use that service's first entry point. Filters In the left pane, you can filter traces by multi-span traces, specific entities, or error types. Once you select a filter, only traces associated with that specific type are displayed. This makes it much easier to view the traces you're most interested in so you can find and fix issues faster. Trace histograms The histogram charts give you a quick understanding of trace distribution for important values, such as duration. Click Show filters at the bottom of the left pane to display the histograms. When you move the histogram sliders, they change the data displayed in the scatterplot or the trace group charts. For example, you can drag the Trace duration chart slider to show only traces over 500 ms, as shown in the histogram example below. Important Some queries that produce many results may result in false positives in histograms. This could manifest as histograms showing trace results that are not in the trace list. Trace details UI page When you select a trace from the trace list, you see a map of services (if available), and a \"waterfall\" display of that trace's spans. When you select a trace from the list of traces, you see details about it. Trace map If a trace involves more than one entity, and we have information about those entities, the trace page includes a map. For more about how that, see Maps in context. Span properties The UI indicates span properties with these icons: Span property Indicator Description Service This icon represents a span that's a service's entry point. In-process This icon represents an in-process span, which is a span that takes place within a process (as opposed to a cross-process span). Examples: middleware instrumentation, user-created spans. Datastore This icon represents a span call to a datastore. External This icon represents category representing a call to an external service made via HTTP. Browser app This icon represents a browser application span. Lambda This icon represents a span from a Lambda function. Some spans will have additional indicators: Span property Indicator Description Type of connection Solid lines indicate a direct parent-child relationship; in other words, one process or function directly calling another. A dotted line indicates a non-direct relationship. For more on relationships between spans, see Trace structure. Errors A span with an error. See How to understand span errors. Anomalous This icon represents the detection of an anomalous span. Orphaned spans Some spans may be \"orphaned,\" or separated, from the trace. These spans will appear at the bottom of the trace. For more details, see Fragmented traces. Multiple app names When beside a span name, this represents an entity that has had multiple app names set. Select this to see all app names it reports to. To search trace data by alternate app names, use the appName attribute. Client/server time difference If a span's duration indicator is not completely colored in (like in this example), it means that there is a time discrepancy between the server-side duration and the client-side duration for that activity. For details on this, see Client/server time difference. For more on the trace structure and how span properties are determined, see Trace structure. Span details pane When you select a span, a pane opens up with span details. These details can be helpful for troubleshooting performance issues. Details include: Performance charts Span attributes The span's data source Anomalous span details The span's full name What a span displays is based on its span type. For example, a datastore span's name attribute will contain the datastore query. View related logs If you are using our logs in context feature together with our log management, you can see any logs that are linked to your traces: Go to the trace details page by clicking on a trace. Click See logs in the upper-right corner. For details related to an individual log message, click directly on the message. Additional UI details Here are some additional distributed tracing UI details, rules, and limits: How to understand span errors Span-level errors show you where errors originated in a process, how they bubbled up, and where they were handled. Every span that ends with an error is shown with an error in the UI and contributes to the total error count for that trace. Here are some general tips about understanding span errors: Spans with errors are highlighted red in the distributed tracing UI. You can see more information on the Error Details pane for each span. All spans that exit with errors are counted in the span error count. When multiple errors occur on the same span, only one is written to the span in this order of precedence: A noticeError The most recent span error within the scope of that span This table describes how different span errors are handled: Error type Description Spans ending in errors An error that leaves the boundary of a span results in an error on that span and on any ancestor spans that also exit with an error, until the error is caught or exits the transaction. You can see if an error is caught in an ancestor span. Notice errors Errors noticed by calls to the agent noticeError API or by the automatic agent instrumentation are attached to the currently executing span. Response code errors Response code errors are attached to the associated span, such as: Client span: External transactions prefixed with http or db. Entry span: In the case of a transaction ending in a response code error. The response code for these spans is captured as an attribute httpResponseCode and attached to that span. OpenTelemetry Errors The Error Details box of the right pane is populated by spans containing otel.status_code = ERROR and displays the content of otel.status_description. Tip OpenTelemetry span events handled by the app/service are displayed independently of span error status and are not necessarily associated with a span error status. You can view span event exceptions and non-exceptions by clicking View span events in the right pane. Anomalous spans If a span is displayed as anomalous in the UI, it means that the following are both true: The span is more than two standard deviations slower than the average of all spans with the same name from the same service over the last six hours. The span's duration is more than 10% of the trace's duration. Client span duration: time differences between client and server spans When a process calls another process, and both processes are instrumented by New Relic, the trace contains both a client-side representation of the call and a server-side representation. The client span (calling process) can have time-related differences when compared to the server span (called process). These differences could be due to: Clock skew, due to system clock time differences Differences in duration, due to things like network latency or DNS resolution delay The UI shows these time-related differences by displaying an outline of the client span in the same space as the server span. This span represents the duration of the client span. It isn't possible to determine every factor contributing to these time-related discrepancies, but here are some common span patterns and tips for understanding them: When a client span is longer than the server span, this could be due to latency in a number of areas, such as: network time, queue time, DNS resolution time, or from a load balancer that we cannot see. When a client span starts and ends before a server span begins, this could be due to clock skew, or due to the server doing asynchronous work that continues after sending the response. When a client span starts after a server span, this is most likely clock skew. Fragmented traces Fragmented traces are traces with missing spans. When a span is missing or has invalid parent span IDs, its children spans become separated from the rest of the trace, which we refer to as \"orphaned.\" Orphaned spans appear at the bottom of the trace, and they will lack connecting lines to the rest of the trace. Types of orphaned span properties indicated in the UI: No root span. Missing the root span, which is the first operation in the request. When this happens, the span with the earliest timestamp is displayed as the root. Orphaned span. A single span with a missing parent span. This could be due to the parent span having an ID that doesn't match its child span. Orphaned trace fragment. A group of connected spans where the first span in the group is an orphan span. This can happen for a number of reasons, including: Collection limits. Some high-throughput applications may exceed collection limits (for example, APM agent collection limits, or API limits). When this happens, it may result in traces having missing spans. One way to remedy this is to turn off some reporting, so that the limit is not reached. Incorrect instrumentation. If an application is instrumented incorrectly, it won't pass trace context correctly and this will result in fragmented traces. To remedy this, examine the data source that is generating orphan spans to ensure instrumentation is done correctly. To discover a span's data source, select it and examine its span details. Spans still arriving. If some parent spans haven't been collected yet, this can result in temporary gaps until the entire trace has reported. UI display limits. Orphaned spans may result if a trace exceeds the 10K span display limit. Trace details obfuscated based on account access If you don’t have access to the New Relic accounts that monitor other services, some of the span and service details will be obfuscated in the UI. Obfuscation can include: Span name concealed by asterisks Service name replaced with New Relic account ID and app ID For more information on the factors affecting your access to accounts, see Account access. Span limits and sampling See Sampling. Incomplete span names in waterfall view When viewing the span waterfall, span names may be displayed in an incomplete form that is more human-readable than the complete span name. To find the complete name, select that span and look for the Full span name. Knowing the complete name can be valuable for querying that data with NRQL. Missing spans and span/service count discrepancies A trace may sometimes have (or seem to have) missing spans or services. This can manifest as a discrepancy between the count of a trace's spans or services displayed in the trace list and the count displayed on the trace details page. Reasons for missing spans and count discrepancies include: An APM agent may have hit its 1K span collection limit. A span may be initially counted but not make it into a trace display, for reasons such as network latency or a query issue. The UI may have hit its 10K span display limit. All spans collected, including those not displayed, can be queried with NRQL.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 181.21475,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Understand and use the <em>distributed</em> <em>tracing</em> UI",
        "sections": "Understand and use the <em>distributed</em> <em>tracing</em> UI",
        "tags": "<em>Distributed</em> <em>tracing</em>",
        "body": " &gt; <em>Distributed</em> <em>tracing</em> <em>Trace</em> groups The default view of <em>distributed</em> <em>tracing</em> shows traces grouped by the same root entry span. In other words, traces are grouped by the span where <em>New</em> <em>Relic</em> began recording the request. You can slide the toggle Group similar traces to turn this on and off. With <em>trace</em>"
      },
      "id": "6072a70028ccbc265a51c13d"
    },
    {
      "image": "https://docs.newrelic.com/static/f487e8c287d614c494f56bd35fd38bb5/c1b63/arrow-step-diagram-trans.png",
      "url": "https://docs.newrelic.com/docs/distributed-tracing/enable-configure/quick-start/",
      "sections": [
        "Distributed tracing quick start"
      ],
      "published_at": "2021-09-14T05:45:31Z",
      "title": "Distributed tracing quick start",
      "updated_at": "2021-09-14T05:45:31Z",
      "type": "docs",
      "external_id": "f9f4aa287602eee82a0eb7d15775d033ada26d63",
      "document_type": "page",
      "popularity": 1,
      "body": "To set up distributed tracing, you'll complete these three general steps: Identify services: Identify and write down the endpoints, services, languages, and systems that are used to complete this request (you'll need this information in the next step). If you have an environment diagram like the following, you could use it to create a list of services handling requests: Instrument services: Instrument each service you identify so it can send your trace data. Some tools, such as APM agents, instrument services automatically, while other tools require you to insert some code in the services. Click the icon below for instrumentation steps: APM: C APM: Golang APM: Java APM: .NET APM: Node.js APM: PHP APM: Python APM: Ruby Browser monitoring Mobile monitoring AWS Lambda Functions Istio Kamon OpenTelemetry X-Ray Zipkin format: custom integration New Relic format: custom integration View traces: After you instrument the services, generate some traffic in your application, and then go to the New Relic UI to see your trace data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.82828,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Distributed</em> <em>tracing</em> quick start",
        "sections": "<em>Distributed</em> <em>tracing</em> quick start",
        "body": ". Click the icon below for instrumentation steps: APM: C APM: Golang APM: Java APM: .NET APM: Node.js APM: PHP APM: Python APM: Ruby Browser <em>monitoring</em> <em>Mobile</em> <em>monitoring</em> AWS Lambda Functions Istio Kamon OpenTelemetry X-Ray Zipkin format: custom integration <em>New</em> <em>Relic</em> format: custom integration View traces: After you instrument the services, generate some traffic in your application, and then go to the <em>New</em> <em>Relic</em> UI to see your <em>trace</em> data."
      },
      "id": "6072a60564441f2f6f9d8541"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/install-configure/android-agent-crash-reporting": [
    {
      "sections": [
        "Configure ProGuard or DexGuard for Android apps",
        "Configure ProGuard",
        "Network library support",
        "Configure DexGuard"
      ],
      "title": "Configure ProGuard or DexGuard for Android apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "8a8df969c4099f75cb214354cef311dfa2ab50e2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/configure-proguard-or-dexguard-android-apps/",
      "published_at": "2021-09-14T07:45:07Z",
      "updated_at": "2021-08-21T09:16:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to support ProGuard or DexGuard with the Android agent. Check our Android compatibility and requirements, and if you have previously installed the Android agent SDK, follow the steps before upgrading to the latest version with ProGuard or DexGuard. Configure ProGuard To add support for ProGuard: Add an exclusion to your app; for example: To support New Relic instrumentation, add keep class. To disable warnings related to unresolved problems, add dont warn. To preserve line numbers for crash reporting, add LineNumberTable. To preserve stack information for handled exceptions, add SourceFile and EnclosingMethod. Add the following to your ProGuard config file (proguard.cfg, proguard-android.txt, proguard-rules.pro, etc.): -keep class com.newrelic.** { *; } -dontwarn com.newrelic.** -keepattributes Exceptions, Signature, InnerClasses, LineNumberTable, SourceFile, EnclosingMethod Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors. Network library support New Relic instrumentation happens before ProGuard obfuscates your code. In order for these libraries to be properly instrumented, their classes must not be obfuscated by ProGuard. Here are examples of rules to be applied to preserve these classes. This is not a complete list. Different rules will be needed depending on your library or version. Library Rules Apache Http -keep class org.apache.http.** { *; } -dontwarn org.apache.http.** Copy OkHttp 2 -keep class com.squareup.okhttp.* { *; } -dontwarn com.squareup.okhttp.** -dontwarn okio.** Copy OkHttp 3 -keep class okhttp3.** { *; } -dontwarn okhttp3.** -dontwarn okio.** Copy Retrofit 2 -keep class retrofit2.** { *; } -dontwarn retrofit2.** Copy Configure DexGuard DexGuard uses the same configuration options as ProGuard, and it can read any pre-existing ProGuard configuration files. DexGuard also has its own set of additional configuration options and provides sample configurations for many common app frameworks. To add support for DexGuard: Add DexGuard to your app and set up the Gradle plugin according to the directions from DexGuard. Create a dexguard-project.txt file to hold specific DexGuard configuration options, and add: -dontnote com.newrelic.agent.android.NewRelic -dontnote com.newrelic.agent.android.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app's buildTypes configuration is similar to this: buildTypes { release { minifyEnabled true proguardFile getDefaultDexGuardFile('dexguard-release.pro') proguardFile 'proguard-rules.pro' proguardFile 'dexguard-project.txt' } ... Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 156.56036,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "sections": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": ", and add: -dontnote com.newrelic.agent.<em>android.NewRelic</em> -dontnote com.newrelic.agent.<em>android</em>.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app&#x27;s buildTypes configuration is similar to this: buildTypes { release { minifyEnabled"
      },
      "id": "604418de196a6770e7960f6c"
    },
    {
      "sections": [
        "Install Android apps with Gradle and Android Studio",
        "Install your Android app",
        "Configure with Gradle and Android Studio",
        "Project level build.gradle file:",
        "App level build.gradle file:",
        "Important",
        "Update your Android installation",
        "Android 4.x: Multidex support",
        "New Relic Gradle Plugin configuration"
      ],
      "title": "Install Android apps with Gradle and Android Studio",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "51fab3eba87ddee949cd4729de8b5f64534de9c7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-android-apps-gradle-android-studio/",
      "published_at": "2021-09-14T08:10:37Z",
      "updated_at": "2021-07-27T17:09:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Gradle or Android Studio, follow these instructions to install New Relic's mobile monitoring for the first time. If you have previously installed the Android agent SDK for mobile monitoring, follow the steps before upgrading to the latest version with Gradle and Android Studio. Install your Android app As part of the installation process for mobile monitoring, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. Go to one.newrelic.com > Mobile. If applicable: From the Mobile apps index, select Add a new app. From the Get started page, select Android as the platform for mobile monitoring. Type a meaningful name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring with Gradle and Android Studio. OR: To complete the configuration process for a new mobile app later: Go to one.newrelic.com > Mobile, then select See instructions next to your mobile app name. To upgrade an existing Android installation: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Configure with Gradle and Android Studio These procedures to configure your Android app with Gradle and Android Studio also appear on the Get started page in New Relic. Merge New Relic's mobile monitoring code in the Gradle & Android Studio tab to your build.gradle file. Project level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. buildscript { repositories { mavenCentral() } dependencies { classpath \"com.newrelic.agent.android:agent-gradle-plugin:AGENT_VERSION\" } } Copy App level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. repositories { mavenCentral() } apply plugin: 'android' apply plugin: 'newrelic' dependencies { compile 'com.newrelic.agent.android:android-agent:AGENT_VERSION' } Copy ProGuard or DexGuard: In your project’s root directory (projectname/app), add a newrelic.properties file with the following line: com.newrelic.application_token=GENERATED_TOKEN Copy Follow the additional, required configuration steps for using ProGuard or DexGuard with New Relic. Set app permissions: Ensure that your Android app requests INTERNET and ACCESS_NETWORK_STATE permissions by adding these lines to your AndroidManifest.xml file: <uses-permission android:name=\"android.permission.INTERNET\" /> <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /> Copy To start New Relic's mobile monitoring agent: In your Default Activity (as defined in your Manifest), import the NewRelic class: import com.newrelic.agent.android.NewRelic; Copy Important We do not support starting the mobile monitoring agent in other classes, as that can cause unexpected or unstable behavior. To initialize mobile monitoring: In the onCreate() method, add this call: NewRelic.withApplicationToken(\"GENERATED_TOKEN\").start(this.getApplication()); Copy Optional: Change the logging level. To build and run your application: Clean your project, then run your app in an emulator or device to generate traffic. Wait a few minutes, then view data for your Android app from the Overview page: Go to one.newrelic.com > Mobile > (select an app). If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI, follow the troubleshooting procedures. Update your Android installation To keep your Android agent up to date, follow the procedures to upgrade the Android agent SDK for New Relic. To install the latest Android version for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Android 4.x: Multidex support New Relic's mobile monitoring for Android versions prior to Android 5.0 (API level 21) use the Dalvik runtime to execute app code. By default, Dalvik limits apps to a single classes.dex bytecode file per APK. In order to get around this limitation, you must enable multidex support. Then you can use the multidex support library, which becomes part of the primary DEX file of your app and then manages access to the additional DEX files and the code they contain. When building each DEX file for a multidex app, the build tools perform complex decision making to determine which classes are needed in the primary DEX file so that your app can start successfully. If any class required during startup is not provided in the primary DEX file, then your app crashes with the error java.lang.NoClassDefFoundError. If you see the java.lang.NoClassDefFoundError error, then you must manually specify these additional classes as required in the primary DEX file: Create a proguard.multidex.config file within the /app folder of your project. Update mypackage to reflect your package name. #################### # keep class names # #################### #Keep New Relic in the main dex -keep class com.newrelic.** { *; } -keep class com.mypackage.activities.** { *; } Copy Merge the following code into the app-level build.gradle file: android { defaultConfig{ … multiDexKeepProguard file(\"proguard.multidex.config\") } } Copy For more information, see the Android Developers documentation on declaring classes required in the primary DEX file. New Relic Gradle Plugin configuration For details on how to configure the behavior of the mobile monitoring agent plugin during Gradle builds, see the New Relic Gradle plugin extension guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.40434,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "sections": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "If you use Gradle or <em>Android</em> Studio, follow these instructions to <em>install</em> <em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for the first time. If you have previously installed the <em>Android</em> agent SDK for <em>mobile</em> <em>monitoring</em>, follow the steps before upgrading to the latest version with Gradle and <em>Android</em> Studio. <em>Install</em>"
      },
      "id": "603ea70128ccbc59c2eba74e"
    },
    {
      "sections": [
        "Upgrade the Android agent",
        "Upgrade from Android SDK versions 2 or 3",
        "Upgrade Android SDK version 1"
      ],
      "title": "Upgrade the Android agent",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "eca0e4db3d71cbe83bbb40fdc2e7d026d5e5ed4b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/upgrade-new-relic-mobiles-android-sdk/",
      "published_at": "2021-09-14T07:47:59Z",
      "updated_at": "2021-07-09T15:02:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To ensure you have the most current version of the Android agent, see the Android agent release notes. Instructions to upgrade your Android app will vary, based on which version of the Android agent SDK you are currently using. Upgrade from Android SDK versions 2 or 3 If you have previously installed version 2 or 3 of the Android SDK: Go to one.newrelic.com > Mobile > (select an app) > Settings > Upgrade. Upgrade Android SDK version 1 If you have previously installed version 1 of the Android SDK, follow these steps before upgrading to version 2 or higher. Step Notes Open your AndroidManifest.xml file, and remove the NewRelicApplication class. When you first ran nrandroid-setup, the NewRelicApplication class was added to your AndroidManifest.xml file. This has been removed from the New Relic SDK and is no longer necessary. If you had an existing Application subclass and modified it to inherit from NewRelicApplication, update your subclass to inherit from Application instead. Stop using nrandroid-ant. Mobile monitoring no longer requires the custom Ant wrapper script for Android applications. Once you upgrade, simply use your standard build tools. If you modified an existing Maven configuration to invoke the mobile build steps, remove those modifications, and use the revised build instructions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 130.82756,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upgrade the <em>Android</em> agent",
        "sections": "Upgrade the <em>Android</em> agent",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " it to inherit from <em>NewRelic</em>Application, update your subclass to inherit from Application instead. Stop using nrandroid-ant. <em>Mobile</em> <em>monitoring</em> no longer requires the custom Ant wrapper script for <em>Android</em> applications. Once you upgrade, simply use your standard build tools. If you modified an existing Maven configuration to invoke the <em>mobile</em> build steps, remove those modifications, and use the revised build instructions."
      },
      "id": "603eae0664441f985b4e8843"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/install-configure/configure-new-relic-gradle-plugin": [
    {
      "sections": [
        "Configure ProGuard or DexGuard for Android apps",
        "Configure ProGuard",
        "Network library support",
        "Configure DexGuard"
      ],
      "title": "Configure ProGuard or DexGuard for Android apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "8a8df969c4099f75cb214354cef311dfa2ab50e2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/configure-proguard-or-dexguard-android-apps/",
      "published_at": "2021-09-14T07:45:07Z",
      "updated_at": "2021-08-21T09:16:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to support ProGuard or DexGuard with the Android agent. Check our Android compatibility and requirements, and if you have previously installed the Android agent SDK, follow the steps before upgrading to the latest version with ProGuard or DexGuard. Configure ProGuard To add support for ProGuard: Add an exclusion to your app; for example: To support New Relic instrumentation, add keep class. To disable warnings related to unresolved problems, add dont warn. To preserve line numbers for crash reporting, add LineNumberTable. To preserve stack information for handled exceptions, add SourceFile and EnclosingMethod. Add the following to your ProGuard config file (proguard.cfg, proguard-android.txt, proguard-rules.pro, etc.): -keep class com.newrelic.** { *; } -dontwarn com.newrelic.** -keepattributes Exceptions, Signature, InnerClasses, LineNumberTable, SourceFile, EnclosingMethod Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors. Network library support New Relic instrumentation happens before ProGuard obfuscates your code. In order for these libraries to be properly instrumented, their classes must not be obfuscated by ProGuard. Here are examples of rules to be applied to preserve these classes. This is not a complete list. Different rules will be needed depending on your library or version. Library Rules Apache Http -keep class org.apache.http.** { *; } -dontwarn org.apache.http.** Copy OkHttp 2 -keep class com.squareup.okhttp.* { *; } -dontwarn com.squareup.okhttp.** -dontwarn okio.** Copy OkHttp 3 -keep class okhttp3.** { *; } -dontwarn okhttp3.** -dontwarn okio.** Copy Retrofit 2 -keep class retrofit2.** { *; } -dontwarn retrofit2.** Copy Configure DexGuard DexGuard uses the same configuration options as ProGuard, and it can read any pre-existing ProGuard configuration files. DexGuard also has its own set of additional configuration options and provides sample configurations for many common app frameworks. To add support for DexGuard: Add DexGuard to your app and set up the Gradle plugin according to the directions from DexGuard. Create a dexguard-project.txt file to hold specific DexGuard configuration options, and add: -dontnote com.newrelic.agent.android.NewRelic -dontnote com.newrelic.agent.android.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app's buildTypes configuration is similar to this: buildTypes { release { minifyEnabled true proguardFile getDefaultDexGuardFile('dexguard-release.pro') proguardFile 'proguard-rules.pro' proguardFile 'dexguard-project.txt' } ... Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 156.56036,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "sections": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": ", and add: -dontnote com.newrelic.agent.<em>android.NewRelic</em> -dontnote com.newrelic.agent.<em>android</em>.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app&#x27;s buildTypes configuration is similar to this: buildTypes { release { minifyEnabled"
      },
      "id": "604418de196a6770e7960f6c"
    },
    {
      "sections": [
        "Install Android apps with Gradle and Android Studio",
        "Install your Android app",
        "Configure with Gradle and Android Studio",
        "Project level build.gradle file:",
        "App level build.gradle file:",
        "Important",
        "Update your Android installation",
        "Android 4.x: Multidex support",
        "New Relic Gradle Plugin configuration"
      ],
      "title": "Install Android apps with Gradle and Android Studio",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "51fab3eba87ddee949cd4729de8b5f64534de9c7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-android-apps-gradle-android-studio/",
      "published_at": "2021-09-14T08:10:37Z",
      "updated_at": "2021-07-27T17:09:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Gradle or Android Studio, follow these instructions to install New Relic's mobile monitoring for the first time. If you have previously installed the Android agent SDK for mobile monitoring, follow the steps before upgrading to the latest version with Gradle and Android Studio. Install your Android app As part of the installation process for mobile monitoring, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. Go to one.newrelic.com > Mobile. If applicable: From the Mobile apps index, select Add a new app. From the Get started page, select Android as the platform for mobile monitoring. Type a meaningful name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring with Gradle and Android Studio. OR: To complete the configuration process for a new mobile app later: Go to one.newrelic.com > Mobile, then select See instructions next to your mobile app name. To upgrade an existing Android installation: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Configure with Gradle and Android Studio These procedures to configure your Android app with Gradle and Android Studio also appear on the Get started page in New Relic. Merge New Relic's mobile monitoring code in the Gradle & Android Studio tab to your build.gradle file. Project level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. buildscript { repositories { mavenCentral() } dependencies { classpath \"com.newrelic.agent.android:agent-gradle-plugin:AGENT_VERSION\" } } Copy App level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. repositories { mavenCentral() } apply plugin: 'android' apply plugin: 'newrelic' dependencies { compile 'com.newrelic.agent.android:android-agent:AGENT_VERSION' } Copy ProGuard or DexGuard: In your project’s root directory (projectname/app), add a newrelic.properties file with the following line: com.newrelic.application_token=GENERATED_TOKEN Copy Follow the additional, required configuration steps for using ProGuard or DexGuard with New Relic. Set app permissions: Ensure that your Android app requests INTERNET and ACCESS_NETWORK_STATE permissions by adding these lines to your AndroidManifest.xml file: <uses-permission android:name=\"android.permission.INTERNET\" /> <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /> Copy To start New Relic's mobile monitoring agent: In your Default Activity (as defined in your Manifest), import the NewRelic class: import com.newrelic.agent.android.NewRelic; Copy Important We do not support starting the mobile monitoring agent in other classes, as that can cause unexpected or unstable behavior. To initialize mobile monitoring: In the onCreate() method, add this call: NewRelic.withApplicationToken(\"GENERATED_TOKEN\").start(this.getApplication()); Copy Optional: Change the logging level. To build and run your application: Clean your project, then run your app in an emulator or device to generate traffic. Wait a few minutes, then view data for your Android app from the Overview page: Go to one.newrelic.com > Mobile > (select an app). If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI, follow the troubleshooting procedures. Update your Android installation To keep your Android agent up to date, follow the procedures to upgrade the Android agent SDK for New Relic. To install the latest Android version for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Android 4.x: Multidex support New Relic's mobile monitoring for Android versions prior to Android 5.0 (API level 21) use the Dalvik runtime to execute app code. By default, Dalvik limits apps to a single classes.dex bytecode file per APK. In order to get around this limitation, you must enable multidex support. Then you can use the multidex support library, which becomes part of the primary DEX file of your app and then manages access to the additional DEX files and the code they contain. When building each DEX file for a multidex app, the build tools perform complex decision making to determine which classes are needed in the primary DEX file so that your app can start successfully. If any class required during startup is not provided in the primary DEX file, then your app crashes with the error java.lang.NoClassDefFoundError. If you see the java.lang.NoClassDefFoundError error, then you must manually specify these additional classes as required in the primary DEX file: Create a proguard.multidex.config file within the /app folder of your project. Update mypackage to reflect your package name. #################### # keep class names # #################### #Keep New Relic in the main dex -keep class com.newrelic.** { *; } -keep class com.mypackage.activities.** { *; } Copy Merge the following code into the app-level build.gradle file: android { defaultConfig{ … multiDexKeepProguard file(\"proguard.multidex.config\") } } Copy For more information, see the Android Developers documentation on declaring classes required in the primary DEX file. New Relic Gradle Plugin configuration For details on how to configure the behavior of the mobile monitoring agent plugin during Gradle builds, see the New Relic Gradle plugin extension guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.40434,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "sections": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "If you use Gradle or <em>Android</em> Studio, follow these instructions to <em>install</em> <em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for the first time. If you have previously installed the <em>Android</em> agent SDK for <em>mobile</em> <em>monitoring</em>, follow the steps before upgrading to the latest version with Gradle and <em>Android</em> Studio. <em>Install</em>"
      },
      "id": "603ea70128ccbc59c2eba74e"
    },
    {
      "sections": [
        "Upgrade the Android agent",
        "Upgrade from Android SDK versions 2 or 3",
        "Upgrade Android SDK version 1"
      ],
      "title": "Upgrade the Android agent",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "eca0e4db3d71cbe83bbb40fdc2e7d026d5e5ed4b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/upgrade-new-relic-mobiles-android-sdk/",
      "published_at": "2021-09-14T07:47:59Z",
      "updated_at": "2021-07-09T15:02:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To ensure you have the most current version of the Android agent, see the Android agent release notes. Instructions to upgrade your Android app will vary, based on which version of the Android agent SDK you are currently using. Upgrade from Android SDK versions 2 or 3 If you have previously installed version 2 or 3 of the Android SDK: Go to one.newrelic.com > Mobile > (select an app) > Settings > Upgrade. Upgrade Android SDK version 1 If you have previously installed version 1 of the Android SDK, follow these steps before upgrading to version 2 or higher. Step Notes Open your AndroidManifest.xml file, and remove the NewRelicApplication class. When you first ran nrandroid-setup, the NewRelicApplication class was added to your AndroidManifest.xml file. This has been removed from the New Relic SDK and is no longer necessary. If you had an existing Application subclass and modified it to inherit from NewRelicApplication, update your subclass to inherit from Application instead. Stop using nrandroid-ant. Mobile monitoring no longer requires the custom Ant wrapper script for Android applications. Once you upgrade, simply use your standard build tools. If you modified an existing Maven configuration to invoke the mobile build steps, remove those modifications, and use the revised build instructions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 130.82756,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upgrade the <em>Android</em> agent",
        "sections": "Upgrade the <em>Android</em> agent",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " it to inherit from <em>NewRelic</em>Application, update your subclass to inherit from Application instead. Stop using nrandroid-ant. <em>Mobile</em> <em>monitoring</em> no longer requires the custom Ant wrapper script for <em>Android</em> applications. Once you upgrade, simply use your standard build tools. If you modified an existing Maven configuration to invoke the <em>mobile</em> build steps, remove those modifications, and use the revised build instructions."
      },
      "id": "603eae0664441f985b4e8843"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/install-configure/configure-proguard-or-dexguard-android-apps": [
    {
      "sections": [
        "Install Android apps with Gradle and Android Studio",
        "Install your Android app",
        "Configure with Gradle and Android Studio",
        "Project level build.gradle file:",
        "App level build.gradle file:",
        "Important",
        "Update your Android installation",
        "Android 4.x: Multidex support",
        "New Relic Gradle Plugin configuration"
      ],
      "title": "Install Android apps with Gradle and Android Studio",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "51fab3eba87ddee949cd4729de8b5f64534de9c7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-android-apps-gradle-android-studio/",
      "published_at": "2021-09-14T08:10:37Z",
      "updated_at": "2021-07-27T17:09:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Gradle or Android Studio, follow these instructions to install New Relic's mobile monitoring for the first time. If you have previously installed the Android agent SDK for mobile monitoring, follow the steps before upgrading to the latest version with Gradle and Android Studio. Install your Android app As part of the installation process for mobile monitoring, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. Go to one.newrelic.com > Mobile. If applicable: From the Mobile apps index, select Add a new app. From the Get started page, select Android as the platform for mobile monitoring. Type a meaningful name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring with Gradle and Android Studio. OR: To complete the configuration process for a new mobile app later: Go to one.newrelic.com > Mobile, then select See instructions next to your mobile app name. To upgrade an existing Android installation: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Configure with Gradle and Android Studio These procedures to configure your Android app with Gradle and Android Studio also appear on the Get started page in New Relic. Merge New Relic's mobile monitoring code in the Gradle & Android Studio tab to your build.gradle file. Project level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. buildscript { repositories { mavenCentral() } dependencies { classpath \"com.newrelic.agent.android:agent-gradle-plugin:AGENT_VERSION\" } } Copy App level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. repositories { mavenCentral() } apply plugin: 'android' apply plugin: 'newrelic' dependencies { compile 'com.newrelic.agent.android:android-agent:AGENT_VERSION' } Copy ProGuard or DexGuard: In your project’s root directory (projectname/app), add a newrelic.properties file with the following line: com.newrelic.application_token=GENERATED_TOKEN Copy Follow the additional, required configuration steps for using ProGuard or DexGuard with New Relic. Set app permissions: Ensure that your Android app requests INTERNET and ACCESS_NETWORK_STATE permissions by adding these lines to your AndroidManifest.xml file: <uses-permission android:name=\"android.permission.INTERNET\" /> <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /> Copy To start New Relic's mobile monitoring agent: In your Default Activity (as defined in your Manifest), import the NewRelic class: import com.newrelic.agent.android.NewRelic; Copy Important We do not support starting the mobile monitoring agent in other classes, as that can cause unexpected or unstable behavior. To initialize mobile monitoring: In the onCreate() method, add this call: NewRelic.withApplicationToken(\"GENERATED_TOKEN\").start(this.getApplication()); Copy Optional: Change the logging level. To build and run your application: Clean your project, then run your app in an emulator or device to generate traffic. Wait a few minutes, then view data for your Android app from the Overview page: Go to one.newrelic.com > Mobile > (select an app). If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI, follow the troubleshooting procedures. Update your Android installation To keep your Android agent up to date, follow the procedures to upgrade the Android agent SDK for New Relic. To install the latest Android version for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Android 4.x: Multidex support New Relic's mobile monitoring for Android versions prior to Android 5.0 (API level 21) use the Dalvik runtime to execute app code. By default, Dalvik limits apps to a single classes.dex bytecode file per APK. In order to get around this limitation, you must enable multidex support. Then you can use the multidex support library, which becomes part of the primary DEX file of your app and then manages access to the additional DEX files and the code they contain. When building each DEX file for a multidex app, the build tools perform complex decision making to determine which classes are needed in the primary DEX file so that your app can start successfully. If any class required during startup is not provided in the primary DEX file, then your app crashes with the error java.lang.NoClassDefFoundError. If you see the java.lang.NoClassDefFoundError error, then you must manually specify these additional classes as required in the primary DEX file: Create a proguard.multidex.config file within the /app folder of your project. Update mypackage to reflect your package name. #################### # keep class names # #################### #Keep New Relic in the main dex -keep class com.newrelic.** { *; } -keep class com.mypackage.activities.** { *; } Copy Merge the following code into the app-level build.gradle file: android { defaultConfig{ … multiDexKeepProguard file(\"proguard.multidex.config\") } } Copy For more information, see the Android Developers documentation on declaring classes required in the primary DEX file. New Relic Gradle Plugin configuration For details on how to configure the behavior of the mobile monitoring agent plugin during Gradle builds, see the New Relic Gradle plugin extension guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.40433,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "sections": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "If you use Gradle or <em>Android</em> Studio, follow these instructions to <em>install</em> <em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for the first time. If you have previously installed the <em>Android</em> agent SDK for <em>mobile</em> <em>monitoring</em>, follow the steps before upgrading to the latest version with Gradle and <em>Android</em> Studio. <em>Install</em>"
      },
      "id": "603ea70128ccbc59c2eba74e"
    },
    {
      "sections": [
        "Upgrade the Android agent",
        "Upgrade from Android SDK versions 2 or 3",
        "Upgrade Android SDK version 1"
      ],
      "title": "Upgrade the Android agent",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "eca0e4db3d71cbe83bbb40fdc2e7d026d5e5ed4b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/upgrade-new-relic-mobiles-android-sdk/",
      "published_at": "2021-09-14T07:47:59Z",
      "updated_at": "2021-07-09T15:02:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To ensure you have the most current version of the Android agent, see the Android agent release notes. Instructions to upgrade your Android app will vary, based on which version of the Android agent SDK you are currently using. Upgrade from Android SDK versions 2 or 3 If you have previously installed version 2 or 3 of the Android SDK: Go to one.newrelic.com > Mobile > (select an app) > Settings > Upgrade. Upgrade Android SDK version 1 If you have previously installed version 1 of the Android SDK, follow these steps before upgrading to version 2 or higher. Step Notes Open your AndroidManifest.xml file, and remove the NewRelicApplication class. When you first ran nrandroid-setup, the NewRelicApplication class was added to your AndroidManifest.xml file. This has been removed from the New Relic SDK and is no longer necessary. If you had an existing Application subclass and modified it to inherit from NewRelicApplication, update your subclass to inherit from Application instead. Stop using nrandroid-ant. Mobile monitoring no longer requires the custom Ant wrapper script for Android applications. Once you upgrade, simply use your standard build tools. If you modified an existing Maven configuration to invoke the mobile build steps, remove those modifications, and use the revised build instructions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 130.82756,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upgrade the <em>Android</em> agent",
        "sections": "Upgrade the <em>Android</em> agent",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " it to inherit from <em>NewRelic</em>Application, update your subclass to inherit from Application instead. Stop using nrandroid-ant. <em>Mobile</em> <em>monitoring</em> no longer requires the custom Ant wrapper script for <em>Android</em> applications. Once you upgrade, simply use your standard build tools. If you modified an existing Maven configuration to invoke the <em>mobile</em> build steps, remove those modifications, and use the revised build instructions."
      },
      "id": "603eae0664441f985b4e8843"
    },
    {
      "sections": [
        "Install the New Relic plugin for Android Instant Apps",
        "Terminology",
        "Install the plugin",
        "Minimal build.gradle example",
        "Instrumentation",
        "ProGuard and Dexguard support",
        "Important",
        "Troubleshoot auto-instrumentation"
      ],
      "title": "Install the New Relic plugin for Android Instant Apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "a9b40dd5eccb3d96a0cdc246eafe66b92fdeab6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-new-relic-plugin-android-instant-apps/",
      "published_at": "2021-09-14T08:11:53Z",
      "updated_at": "2021-07-09T15:02:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Android Instant Apps allow users to quickly use your applications without installation. With the Android agent version 5.17.0 and higher, you can use New Relic to detect and instrument all feature modules for an instant app. Use this documentation along with the standard New Relic procedures to install Android apps with Gradle and Android Studio. After following the standard installation procedures, follow these additional steps for Android instant apps. Terminology This procedure uses the following terms that are specific to the Android Instant Apps plugin: Module: Any packaged class and/or resource collection APK: A module that packages the apps resources and DEX’ed classes Feature module: A slimmed down module that contains only a subset of the total APK Install the plugin To install the New Relic plugin for Android Instant Apps: First follow the steps in the Install Android apps with Gradle and Android Studio documentation. Apply the agent plugin in every project Gradle build file. List the Android agent as a dependency. Start the agent from each Activity class in the feature that could be side-loaded through a Digital Asset Link intent, (for example, mobile.example.com/signin). Minimal build.gradle example apply plugin: ‘com.android.[application|library|feature|instantapp]' apply plugin: ‘newrelic’ dependencies { implementation \"com.newrelic.agent.android:android-agent:${project.agentVersion}\" } Copy Review the considerations for instrumentation. Instrumentation When instrumenting an instant app, be aware of the following considerations with APKs: Instant apps and APKs Comments Instrumentation Instrumentation of instant apps behaves the same as instrumentation with a normal APK. The agent will detect when an APK is an instant app. For feature APKs, the agent will inject a unique build ID that instant apps will use when reporting crashes. The side-loaded (main) activity of every feature must call NewRelic.start() when the activity is created (as per normal instructions). ProGuard and Dexguard support for feature and application APKs Place the newrelic.properties file in the root (main) directory of the project. ProGuard and Dexguard support The Android Studio Gradle plugin will obfuscate any build configuration where minifyEnabled is set to true. In these conditions, the New Relic agent will forward the ProGuard map generated for the build to crash collectors, tagged with a unique build ID generated by the agent. Obfuscation is best configured in the application or instant app project that includes other modules as dependencies. Modules may configure ProGuard as needed. Important When using ProGuard or DexGuard with Android apps, follow the procedures to complete the additional, required configuration steps. For more information, see the ProGuard and DexGuard configuration documentation. Troubleshoot auto-instrumentation If you are not whether the agent is auto-instrumenting an instant app project, try running these steps: Build app with debug (-d, --debug) option, and capture the build log. Search the log for evidence of instant apps by looking for either of these terms: This appears to be an Instant App Copy BuildId[1a2b34c5-def6-7890-g123-h4567890a] Copy The agent will add an attribute named 'instantApp' to the app's Insights session attributes if the app appears to be an instant app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 130.82756,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "sections": "<em>Install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " and&#x2F;or resource collection APK: A module that packages the apps resources and DEX’ed classes Feature module: A slimmed down module that contains only a subset of the total APK <em>Install</em> the plugin To <em>install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps: First follow the steps in the <em>Install</em> <em>Android</em> apps"
      },
      "id": "603e87a764441fa6934e885e"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-android-apps-gradle-android-studio": [
    {
      "sections": [
        "Configure ProGuard or DexGuard for Android apps",
        "Configure ProGuard",
        "Network library support",
        "Configure DexGuard"
      ],
      "title": "Configure ProGuard or DexGuard for Android apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "8a8df969c4099f75cb214354cef311dfa2ab50e2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/configure-proguard-or-dexguard-android-apps/",
      "published_at": "2021-09-14T07:45:07Z",
      "updated_at": "2021-08-21T09:16:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to support ProGuard or DexGuard with the Android agent. Check our Android compatibility and requirements, and if you have previously installed the Android agent SDK, follow the steps before upgrading to the latest version with ProGuard or DexGuard. Configure ProGuard To add support for ProGuard: Add an exclusion to your app; for example: To support New Relic instrumentation, add keep class. To disable warnings related to unresolved problems, add dont warn. To preserve line numbers for crash reporting, add LineNumberTable. To preserve stack information for handled exceptions, add SourceFile and EnclosingMethod. Add the following to your ProGuard config file (proguard.cfg, proguard-android.txt, proguard-rules.pro, etc.): -keep class com.newrelic.** { *; } -dontwarn com.newrelic.** -keepattributes Exceptions, Signature, InnerClasses, LineNumberTable, SourceFile, EnclosingMethod Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors. Network library support New Relic instrumentation happens before ProGuard obfuscates your code. In order for these libraries to be properly instrumented, their classes must not be obfuscated by ProGuard. Here are examples of rules to be applied to preserve these classes. This is not a complete list. Different rules will be needed depending on your library or version. Library Rules Apache Http -keep class org.apache.http.** { *; } -dontwarn org.apache.http.** Copy OkHttp 2 -keep class com.squareup.okhttp.* { *; } -dontwarn com.squareup.okhttp.** -dontwarn okio.** Copy OkHttp 3 -keep class okhttp3.** { *; } -dontwarn okhttp3.** -dontwarn okio.** Copy Retrofit 2 -keep class retrofit2.** { *; } -dontwarn retrofit2.** Copy Configure DexGuard DexGuard uses the same configuration options as ProGuard, and it can read any pre-existing ProGuard configuration files. DexGuard also has its own set of additional configuration options and provides sample configurations for many common app frameworks. To add support for DexGuard: Add DexGuard to your app and set up the Gradle plugin according to the directions from DexGuard. Create a dexguard-project.txt file to hold specific DexGuard configuration options, and add: -dontnote com.newrelic.agent.android.NewRelic -dontnote com.newrelic.agent.android.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app's buildTypes configuration is similar to this: buildTypes { release { minifyEnabled true proguardFile getDefaultDexGuardFile('dexguard-release.pro') proguardFile 'proguard-rules.pro' proguardFile 'dexguard-project.txt' } ... Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 156.56036,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "sections": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": ", and add: -dontnote com.newrelic.agent.<em>android.NewRelic</em> -dontnote com.newrelic.agent.<em>android</em>.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app&#x27;s buildTypes configuration is similar to this: buildTypes { release { minifyEnabled"
      },
      "id": "604418de196a6770e7960f6c"
    },
    {
      "sections": [
        "Upgrade the Android agent",
        "Upgrade from Android SDK versions 2 or 3",
        "Upgrade Android SDK version 1"
      ],
      "title": "Upgrade the Android agent",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "eca0e4db3d71cbe83bbb40fdc2e7d026d5e5ed4b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/upgrade-new-relic-mobiles-android-sdk/",
      "published_at": "2021-09-14T07:47:59Z",
      "updated_at": "2021-07-09T15:02:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To ensure you have the most current version of the Android agent, see the Android agent release notes. Instructions to upgrade your Android app will vary, based on which version of the Android agent SDK you are currently using. Upgrade from Android SDK versions 2 or 3 If you have previously installed version 2 or 3 of the Android SDK: Go to one.newrelic.com > Mobile > (select an app) > Settings > Upgrade. Upgrade Android SDK version 1 If you have previously installed version 1 of the Android SDK, follow these steps before upgrading to version 2 or higher. Step Notes Open your AndroidManifest.xml file, and remove the NewRelicApplication class. When you first ran nrandroid-setup, the NewRelicApplication class was added to your AndroidManifest.xml file. This has been removed from the New Relic SDK and is no longer necessary. If you had an existing Application subclass and modified it to inherit from NewRelicApplication, update your subclass to inherit from Application instead. Stop using nrandroid-ant. Mobile monitoring no longer requires the custom Ant wrapper script for Android applications. Once you upgrade, simply use your standard build tools. If you modified an existing Maven configuration to invoke the mobile build steps, remove those modifications, and use the revised build instructions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 130.82756,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upgrade the <em>Android</em> agent",
        "sections": "Upgrade the <em>Android</em> agent",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " it to inherit from <em>NewRelic</em>Application, update your subclass to inherit from Application instead. Stop using nrandroid-ant. <em>Mobile</em> <em>monitoring</em> no longer requires the custom Ant wrapper script for <em>Android</em> applications. Once you upgrade, simply use your standard build tools. If you modified an existing Maven configuration to invoke the <em>mobile</em> build steps, remove those modifications, and use the revised build instructions."
      },
      "id": "603eae0664441f985b4e8843"
    },
    {
      "sections": [
        "Install the New Relic plugin for Android Instant Apps",
        "Terminology",
        "Install the plugin",
        "Minimal build.gradle example",
        "Instrumentation",
        "ProGuard and Dexguard support",
        "Important",
        "Troubleshoot auto-instrumentation"
      ],
      "title": "Install the New Relic plugin for Android Instant Apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "a9b40dd5eccb3d96a0cdc246eafe66b92fdeab6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-new-relic-plugin-android-instant-apps/",
      "published_at": "2021-09-14T08:11:53Z",
      "updated_at": "2021-07-09T15:02:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Android Instant Apps allow users to quickly use your applications without installation. With the Android agent version 5.17.0 and higher, you can use New Relic to detect and instrument all feature modules for an instant app. Use this documentation along with the standard New Relic procedures to install Android apps with Gradle and Android Studio. After following the standard installation procedures, follow these additional steps for Android instant apps. Terminology This procedure uses the following terms that are specific to the Android Instant Apps plugin: Module: Any packaged class and/or resource collection APK: A module that packages the apps resources and DEX’ed classes Feature module: A slimmed down module that contains only a subset of the total APK Install the plugin To install the New Relic plugin for Android Instant Apps: First follow the steps in the Install Android apps with Gradle and Android Studio documentation. Apply the agent plugin in every project Gradle build file. List the Android agent as a dependency. Start the agent from each Activity class in the feature that could be side-loaded through a Digital Asset Link intent, (for example, mobile.example.com/signin). Minimal build.gradle example apply plugin: ‘com.android.[application|library|feature|instantapp]' apply plugin: ‘newrelic’ dependencies { implementation \"com.newrelic.agent.android:android-agent:${project.agentVersion}\" } Copy Review the considerations for instrumentation. Instrumentation When instrumenting an instant app, be aware of the following considerations with APKs: Instant apps and APKs Comments Instrumentation Instrumentation of instant apps behaves the same as instrumentation with a normal APK. The agent will detect when an APK is an instant app. For feature APKs, the agent will inject a unique build ID that instant apps will use when reporting crashes. The side-loaded (main) activity of every feature must call NewRelic.start() when the activity is created (as per normal instructions). ProGuard and Dexguard support for feature and application APKs Place the newrelic.properties file in the root (main) directory of the project. ProGuard and Dexguard support The Android Studio Gradle plugin will obfuscate any build configuration where minifyEnabled is set to true. In these conditions, the New Relic agent will forward the ProGuard map generated for the build to crash collectors, tagged with a unique build ID generated by the agent. Obfuscation is best configured in the application or instant app project that includes other modules as dependencies. Modules may configure ProGuard as needed. Important When using ProGuard or DexGuard with Android apps, follow the procedures to complete the additional, required configuration steps. For more information, see the ProGuard and DexGuard configuration documentation. Troubleshoot auto-instrumentation If you are not whether the agent is auto-instrumenting an instant app project, try running these steps: Build app with debug (-d, --debug) option, and capture the build log. Search the log for evidence of instant apps by looking for either of these terms: This appears to be an Instant App Copy BuildId[1a2b34c5-def6-7890-g123-h4567890a] Copy The agent will add an attribute named 'instantApp' to the app's Insights session attributes if the app appears to be an instant app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 130.82756,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "sections": "<em>Install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " and&#x2F;or resource collection APK: A module that packages the apps resources and DEX’ed classes Feature module: A slimmed down module that contains only a subset of the total APK <em>Install</em> the plugin To <em>install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps: First follow the steps in the <em>Install</em> <em>Android</em> apps"
      },
      "id": "603e87a764441fa6934e885e"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-new-relic-plugin-android-instant-apps": [
    {
      "sections": [
        "Configure ProGuard or DexGuard for Android apps",
        "Configure ProGuard",
        "Network library support",
        "Configure DexGuard"
      ],
      "title": "Configure ProGuard or DexGuard for Android apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "8a8df969c4099f75cb214354cef311dfa2ab50e2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/configure-proguard-or-dexguard-android-apps/",
      "published_at": "2021-09-14T07:45:07Z",
      "updated_at": "2021-08-21T09:16:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to support ProGuard or DexGuard with the Android agent. Check our Android compatibility and requirements, and if you have previously installed the Android agent SDK, follow the steps before upgrading to the latest version with ProGuard or DexGuard. Configure ProGuard To add support for ProGuard: Add an exclusion to your app; for example: To support New Relic instrumentation, add keep class. To disable warnings related to unresolved problems, add dont warn. To preserve line numbers for crash reporting, add LineNumberTable. To preserve stack information for handled exceptions, add SourceFile and EnclosingMethod. Add the following to your ProGuard config file (proguard.cfg, proguard-android.txt, proguard-rules.pro, etc.): -keep class com.newrelic.** { *; } -dontwarn com.newrelic.** -keepattributes Exceptions, Signature, InnerClasses, LineNumberTable, SourceFile, EnclosingMethod Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors. Network library support New Relic instrumentation happens before ProGuard obfuscates your code. In order for these libraries to be properly instrumented, their classes must not be obfuscated by ProGuard. Here are examples of rules to be applied to preserve these classes. This is not a complete list. Different rules will be needed depending on your library or version. Library Rules Apache Http -keep class org.apache.http.** { *; } -dontwarn org.apache.http.** Copy OkHttp 2 -keep class com.squareup.okhttp.* { *; } -dontwarn com.squareup.okhttp.** -dontwarn okio.** Copy OkHttp 3 -keep class okhttp3.** { *; } -dontwarn okhttp3.** -dontwarn okio.** Copy Retrofit 2 -keep class retrofit2.** { *; } -dontwarn retrofit2.** Copy Configure DexGuard DexGuard uses the same configuration options as ProGuard, and it can read any pre-existing ProGuard configuration files. DexGuard also has its own set of additional configuration options and provides sample configurations for many common app frameworks. To add support for DexGuard: Add DexGuard to your app and set up the Gradle plugin according to the directions from DexGuard. Create a dexguard-project.txt file to hold specific DexGuard configuration options, and add: -dontnote com.newrelic.agent.android.NewRelic -dontnote com.newrelic.agent.android.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app's buildTypes configuration is similar to this: buildTypes { release { minifyEnabled true proguardFile getDefaultDexGuardFile('dexguard-release.pro') proguardFile 'proguard-rules.pro' proguardFile 'dexguard-project.txt' } ... Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 156.56035,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "sections": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": ", and add: -dontnote com.newrelic.agent.<em>android.NewRelic</em> -dontnote com.newrelic.agent.<em>android</em>.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app&#x27;s buildTypes configuration is similar to this: buildTypes { release { minifyEnabled"
      },
      "id": "604418de196a6770e7960f6c"
    },
    {
      "sections": [
        "Install Android apps with Gradle and Android Studio",
        "Install your Android app",
        "Configure with Gradle and Android Studio",
        "Project level build.gradle file:",
        "App level build.gradle file:",
        "Important",
        "Update your Android installation",
        "Android 4.x: Multidex support",
        "New Relic Gradle Plugin configuration"
      ],
      "title": "Install Android apps with Gradle and Android Studio",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "51fab3eba87ddee949cd4729de8b5f64534de9c7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-android-apps-gradle-android-studio/",
      "published_at": "2021-09-14T08:10:37Z",
      "updated_at": "2021-07-27T17:09:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Gradle or Android Studio, follow these instructions to install New Relic's mobile monitoring for the first time. If you have previously installed the Android agent SDK for mobile monitoring, follow the steps before upgrading to the latest version with Gradle and Android Studio. Install your Android app As part of the installation process for mobile monitoring, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. Go to one.newrelic.com > Mobile. If applicable: From the Mobile apps index, select Add a new app. From the Get started page, select Android as the platform for mobile monitoring. Type a meaningful name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring with Gradle and Android Studio. OR: To complete the configuration process for a new mobile app later: Go to one.newrelic.com > Mobile, then select See instructions next to your mobile app name. To upgrade an existing Android installation: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Configure with Gradle and Android Studio These procedures to configure your Android app with Gradle and Android Studio also appear on the Get started page in New Relic. Merge New Relic's mobile monitoring code in the Gradle & Android Studio tab to your build.gradle file. Project level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. buildscript { repositories { mavenCentral() } dependencies { classpath \"com.newrelic.agent.android:agent-gradle-plugin:AGENT_VERSION\" } } Copy App level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. repositories { mavenCentral() } apply plugin: 'android' apply plugin: 'newrelic' dependencies { compile 'com.newrelic.agent.android:android-agent:AGENT_VERSION' } Copy ProGuard or DexGuard: In your project’s root directory (projectname/app), add a newrelic.properties file with the following line: com.newrelic.application_token=GENERATED_TOKEN Copy Follow the additional, required configuration steps for using ProGuard or DexGuard with New Relic. Set app permissions: Ensure that your Android app requests INTERNET and ACCESS_NETWORK_STATE permissions by adding these lines to your AndroidManifest.xml file: <uses-permission android:name=\"android.permission.INTERNET\" /> <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /> Copy To start New Relic's mobile monitoring agent: In your Default Activity (as defined in your Manifest), import the NewRelic class: import com.newrelic.agent.android.NewRelic; Copy Important We do not support starting the mobile monitoring agent in other classes, as that can cause unexpected or unstable behavior. To initialize mobile monitoring: In the onCreate() method, add this call: NewRelic.withApplicationToken(\"GENERATED_TOKEN\").start(this.getApplication()); Copy Optional: Change the logging level. To build and run your application: Clean your project, then run your app in an emulator or device to generate traffic. Wait a few minutes, then view data for your Android app from the Overview page: Go to one.newrelic.com > Mobile > (select an app). If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI, follow the troubleshooting procedures. Update your Android installation To keep your Android agent up to date, follow the procedures to upgrade the Android agent SDK for New Relic. To install the latest Android version for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Android 4.x: Multidex support New Relic's mobile monitoring for Android versions prior to Android 5.0 (API level 21) use the Dalvik runtime to execute app code. By default, Dalvik limits apps to a single classes.dex bytecode file per APK. In order to get around this limitation, you must enable multidex support. Then you can use the multidex support library, which becomes part of the primary DEX file of your app and then manages access to the additional DEX files and the code they contain. When building each DEX file for a multidex app, the build tools perform complex decision making to determine which classes are needed in the primary DEX file so that your app can start successfully. If any class required during startup is not provided in the primary DEX file, then your app crashes with the error java.lang.NoClassDefFoundError. If you see the java.lang.NoClassDefFoundError error, then you must manually specify these additional classes as required in the primary DEX file: Create a proguard.multidex.config file within the /app folder of your project. Update mypackage to reflect your package name. #################### # keep class names # #################### #Keep New Relic in the main dex -keep class com.newrelic.** { *; } -keep class com.mypackage.activities.** { *; } Copy Merge the following code into the app-level build.gradle file: android { defaultConfig{ … multiDexKeepProguard file(\"proguard.multidex.config\") } } Copy For more information, see the Android Developers documentation on declaring classes required in the primary DEX file. New Relic Gradle Plugin configuration For details on how to configure the behavior of the mobile monitoring agent plugin during Gradle builds, see the New Relic Gradle plugin extension guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.40433,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "sections": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "If you use Gradle or <em>Android</em> Studio, follow these instructions to <em>install</em> <em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for the first time. If you have previously installed the <em>Android</em> agent SDK for <em>mobile</em> <em>monitoring</em>, follow the steps before upgrading to the latest version with Gradle and <em>Android</em> Studio. <em>Install</em>"
      },
      "id": "603ea70128ccbc59c2eba74e"
    },
    {
      "sections": [
        "Upgrade the Android agent",
        "Upgrade from Android SDK versions 2 or 3",
        "Upgrade Android SDK version 1"
      ],
      "title": "Upgrade the Android agent",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "eca0e4db3d71cbe83bbb40fdc2e7d026d5e5ed4b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/upgrade-new-relic-mobiles-android-sdk/",
      "published_at": "2021-09-14T07:47:59Z",
      "updated_at": "2021-07-09T15:02:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To ensure you have the most current version of the Android agent, see the Android agent release notes. Instructions to upgrade your Android app will vary, based on which version of the Android agent SDK you are currently using. Upgrade from Android SDK versions 2 or 3 If you have previously installed version 2 or 3 of the Android SDK: Go to one.newrelic.com > Mobile > (select an app) > Settings > Upgrade. Upgrade Android SDK version 1 If you have previously installed version 1 of the Android SDK, follow these steps before upgrading to version 2 or higher. Step Notes Open your AndroidManifest.xml file, and remove the NewRelicApplication class. When you first ran nrandroid-setup, the NewRelicApplication class was added to your AndroidManifest.xml file. This has been removed from the New Relic SDK and is no longer necessary. If you had an existing Application subclass and modified it to inherit from NewRelicApplication, update your subclass to inherit from Application instead. Stop using nrandroid-ant. Mobile monitoring no longer requires the custom Ant wrapper script for Android applications. Once you upgrade, simply use your standard build tools. If you modified an existing Maven configuration to invoke the mobile build steps, remove those modifications, and use the revised build instructions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 130.82756,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upgrade the <em>Android</em> agent",
        "sections": "Upgrade the <em>Android</em> agent",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " it to inherit from <em>NewRelic</em>Application, update your subclass to inherit from Application instead. Stop using nrandroid-ant. <em>Mobile</em> <em>monitoring</em> no longer requires the custom Ant wrapper script for <em>Android</em> applications. Once you upgrade, simply use your standard build tools. If you modified an existing Maven configuration to invoke the <em>mobile</em> build steps, remove those modifications, and use the revised build instructions."
      },
      "id": "603eae0664441f985b4e8843"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/install-configure/upgrade-new-relic-mobiles-android-sdk": [
    {
      "sections": [
        "Configure ProGuard or DexGuard for Android apps",
        "Configure ProGuard",
        "Network library support",
        "Configure DexGuard"
      ],
      "title": "Configure ProGuard or DexGuard for Android apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "8a8df969c4099f75cb214354cef311dfa2ab50e2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/configure-proguard-or-dexguard-android-apps/",
      "published_at": "2021-09-14T07:45:07Z",
      "updated_at": "2021-08-21T09:16:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to support ProGuard or DexGuard with the Android agent. Check our Android compatibility and requirements, and if you have previously installed the Android agent SDK, follow the steps before upgrading to the latest version with ProGuard or DexGuard. Configure ProGuard To add support for ProGuard: Add an exclusion to your app; for example: To support New Relic instrumentation, add keep class. To disable warnings related to unresolved problems, add dont warn. To preserve line numbers for crash reporting, add LineNumberTable. To preserve stack information for handled exceptions, add SourceFile and EnclosingMethod. Add the following to your ProGuard config file (proguard.cfg, proguard-android.txt, proguard-rules.pro, etc.): -keep class com.newrelic.** { *; } -dontwarn com.newrelic.** -keepattributes Exceptions, Signature, InnerClasses, LineNumberTable, SourceFile, EnclosingMethod Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors. Network library support New Relic instrumentation happens before ProGuard obfuscates your code. In order for these libraries to be properly instrumented, their classes must not be obfuscated by ProGuard. Here are examples of rules to be applied to preserve these classes. This is not a complete list. Different rules will be needed depending on your library or version. Library Rules Apache Http -keep class org.apache.http.** { *; } -dontwarn org.apache.http.** Copy OkHttp 2 -keep class com.squareup.okhttp.* { *; } -dontwarn com.squareup.okhttp.** -dontwarn okio.** Copy OkHttp 3 -keep class okhttp3.** { *; } -dontwarn okhttp3.** -dontwarn okio.** Copy Retrofit 2 -keep class retrofit2.** { *; } -dontwarn retrofit2.** Copy Configure DexGuard DexGuard uses the same configuration options as ProGuard, and it can read any pre-existing ProGuard configuration files. DexGuard also has its own set of additional configuration options and provides sample configurations for many common app frameworks. To add support for DexGuard: Add DexGuard to your app and set up the Gradle plugin according to the directions from DexGuard. Create a dexguard-project.txt file to hold specific DexGuard configuration options, and add: -dontnote com.newrelic.agent.android.NewRelic -dontnote com.newrelic.agent.android.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app's buildTypes configuration is similar to this: buildTypes { release { minifyEnabled true proguardFile getDefaultDexGuardFile('dexguard-release.pro') proguardFile 'proguard-rules.pro' proguardFile 'dexguard-project.txt' } ... Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 156.56035,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "sections": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": ", and add: -dontnote com.newrelic.agent.<em>android.NewRelic</em> -dontnote com.newrelic.agent.<em>android</em>.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app&#x27;s buildTypes configuration is similar to this: buildTypes { release { minifyEnabled"
      },
      "id": "604418de196a6770e7960f6c"
    },
    {
      "sections": [
        "Install Android apps with Gradle and Android Studio",
        "Install your Android app",
        "Configure with Gradle and Android Studio",
        "Project level build.gradle file:",
        "App level build.gradle file:",
        "Important",
        "Update your Android installation",
        "Android 4.x: Multidex support",
        "New Relic Gradle Plugin configuration"
      ],
      "title": "Install Android apps with Gradle and Android Studio",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "51fab3eba87ddee949cd4729de8b5f64534de9c7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-android-apps-gradle-android-studio/",
      "published_at": "2021-09-14T08:10:37Z",
      "updated_at": "2021-07-27T17:09:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Gradle or Android Studio, follow these instructions to install New Relic's mobile monitoring for the first time. If you have previously installed the Android agent SDK for mobile monitoring, follow the steps before upgrading to the latest version with Gradle and Android Studio. Install your Android app As part of the installation process for mobile monitoring, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. Go to one.newrelic.com > Mobile. If applicable: From the Mobile apps index, select Add a new app. From the Get started page, select Android as the platform for mobile monitoring. Type a meaningful name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring with Gradle and Android Studio. OR: To complete the configuration process for a new mobile app later: Go to one.newrelic.com > Mobile, then select See instructions next to your mobile app name. To upgrade an existing Android installation: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Configure with Gradle and Android Studio These procedures to configure your Android app with Gradle and Android Studio also appear on the Get started page in New Relic. Merge New Relic's mobile monitoring code in the Gradle & Android Studio tab to your build.gradle file. Project level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. buildscript { repositories { mavenCentral() } dependencies { classpath \"com.newrelic.agent.android:agent-gradle-plugin:AGENT_VERSION\" } } Copy App level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. repositories { mavenCentral() } apply plugin: 'android' apply plugin: 'newrelic' dependencies { compile 'com.newrelic.agent.android:android-agent:AGENT_VERSION' } Copy ProGuard or DexGuard: In your project’s root directory (projectname/app), add a newrelic.properties file with the following line: com.newrelic.application_token=GENERATED_TOKEN Copy Follow the additional, required configuration steps for using ProGuard or DexGuard with New Relic. Set app permissions: Ensure that your Android app requests INTERNET and ACCESS_NETWORK_STATE permissions by adding these lines to your AndroidManifest.xml file: <uses-permission android:name=\"android.permission.INTERNET\" /> <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /> Copy To start New Relic's mobile monitoring agent: In your Default Activity (as defined in your Manifest), import the NewRelic class: import com.newrelic.agent.android.NewRelic; Copy Important We do not support starting the mobile monitoring agent in other classes, as that can cause unexpected or unstable behavior. To initialize mobile monitoring: In the onCreate() method, add this call: NewRelic.withApplicationToken(\"GENERATED_TOKEN\").start(this.getApplication()); Copy Optional: Change the logging level. To build and run your application: Clean your project, then run your app in an emulator or device to generate traffic. Wait a few minutes, then view data for your Android app from the Overview page: Go to one.newrelic.com > Mobile > (select an app). If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI, follow the troubleshooting procedures. Update your Android installation To keep your Android agent up to date, follow the procedures to upgrade the Android agent SDK for New Relic. To install the latest Android version for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Android 4.x: Multidex support New Relic's mobile monitoring for Android versions prior to Android 5.0 (API level 21) use the Dalvik runtime to execute app code. By default, Dalvik limits apps to a single classes.dex bytecode file per APK. In order to get around this limitation, you must enable multidex support. Then you can use the multidex support library, which becomes part of the primary DEX file of your app and then manages access to the additional DEX files and the code they contain. When building each DEX file for a multidex app, the build tools perform complex decision making to determine which classes are needed in the primary DEX file so that your app can start successfully. If any class required during startup is not provided in the primary DEX file, then your app crashes with the error java.lang.NoClassDefFoundError. If you see the java.lang.NoClassDefFoundError error, then you must manually specify these additional classes as required in the primary DEX file: Create a proguard.multidex.config file within the /app folder of your project. Update mypackage to reflect your package name. #################### # keep class names # #################### #Keep New Relic in the main dex -keep class com.newrelic.** { *; } -keep class com.mypackage.activities.** { *; } Copy Merge the following code into the app-level build.gradle file: android { defaultConfig{ … multiDexKeepProguard file(\"proguard.multidex.config\") } } Copy For more information, see the Android Developers documentation on declaring classes required in the primary DEX file. New Relic Gradle Plugin configuration For details on how to configure the behavior of the mobile monitoring agent plugin during Gradle builds, see the New Relic Gradle plugin extension guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.40433,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "sections": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "If you use Gradle or <em>Android</em> Studio, follow these instructions to <em>install</em> <em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for the first time. If you have previously installed the <em>Android</em> agent SDK for <em>mobile</em> <em>monitoring</em>, follow the steps before upgrading to the latest version with Gradle and <em>Android</em> Studio. <em>Install</em>"
      },
      "id": "603ea70128ccbc59c2eba74e"
    },
    {
      "sections": [
        "Install the New Relic plugin for Android Instant Apps",
        "Terminology",
        "Install the plugin",
        "Minimal build.gradle example",
        "Instrumentation",
        "ProGuard and Dexguard support",
        "Important",
        "Troubleshoot auto-instrumentation"
      ],
      "title": "Install the New Relic plugin for Android Instant Apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "a9b40dd5eccb3d96a0cdc246eafe66b92fdeab6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-new-relic-plugin-android-instant-apps/",
      "published_at": "2021-09-14T08:11:53Z",
      "updated_at": "2021-07-09T15:02:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Android Instant Apps allow users to quickly use your applications without installation. With the Android agent version 5.17.0 and higher, you can use New Relic to detect and instrument all feature modules for an instant app. Use this documentation along with the standard New Relic procedures to install Android apps with Gradle and Android Studio. After following the standard installation procedures, follow these additional steps for Android instant apps. Terminology This procedure uses the following terms that are specific to the Android Instant Apps plugin: Module: Any packaged class and/or resource collection APK: A module that packages the apps resources and DEX’ed classes Feature module: A slimmed down module that contains only a subset of the total APK Install the plugin To install the New Relic plugin for Android Instant Apps: First follow the steps in the Install Android apps with Gradle and Android Studio documentation. Apply the agent plugin in every project Gradle build file. List the Android agent as a dependency. Start the agent from each Activity class in the feature that could be side-loaded through a Digital Asset Link intent, (for example, mobile.example.com/signin). Minimal build.gradle example apply plugin: ‘com.android.[application|library|feature|instantapp]' apply plugin: ‘newrelic’ dependencies { implementation \"com.newrelic.agent.android:android-agent:${project.agentVersion}\" } Copy Review the considerations for instrumentation. Instrumentation When instrumenting an instant app, be aware of the following considerations with APKs: Instant apps and APKs Comments Instrumentation Instrumentation of instant apps behaves the same as instrumentation with a normal APK. The agent will detect when an APK is an instant app. For feature APKs, the agent will inject a unique build ID that instant apps will use when reporting crashes. The side-loaded (main) activity of every feature must call NewRelic.start() when the activity is created (as per normal instructions). ProGuard and Dexguard support for feature and application APKs Place the newrelic.properties file in the root (main) directory of the project. ProGuard and Dexguard support The Android Studio Gradle plugin will obfuscate any build configuration where minifyEnabled is set to true. In these conditions, the New Relic agent will forward the ProGuard map generated for the build to crash collectors, tagged with a unique build ID generated by the agent. Obfuscation is best configured in the application or instant app project that includes other modules as dependencies. Modules may configure ProGuard as needed. Important When using ProGuard or DexGuard with Android apps, follow the procedures to complete the additional, required configuration steps. For more information, see the ProGuard and DexGuard configuration documentation. Troubleshoot auto-instrumentation If you are not whether the agent is auto-instrumenting an instant app project, try running these steps: Build app with debug (-d, --debug) option, and capture the build log. Search the log for evidence of instant apps by looking for either of these terms: This appears to be an Instant App Copy BuildId[1a2b34c5-def6-7890-g123-h4567890a] Copy The agent will add an attribute named 'instantApp' to the app's Insights session attributes if the app appears to be an instant app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 130.82756,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "sections": "<em>Install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " and&#x2F;or resource collection APK: A module that packages the apps resources and DEX’ed classes Feature module: A slimmed down module that contains only a subset of the total APK <em>Install</em> the plugin To <em>install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps: First follow the steps in the <em>Install</em> <em>Android</em> apps"
      },
      "id": "603e87a764441fa6934e885e"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/legacy/install-android-apps-android-22-support": [
    {
      "sections": [
        "Configure ProGuard or DexGuard for Android apps",
        "Configure ProGuard",
        "Network library support",
        "Configure DexGuard"
      ],
      "title": "Configure ProGuard or DexGuard for Android apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "8a8df969c4099f75cb214354cef311dfa2ab50e2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/configure-proguard-or-dexguard-android-apps/",
      "published_at": "2021-09-14T07:45:07Z",
      "updated_at": "2021-08-21T09:16:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to support ProGuard or DexGuard with the Android agent. Check our Android compatibility and requirements, and if you have previously installed the Android agent SDK, follow the steps before upgrading to the latest version with ProGuard or DexGuard. Configure ProGuard To add support for ProGuard: Add an exclusion to your app; for example: To support New Relic instrumentation, add keep class. To disable warnings related to unresolved problems, add dont warn. To preserve line numbers for crash reporting, add LineNumberTable. To preserve stack information for handled exceptions, add SourceFile and EnclosingMethod. Add the following to your ProGuard config file (proguard.cfg, proguard-android.txt, proguard-rules.pro, etc.): -keep class com.newrelic.** { *; } -dontwarn com.newrelic.** -keepattributes Exceptions, Signature, InnerClasses, LineNumberTable, SourceFile, EnclosingMethod Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors. Network library support New Relic instrumentation happens before ProGuard obfuscates your code. In order for these libraries to be properly instrumented, their classes must not be obfuscated by ProGuard. Here are examples of rules to be applied to preserve these classes. This is not a complete list. Different rules will be needed depending on your library or version. Library Rules Apache Http -keep class org.apache.http.** { *; } -dontwarn org.apache.http.** Copy OkHttp 2 -keep class com.squareup.okhttp.* { *; } -dontwarn com.squareup.okhttp.** -dontwarn okio.** Copy OkHttp 3 -keep class okhttp3.** { *; } -dontwarn okhttp3.** -dontwarn okio.** Copy Retrofit 2 -keep class retrofit2.** { *; } -dontwarn retrofit2.** Copy Configure DexGuard DexGuard uses the same configuration options as ProGuard, and it can read any pre-existing ProGuard configuration files. DexGuard also has its own set of additional configuration options and provides sample configurations for many common app frameworks. To add support for DexGuard: Add DexGuard to your app and set up the Gradle plugin according to the directions from DexGuard. Create a dexguard-project.txt file to hold specific DexGuard configuration options, and add: -dontnote com.newrelic.agent.android.NewRelic -dontnote com.newrelic.agent.android.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app's buildTypes configuration is similar to this: buildTypes { release { minifyEnabled true proguardFile getDefaultDexGuardFile('dexguard-release.pro') proguardFile 'proguard-rules.pro' proguardFile 'dexguard-project.txt' } ... Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.509125,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Configure ProGuard or DexGuard for <em>Android</em> apps",
        "sections": "Configure ProGuard or DexGuard for <em>Android</em> apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": ", and add: -dontnote com.newrelic.agent.<em>android.NewRelic</em> -dontnote com.newrelic.agent.<em>android</em>.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app&#x27;s buildTypes configuration is similar to this: buildTypes { release { minifyEnabled"
      },
      "id": "604418de196a6770e7960f6c"
    },
    {
      "sections": [
        "No data appears (Android)",
        "Problem",
        "Solution"
      ],
      "title": "No data appears (Android)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Troubleshoot"
      ],
      "external_id": "cab2851a6f3c8bfddb1ed445f8722b3dddff7442",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/troubleshoot/no-data-appears-android/",
      "published_at": "2021-09-14T07:46:30Z",
      "updated_at": "2021-07-09T15:38:22Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After installing the Android agent and waiting at least 5 minutes, no data appears in New Relic UI. Solution If no data appears after you wait at least five minutes, use New Relic Diagnostics to automatically detect common problems and suggest troubleshooting. If that does not solve your issue, try the following: Make sure your system meets the compatibility and requirements. Make sure that you are calling the Android agent on the first line of onCreate() in the MainActivity class and that you are running the agent on the main thread. The Android agent does not support starting the agent in another class. Check whether your Android app exceeds the 64k multidex limit. Increase the logging level and examine your logs for errors: Increase the New Relic logging level to AUDIT using withLogLevel: NewRelic.withApplicationToken(\"YOUR_APP_TOKEN\") .withLogLevel(AgentLog.AUDIT) .start(this.getApplication()); Copy Generate a few minutes of activity in your app. Examine your device log and your application build logs for issues. Confirm the device can reach the mobile monitoring endpoints listed in the Networks doc. If you need additional help, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 116.71689,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No data appears (<em>Android</em>)",
        "sections": "No data appears (<em>Android</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Problem After installing the <em>Android</em> agent and waiting at least 5 minutes, no data appears in <em>New</em> <em>Relic</em> UI. Solution If no data appears after you wait at least five minutes, use <em>New</em> <em>Relic</em> Diagnostics to automatically detect common problems and suggest troubleshooting. If that does not solve your"
      },
      "id": "603e8eb6196a67b64ea83d81"
    },
    {
      "sections": [
        "Android app exceeds 64k multidex limit",
        "Problem",
        "Build time error message example",
        "Run time crash message example",
        "Solution"
      ],
      "title": "Android app exceeds 64k multidex limit",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Troubleshoot"
      ],
      "external_id": "4b456c8143055292aa480cc213ffc82b72ddee70",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/troubleshoot/android-app-exceeds-64k-multidex-limit/",
      "published_at": "2021-09-14T10:07:20Z",
      "updated_at": "2021-07-09T15:04:03Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem Your Android app exceeds the 64k limit for the total number of methods that can be referenced within a single Dalvik Executable file (DEX), including methods for frameworks, libraries, and your own Android app code. You see error messages from the agent such as these: Build time error message example > com.android.build.api.transform.TransformException: com.android.ide.common.process.ProcessException: java.util.concurrent.ExecutionException: com.android.dex.DexException: Too many classes in --main-dex-list, main dex capacity exceeded Copy Run time crash message example E/AndroidRuntime: FATAL EXCEPTION: main Process: com.example.mobile.debug, PID: 12345 java.lang.NoClassDefFoundError: com.example.foobar.myapp.MainActivity Copy These exception errors typically occur with Android devices prior to Android 5.0 (API level 21), which requires the multidex support library. Solution To fix build errors or runtime exceptions when using the latest Android build tool: Make sure you have the latest Android agent version. Enable multidex. Enable Proguard or Dexguard to optimize classes and methods in your DEX. If you still have problems with keeping your Android app under the 64k limit, use a keepfile.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 116.71223,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> app exceeds 64k multidex limit",
        "sections": "<em>Android</em> app exceeds 64k multidex limit",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "&#x2F;<em>Android</em>Runtime: FATAL EXCEPTION: main Process: com.example.<em>mobile</em>.debug, PID: 12345 java.lang.NoClassDefFoundError: com.example.foobar.myapp.MainActivity Copy These exception errors typically occur with <em>Android</em> devices prior to <em>Android</em> 5.0 (API level 21), which requires the multidex support library. Solution"
      },
      "id": "60441922196a6721e4960f26"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/troubleshoot/android-app-exceeds-64k-multidex-limit": [
    {
      "sections": [
        "No data appears (Android)",
        "Problem",
        "Solution"
      ],
      "title": "No data appears (Android)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Troubleshoot"
      ],
      "external_id": "cab2851a6f3c8bfddb1ed445f8722b3dddff7442",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/troubleshoot/no-data-appears-android/",
      "published_at": "2021-09-14T07:46:30Z",
      "updated_at": "2021-07-09T15:38:22Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After installing the Android agent and waiting at least 5 minutes, no data appears in New Relic UI. Solution If no data appears after you wait at least five minutes, use New Relic Diagnostics to automatically detect common problems and suggest troubleshooting. If that does not solve your issue, try the following: Make sure your system meets the compatibility and requirements. Make sure that you are calling the Android agent on the first line of onCreate() in the MainActivity class and that you are running the agent on the main thread. The Android agent does not support starting the agent in another class. Check whether your Android app exceeds the 64k multidex limit. Increase the logging level and examine your logs for errors: Increase the New Relic logging level to AUDIT using withLogLevel: NewRelic.withApplicationToken(\"YOUR_APP_TOKEN\") .withLogLevel(AgentLog.AUDIT) .start(this.getApplication()); Copy Generate a few minutes of activity in your app. Examine your device log and your application build logs for issues. Confirm the device can reach the mobile monitoring endpoints listed in the Networks doc. If you need additional help, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 153.25468,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No data appears (<em>Android</em>)",
        "sections": "No data appears (<em>Android</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Problem After installing the <em>Android</em> agent and waiting at least 5 minutes, no data appears in <em>New</em> <em>Relic</em> UI. Solution If no data appears after you wait at least five minutes, use <em>New</em> <em>Relic</em> Diagnostics to automatically detect common problems and suggest troubleshooting. If that does not solve your"
      },
      "id": "603e8eb6196a67b64ea83d81"
    },
    {
      "sections": [
        "Introduction to iOS mobile app",
        "Features",
        "Time range",
        "Synthetic monitoring",
        "Alerts",
        "Mobile monitoring",
        "Data privacy"
      ],
      "title": "Introduction to iOS mobile app",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "iOS app"
      ],
      "external_id": "371077582a50dfd2a1e7c57cfbbf9eeaf8013e1c",
      "image": "https://docs.newrelic.com/static/630c7a9a486540073ab96a2c9926e303/442cb/device-ios-synthetics-view-monitor.png",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/ios-app/introduction-ios-mobile-app/",
      "published_at": "2021-09-14T07:29:48Z",
      "updated_at": "2021-09-14T07:29:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The user interface for New Relic's iPhone and iPad app provides functionality similar to New Relic's standard user interface, with customized details for mobile users. The New Relic iOS apps show near real-time information about your apps, hosts, and more. Features New Relic's iOS app includes these New Relic products and features: New Relic's iOS app for iPhone and iPad includes these New Relic products and features: APM (iPhone and iPad). Includes real-time and historical data. Select the icon to see transaction details. Select Overview Charts to view summary charts of your top five transactions. Browser monitoring (iPhone and iPad). Provide overview dashboard, including average page load time, browser Apdex, average throughput, and more. Infrastructure monitoring (iPhone only). Alerts (iPhone and iPad). Get alert and deployment notifications. Synthetic monitoring (iPhone only). Mobile monitoring (iPhone and iPad). Includes crash reports, network errors, API calls, and active user count. New Relic's iOS app does not have all the features of the New Relic web application. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the clock icon in the top right of the page. This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth across the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). For iPads: to specify an end time other than now, slide the toggle from Ending Now to Custom Date. Synthetic monitoring You can use the iOS app to view your synthetic monitoring data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you connect the iOS app to your New Relic account, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For iOS alerts, notifications appear on your lock screen and can be viewed by swiping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile monitoring If you have a mobile application and have installed mobile monitoring, you can monitor its performance directly from your iPhone or iPad. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. Data privacy New Relic's mobile apps only record information needed to help authenticate and troubleshoot: User's email address associated with your New Relic account, including first and last name (for authentication purposes only) IP address Device ID For more information, see our Mobile data privacy and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.31698,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to iOS <em>mobile</em> app",
        "sections": "<em>Mobile</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> apps",
        "body": " sends a push notification when a colleague acknowledges an open event. Then, <em>New</em> <em>Relic</em> sends a final, closing notification when all Critical events end. <em>Mobile</em> <em>monitoring</em> If you have a <em>mobile</em> application and have installed <em>mobile</em> <em>monitoring</em>, you can <em>monitor</em> its performance directly from your iPhone"
      },
      "id": "6044161628ccbc96b62c6092"
    },
    {
      "sections": [
        "Install the New Relic plugin for Android Instant Apps",
        "Terminology",
        "Install the plugin",
        "Minimal build.gradle example",
        "Instrumentation",
        "ProGuard and Dexguard support",
        "Important",
        "Troubleshoot auto-instrumentation"
      ],
      "title": "Install the New Relic plugin for Android Instant Apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "a9b40dd5eccb3d96a0cdc246eafe66b92fdeab6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-new-relic-plugin-android-instant-apps/",
      "published_at": "2021-09-14T08:11:53Z",
      "updated_at": "2021-07-09T15:02:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Android Instant Apps allow users to quickly use your applications without installation. With the Android agent version 5.17.0 and higher, you can use New Relic to detect and instrument all feature modules for an instant app. Use this documentation along with the standard New Relic procedures to install Android apps with Gradle and Android Studio. After following the standard installation procedures, follow these additional steps for Android instant apps. Terminology This procedure uses the following terms that are specific to the Android Instant Apps plugin: Module: Any packaged class and/or resource collection APK: A module that packages the apps resources and DEX’ed classes Feature module: A slimmed down module that contains only a subset of the total APK Install the plugin To install the New Relic plugin for Android Instant Apps: First follow the steps in the Install Android apps with Gradle and Android Studio documentation. Apply the agent plugin in every project Gradle build file. List the Android agent as a dependency. Start the agent from each Activity class in the feature that could be side-loaded through a Digital Asset Link intent, (for example, mobile.example.com/signin). Minimal build.gradle example apply plugin: ‘com.android.[application|library|feature|instantapp]' apply plugin: ‘newrelic’ dependencies { implementation \"com.newrelic.agent.android:android-agent:${project.agentVersion}\" } Copy Review the considerations for instrumentation. Instrumentation When instrumenting an instant app, be aware of the following considerations with APKs: Instant apps and APKs Comments Instrumentation Instrumentation of instant apps behaves the same as instrumentation with a normal APK. The agent will detect when an APK is an instant app. For feature APKs, the agent will inject a unique build ID that instant apps will use when reporting crashes. The side-loaded (main) activity of every feature must call NewRelic.start() when the activity is created (as per normal instructions). ProGuard and Dexguard support for feature and application APKs Place the newrelic.properties file in the root (main) directory of the project. ProGuard and Dexguard support The Android Studio Gradle plugin will obfuscate any build configuration where minifyEnabled is set to true. In these conditions, the New Relic agent will forward the ProGuard map generated for the build to crash collectors, tagged with a unique build ID generated by the agent. Obfuscation is best configured in the application or instant app project that includes other modules as dependencies. Modules may configure ProGuard as needed. Important When using ProGuard or DexGuard with Android apps, follow the procedures to complete the additional, required configuration steps. For more information, see the ProGuard and DexGuard configuration documentation. Troubleshoot auto-instrumentation If you are not whether the agent is auto-instrumenting an instant app project, try running these steps: Build app with debug (-d, --debug) option, and capture the build log. Search the log for evidence of instant apps by looking for either of these terms: This appears to be an Instant App Copy BuildId[1a2b34c5-def6-7890-g123-h4567890a] Copy The agent will add an attribute named 'instantApp' to the app's Insights session attributes if the app appears to be an instant app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.35313,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "sections": "Install the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "<em>Android</em> Instant Apps allow users to quickly use your applications without installation. With the <em>Android</em> agent version 5.17.0 and higher, you can use <em>New</em> <em>Relic</em> to detect and instrument all feature modules for an instant app. Use this documentation along with the standard <em>New</em> <em>Relic</em> procedures"
      },
      "id": "603e87a764441fa6934e885e"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/troubleshoot/no-data-appears-android": [
    {
      "sections": [
        "Android app exceeds 64k multidex limit",
        "Problem",
        "Build time error message example",
        "Run time crash message example",
        "Solution"
      ],
      "title": "Android app exceeds 64k multidex limit",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Troubleshoot"
      ],
      "external_id": "4b456c8143055292aa480cc213ffc82b72ddee70",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/troubleshoot/android-app-exceeds-64k-multidex-limit/",
      "published_at": "2021-09-14T10:07:20Z",
      "updated_at": "2021-07-09T15:04:03Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem Your Android app exceeds the 64k limit for the total number of methods that can be referenced within a single Dalvik Executable file (DEX), including methods for frameworks, libraries, and your own Android app code. You see error messages from the agent such as these: Build time error message example > com.android.build.api.transform.TransformException: com.android.ide.common.process.ProcessException: java.util.concurrent.ExecutionException: com.android.dex.DexException: Too many classes in --main-dex-list, main dex capacity exceeded Copy Run time crash message example E/AndroidRuntime: FATAL EXCEPTION: main Process: com.example.mobile.debug, PID: 12345 java.lang.NoClassDefFoundError: com.example.foobar.myapp.MainActivity Copy These exception errors typically occur with Android devices prior to Android 5.0 (API level 21), which requires the multidex support library. Solution To fix build errors or runtime exceptions when using the latest Android build tool: Make sure you have the latest Android agent version. Enable multidex. Enable Proguard or Dexguard to optimize classes and methods in your DEX. If you still have problems with keeping your Android app under the 64k limit, use a keepfile.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 153.24857,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> app exceeds 64k multidex limit",
        "sections": "<em>Android</em> app exceeds 64k multidex limit",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "&#x2F;<em>Android</em>Runtime: FATAL EXCEPTION: main Process: com.example.<em>mobile</em>.debug, PID: 12345 java.lang.NoClassDefFoundError: com.example.foobar.myapp.MainActivity Copy These exception errors typically occur with <em>Android</em> devices prior to <em>Android</em> 5.0 (API level 21), which requires the multidex support library. Solution"
      },
      "id": "60441922196a6721e4960f26"
    },
    {
      "sections": [
        "Introduction to iOS mobile app",
        "Features",
        "Time range",
        "Synthetic monitoring",
        "Alerts",
        "Mobile monitoring",
        "Data privacy"
      ],
      "title": "Introduction to iOS mobile app",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "iOS app"
      ],
      "external_id": "371077582a50dfd2a1e7c57cfbbf9eeaf8013e1c",
      "image": "https://docs.newrelic.com/static/630c7a9a486540073ab96a2c9926e303/442cb/device-ios-synthetics-view-monitor.png",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/ios-app/introduction-ios-mobile-app/",
      "published_at": "2021-09-14T07:29:48Z",
      "updated_at": "2021-09-14T07:29:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The user interface for New Relic's iPhone and iPad app provides functionality similar to New Relic's standard user interface, with customized details for mobile users. The New Relic iOS apps show near real-time information about your apps, hosts, and more. Features New Relic's iOS app includes these New Relic products and features: New Relic's iOS app for iPhone and iPad includes these New Relic products and features: APM (iPhone and iPad). Includes real-time and historical data. Select the icon to see transaction details. Select Overview Charts to view summary charts of your top five transactions. Browser monitoring (iPhone and iPad). Provide overview dashboard, including average page load time, browser Apdex, average throughput, and more. Infrastructure monitoring (iPhone only). Alerts (iPhone and iPad). Get alert and deployment notifications. Synthetic monitoring (iPhone only). Mobile monitoring (iPhone and iPad). Includes crash reports, network errors, API calls, and active user count. New Relic's iOS app does not have all the features of the New Relic web application. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the clock icon in the top right of the page. This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth across the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). For iPads: to specify an end time other than now, slide the toggle from Ending Now to Custom Date. Synthetic monitoring You can use the iOS app to view your synthetic monitoring data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you connect the iOS app to your New Relic account, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For iOS alerts, notifications appear on your lock screen and can be viewed by swiping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile monitoring If you have a mobile application and have installed mobile monitoring, you can monitor its performance directly from your iPhone or iPad. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. Data privacy New Relic's mobile apps only record information needed to help authenticate and troubleshoot: User's email address associated with your New Relic account, including first and last name (for authentication purposes only) IP address Device ID For more information, see our Mobile data privacy and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.31698,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to iOS <em>mobile</em> app",
        "sections": "<em>Mobile</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> apps",
        "body": " sends a push notification when a colleague acknowledges an open event. Then, <em>New</em> <em>Relic</em> sends a final, closing notification when all Critical events end. <em>Mobile</em> <em>monitoring</em> If you have a <em>mobile</em> application and have installed <em>mobile</em> <em>monitoring</em>, you can <em>monitor</em> its performance directly from your iPhone"
      },
      "id": "6044161628ccbc96b62c6092"
    },
    {
      "sections": [
        "Install the New Relic plugin for Android Instant Apps",
        "Terminology",
        "Install the plugin",
        "Minimal build.gradle example",
        "Instrumentation",
        "ProGuard and Dexguard support",
        "Important",
        "Troubleshoot auto-instrumentation"
      ],
      "title": "Install the New Relic plugin for Android Instant Apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "a9b40dd5eccb3d96a0cdc246eafe66b92fdeab6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-new-relic-plugin-android-instant-apps/",
      "published_at": "2021-09-14T08:11:53Z",
      "updated_at": "2021-07-09T15:02:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Android Instant Apps allow users to quickly use your applications without installation. With the Android agent version 5.17.0 and higher, you can use New Relic to detect and instrument all feature modules for an instant app. Use this documentation along with the standard New Relic procedures to install Android apps with Gradle and Android Studio. After following the standard installation procedures, follow these additional steps for Android instant apps. Terminology This procedure uses the following terms that are specific to the Android Instant Apps plugin: Module: Any packaged class and/or resource collection APK: A module that packages the apps resources and DEX’ed classes Feature module: A slimmed down module that contains only a subset of the total APK Install the plugin To install the New Relic plugin for Android Instant Apps: First follow the steps in the Install Android apps with Gradle and Android Studio documentation. Apply the agent plugin in every project Gradle build file. List the Android agent as a dependency. Start the agent from each Activity class in the feature that could be side-loaded through a Digital Asset Link intent, (for example, mobile.example.com/signin). Minimal build.gradle example apply plugin: ‘com.android.[application|library|feature|instantapp]' apply plugin: ‘newrelic’ dependencies { implementation \"com.newrelic.agent.android:android-agent:${project.agentVersion}\" } Copy Review the considerations for instrumentation. Instrumentation When instrumenting an instant app, be aware of the following considerations with APKs: Instant apps and APKs Comments Instrumentation Instrumentation of instant apps behaves the same as instrumentation with a normal APK. The agent will detect when an APK is an instant app. For feature APKs, the agent will inject a unique build ID that instant apps will use when reporting crashes. The side-loaded (main) activity of every feature must call NewRelic.start() when the activity is created (as per normal instructions). ProGuard and Dexguard support for feature and application APKs Place the newrelic.properties file in the root (main) directory of the project. ProGuard and Dexguard support The Android Studio Gradle plugin will obfuscate any build configuration where minifyEnabled is set to true. In these conditions, the New Relic agent will forward the ProGuard map generated for the build to crash collectors, tagged with a unique build ID generated by the agent. Obfuscation is best configured in the application or instant app project that includes other modules as dependencies. Modules may configure ProGuard as needed. Important When using ProGuard or DexGuard with Android apps, follow the procedures to complete the additional, required configuration steps. For more information, see the ProGuard and DexGuard configuration documentation. Troubleshoot auto-instrumentation If you are not whether the agent is auto-instrumenting an instant app project, try running these steps: Build app with debug (-d, --debug) option, and capture the build log. Search the log for evidence of instant apps by looking for either of these terms: This appears to be an Instant App Copy BuildId[1a2b34c5-def6-7890-g123-h4567890a] Copy The agent will add an attribute named 'instantApp' to the app's Insights session attributes if the app appears to be an instant app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.35313,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "sections": "Install the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "<em>Android</em> Instant Apps allow users to quickly use your applications without installation. With the <em>Android</em> agent version 5.17.0 and higher, you can use <em>New</em> <em>Relic</em> to detect and instrument all feature modules for an instant app. Use this documentation along with the standard <em>New</em> <em>Relic</em> procedures"
      },
      "id": "603e87a764441fa6934e885e"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-apps/mobile-app-features/authentication-partner-saml-sso-accounts": [
    {
      "sections": [
        "Introduction to iOS mobile app",
        "Features",
        "Time range",
        "Synthetic monitoring",
        "Alerts",
        "Mobile monitoring",
        "Data privacy"
      ],
      "title": "Introduction to iOS mobile app",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "iOS app"
      ],
      "external_id": "371077582a50dfd2a1e7c57cfbbf9eeaf8013e1c",
      "image": "https://docs.newrelic.com/static/630c7a9a486540073ab96a2c9926e303/442cb/device-ios-synthetics-view-monitor.png",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/ios-app/introduction-ios-mobile-app/",
      "published_at": "2021-09-14T07:29:48Z",
      "updated_at": "2021-09-14T07:29:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The user interface for New Relic's iPhone and iPad app provides functionality similar to New Relic's standard user interface, with customized details for mobile users. The New Relic iOS apps show near real-time information about your apps, hosts, and more. Features New Relic's iOS app includes these New Relic products and features: New Relic's iOS app for iPhone and iPad includes these New Relic products and features: APM (iPhone and iPad). Includes real-time and historical data. Select the icon to see transaction details. Select Overview Charts to view summary charts of your top five transactions. Browser monitoring (iPhone and iPad). Provide overview dashboard, including average page load time, browser Apdex, average throughput, and more. Infrastructure monitoring (iPhone only). Alerts (iPhone and iPad). Get alert and deployment notifications. Synthetic monitoring (iPhone only). Mobile monitoring (iPhone and iPad). Includes crash reports, network errors, API calls, and active user count. New Relic's iOS app does not have all the features of the New Relic web application. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the clock icon in the top right of the page. This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth across the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). For iPads: to specify an end time other than now, slide the toggle from Ending Now to Custom Date. Synthetic monitoring You can use the iOS app to view your synthetic monitoring data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you connect the iOS app to your New Relic account, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For iOS alerts, notifications appear on your lock screen and can be viewed by swiping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile monitoring If you have a mobile application and have installed mobile monitoring, you can monitor its performance directly from your iPhone or iPad. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. Data privacy New Relic's mobile apps only record information needed to help authenticate and troubleshoot: User's email address associated with your New Relic account, including first and last name (for authentication purposes only) IP address Device ID For more information, see our Mobile data privacy and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 277.5364,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to iOS <em>mobile</em> <em>app</em>",
        "sections": "Introduction to iOS <em>mobile</em> <em>app</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": "The user interface for <em>New</em> <em>Relic</em>&#x27;s iPhone and iPad <em>app</em> provides functionality similar to <em>New</em> <em>Relic</em>&#x27;s standard user interface, with customized details for <em>mobile</em> users. The <em>New</em> <em>Relic</em> iOS <em>apps</em> show near real-time information about your <em>apps</em>, hosts, and more. Features <em>New</em> <em>Relic</em>&#x27;s iOS <em>app</em> includes"
      },
      "id": "6044161628ccbc96b62c6092"
    },
    {
      "sections": [
        "Introduction to New Relic Android app",
        "Requirements",
        "Install New Relic's mobile app",
        "View New Relic data",
        "New Relic product details",
        "Synthetics data",
        "Alerts",
        "Mobile app monitoring",
        "Details on setting time range",
        "Data privacy"
      ],
      "title": "Introduction to New Relic Android app",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Android app"
      ],
      "external_id": "ff8415c00363a49eaa062f4b0b13c795b4717ea5",
      "image": "https://docs.newrelic.com/static/ea914fce17844b32fdabefd60efc457e/e5166/navigation_nexus.jpg",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/android-app/introduction-new-relic-android-app/",
      "published_at": "2021-09-14T07:28:16Z",
      "updated_at": "2021-09-14T07:28:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The user interface for New Relic's Android app provides functionality similar to New Relic's standard user interface, with customized details for mobile users. Requirements Requirements include: Android 4.0 (Ice Cream Sandwich) or higher Screen size of 7 inches or less Install New Relic's mobile app You can install the New Relic Android app from the Google Play Store or learn more from the New Relic website. Follow standard procedures to install any Android app, then sign in with your New Relic user name (account email) and password if applicable. Depending on your New Relic account, additional installation or user authentication steps may be required. View New Relic data To view details of your apps monitored by New Relic, select a product from the app's main menu. See below for details on how to use specific features of the app: New Relic product details The New Relic Android app includes data about these features: APM metrics, both real-time and historical data, including health maps. Select the transaction icon to see detailed transaction metrics, or an Overview chart to view summary charts of your top five transactions. Select the icon to filter by labels and categories. Browser monitoring metrics, including average page load time, Apdex, average throughput, and more. Infrastructure monitoring. Mobile monitoring, including crash reports, network errors, API calls, and active user count. Event notifications, including mobile alerts wherever you are, plus deployment notifications and notes. New Relic's Android app does not have the full feature set of the New Relic web interface. For more detailed analysis, sign in to your New Relic account with a web browser. Synthetics data You can use the Android app to view your synthetic monitoring data, including charts of your monitor's availability, load times, and load sizes. To view more detailed charts, select the caret icon. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you log in to your New Relic account from the Android app, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For Android alerts, notifications appear on your lock screen. To view them, tap the alert event. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile app monitoring If you have installed mobile monitoring, you can monitor its performance directly from your Android device. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. Details on setting time range When viewing an application or host, you can change the visible time frame with the time picker. To move back and forth across the timeline, scrub the New Relic charts. To change the duration of the visible time slice, select the clock icon. To specify an end time other than now, slide the toggle from Ending Now to Custom Date. To save your changes and refresh the chart data, select the clock icon again. Data privacy New Relic's mobile apps only record information needed to help authenticate and troubleshoot: User's email address associated with your New Relic account, including first and last name (for authentication purposes only) IP address Device ID For more information, see our Mobile data privacy and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 277.51862,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>Android</em> <em>app</em>",
        "sections": "Install <em>New</em> <em>Relic&#x27;s</em> <em>mobile</em> <em>app</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": ", additional installation or user <em>authentication</em> steps may be required. View <em>New</em> <em>Relic</em> data To view details of your <em>apps</em> monitored by <em>New</em> <em>Relic</em>, select a product from the <em>app</em>&#x27;s main menu. See below for details on how to use specific features of the <em>app</em>: <em>New</em> <em>Relic</em> product details The <em>New</em> <em>Relic</em> Android <em>app</em>"
      },
      "id": "604415e0196a67ff23960f46"
    },
    {
      "sections": [
        "Android app UI",
        "Pages",
        "Time range",
        "New Relic Synthetics",
        "Alerts",
        "Mobile apps",
        "For more help"
      ],
      "title": "Android app UI",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Android app"
      ],
      "external_id": "8918a5a2454491a91421c55e26501a0e3f64cd3a",
      "image": "https://docs.newrelic.com/static/fc97ade0bbdbdef58b89495a0d91b734/edd00/deployment-markers_nexus.jpg",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/android-app/android-app-ui/",
      "published_at": "2021-09-14T07:28:15Z",
      "updated_at": "2021-09-14T07:28:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The UI for the New Relic Android app provides functionality similar to the standard user interface, with customized details for mobile users. Pages To view details of your New Relic apps, hosts, Synthetics monitors, Alerts, plugins, and key transactions, select a product from the main menu. The New Relic Android app includes: APM metrics, both real-time and historical data, including health maps. And, select the transaction icon for detailed transaction metrics, or an Overview Charts to view summary charts of your top five transactions. New Relic Infrastructure utilization. New Relic Plugins, including a list of their components or instances, and their charts and current values from the plugin's Summary. Mobile monitoring, including crash reports, network errors, API calls, and active user count. Select the filter icon to filter by labels and categories. Event notifications, including mobile alerts wherever you are, plus deployment notifications and notes. Note: New Relic's Android app does not have the full feature set of the New Relic web interface. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the time picker icon in the top right of the page (the 7D in the screenshot). This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth in the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). New Relic Synthetics You can use the Android app to view your New Relic Synthetics data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you log in to your New Relic account from the Android app, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For Android alerts, notifications appear on your lock screen and can be viewed by tapping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile apps If you have a mobile application and have installed mobile monitoring, you can monitor its performance directly from your Android device. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. For more help Additional documentation resources include: New Relic Android app (compatibility, requirements, installation) Android authentication (procedures to add or remove users, and for the users to authenticate with their Android device)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 277.51843,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>app</em> UI",
        "sections": "<em>Mobile</em> <em>apps</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": "The UI for the <em>New</em> <em>Relic</em> Android <em>app</em> provides functionality similar to the standard user interface, with customized details for <em>mobile</em> users. Pages To view details of your <em>New</em> <em>Relic</em> <em>apps</em>, hosts, Synthetics monitors, <em>Alerts</em>, plugins, and key transactions, select a product from the main menu. The <em>New</em>"
      },
      "id": "6044181d28ccbc9a522c60a5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-cordova-phonegap/get-started/introduction-new-relic-cordova": [
    {
      "sections": [
        "New Relic API keys",
        "API key UI",
        "Overview of keys",
        "Keys for data ingest",
        "Keys for querying and configuration",
        "License key",
        "View and manage license key",
        "User key",
        "Browser key",
        "Insights insert key",
        "Important",
        "REST API key",
        "Insights query key",
        "Admin key",
        "Account ID"
      ],
      "title": "New Relic API keys",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "b373cd68cf21daeb5d912ffb4b1ae3f14f500fcc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/intro-apis/new-relic-api-keys/",
      "published_at": "2021-09-13T14:57:47Z",
      "updated_at": "2021-09-07T16:54:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic has several different APIs that use different API keys. This resource explains our keys, what they're used for, and how to access them. API key UI Most of the keys can be viewed and managed via the API keys UI page: From the account dropdown, click API keys (get a direct link to the API keys page). If you're using NerdGraph, you can manage license keys and user keys from our GraphiQL explorer. Overview of keys If you're using a specific API, see the docs for that API to understand which keys are required and recommended. To learn about our APIs, see Introduction to APIs. Our keys can be broken down into two categories: Keys used for data ingest Keys used for querying and configuration Keys for data ingest There are many ways to get data into New Relic. Here are the API keys used for data ingest: License key: our primary ingest key, used for APM ingest, infrastructure monitoring ingest, and our ingest APIs and the integrations that use them. Browser key: used for browser monitoring ingest. Mobile app token: used for mobile monitoring ingest. Insights insert key: an older key that has been mostly deprecated, it has the same functionality as the license key. We recommend using the license key instead. Keys for querying and configuration Here are keys used for querying New Relic data or configuration of features: User key, also known as a \"personal API key\": used for NerdGraph (our GraphQL API) and for accessing REST API endpoints. REST API key: used for the REST API but we instead recommend using the user key because it has fewer restrictions. Insights query key: used with the Insights query API for querying New Relic data. We recommend using NerdGraph instead of this API. License key Our primary key used for data ingest is called the license key, also referenced in the UI and NerdGraph API as ingest - license. The license key is a 40-character hexadecimal string associated with a New Relic account. Each account in a New Relic organization has its own license key. When you first sign up for New Relic, that creates an organization with a single account, and that account has its own license key. If more accounts are added, each account will have its own license key. The types of data ingest the license key is used for include: APM agent data Infrastructure agent data Data sent via our core data ingest APIs (Metric API, Trace API, Event API, Log API), and the SDKs and integrations that use those APIs The license key is used for all data ingest except for browser monitoring data (which uses a browser key) and mobile monitoring data (which uses a mobile app token). Because the license key is used for data ingest, we recommend you treat your license key securely, like you would a password. This ensures no unwanted data is sent to your New Relic account. If your license key falls into the wrong hands, an attacker could send fake data to your account, which could trigger false alerts and contaminate your data so that detecting actual issues is more difficult. If you believe a license key has been exposed and has led to unwanted data, work with our Support team. View and manage license key To manage the license key: From the account dropdown, click API keys (get a direct link to the API keys page). You can't manage or delete the original license key that was created when an account was initially created. For that, contact New Relic support. You can also create additional license keys and manage them with our NerdGraph API. User key New Relic user keys, sometimes referred to as \"personal API keys\", are required for using NerdGraph and for the REST API. A user key is tied to both a specific New Relic user and a specific account. Our APIs that use this key let a user make queries for any accounts that user has been granted access to. To view and manage the user key and other API keys in the UI: From the account dropdown, click API keys (here's a direct link to the API keys page). To manage this key via API, see Manage keys with NerdGraph. You can also get or generate a user key from the NerdGraph GraphiQL explorer. Browser key One of the New Relic API keys that are used for data ingest is the browser key. The browser key allows the ingestion of data from New Relic browser monitoring. To view and manage this key: From the account dropdown, click API keys (here's a direct link to the API keys page). You can't manage or delete an original browser key that was created when your account was created. For that, contact New Relic support. Insights insert key Important This key is still in use but we highly recommend using the license key, which can be used for the same things and more. One of the New Relic API keys used for data ingest is the Insights insert key, also known as an \"insert key\"). Note that the license key is used for the same functionality and more, which is why we recommend the license key over this key. This key is used for the ingestion of data via our Event API, Log API, Metric API, and Trace API, or via tools that use those APIs. Tips on availability and access: Because these keys are associated with an account and not a specific user, anyone in the account with access to a key can use it. As a best practice for security purposes, we recommend you use different Insights insert keys for different applications or different data sources. To find and manage Insights insert keys: From the account dropdown, click API keys (get a direct link to the API keys page). Then click Insights insert keys. REST API key Important We highly recommend using a user key instead, because that key has fewer restrictions. The REST API key is for using our REST APIs for Alerts, APM, browser, infrastructure alerts, as well as mobile monitoring REST APIs and the API Explorer. Things to consider: We recommend using our newer NerdGraph API over the REST API, if possible. Requires admin-level user permissions. If you don't have access to the REST API key or the REST API explorer, it might be due to lack of permissions. Talk to your New Relic account manager, or use a user key instead. Each New Relic account can have only one REST API key. To find and manage REST API keys: From the account dropdown, click API keys (get a direct link to the API keys page). Then click REST API key. Before you configure or delete an API key, ensure you are doing so for the correct account. Insights query key The Insights query key is used for our Insights query API: we now recommend using NerdGraph for querying New Relic data. To find and manage Insights query keys: From the account dropdown, click API keys (get a direct link to the API keys page). Then click Insights query keys. Admin key Important As of December 4, 2020, all existing admin keys have been migrated to be user keys. You don’t need to do anything for existing admin keys to remain active. They will be automatically accessible via the API keys UI, labeled as user keys, and granted identical permissions. You can manage them as you would any user key via the same workflow. All migrated admin keys will have a note that says “Migrated from an admin user key” in the key table, so you’ll be able to find them easily. Account ID Looking for the account ID? See Account ID.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.34612,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> API keys",
        "sections": "<em>New</em> <em>Relic</em> API keys",
        "tags": "<em>Get</em> <em>started</em>",
        "body": "<em>New</em> <em>Relic</em> has several different APIs that use different API keys. This resource explains our keys, what they&#x27;re used for, and how to access them. API key UI Most of the keys can be viewed and managed via the API keys UI page: From the account dropdown, click API keys (<em>get</em> a direct link to the API"
      },
      "id": "6043fa3464441f1358378f3b"
    },
    {
      "sections": [
        "Glossary",
        "account dropdown",
        "account switcher",
        "administrator",
        "agent",
        "agent API",
        "aggregated metrics",
        "aggregation function",
        "aggregation window",
        "alert",
        "alert condition",
        "alert evaluation",
        "alert policy",
        "apdex",
        "apdex_f",
        "apdex_t",
        "API (application programming interface)",
        "APM",
        "application",
        "application ID",
        "application name",
        "Applied Intelligence (AI)",
        "attribute",
        "availability monitoring",
        "browser",
        "Browser monitoring",
        "background external",
        "child account",
        "cloud-based integration",
        "collector",
        "Command line interface (CLI)",
        "compute unit (CU)",
        "condition_id",
        "CPM (calls per minute)",
        "CPU burn",
        "custom attribute",
        "custom dashboard",
        "custom event",
        "custom instrumentation",
        "custom metric",
        "data collector",
        "data explorer",
        "degradation period",
        "dimensional metric",
        "Docker",
        "downtime",
        "entity",
        "event",
        "expected error",
        "exporter",
        "Flex",
        "framework",
        "Full-Stack Observability",
        "harvest cycle",
        "health status indicator",
        "host",
        "host ID",
        "ignored error",
        "incident",
        "Infrastructure monitoring",
        "Insights",
        "instance ID",
        "instrumentation",
        "integration",
        "interaction",
        "interaction trace",
        "inventory data",
        "key transaction",
        "launcher",
        "log",
        "Log monitoring",
        "Logs",
        "Logs in context",
        "master account",
        "metric",
        "metric timeslice",
        "metric grouping issue",
        "minion",
        "Mobile monitoring",
        "monitor",
        "NerdGraph",
        "Nerdlet",
        "Nerdpack",
        "New Relic Edge with Infinite Tracing",
        "New Relic One",
        "New Relic One catalog",
        "NRQL (New Relic query language)",
        "non-web transaction",
        "notification",
        "notification channel",
        "on-host integration",
        "owner",
        "page load timing",
        "parameter",
        "parent account",
        "permalink",
        "pinger",
        "Plugins",
        "polling interval (AWS)",
        "PPM (pages per minute)",
        "private location",
        "recovery period",
        "response time",
        "restricted user",
        "rollup",
        "root span",
        "RPM",
        "RUM (real user monitoring)",
        "runbook",
        "SAML (Security Assertion Markup Language)",
        "Selenium",
        "service",
        "signal",
        "signal filter",
        "span",
        "SSL certificate",
        "SSO (single sign on)",
        "streaming algorithm",
        "sub-accounts",
        "Synthetic monitoring",
        "target",
        "tag",
        "Telemetry Data Platform",
        "thresholds",
        "throughput",
        "tier",
        "time picker",
        "time range",
        "timeslice data",
        "trace",
        "traffic light",
        "transaction",
        "transaction trace",
        "UI",
        "user",
        "UTC",
        "value function (metrics)",
        "violation",
        "web external",
        "web transaction",
        "WebDriverJS",
        "workload"
      ],
      "title": "Glossary",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Welcome to New Relic",
        "Get started"
      ],
      "external_id": "756954560251823f905fe44d0ebea119cf983160",
      "image": "https://docs.newrelic.com/static/44172b3e07c1f24191825360676b9d99/c1b63/account-dropdown.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/glossary/",
      "published_at": "2021-09-14T09:10:41Z",
      "updated_at": "2021-09-14T09:10:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "A glossary of common terminology you may encounter. account dropdown In the upper right of the New Relic UI, the account dropdown gives you access to your account settings. If you're trying to switch between accounts, use the account switcher. account switcher If you have access to more than one account in a multi-account organization, you can use the account switcher to switch between accounts. This is located in the top right of most New Relic UI pages. For more on factors that affect access to accounts, see Factors affecting access. To find account settings, use the account dropdown. administrator A type of user role on a New Relic account. For more information, see Users. agent At New Relic, an agent is a piece of monitoring software that provides integrations with various technologies (for example, web frameworks, host operating systems, or database types). The agents send that data to New Relic, usually on a specific cadence. For more information, see: New Relic integrations Install agents agent API Some New Relic agents have agent APIs that allow you to extend the functionality of an agent. You can use the API to control, customize and extend the functionality of the agent. Here are some agent API docs: APM agents: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Ruby agent API Python agent API Browser agent: Browser agent API Mobile agents: iOS SDK API Android SDK API aggregated metrics Aggregated metric data summarizes calls to specific methods in your application, including how many times each one was called and response times. In the New Relic UI, you see the class and method names along with their aggregate numbers. Metric data aggregation depends on the New Relic tool and your subscription level. For more information, see the documentation about data retention. aggregation function You can use NRQL query function, such as sum(), average(), or latest() to choose how the data points in an aggregation window should be processed into a single data point. The single aggregated data point is what's passed through the alert evaluation process. aggregation window Streaming alerts gathers data together into specific amounts of time. These windows of time are customizable. Data points are collected together based their timestamps and reported as a batch. The customizable aggregation window provides greater flexibility and fewer false violations when alerting on irregular or less frequent data points. alert An alert communicates an event or incident that designated personnel can track through Alerts. For an explanation of how basic alerts concepts are related, see Concepts and workflow. alert condition An alert condition (or condition), identified by its unique numeric condition_id, contains the criteria for creating a violation. The condition includes the threshold that is set for a metric timeslice or a custom metric over time on a chosen target. For an explanation of how a condition relates to other basic alerts concepts, see Concepts and workflow. alert evaluation Streaming data is assessed on a set of aggregation windows to determine if an alert condition is violating or recovering. The aggregation window time is how long we'll collect data before running the NRQL query condition. The offset evaluation time is how long you want us to wait for late data before assessing it. If a window doesn't have any data points, it's treated as a gap for loss of signal. alert policy A collection of one or more conditions, one or more notification channels, and an Incident preference setting. If a condition contained within the policy opens a violation, an incident may be opened depending on the Incident preference setting. Notifications will then be sent to all channels attached to the policy. For an explanation of how a policy relates to other basic alerts concepts, see Concepts and workflow. apdex Apdex is an industry-standard way to measure users' satisfaction with the response time of an application or service. New Relic rates each response as Satisfied, Tolerated, or Frustrated, and uses these ratings to calculate an overall user satisfaction score. For more information, see Apdex: Measure user satisfaction. apdex_f The response time above which a transaction are rated frustrating. Defaults to four times apdex_t. Requests that complete in less than apdex_t are rated satisfied. Requests that take longer than apdex_t, but less than four times apdex_t (apdex_f), are tolerated. Any requests that take longer than apdex_f are rated frustrating. For more information, see Apdex: Measure user satisfaction. apdex_t The response time above which a transaction is considered tolerable. The default value is 0.5 seconds, but you can change this in your Apdex settings. Requests that complete in less than apdex_t are rated satisfied. Requests that take more than apdex_t, but less than apdex_f, are tolerated. Any requests that take longer than apdex_f are rated frustrating. For more information, see Apdex: Measure user satisfaction. API (application programming interface) New Relic offers a variety of APIs and SDKs. For more information, see the introduction to New Relic's APIs. APM New Relic's APM (application performance monitoring) provides monitoring of your web or non-web application's performance. APM supports apps using several programming languages. application For New Relic purposes, any program instrumented by New Relic. application ID Some New Relic solutions assign a monitored application a unique application ID, often shortened to app ID. When present, this ID is available in the UI. It is also reported as an attribute and can be queried. For how to determine this, see Find app ID. application name The name that New Relic combines with your license key to uniquely identify a particular app. For more information, see Name your application. Applied Intelligence (AI) Applied Intelligence (AI) helps you find, troubleshoot, and resolve problems more quickly. Specifically, it’s a hybrid machine learning engine that reduces alert noise, correlates incidents, and automatically detects anomalies. Applied Intelligence includes Alerts, Incident Intelligence, and Proactive Detection. attribute Attributes are key-value pairs attached to data objects reported to New Relic. Attributes add detail, and they're similar to tags or labels in other SaaS software. You can explore this data by querying or searching via the UI or by using the data dictionary. Examples: APM reports a Transaction event. This includes timing data for the transaction in a duration attribute, which might have a value of .002. Our Infrastructure Monitoring reports a ProcessSample event. This includes a variety of CPU usage attributes, including a cpuSystemPercent attribute, which might have a value of .01. Our Telemetry SDK reports a Metric data type for storing metrics, with attached attributes like metricName and newrelic.source. Some New Relic tools allow you to report custom attributes to enhance your monitoring. For more information about attributes in APM, see Agent attributes. availability monitoring See Types of Synthetics monitors. browser The New Relic UI supports most browsers. For more information, see Supported browsers. For our end-user browser monitoring tool, see Browser Monitoring. Browser monitoring A Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. background external See web external. child account See parent account. cloud-based integration New Relic offers cloud-based integrations with providers such as Amazon Web Services (AWS), Microsoft Azure, and Google Cloud Platform. collector The component that collects data from New Relic agents running on an app server, mobile device, or end-user browser. While the agent is installed on a user's app server, the collectors are centrally located in New Relic's data center. In order to contact the collector, the agent must be able to reach New Relic's domains and IP addresses. (The exact domain or IP depends on the New Relic monitoring tool.) The collector receives and interprets this data, and stores it in a database. The data is then retrieved and presented in the New Relic UI and by our various REST APIs. Command line interface (CLI) Our command line interface (CLI) is a tool you can use to build a New Relic application. This is the same tool our own engineers use. Go here for quick start instructions. Go to our Developer site for sample apps and guides. compute unit (CU) A unit of measurement that determines your pricing for some New Relic products governed by our original product-based pricing plan. For more information, see Compute unit pricing. condition_id See alert condition. CPM (calls per minute) The number of calls your application receives each minute. This usually corresponds to the number of page views or external connections, and is usually the same as RPM (requests per minute). CPU burn The time consumed by code minus the wait time for a transaction. This is the time actually spent processing the transaction. It appears in the New Relic UI at the top of the transaction view for the agents that provide it (Ruby and PHP only). custom attribute A key-value pair added to a transaction or event in order to gain additional information about it. For more information, see custom attributes. custom dashboard A customizable dashboard with charts and tables that includes data from multiple New Relic data sources. For more information, see dashboards. custom event An event, in New Relic terms, is a data object with attached attributes. New Relic reports default event types, like Transaction and TransactionError. You can also create your own events. Events can be queried, and are used in some other features. You can generate custom events with APM agents, with the Browser agent, with the mobile monitoring agents, and via the Event API. Alternatively, you can add custom attributes to some existing default New Relic events. custom instrumentation Custom instrumentation allows you to extend New Relic's monitoring to instrument code elements New Relic doesn't automatically instrument. Custom instrumentation is useful when your framework is not supported by New Relic, or when New Relic fails to pick up some element of your program. You can also use custom instrumentation to block a transaction from being reported entirely. For more information, see Custom instrumentation. custom metric Metric timeslice data that is manually recorded via an API call. Custom metrics allow you to record arbitrary metrics; for example, timing or computer resource data. All custom metric names must be prefixed with Custom/. For more information, see Custom metrics. Not to be confused with custom instrumentation data. data collector See collector. data explorer Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. For more on using the data explorer, see Introduction to the data explorer. degradation period When a data source enters a violating state, a degradation period of time begins. The degradation period is set in the condition's threshold. A violation will open if the source stays in a violating state for the entire degradation period. In addition: If the data source enters a non-violating state before the entire time has elapsed, the degradation period countdown is reset, and a violation does not open. If your alert condition threshold is configured as at least once in, the degradation period always lasts a single minute. dimensional metric A dimensional metric is a metric that has multiple attributes, also known as dimensions. At New Relic, we report dimensional metrics using the Metric data type. For more on other metric data types, see Metric data. Docker An open platform for distributed applications, which allows you to assemble multi-container portable apps. Infrastructure Monitoring includes integrated Docker monitoring. For more information about Docker, see the Docker website. downtime The period of time when customers cannot access your site and your app is not reporting to New Relic. For more information, see Synthetic Monitoring and Types of synthetic monitors. entity In New Relic, an entity is anything we can identify that has data you can monitor. An entity can be something you monitor directly, like applications and microservices, or indirectly, like data centers. You can identify one or more entities to be targets for alert conditions. In the Alerts API, the entity being monitored is identified with an entity_id. For more on this, see What are entities? event The word event is a general term that can have many meanings. At New Relic, event can have several meanings: At New Relic, event data is one of our core data types. Event data represents a record of a single event at a particular moment in time. Events can vary by type (for example, Transaction or Mobile, and will have associated attributes (for example, timestamp or transactionName). For more details, see Event data. For our infrastructure monitoring, the word event can be used to refer to important system and host activity. For example, a configuration change for a monitored host would be registered on Infrastructure's Events UI page. For alerts, the Events UI page displays a list of alerts-related incidents for your monitored entities. Events are reported for a violation opening and for closing. In some contexts, event can refer to any NRQL-queryable data type. For example, when you run a NRQL query, you will see a count of inspected events: this refers to a count of all data types queried. expected error An expected error is a common error that you don't want to affect your Apdex score or error rate. For more information, see Manage errors in APM. exporter At New Relic, an exporter is a type of integration that reports telemetry data to New Relic from a third-party (non-New Relic) telemetry tool. For examples, see Exporters, or search our integrations. Flex New Relic Flex is an application-agnostic, all-in-one integration. With it, you can build your own integration that collects metric data from a wide variety of services, and that can instrument any app that exposes metrics over a standard protocol (HTTP, file, shell) in a standard format (for example, JSON or plain text) to the terminal. It's a recommended way to create a custom integration, because it doesn't require coding skills. framework A framework is a structured collection of pre-defined functions, into which an application builder inserts their own code to build their application. A framework is not the same as a library. While a library is a collection of functions you can call as needed, a framework is a skeleton for your application. The functions in that framework then call your functions. For more about the distinction between a framework and a library, see What is the difference between a framework and a library?. New Relic automatically instruments many common frameworks. For more about the frameworks New Relic supports, see the agent-specific documentation: C SDK supported frameworks Go supported frameworks Java supported frameworks .NET supported frameworks Node.js supported frameworks PHP supported frameworks Python supported frameworks Ruby supported frameworks Full-Stack Observability The collection of features and tools you can use to easily analyze and troubleshoot problems across your entire software stack. For more information, read our Introduction to Full-Stack Observability. harvest cycle The period of time between each connection from a New Relic agent to the collector. Between harvest cycles, an agent collects and caches data. At the end of the cycle an agent reports those data to the collector, then begins a new harvest cycle. health status indicator Some New Relic UI pages have a health status indicator appearing next to an index of monitored entities. This is a colored bar (generally green, yellow, red, or gray) indicating the status of your app or other entity monitored by New Relic. It also indicates whether the entity has any alert policies assigned to it and whether there are any policy violations. In general, the colored bar will be green, yellow, red, or gray to indicate the health status. Exceptions: Our REST API (v2) uses orange instead of yellow for the application's health and reporting status. Service maps use different criteria for reporting the health of a connection between an app and an external service not monitored by New Relic (for example, a third party API). host At New Relic, a host means one of the following: A physical machine is a hardware-based device with dedicated physical resources, including memory, processing, and storage. Each machine has its own OS which applications run on. A virtual machine (VM) is the software implementation of a physical machine that executes programs like a physical machine. One or more virtual machines can run on a physical machine. Each virtual machine has its own OS and allocated virtual machine resources such as RAM and CPU. A cloud instance is a type of virtual machine that is run in the public cloud. In this context, virtual machines and cloud instances are different from Java Virtual Machines (JVMs) and containers. host ID Each host identified by APM is assigned a host ID. This ID is used to uniquely identify it, and to retrieve data about that host via the REST API. For more information, see List host ID. ignored error An error that you have told the APM agent not to report to the collector. For more information, see Manage errors in APM. incident An incident is a collection of one or more violations of the conditions defined in an alert policy. An incident record includes all of the open and close time stamps for each violation, as well as chart snapshots of the data being evaluated around the time of each violation. You can view detailed information from the Incidents pages in the user interface. You can also select your preference for how we roll up violations into the incident. For an explanation of how an incident relates to other basic alerts concepts, see Concepts and workflow. Infrastructure monitoring By connecting changes in host performance to changes in your configuration, infrastructure monitoring provides real-time metrics and powerful analytics that reduce your mean-time-to-resolution (MTTR). Infrastructure is specifically designed for complex environments that need flexible, dynamic server monitoring, from a physical datacenter to thousands of Amazon Elastic Compute Cloud (Amazon EC2) instances and other types of integrations. Insights Insights was the name for the New Relic product that previously governed the reporting of custom events, and the ability to query and chart your New Relic data. These features are now a fundamental part of the New Relic One platform and are no longer governed by the Insights product or name. To learn more about these features: Event API for reporting custom events Query and chart data For historical reasons, the word \"Insights\" is still used in some places. Some examples of this: Some APM agents still have Insights language in their codebase. For example, the Java agent custom_insights_events configuration. For New Relic organizations on our original pricing plan, Insights Pro is still the product name governing custom event data ingest and retention. There is an API key called the Insights insert key. instance ID Each instance identified by New Relic is assigned a unique instance ID. Instance IDs are most commonly found for JVMs (Java Virtual Machines), but can exist for each agent. This ID is used to uniquely identify it, and to retrieve data about that instance via the REST API. For more information, see List instance IDs. instrumentation The collection of data from an application or host. When New Relic instruments a framework, it detects the methods and calls used by that framework, and intelligently groups them together. integration At New Relic, an integration refers to a solution that integrates with a specific technology (like a web framework or a type of database). See Integrations. interaction In our mobile monitoring, an interaction is a specific code path initiated by a user interaction (usually a button press). An interaction is the mobile equivalent of a transaction, and like a transaction an interaction can be traced and monitored. You can see much of the data included in an interaction in the BrowserInteraction event. interaction trace An interaction trace is a complete picture of a single interaction. With interaction traces, New Relic gives you much deeper visibility into a single slow interaction, which can help you understand a broader problem. Interaction traces are the mobile equivalent of a transaction trace. For more information, see Creating interactions (iOS) and Creating interactions (Android). inventory data Inventory data is information about the status or configuration of a service or host. Examples of inventory data include: Configuration settings Name of the host the service is on Amazon AWS region Port being used For more information, see Understand and use data. key transaction A web transaction that the user has marked as particularly important; for example, key business events (such as signups or purchase confirmations), or transactions with a high performance impact (such as searches). Key transactions have their own pages in the UI and other customized values. For more information, see Key transactions. launcher A launcher is a specific piece of code you can include when you create a New Relic One app. It creates the tile on the homepage that you click to launch the app. For more information, see the documentation about core UI components. log A log is a message about a system used to understand the activity of the system and to diagnose problems. For more information on how we use log data, see Log management. Log monitoring Our log management and monitoring features give you the tools to collect, process, explore, visualize, and alert on your log data using your existing log forwarder. With all of your log data in one place, you'll be able to make better decisions, detect and resolve problems more quickly, and see your logs in context to troubleshoot faster. Logs Our Logs feature is a scalable log management platform that allows you to connect your log data with the rest of your telemetry data. Pre-built plugins with some of the most common open-source logging tools make it simple to send your data from anywhere to New Relic. Logs in context Logs in context makes it easy to link to your log data with related data across the rest of our platform. Bringing all of this data together in a single tool allows you to quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. master account See parent account. metric A metric is a numeric measurement. Metric data is a broad category because there are several ways to make and report measurements. For more about how metrics are reported at New Relic, see New Relic data types. metric timeslice New Relic reports metrics in several ways. One variety of metric data is called metric timeslice data; this is the type of data used to generate many of the charts in APM, mobile monitoring, and browser monitoring (for more details, see metric timeslice data). Over time, metric timeslice data is aggregated into longer timeslice data records for more efficient storage. For more about how we aggregate this type of data, see Data aggregation. For how to query this type of data, see Query metric timeslice data. metric grouping issue A metric grouping issue occurs when an account sends too many differently named metric timeslice data points to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. For more information, see Metric grouping issues. minion The software that accepts monitor jobs from a private location. A minion is a packaged virtual appliance that runs in your hypervisor. For more information, see Private locations overview and install and configure private minions. Mobile monitoring Mobile monitoring allows you to monitor and manage the performance of your mobile apps on Android, iOS, tvOS, and other systems. Mobile monitoring provides end-to-end details, including crashes, throughput, HTTP requests, error traces, and more. Not to be confused with New Relic's own mobile apps for Android, iPhone, and iPad. monitor For our Synthetic Monitoring, a monitor ensures your website or API endpoint is available. For more information, see Adding and editing monitors. NerdGraph NerdGraph is our GraphQL API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time and enables powerful developer tools. You can use our NerdGraph GraphiQL explorer to explore the schema and find definitions. With valid New Relic API key, you can try it out yourself at api.newrelic.com/graphiql. Nerdlet A Nerdlet is a component of a New Relic One application. It's a specific UI view, represented by a React JavaScript package. For more information, see Nerdpack file structure. Nerdpack A Nerdpack is a component of a New Relic One application. It's the package containing all the files needed by that application. For more information, see Nerdpack file structure. New Relic Edge with Infinite Tracing New Relic Edge with Infinite Tracing is a fully managed, distributed tracing service that observes 100% of your application traces, then provides actionable data so you can solve issues faster. For more information, see /docs/understand-dependencies/distributed-tracing/get-started/how-new-relic-distributed-tracing-works. New Relic One For more information, see Introduction to New Relic One. New Relic One catalog Our catalog is a collection of applications built on the New Relic One platform. The catalog includes custom apps we've built, public open source apps, and any apps that you buid. You can browse the catalog on New Relic One. NRQL (New Relic query language) NRQL is a query language, similar in form to SQL, that allows you to query the data stored in your New Relic account. non-web transaction APM identifies transactions as either web or non-web. When New Relic does not detect a transaction was initiated by a web request, this is called a non-web transaction. For more information, see Background processes and other non-web transactions. notification The message sent when an incident opens, is acknowledged, or closes. The type of notification is defined by the alert policy's notification channel. For an explanation of how notifications relate to other basic alerts concepts, see Concepts and workflow. notification channel Where we send a notification when an incident opens, is acknowledged, or closes. Available channels include email, mobile push notifications, webhooks, and more. on-host integration On-host integrations refer to integrations that reside on your own servers or hosts and that communicate with our infrastructure agent. For more information, see Introduction to on-host integrations. owner For accounts on our original pricing plan, this is a type of user role: the user who initially created the account. For more information, see Users. page load timing With page load timing, New Relic monitors the full load time for end-user browsers. New Relic's application agents dynamically inject JavaScript into the page, then capture the following key load points: Navigation start: The user initiates the transaction. First byte: The browser receives the requested page. DOM ready: The browser has finished parsing DOM. Page ready: Page loading is complete. Page load timing is sometimes referred to as RUM, or real user monitoring. Unlike standard RUM, page load timing also captures JavaScript errors and AJAX requests. For more information, see Page load timing process. parameter Deprecated term; see attribute. parent account New Relic organizations can have a parent/child account structure. This structure was much more important for organizations on our original user model, but is still used for some features for organizations on the New Relic One user model. Learn more about account structure. Parent accounts were previously referred to as \"master accounts\", and child accounts were previously referred to as \"sub-accounts\". permalink A unique URL that links to a view of your application at a specific point in time. Permalinks are useful for troubleshooting and for sharing interesting time windows with colleagues. pinger The component of New Relic that connects to your website to verify your website is accessible. New Relic has pingers in Europe, Asia, and the United States. Each pinger attempts to contact your website at least once every two minutes. If enough pingers are unable to reach your website, your application will be considered down. For in-depth scriptable testing, including real browser tests and tests of API endpoints, see Synthetic Monitoring. Synthetic Monitoring includes free ping monitoring, which allows you to monitor your website from locations around the world. For more information, see Types of Synthetic monitors. Plugins Plugins provides an open platform to monitor critical information about your entire stack. New Relic partners, PaAS and SaAS providers, third-party vendors, and plugin users can: Quickly install and use publicly available plugins in Plugin Central. Develop your own plugin agents to collect the metric data that matters most to your business. Publish your plugins for public or private access. polling interval (AWS) Our Amazon integrations query your AWS services according to a polling interval, which varies depending on the integration. Each polling interval occurs for every AWS entity. For example, if you have thirteen Elastic Load Balancers (ELB), each one will be polled every five minutes. Depending on the AWS integration, there may be delays in the timing between the API request and the metric data returned. If you notice unusual delays, follow the integration troubleshooting procedures. PPM (pages per minute) The number of pages per minute your application serves. private location A Synthetic monitor feature that allows you to run Synthetic monitors from within your own systems by creating private minions. Private locations allow you to extend your Synthetic coverage to new geographical locations, and to monitor websites behind your firewall such as an intranet site. For more information, see Private locations overview. recovery period A recovery period of time begins when a data source enters a non-violating state after being in a violating state. The recovery period is set in the condition's threshold. A violation will close when a source remains in a non-violating state and the recovery period time has elapsed. If the data source enters a violating state before the time has elapsed, the recovery period clock will reset and the violation won't close. response time The duration of time between a request for service and a response. For more information, see Response time. restricted user A type of user role on a New Relic account. For more information, see Users. rollup Using the same application name for multiple applications. This allows you to combine data in APM, either from multiple applications, or from multiple instances of an application. For more information, see Rolling up app data. root span For distributed tracing, the root span is the first span in a trace. In many cases, the root span duration will represent the duration of the entire trace, or be very close to it. However, for more complex, modern systems that use a lot of asynchronous, non-blocking processes, this will not be true. For those systems, the root span’s duration may be significantly less than the duration of the trace. RPM The term RPM usually refers to the number of requests per minute your application receives from users. This is usually the same as CPM (calls per minute). Historically, some New Relic monitoring solutions, like APM and Browser Monitoring, used to contain RPM in the URL; for example, https://rpm.newrelic.com. This language use originally referred to Rails performance management because the first iteration of our product monitored Ruby on Rails applications. We monitor many more languages and systems than Ruby now. RUM (real user monitoring) See page load timing. runbook A runbook contains standard procedures and operations typically used by system administrators, network operations staff, and other personnel to handle outages, alert incidents, and other situations. If your organization stores runbook instructions as URLs, you can link this information to an alerts policy so your personnel has easy access to this information when an incident violates the defined policy thresholds. SAML (Security Assertion Markup Language) SAML is an XML-based data format for sharing authentication data between two parties. New Relic accounts must obtain a SAML certificate in order to enable Single Sign On for their users. For more information, see SAML service providers. Selenium Selenium is an open-source browser testing suite. Synthetics uses Selenium to test monitored websites with real browsers. For more information, see monitor types. service A service is a cluster of runtime server processes that accomplish a particular task, usually service requests. Unlike an application, a service is not usually invoked by a human. New Relic offers a variety of integrations that allow you to report data from your services. signal The stream of telemetry data that's watched and alerted on. You use NRQL queries to define a signal. signal filter When we receive data and it's routed to the streaming alerts platform, your NRQL WHERE clause will filter the data coming in. The filtered streaming data is what's evaluated for loss of signal violations, for example. span In a distributed trace, a span is a \"named, timed operation representing a contiguous segment of work in that trace\" (from OpenTracing.io definition). For distributed tracing, spans are displayed in the distributed tracing UI, and the data type Span is available to be queried. See also root span. SSL certificate SSL certificates encrypt data that is being transmitted. While New Relic refers to security certificates as SSL because it is a more commonly used term, all certificates adhere to industry standards for secure encryption in transit. SSO (single sign on) SSO (single sign on) allows you to manage user authentication in New Relic using an external SSO provider. For more information, see Setting up SSO. streaming algorithm This is what determines when the data in an aggregation window is processed. The streaming algorithm uses your server's clock time and the aggregation window size to trigger the alert evaluation process. sub-accounts See master account. Synthetic monitoring Synthetic monitoring allows you to monitor your website or API endpoint via automated, scriptable tools. Use free ping monitor to ensure your website is accessible, or expand your monitoring with browser monitors, which test your website with real browsers. Go further with scripting, to script browsers or API monitors for sophisticated testing. target A target is a resource or component monitored by a New Relic monitoring tool that has been identified in an alert condition. When the data source for that target crosses the defined critical threshold, we will open a violation. Depending on your policy's Incident preference setting, Alerts may create an incident record and send notifications through the defined channels. See also entity. tag Tags are key:value metadata added to monitored apps, hosts, dashboards, and other entities to help you organize your data at a high level. For details, see Tags. Telemetry Data Platform The collection of features and tools you can use to ingest, visualize, and alert on all your telemetry data in one place. For more information, read the Introduction to the Telemetry Data Platform. thresholds Thresholds are alert condition settings that define a violation. Threshold values include the value a data source must pass to trigger a violation and the time-related settings that define a violation; for example: Passing a certain value for at least x minutes Passing a certain value only once in x minutes While the data source passes a certain value, a degradation period starts. Likewise, when that data source stops passing a certain value, a recovery period starts. The durations of these two time periods are defined in the alert condition threshold settings. Thresholds have a required critical (red) threshold and an optional warning (yellow) threshold. In the UI, the entity's health status indicator will change to yellow or red when a threshold has been crossed and a violation will open. For more information, see Define thresholds. For an explanation of how thresholds relate to other basic Alerts concepts, see Concepts and workflow. throughput Throughput is a measurement of user activity for a monitored application. APM throughput and Browser Monitoring throughput are measured in different ways: APM: requests per minute (RPM) Browser: page views per minute (PPM) tier A tier can refer to how New Relic categorizes or visualizes the various agent language ecosystems that we support. For example: In APM, the color-coded categories that appear on your app's main Overview chart show response time spent in various functions, processes, or agents as tiers; for example, request queuing, garbage collection, Middleware, JVMs, etc. In New Relic labels, TIER can be used to define or classify the client-server architecture; for example, front-end and back-end tiers. \"Tier\" may sometimes be used to refer to our Full Stack Observability pricing editions. time picker By default the New Relic UI shows data for the past 30 minutes, ending now. To change the time window, use the time picker. time range A time range can refer to a length of time selected in the New Relic UI. New Relic displays a time range depending on the range you select using the time picker. timeslice data See metric timeslice data. trace A trace is a description of how a request travels through a system. Trace data helps you understand the performance of your system and diagnose problems. For more information on how we use trace data, see New Relic data types. traffic light See health status. transaction A transaction is defined as one logical unit of work in an application. This term primarily refers to server-side transactions monitored by APM. For more information, see documentation about web transactions and non-web transactions. The term transaction is also sometimes used in Browser Monitoring. In that case, it primarily refers to activity beginning with a browser-side web request and ending with a complete page load. transaction trace A transaction trace is a complete picture of a single transaction, down to the database queries and exact invocation patterns. With transaction traces, New Relic gives you much deeper visibility into a single slow transaction, which can help you understand a broader problem. For more information, see Transaction traces. UI The New Relic user interface. For more information, see Standard page functions. user A user can refer to a specific user role in a New Relic account. For more information, see Users. UTC Universal Time Coordinated (UTC), or Coordinated Universal Time, is a standard timestamp for synchronizing time around the world. value function (metrics) The numeric value obtained from metric timeslice data; for example, an average, minimum, maximum, total, sample size, etc. violation A violation occurs when the entity monitored by an alert condition reports a value that crosses the thresholds defined in that condition. For an explanation of how violations relate to other basic alerts concepts, see Concepts and workflow. You can view a summary of the violations for a selected incident's page. You can also view the violations for a specific entity from the product's UI. web external Web external is the term applied to the portion of time spent in transactions to external applications from within the code of the application you are monitoring. That time can be a call to a third party company (a payment provider, for example) or it could be a call to another microservice within your own company. Web external demonstrates how performance is impacted by your code executing outside the application you are measuring. web transaction A transaction is defined as one logical unit of work in an application. This term primarily refers to server-side transactions monitored by APM. Web transactions are initiated with an HTTP request. For most organizations, these represent customer-centric interactions and thus are the most important transactions to monitor. For more information, see Web transactions and Non-web transactions. WebDriverJS WebDriver is a Selenium component, used to control Synthetics scripted browsers. Specifically, Synthetics uses WebDriverJS, a Node.js-based flavor of Selenium. For more information, see Writing scripted browsers and Scripted browser examples. workload A workload represents a group of entities that work together to provide a digital service. For more information, see Workloads.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.78125,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Mobile</em> <em>monitoring</em>",
        "tags": "<em>Get</em> <em>started</em>",
        "body": " <em>mobile</em> apps on Android, iOS, tvOS, and other systems. <em>Mobile</em> <em>monitoring</em> provides end-to-end details, including crashes, throughput, HTTP requests, error traces, and more. Not to be confused with <em>New</em> <em>Relic</em>&#x27;s own <em>mobile</em> apps for Android, iPhone, and iPad. <em>monitor</em> For our Synthetic <em>Monitoring</em>, a <em>monitor</em>"
      },
      "id": "603eb6f5e7b9d288392a07fc"
    },
    {
      "sections": [
        "Map page for mobile apps (deprecated)",
        "Important",
        "View a map of your mobile app services"
      ],
      "title": "Map page for mobile apps (deprecated)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "a082467948ce481c9ecb544d26a802e8d5f3894b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/map-page-mobile-apps-deprecated/",
      "published_at": "2021-09-14T20:45:24Z",
      "updated_at": "2021-09-14T20:45:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important The mobile Maps UI is deprecated since December 22, 2020. Service maps are available in New Relic One's left navigation for each mobile entity, and they are a better way to visualize and customize representations of your architecture. For more information, see our Explorers Hub post. Maps help you find performance problems for a mobile app or its services. This gives you a clear picture of your app's relationships to other services and the influence of each service on the others. If one service fails, you can see at a glance which other services are affected. View a map of your mobile app services To view your mobile app and its related services as an architectural map, go to one.newrelic.com > Mobile > (select a mobile app) > Monitor > Service map. For more information, see the service maps documentation. If you need to use the deprecated mobile Map page, follow these steps: Go to one.newrelic.com > Mobile > (select an app) > Network > Map. To view HTTP request details for a service, select its name. To view details for an app monitored by APM that is related to the service, select the service's name below the associated hostname. To view throughput details as a chart, select the icon or the cpm bar below the service's name. To view detailed metrics for a service, mouse over the throughput chart. The Map page for mobile monitoring gives an architectural view of your mobile app and the services it uses,",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.540955,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Map page for <em>mobile</em> apps (deprecated)",
        "sections": "Map page for <em>mobile</em> apps (deprecated)",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": "Important The <em>mobile</em> Maps UI is deprecated since December 22, 2020. Service maps are available in <em>New</em> <em>Relic</em> One&#x27;s left navigation for each <em>mobile</em> entity, and they are a better way to visualize and customize representations of your architecture. For more information, see our Explorers Hub post. Maps"
      },
      "id": "6044141828ccbc0f862c60ae"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/api-guides/ios-agent-configuration-feature-flags": [
    {
      "sections": [
        "Retrieve dSYMs for Bitcode apps",
        "Identify missing dSYMs",
        "Download dSYM files using iTunes Connect",
        "Download dSYM files using Xcode's app archive",
        "Upload dSYMs"
      ],
      "title": "Retrieve dSYMs for Bitcode apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "34e375873e36095062eccef6d99f26be7562308f",
      "image": "https://docs.newrelic.com/static/041368cdc60d9252ad80c2c37321b805/ec3e2/screen-dsym2.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/retrieve-dsyms-bitcode-apps/",
      "published_at": "2021-09-14T08:13:27Z",
      "updated_at": "2021-07-09T19:35:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Bitcode is a feature that gives Apple the ability to re-compile iOS and tvOS applications for specific users' hardware. This provides a smaller download size for end users. For more about this process, see Apple's Bitcode and app thinning documentation. When Apple compiles an app, the dSYM files are also compiled. For New Relic to be able to symbolicate crashes of your Bitcode-enabled app, these dSYM files need to be downloaded from Apple and then uploaded to New Relic. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: from the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Download dSYM files using iTunes Connect To download the dSYM files you need for your app: Log in to Apple iTunes Connect. Select My Apps > (selected app) > Activity. From the list of builds for your application, select the build number you need for the dSYM. Select Download dSYM. Then, to upload the resulting zip file directly to New Relic: Follow the instructions to manually upload dSYM, and skip step 1. Unpack one dSYM contained in this zip file to retrieve a build UUID that you can upload. (Follow the last step in the manual upload instructions.) Once New Relic receives the zip file, the build UUIDs for all other dSYMs contained in that zip file will be identified. Download dSYM files using Xcode's app archive Use the app version and build number to identify the applicable app archive in the Xcode Organizer and download the dSYMs. Using Xcode to download dSYMs: From the Archives tab, select the app and version/build, then select Download dSYMs. Open the Xcode Organizer: From the Xcode menu, select Window > Organizer > Archives > (select a mobile app). From Version, select the archive that matches the app version (listed first) and build number (following the app version in parentheses). Select Download dSYMs. The dSYMs will be downloaded from Apple if available and if the file names contain a series of letters and numbers. If the dSYM files are named after the the dependencies in your project, the download will not be successful. Upload dSYMs Once you have located the dSYMs, follow the instructions to upload a dSYM for each zipped dSYM.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.67316,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Identify</em> missing dSYMs",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Bitcode is a feature that gives Apple the ability to re-compile <em>iOS</em> and tv<em>OS</em> applications for specific users&#x27; hardware. This provides a smaller download size for end users. For more about this process, see Apple&#x27;s Bitcode and app thinning documentation. When Apple compiles an app, the dSYM files"
      },
      "id": "6044144228ccbc04a2303885"
    },
    {
      "sections": [
        "iOS and tvOS crash reporting",
        "dSYM files",
        "Debug the crash reporter",
        "Disable crash reporting"
      ],
      "title": "iOS and tvOS crash reporting",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "b2b79e6f9e78f6113bb20032c674996c746e14d4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/ios-tvos-crash-reporting/",
      "published_at": "2021-09-14T14:27:28Z",
      "updated_at": "2021-07-09T18:14:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For agent version 4 or higher, New Relic produces crash reports for your mobile applications. When an iOS or tvOS application crashes, the operating system creates a crash report and stores it on the device. New Relic uploads this report the next time the app launches. Using this report and any relevant dSYM files, the crash report includes the complete stack trace with human-readable information. You can then log into New Relic and see each crash, including the method and line where it crashed, plus device and environment details. dSYM files When you create a release build of an iOS or tvOS application, the names of methods and classes are stripped, leaving only machine-readable memory addresses. When the application crashes, the stack trace consists of this machine-readable code. A dSYM file is an Xcode project file for debug symbols. It contains the debugging symbols that allow for translation of the initial crash report to human-readable information. This process is known as symbolication. New Relic has dynamic framework support for dSYM uploading. If your app uses a dynamic framework with multiple dSYM files, New Relic automatically uploads and uses those files. For more information, see Retrieve and download dSYMs or Upload dSYM files. Debug the crash reporter Crash reporting is enabled by default, but there are some circumstances where it will be disabled: If the debugger is enabled: There can only be one uncaught exception handler registered at a time per application. If running with the debugger attached, New Relic will not capture and report crashes. If another crash reporter is enabled: If another uncaught exception handler is registered after New Relic starts, this error message is logged: The New Relic exception handler has been replaced. This may result in crashes no longer reporting to New Relic. Copy Disable crash reporting To disable New Relic crash reporting, call the following API method: Language Procedure Objective-C Call prior to [NewRelic startWithApplicationToken:...]; [NewRelic disableFeatures:NRFeatureFlag_CrashReporting]; Copy Swift Call prior to NewRelic.start(withApplicationToken:) NewRelic.disableFeatures(NRMAFeatureFlags.NRFeatureFlag_CrashReporting) Copy For more information about this call, see the NewRelic.h file. For more on applicable feature flags, see the NewRelicFeatureFlags.h file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.6604,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> and tvOS crash reporting",
        "sections": "<em>iOS</em> and tvOS crash reporting",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "For agent version 4 or higher, <em>New</em> <em>Relic</em> produces crash reports for your <em>mobile</em> applications. When an <em>iOS</em> or tv<em>OS</em> application crashes, the operating system creates a crash report and stores it on the device. <em>New</em> <em>Relic</em> uploads this report the next time the app launches. Using this report and any"
      },
      "id": "603ec58128ccbc9b51eba7d2"
    },
    {
      "sections": [
        "Enable Swift interaction traces",
        "Enable dynamic method lookup",
        "Enable Swift instrumentation"
      ],
      "title": "Enable Swift interaction traces",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "168467256056a1f7b4410a7112f4bcfe0a93e5ec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/enable-swift-interaction-traces/",
      "published_at": "2021-09-14T08:13:26Z",
      "updated_at": "2021-07-09T09:36:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Dynamic-by-default method lookups for iOS development have been removed with Swift. This interrupts the agent's default method instrumentation. For example, interaction tracing in Swift classes are disabled by default, but you can re-enable them. Interactions in a Swift app are captured if automatically instrumented classes and methods are used or when defining custom interactions. However, if a Swift class creates sub-classes for any of these default classes, follow these steps to capture interactions. Enable dynamic method lookup To re-enable dynamic method lookup on a method-by-method basis in Swift, adding the dynamic declaration modifier. For example: class MyViewController : UIViewController { override dynamic func viewDidLoad() { super.viewDidLoad() ... } } Copy For every function that New Relic automatically instruments, be sure to add this modifier every time you create a sub-class and override in Swift. Enable Swift instrumentation After adding the dynamic keyword to your method overrides, you can re-enable Swift instrumentation by calling the following method: Language Procedure Objective-C Call prior to [NewRelic startWithApplicationToken:...]; [NewRelic enableFeatures:NRFeatureFlag_SwiftInteractionTracing]; Copy Swift Call prior to NewRelic.start(withApplicationToken:) NewRelic.enableFeatures(NRMAFeatureFlags.NRFeatureFlag_SwiftInteractionTracing) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.57883,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Enable Swift <em>interaction</em> traces",
        "sections": "Enable Swift <em>interaction</em> traces",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Dynamic-by-default method lookups for <em>iOS</em> development have been removed with Swift. This interrupts the agent&#x27;s default method instrumentation. For example, interaction tracing in Swift classes are disabled by default, but you can re-enable them. Interactions in a Swift app are captured"
      },
      "id": "603ed6ef64441fa4f14e889d"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/api-guides/ios-sdk-api-guide": [
    {
      "sections": [
        "CocoaPods installation",
        "Install your iOS application",
        "Configure using Objective-C",
        "Important",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "9a062745f628f66e34f865a47d58713f12e59ac9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/cocoapods-installation/",
      "published_at": "2021-09-14T14:28:11Z",
      "updated_at": "2021-07-27T15:09:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply to iOS apps using Cocoapods. For other types, see iOS installation and configuration. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps list, select Add a new app. From the Get Started page, select iOS as the platform for mobile monitoring. Type a name for your mobile app, then select Continue. Continue with the steps to configure New Relic for mobile monitoring. Configure using Objective-C These procedures to configure your iOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your APP_NAME-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: [NewRelic startWithApplicationToken:@\"APP_TOKEN\"]; Copy Important The agent must be on the first line of didFinishLaunchingWithOptions and run on the main thread to ensure proper instrumentation. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Configure using Swift These procedures to configure your iOS app with CocoaPods and Swift also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your APP_NAME-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: NewRelic.start(withApplicationToken:\"APP_TOKEN\") Copy Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling NewRelic.start(withApplicationToken): [NRLogger setLogLevels:NRLogLevelALL]; Copy For Swift apps: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.39992,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods <em>installation</em>",
        "sections": "<em>Install</em> your <em>iOS</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps list, select Add a <em>new</em> app. From the Get Started page, select <em>iOS</em> as the platform for <em>mobile</em> <em>monitoring</em>. Type a name for your <em>mobile</em> app, then select Continue"
      },
      "id": "603ea15d64441fef3d4e8867"
    },
    {
      "sections": [
        "iOS manual installation",
        "Install your iOS application",
        "Add the New Relic framework to your app",
        "Important",
        "Optional: Execute a demo crash",
        "Optional: Change the logging level"
      ],
      "title": "iOS manual installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "0a674eb7f3756cd5d124c6dcf2344edf38e40a8a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/ios-manual-installation/",
      "published_at": "2021-09-14T14:29:01Z",
      "updated_at": "2021-07-27T15:09:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To install and configure New Relic functionality with your iOS applications, follow these procedures. If your iOS app uses Cocoapods, follow the Cocoapods installation procedures. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps index, select Add a new app. From the Get started page, select XCFramework as the platform for mobile monitoring. Type a name for your mobile app, and select Continue. Continue with the steps to configure New Relic. Add the New Relic framework to your app Download and unzip the iOS SDK for New Relic. To add the New Relic framework to your Xcode project: Use Finder to drag the NewRelicAgent.framework folder into your Xcode project, and drop it onto your project in the Project navigator window, under Frameworks, Libraries, and Embedded Content. Make sure Embed & Sign is selected under the Embed dropdown menu. Implement the agent using the appropriate method: Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Language Procedure Objective-C To start the agent: Import the New Relic header at the top of your prefix.pch. Add +[NewRelic startWithApplicationToken:@\"<appToken>\"] to the top of -application:didFinishLaunchingWithOptions: in your AppDelegate.m, using the unique application token that is automatically generated. Swift Create a bridging header file: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. Delete Placeholder.m. Import the New Relic agent by adding #import \"NewRelic/NewRelic.h\" to the top of MyApp-Bridging-Header.h. Add NewRelic.start(withApplicationToken: \">appToken>\") to the top of application(_:didFinishLaunchingWithOptions:) in your AppDelegate.swift using the unique application token that is automatically generated. Add a build script to your target's Build Phases. Ensure the new build script is the very last build phase, then paste the following, replacing PUT_NEW_RELIC_APP_TOKEN_HERE with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, and then run it in the simulator or other device. Optional: Execute a demo crash If you have trouble getting your app to crash, the New Relic agent provides an API to execute a demo crash. Recommendation: Add one of these lines of code to a button click event handler as applicable: Language Code Objective-C Crash: [NewRelic crashNow]; Copy Crash with log message: [NewRelic crashNow:@\"<reason>\"]; Copy Swift Crash: NewRelic.crashNow() Copy Crash with log message: NewRelic.crashNow(_ message:) Copy Optional: Change the logging level Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add the following method: Language Code Objective-C Just before calling startWithApplicationToken in AppDelegate.m, add: [NRLogger setLogLevels:NRLogLevelALL]; Copy Swift Just before calling start(withApplicationToken:) in AppDelegate.swift, add: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.39992,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> manual <em>installation</em>",
        "sections": "<em>iOS</em> manual <em>installation</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " token. This is a 40-character hexadecimal string for authenticating each <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps index, select Add a <em>new</em> app. From the Get started page, select XCFramework"
      },
      "id": "603ea44864441f80904e8899"
    },
    {
      "sections": [
        "CocoaPods for tvOS installation and configuration",
        "Install your tvOS application",
        "Configure using Objective-C",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods for tvOS installation and configuration",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "dd8c9ed16a980b08c67150dada56e129900202bd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/cocoapods-tvos-installation-configuration/",
      "published_at": "2021-09-14T07:52:30Z",
      "updated_at": "2021-07-21T20:49:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply only to tvOS apps using Cocoapods. For all other types of tvOS apps, see tvOS installation and configuration. Install your tvOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: Select Add more data, select XCFramework. From the drawer, select the New Relic account you would like to add your tvOS application to, and select Continue. Type a name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring. Configure using Objective-C These procedures to configure your tvOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your [app_name]-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions: [NewRelicAgent startWithApplicationToken:@\"<appToken>\"]; Copy Add a build script to your target's Build Phases and paste the following, replacing \"PUT_NEW_RELIC_APP_TOKEN_HERE\" with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/bash \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, then run it in the simulator or other device. Within a few minutes you will begin to see data for your app: Go to one.newrelic.com > Mobile > (select an app). Configure using Swift These procedures to configure your tvOS app with CocoaPods and Swift are also available on the Get Started page in the mobile monitoring UI: In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your [ app_name]-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions: NewRelic.startWithApplicationToken(\"<appToken>\"); Copy Add a build script to your target's Build Phases and paste the following, replacing NEW_RELIC_APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/bash \"${SCRIPT}\" NEW_RELIC_APP_TOKEN Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling startWithApplicationToken: [NRLogger setLogLevels:NRLogLevelALL]; Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.621735,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods for tvOS <em>installation</em> and configuration",
        "sections": "CocoaPods for tvOS <em>installation</em> and configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " for authenticating each <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: Select Add more data, select XCFramework. From the drawer, select the <em>New</em> <em>Relic</em> account you would like to add your tv<em>OS</em> application to, and select"
      },
      "id": "60441ac6196a6710e4960f57"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project": [
    {
      "sections": [
        "Retrieve dSYMs for Bitcode apps",
        "Identify missing dSYMs",
        "Download dSYM files using iTunes Connect",
        "Download dSYM files using Xcode's app archive",
        "Upload dSYMs"
      ],
      "title": "Retrieve dSYMs for Bitcode apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "34e375873e36095062eccef6d99f26be7562308f",
      "image": "https://docs.newrelic.com/static/041368cdc60d9252ad80c2c37321b805/ec3e2/screen-dsym2.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/retrieve-dsyms-bitcode-apps/",
      "published_at": "2021-09-14T08:13:27Z",
      "updated_at": "2021-07-09T19:35:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Bitcode is a feature that gives Apple the ability to re-compile iOS and tvOS applications for specific users' hardware. This provides a smaller download size for end users. For more about this process, see Apple's Bitcode and app thinning documentation. When Apple compiles an app, the dSYM files are also compiled. For New Relic to be able to symbolicate crashes of your Bitcode-enabled app, these dSYM files need to be downloaded from Apple and then uploaded to New Relic. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: from the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Download dSYM files using iTunes Connect To download the dSYM files you need for your app: Log in to Apple iTunes Connect. Select My Apps > (selected app) > Activity. From the list of builds for your application, select the build number you need for the dSYM. Select Download dSYM. Then, to upload the resulting zip file directly to New Relic: Follow the instructions to manually upload dSYM, and skip step 1. Unpack one dSYM contained in this zip file to retrieve a build UUID that you can upload. (Follow the last step in the manual upload instructions.) Once New Relic receives the zip file, the build UUIDs for all other dSYMs contained in that zip file will be identified. Download dSYM files using Xcode's app archive Use the app version and build number to identify the applicable app archive in the Xcode Organizer and download the dSYMs. Using Xcode to download dSYMs: From the Archives tab, select the app and version/build, then select Download dSYMs. Open the Xcode Organizer: From the Xcode menu, select Window > Organizer > Archives > (select a mobile app). From Version, select the archive that matches the app version (listed first) and build number (following the app version in parentheses). Select Download dSYMs. The dSYMs will be downloaded from Apple if available and if the file names contain a series of letters and numbers. If the dSYM files are named after the the dependencies in your project, the download will not be successful. Upload dSYMs Once you have located the dSYMs, follow the instructions to upload a dSYM for each zipped dSYM.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.67316,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Identify</em> missing dSYMs",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Bitcode is a feature that gives Apple the ability to re-compile <em>iOS</em> and tv<em>OS</em> applications for specific users&#x27; hardware. This provides a smaller download size for end users. For more about this process, see Apple&#x27;s Bitcode and app thinning documentation. When Apple compiles an app, the dSYM files"
      },
      "id": "6044144228ccbc04a2303885"
    },
    {
      "sections": [
        "iOS and tvOS crash reporting",
        "dSYM files",
        "Debug the crash reporter",
        "Disable crash reporting"
      ],
      "title": "iOS and tvOS crash reporting",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "b2b79e6f9e78f6113bb20032c674996c746e14d4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/ios-tvos-crash-reporting/",
      "published_at": "2021-09-14T14:27:28Z",
      "updated_at": "2021-07-09T18:14:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For agent version 4 or higher, New Relic produces crash reports for your mobile applications. When an iOS or tvOS application crashes, the operating system creates a crash report and stores it on the device. New Relic uploads this report the next time the app launches. Using this report and any relevant dSYM files, the crash report includes the complete stack trace with human-readable information. You can then log into New Relic and see each crash, including the method and line where it crashed, plus device and environment details. dSYM files When you create a release build of an iOS or tvOS application, the names of methods and classes are stripped, leaving only machine-readable memory addresses. When the application crashes, the stack trace consists of this machine-readable code. A dSYM file is an Xcode project file for debug symbols. It contains the debugging symbols that allow for translation of the initial crash report to human-readable information. This process is known as symbolication. New Relic has dynamic framework support for dSYM uploading. If your app uses a dynamic framework with multiple dSYM files, New Relic automatically uploads and uses those files. For more information, see Retrieve and download dSYMs or Upload dSYM files. Debug the crash reporter Crash reporting is enabled by default, but there are some circumstances where it will be disabled: If the debugger is enabled: There can only be one uncaught exception handler registered at a time per application. If running with the debugger attached, New Relic will not capture and report crashes. If another crash reporter is enabled: If another uncaught exception handler is registered after New Relic starts, this error message is logged: The New Relic exception handler has been replaced. This may result in crashes no longer reporting to New Relic. Copy Disable crash reporting To disable New Relic crash reporting, call the following API method: Language Procedure Objective-C Call prior to [NewRelic startWithApplicationToken:...]; [NewRelic disableFeatures:NRFeatureFlag_CrashReporting]; Copy Swift Call prior to NewRelic.start(withApplicationToken:) NewRelic.disableFeatures(NRMAFeatureFlags.NRFeatureFlag_CrashReporting) Copy For more information about this call, see the NewRelic.h file. For more on applicable feature flags, see the NewRelicFeatureFlags.h file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.6604,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> and tvOS crash reporting",
        "sections": "<em>iOS</em> and tvOS crash reporting",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "For agent version 4 or higher, <em>New</em> <em>Relic</em> produces crash reports for your <em>mobile</em> applications. When an <em>iOS</em> or tv<em>OS</em> application crashes, the operating system creates a crash report and stores it on the device. <em>New</em> <em>Relic</em> uploads this report the next time the app launches. Using this report and any"
      },
      "id": "603ec58128ccbc9b51eba7d2"
    },
    {
      "sections": [
        "iOS agent configuration and feature flags",
        "Enable or disable feature flags",
        "Crash and error reporting feature flag",
        "NRFeatureFlag_CrashReporting",
        "NRFeatureFlag_HandledExceptionEvents",
        "Distributed tracing",
        "NRFeatureFlag_DistributedTracing",
        "Interactions feature flags",
        "NRFeatureFlag_DefaultInteractions",
        "NRFeatureFlag_InteractionTracing",
        "NRFeatureFlag_SwiftInteractionTracing",
        "Caution",
        "Networking feature flags",
        "NRFeatureFlag_ExperimentalNetworkingInstrumentation",
        "NRFeatureFlag_NSURLSessionInstrumentation",
        "NRFeatureFlag_NetworkRequestEvents",
        "NRFeatureFlag_RequestErrorEvents",
        "NRFeatureFlag_HttpResponseBodyCapture"
      ],
      "title": "iOS agent configuration and feature flags",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "8ced2dac1fbc45a65d6cdca6b27a4db001d6a4db",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/api-guides/ios-agent-configuration-feature-flags/",
      "published_at": "2021-09-14T08:11:52Z",
      "updated_at": "2021-07-09T14:31:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's iOS agent provides configuration settings to change the default behavior of the agent. If used, implement these flags just before calling: Objective-C: +[NewRelic startWithApplicationToken:] Swift: NewRelic.start(withApplicationToken:) Enable or disable feature flags To configure feature flags, use the following method defined in NewRelic.h: iOS language Procedure Objective-C In Objective-C, these features are bitmasked, so you can use a | to enable or disable multiple features at the same time. Enable a feature flag: +[NewRelic enableFeatures:(NRMAFeatureFlags)flags]; Copy Disable a feature flag: +[NewRelic disableFeatures:(NRMAFeatureFlags)flags]; Copy Here is an example where: Interaction tracing and experimental networking instrumentation are enabled. NSURLSession instrumentation and crash reporting are disabled. [NewRelic enableFeatures:NRFeatureFlag_SwiftInteractionTracing | NRFeatureFlag_ExperimentalNetworkingInstrumentation]; [NewRelic disableFeatures:NRFeatureFlag_NSURLSessionInstrumentation | NRFeatureFlag_CrashReporting]; [NewRelic startWithApplicationToken:...]; Copy Swift Enable a feature flag: NewRelic.enableFeatures(NRMAFeatureFlags.[NRMAFeatureFlag]) Copy Disable a feature flag: NewRelic.disableFeatures(NRMAFeatureFlags.[NRMAFeatureFlag]) Copy Example to disable interaction tracing: NewRelic.disableFeatures(NRMAFeatureFlags.NRFeatureFlag_DefaultInteractions) Copy Crash and error reporting feature flag If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_CrashReporting Enable (default) or disable crash reporting, which appears on the Crash analysis page. Type Boolean Default true NRFeatureFlag_HandledExceptionEvents Globally enable (default) or disable recording handled exceptions events, which appear on the Handled exception page. Type Boolean Default true Distributed tracing NRFeatureFlag_DistributedTracing Enable or disable the adding of distributed tracing headers to network requests. Refer to How New Relic distributed tracing works for more information on distributed tracing in mobile apps. Type Boolean Default true Interactions feature flags If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_DefaultInteractions Enable (default) or disable interaction tracing only for default instrumented classes and methods. Custom interactions will be reported. The traces will appear on the Interactions page. Type Boolean Default true NRFeatureFlag_InteractionTracing Globally enable (default) or disable interaction traces, which appear on the Interactions page. Interaction tracing will be disabled after the agent has started. Interactions for any activity or methods executed prior to starting the agent may still appear on the Interactions page. Type Boolean Default true NRFeatureFlag_SwiftInteractionTracing Caution Before enabling this feature, see Enable Swift interaction traces. If proper steps are not taken, enabling this feature may cause instability. Enable or disable (default) interaction tracing for Swift code. The traces appear on the Interactions page. This feature will always be disabled if NRFeatureFlag_InteractionTracing is disabled. Type Boolean Default false Networking feature flags If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_ExperimentalNetworkingInstrumentation Caution Enabling this feature flag call may decrease the stability of applications. Avoid using unless instructed by New Relic. Enable or disable (default) experimental networking instrumentation. This forces all NSURLConnection network requests through the NRMAURProtocol. Type Boolean Default false NRFeatureFlag_NSURLSessionInstrumentation Enable (default) or disable networking instrumentation for NSURLSession. These URL traces are sent to the HTTP Requests page. Type Boolean Default true NRFeatureFlag_NetworkRequestEvents Enable or disable (default) networking instrumentation. This sends the HTTP response data as MobileRequest events. Available for iOS Agent version 5.14.0 and higher Type Boolean Default true - Enabled by default as of 6.0.0 NRFeatureFlag_RequestErrorEvents Enable (default) or disable HTTP request error event generation of instrumented network calls that result in an error or failure. These events are reported as MobileRequestError events. Available for iOS Agent version 5.11.0 and higher Type Boolean Default true NRFeatureFlag_HttpResponseBodyCapture Enable or disable capture of HTTP response bodies for HTTP error traces, and MobileRequestError events. Type Boolean Default true",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.62509,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> agent <em>configuration</em> and feature flags",
        "sections": "<em>iOS</em> agent <em>configuration</em> and feature flags",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> agent provides <em>configuration</em> settings to change the default behavior of the agent. If used, implement these flags just before calling: Objective-C: +[<em>NewRelic</em> startWithApplicationToken:] Swift: <em>NewRelic</em>.start(withApplicationToken:) Enable or disable feature flags To configure"
      },
      "id": "60441925196a67324d960f1b"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/configuration/enable-swift-interaction-traces": [
    {
      "sections": [
        "Retrieve dSYMs for Bitcode apps",
        "Identify missing dSYMs",
        "Download dSYM files using iTunes Connect",
        "Download dSYM files using Xcode's app archive",
        "Upload dSYMs"
      ],
      "title": "Retrieve dSYMs for Bitcode apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "34e375873e36095062eccef6d99f26be7562308f",
      "image": "https://docs.newrelic.com/static/041368cdc60d9252ad80c2c37321b805/ec3e2/screen-dsym2.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/retrieve-dsyms-bitcode-apps/",
      "published_at": "2021-09-14T08:13:27Z",
      "updated_at": "2021-07-09T19:35:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Bitcode is a feature that gives Apple the ability to re-compile iOS and tvOS applications for specific users' hardware. This provides a smaller download size for end users. For more about this process, see Apple's Bitcode and app thinning documentation. When Apple compiles an app, the dSYM files are also compiled. For New Relic to be able to symbolicate crashes of your Bitcode-enabled app, these dSYM files need to be downloaded from Apple and then uploaded to New Relic. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: from the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Download dSYM files using iTunes Connect To download the dSYM files you need for your app: Log in to Apple iTunes Connect. Select My Apps > (selected app) > Activity. From the list of builds for your application, select the build number you need for the dSYM. Select Download dSYM. Then, to upload the resulting zip file directly to New Relic: Follow the instructions to manually upload dSYM, and skip step 1. Unpack one dSYM contained in this zip file to retrieve a build UUID that you can upload. (Follow the last step in the manual upload instructions.) Once New Relic receives the zip file, the build UUIDs for all other dSYMs contained in that zip file will be identified. Download dSYM files using Xcode's app archive Use the app version and build number to identify the applicable app archive in the Xcode Organizer and download the dSYMs. Using Xcode to download dSYMs: From the Archives tab, select the app and version/build, then select Download dSYMs. Open the Xcode Organizer: From the Xcode menu, select Window > Organizer > Archives > (select a mobile app). From Version, select the archive that matches the app version (listed first) and build number (following the app version in parentheses). Select Download dSYMs. The dSYMs will be downloaded from Apple if available and if the file names contain a series of letters and numbers. If the dSYM files are named after the the dependencies in your project, the download will not be successful. Upload dSYMs Once you have located the dSYMs, follow the instructions to upload a dSYM for each zipped dSYM.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.67316,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Identify</em> missing dSYMs",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Bitcode is a feature that gives Apple the ability to re-compile <em>iOS</em> and tv<em>OS</em> applications for specific users&#x27; hardware. This provides a smaller download size for end users. For more about this process, see Apple&#x27;s Bitcode and app thinning documentation. When Apple compiles an app, the dSYM files"
      },
      "id": "6044144228ccbc04a2303885"
    },
    {
      "sections": [
        "iOS and tvOS crash reporting",
        "dSYM files",
        "Debug the crash reporter",
        "Disable crash reporting"
      ],
      "title": "iOS and tvOS crash reporting",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "b2b79e6f9e78f6113bb20032c674996c746e14d4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/ios-tvos-crash-reporting/",
      "published_at": "2021-09-14T14:27:28Z",
      "updated_at": "2021-07-09T18:14:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For agent version 4 or higher, New Relic produces crash reports for your mobile applications. When an iOS or tvOS application crashes, the operating system creates a crash report and stores it on the device. New Relic uploads this report the next time the app launches. Using this report and any relevant dSYM files, the crash report includes the complete stack trace with human-readable information. You can then log into New Relic and see each crash, including the method and line where it crashed, plus device and environment details. dSYM files When you create a release build of an iOS or tvOS application, the names of methods and classes are stripped, leaving only machine-readable memory addresses. When the application crashes, the stack trace consists of this machine-readable code. A dSYM file is an Xcode project file for debug symbols. It contains the debugging symbols that allow for translation of the initial crash report to human-readable information. This process is known as symbolication. New Relic has dynamic framework support for dSYM uploading. If your app uses a dynamic framework with multiple dSYM files, New Relic automatically uploads and uses those files. For more information, see Retrieve and download dSYMs or Upload dSYM files. Debug the crash reporter Crash reporting is enabled by default, but there are some circumstances where it will be disabled: If the debugger is enabled: There can only be one uncaught exception handler registered at a time per application. If running with the debugger attached, New Relic will not capture and report crashes. If another crash reporter is enabled: If another uncaught exception handler is registered after New Relic starts, this error message is logged: The New Relic exception handler has been replaced. This may result in crashes no longer reporting to New Relic. Copy Disable crash reporting To disable New Relic crash reporting, call the following API method: Language Procedure Objective-C Call prior to [NewRelic startWithApplicationToken:...]; [NewRelic disableFeatures:NRFeatureFlag_CrashReporting]; Copy Swift Call prior to NewRelic.start(withApplicationToken:) NewRelic.disableFeatures(NRMAFeatureFlags.NRFeatureFlag_CrashReporting) Copy For more information about this call, see the NewRelic.h file. For more on applicable feature flags, see the NewRelicFeatureFlags.h file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.6604,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> and tvOS crash reporting",
        "sections": "<em>iOS</em> and tvOS crash reporting",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "For agent version 4 or higher, <em>New</em> <em>Relic</em> produces crash reports for your <em>mobile</em> applications. When an <em>iOS</em> or tv<em>OS</em> application crashes, the operating system creates a crash report and stores it on the device. <em>New</em> <em>Relic</em> uploads this report the next time the app launches. Using this report and any"
      },
      "id": "603ec58128ccbc9b51eba7d2"
    },
    {
      "sections": [
        "iOS agent configuration and feature flags",
        "Enable or disable feature flags",
        "Crash and error reporting feature flag",
        "NRFeatureFlag_CrashReporting",
        "NRFeatureFlag_HandledExceptionEvents",
        "Distributed tracing",
        "NRFeatureFlag_DistributedTracing",
        "Interactions feature flags",
        "NRFeatureFlag_DefaultInteractions",
        "NRFeatureFlag_InteractionTracing",
        "NRFeatureFlag_SwiftInteractionTracing",
        "Caution",
        "Networking feature flags",
        "NRFeatureFlag_ExperimentalNetworkingInstrumentation",
        "NRFeatureFlag_NSURLSessionInstrumentation",
        "NRFeatureFlag_NetworkRequestEvents",
        "NRFeatureFlag_RequestErrorEvents",
        "NRFeatureFlag_HttpResponseBodyCapture"
      ],
      "title": "iOS agent configuration and feature flags",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "8ced2dac1fbc45a65d6cdca6b27a4db001d6a4db",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/api-guides/ios-agent-configuration-feature-flags/",
      "published_at": "2021-09-14T08:11:52Z",
      "updated_at": "2021-07-09T14:31:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's iOS agent provides configuration settings to change the default behavior of the agent. If used, implement these flags just before calling: Objective-C: +[NewRelic startWithApplicationToken:] Swift: NewRelic.start(withApplicationToken:) Enable or disable feature flags To configure feature flags, use the following method defined in NewRelic.h: iOS language Procedure Objective-C In Objective-C, these features are bitmasked, so you can use a | to enable or disable multiple features at the same time. Enable a feature flag: +[NewRelic enableFeatures:(NRMAFeatureFlags)flags]; Copy Disable a feature flag: +[NewRelic disableFeatures:(NRMAFeatureFlags)flags]; Copy Here is an example where: Interaction tracing and experimental networking instrumentation are enabled. NSURLSession instrumentation and crash reporting are disabled. [NewRelic enableFeatures:NRFeatureFlag_SwiftInteractionTracing | NRFeatureFlag_ExperimentalNetworkingInstrumentation]; [NewRelic disableFeatures:NRFeatureFlag_NSURLSessionInstrumentation | NRFeatureFlag_CrashReporting]; [NewRelic startWithApplicationToken:...]; Copy Swift Enable a feature flag: NewRelic.enableFeatures(NRMAFeatureFlags.[NRMAFeatureFlag]) Copy Disable a feature flag: NewRelic.disableFeatures(NRMAFeatureFlags.[NRMAFeatureFlag]) Copy Example to disable interaction tracing: NewRelic.disableFeatures(NRMAFeatureFlags.NRFeatureFlag_DefaultInteractions) Copy Crash and error reporting feature flag If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_CrashReporting Enable (default) or disable crash reporting, which appears on the Crash analysis page. Type Boolean Default true NRFeatureFlag_HandledExceptionEvents Globally enable (default) or disable recording handled exceptions events, which appear on the Handled exception page. Type Boolean Default true Distributed tracing NRFeatureFlag_DistributedTracing Enable or disable the adding of distributed tracing headers to network requests. Refer to How New Relic distributed tracing works for more information on distributed tracing in mobile apps. Type Boolean Default true Interactions feature flags If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_DefaultInteractions Enable (default) or disable interaction tracing only for default instrumented classes and methods. Custom interactions will be reported. The traces will appear on the Interactions page. Type Boolean Default true NRFeatureFlag_InteractionTracing Globally enable (default) or disable interaction traces, which appear on the Interactions page. Interaction tracing will be disabled after the agent has started. Interactions for any activity or methods executed prior to starting the agent may still appear on the Interactions page. Type Boolean Default true NRFeatureFlag_SwiftInteractionTracing Caution Before enabling this feature, see Enable Swift interaction traces. If proper steps are not taken, enabling this feature may cause instability. Enable or disable (default) interaction tracing for Swift code. The traces appear on the Interactions page. This feature will always be disabled if NRFeatureFlag_InteractionTracing is disabled. Type Boolean Default false Networking feature flags If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_ExperimentalNetworkingInstrumentation Caution Enabling this feature flag call may decrease the stability of applications. Avoid using unless instructed by New Relic. Enable or disable (default) experimental networking instrumentation. This forces all NSURLConnection network requests through the NRMAURProtocol. Type Boolean Default false NRFeatureFlag_NSURLSessionInstrumentation Enable (default) or disable networking instrumentation for NSURLSession. These URL traces are sent to the HTTP Requests page. Type Boolean Default true NRFeatureFlag_NetworkRequestEvents Enable or disable (default) networking instrumentation. This sends the HTTP response data as MobileRequest events. Available for iOS Agent version 5.14.0 and higher Type Boolean Default true - Enabled by default as of 6.0.0 NRFeatureFlag_RequestErrorEvents Enable (default) or disable HTTP request error event generation of instrumented network calls that result in an error or failure. These events are reported as MobileRequestError events. Available for iOS Agent version 5.11.0 and higher Type Boolean Default true NRFeatureFlag_HttpResponseBodyCapture Enable or disable capture of HTTP response bodies for HTTP error traces, and MobileRequestError events. Type Boolean Default true",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.62509,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> agent <em>configuration</em> and feature flags",
        "sections": "<em>iOS</em> agent <em>configuration</em> and feature flags",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> agent provides <em>configuration</em> settings to change the default behavior of the agent. If used, implement these flags just before calling: Objective-C: +[<em>NewRelic</em> startWithApplicationToken:] Swift: <em>NewRelic</em>.start(withApplicationToken:) Enable or disable feature flags To configure"
      },
      "id": "60441925196a67324d960f1b"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/configuration/ios-device-id-obfuscation": [
    {
      "sections": [
        "Introduction to iOS mobile app",
        "Features",
        "Time range",
        "Synthetic monitoring",
        "Alerts",
        "Mobile monitoring",
        "Data privacy"
      ],
      "title": "Introduction to iOS mobile app",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "iOS app"
      ],
      "external_id": "371077582a50dfd2a1e7c57cfbbf9eeaf8013e1c",
      "image": "https://docs.newrelic.com/static/630c7a9a486540073ab96a2c9926e303/442cb/device-ios-synthetics-view-monitor.png",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/ios-app/introduction-ios-mobile-app/",
      "published_at": "2021-09-14T07:29:48Z",
      "updated_at": "2021-09-14T07:29:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The user interface for New Relic's iPhone and iPad app provides functionality similar to New Relic's standard user interface, with customized details for mobile users. The New Relic iOS apps show near real-time information about your apps, hosts, and more. Features New Relic's iOS app includes these New Relic products and features: New Relic's iOS app for iPhone and iPad includes these New Relic products and features: APM (iPhone and iPad). Includes real-time and historical data. Select the icon to see transaction details. Select Overview Charts to view summary charts of your top five transactions. Browser monitoring (iPhone and iPad). Provide overview dashboard, including average page load time, browser Apdex, average throughput, and more. Infrastructure monitoring (iPhone only). Alerts (iPhone and iPad). Get alert and deployment notifications. Synthetic monitoring (iPhone only). Mobile monitoring (iPhone and iPad). Includes crash reports, network errors, API calls, and active user count. New Relic's iOS app does not have all the features of the New Relic web application. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the clock icon in the top right of the page. This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth across the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). For iPads: to specify an end time other than now, slide the toggle from Ending Now to Custom Date. Synthetic monitoring You can use the iOS app to view your synthetic monitoring data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you connect the iOS app to your New Relic account, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For iOS alerts, notifications appear on your lock screen and can be viewed by swiping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile monitoring If you have a mobile application and have installed mobile monitoring, you can monitor its performance directly from your iPhone or iPad. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. Data privacy New Relic's mobile apps only record information needed to help authenticate and troubleshoot: User's email address associated with your New Relic account, including first and last name (for authentication purposes only) IP address Device ID For more information, see our Mobile data privacy and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 326.2741,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> mobile app",
        "sections": "<em>Introduction</em> to <em>iOS</em> mobile app",
        "tags": "<em>iOS</em> app",
        "body": " times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you connect the <em>iOS</em> app to your New Relic account, your <em>device</em>"
      },
      "id": "6044161628ccbc96b62c6092"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/attribute-dictionary/",
      "sections": [
        "New Relic data dictionary",
        "AjaxRequest",
        "AwsLambdaInvocation",
        "AwsLambdaInvocationError",
        "BrowserInteraction",
        "BrowserTiming",
        "ContainerSample",
        "DistributedTraceSummary",
        "InfrastructureEvent",
        "JavaScriptError",
        "Metric",
        "Mobile",
        "MobileCrash",
        "MobileHandledException",
        "MobileRequest",
        "MobileRequestError",
        "MobileSession",
        "NetworkSample",
        "NrAiIncident",
        "NrAuditEvent",
        "NrConsumption",
        "NrDailyUsage",
        "NrIntegrationError",
        "NrMTDConsumption",
        "NrUsage",
        "PageAction",
        "PageView",
        "PageViewTiming",
        "ProcessSample",
        "Span",
        "StorageSample",
        "SyntheticCheck",
        "SyntheticRequest",
        "SyntheticsPrivateLocationStatus",
        "SyntheticsPrivateMinion",
        "SystemSample",
        "Transaction",
        "TransactionError",
        "WorkloadStatus"
      ],
      "published_at": "2021-09-14T11:24:53Z",
      "title": "New Relic data dictionary",
      "updated_at": "2021-09-14T11:24:52Z",
      "type": "docs",
      "external_id": "cbca3a897621bcbb31159067d6d4ec27c5178fe4",
      "document_type": "views_page_content",
      "popularity": 1,
      "body": "AjaxRequest Data source : Browser agent An AjaxRequest event is created automatically when an Ajax request occurs during a BrowserInteraction event. The event attributes track geographic and browser info. Attribute name Definition Data types appId ID The ID of your application, as recorded by New Relic. AjaxRequest BrowserTiming BrowserInteraction PageAction PageView PageViewTiming appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError browserInteractionName The name of the interaction. This is either the targetGroupedUrl or the custom name set via the API. AjaxRequest BrowserTiming BrowserInteraction city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageView eventId ID A value that you can link to multiple BrowserInteraction events so you can view the interactions that occurred surrounding a specific event. For example, you can see the browser interactions that occurred prior to a JS error. AjaxRequest BrowserTiming BrowserInteraction groupedPageURL The grouped URL of the view that made the AJAX request. For example: myapp.com/acct/*/dash. AjaxRequest BrowserTiming groupedRequestUrl The grouped URL of the AJAX request. For example: myapp.com/acct/*/ajax. AjaxRequest Span hostname The fully qualified domain name (FQDN) of the request URL. AjaxRequest httpMethod enum The HTTP method of the AJAX request. Example: POST. AjaxRequest httpResponseCode enum The HTTP response code. Example: 200. AjaxRequest jsDuration seconds (s) The total duration, in seconds, spent on JavaScript execution. (This attribute doesn't exist for initial page load events.) AjaxRequest BrowserTiming BrowserInteraction pageUrl The URL of the page that was loaded for the PageView. For example: http://www.newrelic.com. This URL does not include query parameters. AjaxRequest BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError port enum The request port. AjaxRequest Span priority Likelihood this event will be saved. AjaxRequest regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming requestBodySize bytes (B) The payload size of the request body, in bytes. AjaxRequest requestUrl The URL of the AJAX request. For example: myapp.com/acct/1/ajax. AjaxRequest responseBodySize bytes (B) The payload size of the response body, in bytes. AjaxRequest session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming Span timeSinceBrowserInteractionStart seconds (s) The time in seconds between the start of the BrowserInteraction and the start of the request. AjaxRequest BrowserTiming timeToLastCallbackEnd seconds (s) The duration, in seconds, from the start of the request (timestamp) to the end of the last callback. This is not just an additive function; the callback time can overlap with the wait time. AjaxRequest BrowserTiming timeToLoadEventStart seconds (s) The time, in seconds, from the start of the AJAX request to the start of its load event. This value represents the duration of the AJAX request with single page app (SPA) monitoring. For more information, see the Mozilla developer documentation about XMLHttpRequest load events. AjaxRequest timeToSettle seconds (s) The time, in seconds, from the start of the request to when all resulting callbacks (including callbacks of subsequent AJAX requests) are complete. AjaxRequest BrowserTiming timestamp The time (date, hour, minute, second) at which the interaction occurred. AjaxRequest BrowserTiming BrowserInteraction PageAction PageView PageViewTiming Span userAgentName The browser’s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming userAgentOS The browser’s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browser’s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming AwsLambdaInvocation Data source : AWS Lambda This event is reported by New Relic monitoring for AWS Lambda. This event captures overall function timing and associated metadata. A single AwsLambdaInvocation event is generated for each invocation. Attribute name Definition Data types aws.lambda.arn The Amazon Resource Name (ARN) of the instrumented Lambda function. AwsLambdaInvocation AwsLambdaInvocationError aws.lambda.coldStart A Boolean indicating if the AWS Lambda invocation is a cold start. AwsLambdaInvocation AwsLambdaInvocationError aws.lambda.eventSource.arn The Amazon Resource Name (ARN) of the entity that invoked the instrumented Lambda function. AwsLambdaInvocation AwsLambdaInvocationError aws.requestId ID AWS identifier of the invocation. AwsLambdaInvocation AwsLambdaInvocationError databaseCallCount count The number of database calls made by this transaction. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError databaseDuration seconds (s) The database response time in seconds. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError duration seconds (s) The total invocation time for the transaction, in seconds. (Data source: AWS Lambda) AwsLambdaInvocation AwsLambdaInvocationError externalCallCount count The number of external calls made by this transaction. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError externalDuration seconds (s) The total response time of all external (out-of-process) services, in seconds. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError newRelic.ingestPoint Where the data point entered the platform (such as browser.spans, or api.traces). AwsLambdaInvocation AwsLambdaInvocationError Span parent.account ID If a distributed tracing payload is received, this is the account identifier for the transaction's upstream caller. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.app ID If a distributed tracing payload is received, this is the application identifier. APM agents retrieve this value in the connect response under the key primary_application_id. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.transportType When a distributed tracing payload is received, the method of transport for the payload. Example values: Unknown, HTTP, HTTPS, Kafka, JMS, IronMQ, AMQP, Queue, or Other. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.type If a distributed trace payload was received, the parent's data source type. Example values: App, Browser, Mobile. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.accept The types as read from the HTTP Accept request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.contentLength bytes (B) Incoming request size in bytes as read from the Content-Length HTTP request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.contentType Incoming request content-type as read from the HTTP request header Content-Type. Example value: application/octet-stream. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.host The name from the HTTP host request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.referer The incoming request referer as read from the Referer request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.userAgent The contents of the User-Agent HTTP header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.method The HTTP request method used. Example values: POST, GET. AwsLambdaInvocation AwsLambdaInvocationError Span Transaction TransactionError response.headers.contentLength bytes (B) The outgoing response size in bytes as read from the Content-Length response header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError response.headers.contentType For an HTTP response, the data type of the returned response. Example values: text/html, application/json. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError response.status bytes (B) The response code for an HTTP request AwsLambdaInvocation totalTime seconds (s) The sum of all async components' duration, in seconds. An async component is a method or function where there is no instrumented encapsulating method or function. AwsLambdaInvocation Transaction traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocation AwsLambdaInvocationError MobileRequest MobileRequestError Span type The New Relic event type. Example values: Transaction, Span. AwsLambdaInvocation AwsLambdaInvocationError AwsLambdaInvocationError Data source : AWS Lambda This event is reported by New Relic monitoring for AWS Lambda. It's generated when an error occurs during a Lambda function invocation. Attribute name Definition Data types aws.lambda.arn The Amazon Resource Name (ARN) of the instrumented Lambda function. AwsLambdaInvocation AwsLambdaInvocationError aws.lambda.coldStart A Boolean indicating if the AWS Lambda invocation is a cold start. AwsLambdaInvocation AwsLambdaInvocationError aws.lambda.eventSource.arn The Amazon Resource Name (ARN) of the entity that invoked the instrumented Lambda function. AwsLambdaInvocation AwsLambdaInvocationError aws.requestId ID AWS identifier of the invocation. AwsLambdaInvocation AwsLambdaInvocationError databaseCallCount count The number of database calls made by this transaction. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError databaseDuration seconds (s) The database response time in seconds. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError duration seconds (s) The total invocation time for the transaction, in seconds. (Data source: AWS Lambda) AwsLambdaInvocation AwsLambdaInvocationError error.class The class name or type for the error. This will be server and platform specific. AwsLambdaInvocationError TransactionError error.message The error message for the transaction. This will be server and platform specific. AwsLambdaInvocationError TransactionError externalCallCount count The number of external calls made by this transaction. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError externalDuration seconds (s) The total response time of all external (out-of-process) services, in seconds. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError newRelic.ingestPoint Where the data point entered the platform (such as browser.spans, or api.traces). AwsLambdaInvocation AwsLambdaInvocationError Span parent.account ID If a distributed tracing payload is received, this is the account identifier for the transaction's upstream caller. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.app ID If a distributed tracing payload is received, this is the application identifier. APM agents retrieve this value in the connect response under the key primary_application_id. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.transportType When a distributed tracing payload is received, the method of transport for the payload. Example values: Unknown, HTTP, HTTPS, Kafka, JMS, IronMQ, AMQP, Queue, or Other. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.type If a distributed trace payload was received, the parent's data source type. Example values: App, Browser, Mobile. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.accept The types as read from the HTTP Accept request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.contentLength bytes (B) Incoming request size in bytes as read from the Content-Length HTTP request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.contentType Incoming request content-type as read from the HTTP request header Content-Type. Example value: application/octet-stream. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.host The name from the HTTP host request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.referer The incoming request referer as read from the Referer request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.userAgent The contents of the User-Agent HTTP header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.method The HTTP request method used. Example values: POST, GET. AwsLambdaInvocation AwsLambdaInvocationError Span Transaction TransactionError response.headers.contentLength bytes (B) The outgoing response size in bytes as read from the Content-Length response header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError response.headers.contentType For an HTTP response, the data type of the returned response. Example values: text/html, application/json. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError stackTrace The error stack trace. The format will be different depending on the agent language. AwsLambdaInvocationError traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocation AwsLambdaInvocationError MobileRequest MobileRequestError Span transactionName Name of the transaction in which the error occurred. Example value: Controller/customers/show. Value may be 'Unknown' if an error occurs outside of a transaction. AwsLambdaInvocationError TransactionError type The New Relic event type. Example values: Transaction, Span. AwsLambdaInvocation AwsLambdaInvocationError BrowserInteraction Data source : Browser agent A BrowserInteraction represents a unit of work in a browser session, triggered by a user interacting with the webpage. It captures information about the session, AJAX calls and custom JavaScript timing that occurred as a result of the interaction. Initial load and route changes are captured as special types of browser interactions, and are used for SPA monitoring. Attribute name Definition Data types actionText The text of the HTML element that was clicked when a browser interaction started. BrowserInteraction ajaxCount count A count of all XHRs included in the timing of a SPA interaction. BrowserInteraction appId ID The ID of your application, as recorded by New Relic. AjaxRequest BrowserTiming BrowserInteraction PageAction PageView PageViewTiming appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming backendTransactionName The name of the backend transaction that served the initial page load. BrowserInteraction browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError browserInteractionName The name of the interaction. This is either the targetGroupedUrl or the custom name set via the API. AjaxRequest BrowserTiming BrowserInteraction category The type of interaction; either initial page load, route change, or custom. BrowserInteraction city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageView domain The domain portion of the request URL. BrowserInteraction JavaScriptError PageView PageViewTiming duration seconds (s) The total time elapsed of the interaction event BrowserInteraction eventId ID A value that you can link to multiple BrowserInteraction events so you can view the interactions that occurred surrounding a specific event. For example, you can see the browser interactions that occurred prior to a JS error. AjaxRequest BrowserTiming BrowserInteraction firstContentfulPaint firstContentfulPaint is the point when the browser renders the first bit of content from the DOM, which may be text, an image, SVG, or a <canvas> element. Google's User-centric Performance Metrics contains detailed information about its Paint Timing API and firstContentfulPaint. See Compatibility and requirements for New Relic Browser for additional information about firstContentfulPaint browser compatibility. BrowserInteraction PageView firstPaint firstPaint marks the point when the browser renders anything that is visually different from what was on the screen prior to navigation. This includes non-default background paint and the enclosing box of an iframe. Google's User-centric Performance Metrics contains detailed information about its Paint Timing API and firstPaint. See Compatibility and requirements for New Relic Browser for additional information about firstPaint browser compatibility. BrowserInteraction PageView jsDuration seconds (s) The total duration, in seconds, spent on JavaScript execution. (This attribute doesn't exist for initial page load events.) AjaxRequest BrowserTiming BrowserInteraction monitorAccountId The Synthetics account from which you are running the monitor. BrowserInteraction JavaScriptError monitorId ID A unique number identifying a particular monitor. BrowserInteraction JavaScriptError SyntheticCheck monitorJobId ID The ID of a single Synthetics monitor run, which began at a specific time and originated from a specific location. BrowserInteraction JavaScriptError parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError previousGroupedUrl The grouped version of the URL in the browser at the start of the interaction. BrowserInteraction previousRouteName The route name of the page at the start of the interaction. This is the last value passed by setCurrentRouteName before the start of the interaction. BrowserInteraction previousURL The ungrouped URL in the browser at the start of the interaction. BrowserInteraction regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming Span targetGroupedUrl The grouped version of the URL in the browser at the end of the interaction. BrowserInteraction targetRouteName The route name for the page at the end of the interaction. The last value passed by setCurrentRouteName before the end of the interaction. BrowserInteraction targetUrl The ungrouped URL in the browser at the end of the interaction. BrowserInteraction timeToConnectEnd seconds (s) The time, in seconds, from the start of the interaction to the connectEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToConnectStart seconds (s) The time, in seconds, from the start of the interaction to the connectStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomComplete seconds (s) The time, in seconds, from the start of the interaction to the domComplete, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomContentLoadedEventEnd seconds (s) The time, in seconds, from the start of the interaction to the domContentLoadedEventEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomContentLoadedEventStart seconds (s) The time, in seconds, from the start of the interaction to the domContentLoadedEventStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomInteractive seconds (s) The time, in seconds, from the start of the interaction to the domInteractive, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomLoading seconds (s) The time, in seconds, from the start of the interaction to the domLoading, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomainLookupEnd seconds (s) The time, in seconds, from the start of the interaction to the domainLookupEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomainLookupStart seconds (s) The time, in seconds, from the start of the interaction to the domainLookupStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToFetchStart seconds (s) The time, in seconds, from the start of the interaction to the fetchStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToLoadEventEnd seconds (s) The time, in seconds, from the start of the interaction to the loadEventEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToLoadEventStart seconds (s) The time, in seconds, from the start of the interaction to the loadEventStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information, see our documentation about instrumentation for the Navigation Timing API. BrowserInteraction timeToRedirectEnd seconds (s) The time, in seconds, from the start of the interaction to the redirectEnd, as defined by the Navigation Timing API. This attribute exists only for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToRedirectStart seconds (s) The time, in seconds, from the start of the interaction to the redirectStart, as defined by the Navigation Timing API. This attribute exists only for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToRequestStart seconds (s) The time, in seconds, from the start of the interaction to the requestStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToResponseEnd seconds (s) The time, in seconds, from the start of the interaction to the responseEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToResponseStart seconds (s) The time, in seconds, from the start of the interaction to the responseStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToSecureConnectionStart seconds (s) The time, in seconds, from the start of the interaction to the secureConnectionStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToUnloadEventEnd seconds (s) The time, in seconds, from the start of the interaction to the unloadEventEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToUnloadEventStart seconds (s) The time, in seconds, from the start of the interaction to the unloadEventStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timestamp The time (date, hour, minute, second) at which the interaction occurred. AjaxRequest BrowserTiming BrowserInteraction PageAction PageView PageViewTiming Span trigger The cause of the route change or page load. The default values are click, submit, popstate, or initial page load. For a custom event created with the API, the default value for trigger will be api. This value can also be set via the API. BrowserInteraction userAgentName The browser’s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming userAgentOS The browser’s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browser’s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming BrowserTiming Data source : Browser agent BrowserTiming is a custom event that captures SPA timing data for browser interactions started using the custom createTracer SPA API method. BrowserTiming contains many of the same attributes used by other events, especially AjaxRequest. Attribute name Definition Data types appId ID The ID of your application, as recorded by New Relic. AjaxRequest BrowserTiming BrowserInteraction PageAction PageView PageViewTiming appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError browserInteractionName The name of the interaction. This is either the targetGroupedUrl or the custom name set via the API. AjaxRequest BrowserTiming BrowserInteraction browserTimingName The name of the event. This is taken from the name argument of createTracer. BrowserTiming city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageView eventId ID A value that you can link to multiple BrowserInteraction events so you can view the interactions that occurred surrounding a specific event. For example, you can see the browser interactions that occurred prior to a JS error. AjaxRequest BrowserTiming BrowserInteraction groupedPageURL The grouped URL of the view that made the AJAX request. For example: myapp.com/acct/*/dash. AjaxRequest BrowserTiming jsDuration seconds (s) The total duration, in seconds, spent on JavaScript execution. (This attribute doesn't exist for initial page load events.) AjaxRequest BrowserTiming BrowserInteraction pageUrl The URL of the page that was loaded for the PageView. For example: http://www.newrelic.com. This URL does not include query parameters. AjaxRequest BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming Span timeSinceBrowserInteractionStart seconds (s) The time in seconds between the start of the BrowserInteraction and the start of the request. AjaxRequest BrowserTiming timeToLastCallbackEnd seconds (s) The duration, in seconds, from the start of the request (timestamp) to the end of the last callback. This is not just an additive function; the callback time can overlap with the wait time. AjaxRequest BrowserTiming timeToSettle seconds (s) The time, in seconds, from the start of the request to when all resulting callbacks (including callbacks of subsequent AJAX requests) are complete. AjaxRequest BrowserTiming timeToTracedCallbackStart seconds (s) The time in seconds from the start of the custom tracer until the start of the traced callback. This attribute is unique to the BrowserTiming event. BrowserTiming timestamp The time (date, hour, minute, second) at which the interaction occurred. AjaxRequest BrowserTiming BrowserInteraction PageAction PageView PageViewTiming Span tracedCallbackDuration seconds (s) The duration in seconds of the traced callback. This attribute is unique to the BrowserTiming event. BrowserTiming userAgentName The browser’s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming userAgentOS The browser’s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browser’s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming ContainerSample Data source : Infrastructure This event is reported by the New Relic Infrastructure agent. It collects data from all the Docker containers on the host (which may or may not be running). It includes the container's ID, name, image, image name, and metrics about CPU, memory and networking. We take a snapshot of this data every 15 seconds for each container and package it into this event, which is then sent to New Relic. This data appears on the Containers UI page. Attribute name Definition Data types StorageDataAvailableBytes bytes (B) Data space available in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageDataTotalBytes bytes (B) Total Data space in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageDataUsagePercent percentage (%) Percent of Data space used in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageDataUsedBytes bytes (B) Data space used by the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataAvailableBytes bytes (B) Metadata space available in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataTotalBytes bytes (B) Total Metadata space in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataUsagePercent percentage (%) Percent of Metadata space used in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataUsedBytes bytes (B) Metadata space used by the Storage Driver. Only Device Mapper driver is supported. ContainerSample commandLine The command line used in the container. ContainerSample containerId ID The unique Docker container ID. ContainerSample cpuKernelPercent percentage (%) CPU time percentage used in kernel space. ContainerSample cpuLimitCores count Number of cores available for the container. ContainerSample cpuPercent percentage (%) CPU usage percentage used. ContainerSample cpuShares count Number of CPU shares assigned to the container. ContainerSample cpuThrottlePeriods count Total number of periods throttled. ContainerSample cpuThrottleTimeMs milliseconds (ms) Total throttling time in milliseconds. ContainerSample cpuUsedCores percentage (%) CPU usage per core. ContainerSample cpuUsedCoresPercent percentage (%) CPU usage percentage per core. ContainerSample cpuUserPercent percentage (%) CPU time percentage used in user space. ContainerSample criticalViolationCount count The number of times that alert conditions violated critical thresholds, causing critical violations and opening incidents. If this attribute does not exist on the sample, it has zero violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample image ID The Docker image ID for the image the container is based on. ContainerSample imageName The Docker image name for the container. ContainerSample label_KEY Docker labels associated with this container (where KEY represents a custom label's key value). ContainerSample memoryCacheBytes count The amount of memory used by the container that can be associated precisely with a block on a block device. ContainerSample memoryKernelUsageBytes bytes (B) The amount of current kernel memory allocation. ContainerSample memoryResidentSizeBytes bytes (B) The amount of memory that doesn't correspond to anything on disk: stacks, heaps, and anonymous memory maps. ContainerSample memorySizeLimitBytes bytes (B) The total amount of memory the container is allowed to use. ContainerSample memorySoftLimitBytes bytes (B) The soft limit of memory usage equivalent to the memory reservation of the container. ContainerSample memorySwapLimitBytes bytes (B) The total amount of memory the container is using, including swap. ContainerSample memorySwapLimitUsagePercent percentage (%) This metric is calculated as the percentage of memorySwapUsageBytes over memorySwapLimitBytes, if the limit exists. ContainerSample memorySwapOnlyUsageBytes bytes (B) The amount of swap memory the container is using. This memory doesn't include non-swap memory. ContainerSample memorySwapUsageBytes bytes (B) The amount of memory swap the container is using, including swap. ContainerSample memoryUsageBytes bytes (B) This metric doesn't account for swap usage. ContainerSample memoryUsageLimitPercent percentage (%) This metric is calculated as the memoryUsageBytes percentage over memorySizeLimitBytes, if the limit exists. ContainerSample name The Docker container name. ContainerSample networkRxBytes bytes (B) Total number of received bytes. ContainerSample networkRxBytesPerSecond rate Number of received bytes per second. ContainerSample networkRxDropped count Total number of received packets dropped. ContainerSample networkRxDroppedPerSecond rate Number of received packets dropped per second. ContainerSample networkRxError count Total number of received packets with error. ContainerSample networkRxErrorsPerSecond rate Number of received packets with error per second. ContainerSample networkRxPackets count Total number of received packets. ContainerSample networkRxPacketsPerSecond rate Number of received packets with error per second. ContainerSample networkTxBytesPerSecond rate Number of transmitted bytes per second. ContainerSample networkTxDropped count Total number of transmitted packets dropped. ContainerSample networkTxDroppedPerSecond rate Number of transmitted packets dropped per second. ContainerSample networkTxErrors count Total number of transmitted packets with error. ContainerSample networkTxErrorsPerSecond rate Number of transmitted packets with error per second. ContainerSample networkTxPackets count Total number of transmitted packets. ContainerSample networkTxPacketsPerSecond rate Number of transmitted packets per second. ContainerSample networksTxBytes count Total number of bytes transmitted. ContainerSample restartCount count The number of times the container was restarted. ContainerSample state It can be: created, restarting, running, removing, paused, exited, or dead. ContainerSample status Holds the current container state. ContainerSample warningViolationCount count The number of times that alert conditions violated warning thresholds, causing warning violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample DistributedTraceSummary Data source : Distributed Tracing This event contains summary data about a distributed trace and provides an aggregated view of distributed tracing data. DistributedTraceSummary events are generated by New Relic and are triggered by distributed tracing data from agents or the Trace API. Attribute name Definition Data types accountIds A comma delimited list of newrelic accountIds that took part in this trace. DistributedTraceSummary backend.duration.ms milliseconds (ms) The total elapsed time in milliseconds of all backend services in this trace. DistributedTraceSummary backend.timestamp milliseconds (ms) The timestamp of the first span in this trace from a backend entity. In distributed tracing, any events that are not from client-side applications contributed to the backend duration. DistributedTraceSummary duration.ms The duration of the entire distributed trace, including both backend and client-side entities. the earliest span to the latest. DistributedTraceSummary entityCount count The number of unique entities that took part in this trace. DistributedTraceSummary entityGuids A comma delimited list of entity GUIDs for entities that participated in this trace. These GUIDs are assigned by New Relic for the New Relic-monitored entity (host, application, etc.). Each GUID is stored as a Base64 encoded value. DistributedTraceSummary errorCount count The number of events in this distributed trace that were identified as errors. DistributedTraceSummary newRelic.traceFilter.type The name of the trace filter used by the Infinite Tracing trace observer to select this trace. DistributedTraceSummary Span root.entity.accountId The New Relic account ID that the root entity of this trace reports data to. DistributedTraceSummary root.entity.guid The entity GUID associated with the root entity of this trace. DistributedTraceSummary root.entity.name The name of the root entity of this trace. DistributedTraceSummary root.span.duration.ms milliseconds (ms) The elapsed time in milliseconds of the root span of this trace. The root of a distributed trace is the first span, and will have a null value for parent.id. DistributedTraceSummary root.span.id The unique identifier of the root span of this trace. The root of a distributed trace is the first span, and it has a null value for parent.id. DistributedTraceSummary root.span.name The name of the root span of this trace. DistributedTraceSummary root.span.timestamp milliseconds (ms) The timestamp of the root span of this trace. The root of a distributed trace is the first span, and will have a null value for parent.id. DistributedTraceSummary spanCount count The number of events in this distributed trace. Events in a distributed trace can have several event types, including Span, Transaction, and TransactionError. DistributedTraceSummary timestamp milliseconds (ms) The timestamp of the root span in this distributed trace. DistributedTraceSummary trace.id ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. DistributedTraceSummary MobileRequest MobileRequestError Span Transaction TransactionError InfrastructureEvent Data sources : InfrastructureCloudTrail InfrastructureEvent describes changes (deltas) that occur in a system's live state. When an inventory or system state is added, removed, or changed, Infrastructure will produce an InfrastructureEvent that logs that activity. Attribute name Definition Data types category A New Relic category used to organize events in the UI. For example: automation, notification, and service. InfrastructureEvent changeType A simple classification of the type of change made to the entity: added, modified, or removed. InfrastructureEvent changedPath The fully specified name of the item that changed. This is constructed by taking the source and adding one or more additional path elements that uniquely identify the item that changed. InfrastructureEvent deltaId Delta refers to a recorded change in the system. The deltaId is a number used by New Relic to organize incoming inventory change data. InfrastructureEvent eventId The unique ID of the event, generated by New Relic. InfrastructureEvent format The type of infrastructure event. Each format type includes attributes that may be used to render the event in the UI. InfrastructureEvent newStatus The new agent status: disconnected or connected. InfrastructureEvent newValue If a change is made to the entity, this attribute contains the new value of the inventory that was changed. This will have no value if no change has been made. The value will display approximately 4K bytes of data. InfrastructureEvent oldValue If a change is made to the entity, this attribute contains the old value of the inventory that was changed. This will be blank if no change has been made. InfrastructureEvent provider For integrations that use generic event types (like the DatastoreSample event), the provider value specifies the source of the data (the service, or a sub-category of data from that service). Some Insights events are generic and are used by several integrations. For example, the DatastoreSample event is used by several integrations, including the AWS DynamoDB integration and the AWS RDS integration. In these cases, the provider attribute value represents the source of that attribute. This will usually be the service that data comes from or, for integrations that use several provider values, a certain sub-category of data from that service. When a provider value is present for a generic event, that event will have additional integration-specific attributes attached to it. Here’s an example of an Insights NRQL query that returns the attributes present for a DatastoreSample event reported by the AWS RDS integration: SELECT * from DatastoreSample where provider = 'RdsDbCluster' InfrastructureEvent source The fully specified origin of this inventory item. This is typically in the form category/plugin, where plugin is the generic word used for the tool that gathered this data. InfrastructureEvent summary A summary of the change that happened. Uses a human-friendly string, such as Agent disconnected. InfrastructureEvent violationUpdateType The type of change to the violation: For example: open or closed. InfrastructureEvent JavaScriptError Data source : Browser agent As JavaScript errors are triggered, we capture details as events. The JavaScriptError event contains information to help you segment errors to understand how they impact performance. Attribute name Definition Data types appId ID The identification number for the reporting browser agent. JavaScriptError appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError browserStackHash ID An unique identifier generated for a stack trace. The browserStackHash for a stack trace is different across different browsers. An identical stack trace will generate the same identifier. JavaScriptError city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageView domain The domain portion of the request URL. BrowserInteraction JavaScriptError PageView PageViewTiming entityGuid The unique identifier of the monitor referenced in New Relic One. JavaScriptError SyntheticCheck SyntheticRequest errorClass The error type of the JavaScript Error object. Examples: ReferenceError, SyntaxError, and UncaughtException. JavaScriptError errorMessage The error message that was delivered. JavaScriptError firstErrorInSession A value to indicate whether or not this was the first JS error in the session. Example: true. JavaScriptError monitorAccountId The Synthetics account from which you are running the monitor. BrowserInteraction JavaScriptError monitorId ID A unique number identifying a particular monitor. BrowserInteraction JavaScriptError SyntheticCheck monitorJobId ID The ID of a single Synthetics monitor run, which began at a specific time and originated from a specific location. BrowserInteraction JavaScriptError pageUrl The URL of the page that was loaded for the PageView. For example: http://www.newrelic.com. This URL does not include query parameters. AjaxRequest BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming releaseIds ID The releases in which the app was updated. Example: {\\\"jQuery\\\":\\\"v3.1.1\\\",\\\"multiverse\\\":\\\"96e9ac7\\\"}. JavaScriptError requestUri The URI of the requested resource. JavaScriptError session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming Span stackHash ID A unique identifier generated by the Browser agent for a stack trace. The stackHash for a stack trace is the same across different browsers. An identical stack trace will generate the same identifier. JavaScriptError stackTrace A collection of the active stack frames when the error occurred. JavaScriptError stackTraceGzip A compressed version of the stackTrace attribute. JavaScriptError timestamp The time that the error occurred, in Unix time. JavaScriptError transactionName The full metric name of the transaction in which the error occurred, or Unknown if the error occurs outside of a transaction. JavaScriptError userAgentName The browser’s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming userAgentOS The browser’s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browser’s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError PageAction PageView PageViewTiming Metric Data source : Metrics Represents a metric data point (e.g., a measurement over a range of time, or a sample at a specific point in time) with multiple attributes attached, which allow for in-depth analysis and querying. This metric data comes from our Metric API, our Telemetry SDKs, and some of our open-source exporters/integrations. Attribute name Definition Data types endTimestamp milliseconds (ms) The end of the time range associated with the metric, in Unix time, in milliseconds. This is calculated by adding the metric interval to the timestamp of the metric (timestamp + interval.ms). Metric interval.ms milliseconds (ms) The length of the time window. Metric metricName Name of the metric. Metric newrelic.source The source of this data. For example: metricAPI. Metric timestamp milliseconds (ms) The start time for the metric, in Unix time. Metric Mobile Data source : Mobile A Mobile event is created when a crash occurs, when an interaction ends or has run for 1 second, or if a session completes after the app is closed, backgrounded, or has run for 10 minutes. Mobile events were once the only event type and were generated for every event, but now there are several specialized event types. Recommendation: Upgrade to the most recent mobile monitoring agent version to take full advantage of the new event types. Attribute name Definition Data types category The type of data, either session or interaction. Mobile MobileSession interactionDuration For interaction category events only. This is the total time for the interaction to render on the device. In addition to render time, this usually includes all external calls associated with the interaction. Currently, this attribute is measured in seconds for Android devices and in milliseconds for iOS devices. Mobile name For interaction category events only. This is the label of the interaction associated with the event. It is by default assigned by New Relic. For example: ApplicationsListFragment or Display iOS_Example.MasterViewController. Mobile reportedTimestampMs For interaction category events only. The UTC based timestamp for when the event was sent to New Relic. This is different from the attribute ‘timestamp’, which is when the event began. Mobile MobileCrash Data source : Mobile The MobileCrash event is created when an app crashes. MobileCrash includes attributes such as crash line number, class, and crash message. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appToken The mobile application license token. MobileCrash appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession architecture The processor architecture of the device. For example: armv7 or arm64. MobileCrash asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession bundleId ID The unique string used to identify the application. MobileCrash MobileSession carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession crashException The exception associated with the crash, if one is present. For example: java.lang.NullPointerException. MobileCrash crashFingerprint ID The New Relic-generated fingerprint used to uniquely identify the crash and other crashes identical to this one. MobileCrash crashLocationFile The file in which the crash occurred. MobileCrash crashMessage The message associated with the crash, if one is present. MobileCrash deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceName The device's name. MobileCrash deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession diskAvailable bytes (B) Space available on the device, in bytes. MobileCrash interactionHistory The client interactions with the application that led to the crash. MobileCrash isFirstOccurrence A boolean value indicating whether or not this was the first occurrence of the crash. MobileCrash lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession modelNumber The model of the device. This is the same as the session-level deviceModel attribute. MobileCrash networkStatus The type of network that the device was on at the time of crash, such as wifi or LTE. MobileCrash newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession occurrenceId ID The ID for this instance of the crash. MobileCrash orientation The orientation of the device, such as landscape or portrait. MobileCrash osBuild For Android only. The specific build of the Android OS. MobileCrash MobileHandledException osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession parentProcess The parent process that launched the crashing process. MobileCrash parentProcessId ID The parent identification number (PID) of the parent process. MobileCrash platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession processId ID The PID of the previously running process on the device. MobileCrash processName The name of the previously running process. MobileCrash processPath The path to the binary. MobileCrash reportedTimestampMs The UTC timestamp for when the event was received by New Relic. (This is different from timestamp, which is when the MobileSession event began that crashed.) MobileCrash runTime For Android only. The Android Runtime version where the exception/crash was generated. MobileCrash MobileHandledException sessionCrashed A boolean value indicating whether or not that session crashed. MobileCrash MobileSession sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession symbolicated A boolean value indicating whether or not the crash was properly symbolicated. MobileCrash timeSinceLastInteraction milliseconds (ms) The time, in milliseconds, since the interaction before a crash event. MobileCrash userImageUuids ID The array of build UUIDs for applications and libraries. MobileCrash uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession MobileHandledException Data source : Mobile MobileHandledException is sent when an exception is caught and is used for non-fatal exceptions reported to New Relic using the recordHandledException API for Android or iOS. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileRequestError MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileRequestError MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileRequestError MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession exceptionAppBuildUuid ID The build uuid of the application binary in which the exception was caught. MobileHandledException exceptionCause The unsymbolicated, platform-specific cause of the exception. MobileHandledException exceptionLocation New Relic defined location of an exception. Contains a combination of exception file name, class, line number, and method. MobileHandledException exceptionLocationClass The class that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionLocationFile The class that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionLocationLibraryOffset For XCFramework agent only. The library offset of the library that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionLocationLine Comes from the exception: The line number where the exception was generated. Only present if symbolication succeeded. MobileHandledException exceptionLocationMethod The method that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionMessage The unsymbolicated message from the exception. It can be user-generated or a generic system message. For Android, this is the Throwable message. MobileHandledException exceptionName The unsymbolicated exception type. MobileHandledException fingerprint ID The New Relic-generated identifier used to group like exceptions. MobileHandledException handledExceptionUuid ID The unique ID of the exception event. MobileHandledException lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession libraryName For XCFramework agent only. The library name where the exception was generated. MobileHandledException libraryStartAddr For XCFramework agent only. The library start address where the exception was generated. MobileHandledException memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession occurrenceTimestamp Agent-reported epoch timestamp of the handled exception. MobileHandledException osBuild For Android only. The specific build of the Android OS. MobileCrash MobileHandledException osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileRequestError MobileSession runTime For Android only. The Android Runtime version where the exception/crash was generated. MobileCrash MobileHandledException sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession timestamp Epoch timestamp of the handled exception. This exception timestamp represents the time New Relic created the event, if it's older than two days or some other unexpected time. MobileHandledException uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession MobileRequest Data source : Mobile A MobileRequest event is created when an HTTP request successfully completes, resulting in a response code below 400. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession bytesReceived bytes (B) Optional: If the application received a response from the requestUrl, the size of that response in bytes. MobileRequest MobileRequestError bytesSent bytes (B) Optional: If the application sent a request to the requestUrl, the size of that request in bytes. MobileRequest MobileRequestError carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession connectionType The type of connection which the device was using, such as 2G or 3G. MobileRequest MobileRequestError countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileRequestError MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileRequestError MobileSession deviceGroup The category of the device, such as iPhone or Tablet. MobileRequest MobileRequestError MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceSize The display size of the device: Small, normal, large, xlarge. MobileRequest MobileRequestError deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileRequestError MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession duration seconds (s) Optional: The time to complete the request, measured in fractional seconds. MobileRequest MobileRequestError guid ID The unique identifier for the segment. This is equivalent to spanID in OpenTracing semantics. MobileRequest MobileRequestError Span lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileRequestError MobileSession requestDomain The domain that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestFingerprint ID The New Relic-generated identifier used to group like request events. MobileRequest requestMethod The REST method (GET, PUT, POST, etc.) that the application attempted when the event occurred. MobileRequest MobileRequestError requestPath The path that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUrl The URL that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUuid ID A unique identifer for the request event. MobileRequest MobileRequestError responseTime seconds (s) The time between the request and the response in fractional seconds. MobileRequest MobileRequestError sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession statusCode Optional: The HTTP status code for the HTTP event. MobileRequest MobileRequestError timestamp The UTC epoch time at which an event began. MobileRequest MobileRequestError MobileSession trace.id ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. DistributedTraceSummary MobileRequest MobileRequestError Span Transaction TransactionError traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocation AwsLambdaInvocationError MobileRequest MobileRequestError Span uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession MobileRequestError Data source : Mobile A MobileRequestError is used for HTTP errors or network failures. HTTP errors are HTTP requests that have a status code greater than 400. A network failure is a HTTP request that results in no response. The event is sent when the HTTP request completes. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession bytesReceived bytes (B) Optional: If the application received a response from the requestUrl, the size of that response in bytes. MobileRequest MobileRequestError bytesSent bytes (B) Optional: If the application sent a request to the requestUrl, the size of that request in bytes. MobileRequest MobileRequestError carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession connectionType The type of connection which the device was using, such as 2G or 3G. MobileRequest MobileRequestError countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileRequestError MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileRequestError MobileSession deviceGroup The category of the device, such as iPhone or Tablet. MobileRequest MobileRequestError MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceSize The display size of the device: Small, normal, large, xlarge. MobileRequest MobileRequestError deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileRequestError MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession duration seconds (s) Optional: The time to complete the request, measured in fractional seconds. MobileRequest MobileRequestError errorType Either HTTPError or NetworkFailure, depending on whether the error is a result of a failed request to a host or a failure on the cellular network. MobileRequestError guid ID The unique identifier for the segment. This is equivalent to spanID in OpenTracing semantics. MobileRequest MobileRequestError Span lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession networkError The error message associated with the iOS NSURL Error code. See networkErrorCode for more information. MobileRequestError networkErrorCode If the error is a network error, this is the iOS network error code. For Android applications, this is the mapped value. MobileRequestError newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileRequestError MobileSession requestDomain The domain that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestErrorFingerprint ID The New Relic-generated identifier used to group like request error events. MobileRequestError requestMethod The REST method (GET, PUT, POST, etc.) that the application attempted when the event occurred. MobileRequest MobileRequestError requestPath The path that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUrl The URL that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUuid ID A unique identifer for the request event. MobileRequest MobileRequestError responseBody Optional: The response that is sent from the requestDomain for the HTTP error, up to 4096 bytes. MobileRequestError responseTime seconds (s) The time between the request and the response in fractional seconds. MobileRequest MobileRequestError sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession statusCode Optional: The HTTP status code for the HTTP event. MobileRequest MobileRequestError timestamp The UTC epoch time at which an event began. MobileRequest MobileRequestError MobileSession trace.id ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. DistributedTraceSummary MobileRequest MobileRequestError Span Transaction TransactionError traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocation AwsLambdaInvocationError MobileRequest MobileRequestError Span uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession MobileSession Data source : Mobile A MobileSession event is sent when an app is closed, backgrounded, or when 10 minutes of active use has elapsed. This is the source of the general session data used by the other mobile monitoring events. MobileSession captures attributes such as device type, device OS, and geographical information. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession bundleId ID The unique string used to identify the application. MobileCrash MobileSession carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession category The type of data, either session or interaction. Mobile MobileSession city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserTiming BrowserInteraction JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileRequestError MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileRequestError MobileSession deviceGroup The category of the device, such as iPhone or Tablet. MobileRequest MobileRequestError MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileRequestError MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession install Indicates true only if the current session is the first session after app install. MobileSession lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession newRelicAgent The New Relic agent running on the application. For example: the iOSAgent or the androidAgent. MobileSession newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileRequestError MobileSession sessionCrashed A boolean value indicating whether or not that session crashed. MobileCrash MobileSession sessionDuration seconds (s) The length of time for which the user used the application in seconds. If the session crashes, sessionDuration is not captured (although other events and attributes are still recorded). For sessions longer than 10 minutes, events in the Interaction and Custom event categories are sent to Insights while the session is ongoing, and therefore do not have sessionDuration attributes. Events recorded near the end of the session will include the duration, as will the Session event category. MobileSession sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession timeSinceLoad seconds (s) The time, in seconds, from the beginning of the mobile session to the time the event occurred. MobileSession timestamp The UTC epoch time at which an event began. MobileRequest MobileRequestError MobileSession upgradeFrom Indictates previous version number only if this is the first launch after app upgrade. MobileSession uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession NetworkSample Data source : Infrastructure NetworkSample event captures the descriptive and state information for each network device associated with a server. It includes the device's interface and address information, as well as current usage data. New Relic samples this data every 10 seconds for each attached network interface and packages it into a NetworkSample event, then sends the raw data to New Relic's collectors every 60 seconds. Attribute name Definition Data types agentName The name of the agent (Infrastructure). NetworkSample ProcessSample StorageSample SystemSample agentVersion The version of the New Relic Infrastructure agent. NetworkSample ProcessSample StorageSample SystemSample criticalViolationCount count The number of times that alert conditions violated critical thresholds, causing critical violations and opening incidents. If this attribute does not exist on the sample, it has zero violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample entityID ID New Relic's unique ID number for the entity that is reporting data. This is used by New Relic to distinguish between customers and their entities. NetworkSample ProcessSample StorageSample SystemSample fullHostname The fully qualified (DNS) hostname. NetworkSample ProcessSample StorageSample SystemSample hardwareAddress The unique hardware address of the interface. NetworkSample hostname The short version of the entity's name. NetworkSample ProcessSample StorageSample SystemSample interfaceName The interface name as reported by the operating system. NetworkSample ipV4Address The IP version 4 address. NetworkSample ipV6Address The IP version 6 address. NetworkSample kernelVersion The Linux kernel version, in string format. This attribute is available only for systems on a Linux platform. NetworkSample ProcessSample StorageSample SystemSample linuxDistribution The name of the Linux distribution the server is using. This attribute is available only for systems on a Linux platform. NetworkSample ProcessSample StorageSample SystemSample operatingSystem The operating system on which the agent is installed. NetworkSample ProcessSample StorageSample SystemSample receiveBytesPerSecond bytes (B) The number of bytes per second received during the sampling period. NetworkSample receiveDroppedPerSecond count The number of received packets per second dropped during the sampling period. NetworkSample receiveErrorsPerSecond count The number of receive errors per second on the interface during the sampling period. NetworkSample receivePacketsPerSecond count The number of packets per second (as defined by OS) received during the sampling period. NetworkSample state The state of the entity: either up or down. NetworkSample timestamp The time (date, hour, minute, second) at which the interaction occurred. NetworkSample ProcessSample StorageSample SystemSample transmitBytesPerSecond bytes (B) The number of bytes sent per second during the sampling period. NetworkSample transmitDroppedPerSecond count The number of dropped send packets per second during the sampling period. NetworkSample transmitErrorsPerSecond count The number of send errors per second on the interface during the sampling period. NetworkSample transmitPacketsPerSecond count The number of packets per second as defined by OS) sent during this sampling period. NetworkSample warningViolationCount count The number of times that alert conditions violated warning thresholds, causing warning violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample windowsFamily The ",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 304.27106,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>InfrastructureEvent</em>",
        "body": " MobileSession app<em>Id</em> <em>ID</em> A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - <em>iOS</em>. MobileCrash MobileHandledException"
      },
      "id": "603f53b164441f41894e8875"
    },
    {
      "sections": [
        "setUserId (iOS SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Return values",
        "Examples",
        "Objective-C",
        "Swift"
      ],
      "title": "setUserId (iOS SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "iOS SDK API"
      ],
      "external_id": "c28d39945d8c9eb4ffdb07b727f1ae4babd2fd89",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/set-user-id/",
      "published_at": "2021-09-14T07:52:31Z",
      "updated_at": "2021-08-08T18:39:38Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax setUserId:(NSString*)userId; NewRelic.setUserId:(NSString*)userId; Copy Set a custom user identifier value to associate user sessions with analytics events and attributes. Requirements Compatible with version 5.9.0 or higher. Description This method sets a custom user identifier value to associate mobile user sessions with NRDB events. This method can be called anytime after the New Relic iOS agent starts. A user identifier is useful for several reasons. Using the Crash analysis UI, you can: Find crashes specific to a user. Focusing on one particular crash for one user often is enough to quickly resolve the issue. Filter all crashes to show the occurrences for a user (or group of users) for each crash type; or, filter the crash list to show those users affected by each crash type. If the user ID is represented as an email address, it's then easy to reach out and let them know when there is a solution available that addresses those crashes. If you do not want to explicitly identify users because of privacy rules, this method is still useful when tracking user segments, such as paid vs. free end users, or registered vs. unregistered users. This allows you to filter or facet on the number and types of crashes experienced by each segment, and do outreach based on that segment. For context on how to use this API, see the documentation about sending custom attributes and events for: Objective-C Swift Parameters Parameter Description $userId string Required. Sets user ID. Return values Returns true if it succeeds, or false if it doesn't. Examples Objective-C Method: + (BOOL) setUserId:(NSString*)userId; Copy Example: BOOL userIdWasSet = [NewRelic setUserId:@\"SampleUserName\"]; Copy Swift Method: NewRelic.setUserId(userId: String!) -> Bool Copy Example: let userIdWasSet = NewRelic.setUserId(\"SampleUserName\") Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 211.4284,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setUserId (<em>iOS</em> SDK API)",
        "sections": "setUserId (<em>iOS</em> SDK API)",
        "tags": "New Relic Mobile <em>iOS</em>",
        "body": " to associate mobile user sessions with NRDB events. This method can be called anytime after the New Relic <em>iOS</em> agent starts. A user identifier is useful for several reasons. Using the Crash analysis UI, you can: Find crashes specific to a user. Focusing on one particular crash for one user often is enough"
      },
      "id": "60441a2564441f9b5d378ec6"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/configuration/ios-tvos-crash-reporting": [
    {
      "sections": [
        "Retrieve dSYMs for Bitcode apps",
        "Identify missing dSYMs",
        "Download dSYM files using iTunes Connect",
        "Download dSYM files using Xcode's app archive",
        "Upload dSYMs"
      ],
      "title": "Retrieve dSYMs for Bitcode apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "34e375873e36095062eccef6d99f26be7562308f",
      "image": "https://docs.newrelic.com/static/041368cdc60d9252ad80c2c37321b805/ec3e2/screen-dsym2.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/retrieve-dsyms-bitcode-apps/",
      "published_at": "2021-09-14T08:13:27Z",
      "updated_at": "2021-07-09T19:35:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Bitcode is a feature that gives Apple the ability to re-compile iOS and tvOS applications for specific users' hardware. This provides a smaller download size for end users. For more about this process, see Apple's Bitcode and app thinning documentation. When Apple compiles an app, the dSYM files are also compiled. For New Relic to be able to symbolicate crashes of your Bitcode-enabled app, these dSYM files need to be downloaded from Apple and then uploaded to New Relic. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: from the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Download dSYM files using iTunes Connect To download the dSYM files you need for your app: Log in to Apple iTunes Connect. Select My Apps > (selected app) > Activity. From the list of builds for your application, select the build number you need for the dSYM. Select Download dSYM. Then, to upload the resulting zip file directly to New Relic: Follow the instructions to manually upload dSYM, and skip step 1. Unpack one dSYM contained in this zip file to retrieve a build UUID that you can upload. (Follow the last step in the manual upload instructions.) Once New Relic receives the zip file, the build UUIDs for all other dSYMs contained in that zip file will be identified. Download dSYM files using Xcode's app archive Use the app version and build number to identify the applicable app archive in the Xcode Organizer and download the dSYMs. Using Xcode to download dSYMs: From the Archives tab, select the app and version/build, then select Download dSYMs. Open the Xcode Organizer: From the Xcode menu, select Window > Organizer > Archives > (select a mobile app). From Version, select the archive that matches the app version (listed first) and build number (following the app version in parentheses). Select Download dSYMs. The dSYMs will be downloaded from Apple if available and if the file names contain a series of letters and numbers. If the dSYM files are named after the the dependencies in your project, the download will not be successful. Upload dSYMs Once you have located the dSYMs, follow the instructions to upload a dSYM for each zipped dSYM.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.67316,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Identify</em> missing dSYMs",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Bitcode is a feature that gives Apple the ability to re-compile <em>iOS</em> and tv<em>OS</em> applications for specific users&#x27; hardware. This provides a smaller download size for end users. For more about this process, see Apple&#x27;s Bitcode and app thinning documentation. When Apple compiles an app, the dSYM files"
      },
      "id": "6044144228ccbc04a2303885"
    },
    {
      "sections": [
        "iOS agent configuration and feature flags",
        "Enable or disable feature flags",
        "Crash and error reporting feature flag",
        "NRFeatureFlag_CrashReporting",
        "NRFeatureFlag_HandledExceptionEvents",
        "Distributed tracing",
        "NRFeatureFlag_DistributedTracing",
        "Interactions feature flags",
        "NRFeatureFlag_DefaultInteractions",
        "NRFeatureFlag_InteractionTracing",
        "NRFeatureFlag_SwiftInteractionTracing",
        "Caution",
        "Networking feature flags",
        "NRFeatureFlag_ExperimentalNetworkingInstrumentation",
        "NRFeatureFlag_NSURLSessionInstrumentation",
        "NRFeatureFlag_NetworkRequestEvents",
        "NRFeatureFlag_RequestErrorEvents",
        "NRFeatureFlag_HttpResponseBodyCapture"
      ],
      "title": "iOS agent configuration and feature flags",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "8ced2dac1fbc45a65d6cdca6b27a4db001d6a4db",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/api-guides/ios-agent-configuration-feature-flags/",
      "published_at": "2021-09-14T08:11:52Z",
      "updated_at": "2021-07-09T14:31:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's iOS agent provides configuration settings to change the default behavior of the agent. If used, implement these flags just before calling: Objective-C: +[NewRelic startWithApplicationToken:] Swift: NewRelic.start(withApplicationToken:) Enable or disable feature flags To configure feature flags, use the following method defined in NewRelic.h: iOS language Procedure Objective-C In Objective-C, these features are bitmasked, so you can use a | to enable or disable multiple features at the same time. Enable a feature flag: +[NewRelic enableFeatures:(NRMAFeatureFlags)flags]; Copy Disable a feature flag: +[NewRelic disableFeatures:(NRMAFeatureFlags)flags]; Copy Here is an example where: Interaction tracing and experimental networking instrumentation are enabled. NSURLSession instrumentation and crash reporting are disabled. [NewRelic enableFeatures:NRFeatureFlag_SwiftInteractionTracing | NRFeatureFlag_ExperimentalNetworkingInstrumentation]; [NewRelic disableFeatures:NRFeatureFlag_NSURLSessionInstrumentation | NRFeatureFlag_CrashReporting]; [NewRelic startWithApplicationToken:...]; Copy Swift Enable a feature flag: NewRelic.enableFeatures(NRMAFeatureFlags.[NRMAFeatureFlag]) Copy Disable a feature flag: NewRelic.disableFeatures(NRMAFeatureFlags.[NRMAFeatureFlag]) Copy Example to disable interaction tracing: NewRelic.disableFeatures(NRMAFeatureFlags.NRFeatureFlag_DefaultInteractions) Copy Crash and error reporting feature flag If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_CrashReporting Enable (default) or disable crash reporting, which appears on the Crash analysis page. Type Boolean Default true NRFeatureFlag_HandledExceptionEvents Globally enable (default) or disable recording handled exceptions events, which appear on the Handled exception page. Type Boolean Default true Distributed tracing NRFeatureFlag_DistributedTracing Enable or disable the adding of distributed tracing headers to network requests. Refer to How New Relic distributed tracing works for more information on distributed tracing in mobile apps. Type Boolean Default true Interactions feature flags If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_DefaultInteractions Enable (default) or disable interaction tracing only for default instrumented classes and methods. Custom interactions will be reported. The traces will appear on the Interactions page. Type Boolean Default true NRFeatureFlag_InteractionTracing Globally enable (default) or disable interaction traces, which appear on the Interactions page. Interaction tracing will be disabled after the agent has started. Interactions for any activity or methods executed prior to starting the agent may still appear on the Interactions page. Type Boolean Default true NRFeatureFlag_SwiftInteractionTracing Caution Before enabling this feature, see Enable Swift interaction traces. If proper steps are not taken, enabling this feature may cause instability. Enable or disable (default) interaction tracing for Swift code. The traces appear on the Interactions page. This feature will always be disabled if NRFeatureFlag_InteractionTracing is disabled. Type Boolean Default false Networking feature flags If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_ExperimentalNetworkingInstrumentation Caution Enabling this feature flag call may decrease the stability of applications. Avoid using unless instructed by New Relic. Enable or disable (default) experimental networking instrumentation. This forces all NSURLConnection network requests through the NRMAURProtocol. Type Boolean Default false NRFeatureFlag_NSURLSessionInstrumentation Enable (default) or disable networking instrumentation for NSURLSession. These URL traces are sent to the HTTP Requests page. Type Boolean Default true NRFeatureFlag_NetworkRequestEvents Enable or disable (default) networking instrumentation. This sends the HTTP response data as MobileRequest events. Available for iOS Agent version 5.14.0 and higher Type Boolean Default true - Enabled by default as of 6.0.0 NRFeatureFlag_RequestErrorEvents Enable (default) or disable HTTP request error event generation of instrumented network calls that result in an error or failure. These events are reported as MobileRequestError events. Available for iOS Agent version 5.11.0 and higher Type Boolean Default true NRFeatureFlag_HttpResponseBodyCapture Enable or disable capture of HTTP response bodies for HTTP error traces, and MobileRequestError events. Type Boolean Default true",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.62509,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> agent <em>configuration</em> and feature flags",
        "sections": "<em>iOS</em> agent <em>configuration</em> and feature flags",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> agent provides <em>configuration</em> settings to change the default behavior of the agent. If used, implement these flags just before calling: Objective-C: +[<em>NewRelic</em> startWithApplicationToken:] Swift: <em>NewRelic</em>.start(withApplicationToken:) Enable or disable feature flags To configure"
      },
      "id": "60441925196a67324d960f1b"
    },
    {
      "sections": [
        "Enable Swift interaction traces",
        "Enable dynamic method lookup",
        "Enable Swift instrumentation"
      ],
      "title": "Enable Swift interaction traces",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "168467256056a1f7b4410a7112f4bcfe0a93e5ec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/enable-swift-interaction-traces/",
      "published_at": "2021-09-14T08:13:26Z",
      "updated_at": "2021-07-09T09:36:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Dynamic-by-default method lookups for iOS development have been removed with Swift. This interrupts the agent's default method instrumentation. For example, interaction tracing in Swift classes are disabled by default, but you can re-enable them. Interactions in a Swift app are captured if automatically instrumented classes and methods are used or when defining custom interactions. However, if a Swift class creates sub-classes for any of these default classes, follow these steps to capture interactions. Enable dynamic method lookup To re-enable dynamic method lookup on a method-by-method basis in Swift, adding the dynamic declaration modifier. For example: class MyViewController : UIViewController { override dynamic func viewDidLoad() { super.viewDidLoad() ... } } Copy For every function that New Relic automatically instruments, be sure to add this modifier every time you create a sub-class and override in Swift. Enable Swift instrumentation After adding the dynamic keyword to your method overrides, you can re-enable Swift instrumentation by calling the following method: Language Procedure Objective-C Call prior to [NewRelic startWithApplicationToken:...]; [NewRelic enableFeatures:NRFeatureFlag_SwiftInteractionTracing]; Copy Swift Call prior to NewRelic.start(withApplicationToken:) NewRelic.enableFeatures(NRMAFeatureFlags.NRFeatureFlag_SwiftInteractionTracing) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.57883,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Enable Swift <em>interaction</em> traces",
        "sections": "Enable Swift <em>interaction</em> traces",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Dynamic-by-default method lookups for <em>iOS</em> development have been removed with Swift. This interrupts the agent&#x27;s default method instrumentation. For example, interaction tracing in Swift classes are disabled by default, but you can re-enable them. Interactions in a Swift app are captured"
      },
      "id": "603ed6ef64441fa4f14e889d"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/configuration/retrieve-dsyms-bitcode-apps": [
    {
      "sections": [
        "iOS and tvOS crash reporting",
        "dSYM files",
        "Debug the crash reporter",
        "Disable crash reporting"
      ],
      "title": "iOS and tvOS crash reporting",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "b2b79e6f9e78f6113bb20032c674996c746e14d4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/ios-tvos-crash-reporting/",
      "published_at": "2021-09-14T14:27:28Z",
      "updated_at": "2021-07-09T18:14:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For agent version 4 or higher, New Relic produces crash reports for your mobile applications. When an iOS or tvOS application crashes, the operating system creates a crash report and stores it on the device. New Relic uploads this report the next time the app launches. Using this report and any relevant dSYM files, the crash report includes the complete stack trace with human-readable information. You can then log into New Relic and see each crash, including the method and line where it crashed, plus device and environment details. dSYM files When you create a release build of an iOS or tvOS application, the names of methods and classes are stripped, leaving only machine-readable memory addresses. When the application crashes, the stack trace consists of this machine-readable code. A dSYM file is an Xcode project file for debug symbols. It contains the debugging symbols that allow for translation of the initial crash report to human-readable information. This process is known as symbolication. New Relic has dynamic framework support for dSYM uploading. If your app uses a dynamic framework with multiple dSYM files, New Relic automatically uploads and uses those files. For more information, see Retrieve and download dSYMs or Upload dSYM files. Debug the crash reporter Crash reporting is enabled by default, but there are some circumstances where it will be disabled: If the debugger is enabled: There can only be one uncaught exception handler registered at a time per application. If running with the debugger attached, New Relic will not capture and report crashes. If another crash reporter is enabled: If another uncaught exception handler is registered after New Relic starts, this error message is logged: The New Relic exception handler has been replaced. This may result in crashes no longer reporting to New Relic. Copy Disable crash reporting To disable New Relic crash reporting, call the following API method: Language Procedure Objective-C Call prior to [NewRelic startWithApplicationToken:...]; [NewRelic disableFeatures:NRFeatureFlag_CrashReporting]; Copy Swift Call prior to NewRelic.start(withApplicationToken:) NewRelic.disableFeatures(NRMAFeatureFlags.NRFeatureFlag_CrashReporting) Copy For more information about this call, see the NewRelic.h file. For more on applicable feature flags, see the NewRelicFeatureFlags.h file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.6604,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> and tvOS crash reporting",
        "sections": "<em>iOS</em> and tvOS crash reporting",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "For agent version 4 or higher, <em>New</em> <em>Relic</em> produces crash reports for your <em>mobile</em> applications. When an <em>iOS</em> or tv<em>OS</em> application crashes, the operating system creates a crash report and stores it on the device. <em>New</em> <em>Relic</em> uploads this report the next time the app launches. Using this report and any"
      },
      "id": "603ec58128ccbc9b51eba7d2"
    },
    {
      "sections": [
        "iOS agent configuration and feature flags",
        "Enable or disable feature flags",
        "Crash and error reporting feature flag",
        "NRFeatureFlag_CrashReporting",
        "NRFeatureFlag_HandledExceptionEvents",
        "Distributed tracing",
        "NRFeatureFlag_DistributedTracing",
        "Interactions feature flags",
        "NRFeatureFlag_DefaultInteractions",
        "NRFeatureFlag_InteractionTracing",
        "NRFeatureFlag_SwiftInteractionTracing",
        "Caution",
        "Networking feature flags",
        "NRFeatureFlag_ExperimentalNetworkingInstrumentation",
        "NRFeatureFlag_NSURLSessionInstrumentation",
        "NRFeatureFlag_NetworkRequestEvents",
        "NRFeatureFlag_RequestErrorEvents",
        "NRFeatureFlag_HttpResponseBodyCapture"
      ],
      "title": "iOS agent configuration and feature flags",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "8ced2dac1fbc45a65d6cdca6b27a4db001d6a4db",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/api-guides/ios-agent-configuration-feature-flags/",
      "published_at": "2021-09-14T08:11:52Z",
      "updated_at": "2021-07-09T14:31:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's iOS agent provides configuration settings to change the default behavior of the agent. If used, implement these flags just before calling: Objective-C: +[NewRelic startWithApplicationToken:] Swift: NewRelic.start(withApplicationToken:) Enable or disable feature flags To configure feature flags, use the following method defined in NewRelic.h: iOS language Procedure Objective-C In Objective-C, these features are bitmasked, so you can use a | to enable or disable multiple features at the same time. Enable a feature flag: +[NewRelic enableFeatures:(NRMAFeatureFlags)flags]; Copy Disable a feature flag: +[NewRelic disableFeatures:(NRMAFeatureFlags)flags]; Copy Here is an example where: Interaction tracing and experimental networking instrumentation are enabled. NSURLSession instrumentation and crash reporting are disabled. [NewRelic enableFeatures:NRFeatureFlag_SwiftInteractionTracing | NRFeatureFlag_ExperimentalNetworkingInstrumentation]; [NewRelic disableFeatures:NRFeatureFlag_NSURLSessionInstrumentation | NRFeatureFlag_CrashReporting]; [NewRelic startWithApplicationToken:...]; Copy Swift Enable a feature flag: NewRelic.enableFeatures(NRMAFeatureFlags.[NRMAFeatureFlag]) Copy Disable a feature flag: NewRelic.disableFeatures(NRMAFeatureFlags.[NRMAFeatureFlag]) Copy Example to disable interaction tracing: NewRelic.disableFeatures(NRMAFeatureFlags.NRFeatureFlag_DefaultInteractions) Copy Crash and error reporting feature flag If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_CrashReporting Enable (default) or disable crash reporting, which appears on the Crash analysis page. Type Boolean Default true NRFeatureFlag_HandledExceptionEvents Globally enable (default) or disable recording handled exceptions events, which appear on the Handled exception page. Type Boolean Default true Distributed tracing NRFeatureFlag_DistributedTracing Enable or disable the adding of distributed tracing headers to network requests. Refer to How New Relic distributed tracing works for more information on distributed tracing in mobile apps. Type Boolean Default true Interactions feature flags If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_DefaultInteractions Enable (default) or disable interaction tracing only for default instrumented classes and methods. Custom interactions will be reported. The traces will appear on the Interactions page. Type Boolean Default true NRFeatureFlag_InteractionTracing Globally enable (default) or disable interaction traces, which appear on the Interactions page. Interaction tracing will be disabled after the agent has started. Interactions for any activity or methods executed prior to starting the agent may still appear on the Interactions page. Type Boolean Default true NRFeatureFlag_SwiftInteractionTracing Caution Before enabling this feature, see Enable Swift interaction traces. If proper steps are not taken, enabling this feature may cause instability. Enable or disable (default) interaction tracing for Swift code. The traces appear on the Interactions page. This feature will always be disabled if NRFeatureFlag_InteractionTracing is disabled. Type Boolean Default false Networking feature flags If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_ExperimentalNetworkingInstrumentation Caution Enabling this feature flag call may decrease the stability of applications. Avoid using unless instructed by New Relic. Enable or disable (default) experimental networking instrumentation. This forces all NSURLConnection network requests through the NRMAURProtocol. Type Boolean Default false NRFeatureFlag_NSURLSessionInstrumentation Enable (default) or disable networking instrumentation for NSURLSession. These URL traces are sent to the HTTP Requests page. Type Boolean Default true NRFeatureFlag_NetworkRequestEvents Enable or disable (default) networking instrumentation. This sends the HTTP response data as MobileRequest events. Available for iOS Agent version 5.14.0 and higher Type Boolean Default true - Enabled by default as of 6.0.0 NRFeatureFlag_RequestErrorEvents Enable (default) or disable HTTP request error event generation of instrumented network calls that result in an error or failure. These events are reported as MobileRequestError events. Available for iOS Agent version 5.11.0 and higher Type Boolean Default true NRFeatureFlag_HttpResponseBodyCapture Enable or disable capture of HTTP response bodies for HTTP error traces, and MobileRequestError events. Type Boolean Default true",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.62509,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> agent <em>configuration</em> and feature flags",
        "sections": "<em>iOS</em> agent <em>configuration</em> and feature flags",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> agent provides <em>configuration</em> settings to change the default behavior of the agent. If used, implement these flags just before calling: Objective-C: +[<em>NewRelic</em> startWithApplicationToken:] Swift: <em>NewRelic</em>.start(withApplicationToken:) Enable or disable feature flags To configure"
      },
      "id": "60441925196a67324d960f1b"
    },
    {
      "sections": [
        "Enable Swift interaction traces",
        "Enable dynamic method lookup",
        "Enable Swift instrumentation"
      ],
      "title": "Enable Swift interaction traces",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "168467256056a1f7b4410a7112f4bcfe0a93e5ec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/enable-swift-interaction-traces/",
      "published_at": "2021-09-14T08:13:26Z",
      "updated_at": "2021-07-09T09:36:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Dynamic-by-default method lookups for iOS development have been removed with Swift. This interrupts the agent's default method instrumentation. For example, interaction tracing in Swift classes are disabled by default, but you can re-enable them. Interactions in a Swift app are captured if automatically instrumented classes and methods are used or when defining custom interactions. However, if a Swift class creates sub-classes for any of these default classes, follow these steps to capture interactions. Enable dynamic method lookup To re-enable dynamic method lookup on a method-by-method basis in Swift, adding the dynamic declaration modifier. For example: class MyViewController : UIViewController { override dynamic func viewDidLoad() { super.viewDidLoad() ... } } Copy For every function that New Relic automatically instruments, be sure to add this modifier every time you create a sub-class and override in Swift. Enable Swift instrumentation After adding the dynamic keyword to your method overrides, you can re-enable Swift instrumentation by calling the following method: Language Procedure Objective-C Call prior to [NewRelic startWithApplicationToken:...]; [NewRelic enableFeatures:NRFeatureFlag_SwiftInteractionTracing]; Copy Swift Call prior to NewRelic.start(withApplicationToken:) NewRelic.enableFeatures(NRMAFeatureFlags.NRFeatureFlag_SwiftInteractionTracing) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.57883,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Enable Swift <em>interaction</em> traces",
        "sections": "Enable Swift <em>interaction</em> traces",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Dynamic-by-default method lookups for <em>iOS</em> development have been removed with Swift. This interrupts the agent&#x27;s default method instrumentation. For example, interaction tracing in Swift classes are disabled by default, but you can re-enable them. Interactions in a Swift app are captured"
      },
      "id": "603ed6ef64441fa4f14e889d"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/configuration/upload-dsyms-bitcode-apps": [
    {
      "sections": [
        "Retrieve dSYMs for Bitcode apps",
        "Identify missing dSYMs",
        "Download dSYM files using iTunes Connect",
        "Download dSYM files using Xcode's app archive",
        "Upload dSYMs"
      ],
      "title": "Retrieve dSYMs for Bitcode apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "34e375873e36095062eccef6d99f26be7562308f",
      "image": "https://docs.newrelic.com/static/041368cdc60d9252ad80c2c37321b805/ec3e2/screen-dsym2.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/retrieve-dsyms-bitcode-apps/",
      "published_at": "2021-09-14T08:13:27Z",
      "updated_at": "2021-07-09T19:35:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Bitcode is a feature that gives Apple the ability to re-compile iOS and tvOS applications for specific users' hardware. This provides a smaller download size for end users. For more about this process, see Apple's Bitcode and app thinning documentation. When Apple compiles an app, the dSYM files are also compiled. For New Relic to be able to symbolicate crashes of your Bitcode-enabled app, these dSYM files need to be downloaded from Apple and then uploaded to New Relic. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: from the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Download dSYM files using iTunes Connect To download the dSYM files you need for your app: Log in to Apple iTunes Connect. Select My Apps > (selected app) > Activity. From the list of builds for your application, select the build number you need for the dSYM. Select Download dSYM. Then, to upload the resulting zip file directly to New Relic: Follow the instructions to manually upload dSYM, and skip step 1. Unpack one dSYM contained in this zip file to retrieve a build UUID that you can upload. (Follow the last step in the manual upload instructions.) Once New Relic receives the zip file, the build UUIDs for all other dSYMs contained in that zip file will be identified. Download dSYM files using Xcode's app archive Use the app version and build number to identify the applicable app archive in the Xcode Organizer and download the dSYMs. Using Xcode to download dSYMs: From the Archives tab, select the app and version/build, then select Download dSYMs. Open the Xcode Organizer: From the Xcode menu, select Window > Organizer > Archives > (select a mobile app). From Version, select the archive that matches the app version (listed first) and build number (following the app version in parentheses). Select Download dSYMs. The dSYMs will be downloaded from Apple if available and if the file names contain a series of letters and numbers. If the dSYM files are named after the the dependencies in your project, the download will not be successful. Upload dSYMs Once you have located the dSYMs, follow the instructions to upload a dSYM for each zipped dSYM.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.67316,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Identify</em> missing dSYMs",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Bitcode is a feature that gives Apple the ability to re-compile <em>iOS</em> and tv<em>OS</em> applications for specific users&#x27; hardware. This provides a smaller download size for end users. For more about this process, see Apple&#x27;s Bitcode and app thinning documentation. When Apple compiles an app, the dSYM files"
      },
      "id": "6044144228ccbc04a2303885"
    },
    {
      "sections": [
        "iOS and tvOS crash reporting",
        "dSYM files",
        "Debug the crash reporter",
        "Disable crash reporting"
      ],
      "title": "iOS and tvOS crash reporting",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "b2b79e6f9e78f6113bb20032c674996c746e14d4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/ios-tvos-crash-reporting/",
      "published_at": "2021-09-14T14:27:28Z",
      "updated_at": "2021-07-09T18:14:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For agent version 4 or higher, New Relic produces crash reports for your mobile applications. When an iOS or tvOS application crashes, the operating system creates a crash report and stores it on the device. New Relic uploads this report the next time the app launches. Using this report and any relevant dSYM files, the crash report includes the complete stack trace with human-readable information. You can then log into New Relic and see each crash, including the method and line where it crashed, plus device and environment details. dSYM files When you create a release build of an iOS or tvOS application, the names of methods and classes are stripped, leaving only machine-readable memory addresses. When the application crashes, the stack trace consists of this machine-readable code. A dSYM file is an Xcode project file for debug symbols. It contains the debugging symbols that allow for translation of the initial crash report to human-readable information. This process is known as symbolication. New Relic has dynamic framework support for dSYM uploading. If your app uses a dynamic framework with multiple dSYM files, New Relic automatically uploads and uses those files. For more information, see Retrieve and download dSYMs or Upload dSYM files. Debug the crash reporter Crash reporting is enabled by default, but there are some circumstances where it will be disabled: If the debugger is enabled: There can only be one uncaught exception handler registered at a time per application. If running with the debugger attached, New Relic will not capture and report crashes. If another crash reporter is enabled: If another uncaught exception handler is registered after New Relic starts, this error message is logged: The New Relic exception handler has been replaced. This may result in crashes no longer reporting to New Relic. Copy Disable crash reporting To disable New Relic crash reporting, call the following API method: Language Procedure Objective-C Call prior to [NewRelic startWithApplicationToken:...]; [NewRelic disableFeatures:NRFeatureFlag_CrashReporting]; Copy Swift Call prior to NewRelic.start(withApplicationToken:) NewRelic.disableFeatures(NRMAFeatureFlags.NRFeatureFlag_CrashReporting) Copy For more information about this call, see the NewRelic.h file. For more on applicable feature flags, see the NewRelicFeatureFlags.h file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.6604,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> and tvOS crash reporting",
        "sections": "<em>iOS</em> and tvOS crash reporting",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "For agent version 4 or higher, <em>New</em> <em>Relic</em> produces crash reports for your <em>mobile</em> applications. When an <em>iOS</em> or tv<em>OS</em> application crashes, the operating system creates a crash report and stores it on the device. <em>New</em> <em>Relic</em> uploads this report the next time the app launches. Using this report and any"
      },
      "id": "603ec58128ccbc9b51eba7d2"
    },
    {
      "sections": [
        "iOS agent configuration and feature flags",
        "Enable or disable feature flags",
        "Crash and error reporting feature flag",
        "NRFeatureFlag_CrashReporting",
        "NRFeatureFlag_HandledExceptionEvents",
        "Distributed tracing",
        "NRFeatureFlag_DistributedTracing",
        "Interactions feature flags",
        "NRFeatureFlag_DefaultInteractions",
        "NRFeatureFlag_InteractionTracing",
        "NRFeatureFlag_SwiftInteractionTracing",
        "Caution",
        "Networking feature flags",
        "NRFeatureFlag_ExperimentalNetworkingInstrumentation",
        "NRFeatureFlag_NSURLSessionInstrumentation",
        "NRFeatureFlag_NetworkRequestEvents",
        "NRFeatureFlag_RequestErrorEvents",
        "NRFeatureFlag_HttpResponseBodyCapture"
      ],
      "title": "iOS agent configuration and feature flags",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "8ced2dac1fbc45a65d6cdca6b27a4db001d6a4db",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/api-guides/ios-agent-configuration-feature-flags/",
      "published_at": "2021-09-14T08:11:52Z",
      "updated_at": "2021-07-09T14:31:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's iOS agent provides configuration settings to change the default behavior of the agent. If used, implement these flags just before calling: Objective-C: +[NewRelic startWithApplicationToken:] Swift: NewRelic.start(withApplicationToken:) Enable or disable feature flags To configure feature flags, use the following method defined in NewRelic.h: iOS language Procedure Objective-C In Objective-C, these features are bitmasked, so you can use a | to enable or disable multiple features at the same time. Enable a feature flag: +[NewRelic enableFeatures:(NRMAFeatureFlags)flags]; Copy Disable a feature flag: +[NewRelic disableFeatures:(NRMAFeatureFlags)flags]; Copy Here is an example where: Interaction tracing and experimental networking instrumentation are enabled. NSURLSession instrumentation and crash reporting are disabled. [NewRelic enableFeatures:NRFeatureFlag_SwiftInteractionTracing | NRFeatureFlag_ExperimentalNetworkingInstrumentation]; [NewRelic disableFeatures:NRFeatureFlag_NSURLSessionInstrumentation | NRFeatureFlag_CrashReporting]; [NewRelic startWithApplicationToken:...]; Copy Swift Enable a feature flag: NewRelic.enableFeatures(NRMAFeatureFlags.[NRMAFeatureFlag]) Copy Disable a feature flag: NewRelic.disableFeatures(NRMAFeatureFlags.[NRMAFeatureFlag]) Copy Example to disable interaction tracing: NewRelic.disableFeatures(NRMAFeatureFlags.NRFeatureFlag_DefaultInteractions) Copy Crash and error reporting feature flag If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_CrashReporting Enable (default) or disable crash reporting, which appears on the Crash analysis page. Type Boolean Default true NRFeatureFlag_HandledExceptionEvents Globally enable (default) or disable recording handled exceptions events, which appear on the Handled exception page. Type Boolean Default true Distributed tracing NRFeatureFlag_DistributedTracing Enable or disable the adding of distributed tracing headers to network requests. Refer to How New Relic distributed tracing works for more information on distributed tracing in mobile apps. Type Boolean Default true Interactions feature flags If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_DefaultInteractions Enable (default) or disable interaction tracing only for default instrumented classes and methods. Custom interactions will be reported. The traces will appear on the Interactions page. Type Boolean Default true NRFeatureFlag_InteractionTracing Globally enable (default) or disable interaction traces, which appear on the Interactions page. Interaction tracing will be disabled after the agent has started. Interactions for any activity or methods executed prior to starting the agent may still appear on the Interactions page. Type Boolean Default true NRFeatureFlag_SwiftInteractionTracing Caution Before enabling this feature, see Enable Swift interaction traces. If proper steps are not taken, enabling this feature may cause instability. Enable or disable (default) interaction tracing for Swift code. The traces appear on the Interactions page. This feature will always be disabled if NRFeatureFlag_InteractionTracing is disabled. Type Boolean Default false Networking feature flags If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_ExperimentalNetworkingInstrumentation Caution Enabling this feature flag call may decrease the stability of applications. Avoid using unless instructed by New Relic. Enable or disable (default) experimental networking instrumentation. This forces all NSURLConnection network requests through the NRMAURProtocol. Type Boolean Default false NRFeatureFlag_NSURLSessionInstrumentation Enable (default) or disable networking instrumentation for NSURLSession. These URL traces are sent to the HTTP Requests page. Type Boolean Default true NRFeatureFlag_NetworkRequestEvents Enable or disable (default) networking instrumentation. This sends the HTTP response data as MobileRequest events. Available for iOS Agent version 5.14.0 and higher Type Boolean Default true - Enabled by default as of 6.0.0 NRFeatureFlag_RequestErrorEvents Enable (default) or disable HTTP request error event generation of instrumented network calls that result in an error or failure. These events are reported as MobileRequestError events. Available for iOS Agent version 5.11.0 and higher Type Boolean Default true NRFeatureFlag_HttpResponseBodyCapture Enable or disable capture of HTTP response bodies for HTTP error traces, and MobileRequestError events. Type Boolean Default true",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.62509,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> agent <em>configuration</em> and feature flags",
        "sections": "<em>iOS</em> agent <em>configuration</em> and feature flags",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> agent provides <em>configuration</em> settings to change the default behavior of the agent. If used, implement these flags just before calling: Objective-C: +[<em>NewRelic</em> startWithApplicationToken:] Swift: <em>NewRelic</em>.start(withApplicationToken:) Enable or disable feature flags To configure"
      },
      "id": "60441925196a67324d960f1b"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios": [
    {
      "sections": [
        "CocoaPods installation",
        "Install your iOS application",
        "Configure using Objective-C",
        "Important",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "9a062745f628f66e34f865a47d58713f12e59ac9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/cocoapods-installation/",
      "published_at": "2021-09-14T14:28:11Z",
      "updated_at": "2021-07-27T15:09:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply to iOS apps using Cocoapods. For other types, see iOS installation and configuration. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps list, select Add a new app. From the Get Started page, select iOS as the platform for mobile monitoring. Type a name for your mobile app, then select Continue. Continue with the steps to configure New Relic for mobile monitoring. Configure using Objective-C These procedures to configure your iOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your APP_NAME-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: [NewRelic startWithApplicationToken:@\"APP_TOKEN\"]; Copy Important The agent must be on the first line of didFinishLaunchingWithOptions and run on the main thread to ensure proper instrumentation. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Configure using Swift These procedures to configure your iOS app with CocoaPods and Swift also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your APP_NAME-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: NewRelic.start(withApplicationToken:\"APP_TOKEN\") Copy Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling NewRelic.start(withApplicationToken): [NRLogger setLogLevels:NRLogLevelALL]; Copy For Swift apps: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.89923,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods <em>installation</em>",
        "sections": "<em>Install</em> your <em>iOS</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps list, select Add a <em>new</em> app. From the <em>Get</em> <em>Started</em> page, select <em>iOS</em> as the platform for <em>mobile</em> <em>monitoring</em>. Type a name for your <em>mobile</em> app, then select Continue"
      },
      "id": "603ea15d64441fef3d4e8867"
    },
    {
      "sections": [
        "CocoaPods for tvOS installation and configuration",
        "Install your tvOS application",
        "Configure using Objective-C",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods for tvOS installation and configuration",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "dd8c9ed16a980b08c67150dada56e129900202bd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/cocoapods-tvos-installation-configuration/",
      "published_at": "2021-09-14T07:52:30Z",
      "updated_at": "2021-07-21T20:49:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply only to tvOS apps using Cocoapods. For all other types of tvOS apps, see tvOS installation and configuration. Install your tvOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: Select Add more data, select XCFramework. From the drawer, select the New Relic account you would like to add your tvOS application to, and select Continue. Type a name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring. Configure using Objective-C These procedures to configure your tvOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your [app_name]-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions: [NewRelicAgent startWithApplicationToken:@\"<appToken>\"]; Copy Add a build script to your target's Build Phases and paste the following, replacing \"PUT_NEW_RELIC_APP_TOKEN_HERE\" with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/bash \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, then run it in the simulator or other device. Within a few minutes you will begin to see data for your app: Go to one.newrelic.com > Mobile > (select an app). Configure using Swift These procedures to configure your tvOS app with CocoaPods and Swift are also available on the Get Started page in the mobile monitoring UI: In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your [ app_name]-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions: NewRelic.startWithApplicationToken(\"<appToken>\"); Copy Add a build script to your target's Build Phases and paste the following, replacing NEW_RELIC_APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/bash \"${SCRIPT}\" NEW_RELIC_APP_TOKEN Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling startWithApplicationToken: [NRLogger setLogLevels:NRLogLevelALL]; Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.46858,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods for tvOS <em>installation</em> and configuration",
        "sections": "CocoaPods for tvOS <em>installation</em> and configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " for authenticating each <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: Select Add more data, select XCFramework. From the drawer, select the <em>New</em> <em>Relic</em> account you would like to add your tv<em>OS</em> application to, and select"
      },
      "id": "60441ac6196a6710e4960f57"
    },
    {
      "sections": [
        "tvOS installation and configuration",
        "Tip",
        "Installing your tvOS application",
        "Configuring your tvOS application",
        "Executing a demo crash (optional)",
        "Changing the logging level (optional)"
      ],
      "title": "tvOS installation and configuration",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "04798a275a7591bfbafb5437194cfbab4b33d8e3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/tvos-installation-configuration/",
      "published_at": "2021-09-14T14:32:10Z",
      "updated_at": "2021-07-09T10:39:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to install and configure the tvOS agent. Tip tvOS apps using Cocoapods have separate installation procedures. Installing your tvOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor. For Admins with existing New Relic accounts, follow these steps to install and configure your application. (If you don't have a New Relic account, signup at newrelic.com/signup—it's free, forever.) Go to one.newrelic.com and click Mobile. If applicable: From the Mobile Apps list, select Add a new app From the Get Started page, select tvOS as the platform for mobile monitoring. Type a name for your mobile app, and select Continue. Configuring your tvOS application These procedures to configure your tvOS app are also available on the Get Started page in the mobile monitoring UI. Download and unzip the tvOS SDK. To add the New Relic tvOS Mobile Framework to your Xcode project: Use Finder to drag the NewRelicAgentTVOS.framework folder into your Xcode project, and drop it onto your Project in the Project Navigator window. Follow the prompts to copy items into destination and to create folder references. Add the SystemConfiguration.framework, libc++.tbd, and libz.tbd libraries to your Linker settings. To start the agent: Import the tvOS agent header at the top of your prefix.pch. Add + [ NewRelic startWithApplicationToken: < appToken>] to the top of -application:didFinishLaunchingWithOptions: in your AppDelegate.m using the unique application token that is automatically generated. Add a build script to your target's Build Phases and paste the following, replacing PUT_NEW_RELIC_APP_TOKEN_HERE with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, and then run it in the simulator or other device. Within a few minutes you will begin to see data for your iOS app: Go to one.newrelic.com > Mobile > (selected app). If you don't, see No data appears. Executing a demo crash (optional) If you have trouble getting your app to crash, the New Relic agent provides an API to execute a demo crash. Recommendation: Add one of these lines of code to a button click event handler as applicable: [NewRelic crashNow]; Copy OR [NewRelic crashNow:@\"<reason>\"]; Copy Changing the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling startWithApplicationToken: [NRLogger setLogLevels:NRLogLevelALL]; Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.3445,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "tvOS <em>installation</em> and configuration",
        "sections": "tvOS <em>installation</em> and configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": ". If applicable: From the <em>Mobile</em> Apps list, select Add a <em>new</em> app From the <em>Get</em> <em>Started</em> page, select tv<em>OS</em> as the platform for <em>mobile</em> <em>monitoring</em>. Type a name for your <em>mobile</em> app, and select Continue. Configuring your tv<em>OS</em> application These procedures to configure your tv<em>OS</em> app are also available on the <em>Get</em>"
      },
      "id": "60441ac5e7b9d26bb55799b6"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/get-started/new-relic-ios-compatibility-requirements": [
    {
      "sections": [
        "CocoaPods installation",
        "Install your iOS application",
        "Configure using Objective-C",
        "Important",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "9a062745f628f66e34f865a47d58713f12e59ac9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/cocoapods-installation/",
      "published_at": "2021-09-14T14:28:11Z",
      "updated_at": "2021-07-27T15:09:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply to iOS apps using Cocoapods. For other types, see iOS installation and configuration. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps list, select Add a new app. From the Get Started page, select iOS as the platform for mobile monitoring. Type a name for your mobile app, then select Continue. Continue with the steps to configure New Relic for mobile monitoring. Configure using Objective-C These procedures to configure your iOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your APP_NAME-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: [NewRelic startWithApplicationToken:@\"APP_TOKEN\"]; Copy Important The agent must be on the first line of didFinishLaunchingWithOptions and run on the main thread to ensure proper instrumentation. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Configure using Swift These procedures to configure your iOS app with CocoaPods and Swift also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your APP_NAME-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: NewRelic.start(withApplicationToken:\"APP_TOKEN\") Copy Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling NewRelic.start(withApplicationToken): [NRLogger setLogLevels:NRLogLevelALL]; Copy For Swift apps: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.89923,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods <em>installation</em>",
        "sections": "<em>Install</em> your <em>iOS</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps list, select Add a <em>new</em> app. From the <em>Get</em> <em>Started</em> page, select <em>iOS</em> as the platform for <em>mobile</em> <em>monitoring</em>. Type a name for your <em>mobile</em> app, then select Continue"
      },
      "id": "603ea15d64441fef3d4e8867"
    },
    {
      "sections": [
        "CocoaPods for tvOS installation and configuration",
        "Install your tvOS application",
        "Configure using Objective-C",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods for tvOS installation and configuration",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "dd8c9ed16a980b08c67150dada56e129900202bd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/cocoapods-tvos-installation-configuration/",
      "published_at": "2021-09-14T07:52:30Z",
      "updated_at": "2021-07-21T20:49:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply only to tvOS apps using Cocoapods. For all other types of tvOS apps, see tvOS installation and configuration. Install your tvOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: Select Add more data, select XCFramework. From the drawer, select the New Relic account you would like to add your tvOS application to, and select Continue. Type a name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring. Configure using Objective-C These procedures to configure your tvOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your [app_name]-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions: [NewRelicAgent startWithApplicationToken:@\"<appToken>\"]; Copy Add a build script to your target's Build Phases and paste the following, replacing \"PUT_NEW_RELIC_APP_TOKEN_HERE\" with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/bash \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, then run it in the simulator or other device. Within a few minutes you will begin to see data for your app: Go to one.newrelic.com > Mobile > (select an app). Configure using Swift These procedures to configure your tvOS app with CocoaPods and Swift are also available on the Get Started page in the mobile monitoring UI: In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your [ app_name]-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions: NewRelic.startWithApplicationToken(\"<appToken>\"); Copy Add a build script to your target's Build Phases and paste the following, replacing NEW_RELIC_APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/bash \"${SCRIPT}\" NEW_RELIC_APP_TOKEN Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling startWithApplicationToken: [NRLogger setLogLevels:NRLogLevelALL]; Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.46857,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods for tvOS <em>installation</em> and configuration",
        "sections": "CocoaPods for tvOS <em>installation</em> and configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " for authenticating each <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: Select Add more data, select XCFramework. From the drawer, select the <em>New</em> <em>Relic</em> account you would like to add your tv<em>OS</em> application to, and select"
      },
      "id": "60441ac6196a6710e4960f57"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-09-14T14:28:12Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.4934,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/installation/cocoapods-installation": [
    {
      "sections": [
        "iOS manual installation",
        "Install your iOS application",
        "Add the New Relic framework to your app",
        "Important",
        "Optional: Execute a demo crash",
        "Optional: Change the logging level"
      ],
      "title": "iOS manual installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "0a674eb7f3756cd5d124c6dcf2344edf38e40a8a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/ios-manual-installation/",
      "published_at": "2021-09-14T14:29:01Z",
      "updated_at": "2021-07-27T15:09:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To install and configure New Relic functionality with your iOS applications, follow these procedures. If your iOS app uses Cocoapods, follow the Cocoapods installation procedures. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps index, select Add a new app. From the Get started page, select XCFramework as the platform for mobile monitoring. Type a name for your mobile app, and select Continue. Continue with the steps to configure New Relic. Add the New Relic framework to your app Download and unzip the iOS SDK for New Relic. To add the New Relic framework to your Xcode project: Use Finder to drag the NewRelicAgent.framework folder into your Xcode project, and drop it onto your project in the Project navigator window, under Frameworks, Libraries, and Embedded Content. Make sure Embed & Sign is selected under the Embed dropdown menu. Implement the agent using the appropriate method: Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Language Procedure Objective-C To start the agent: Import the New Relic header at the top of your prefix.pch. Add +[NewRelic startWithApplicationToken:@\"<appToken>\"] to the top of -application:didFinishLaunchingWithOptions: in your AppDelegate.m, using the unique application token that is automatically generated. Swift Create a bridging header file: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. Delete Placeholder.m. Import the New Relic agent by adding #import \"NewRelic/NewRelic.h\" to the top of MyApp-Bridging-Header.h. Add NewRelic.start(withApplicationToken: \">appToken>\") to the top of application(_:didFinishLaunchingWithOptions:) in your AppDelegate.swift using the unique application token that is automatically generated. Add a build script to your target's Build Phases. Ensure the new build script is the very last build phase, then paste the following, replacing PUT_NEW_RELIC_APP_TOKEN_HERE with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, and then run it in the simulator or other device. Optional: Execute a demo crash If you have trouble getting your app to crash, the New Relic agent provides an API to execute a demo crash. Recommendation: Add one of these lines of code to a button click event handler as applicable: Language Code Objective-C Crash: [NewRelic crashNow]; Copy Crash with log message: [NewRelic crashNow:@\"<reason>\"]; Copy Swift Crash: NewRelic.crashNow() Copy Crash with log message: NewRelic.crashNow(_ message:) Copy Optional: Change the logging level Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add the following method: Language Code Objective-C Just before calling startWithApplicationToken in AppDelegate.m, add: [NRLogger setLogLevels:NRLogLevelALL]; Copy Swift Just before calling start(withApplicationToken:) in AppDelegate.swift, add: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.12917,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> manual <em>installation</em>",
        "sections": "<em>iOS</em> manual <em>installation</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " token. This is a 40-character hexadecimal string for authenticating each <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps index, select Add a <em>new</em> app. From the Get started page, select XCFramework"
      },
      "id": "603ea44864441f80904e8899"
    },
    {
      "sections": [
        "Upgrade the iOS agent",
        "Replace your iOS framework"
      ],
      "title": "Upgrade the iOS agent",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "f51e93fbddfa6fd7b531f2b8dc071cfebb8c7fc9",
      "image": "https://docs.newrelic.com/static/ce6f593163d7f9a6c7a72509d4d947bd/8c557/screen-mobile-monitoring-upgrade-ios_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/upgrade-new-relic-mobiles-ios-sdk/",
      "published_at": "2021-09-14T14:30:03Z",
      "updated_at": "2021-07-09T14:20:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You must be an account Admin to install, configure, and upgrade the iOS agent. For information about the latest version, refer to the release notes. Replace your iOS framework Admins: You must replace the earlier version of your iOS agent framework before upgrading to a newer version of the iOS SDK. Here is an example of the workflow to remove your existing iOS agent framework so you can replace it with a newer version. From the Project Navigator (CMD 1) in Xcode, search for NewRelicAgent.framework. Right-click or control-click NewRelicAgent.framework, and select Show in Finder. Drag NewRelicAgent.framework to the trash. Verify that the Xcode project highlights the reference to NewRelicAgent.framework in red. Right-click or control-click NewRelicAgent.framework, and select Delete to remove the obsolete reference from the project. Continue with the standard installation procedures for iOS app monitoring at one.newrelic.com > Mobile > (select an app) > Settings > Installation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.86787,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upgrade the <em>iOS</em> agent",
        "sections": "Upgrade the <em>iOS</em> agent",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>NewRelic</em>Agent.framework to the trash. Verify that the Xcode project highlights the reference to <em>NewRelic</em>Agent.framework in red. Right-click or control-click <em>NewRelic</em>Agent.framework, and select Delete to remove the obsolete reference from the project. Continue with the standard <em>installation</em> procedures for <em>iOS</em> app <em>monitoring</em> at one.newrelic.com &gt; <em>Mobile</em> &gt; (select an app) &gt; Settings &gt; <em>Installation</em>."
      },
      "id": "603eab6a196a672442a83da7"
    },
    {
      "sections": [
        "CocoaPods for tvOS installation and configuration",
        "Install your tvOS application",
        "Configure using Objective-C",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods for tvOS installation and configuration",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "dd8c9ed16a980b08c67150dada56e129900202bd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/cocoapods-tvos-installation-configuration/",
      "published_at": "2021-09-14T07:52:30Z",
      "updated_at": "2021-07-21T20:49:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply only to tvOS apps using Cocoapods. For all other types of tvOS apps, see tvOS installation and configuration. Install your tvOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: Select Add more data, select XCFramework. From the drawer, select the New Relic account you would like to add your tvOS application to, and select Continue. Type a name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring. Configure using Objective-C These procedures to configure your tvOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your [app_name]-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions: [NewRelicAgent startWithApplicationToken:@\"<appToken>\"]; Copy Add a build script to your target's Build Phases and paste the following, replacing \"PUT_NEW_RELIC_APP_TOKEN_HERE\" with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/bash \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, then run it in the simulator or other device. Within a few minutes you will begin to see data for your app: Go to one.newrelic.com > Mobile > (select an app). Configure using Swift These procedures to configure your tvOS app with CocoaPods and Swift are also available on the Get Started page in the mobile monitoring UI: In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your [ app_name]-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions: NewRelic.startWithApplicationToken(\"<appToken>\"); Copy Add a build script to your target's Build Phases and paste the following, replacing NEW_RELIC_APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/bash \"${SCRIPT}\" NEW_RELIC_APP_TOKEN Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling startWithApplicationToken: [NRLogger setLogLevels:NRLogLevelALL]; Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.16899,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods for tvOS <em>installation</em> and configuration",
        "sections": "CocoaPods for tvOS <em>installation</em> and configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " for authenticating each <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: Select Add more data, select XCFramework. From the drawer, select the <em>New</em> <em>Relic</em> account you would like to add your tv<em>OS</em> application to, and select"
      },
      "id": "60441ac6196a6710e4960f57"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/installation/ios-manual-installation": [
    {
      "sections": [
        "CocoaPods installation",
        "Install your iOS application",
        "Configure using Objective-C",
        "Important",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "9a062745f628f66e34f865a47d58713f12e59ac9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/cocoapods-installation/",
      "published_at": "2021-09-14T14:28:11Z",
      "updated_at": "2021-07-27T15:09:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply to iOS apps using Cocoapods. For other types, see iOS installation and configuration. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps list, select Add a new app. From the Get Started page, select iOS as the platform for mobile monitoring. Type a name for your mobile app, then select Continue. Continue with the steps to configure New Relic for mobile monitoring. Configure using Objective-C These procedures to configure your iOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your APP_NAME-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: [NewRelic startWithApplicationToken:@\"APP_TOKEN\"]; Copy Important The agent must be on the first line of didFinishLaunchingWithOptions and run on the main thread to ensure proper instrumentation. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Configure using Swift These procedures to configure your iOS app with CocoaPods and Swift also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your APP_NAME-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: NewRelic.start(withApplicationToken:\"APP_TOKEN\") Copy Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling NewRelic.start(withApplicationToken): [NRLogger setLogLevels:NRLogLevelALL]; Copy For Swift apps: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.12917,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods <em>installation</em>",
        "sections": "<em>Install</em> your <em>iOS</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps list, select Add a <em>new</em> app. From the Get Started page, select <em>iOS</em> as the platform for <em>mobile</em> <em>monitoring</em>. Type a name for your <em>mobile</em> app, then select Continue"
      },
      "id": "603ea15d64441fef3d4e8867"
    },
    {
      "sections": [
        "Upgrade the iOS agent",
        "Replace your iOS framework"
      ],
      "title": "Upgrade the iOS agent",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "f51e93fbddfa6fd7b531f2b8dc071cfebb8c7fc9",
      "image": "https://docs.newrelic.com/static/ce6f593163d7f9a6c7a72509d4d947bd/8c557/screen-mobile-monitoring-upgrade-ios_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/upgrade-new-relic-mobiles-ios-sdk/",
      "published_at": "2021-09-14T14:30:03Z",
      "updated_at": "2021-07-09T14:20:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You must be an account Admin to install, configure, and upgrade the iOS agent. For information about the latest version, refer to the release notes. Replace your iOS framework Admins: You must replace the earlier version of your iOS agent framework before upgrading to a newer version of the iOS SDK. Here is an example of the workflow to remove your existing iOS agent framework so you can replace it with a newer version. From the Project Navigator (CMD 1) in Xcode, search for NewRelicAgent.framework. Right-click or control-click NewRelicAgent.framework, and select Show in Finder. Drag NewRelicAgent.framework to the trash. Verify that the Xcode project highlights the reference to NewRelicAgent.framework in red. Right-click or control-click NewRelicAgent.framework, and select Delete to remove the obsolete reference from the project. Continue with the standard installation procedures for iOS app monitoring at one.newrelic.com > Mobile > (select an app) > Settings > Installation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.86787,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upgrade the <em>iOS</em> agent",
        "sections": "Upgrade the <em>iOS</em> agent",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>NewRelic</em>Agent.framework to the trash. Verify that the Xcode project highlights the reference to <em>NewRelic</em>Agent.framework in red. Right-click or control-click <em>NewRelic</em>Agent.framework, and select Delete to remove the obsolete reference from the project. Continue with the standard <em>installation</em> procedures for <em>iOS</em> app <em>monitoring</em> at one.newrelic.com &gt; <em>Mobile</em> &gt; (select an app) &gt; Settings &gt; <em>Installation</em>."
      },
      "id": "603eab6a196a672442a83da7"
    },
    {
      "sections": [
        "CocoaPods for tvOS installation and configuration",
        "Install your tvOS application",
        "Configure using Objective-C",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods for tvOS installation and configuration",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "dd8c9ed16a980b08c67150dada56e129900202bd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/cocoapods-tvos-installation-configuration/",
      "published_at": "2021-09-14T07:52:30Z",
      "updated_at": "2021-07-21T20:49:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply only to tvOS apps using Cocoapods. For all other types of tvOS apps, see tvOS installation and configuration. Install your tvOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: Select Add more data, select XCFramework. From the drawer, select the New Relic account you would like to add your tvOS application to, and select Continue. Type a name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring. Configure using Objective-C These procedures to configure your tvOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your [app_name]-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions: [NewRelicAgent startWithApplicationToken:@\"<appToken>\"]; Copy Add a build script to your target's Build Phases and paste the following, replacing \"PUT_NEW_RELIC_APP_TOKEN_HERE\" with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/bash \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, then run it in the simulator or other device. Within a few minutes you will begin to see data for your app: Go to one.newrelic.com > Mobile > (select an app). Configure using Swift These procedures to configure your tvOS app with CocoaPods and Swift are also available on the Get Started page in the mobile monitoring UI: In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your [ app_name]-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions: NewRelic.startWithApplicationToken(\"<appToken>\"); Copy Add a build script to your target's Build Phases and paste the following, replacing NEW_RELIC_APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/bash \"${SCRIPT}\" NEW_RELIC_APP_TOKEN Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling startWithApplicationToken: [NRLogger setLogLevels:NRLogLevelALL]; Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.16898,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods for tvOS <em>installation</em> and configuration",
        "sections": "CocoaPods for tvOS <em>installation</em> and configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " for authenticating each <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: Select Add more data, select XCFramework. From the drawer, select the <em>New</em> <em>Relic</em> account you would like to add your tv<em>OS</em> application to, and select"
      },
      "id": "60441ac6196a6710e4960f57"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/installation/spm-installation": [
    {
      "sections": [
        "No data appears (Infrastructure)",
        "Problem",
        "Solution",
        "Important",
        "Missing infrastructure data",
        "Verify install for apt (Debian or Ubuntu)",
        "Verify install for yum (Amazon Linux, CentOS, or RHEL)",
        "Verify install for Windows Server",
        "Verify status with SystemD",
        "Verify status with System V",
        "Verify status with Upstart",
        "Verify status with Windows",
        "Missing integration data"
      ],
      "title": "No data appears (Infrastructure)",
      "type": "docs",
      "tags": [
        "Infrastructure",
        "Infrastructure monitoring troubleshooting",
        "Troubleshoot infrastructure"
      ],
      "external_id": "fd618376814a1ec7b486c00e524b0203bbfa0e09",
      "image": "",
      "url": "https://docs.newrelic.com/docs/infrastructure/infrastructure-troubleshooting/troubleshoot-infrastructure/no-data-appears-infrastructure/",
      "published_at": "2021-09-14T05:43:13Z",
      "updated_at": "2021-09-14T05:43:13Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You installed the New Relic infrastructure agent and waited a few minutes, but no data appears in the Infrastructure UI. Solution Data should appear in the Infrastructure monitoring UI within a few minutes for accounts with previously installed agents. Important For accounts installing the infrastructure agent for the first time, the latency for data appearing in the Infrastructure monitoring UI can be tens of minutes. If the following steps verify the installation and no obvious error conditions appear in the verbose logs, monitor the Infrastructure UI for a longer period before contacting support.newrelic.com for assistance. Important By default, the infrastructure agent doesn't send data about the operating system's processes. To enable the sending of process data set enable_process_metrics to true. To fine-tune which processes you want to monitor, configure include_matching_metrics. Missing infrastructure data If no data appears in the UI, try the following steps to diagnose the problem: Use your package manager to verify that the infrastructure agent is installed: Verify install for apt (Debian or Ubuntu) Use dpkg to verify that the agent is installed: dpkg -l | grep newrelic-infra Copy If dpkg returns no output, see Install with apt. Verify install for yum (Amazon Linux, CentOS, or RHEL) Use rpm to verify that agent is installed: rpm -qa | grep newrelic-infra Copy If rpm returns no output, see Install with yum. Verify install for Windows Server Use the Windows command prompt or Powershell to verify that the agent directory exists: dir \"C:\\Program Files\\New Relic\\newrelic-infra\" Copy If you receive a File not found error, see Install for Windows Server. Use your init system to verify that the agent is running: Verify status with SystemD Use SystemD commands with CentOS 7, Debian 8, RHEL 7, and Ubuntu 15.04 or higher: Check that the agent is running: sudo systemctl status newrelic-infra Copy If the agent isn't running, start the agent manually: sudo systemctl start newrelic-infra Copy Verify status with System V Use System V commands with Debian 7: Check that the agent is running: sudo /etc/init.d/newrelic-infra status Copy If the agent isn't running, start the agent manually: sudo /etc/init.d/newrelic-infra start Copy Verify status with Upstart Use Upstart commands with Amazon Linux, CentOS 6, RHEL 6, and Ubuntu 14.10 or lower: Check that the agent is running: sudo initctl status newrelic-infra Copy If the agent isn't running, start the agent manually: sudo initctl start newrelic-infra Copy Verify status with Windows Use the Windows command prompt: Check that the agent is running: sc query \"newrelic-infra\" | find \"RUNNING\" Copy If the agent isn't running, start the agent manually with the Windows command prompt: net start newrelic-infra Copy If running net start newrelic-infra returns The service name is invalid, the Infrastructure agent may not have been installed correctly and the service was not properly created. To test this: From Powershell, run the command get-service newrelic-infra, which will return the status of the service. If it returns an error Cannot find any service with service name newrelic-infra, then follow standard procedures to reinstall the agent. Use New Relic Diagnostics to try to automatically identify the issue. Verify that your newrelic-infra.yml configuration file contains a valid license_key setting. Verify that the host has a unique hostname, and verify that the hostname is not localhost. For more information, see this Explorers Hub post. Verify that no firewalls or proxies are blocking outbound connections from the agent process to the Infrastructure domains and ports. Confirm the host is reporting correctly even though it is not appearing in the Infrastructure monitoring UI by creating a basic query in Insights, like: SELECT * FROM SystemSample SINCE 60 minutes ago LIMIT 100 Copy Use the query results to note the timestamps, which show when the data was reported. To determine when data was first received, look at the earliest timestamp. Generate verbose logs and examine the logs for errors. Missing integration data If you are missing data from an integration, see troubleshooting procedures for: APM data missing from infrastructure monitoring Amazon/AWS integrations On-host integrations",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.42885,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Verify <em>install</em> for apt (Debian or Ubuntu)",
        "body": " include_matching_metrics. Missing infrastructure data If no data appears in the UI, try the following steps to diagnose the problem: Use your <em>package</em> <em>manager</em> to verify that the infrastructure agent is installed: Verify install for apt (Debian or Ubuntu) Use dpkg to verify that the agent is installed: dpkg -l | grep"
      },
      "id": "603e90b9e7b9d26d8c2a07a9"
    },
    {
      "sections": [
        "Install the infrastructure monitoring agent for macOS",
        "Tip",
        "Install for macOS (Beta)",
        "Limitations (Beta)",
        "Step-by-step instructions",
        "Homebrew install",
        "What's next?",
        "Update the agent"
      ],
      "title": "Install the infrastructure monitoring agent for macOS",
      "type": "docs",
      "tags": [
        "Infrastructure",
        "Install the infrastructure agent",
        "macOS installation"
      ],
      "external_id": "755028024e9e2757dd8441cccb2adb1fd3aefdac",
      "image": "",
      "url": "https://docs.newrelic.com/docs/infrastructure/install-infrastructure-agent/macos-installation/install-infrastructure-monitoring-agent-macos/",
      "published_at": "2021-09-14T20:38:23Z",
      "updated_at": "2021-09-14T20:38:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's infrastructure monitoring agent for macOS (Beta), you can monitor key performance metrics on macOS hosts. The agent can run on your own hardware or in cloud systems such as Amazon EC2. The infrastructure monitoring agent is compatible with all generally available, Apple supported macOS versions. Tip To use infrastructure monitoring and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Install for macOS (Beta) Before installation, be sure to review the requirements. Then, to install the infrastructure monitoring agent for macOS, you can use our Guided Install, or follow the instructions in this document to complete a basic installation. Limitations (Beta) The following capabilities of the infrastructure agent are not yet available on macOS: Process Monitoring. Log forwarder. On-host integrations (including built-in integrations such as Docker and Flex). Automated deployment via Configuration Management tools (Chef, Ansible, Puppet). Step-by-step instructions To install the infrastructure monitoring agent, follow the step-by-step instructions: Homebrew install Review the agent requirements and supported operating systems. Make sure Homebrew is installed in the system. You can check if Homebrew is installed with: which brew Copy If it's not installed, you can install it with this command (or check Homebrew up-to-date instructions): /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" Copy Create the configuration file and add your license key: echo \"license_key: YOUR_LICENSE_KEY\" | sudo tee -a /usr/local/etc/newrelic-infra/newrelic-infra.yml Copy Then, open the terminal and run the following command: brew install newrelic/tap/newrelic-infra-agent -q Copy Start the infrastructure agent service: brew services start newrelic-infra-agent Copy Wait a few minutes, then view your server in the Infrastructure UI. If no data appears after waiting a few minutes, follow the troubleshooting steps. What's next? The only required configuration option is the license_key setting, which is created as part of the installation procedures. You may also want to: Add custom attributes to annotate your infrastructure data. Connect your AWS account if your servers are hosted on Amazon EC2. Add other New Relic infrastructure integrations to collect data from external services. Update the agent To upgrade to the latest version, follow standard procedures to update the infrastructure monitoring agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 232.66794,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the infrastructure monitoring agent for macOS",
        "sections": "<em>Install</em> the infrastructure monitoring agent for macOS",
        "tags": "macOS <em>installation</em>",
        "body": " macOS versions. Tip To use infrastructure monitoring and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Install for macOS (Beta) Before <em>installation</em>, be sure"
      },
      "id": "611fe66a28ccbc920ff9abfa"
    },
    {
      "sections": [
        "Nagios monitoring integration",
        "Compatibility and requirements",
        "Quick start",
        "Install and activate",
        "Linux installation",
        "Windows installation",
        "Configure the integration",
        "Nagios instance settings",
        "Service checks config file",
        "Labels/custom attributes",
        "Permissions",
        "Linux permissions",
        "Windows permissions",
        "Example configurations",
        "Example nagios-config.yml configuration",
        "Example nagios-service-checks.yml configuration",
        "Find and use data",
        "Metric data",
        "Nagios service check sample metrics",
        "Troubleshooting",
        "Config parsing failed error",
        "Solution:",
        "Cause:",
        "Check the source code"
      ],
      "title": "Nagios monitoring integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "On-host integrations",
        "On-host integrations list"
      ],
      "external_id": "98062fcf3378e6a1b075d73961c457be1f2b3e16",
      "image": "https://docs.newrelic.com/static/6bf45ccf002250f7ebaa69cbe3ff706c/c1b63/guided-install-cli.png",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/host-integrations-list/nagios-monitoring-integration/",
      "published_at": "2021-09-14T20:51:21Z",
      "updated_at": "2021-09-14T20:51:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Nagios integration lets you use your service checks directly, without the need to run a Nagios instance. Read on to install the integration, and to see what data we collect. Compatibility and requirements Our integration is compatible with any existing service that conform to the Nagios Plugin API. Before installing the integration, make sure that you meet the following requirements: Install the infrastructure agent. Linux distribution or Windows OS version compatible with New Relic's infrastructure agent. Quick start Instrument your Nagios instance quickly and send your telemetry data with guided install. Our guided install creates a customized CLI command for your environment that downloads and installs the New Relic CLI and the infrastructure agent. Ready to get started? Click one of these buttons to try it out. Guided install EU Guided install Install and activate To install the Nagios integration: Linux installation Follow the instructions for installing an integration, using the file name nri-nagios. Change directory to the integrations folder: cd /etc/newrelic-infra/integrations.d Copy Copy of the sample configuration file: sudo cp nagios-config.yml.sample nagios-config.yml Copy Create a copy of the sample service checks file by running: sudo cp nagios-service-checks.yml.sample nagios-service-checks.yml Copy Edit the nagios-config.yml file as described in the configuration settings. Restart the infrastructure agent. Windows installation Download the nri-nagios .MSI installer image from: http://download.newrelic.com/infrastructure_agent/windows/integrations/nri-nagios/nri-nagios-amd64.msi To install from the Windows command prompt, run: msiexec.exe /qn /i PATH\\TO\\nri-nagios-amd64.msi Copy In the Integrations directory, C:\\Program Files\\New Relic\\newrelic-infra\\integrations.d\\, create a copy of the sample configuration file by running: cp nagios-config.yml.sample nagios-config.yml Copy Edit the nagios-config.yml file as described in the configuration settings. In the Integrations directory, C:\\Program Files\\New Relic\\newrelic-infra\\integrations.d\\, create a nagios-service-checks.yml file that describes the service checks to be run by the integration. For an example configuration, see the example service checks file. Restart the infrastructure agent. Additional notes: Advanced: It's also possible to install the integration from a tarball file. This gives you full control over the installation and configuration process. On-host integrations do not automatically update. For best results, regularly update the integration package and the Infrastructure agent. Configure the integration An integration's YAML-format configuration is where you can place required login credentials and configure how data is collected. Which options you change depend on your setup and preference. For example configurations, see the nagios-config.yml and nagios-service-checks.yml examples. Our configuration files have common settings used in all of our integrations, such as interval, timeout, andinventory_source, among others. For more on these common settings, see this list of configuration properties. Specific settings related to Nagios are defined using the env section of the configuration file. These settings control the connection to your Nagios instance as well as other security settings and features. Nagios instance settings Setting Description Default SERVICE_CHECKS_CONFIG This points to a yaml file containing definitions of the service checks that will be run by the integration. Required. N/A CONCURRENCY The number of service checks to be run concurrently. 1 OUTPUT_TABLE_NAME The name of the table where the service check results are saved. NagiosServiceCheckSample Service checks config file The service_checks_config yaml file contains the top-level array service_checks. Each service check must contain both a name and a command. Key Description name The naming convention is not specific, and allows for easy recognition in the Infrastructure UI. command The command is an array of strings, with the first position containing the path to the executable and the remaining positions containing the arguments to the executable. labels A collection of key: value pairs which help to identify and group service checks in Insights. parse_output Attempts to parse the output of service checks that conform to the Nagios Plugin API spec. Default: false. These setting values can be defined in several ways: Add the values directly in the config file. Replace the values from environment variables using the {{}} notation. This requires Infrastructure agent v1.14.0+. Read more here. Use secrets management to protect sensible information, such as passwords, so that it's not exposed in plain text in the configuration file. For more information, see secrets management. Labels/custom attributes Environment variables can be used to control configuration settings, such as your license key, and are then passed to the Infrastructure agent. For instructions on how to use the passthrough feature, see configure the Infrastructure agent. You can also decorate your metrics using labels. Labels allow you to add key/value pair attributes to your metrics. You can use these labels to query, filter, or group your metrics. Our default sample config file includes examples with labels, you can remove, modify, or add new ones of your choice. labels: env: production role: nagios Copy Permissions Non-configurable commands are run by the infrastructure agent, which itself is run by the root user. For the integration to run properly, ensure that the permissions on the yaml file are appropriately restrictive as indicated below: Linux permissions Set the user permissions flag to 0600, restricting read and write privileges to the file owner. If permissions do not meet this requirement, an error will be logged and the integration will fail to run. Windows permissions By default, the agent and any commands in the yaml file run as an Administrator. As the integration is unable to check permissions, it is up to the user to appropriately restrict permissions for the file. Example configurations Example file configurations: Example nagios-config.yml configuration integrations: - name: nri-nagios env: CONCURRENCY: \"1\" SERVICE_CHECKS_CONFIG: /etc/newrelic-infra/integrations.d/nagios-service-checks.yml interval: 15s Copy Example nagios-service-checks.yml configuration service_checks: - name: check_users command: [\"/usr/local/nagios/libexec/check_users\", \"-w\", \"5\", \"-c\", \"10\"] parse_output: true labels: env: staging key1: val1 - name: check_yum command: [\"/usr/local/nagios/libexec/check_yum\"] Copy For more about the general structure of on-host integration configuration, see Configuration. Find and use data To find your integration data go to one.newrelic.com > Infrastructure > Third-party services and select one of the Nagios integration links. Nagios data is attached to the NagiosServiceCheckSample event type. For more on how to find and use your data, see Understand integration data. Metric data The Nagios integration collects the following metric data attributes. Nagios service check sample metrics These attributes can be found by querying the NagiosServiceCheckSample event types in Insights. Metric Description serviceCheck.command The command used to run the service check. serviceCheck.error The standard error (stderr) output of the service check. serviceCheck.longServiceOutput The portion of the message that is parsed by Nagios as $LONGSERVICEOUTPUT$. Only enabled if parse_output is set. serviceCheck.message The standard output (stdout) of the service check. serviceCheck.name The descriptive name of the service check being performed. serviceCheck.serviceOutput The portion of the message that is parsed by Nagios as $SERVICEOUTPUT$. Only enabled if parse_output is set. serviceCheck.status The return code of the service check. Options: 0 = Ok 1 = Warning 2 = Critical 3 = Unknown * Any additional metrics defined and reported by the service check. Only enabled if parse_output is set. Troubleshooting Troubleshooting tips: Config parsing failed error The following error appears in the log file: Config parsing failed: service checks file permissions are not restrictive enough. Required file permissions are 0600. See documentation for details Copy Solution: Set the user permissions flag to 0600, restricting read and write privileges to the file owner. Cause: If the file is not owned by the root user or the file can be written to by a user other than the root user, the integration will allow users to run arbitrary commands as though they are a root user. If permissions do not meet the requirement, an error will be logged and the integration will fail to run. Check the source code This integration is open source software. That means you can browse its source code and send improvements, or create your own fork and build it.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 230.04323,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Linux <em>installation</em>",
        "body": ". This gives you full control over the <em>installation</em> and configuration process. On-host integrations do not automatically update. For best results, regularly update the integration <em>package</em> and the Infrastructure agent. Configure the integration An integration&#x27;s YAML-format configuration is where you can"
      },
      "id": "603eb881e7b9d2728a2a07b5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/installation/upgrade-new-relic-mobiles-ios-sdk": [
    {
      "sections": [
        "iOS manual installation",
        "Install your iOS application",
        "Add the New Relic framework to your app",
        "Important",
        "Optional: Execute a demo crash",
        "Optional: Change the logging level"
      ],
      "title": "iOS manual installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "0a674eb7f3756cd5d124c6dcf2344edf38e40a8a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/ios-manual-installation/",
      "published_at": "2021-09-14T14:29:01Z",
      "updated_at": "2021-07-27T15:09:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To install and configure New Relic functionality with your iOS applications, follow these procedures. If your iOS app uses Cocoapods, follow the Cocoapods installation procedures. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps index, select Add a new app. From the Get started page, select XCFramework as the platform for mobile monitoring. Type a name for your mobile app, and select Continue. Continue with the steps to configure New Relic. Add the New Relic framework to your app Download and unzip the iOS SDK for New Relic. To add the New Relic framework to your Xcode project: Use Finder to drag the NewRelicAgent.framework folder into your Xcode project, and drop it onto your project in the Project navigator window, under Frameworks, Libraries, and Embedded Content. Make sure Embed & Sign is selected under the Embed dropdown menu. Implement the agent using the appropriate method: Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Language Procedure Objective-C To start the agent: Import the New Relic header at the top of your prefix.pch. Add +[NewRelic startWithApplicationToken:@\"<appToken>\"] to the top of -application:didFinishLaunchingWithOptions: in your AppDelegate.m, using the unique application token that is automatically generated. Swift Create a bridging header file: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. Delete Placeholder.m. Import the New Relic agent by adding #import \"NewRelic/NewRelic.h\" to the top of MyApp-Bridging-Header.h. Add NewRelic.start(withApplicationToken: \">appToken>\") to the top of application(_:didFinishLaunchingWithOptions:) in your AppDelegate.swift using the unique application token that is automatically generated. Add a build script to your target's Build Phases. Ensure the new build script is the very last build phase, then paste the following, replacing PUT_NEW_RELIC_APP_TOKEN_HERE with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, and then run it in the simulator or other device. Optional: Execute a demo crash If you have trouble getting your app to crash, the New Relic agent provides an API to execute a demo crash. Recommendation: Add one of these lines of code to a button click event handler as applicable: Language Code Objective-C Crash: [NewRelic crashNow]; Copy Crash with log message: [NewRelic crashNow:@\"<reason>\"]; Copy Swift Crash: NewRelic.crashNow() Copy Crash with log message: NewRelic.crashNow(_ message:) Copy Optional: Change the logging level Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add the following method: Language Code Objective-C Just before calling startWithApplicationToken in AppDelegate.m, add: [NRLogger setLogLevels:NRLogLevelALL]; Copy Swift Just before calling start(withApplicationToken:) in AppDelegate.swift, add: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.12917,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> manual <em>installation</em>",
        "sections": "<em>iOS</em> manual <em>installation</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " token. This is a 40-character hexadecimal string for authenticating each <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps index, select Add a <em>new</em> app. From the Get started page, select XCFramework"
      },
      "id": "603ea44864441f80904e8899"
    },
    {
      "sections": [
        "CocoaPods installation",
        "Install your iOS application",
        "Configure using Objective-C",
        "Important",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "9a062745f628f66e34f865a47d58713f12e59ac9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/cocoapods-installation/",
      "published_at": "2021-09-14T14:28:11Z",
      "updated_at": "2021-07-27T15:09:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply to iOS apps using Cocoapods. For other types, see iOS installation and configuration. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps list, select Add a new app. From the Get Started page, select iOS as the platform for mobile monitoring. Type a name for your mobile app, then select Continue. Continue with the steps to configure New Relic for mobile monitoring. Configure using Objective-C These procedures to configure your iOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your APP_NAME-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: [NewRelic startWithApplicationToken:@\"APP_TOKEN\"]; Copy Important The agent must be on the first line of didFinishLaunchingWithOptions and run on the main thread to ensure proper instrumentation. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Configure using Swift These procedures to configure your iOS app with CocoaPods and Swift also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your APP_NAME-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: NewRelic.start(withApplicationToken:\"APP_TOKEN\") Copy Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling NewRelic.start(withApplicationToken): [NRLogger setLogLevels:NRLogLevelALL]; Copy For Swift apps: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.12917,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods <em>installation</em>",
        "sections": "<em>Install</em> your <em>iOS</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps list, select Add a <em>new</em> app. From the Get Started page, select <em>iOS</em> as the platform for <em>mobile</em> <em>monitoring</em>. Type a name for your <em>mobile</em> app, then select Continue"
      },
      "id": "603ea15d64441fef3d4e8867"
    },
    {
      "sections": [
        "CocoaPods for tvOS installation and configuration",
        "Install your tvOS application",
        "Configure using Objective-C",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods for tvOS installation and configuration",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "dd8c9ed16a980b08c67150dada56e129900202bd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/cocoapods-tvos-installation-configuration/",
      "published_at": "2021-09-14T07:52:30Z",
      "updated_at": "2021-07-21T20:49:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply only to tvOS apps using Cocoapods. For all other types of tvOS apps, see tvOS installation and configuration. Install your tvOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: Select Add more data, select XCFramework. From the drawer, select the New Relic account you would like to add your tvOS application to, and select Continue. Type a name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring. Configure using Objective-C These procedures to configure your tvOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your [app_name]-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions: [NewRelicAgent startWithApplicationToken:@\"<appToken>\"]; Copy Add a build script to your target's Build Phases and paste the following, replacing \"PUT_NEW_RELIC_APP_TOKEN_HERE\" with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/bash \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, then run it in the simulator or other device. Within a few minutes you will begin to see data for your app: Go to one.newrelic.com > Mobile > (select an app). Configure using Swift These procedures to configure your tvOS app with CocoaPods and Swift are also available on the Get Started page in the mobile monitoring UI: In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your [ app_name]-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions: NewRelic.startWithApplicationToken(\"<appToken>\"); Copy Add a build script to your target's Build Phases and paste the following, replacing NEW_RELIC_APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/bash \"${SCRIPT}\" NEW_RELIC_APP_TOKEN Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling startWithApplicationToken: [NRLogger setLogLevels:NRLogLevelALL]; Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.168976,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods for tvOS <em>installation</em> and configuration",
        "sections": "CocoaPods for tvOS <em>installation</em> and configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " for authenticating each <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: Select Add more data, select XCFramework. From the drawer, select the <em>New</em> <em>Relic</em> account you would like to add your tv<em>OS</em> application to, and select"
      },
      "id": "60441ac6196a6710e4960f57"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/crashnow-ios-sdk-api": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-09-14T08:11:54Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 266.5378,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-09-14T14:28:12Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 246.83685,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "fe6ba3196a927fb8dee72f8bf777461c95f7505c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/api-guides/ios-sdk-api-guide/",
      "published_at": "2021-09-14T02:04:18Z",
      "updated_at": "2021-07-09T15:39:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 230.93848,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " attributes and events you can send to to <em>New</em> <em>Relic</em> Insights, see the <em>iOS</em> <em>SDK</em> <em>API</em> reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by <em>New</em> <em>Relic</em>"
      },
      "id": "603eb3a2e7b9d264f02a07a8"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/current-session-id": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-09-14T08:11:54Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 266.5378,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-09-14T14:28:12Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 246.83685,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "fe6ba3196a927fb8dee72f8bf777461c95f7505c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/api-guides/ios-sdk-api-guide/",
      "published_at": "2021-09-14T02:04:18Z",
      "updated_at": "2021-07-09T15:39:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 230.93848,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " attributes and events you can send to to <em>New</em> <em>Relic</em> Insights, see the <em>iOS</em> <em>SDK</em> <em>API</em> reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by <em>New</em> <em>Relic</em>"
      },
      "id": "603eb3a2e7b9d264f02a07a8"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/increment-attribute": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-09-14T08:11:54Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 266.5378,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-09-14T14:28:12Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 246.83685,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "fe6ba3196a927fb8dee72f8bf777461c95f7505c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/api-guides/ios-sdk-api-guide/",
      "published_at": "2021-09-14T02:04:18Z",
      "updated_at": "2021-07-09T15:39:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 230.93848,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " attributes and events you can send to to <em>New</em> <em>Relic</em> Insights, see the <em>iOS</em> <em>SDK</em> <em>API</em> reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by <em>New</em> <em>Relic</em>"
      },
      "id": "603eb3a2e7b9d264f02a07a8"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/index": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-09-14T08:11:54Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1463.8287,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "New Relic Mobile <em>iOS</em>",
        "body": "Installing New Relic&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; New &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-09-14T14:28:12Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1367.957,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> monitoring",
        "sections": "<em>Introduction</em> to <em>iOS</em> monitoring",
        "tags": "New Relic Mobile <em>iOS</em>",
        "body": " detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>iOS</em> <em>SDK</em> <em>API</em> Use the <em>iOS</em> <em>SDK</em> <em>API</em> to instrument parts of your code that are not instrumented by default"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "fe6ba3196a927fb8dee72f8bf777461c95f7505c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/api-guides/ios-sdk-api-guide/",
      "published_at": "2021-09-14T02:04:18Z",
      "updated_at": "2021-07-09T15:39:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1314.7744,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "New Relic Mobile <em>iOS</em>",
        "body": "Use the <em>iOS</em> <em>SDK</em> <em>API</em> to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier"
      },
      "id": "603eb3a2e7b9d264f02a07a8"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/record-breadcrumb": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-09-14T08:11:54Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 266.5378,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-09-14T14:28:12Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 246.83685,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "fe6ba3196a927fb8dee72f8bf777461c95f7505c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/api-guides/ios-sdk-api-guide/",
      "published_at": "2021-09-14T02:04:18Z",
      "updated_at": "2021-07-09T15:39:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 230.93846,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " attributes and events you can send to to <em>New</em> <em>Relic</em> Insights, see the <em>iOS</em> <em>SDK</em> <em>API</em> reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by <em>New</em> <em>Relic</em>"
      },
      "id": "603eb3a2e7b9d264f02a07a8"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/record-handled-exception": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-09-14T08:11:54Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 266.53778,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-09-14T14:28:12Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 246.83684,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "fe6ba3196a927fb8dee72f8bf777461c95f7505c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/api-guides/ios-sdk-api-guide/",
      "published_at": "2021-09-14T02:04:18Z",
      "updated_at": "2021-07-09T15:39:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 230.93846,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " attributes and events you can send to to <em>New</em> <em>Relic</em> Insights, see the <em>iOS</em> <em>SDK</em> <em>API</em> reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by <em>New</em> <em>Relic</em>"
      },
      "id": "603eb3a2e7b9d264f02a07a8"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/recordcustomevent-ios-sdk-api": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-09-14T08:11:54Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 266.53778,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-09-14T14:28:12Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 246.83684,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "fe6ba3196a927fb8dee72f8bf777461c95f7505c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/api-guides/ios-sdk-api-guide/",
      "published_at": "2021-09-14T02:04:18Z",
      "updated_at": "2021-07-09T15:39:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 230.93846,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " attributes and events you can send to to <em>New</em> <em>Relic</em> Insights, see the <em>iOS</em> <em>SDK</em> <em>API</em> reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by <em>New</em> <em>Relic</em>"
      },
      "id": "603eb3a2e7b9d264f02a07a8"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/recorderror-ios-sdk-api": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-09-14T08:11:54Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 266.53778,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-09-14T14:28:12Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 246.83684,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "fe6ba3196a927fb8dee72f8bf777461c95f7505c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/api-guides/ios-sdk-api-guide/",
      "published_at": "2021-09-14T02:04:18Z",
      "updated_at": "2021-07-09T15:39:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 230.93846,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " attributes and events you can send to to <em>New</em> <em>Relic</em> Insights, see the <em>iOS</em> <em>SDK</em> <em>API</em> reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by <em>New</em> <em>Relic</em>"
      },
      "id": "603eb3a2e7b9d264f02a07a8"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/recordmetric-ios-sdk-api": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-09-14T08:11:54Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 266.53778,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-09-14T14:28:12Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 246.83684,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "fe6ba3196a927fb8dee72f8bf777461c95f7505c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/api-guides/ios-sdk-api-guide/",
      "published_at": "2021-09-14T02:04:18Z",
      "updated_at": "2021-07-09T15:39:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 230.93846,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " attributes and events you can send to to <em>New</em> <em>Relic</em> Insights, see the <em>iOS</em> <em>SDK</em> <em>API</em> reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by <em>New</em> <em>Relic</em>"
      },
      "id": "603eb3a2e7b9d264f02a07a8"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/remove-all-attributes": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-09-14T08:11:54Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 266.53778,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-09-14T14:28:12Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 246.83684,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "fe6ba3196a927fb8dee72f8bf777461c95f7505c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/api-guides/ios-sdk-api-guide/",
      "published_at": "2021-09-14T02:04:18Z",
      "updated_at": "2021-07-09T15:39:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 230.93845,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " attributes and events you can send to to <em>New</em> <em>Relic</em> Insights, see the <em>iOS</em> <em>SDK</em> <em>API</em> reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by <em>New</em> <em>Relic</em>"
      },
      "id": "603eb3a2e7b9d264f02a07a8"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/remove-attribute": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-09-14T08:11:54Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 266.53778,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-09-14T14:28:12Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 246.83684,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "fe6ba3196a927fb8dee72f8bf777461c95f7505c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/api-guides/ios-sdk-api-guide/",
      "published_at": "2021-09-14T02:04:18Z",
      "updated_at": "2021-07-09T15:39:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 230.93845,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " attributes and events you can send to to <em>New</em> <em>Relic</em> Insights, see the <em>iOS</em> <em>SDK</em> <em>API</em> reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by <em>New</em> <em>Relic</em>"
      },
      "id": "603eb3a2e7b9d264f02a07a8"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/set-attribute": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-09-14T08:11:54Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 266.53778,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-09-14T14:28:12Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 246.83682,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "fe6ba3196a927fb8dee72f8bf777461c95f7505c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/api-guides/ios-sdk-api-guide/",
      "published_at": "2021-09-14T02:04:18Z",
      "updated_at": "2021-07-09T15:39:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 230.93845,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " attributes and events you can send to to <em>New</em> <em>Relic</em> Insights, see the <em>iOS</em> <em>SDK</em> <em>API</em> reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by <em>New</em> <em>Relic</em>"
      },
      "id": "603eb3a2e7b9d264f02a07a8"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/set-max-event-buffer-time": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-09-14T08:11:54Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 266.53778,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-09-14T14:28:12Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 246.83682,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "fe6ba3196a927fb8dee72f8bf777461c95f7505c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/api-guides/ios-sdk-api-guide/",
      "published_at": "2021-09-14T02:04:18Z",
      "updated_at": "2021-07-09T15:39:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 230.93845,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " attributes and events you can send to to <em>New</em> <em>Relic</em> Insights, see the <em>iOS</em> <em>SDK</em> <em>API</em> reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by <em>New</em> <em>Relic</em>"
      },
      "id": "603eb3a2e7b9d264f02a07a8"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/set-max-event-pool-size": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-09-14T08:11:54Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 266.53778,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-09-14T14:28:12Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 246.83682,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "fe6ba3196a927fb8dee72f8bf777461c95f7505c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/api-guides/ios-sdk-api-guide/",
      "published_at": "2021-09-14T02:04:18Z",
      "updated_at": "2021-07-09T15:39:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 230.93845,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " attributes and events you can send to to <em>New</em> <em>Relic</em> Insights, see the <em>iOS</em> <em>SDK</em> <em>API</em> reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by <em>New</em> <em>Relic</em>"
      },
      "id": "603eb3a2e7b9d264f02a07a8"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/set-user-id": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-09-14T08:11:54Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 266.53778,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-09-14T14:28:12Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 246.83682,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "fe6ba3196a927fb8dee72f8bf777461c95f7505c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/api-guides/ios-sdk-api-guide/",
      "published_at": "2021-09-14T02:04:18Z",
      "updated_at": "2021-07-09T15:39:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 230.93845,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " attributes and events you can send to to <em>New</em> <em>Relic</em> Insights, see the <em>iOS</em> <em>SDK</em> <em>API</em> reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by <em>New</em> <em>Relic</em>"
      },
      "id": "603eb3a2e7b9d264f02a07a8"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/troubleshoot/no-data-appears-ios": [
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-09-14T14:28:12Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 130.66629,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "CocoaPods installation",
        "Install your iOS application",
        "Configure using Objective-C",
        "Important",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "9a062745f628f66e34f865a47d58713f12e59ac9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/cocoapods-installation/",
      "published_at": "2021-09-14T14:28:11Z",
      "updated_at": "2021-07-27T15:09:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply to iOS apps using Cocoapods. For other types, see iOS installation and configuration. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps list, select Add a new app. From the Get Started page, select iOS as the platform for mobile monitoring. Type a name for your mobile app, then select Continue. Continue with the steps to configure New Relic for mobile monitoring. Configure using Objective-C These procedures to configure your iOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your APP_NAME-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: [NewRelic startWithApplicationToken:@\"APP_TOKEN\"]; Copy Important The agent must be on the first line of didFinishLaunchingWithOptions and run on the main thread to ensure proper instrumentation. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Configure using Swift These procedures to configure your iOS app with CocoaPods and Swift also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your APP_NAME-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: NewRelic.start(withApplicationToken:\"APP_TOKEN\") Copy Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling NewRelic.start(withApplicationToken): [NRLogger setLogLevels:NRLogLevelALL]; Copy For Swift apps: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.39986,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods <em>installation</em>",
        "sections": "<em>Install</em> your <em>iOS</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps list, select Add a <em>new</em> app. From the Get Started page, select <em>iOS</em> as the platform for <em>mobile</em> <em>monitoring</em>. Type a name for your <em>mobile</em> app, then select Continue"
      },
      "id": "603ea15d64441fef3d4e8867"
    },
    {
      "sections": [
        "iOS manual installation",
        "Install your iOS application",
        "Add the New Relic framework to your app",
        "Important",
        "Optional: Execute a demo crash",
        "Optional: Change the logging level"
      ],
      "title": "iOS manual installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "0a674eb7f3756cd5d124c6dcf2344edf38e40a8a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/ios-manual-installation/",
      "published_at": "2021-09-14T14:29:01Z",
      "updated_at": "2021-07-27T15:09:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To install and configure New Relic functionality with your iOS applications, follow these procedures. If your iOS app uses Cocoapods, follow the Cocoapods installation procedures. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps index, select Add a new app. From the Get started page, select XCFramework as the platform for mobile monitoring. Type a name for your mobile app, and select Continue. Continue with the steps to configure New Relic. Add the New Relic framework to your app Download and unzip the iOS SDK for New Relic. To add the New Relic framework to your Xcode project: Use Finder to drag the NewRelicAgent.framework folder into your Xcode project, and drop it onto your project in the Project navigator window, under Frameworks, Libraries, and Embedded Content. Make sure Embed & Sign is selected under the Embed dropdown menu. Implement the agent using the appropriate method: Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Language Procedure Objective-C To start the agent: Import the New Relic header at the top of your prefix.pch. Add +[NewRelic startWithApplicationToken:@\"<appToken>\"] to the top of -application:didFinishLaunchingWithOptions: in your AppDelegate.m, using the unique application token that is automatically generated. Swift Create a bridging header file: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. Delete Placeholder.m. Import the New Relic agent by adding #import \"NewRelic/NewRelic.h\" to the top of MyApp-Bridging-Header.h. Add NewRelic.start(withApplicationToken: \">appToken>\") to the top of application(_:didFinishLaunchingWithOptions:) in your AppDelegate.swift using the unique application token that is automatically generated. Add a build script to your target's Build Phases. Ensure the new build script is the very last build phase, then paste the following, replacing PUT_NEW_RELIC_APP_TOKEN_HERE with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, and then run it in the simulator or other device. Optional: Execute a demo crash If you have trouble getting your app to crash, the New Relic agent provides an API to execute a demo crash. Recommendation: Add one of these lines of code to a button click event handler as applicable: Language Code Objective-C Crash: [NewRelic crashNow]; Copy Crash with log message: [NewRelic crashNow:@\"<reason>\"]; Copy Swift Crash: NewRelic.crashNow() Copy Crash with log message: NewRelic.crashNow(_ message:) Copy Optional: Change the logging level Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add the following method: Language Code Objective-C Just before calling startWithApplicationToken in AppDelegate.m, add: [NRLogger setLogLevels:NRLogLevelALL]; Copy Swift Just before calling start(withApplicationToken:) in AppDelegate.swift, add: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.39986,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> manual <em>installation</em>",
        "sections": "<em>iOS</em> manual <em>installation</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " token. This is a 40-character hexadecimal string for authenticating each <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps index, select Add a <em>new</em> app. From the Get started page, select XCFramework"
      },
      "id": "603ea44864441f80904e8899"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/tvos/cocoapods-tvos-installation-configuration": [
    {
      "sections": [
        "New Relic for tvOS compatibility and requirements",
        "tvOS requirements"
      ],
      "title": "New Relic for tvOS compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "ceb80d833a4f472ce844f6aafecd0f50625b3911",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/new-relic-tvos-compatibility-requirements/",
      "published_at": "2021-09-14T14:32:10Z",
      "updated_at": "2021-07-09T13:30:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install and configure the tvOS agent, make sure your tvOS app meets these requirements. tvOS requirements Make sure your tvOS app meets these requirements: Mobile monitoring tvOS requirements Operating system tvOS 9 or higher API/SDK NSURLConnection, AFNetworking, and ASIHttpRequest networking APIs Languages Objective-C Swift: Works with both network traces and crash reporting, but no interaction traces by default. To enable this, see Enabling interaction tracing in Swift. Devices Any tvOS compatible device (Apple TV 4th generation or higher) File sizes The tvOS agent adds about 270K to your tvOS release app. Architectures ARM 64-bit",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 286.4498,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> for <em>tvOS</em> compatibility and requirements",
        "sections": "<em>New</em> <em>Relic</em> for <em>tvOS</em> compatibility and requirements",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Before you install and configure the <em>tvOS</em> agent, make sure your <em>tvOS</em> app meets these requirements. <em>tvOS</em> requirements Make sure your <em>tvOS</em> app meets these requirements: <em>Mobile</em> <em>monitoring</em> <em>tvOS</em> requirements Operating system <em>tvOS</em> 9 or higher API&#x2F;SDK NSURLConnection, AFNetworking, and ASIHttpRequest"
      },
      "id": "60441ac6196a67e457960f6d"
    },
    {
      "sections": [
        "Upgrade the tvOS SDK",
        "Contents",
        "Replacing your tvOS framework"
      ],
      "title": "Upgrade the tvOS SDK",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "f5d6d3d356952d185b96aa409605b79e3ace8ec9",
      "image": "https://docs.newrelic.com/static/a3b6801675529d8f4eba123cf08e8f1f/c1b63/Mobile_tvOS_replace-framework_1.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/upgrading-new-relic-mobiles-tvos-sdk/",
      "published_at": "2021-09-14T14:33:04Z",
      "updated_at": "2021-07-09T08:17:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You must be the account Admin to install, configure, and upgrade the tvOS agent. For information about the latest version, refer to the release notes. Contents Replacing your tvOS framework Admins: You must replace the earlier version of your tvOS agent framework before upgrading to a newer version of the tvOS SDK. Here is an example of the workflow to remove your existing tvOS agent framework so you can replace it with a newer version. From the Project Navigator (CMD 1) in Xcode, search for NewRelicAgentTVOS.framework. Right-click or control-click NewRelicAgentTVOS.framework, and select Show in Finder. Drag NewRelicAgentTVOS.framework to the trash. Verify that the Xcode project highlights the reference to NewRelicAgentTVOS.framework in red. Right-click or control-click NewRelicAgentTVOS.framework, and select Delete to remove the obsolete reference from the project. Follow standard installation procedures for tvOS app monitoring.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 285.70215,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upgrade the <em>tvOS</em> SDK",
        "sections": "Upgrade the <em>tvOS</em> SDK",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " in Finder. Drag <em>NewRelicAgentTVOS</em>.framework to the trash. Verify that the Xcode project highlights the reference to <em>NewRelicAgentTVOS</em>.framework in red. Right-click or control-click <em>NewRelicAgentTVOS</em>.framework, and select Delete to remove the obsolete reference from the project. Follow standard installation procedures for <em>tvOS</em> app <em>monitoring</em>."
      },
      "id": "604416cc64441f805c378ecf"
    },
    {
      "sections": [
        "tvOS installation and configuration",
        "Tip",
        "Installing your tvOS application",
        "Configuring your tvOS application",
        "Executing a demo crash (optional)",
        "Changing the logging level (optional)"
      ],
      "title": "tvOS installation and configuration",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "04798a275a7591bfbafb5437194cfbab4b33d8e3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/tvos-installation-configuration/",
      "published_at": "2021-09-14T14:32:10Z",
      "updated_at": "2021-07-09T10:39:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to install and configure the tvOS agent. Tip tvOS apps using Cocoapods have separate installation procedures. Installing your tvOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor. For Admins with existing New Relic accounts, follow these steps to install and configure your application. (If you don't have a New Relic account, signup at newrelic.com/signup—it's free, forever.) Go to one.newrelic.com and click Mobile. If applicable: From the Mobile Apps list, select Add a new app From the Get Started page, select tvOS as the platform for mobile monitoring. Type a name for your mobile app, and select Continue. Configuring your tvOS application These procedures to configure your tvOS app are also available on the Get Started page in the mobile monitoring UI. Download and unzip the tvOS SDK. To add the New Relic tvOS Mobile Framework to your Xcode project: Use Finder to drag the NewRelicAgentTVOS.framework folder into your Xcode project, and drop it onto your Project in the Project Navigator window. Follow the prompts to copy items into destination and to create folder references. Add the SystemConfiguration.framework, libc++.tbd, and libz.tbd libraries to your Linker settings. To start the agent: Import the tvOS agent header at the top of your prefix.pch. Add + [ NewRelic startWithApplicationToken: < appToken>] to the top of -application:didFinishLaunchingWithOptions: in your AppDelegate.m using the unique application token that is automatically generated. Add a build script to your target's Build Phases and paste the following, replacing PUT_NEW_RELIC_APP_TOKEN_HERE with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, and then run it in the simulator or other device. Within a few minutes you will begin to see data for your iOS app: Go to one.newrelic.com > Mobile > (selected app). If you don't, see No data appears. Executing a demo crash (optional) If you have trouble getting your app to crash, the New Relic agent provides an API to execute a demo crash. Recommendation: Add one of these lines of code to a button click event handler as applicable: [NewRelic crashNow]; Copy OR [NewRelic crashNow:@\"<reason>\"]; Copy Changing the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling startWithApplicationToken: [NRLogger setLogLevels:NRLogLevelALL]; Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 284.80307,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>tvOS</em> <em>installation</em> and configuration",
        "sections": "<em>tvOS</em> <em>installation</em> and configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " Started page in the <em>mobile</em> <em>monitoring</em> UI. Download and unzip the <em>tvOS</em> SDK. To add the <em>New</em> <em>Relic</em> <em>tvOS</em> <em>Mobile</em> Framework to your Xcode project: Use Finder to drag the <em>NewRelicAgentTVOS</em>.framework folder into your Xcode project, and drop it onto your Project in the Project Navigator window. Follow the prompts"
      },
      "id": "60441ac5e7b9d26bb55799b6"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/tvos/new-relic-tvos-compatibility-requirements": [
    {
      "sections": [
        "CocoaPods for tvOS installation and configuration",
        "Install your tvOS application",
        "Configure using Objective-C",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods for tvOS installation and configuration",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "dd8c9ed16a980b08c67150dada56e129900202bd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/cocoapods-tvos-installation-configuration/",
      "published_at": "2021-09-14T07:52:30Z",
      "updated_at": "2021-07-21T20:49:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply only to tvOS apps using Cocoapods. For all other types of tvOS apps, see tvOS installation and configuration. Install your tvOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: Select Add more data, select XCFramework. From the drawer, select the New Relic account you would like to add your tvOS application to, and select Continue. Type a name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring. Configure using Objective-C These procedures to configure your tvOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your [app_name]-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions: [NewRelicAgent startWithApplicationToken:@\"<appToken>\"]; Copy Add a build script to your target's Build Phases and paste the following, replacing \"PUT_NEW_RELIC_APP_TOKEN_HERE\" with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/bash \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, then run it in the simulator or other device. Within a few minutes you will begin to see data for your app: Go to one.newrelic.com > Mobile > (select an app). Configure using Swift These procedures to configure your tvOS app with CocoaPods and Swift are also available on the Get Started page in the mobile monitoring UI: In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your [ app_name]-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions: NewRelic.startWithApplicationToken(\"<appToken>\"); Copy Add a build script to your target's Build Phases and paste the following, replacing NEW_RELIC_APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/bash \"${SCRIPT}\" NEW_RELIC_APP_TOKEN Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling startWithApplicationToken: [NRLogger setLogLevels:NRLogLevelALL]; Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 288.0394,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods for <em>tvOS</em> <em>installation</em> and configuration",
        "sections": "CocoaPods for <em>tvOS</em> <em>installation</em> and configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " for authenticating each <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: Select Add more data, select XCFramework. From the drawer, select the <em>New</em> <em>Relic</em> account you would like to add your <em>tvOS</em> application to, and select"
      },
      "id": "60441ac6196a6710e4960f57"
    },
    {
      "sections": [
        "Upgrade the tvOS SDK",
        "Contents",
        "Replacing your tvOS framework"
      ],
      "title": "Upgrade the tvOS SDK",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "f5d6d3d356952d185b96aa409605b79e3ace8ec9",
      "image": "https://docs.newrelic.com/static/a3b6801675529d8f4eba123cf08e8f1f/c1b63/Mobile_tvOS_replace-framework_1.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/upgrading-new-relic-mobiles-tvos-sdk/",
      "published_at": "2021-09-14T14:33:04Z",
      "updated_at": "2021-07-09T08:17:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You must be the account Admin to install, configure, and upgrade the tvOS agent. For information about the latest version, refer to the release notes. Contents Replacing your tvOS framework Admins: You must replace the earlier version of your tvOS agent framework before upgrading to a newer version of the tvOS SDK. Here is an example of the workflow to remove your existing tvOS agent framework so you can replace it with a newer version. From the Project Navigator (CMD 1) in Xcode, search for NewRelicAgentTVOS.framework. Right-click or control-click NewRelicAgentTVOS.framework, and select Show in Finder. Drag NewRelicAgentTVOS.framework to the trash. Verify that the Xcode project highlights the reference to NewRelicAgentTVOS.framework in red. Right-click or control-click NewRelicAgentTVOS.framework, and select Delete to remove the obsolete reference from the project. Follow standard installation procedures for tvOS app monitoring.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 285.70215,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upgrade the <em>tvOS</em> SDK",
        "sections": "Upgrade the <em>tvOS</em> SDK",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " in Finder. Drag <em>NewRelicAgentTVOS</em>.framework to the trash. Verify that the Xcode project highlights the reference to <em>NewRelicAgentTVOS</em>.framework in red. Right-click or control-click <em>NewRelicAgentTVOS</em>.framework, and select Delete to remove the obsolete reference from the project. Follow standard installation procedures for <em>tvOS</em> app <em>monitoring</em>."
      },
      "id": "604416cc64441f805c378ecf"
    },
    {
      "sections": [
        "tvOS installation and configuration",
        "Tip",
        "Installing your tvOS application",
        "Configuring your tvOS application",
        "Executing a demo crash (optional)",
        "Changing the logging level (optional)"
      ],
      "title": "tvOS installation and configuration",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "04798a275a7591bfbafb5437194cfbab4b33d8e3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/tvos-installation-configuration/",
      "published_at": "2021-09-14T14:32:10Z",
      "updated_at": "2021-07-09T10:39:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to install and configure the tvOS agent. Tip tvOS apps using Cocoapods have separate installation procedures. Installing your tvOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor. For Admins with existing New Relic accounts, follow these steps to install and configure your application. (If you don't have a New Relic account, signup at newrelic.com/signup—it's free, forever.) Go to one.newrelic.com and click Mobile. If applicable: From the Mobile Apps list, select Add a new app From the Get Started page, select tvOS as the platform for mobile monitoring. Type a name for your mobile app, and select Continue. Configuring your tvOS application These procedures to configure your tvOS app are also available on the Get Started page in the mobile monitoring UI. Download and unzip the tvOS SDK. To add the New Relic tvOS Mobile Framework to your Xcode project: Use Finder to drag the NewRelicAgentTVOS.framework folder into your Xcode project, and drop it onto your Project in the Project Navigator window. Follow the prompts to copy items into destination and to create folder references. Add the SystemConfiguration.framework, libc++.tbd, and libz.tbd libraries to your Linker settings. To start the agent: Import the tvOS agent header at the top of your prefix.pch. Add + [ NewRelic startWithApplicationToken: < appToken>] to the top of -application:didFinishLaunchingWithOptions: in your AppDelegate.m using the unique application token that is automatically generated. Add a build script to your target's Build Phases and paste the following, replacing PUT_NEW_RELIC_APP_TOKEN_HERE with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, and then run it in the simulator or other device. Within a few minutes you will begin to see data for your iOS app: Go to one.newrelic.com > Mobile > (selected app). If you don't, see No data appears. Executing a demo crash (optional) If you have trouble getting your app to crash, the New Relic agent provides an API to execute a demo crash. Recommendation: Add one of these lines of code to a button click event handler as applicable: [NewRelic crashNow]; Copy OR [NewRelic crashNow:@\"<reason>\"]; Copy Changing the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling startWithApplicationToken: [NRLogger setLogLevels:NRLogLevelALL]; Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 284.80307,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>tvOS</em> <em>installation</em> and configuration",
        "sections": "<em>tvOS</em> <em>installation</em> and configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " Started page in the <em>mobile</em> <em>monitoring</em> UI. Download and unzip the <em>tvOS</em> SDK. To add the <em>New</em> <em>Relic</em> <em>tvOS</em> <em>Mobile</em> Framework to your Xcode project: Use Finder to drag the <em>NewRelicAgentTVOS</em>.framework folder into your Xcode project, and drop it onto your Project in the Project Navigator window. Follow the prompts"
      },
      "id": "60441ac5e7b9d26bb55799b6"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/tvos/tvos-installation-configuration": [
    {
      "sections": [
        "CocoaPods for tvOS installation and configuration",
        "Install your tvOS application",
        "Configure using Objective-C",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods for tvOS installation and configuration",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "dd8c9ed16a980b08c67150dada56e129900202bd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/cocoapods-tvos-installation-configuration/",
      "published_at": "2021-09-14T07:52:30Z",
      "updated_at": "2021-07-21T20:49:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply only to tvOS apps using Cocoapods. For all other types of tvOS apps, see tvOS installation and configuration. Install your tvOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: Select Add more data, select XCFramework. From the drawer, select the New Relic account you would like to add your tvOS application to, and select Continue. Type a name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring. Configure using Objective-C These procedures to configure your tvOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your [app_name]-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions: [NewRelicAgent startWithApplicationToken:@\"<appToken>\"]; Copy Add a build script to your target's Build Phases and paste the following, replacing \"PUT_NEW_RELIC_APP_TOKEN_HERE\" with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/bash \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, then run it in the simulator or other device. Within a few minutes you will begin to see data for your app: Go to one.newrelic.com > Mobile > (select an app). Configure using Swift These procedures to configure your tvOS app with CocoaPods and Swift are also available on the Get Started page in the mobile monitoring UI: In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your [ app_name]-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions: NewRelic.startWithApplicationToken(\"<appToken>\"); Copy Add a build script to your target's Build Phases and paste the following, replacing NEW_RELIC_APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/bash \"${SCRIPT}\" NEW_RELIC_APP_TOKEN Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling startWithApplicationToken: [NRLogger setLogLevels:NRLogLevelALL]; Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 288.0394,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods for <em>tvOS</em> <em>installation</em> and configuration",
        "sections": "CocoaPods for <em>tvOS</em> <em>installation</em> and configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " for authenticating each <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: Select Add more data, select XCFramework. From the drawer, select the <em>New</em> <em>Relic</em> account you would like to add your <em>tvOS</em> application to, and select"
      },
      "id": "60441ac6196a6710e4960f57"
    },
    {
      "sections": [
        "New Relic for tvOS compatibility and requirements",
        "tvOS requirements"
      ],
      "title": "New Relic for tvOS compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "ceb80d833a4f472ce844f6aafecd0f50625b3911",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/new-relic-tvos-compatibility-requirements/",
      "published_at": "2021-09-14T14:32:10Z",
      "updated_at": "2021-07-09T13:30:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install and configure the tvOS agent, make sure your tvOS app meets these requirements. tvOS requirements Make sure your tvOS app meets these requirements: Mobile monitoring tvOS requirements Operating system tvOS 9 or higher API/SDK NSURLConnection, AFNetworking, and ASIHttpRequest networking APIs Languages Objective-C Swift: Works with both network traces and crash reporting, but no interaction traces by default. To enable this, see Enabling interaction tracing in Swift. Devices Any tvOS compatible device (Apple TV 4th generation or higher) File sizes The tvOS agent adds about 270K to your tvOS release app. Architectures ARM 64-bit",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 286.44977,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> for <em>tvOS</em> compatibility and requirements",
        "sections": "<em>New</em> <em>Relic</em> for <em>tvOS</em> compatibility and requirements",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Before you install and configure the <em>tvOS</em> agent, make sure your <em>tvOS</em> app meets these requirements. <em>tvOS</em> requirements Make sure your <em>tvOS</em> app meets these requirements: <em>Mobile</em> <em>monitoring</em> <em>tvOS</em> requirements Operating system <em>tvOS</em> 9 or higher API&#x2F;SDK NSURLConnection, AFNetworking, and ASIHttpRequest"
      },
      "id": "60441ac6196a67e457960f6d"
    },
    {
      "sections": [
        "Upgrade the tvOS SDK",
        "Contents",
        "Replacing your tvOS framework"
      ],
      "title": "Upgrade the tvOS SDK",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "f5d6d3d356952d185b96aa409605b79e3ace8ec9",
      "image": "https://docs.newrelic.com/static/a3b6801675529d8f4eba123cf08e8f1f/c1b63/Mobile_tvOS_replace-framework_1.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/upgrading-new-relic-mobiles-tvos-sdk/",
      "published_at": "2021-09-14T14:33:04Z",
      "updated_at": "2021-07-09T08:17:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You must be the account Admin to install, configure, and upgrade the tvOS agent. For information about the latest version, refer to the release notes. Contents Replacing your tvOS framework Admins: You must replace the earlier version of your tvOS agent framework before upgrading to a newer version of the tvOS SDK. Here is an example of the workflow to remove your existing tvOS agent framework so you can replace it with a newer version. From the Project Navigator (CMD 1) in Xcode, search for NewRelicAgentTVOS.framework. Right-click or control-click NewRelicAgentTVOS.framework, and select Show in Finder. Drag NewRelicAgentTVOS.framework to the trash. Verify that the Xcode project highlights the reference to NewRelicAgentTVOS.framework in red. Right-click or control-click NewRelicAgentTVOS.framework, and select Delete to remove the obsolete reference from the project. Follow standard installation procedures for tvOS app monitoring.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 285.70215,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upgrade the <em>tvOS</em> SDK",
        "sections": "Upgrade the <em>tvOS</em> SDK",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " in Finder. Drag <em>NewRelicAgentTVOS</em>.framework to the trash. Verify that the Xcode project highlights the reference to <em>NewRelicAgentTVOS</em>.framework in red. Right-click or control-click <em>NewRelicAgentTVOS</em>.framework, and select Delete to remove the obsolete reference from the project. Follow standard installation procedures for <em>tvOS</em> app <em>monitoring</em>."
      },
      "id": "604416cc64441f805c378ecf"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/tvos/upgrading-new-relic-mobiles-tvos-sdk": [
    {
      "sections": [
        "CocoaPods for tvOS installation and configuration",
        "Install your tvOS application",
        "Configure using Objective-C",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods for tvOS installation and configuration",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "dd8c9ed16a980b08c67150dada56e129900202bd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/cocoapods-tvos-installation-configuration/",
      "published_at": "2021-09-14T07:52:30Z",
      "updated_at": "2021-07-21T20:49:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply only to tvOS apps using Cocoapods. For all other types of tvOS apps, see tvOS installation and configuration. Install your tvOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: Select Add more data, select XCFramework. From the drawer, select the New Relic account you would like to add your tvOS application to, and select Continue. Type a name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring. Configure using Objective-C These procedures to configure your tvOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your [app_name]-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions: [NewRelicAgent startWithApplicationToken:@\"<appToken>\"]; Copy Add a build script to your target's Build Phases and paste the following, replacing \"PUT_NEW_RELIC_APP_TOKEN_HERE\" with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/bash \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, then run it in the simulator or other device. Within a few minutes you will begin to see data for your app: Go to one.newrelic.com > Mobile > (select an app). Configure using Swift These procedures to configure your tvOS app with CocoaPods and Swift are also available on the Get Started page in the mobile monitoring UI: In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your [ app_name]-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions: NewRelic.startWithApplicationToken(\"<appToken>\"); Copy Add a build script to your target's Build Phases and paste the following, replacing NEW_RELIC_APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/bash \"${SCRIPT}\" NEW_RELIC_APP_TOKEN Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling startWithApplicationToken: [NRLogger setLogLevels:NRLogLevelALL]; Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 288.0394,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods for <em>tvOS</em> <em>installation</em> and configuration",
        "sections": "CocoaPods for <em>tvOS</em> <em>installation</em> and configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " for authenticating each <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: Select Add more data, select XCFramework. From the drawer, select the <em>New</em> <em>Relic</em> account you would like to add your <em>tvOS</em> application to, and select"
      },
      "id": "60441ac6196a6710e4960f57"
    },
    {
      "sections": [
        "New Relic for tvOS compatibility and requirements",
        "tvOS requirements"
      ],
      "title": "New Relic for tvOS compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "ceb80d833a4f472ce844f6aafecd0f50625b3911",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/new-relic-tvos-compatibility-requirements/",
      "published_at": "2021-09-14T14:32:10Z",
      "updated_at": "2021-07-09T13:30:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install and configure the tvOS agent, make sure your tvOS app meets these requirements. tvOS requirements Make sure your tvOS app meets these requirements: Mobile monitoring tvOS requirements Operating system tvOS 9 or higher API/SDK NSURLConnection, AFNetworking, and ASIHttpRequest networking APIs Languages Objective-C Swift: Works with both network traces and crash reporting, but no interaction traces by default. To enable this, see Enabling interaction tracing in Swift. Devices Any tvOS compatible device (Apple TV 4th generation or higher) File sizes The tvOS agent adds about 270K to your tvOS release app. Architectures ARM 64-bit",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 286.44977,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> for <em>tvOS</em> compatibility and requirements",
        "sections": "<em>New</em> <em>Relic</em> for <em>tvOS</em> compatibility and requirements",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Before you install and configure the <em>tvOS</em> agent, make sure your <em>tvOS</em> app meets these requirements. <em>tvOS</em> requirements Make sure your <em>tvOS</em> app meets these requirements: <em>Mobile</em> <em>monitoring</em> <em>tvOS</em> requirements Operating system <em>tvOS</em> 9 or higher API&#x2F;SDK NSURLConnection, AFNetworking, and ASIHttpRequest"
      },
      "id": "60441ac6196a67e457960f6d"
    },
    {
      "sections": [
        "tvOS installation and configuration",
        "Tip",
        "Installing your tvOS application",
        "Configuring your tvOS application",
        "Executing a demo crash (optional)",
        "Changing the logging level (optional)"
      ],
      "title": "tvOS installation and configuration",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "04798a275a7591bfbafb5437194cfbab4b33d8e3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/tvos-installation-configuration/",
      "published_at": "2021-09-14T14:32:10Z",
      "updated_at": "2021-07-09T10:39:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to install and configure the tvOS agent. Tip tvOS apps using Cocoapods have separate installation procedures. Installing your tvOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor. For Admins with existing New Relic accounts, follow these steps to install and configure your application. (If you don't have a New Relic account, signup at newrelic.com/signup—it's free, forever.) Go to one.newrelic.com and click Mobile. If applicable: From the Mobile Apps list, select Add a new app From the Get Started page, select tvOS as the platform for mobile monitoring. Type a name for your mobile app, and select Continue. Configuring your tvOS application These procedures to configure your tvOS app are also available on the Get Started page in the mobile monitoring UI. Download and unzip the tvOS SDK. To add the New Relic tvOS Mobile Framework to your Xcode project: Use Finder to drag the NewRelicAgentTVOS.framework folder into your Xcode project, and drop it onto your Project in the Project Navigator window. Follow the prompts to copy items into destination and to create folder references. Add the SystemConfiguration.framework, libc++.tbd, and libz.tbd libraries to your Linker settings. To start the agent: Import the tvOS agent header at the top of your prefix.pch. Add + [ NewRelic startWithApplicationToken: < appToken>] to the top of -application:didFinishLaunchingWithOptions: in your AppDelegate.m using the unique application token that is automatically generated. Add a build script to your target's Build Phases and paste the following, replacing PUT_NEW_RELIC_APP_TOKEN_HERE with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, and then run it in the simulator or other device. Within a few minutes you will begin to see data for your iOS app: Go to one.newrelic.com > Mobile > (selected app). If you don't, see No data appears. Executing a demo crash (optional) If you have trouble getting your app to crash, the New Relic agent provides an API to execute a demo crash. Recommendation: Add one of these lines of code to a button click event handler as applicable: [NewRelic crashNow]; Copy OR [NewRelic crashNow:@\"<reason>\"]; Copy Changing the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling startWithApplicationToken: [NRLogger setLogLevels:NRLogLevelALL]; Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 284.80307,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>tvOS</em> <em>installation</em> and configuration",
        "sections": "<em>tvOS</em> <em>installation</em> and configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " Started page in the <em>mobile</em> <em>monitoring</em> UI. Download and unzip the <em>tvOS</em> SDK. To add the <em>New</em> <em>Relic</em> <em>tvOS</em> <em>Mobile</em> Framework to your Xcode project: Use Finder to drag the <em>NewRelicAgentTVOS</em>.framework folder into your Xcode project, and drop it onto your Project in the Project Navigator window. Follow the prompts"
      },
      "id": "60441ac5e7b9d26bb55799b6"
    }
  ],
  "/docs/network-performance-monitoring/get-started/npm-introduction": [
    {
      "sections": [
        "Visualize your network performance data in New Relic One",
        "Prerequisites",
        "Add the Network dashboards to your account",
        "Tip",
        "Start exploring your network performance data"
      ],
      "title": "Visualize your network performance data in New Relic One",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Monitoring"
      ],
      "external_id": "a9e82cf586cd71595b0fd3bdcc831768578417cf",
      "image": "https://docs.newrelic.com/static/f6a643a55e2f9a2b070d85ab9174ba48/c1b63/flow_data_dashboard.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/monitoring-network-data/visualize-network-data/",
      "published_at": "2021-09-14T18:18:06Z",
      "updated_at": "2021-09-14T18:18:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you've set up your network data for performance monitoring, you can go to New Relic One to install several custom curated visualizations designed specifically for network performance monitoring. Once you've set up these visualizations, you'll be able to start exploring the network data your devices are reporting to New Relic One. Prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. Having set up your Network Performance Monitoring devices. Read how to: Set up SNMP data monitoring. Set up network flow data monitoring. Add the custom visualizations app to your account: Go to one.newrelic.com > Apps, and search for Network Agent Visualizations. Click the app, and then click Open visualization. one.newrelic.com > Apps, and search for Network Agent Visualizations. From the Account ID dropdown, select the account you want to add the visualizations to, and click Enable. Add the Network dashboards to your account You can go to New Relic One and import several dashboards to see curated views of your network telemetry, including the GeoMap and Sankey custom visualizations from the prerequisites. Go to one.newrelic.com > Apps, and search for Quickstarts. Click Quickstarts, and in the search bar, search for Network and click one of the dashboards: The Network - Data Ingest and Cardinality dashboard to analyze usage trends. The Network - Routers and Switches dashboard for SNMP data from Router and Switch entities. The Network - Flow Devices dashboard for network flow data. one.newrelic.com > Apps, and search for Network. Click Import, and Select the account you want to add the dashboard to. Edit the dashboard name, if you want to. Click Import dashboard. Tip If you want to read more about custom visualizations in New Relic One, see the introduction to custom visualizations. Start exploring your network performance data Once you've finished setting up these dashboards, you can start seeing your network data by going to: one.newrelic.com > Dashboards: For usage trend analysis, you'll see the following dashboard: Dashboard for analyzing network telemetry usage trends in New Relic One. For SNMP data, you'll see the following dashboard: Dashboard for SNMP data from Router and Switch entities in New Relic One. For Network flow data, you'll see the following dashboard: Dashboard for Network flow data monitoring in New Relic One. one.newrelic.com > Explorer: Entities are listed under the Network category in the left-hand side menu. Open a specific device to see the details and trend of its performance. On the top right-hand side, click Lookout to see anomalies. Lookout view for Network Performance Monitoring in New Relic One.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 238.70749,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Visualize your <em>network</em> <em>performance</em> data in New Relic One",
        "sections": "<em>Start</em> exploring your <em>network</em> <em>performance</em> data",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": "After you&#x27;ve set up your <em>network</em> data for <em>performance</em> <em>monitoring</em>, you can go to New Relic One to install several custom curated visualizations designed specifically for <em>network</em> <em>performance</em> <em>monitoring</em>. Once you&#x27;ve set up these visualizations, you&#x27;ll be able to <em>start</em> exploring the <em>network</em> data your"
      },
      "id": "6127249b64441f621ea47c42"
    },
    {
      "sections": [
        "SNMP discovery does not find any devices",
        "Problem",
        "Solutions"
      ],
      "title": "SNMP discovery does not find any devices",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Troubleshooting"
      ],
      "external_id": "decc0855d366bdfe7098baba127389a7ab22f803",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/troubleshooting/snmp-troubleshooting-no-devices/",
      "published_at": "2021-09-13T20:24:53Z",
      "updated_at": "2021-09-13T20:24:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem You launched an SNMP discovery run but didn't find any devices. Solutions The SNMP discovery process will run against every IP address in your list from the cidr section in the discovery configuration. During the scan, there is a check to ensure the target IP address is responsive. If successful, ktranslate will then attempt to communicate with the IP address via SNMP. Common failure points in the discovery process include: timeouts due to either network latency or device response times to SNMP requests. Meraki Cloud Controllers recommend at least a 10s timeout value, for instance. initial failures on the responsiveness check from devices that are generally under tighter security postures, like firewalls. To work around these problems, try one or both of the following solutions: Edit the snmp-base.yaml and increase the timeout value for the timeout_ms variable. For devices that still seem unresponsive, set all the cidrs values to a length of /32, which forces the discovery process to skip the responsiveness check and only attempts the SNMP connection.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.81236,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": ". If successful, ktranslate will then attempt to communicate with the IP address via SNMP. Common failure points in the discovery process include: timeouts due to either <em>network</em> latency or device response times to SNMP requests. Meraki Cloud Controllers recommend at least a 10s timeout value, for instance"
      },
      "id": "612724e1196a67a03300b322"
    },
    {
      "sections": [
        "Set up network flow data monitoring",
        "Prerequisites",
        "Network security prerequisites",
        "Supported types of network flow data",
        "Important",
        "Scaling Network Flow Collection",
        "Set up network flow data monitoring in New Relic One",
        "Tip"
      ],
      "title": "Set up network flow data monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Installation",
        "Setup"
      ],
      "external_id": "626c9bebce36e550d5793d8ef932e6d654c23e47",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/network-flow-monitoring/",
      "published_at": "2021-09-14T18:19:01Z",
      "updated_at": "2021-09-14T18:19:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Set up your network devices so they send network data to New Relic One. Prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. A New Relic account ID. Read how to find your account ID. A New Relic license key. Docker installed in your local machine. SSH access to the Docker host, with the ability to launch new containers. Access to Layer 2/3 network devices that can generate and send network flow data, and also add and modify network flow targets on the device. Here's how to configure network flow data collection in some devices: NetFlow data Palo Alto - PAN-OS Fortinet Fortigate Cisco - NX-OS Cisco - IOS Cisco - Meraki sFlow data F5 - BIG-IP jFlow data Juniper - Junos Network security prerequisites Direction Source Destination Ports Protocol Outbound Docker host Kentik's docker image GitHub repository 80, 443 UDP, TCP Outbound Docker host EU Logs endpoint https://log-api.eu.newrelic.com/log/v1 Copy US Logs endpoint https://log-api.newrelic.com/log/v1 Copy 80, 443 UDP, TCP Outbound Docker host EU Events endpoint http://insights-collector.eu01.nr-data.net/ Copy US Events endpoint http://insights-collector.newrelic.com/ Copy 80, 443 UDP, TCP Inbound Network flow data device Docker host 9995 UDP Supported types of network flow data Kentik's integration supports four types of network flow data. When running the ktranslate image, you can specify which type you want to monitor using the -nf.source option. Important The ktranslate image only supports monitoring one type of network flow data type at a time. If you want to monitor several types, each will require a container. IPFIX and NetflowV9 can be sent to the same container, but we recommend running a separate container as a best practice. To check the equivalence among the network flow data type and the value you need to specify when running the image, see the following table: Network flow data type -nf.source value IPFIX ipfix NetFlow version 5 netflow5 NetFlow version 9 netflow9 sFlow sflow Important For Juniper Networks' jFlow, use the netflow5 value. Scaling Network Flow Collection When planning your strategy for collecting network flows at scale, New Relic recommends 1 CPU per 2000 flows-per-second (120,000 flows-per-minute). Deciding whether to run more small containers to distribute load or fewer large containers to consolidate management is a matter of personal preference. Set up network flow data monitoring in New Relic One In your local machine, from a Linux host with Docker installed, download the ktranslate image from dockerhub by running bash Copy $ docker pull kentik/ktranslate:v2 Copy the snmp-base.yaml file to the local $HOME directory of your Docker user, and discard the container by running bash Copy $ cd . $ id=$(docker create kentik/ktranslate:v2) $ docker cp $id:/etc/ktranslate/snmp-base.yaml . $ docker rm -v $id In the snmp-base.yaml file, add your network flow devices inside the devices variable with the following structure: devices: flowDevice: device_name: edge-router device_ip: 10.10.1.254 flow_only: true user_tags: owning_team: net_eng environment: production Copy Tip If you're already monitoring SNMP data devices that send network flow data, you don't need to add them in your snmp-base.yaml file. Run ktranslate to listen for network flows from devices by entering the following commands: Important Add your New Relic license key and your account ID in the $NR_LICENSE_KEY and $NR_ACCOUNT_ID variables respectively. bash Copy $ docker run -d --name ktranslate-sflow --restart unless-stopped --net=host \\ > -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ > -e NEW_RELIC_API_KEY=$NR_LICENSE_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$NR_ACCOUNT_ID \\ > -metrics=jchf \\ > -log_level=info \\ > -tee_logs=true \\ > -flow_only=true \\ > -nf.source=sflow \\ > nr1.flow $ ## If your account is located in Europe, you need to add the following option before the nr1.flow line $ ## -nr_region=EU \\ To get better visibility into your network, set up SNMP data monitoring. Visualize your network performance data in New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.07092,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set up <em>network</em> flow data <em>monitoring</em>",
        "sections": "Set up <em>network</em> flow data <em>monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": ", you need to add the following option before the nr1.flow line $ ## -nr_region=EU \\ To <em>get</em> better visibility into your <em>network</em>, set up SNMP data <em>monitoring</em>. Visualize your <em>network</em> <em>performance</em> data in New Relic."
      },
      "id": "612724e128ccbc4ac9f2612a"
    }
  ],
  "/docs/network-performance-monitoring/monitoring-network-data/visualize-network-data": [
    {
      "sections": [
        "Get started with Network Performance Monitoring",
        "Types of network performance data",
        "Important",
        "High level architecture overview"
      ],
      "title": "Get started with Network Performance Monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Get started"
      ],
      "external_id": "96d12e2c5551a6e5eab76238cd2b787e5c188c01",
      "image": "https://docs.newrelic.com/static/eb0db7c88b717f386c4900a04e12a8ed/e5166/overview_navigator.jpg",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/get-started/npm-introduction/",
      "published_at": "2021-09-14T11:21:45Z",
      "updated_at": "2021-09-14T01:43:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When system performance suffers, you need to know if it’s due to your code, your infrastructure, or the underlying network. And you need to know fast, so you can focus your efforts. With Network Performance Monitoring you can correlate and analyze application, infrastructure, digital experience, and network data all in one place, and understand how network performance and overall system performance impact each other. Using Navigator with Network Performance Monitoring. Network Performance Monitoring adds the context of network data to the application and infrastructure data you already collect in New Relic One. By monitoring your network data, you can: Analyze and understand the performance of your entire stack (application and infrastructure) for a holistic understanding of your system performance. Have all the data in a single platform to eliminate blind spots. See at first glance whether a network is implicated in an issue. Sign up for free! No credit card required. Already have an account? Login. Types of network performance data You can monitor the following types of network performance data: SNMP data: Simple Network Management Protocol (SNMP) is an application–layer protocol for exchanging management information between network devices. To send SNMP data to New Relic One, see Set up SNMP data monitoring. Network flow data: It captures information about the IP traffic going to and from network interfaces in your on-premises network. To send network flow data to New Relic One, see Set up network flow data monitoring. Important We recommend configuring both SNMP and network flow data for better visibility into your network. This will provide both performance metrics and traffic patterns to troubleshoot and optimize your network. High level architecture overview Our solution is based on the ktranslate docker container developed by our partner, Kentik. This single container image is hosted in your environment to collect and process your data to be exported to the Event, Metric, and Log APIs in New Relic One’s Telemetry Data Platform (TDP). Overview of Network Performance Monitoring architecture.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 262.76843,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "sections": "Get started with <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": "When system <em>performance</em> suffers, you need to know if it’s due to your code, your infrastructure, or the underlying <em>network</em>. And you need to know fast, so you can focus your efforts. With <em>Network</em> <em>Performance</em> <em>Monitoring</em> you can correlate and analyze application, infrastructure, digital experience"
      },
      "id": "6126f39b28ccbc8c49f26162"
    },
    {
      "sections": [
        "SNMP discovery does not find any devices",
        "Problem",
        "Solutions"
      ],
      "title": "SNMP discovery does not find any devices",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Troubleshooting"
      ],
      "external_id": "decc0855d366bdfe7098baba127389a7ab22f803",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/troubleshooting/snmp-troubleshooting-no-devices/",
      "published_at": "2021-09-13T20:24:53Z",
      "updated_at": "2021-09-13T20:24:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem You launched an SNMP discovery run but didn't find any devices. Solutions The SNMP discovery process will run against every IP address in your list from the cidr section in the discovery configuration. During the scan, there is a check to ensure the target IP address is responsive. If successful, ktranslate will then attempt to communicate with the IP address via SNMP. Common failure points in the discovery process include: timeouts due to either network latency or device response times to SNMP requests. Meraki Cloud Controllers recommend at least a 10s timeout value, for instance. initial failures on the responsiveness check from devices that are generally under tighter security postures, like firewalls. To work around these problems, try one or both of the following solutions: Edit the snmp-base.yaml and increase the timeout value for the timeout_ms variable. For devices that still seem unresponsive, set all the cidrs values to a length of /32, which forces the discovery process to skip the responsiveness check and only attempts the SNMP connection.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 257.39417,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": ". If successful, ktranslate will then attempt to communicate with the IP address via SNMP. Common failure points in the discovery process include: timeouts due to either <em>network</em> latency or device response times to SNMP requests. Meraki Cloud Controllers recommend at least a 10s timeout value, for instance"
      },
      "id": "612724e1196a67a03300b322"
    },
    {
      "sections": [
        "Set up SNMP data monitoring",
        "Prerequisites",
        "Network security prerequisites",
        "Set up SNMP data monitoring in New Relic One",
        "Manual setup",
        "Important"
      ],
      "title": "Set up SNMP data monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Installation",
        "Setup"
      ],
      "external_id": "ab50c7659f03d76e429769be42ddec21d4744a0d",
      "image": "https://docs.newrelic.com/static/59f9f8d2d86daf23058506e7cf1c9fcc/c1b63/snmp-guided-install.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/snmp-performance-monitoring/",
      "published_at": "2021-09-14T18:18:06Z",
      "updated_at": "2021-09-14T18:18:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Set up your network devices so they send network data to New Relic One. Prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. A New Relic account ID. Read how to find your account ID. A License key. Read how to generate a new License key. Docker installed in a Linux host. SSH access to the Docker host, with the ability to launch new containers. We recommend using read-only community strings for SNMPv1 and SNMPv2c. We recommend read-only configuration for SNMPv3. Network security prerequisites Direction Source Destination Ports Protocol Outbound Docker host Kentik's docker image GitHub repository 80, 443 UDP, TCP Outbound Docker host EU Logs endpoint https://log-api.eu.newrelic.com/log/v1 Copy US Logs endpoint https://log-api.newrelic.com/log/v1 Copy 80, 443 UDP, TCP Outbound Docker host Metrics endpoint https://log-api.eu.newrelic.com/log/v1 Copy 80, 443 UDP, TCP Outbound Docker host Target devices that will send SNMP data 161 TCP Set up SNMP data monitoring in New Relic One Go to one.newrelic.com and click Add more data. Scroll down until you see Network performance monitoring and click SNMP. Follow the steps in New Relic One. one.newrelic.com > Add more data > Network performance monitoring > SNMP to set up SNMP data monitoring. To get better visibility into your network, set up network flow data monitoring. Visualize your network performance data in New Relic. Manual setup If you prefer to do the setup manually, proceed with the following steps. In your local machine, from a Linux host with Docker installed, download the ktranslate image from dockerhub by running bash Copy $ docker pull kentik/ktranslate:v2 Copy the snmp-base.yaml file to the local $HOME directory of your Docker user, and discard the container by running bash Copy $ cd . $ id=$(docker create kentik/ktranslate:v2) $ docker cp $id:/etc/ktranslate/snmp-base.yaml . $ docker rm -v $id Edit the snmp-base.yaml file and define the cidrs and default_communities variables to appropriate values for your network. Optionally, you can launch a discovery run on SNMP devices. This helps you ensure your devices are ready to be monitored. This discovery run is based on the values you defined for the cidrs and default_communities variables by running bash Copy $ docker run -ti --name ktranslate-discovery --rm --net=host \\ > -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -log_level info \\ > -snmp_discovery=true After the discovery run finishes, you should see an output similar to the following: bash Copy $ >[Info] KTranslate Adding 3 new snmp devices to the config, 0 replaced from 3 $ # In this example, the discovery run found 3 new SNMP devices. The discovered devices are listed in the snmp-base.yaml file. By default, only the IF-MIB mib is polled. You can manually add other mibs here if your devices support them. Run ktranslate to poll target devices. Use the following example: Important Add your New Relic License key and your account ID in the $NR_LICENSE_KEY and $NR_ACCOUNT_ID variables respectively. bash Copy $ docker run -d --name ktranslate-snmp --restart unless-stopped --net=host \\ > -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ > -e NEW_RELIC_API_KEY=$NR_LICENSE_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$NR_ACCOUNT_ID \\ > -log_level=info \\ > -metrics=jchf \\ > -tee_logs=true \\ > ## If your account is located in Europe, you need to add the following option: $ ## -nr_region=EU $ nr1.snmp To get better visibility into your network, set up network flow data monitoring. Visualize your network performance data in New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 245.75845,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set up SNMP data <em>monitoring</em>",
        "sections": "Set up SNMP data <em>monitoring</em>",
        "tags": "<em>Network</em> <em>performance</em> <em>monitoring</em>",
        "body": " 80, 443 UDP, TCP Outbound Docker host Target devices that will send SNMP data 161 TCP Set up SNMP data <em>monitoring</em> in New Relic One Go to one.newrelic.com and click Add more data. Scroll down until you see <em>Network</em> <em>performance</em> <em>monitoring</em> and click SNMP. Follow the steps in New Relic One"
      },
      "id": "6127249b28ccbc09a4f26187"
    }
  ],
  "/docs/network-performance-monitoring/setup-performance-monitoring/advanced-config": [
    {
      "sections": [
        "Visualize your network performance data in New Relic One",
        "Prerequisites",
        "Add the Network dashboards to your account",
        "Tip",
        "Start exploring your network performance data"
      ],
      "title": "Visualize your network performance data in New Relic One",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Monitoring"
      ],
      "external_id": "a9e82cf586cd71595b0fd3bdcc831768578417cf",
      "image": "https://docs.newrelic.com/static/f6a643a55e2f9a2b070d85ab9174ba48/c1b63/flow_data_dashboard.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/monitoring-network-data/visualize-network-data/",
      "published_at": "2021-09-14T18:18:06Z",
      "updated_at": "2021-09-14T18:18:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you've set up your network data for performance monitoring, you can go to New Relic One to install several custom curated visualizations designed specifically for network performance monitoring. Once you've set up these visualizations, you'll be able to start exploring the network data your devices are reporting to New Relic One. Prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. Having set up your Network Performance Monitoring devices. Read how to: Set up SNMP data monitoring. Set up network flow data monitoring. Add the custom visualizations app to your account: Go to one.newrelic.com > Apps, and search for Network Agent Visualizations. Click the app, and then click Open visualization. one.newrelic.com > Apps, and search for Network Agent Visualizations. From the Account ID dropdown, select the account you want to add the visualizations to, and click Enable. Add the Network dashboards to your account You can go to New Relic One and import several dashboards to see curated views of your network telemetry, including the GeoMap and Sankey custom visualizations from the prerequisites. Go to one.newrelic.com > Apps, and search for Quickstarts. Click Quickstarts, and in the search bar, search for Network and click one of the dashboards: The Network - Data Ingest and Cardinality dashboard to analyze usage trends. The Network - Routers and Switches dashboard for SNMP data from Router and Switch entities. The Network - Flow Devices dashboard for network flow data. one.newrelic.com > Apps, and search for Network. Click Import, and Select the account you want to add the dashboard to. Edit the dashboard name, if you want to. Click Import dashboard. Tip If you want to read more about custom visualizations in New Relic One, see the introduction to custom visualizations. Start exploring your network performance data Once you've finished setting up these dashboards, you can start seeing your network data by going to: one.newrelic.com > Dashboards: For usage trend analysis, you'll see the following dashboard: Dashboard for analyzing network telemetry usage trends in New Relic One. For SNMP data, you'll see the following dashboard: Dashboard for SNMP data from Router and Switch entities in New Relic One. For Network flow data, you'll see the following dashboard: Dashboard for Network flow data monitoring in New Relic One. one.newrelic.com > Explorer: Entities are listed under the Network category in the left-hand side menu. Open a specific device to see the details and trend of its performance. On the top right-hand side, click Lookout to see anomalies. Lookout view for Network Performance Monitoring in New Relic One.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 240.79381,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Visualize your <em>network</em> <em>performance</em> data in New Relic One",
        "sections": "Visualize your <em>network</em> <em>performance</em> data in New Relic One",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": "After you&#x27;ve set up your <em>network</em> data for <em>performance</em> <em>monitoring</em>, you can go to New Relic One to install several custom curated visualizations designed specifically for <em>network</em> <em>performance</em> <em>monitoring</em>. Once you&#x27;ve set up these visualizations, you&#x27;ll be able to start exploring the <em>network</em> data your"
      },
      "id": "6127249b64441f621ea47c42"
    },
    {
      "sections": [
        "Get started with Network Performance Monitoring",
        "Types of network performance data",
        "Important",
        "High level architecture overview"
      ],
      "title": "Get started with Network Performance Monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Get started"
      ],
      "external_id": "96d12e2c5551a6e5eab76238cd2b787e5c188c01",
      "image": "https://docs.newrelic.com/static/eb0db7c88b717f386c4900a04e12a8ed/e5166/overview_navigator.jpg",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/get-started/npm-introduction/",
      "published_at": "2021-09-14T11:21:45Z",
      "updated_at": "2021-09-14T01:43:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When system performance suffers, you need to know if it’s due to your code, your infrastructure, or the underlying network. And you need to know fast, so you can focus your efforts. With Network Performance Monitoring you can correlate and analyze application, infrastructure, digital experience, and network data all in one place, and understand how network performance and overall system performance impact each other. Using Navigator with Network Performance Monitoring. Network Performance Monitoring adds the context of network data to the application and infrastructure data you already collect in New Relic One. By monitoring your network data, you can: Analyze and understand the performance of your entire stack (application and infrastructure) for a holistic understanding of your system performance. Have all the data in a single platform to eliminate blind spots. See at first glance whether a network is implicated in an issue. Sign up for free! No credit card required. Already have an account? Login. Types of network performance data You can monitor the following types of network performance data: SNMP data: Simple Network Management Protocol (SNMP) is an application–layer protocol for exchanging management information between network devices. To send SNMP data to New Relic One, see Set up SNMP data monitoring. Network flow data: It captures information about the IP traffic going to and from network interfaces in your on-premises network. To send network flow data to New Relic One, see Set up network flow data monitoring. Important We recommend configuring both SNMP and network flow data for better visibility into your network. This will provide both performance metrics and traffic patterns to troubleshoot and optimize your network. High level architecture overview Our solution is based on the ktranslate docker container developed by our partner, Kentik. This single container image is hosted in your environment to collect and process your data to be exported to the Event, Metric, and Log APIs in New Relic One’s Telemetry Data Platform (TDP). Overview of Network Performance Monitoring architecture.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 228.62845,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "sections": "Get started with <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": "When system <em>performance</em> suffers, you need to know if it’s due to your code, your infrastructure, or the underlying <em>network</em>. And you need to know fast, so you can focus your efforts. With <em>Network</em> <em>Performance</em> <em>Monitoring</em> you can correlate and analyze application, infrastructure, digital experience"
      },
      "id": "6126f39b28ccbc8c49f26162"
    },
    {
      "sections": [
        "SNMP discovery does not find any devices",
        "Problem",
        "Solutions"
      ],
      "title": "SNMP discovery does not find any devices",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Troubleshooting"
      ],
      "external_id": "decc0855d366bdfe7098baba127389a7ab22f803",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/troubleshooting/snmp-troubleshooting-no-devices/",
      "published_at": "2021-09-13T20:24:53Z",
      "updated_at": "2021-09-13T20:24:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem You launched an SNMP discovery run but didn't find any devices. Solutions The SNMP discovery process will run against every IP address in your list from the cidr section in the discovery configuration. During the scan, there is a check to ensure the target IP address is responsive. If successful, ktranslate will then attempt to communicate with the IP address via SNMP. Common failure points in the discovery process include: timeouts due to either network latency or device response times to SNMP requests. Meraki Cloud Controllers recommend at least a 10s timeout value, for instance. initial failures on the responsiveness check from devices that are generally under tighter security postures, like firewalls. To work around these problems, try one or both of the following solutions: Edit the snmp-base.yaml and increase the timeout value for the timeout_ms variable. For devices that still seem unresponsive, set all the cidrs values to a length of /32, which forces the discovery process to skip the responsiveness check and only attempts the SNMP connection.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.786,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": "Problem You launched an SNMP discovery run but didn&#x27;t find any devices. Solutions The SNMP discovery process will run against every IP address in your list from the cidr section in the discovery <em>configuration</em>. During the scan, there is a check to ensure the target IP address is responsive"
      },
      "id": "612724e1196a67a03300b322"
    }
  ],
  "/docs/network-performance-monitoring/setup-performance-monitoring/network-flow-monitoring": [
    {
      "sections": [
        "Set up SNMP data monitoring",
        "Prerequisites",
        "Network security prerequisites",
        "Set up SNMP data monitoring in New Relic One",
        "Manual setup",
        "Important"
      ],
      "title": "Set up SNMP data monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Installation",
        "Setup"
      ],
      "external_id": "ab50c7659f03d76e429769be42ddec21d4744a0d",
      "image": "https://docs.newrelic.com/static/59f9f8d2d86daf23058506e7cf1c9fcc/c1b63/snmp-guided-install.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/snmp-performance-monitoring/",
      "published_at": "2021-09-14T18:18:06Z",
      "updated_at": "2021-09-14T18:18:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Set up your network devices so they send network data to New Relic One. Prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. A New Relic account ID. Read how to find your account ID. A License key. Read how to generate a new License key. Docker installed in a Linux host. SSH access to the Docker host, with the ability to launch new containers. We recommend using read-only community strings for SNMPv1 and SNMPv2c. We recommend read-only configuration for SNMPv3. Network security prerequisites Direction Source Destination Ports Protocol Outbound Docker host Kentik's docker image GitHub repository 80, 443 UDP, TCP Outbound Docker host EU Logs endpoint https://log-api.eu.newrelic.com/log/v1 Copy US Logs endpoint https://log-api.newrelic.com/log/v1 Copy 80, 443 UDP, TCP Outbound Docker host Metrics endpoint https://log-api.eu.newrelic.com/log/v1 Copy 80, 443 UDP, TCP Outbound Docker host Target devices that will send SNMP data 161 TCP Set up SNMP data monitoring in New Relic One Go to one.newrelic.com and click Add more data. Scroll down until you see Network performance monitoring and click SNMP. Follow the steps in New Relic One. one.newrelic.com > Add more data > Network performance monitoring > SNMP to set up SNMP data monitoring. To get better visibility into your network, set up network flow data monitoring. Visualize your network performance data in New Relic. Manual setup If you prefer to do the setup manually, proceed with the following steps. In your local machine, from a Linux host with Docker installed, download the ktranslate image from dockerhub by running bash Copy $ docker pull kentik/ktranslate:v2 Copy the snmp-base.yaml file to the local $HOME directory of your Docker user, and discard the container by running bash Copy $ cd . $ id=$(docker create kentik/ktranslate:v2) $ docker cp $id:/etc/ktranslate/snmp-base.yaml . $ docker rm -v $id Edit the snmp-base.yaml file and define the cidrs and default_communities variables to appropriate values for your network. Optionally, you can launch a discovery run on SNMP devices. This helps you ensure your devices are ready to be monitored. This discovery run is based on the values you defined for the cidrs and default_communities variables by running bash Copy $ docker run -ti --name ktranslate-discovery --rm --net=host \\ > -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -log_level info \\ > -snmp_discovery=true After the discovery run finishes, you should see an output similar to the following: bash Copy $ >[Info] KTranslate Adding 3 new snmp devices to the config, 0 replaced from 3 $ # In this example, the discovery run found 3 new SNMP devices. The discovered devices are listed in the snmp-base.yaml file. By default, only the IF-MIB mib is polled. You can manually add other mibs here if your devices support them. Run ktranslate to poll target devices. Use the following example: Important Add your New Relic License key and your account ID in the $NR_LICENSE_KEY and $NR_ACCOUNT_ID variables respectively. bash Copy $ docker run -d --name ktranslate-snmp --restart unless-stopped --net=host \\ > -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ > -e NEW_RELIC_API_KEY=$NR_LICENSE_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$NR_ACCOUNT_ID \\ > -log_level=info \\ > -metrics=jchf \\ > -tee_logs=true \\ > ## If your account is located in Europe, you need to add the following option: $ ## -nr_region=EU $ nr1.snmp To get better visibility into your network, set up network flow data monitoring. Visualize your network performance data in New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 367.4825,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set up SNMP data <em>monitoring</em>",
        "sections": "Set up SNMP data <em>monitoring</em>",
        "tags": "<em>Network</em> <em>performance</em> <em>monitoring</em>",
        "body": ". one.newrelic.com &gt; Add more data &gt; <em>Network</em> <em>performance</em> <em>monitoring</em> &gt; SNMP to set up SNMP data <em>monitoring</em>. To get better visibility into your <em>network</em>, set up <em>network</em> flow data <em>monitoring</em>. Visualize your <em>network</em> <em>performance</em> data in New Relic. Manual <em>setup</em> If you prefer to do the <em>setup</em> manually, proceed"
      },
      "id": "6127249b28ccbc09a4f26187"
    },
    {
      "sections": [
        "Visualize your network performance data in New Relic One",
        "Prerequisites",
        "Add the Network dashboards to your account",
        "Tip",
        "Start exploring your network performance data"
      ],
      "title": "Visualize your network performance data in New Relic One",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Monitoring"
      ],
      "external_id": "a9e82cf586cd71595b0fd3bdcc831768578417cf",
      "image": "https://docs.newrelic.com/static/f6a643a55e2f9a2b070d85ab9174ba48/c1b63/flow_data_dashboard.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/monitoring-network-data/visualize-network-data/",
      "published_at": "2021-09-14T18:18:06Z",
      "updated_at": "2021-09-14T18:18:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you've set up your network data for performance monitoring, you can go to New Relic One to install several custom curated visualizations designed specifically for network performance monitoring. Once you've set up these visualizations, you'll be able to start exploring the network data your devices are reporting to New Relic One. Prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. Having set up your Network Performance Monitoring devices. Read how to: Set up SNMP data monitoring. Set up network flow data monitoring. Add the custom visualizations app to your account: Go to one.newrelic.com > Apps, and search for Network Agent Visualizations. Click the app, and then click Open visualization. one.newrelic.com > Apps, and search for Network Agent Visualizations. From the Account ID dropdown, select the account you want to add the visualizations to, and click Enable. Add the Network dashboards to your account You can go to New Relic One and import several dashboards to see curated views of your network telemetry, including the GeoMap and Sankey custom visualizations from the prerequisites. Go to one.newrelic.com > Apps, and search for Quickstarts. Click Quickstarts, and in the search bar, search for Network and click one of the dashboards: The Network - Data Ingest and Cardinality dashboard to analyze usage trends. The Network - Routers and Switches dashboard for SNMP data from Router and Switch entities. The Network - Flow Devices dashboard for network flow data. one.newrelic.com > Apps, and search for Network. Click Import, and Select the account you want to add the dashboard to. Edit the dashboard name, if you want to. Click Import dashboard. Tip If you want to read more about custom visualizations in New Relic One, see the introduction to custom visualizations. Start exploring your network performance data Once you've finished setting up these dashboards, you can start seeing your network data by going to: one.newrelic.com > Dashboards: For usage trend analysis, you'll see the following dashboard: Dashboard for analyzing network telemetry usage trends in New Relic One. For SNMP data, you'll see the following dashboard: Dashboard for SNMP data from Router and Switch entities in New Relic One. For Network flow data, you'll see the following dashboard: Dashboard for Network flow data monitoring in New Relic One. one.newrelic.com > Explorer: Entities are listed under the Network category in the left-hand side menu. Open a specific device to see the details and trend of its performance. On the top right-hand side, click Lookout to see anomalies. Lookout view for Network Performance Monitoring in New Relic One.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 240.79381,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Visualize your <em>network</em> <em>performance</em> data in New Relic One",
        "sections": "Visualize your <em>network</em> <em>performance</em> data in New Relic One",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": "After you&#x27;ve set up your <em>network</em> data for <em>performance</em> <em>monitoring</em>, you can go to New Relic One to install several custom curated visualizations designed specifically for <em>network</em> <em>performance</em> <em>monitoring</em>. Once you&#x27;ve set up these visualizations, you&#x27;ll be able to start exploring the <em>network</em> data your"
      },
      "id": "6127249b64441f621ea47c42"
    },
    {
      "sections": [
        "Get started with Network Performance Monitoring",
        "Types of network performance data",
        "Important",
        "High level architecture overview"
      ],
      "title": "Get started with Network Performance Monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Get started"
      ],
      "external_id": "96d12e2c5551a6e5eab76238cd2b787e5c188c01",
      "image": "https://docs.newrelic.com/static/eb0db7c88b717f386c4900a04e12a8ed/e5166/overview_navigator.jpg",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/get-started/npm-introduction/",
      "published_at": "2021-09-14T11:21:45Z",
      "updated_at": "2021-09-14T01:43:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When system performance suffers, you need to know if it’s due to your code, your infrastructure, or the underlying network. And you need to know fast, so you can focus your efforts. With Network Performance Monitoring you can correlate and analyze application, infrastructure, digital experience, and network data all in one place, and understand how network performance and overall system performance impact each other. Using Navigator with Network Performance Monitoring. Network Performance Monitoring adds the context of network data to the application and infrastructure data you already collect in New Relic One. By monitoring your network data, you can: Analyze and understand the performance of your entire stack (application and infrastructure) for a holistic understanding of your system performance. Have all the data in a single platform to eliminate blind spots. See at first glance whether a network is implicated in an issue. Sign up for free! No credit card required. Already have an account? Login. Types of network performance data You can monitor the following types of network performance data: SNMP data: Simple Network Management Protocol (SNMP) is an application–layer protocol for exchanging management information between network devices. To send SNMP data to New Relic One, see Set up SNMP data monitoring. Network flow data: It captures information about the IP traffic going to and from network interfaces in your on-premises network. To send network flow data to New Relic One, see Set up network flow data monitoring. Important We recommend configuring both SNMP and network flow data for better visibility into your network. This will provide both performance metrics and traffic patterns to troubleshoot and optimize your network. High level architecture overview Our solution is based on the ktranslate docker container developed by our partner, Kentik. This single container image is hosted in your environment to collect and process your data to be exported to the Event, Metric, and Log APIs in New Relic One’s Telemetry Data Platform (TDP). Overview of Network Performance Monitoring architecture.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 228.62845,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "sections": "Get started with <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": "When system <em>performance</em> suffers, you need to know if it’s due to your code, your infrastructure, or the underlying <em>network</em>. And you need to know fast, so you can focus your efforts. With <em>Network</em> <em>Performance</em> <em>Monitoring</em> you can correlate and analyze application, infrastructure, digital experience"
      },
      "id": "6126f39b28ccbc8c49f26162"
    }
  ],
  "/docs/network-performance-monitoring/setup-performance-monitoring/snmp-performance-monitoring": [
    {
      "sections": [
        "Set up network flow data monitoring",
        "Prerequisites",
        "Network security prerequisites",
        "Supported types of network flow data",
        "Important",
        "Scaling Network Flow Collection",
        "Set up network flow data monitoring in New Relic One",
        "Tip"
      ],
      "title": "Set up network flow data monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Installation",
        "Setup"
      ],
      "external_id": "626c9bebce36e550d5793d8ef932e6d654c23e47",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/network-flow-monitoring/",
      "published_at": "2021-09-14T18:19:01Z",
      "updated_at": "2021-09-14T18:19:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Set up your network devices so they send network data to New Relic One. Prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. A New Relic account ID. Read how to find your account ID. A New Relic license key. Docker installed in your local machine. SSH access to the Docker host, with the ability to launch new containers. Access to Layer 2/3 network devices that can generate and send network flow data, and also add and modify network flow targets on the device. Here's how to configure network flow data collection in some devices: NetFlow data Palo Alto - PAN-OS Fortinet Fortigate Cisco - NX-OS Cisco - IOS Cisco - Meraki sFlow data F5 - BIG-IP jFlow data Juniper - Junos Network security prerequisites Direction Source Destination Ports Protocol Outbound Docker host Kentik's docker image GitHub repository 80, 443 UDP, TCP Outbound Docker host EU Logs endpoint https://log-api.eu.newrelic.com/log/v1 Copy US Logs endpoint https://log-api.newrelic.com/log/v1 Copy 80, 443 UDP, TCP Outbound Docker host EU Events endpoint http://insights-collector.eu01.nr-data.net/ Copy US Events endpoint http://insights-collector.newrelic.com/ Copy 80, 443 UDP, TCP Inbound Network flow data device Docker host 9995 UDP Supported types of network flow data Kentik's integration supports four types of network flow data. When running the ktranslate image, you can specify which type you want to monitor using the -nf.source option. Important The ktranslate image only supports monitoring one type of network flow data type at a time. If you want to monitor several types, each will require a container. IPFIX and NetflowV9 can be sent to the same container, but we recommend running a separate container as a best practice. To check the equivalence among the network flow data type and the value you need to specify when running the image, see the following table: Network flow data type -nf.source value IPFIX ipfix NetFlow version 5 netflow5 NetFlow version 9 netflow9 sFlow sflow Important For Juniper Networks' jFlow, use the netflow5 value. Scaling Network Flow Collection When planning your strategy for collecting network flows at scale, New Relic recommends 1 CPU per 2000 flows-per-second (120,000 flows-per-minute). Deciding whether to run more small containers to distribute load or fewer large containers to consolidate management is a matter of personal preference. Set up network flow data monitoring in New Relic One In your local machine, from a Linux host with Docker installed, download the ktranslate image from dockerhub by running bash Copy $ docker pull kentik/ktranslate:v2 Copy the snmp-base.yaml file to the local $HOME directory of your Docker user, and discard the container by running bash Copy $ cd . $ id=$(docker create kentik/ktranslate:v2) $ docker cp $id:/etc/ktranslate/snmp-base.yaml . $ docker rm -v $id In the snmp-base.yaml file, add your network flow devices inside the devices variable with the following structure: devices: flowDevice: device_name: edge-router device_ip: 10.10.1.254 flow_only: true user_tags: owning_team: net_eng environment: production Copy Tip If you're already monitoring SNMP data devices that send network flow data, you don't need to add them in your snmp-base.yaml file. Run ktranslate to listen for network flows from devices by entering the following commands: Important Add your New Relic license key and your account ID in the $NR_LICENSE_KEY and $NR_ACCOUNT_ID variables respectively. bash Copy $ docker run -d --name ktranslate-sflow --restart unless-stopped --net=host \\ > -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ > -e NEW_RELIC_API_KEY=$NR_LICENSE_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$NR_ACCOUNT_ID \\ > -metrics=jchf \\ > -log_level=info \\ > -tee_logs=true \\ > -flow_only=true \\ > -nf.source=sflow \\ > nr1.flow $ ## If your account is located in Europe, you need to add the following option before the nr1.flow line $ ## -nr_region=EU \\ To get better visibility into your network, set up SNMP data monitoring. Visualize your network performance data in New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 367.49728,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set up <em>network</em> flow data <em>monitoring</em>",
        "sections": "Set up <em>network</em> flow data <em>monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": " supports <em>monitoring</em> one type of <em>network</em> flow data type at a time. If you want to <em>monitor</em> several types, each will require a container. IPFIX and NetflowV9 can be sent to the same container, but we recommend running a separate container as a best practice. To check the equivalence among the <em>network</em>"
      },
      "id": "612724e128ccbc4ac9f2612a"
    },
    {
      "sections": [
        "Visualize your network performance data in New Relic One",
        "Prerequisites",
        "Add the Network dashboards to your account",
        "Tip",
        "Start exploring your network performance data"
      ],
      "title": "Visualize your network performance data in New Relic One",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Monitoring"
      ],
      "external_id": "a9e82cf586cd71595b0fd3bdcc831768578417cf",
      "image": "https://docs.newrelic.com/static/f6a643a55e2f9a2b070d85ab9174ba48/c1b63/flow_data_dashboard.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/monitoring-network-data/visualize-network-data/",
      "published_at": "2021-09-14T18:18:06Z",
      "updated_at": "2021-09-14T18:18:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you've set up your network data for performance monitoring, you can go to New Relic One to install several custom curated visualizations designed specifically for network performance monitoring. Once you've set up these visualizations, you'll be able to start exploring the network data your devices are reporting to New Relic One. Prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. Having set up your Network Performance Monitoring devices. Read how to: Set up SNMP data monitoring. Set up network flow data monitoring. Add the custom visualizations app to your account: Go to one.newrelic.com > Apps, and search for Network Agent Visualizations. Click the app, and then click Open visualization. one.newrelic.com > Apps, and search for Network Agent Visualizations. From the Account ID dropdown, select the account you want to add the visualizations to, and click Enable. Add the Network dashboards to your account You can go to New Relic One and import several dashboards to see curated views of your network telemetry, including the GeoMap and Sankey custom visualizations from the prerequisites. Go to one.newrelic.com > Apps, and search for Quickstarts. Click Quickstarts, and in the search bar, search for Network and click one of the dashboards: The Network - Data Ingest and Cardinality dashboard to analyze usage trends. The Network - Routers and Switches dashboard for SNMP data from Router and Switch entities. The Network - Flow Devices dashboard for network flow data. one.newrelic.com > Apps, and search for Network. Click Import, and Select the account you want to add the dashboard to. Edit the dashboard name, if you want to. Click Import dashboard. Tip If you want to read more about custom visualizations in New Relic One, see the introduction to custom visualizations. Start exploring your network performance data Once you've finished setting up these dashboards, you can start seeing your network data by going to: one.newrelic.com > Dashboards: For usage trend analysis, you'll see the following dashboard: Dashboard for analyzing network telemetry usage trends in New Relic One. For SNMP data, you'll see the following dashboard: Dashboard for SNMP data from Router and Switch entities in New Relic One. For Network flow data, you'll see the following dashboard: Dashboard for Network flow data monitoring in New Relic One. one.newrelic.com > Explorer: Entities are listed under the Network category in the left-hand side menu. Open a specific device to see the details and trend of its performance. On the top right-hand side, click Lookout to see anomalies. Lookout view for Network Performance Monitoring in New Relic One.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 240.79362,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Visualize your <em>network</em> <em>performance</em> data in New Relic One",
        "sections": "Visualize your <em>network</em> <em>performance</em> data in New Relic One",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": "After you&#x27;ve set up your <em>network</em> data for <em>performance</em> <em>monitoring</em>, you can go to New Relic One to install several custom curated visualizations designed specifically for <em>network</em> <em>performance</em> <em>monitoring</em>. Once you&#x27;ve set up these visualizations, you&#x27;ll be able to start exploring the <em>network</em> data your"
      },
      "id": "6127249b64441f621ea47c42"
    },
    {
      "sections": [
        "Get started with Network Performance Monitoring",
        "Types of network performance data",
        "Important",
        "High level architecture overview"
      ],
      "title": "Get started with Network Performance Monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Get started"
      ],
      "external_id": "96d12e2c5551a6e5eab76238cd2b787e5c188c01",
      "image": "https://docs.newrelic.com/static/eb0db7c88b717f386c4900a04e12a8ed/e5166/overview_navigator.jpg",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/get-started/npm-introduction/",
      "published_at": "2021-09-14T11:21:45Z",
      "updated_at": "2021-09-14T01:43:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When system performance suffers, you need to know if it’s due to your code, your infrastructure, or the underlying network. And you need to know fast, so you can focus your efforts. With Network Performance Monitoring you can correlate and analyze application, infrastructure, digital experience, and network data all in one place, and understand how network performance and overall system performance impact each other. Using Navigator with Network Performance Monitoring. Network Performance Monitoring adds the context of network data to the application and infrastructure data you already collect in New Relic One. By monitoring your network data, you can: Analyze and understand the performance of your entire stack (application and infrastructure) for a holistic understanding of your system performance. Have all the data in a single platform to eliminate blind spots. See at first glance whether a network is implicated in an issue. Sign up for free! No credit card required. Already have an account? Login. Types of network performance data You can monitor the following types of network performance data: SNMP data: Simple Network Management Protocol (SNMP) is an application–layer protocol for exchanging management information between network devices. To send SNMP data to New Relic One, see Set up SNMP data monitoring. Network flow data: It captures information about the IP traffic going to and from network interfaces in your on-premises network. To send network flow data to New Relic One, see Set up network flow data monitoring. Important We recommend configuring both SNMP and network flow data for better visibility into your network. This will provide both performance metrics and traffic patterns to troubleshoot and optimize your network. High level architecture overview Our solution is based on the ktranslate docker container developed by our partner, Kentik. This single container image is hosted in your environment to collect and process your data to be exported to the Event, Metric, and Log APIs in New Relic One’s Telemetry Data Platform (TDP). Overview of Network Performance Monitoring architecture.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 228.6283,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "sections": "Get started with <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": "When system <em>performance</em> suffers, you need to know if it’s due to your code, your infrastructure, or the underlying <em>network</em>. And you need to know fast, so you can focus your efforts. With <em>Network</em> <em>Performance</em> <em>Monitoring</em> you can correlate and analyze application, infrastructure, digital experience"
      },
      "id": "6126f39b28ccbc8c49f26162"
    }
  ],
  "/docs/network-performance-monitoring/troubleshooting/snmp-troubleshooting-no-devices": [
    {
      "sections": [
        "Visualize your network performance data in New Relic One",
        "Prerequisites",
        "Add the Network dashboards to your account",
        "Tip",
        "Start exploring your network performance data"
      ],
      "title": "Visualize your network performance data in New Relic One",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Monitoring"
      ],
      "external_id": "a9e82cf586cd71595b0fd3bdcc831768578417cf",
      "image": "https://docs.newrelic.com/static/f6a643a55e2f9a2b070d85ab9174ba48/c1b63/flow_data_dashboard.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/monitoring-network-data/visualize-network-data/",
      "published_at": "2021-09-14T18:18:06Z",
      "updated_at": "2021-09-14T18:18:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you've set up your network data for performance monitoring, you can go to New Relic One to install several custom curated visualizations designed specifically for network performance monitoring. Once you've set up these visualizations, you'll be able to start exploring the network data your devices are reporting to New Relic One. Prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. Having set up your Network Performance Monitoring devices. Read how to: Set up SNMP data monitoring. Set up network flow data monitoring. Add the custom visualizations app to your account: Go to one.newrelic.com > Apps, and search for Network Agent Visualizations. Click the app, and then click Open visualization. one.newrelic.com > Apps, and search for Network Agent Visualizations. From the Account ID dropdown, select the account you want to add the visualizations to, and click Enable. Add the Network dashboards to your account You can go to New Relic One and import several dashboards to see curated views of your network telemetry, including the GeoMap and Sankey custom visualizations from the prerequisites. Go to one.newrelic.com > Apps, and search for Quickstarts. Click Quickstarts, and in the search bar, search for Network and click one of the dashboards: The Network - Data Ingest and Cardinality dashboard to analyze usage trends. The Network - Routers and Switches dashboard for SNMP data from Router and Switch entities. The Network - Flow Devices dashboard for network flow data. one.newrelic.com > Apps, and search for Network. Click Import, and Select the account you want to add the dashboard to. Edit the dashboard name, if you want to. Click Import dashboard. Tip If you want to read more about custom visualizations in New Relic One, see the introduction to custom visualizations. Start exploring your network performance data Once you've finished setting up these dashboards, you can start seeing your network data by going to: one.newrelic.com > Dashboards: For usage trend analysis, you'll see the following dashboard: Dashboard for analyzing network telemetry usage trends in New Relic One. For SNMP data, you'll see the following dashboard: Dashboard for SNMP data from Router and Switch entities in New Relic One. For Network flow data, you'll see the following dashboard: Dashboard for Network flow data monitoring in New Relic One. one.newrelic.com > Explorer: Entities are listed under the Network category in the left-hand side menu. Open a specific device to see the details and trend of its performance. On the top right-hand side, click Lookout to see anomalies. Lookout view for Network Performance Monitoring in New Relic One.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 240.79344,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Visualize your <em>network</em> <em>performance</em> data in New Relic One",
        "sections": "Visualize your <em>network</em> <em>performance</em> data in New Relic One",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": "After you&#x27;ve set up your <em>network</em> data for <em>performance</em> <em>monitoring</em>, you can go to New Relic One to install several custom curated visualizations designed specifically for <em>network</em> <em>performance</em> <em>monitoring</em>. Once you&#x27;ve set up these visualizations, you&#x27;ll be able to start exploring the <em>network</em> data your"
      },
      "id": "6127249b64441f621ea47c42"
    },
    {
      "sections": [
        "Get started with Network Performance Monitoring",
        "Types of network performance data",
        "Important",
        "High level architecture overview"
      ],
      "title": "Get started with Network Performance Monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Get started"
      ],
      "external_id": "96d12e2c5551a6e5eab76238cd2b787e5c188c01",
      "image": "https://docs.newrelic.com/static/eb0db7c88b717f386c4900a04e12a8ed/e5166/overview_navigator.jpg",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/get-started/npm-introduction/",
      "published_at": "2021-09-14T11:21:45Z",
      "updated_at": "2021-09-14T01:43:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When system performance suffers, you need to know if it’s due to your code, your infrastructure, or the underlying network. And you need to know fast, so you can focus your efforts. With Network Performance Monitoring you can correlate and analyze application, infrastructure, digital experience, and network data all in one place, and understand how network performance and overall system performance impact each other. Using Navigator with Network Performance Monitoring. Network Performance Monitoring adds the context of network data to the application and infrastructure data you already collect in New Relic One. By monitoring your network data, you can: Analyze and understand the performance of your entire stack (application and infrastructure) for a holistic understanding of your system performance. Have all the data in a single platform to eliminate blind spots. See at first glance whether a network is implicated in an issue. Sign up for free! No credit card required. Already have an account? Login. Types of network performance data You can monitor the following types of network performance data: SNMP data: Simple Network Management Protocol (SNMP) is an application–layer protocol for exchanging management information between network devices. To send SNMP data to New Relic One, see Set up SNMP data monitoring. Network flow data: It captures information about the IP traffic going to and from network interfaces in your on-premises network. To send network flow data to New Relic One, see Set up network flow data monitoring. Important We recommend configuring both SNMP and network flow data for better visibility into your network. This will provide both performance metrics and traffic patterns to troubleshoot and optimize your network. High level architecture overview Our solution is based on the ktranslate docker container developed by our partner, Kentik. This single container image is hosted in your environment to collect and process your data to be exported to the Event, Metric, and Log APIs in New Relic One’s Telemetry Data Platform (TDP). Overview of Network Performance Monitoring architecture.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 228.62814,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "sections": "Get started with <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": " Relic One, see Set up <em>network</em> flow data <em>monitoring</em>. Important We recommend configuring both SNMP and <em>network</em> flow data for better visibility into your <em>network</em>. This will provide both <em>performance</em> metrics and traffic patterns to <em>troubleshoot</em> and optimize your <em>network</em>. High level architecture overview Our"
      },
      "id": "6126f39b28ccbc8c49f26162"
    },
    {
      "sections": [
        "Set up network flow data monitoring",
        "Prerequisites",
        "Network security prerequisites",
        "Supported types of network flow data",
        "Important",
        "Scaling Network Flow Collection",
        "Set up network flow data monitoring in New Relic One",
        "Tip"
      ],
      "title": "Set up network flow data monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Installation",
        "Setup"
      ],
      "external_id": "626c9bebce36e550d5793d8ef932e6d654c23e47",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/network-flow-monitoring/",
      "published_at": "2021-09-14T18:19:01Z",
      "updated_at": "2021-09-14T18:19:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Set up your network devices so they send network data to New Relic One. Prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. A New Relic account ID. Read how to find your account ID. A New Relic license key. Docker installed in your local machine. SSH access to the Docker host, with the ability to launch new containers. Access to Layer 2/3 network devices that can generate and send network flow data, and also add and modify network flow targets on the device. Here's how to configure network flow data collection in some devices: NetFlow data Palo Alto - PAN-OS Fortinet Fortigate Cisco - NX-OS Cisco - IOS Cisco - Meraki sFlow data F5 - BIG-IP jFlow data Juniper - Junos Network security prerequisites Direction Source Destination Ports Protocol Outbound Docker host Kentik's docker image GitHub repository 80, 443 UDP, TCP Outbound Docker host EU Logs endpoint https://log-api.eu.newrelic.com/log/v1 Copy US Logs endpoint https://log-api.newrelic.com/log/v1 Copy 80, 443 UDP, TCP Outbound Docker host EU Events endpoint http://insights-collector.eu01.nr-data.net/ Copy US Events endpoint http://insights-collector.newrelic.com/ Copy 80, 443 UDP, TCP Inbound Network flow data device Docker host 9995 UDP Supported types of network flow data Kentik's integration supports four types of network flow data. When running the ktranslate image, you can specify which type you want to monitor using the -nf.source option. Important The ktranslate image only supports monitoring one type of network flow data type at a time. If you want to monitor several types, each will require a container. IPFIX and NetflowV9 can be sent to the same container, but we recommend running a separate container as a best practice. To check the equivalence among the network flow data type and the value you need to specify when running the image, see the following table: Network flow data type -nf.source value IPFIX ipfix NetFlow version 5 netflow5 NetFlow version 9 netflow9 sFlow sflow Important For Juniper Networks' jFlow, use the netflow5 value. Scaling Network Flow Collection When planning your strategy for collecting network flows at scale, New Relic recommends 1 CPU per 2000 flows-per-second (120,000 flows-per-minute). Deciding whether to run more small containers to distribute load or fewer large containers to consolidate management is a matter of personal preference. Set up network flow data monitoring in New Relic One In your local machine, from a Linux host with Docker installed, download the ktranslate image from dockerhub by running bash Copy $ docker pull kentik/ktranslate:v2 Copy the snmp-base.yaml file to the local $HOME directory of your Docker user, and discard the container by running bash Copy $ cd . $ id=$(docker create kentik/ktranslate:v2) $ docker cp $id:/etc/ktranslate/snmp-base.yaml . $ docker rm -v $id In the snmp-base.yaml file, add your network flow devices inside the devices variable with the following structure: devices: flowDevice: device_name: edge-router device_ip: 10.10.1.254 flow_only: true user_tags: owning_team: net_eng environment: production Copy Tip If you're already monitoring SNMP data devices that send network flow data, you don't need to add them in your snmp-base.yaml file. Run ktranslate to listen for network flows from devices by entering the following commands: Important Add your New Relic license key and your account ID in the $NR_LICENSE_KEY and $NR_ACCOUNT_ID variables respectively. bash Copy $ docker run -d --name ktranslate-sflow --restart unless-stopped --net=host \\ > -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ > -e NEW_RELIC_API_KEY=$NR_LICENSE_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$NR_ACCOUNT_ID \\ > -metrics=jchf \\ > -log_level=info \\ > -tee_logs=true \\ > -flow_only=true \\ > -nf.source=sflow \\ > nr1.flow $ ## If your account is located in Europe, you need to add the following option before the nr1.flow line $ ## -nr_region=EU \\ To get better visibility into your network, set up SNMP data monitoring. Visualize your network performance data in New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 214.01762,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set up <em>network</em> flow data <em>monitoring</em>",
        "sections": "Set up <em>network</em> flow data <em>monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": " supports <em>monitoring</em> one type of <em>network</em> flow data type at a time. If you want to <em>monitor</em> several types, each will require a container. IPFIX and NetflowV9 can be sent to the same container, but we recommend running a separate container as a best practice. To check the equivalence among the <em>network</em>"
      },
      "id": "612724e128ccbc4ac9f2612a"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application": [
    {
      "sections": [
        "What is an entity in New Relic?",
        "What's an entity?",
        "Find and explore entities and entity data",
        "Tip",
        "Group and organize entities",
        "Customize entity data with entity synthesis",
        "Reserved attributes for synthesized entities",
        "Entity relationships",
        "Important",
        "Which relationships are created?",
        "Source: New Relic agent",
        "Source: Infrastructure",
        "Source: Synthetics monitor",
        "Source: Kubernetes",
        "External services"
      ],
      "title": "What is an entity in New Relic?",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "52a3e08bc9103c717d27b153e4fd4f547d6ecc32",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-09-14T10:08:21Z",
      "updated_at": "2021-09-01T17:25:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic monitoring is built around the concept of entities. In this doc, you'll learn how we define entities, what you can do with them, and how you can create your own entities or groupings of entities. What's an entity? From a New Relic perspective, entity is purposefully a broad concept. An entity is anything that a) reports data to New Relic or that contains data that we have access to, and b) is something we've identified with a unique entity ID. For most entities, the ID is indicated by the attribute entityGuid. An entity can be any fundamental data-reporting component, like an application, a host, or a database service, but it can also refer to larger groupings of those components. For example, to monitor a data center, you could aggregate those hosts in New Relic to be a workload (a custom grouping of entities). That workload is, itself, also an entity. Also very important is the relationships between entities. Our behind-the-scenes relationship-mapping helps us understand how entities are connected, how they affect each other. And this allows us to give you the power to configure how any data you're bringing in is related to existing entities, or how it's related to other entities. Our focus on entities and their relationships is important because our goal is to give you practical information about your business-important entities, and not give you an unhelpfully huge stream of data from a huge list of monitored things. With more insight at the entity level, you can better monitor and troubleshoot complex, modern systems. Find and explore entities and entity data Tip You can create new entity types for monitoring any data source. Learn more about entity synthesis. Some tips for finding and understanding entity data: To find an entity's entityGuid and entityName and other metadata: from any list of monitored entities in the New Relic Explorer, click an entity's icon, and click See metadata and tags. For most entities, its GUID is reported as the attribute entityGuid. For workloads, it's workloadGuid. You can run NRQL queries to find entities by their GUID. To see connections between entities, you have several options: When viewing an entity in the UI, use the Related entities UI. Service maps. Distributed tracing. Our NerdGraph API. To group entities together, see Group entities. Customize entity definitions and relationships. To learn technical details about entity types, see our GitHub repo. In an entity type's definition file, you'll see information like: The domain: for example, APM, or Infra. Its type: for example, Application or AWSECSCONTAINERINSTANCE. Default tags. The entityExpirationTime: how long data from that entity lasts in the UI, which is different from database data retention. Group and organize entities You can place entities into groups that reflect business-important relationships in your organization. For example, you might group all entities related to a specific team or department, or related to a specific service. Or you might group multiple hosts together to reflect their grouping in a data center. To group your entities, see: Tag entities. Create workloads, which allow you to group business-important sets of entities. Create entities and customize entity data Customize entity data with entity synthesis If you have telemetry from any source that's not supported by New Relic out of the box, you can propose a mapping for it. Once approved, any telemetry received by New Relic that matches your definition file will be synthesized into an entity. To learn more: For reserved attributes and how entity relationships are defined, keep reading this doc. For how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Reserved attributes for synthesized entities These attributes are meant to be synthesized from the telemetry we receive. Do not set them unless you're aware of the implications and consequences. Attribute Description entity.guid Generally, you should not set this attribute field on your telemetry data. New Relic may add this field to ingested data to store a unique identifier for the entity associated with the data point. If telemetry arrives with the entity.guid attribute already present, then New Relic will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. One use case for passing this attribute is to associate ingested telemetry with an entity already created by New Relic. When the entity.guid attribute is sent, the value will override New Relic’s entity identification system (such as entity synthesis definitions) and instead will use the attribute as the data. entity.name This attribute shouldn't be put on ingested telemetry data unless you're trying to override the entity name that would have been selected by New Relic’s entity identification system. While New Relic won't change the value if it's already present on the data, New Relic may add the attribute to your data. Therefore invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. If this field is present on ingested telemetry, its value will be used to name the entity associated with the data point. This name will be used instead of the name selected by New Relic’s entity identification system (for example, entity synthesis definitions). Note that many entities use the name as part of their identification, so changing this field may result in the generation of a new entity. entity.type This attribute shouldn't be put on ingested telemetry data except for certain legacy cases where it's required to distinguish entity types. Passing this field may interfere with entity detection, particularly if unrecognized values are sent in this field. While New Relic won't change the value if already present on the data, the field is not guaranteed to provide unambiguous filtering of telemetry at query-time. Existing entity definitions already have overlapping values, and we recommend avoiding entity.type in favor of other fields for filtering telemetry queries. This field is used by New Relic, meaning that invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. To learn how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Entity relationships Connections between entities are automatically created by New Relic based on what we can infer from your telemetry. For example, when two services that communicate using HTTP are instrumented with New Relic, we infer a \"calls/called-by\" relationship between them. When viewing a specific entity in either the New Relic Explorer, Navigator, or Lookout, you can see its Related entities in the entity's mini overview. This gives a visualization of the various entities connected directly to the current entity. You can quickly view important metrics for these related entities and navigate from one entity to another, through all the connected parts of your stack. Tip Learn more about how entities are related with our NerdGraph API. When relationships are not automatically detected, you can manually create them using the \"Add/edit related entities\" link in Related entities. Important Currently, you can only manually create calls/called-by relationships between service entities. Tip To manage manual relationships, you need to have modify and delete capabilities on entity relationships. If you don’t see the edit relationships button, contact your account admin. Which relationships are created? These are the relationships created between entities: Source: New Relic agent Relationship source Relationship type Relationship target Why is the relationship created? Application instrumented with a New Relic agent CALLS Application instrumented with a New Relic agent Relationships between applications monitored by New Relic agents are reported using the DurationByCaller metric. The callee reports the metric. For example, the metric DurationByCaller/Mobile/100/1234/HTTP/all indicates that the caller is APPLICATION 1234 for account 100. Application instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent An application (caller) that calls a service (callee) monitored by New Relic creates a relationship that's reported by the caller using the ExternalApp metric. For example, the metric ExternalApp/dirac.vips.net/100#1234/all indicates that the callee is APPLICATION 1234 for account 100. The metric is reported if the callee successfully responds to the caller. Service instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent When a New Relic agent detects that a service (caller) calls another service (callee) instrumented by New Relic, the callee reports the metric ClientApplication. For example, the metric ClientApplication/100#1234/all indicates that the caller is APPLICATION 1234 for account 100. Service instrumented with a New Relic agent CALLS A datastore instance When an application calls a datastore instance it creates a relationship reported with the DatastoreInstance metric. For example, the metric Datastore/instance/MySQL/172.16.16.3/3306 indicates the datastore instance is vendor: MySQL, host: 172.16.16.3, port: 3306. This metric also supports the legacy datastore instance format Datastore/instance/MySQL/172.16.16.3:3306. Currently we cannot determine whether the datastore instance is instrumented by New Relic and has an entity associated to it. APM agent SERVES Browser agent This relationship is created when an APM agent injects the browser agent into a page. Workload entity CONTAINS Any entity When a workload is created or updated, relationships for each of the entities that belong to the workload are created. Because some workloads are “dynamic” (defined by tags), relationships are re-created every 5 minutes. This way entities can join or leave the workload. Source: Infrastructure Relationship source Relationship type Relationship target Why is the relationship created? Infrastructure host HOSTS Application This relationship is created when an application is running in one or more hosts, and the infra agent is running in those hosts. Infrastructure host HOSTS Container This relationship is created when containers are running in one or more hosts, and the host is instrumented with the infra agent. Source: Synthetics monitor Relationship source Relationship type Relationship target Why is the relationship created? Synthetics Monitor CALLS Browser agent This relationship is created when a synthetics monitor checks a page instrumented with the browser agent. Synthetics Monitor CALLS APM application Agent events that contain the attribute nr.syntheticsMonitorId have been described as synthetics monitors (the source) interacting with an APM application (the target). If the header exists and the APM application Id exists, a relationship is created between the monitor and the app. Source: Kubernetes Relationship source Relationship type Relationship target Why is the relationship created? Cluster CONTAINS Pod This relationship is created when a pod is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Deployment This relationship is created when a deployment is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS DaemonSet This relationship is created when a DaemonSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS StatefulSet This relationship is created when a StatefulSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Host This relationship is created when a host that's part of a cluster is instrumented with the New Relic Kubernetes integration. Deployment CONTAINS Pod This relationship is created when a deployment creates a pod in a cluster instrumented with the New Relic Kubernetes integration. DaemonSet CONTAINS Pod This relationship is created when a DaemonSet is created a pod in a cluster instrumented with the New Relic Kubernetes integration. StatefulSet CONTAINS Pod This relationship is created when a StatefulSet creates a pod in a cluster instrumented with the New Relic Kubernetes integration. Pod CONTAINS Container This relationship is created when a pod creates a container in a cluster instrumented with the New Relic Kubernetes integration. Host HOSTS Pod This relationship is created when a pod is running in a host that's part of a cluster instrumented with the New Relic Kubernetes integration. Container HOSTS Application This relationship is created when an application is running in docker, and the hosts where docker is running are instrumented by the the infra agent. External services Relationship source Relationship type Relationship target Why is the relationship created? External service CALLS External service When the relationship is created, the external service reports a span with its name on the service.name attribute and the name of the service that initiates the call in the parent.service.name attribute. Application IS External service A relationship between an application and an external service is created so that users can navigate between them using the related entities component. Browser application instrumented with a New Relic agent CALLS External service A browser application reports an Ajax/HostTransaction metric when calling an external service (URL). Example metric: Ajax/HostTransaction/api.segment.io:443/CallbackTime' Cluster CONTAINS External service When the relationship is created, the external service reports a span with the attribute k8s.cluster.name, the name of the cluster. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span. Pod HOSTS External service When the relationship is created, the external service reports a span with the following attributes: service.name: The name of the service. k8s.cluster.name: The name of the cluster. k8s.pod.name: The name of the pod that’s running the service. k8s.namespace.name: The namespace where the pod was created. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.913,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What is an entity in <em>New</em> <em>Relic</em>?",
        "sections": "What is an entity in <em>New</em> <em>Relic</em>?",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": ". If telemetry arrives with the entity.guid attribute already present, then <em>New</em> <em>Relic</em> will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. <em>One</em> <em>use</em> case for passing this attribute is to associate"
      },
      "id": "603ec160e7b9d295f72a07fc"
    },
    {
      "sections": [
        "Dependencies UI: View an entity's upstream and downstream dependencies",
        "Requirements",
        "View dependencies"
      ],
      "title": "Dependencies UI: View an entity's upstream and downstream dependencies",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "2b2f328a6281bb155bcde07efec7f42eae943048",
      "image": "https://docs.newrelic.com/static/aabc5f64a91cc01b6e226df53c62458f/c1b63/new-relic-one-dependencies-UI.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/explore-downstream-dependencies-new-relic-one/",
      "published_at": "2021-09-14T10:09:26Z",
      "updated_at": "2021-08-21T09:29:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the New Relic Explorer, an entity's Dependencies page shows a filterable list of all the applications, services, databases, and hosts connected to the entity. It shows upstream and downstream dependencies, and provides paths to explore them. Similar to service maps, the dependencies page helps you understand how all of your upstream and downstream services are connected. It also uses the same color coding system used by service maps to show you what's performing well and what isn't. Requirements To view an entity's dependencies, make sure your app uses the minimum required APM agent version: C 1.0.0 or higher Go 1.11 or higher Java 3.9.0 or higher .NET 4.2 or higher Node.js 2.0.0 or higher PHP 4.19.0 or higher Python 2.38.0.31 or higher Ruby 4.3.0 or higher View dependencies To view dependencies for applications, services, databases, and hosts connected to an entity: Go to one.newrelic.com, select Explorer, and select an entity. Select Dependencies. To drill down further, filter the apps, services, databases, or hosts. one.newrelic.com > Explorer > (select an entity) > Dependencies: View a filterable list of all the apps, services, databases, and hosts connected to an entity, and their color-coded health status. You can filter the dependencies page to view specific things that report to the entity. Dependencies include: Services: APM-monitored applications and services. Mobile applications: your mobile apps. Browser applications: your front-end browser apps. External services: external services monitored by APM. External services include out-of-process services such as web services, resources in the cloud, and any other network calls. Databases: your application's database and cache data. Databases are agentless. Because of this, alerts cannot be set for the database, as only the service call is reported to New Relic. Hosts: your infrastructure (servers and hosts).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.90526,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": "In the <em>New</em> <em>Relic</em> Explorer, an entity&#x27;s Dependencies page shows a filterable list of all the applications, services, databases, and hosts connected to the entity. It shows upstream and downstream dependencies, and provides paths to explore them. Similar to service maps, the dependencies page helps"
      },
      "id": "603eb2e564441f0fe44e889b"
    },
    {
      "sections": [
        "Basic platform UI: search, share, chart UI, customize navigation, and more",
        "Observe your platform",
        "Customize the navigation bar and shortcuts",
        "Light and dark mode",
        "Search accounts and entities",
        "Chart and query features",
        "Share New Relic views with others",
        "Account and user settings",
        "Other UI experiences"
      ],
      "title": "Basic platform UI: search, share, chart UI, customize navigation, and more",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "b3cdcfc60a2821dfa5bee9766aba483cc3389398",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-09-14T10:08:22Z",
      "updated_at": "2021-08-21T09:29:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One has some basic UI functions that are widely available across the platform. Understanding these features will help you find and analyze your data more easily. Observe your platform New Relic One gives you full access to the data from all the entities in your stack. Go to the New Relic Explorer at one.newrelic.com to see a full list of entities, identify overall behaviors, filter them to locate sources of performance issues, or plan improvements for your system. Customize the navigation bar and shortcuts Select the edit icon at the right end of the navigation bar to customize your view. Home, Explorer, Browse data, Dashboards, and Alerts & AI are fixed, but you can favorite up to six more elements to display on the bar as well. The rest will go on the More group. Navigation shortcuts are a faster way to find entities and apps that are relevant to you. Mouse over any menu item for quick access to your favorite entities, those you recently visited, or just to search without having to navigate to a specific section. If you click on an entity, you can choose to open it in the same browser tab or in a new one. Light and dark mode See Light and dark mode. Search accounts and entities Access Quick find clicking the button, near the top right of the New Relic One UI. Some details about your search: You can search across all accounts that you have been granted access to in your organization. For more about account access, see Factors affecting access. Entities that cease to exist are available in search for eight days. If your organization has multiple accounts, use the account picker at the top left corner to select accounts. Chart and query features You can add most charts to a new or existing dashboard. Here are some query and chart features available across all or most of the platform: If you want to... Do this... Start querying your data Mouse over Browse data and select metrics, events, logs, or traces for a direct access to any of those types of data. Also, at the top of any UI page, select Query your data to access the data explorer and query builder. View a chart's query For some charts, you can view the NRQL query used to generate that chart. This can help you understand a chart better or use it as the basis for a new query. Choose time range Drag across a section of a chart to zoom in on that time range. Or, use the time picker in the top right corner of the UI to select pre-set time ranges or set a custom one. View chart details Mouse over a chart to see a pop-up with more detail. For some charts, selecting a point on the chart will take you to a UI page with more information about that metric. Hide or return chart elements To hide or unhide a displayed chart element, select that element's name below the chart. The chart display will adjust to reflect the absence or presence of that element. Share New Relic views with others Here are some options for sharing New Relic UI pages and visualizations. If you want to... Do this... Share UI pages and dashboards To share an entire New Relic UI page, click Share near the top of the UI to copy the URL. Share charts If New Relic charts are built with NRQL queries, they have a menu that exposes various options, including sharing options like Get as image and Get chart link. Some notes about sharing: The person you share with may not have access to view the data from that account. To solve that, someone on your team with New Relic user management abilities must add that person to the account. If someone can't access a custom dashboard, it may be that it is set to private. Read more about dashboard permissions. Some sharing options have associated time ranges, which may impact later viewings of it. For example, if you use a chart's Get chart link option and that chart is set to 'Last 30 minutes', when viewed it will show the last 30 minutes, not the time range displayed when it was shared. To share a specific time range, you must select that time range in the UI. Account and user settings To find account settings and user preferences, use the account dropdown, located at the top right of the UI, beside your user name. Other UI experiences This has been a look at a few basic platform UI experiences. For more about the UI, search for docs related to the specific New Relic solution you're using.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.90526,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Share <em>New</em> <em>Relic</em> views with others",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> has some basic UI functions that are widely available across the platform. Understanding these features will help you find and analyze your data more easily. Observe your platform <em>New</em> <em>Relic</em> <em>One</em> gives you full access to the data from all the entities in your stack. Go to the <em>New</em> <em>Relic</em>"
      },
      "id": "603ec1f964441f5b0e4e8860"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/core-concepts/dashboards-api-migration-insights-api-nerdgraph": [
    {
      "sections": [
        "Dashboards API",
        "Starting out with NerdGraph",
        "Operations",
        "Dashboard CRUD operations",
        "Dashboard page operations",
        "Other operations",
        "Limits",
        "Dashboard limits",
        "Dashboard page limits",
        "Widget limits",
        "Errors as first class citizens",
        "Errors as part of every mutation response"
      ],
      "title": "Dashboards API",
      "type": "docs",
      "tags": [
        "Dashboards",
        "Dashboards API"
      ],
      "external_id": "96f807b5a19101ec83176ceeb95b822eb8165896",
      "image": "",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/dashboards-api/",
      "published_at": "2021-09-14T13:38:25Z",
      "updated_at": "2021-08-08T11:47:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Dashboards API allows you to create and manage dashboards. Starting out with NerdGraph If you're new to NerdGraph and GraphQL, you may want to first read our Introduction to NerdGraph. If you’re already familiar with the dashboards API, you can read Create dashboards with NerdGraph. When using NerdGraph, it helps to understand that our dashboards are entities that report data from other entities, such as monitored apps, hosts and services. Find the NerdGraph API explorer at api.newrelic.com/graphiql. Operations We have defined a granular GraphQL API that lets you execute different dashboard operations depending on their goal and scope. Dashboard CRUD operations Operation GraphQL operation type Notes actor > entity() query Get dashboard operation. You can get all dashboard and widget data for a given dashboard entity GUID. dashboardCreate() mutation Create dashboard operation. You can create a dashboard attached to a specific account by specifying all its elements, from metadata to widget configuration. dashboardUpdate() mutation Update dashboard operation. You can update an existing dashboard given a dashboard entity GUID. You need to specify the complete, updated dashboard elements, from metadata to widget configuration. dashboardDelete() mutation Delete dashboard operation. You can delete an existing dashboard given a dashboard entity GUID. This operation executes a logical delete that lets you recover your dashboard. dashboardUndelete() mutation Undelete dashboard operation. You can recover a previously deleted dashboard given a dashboard entity GUID. Dashboard page operations Operation GraphQL operation type Notes dashboardUpdatePage() mutation Update dashboard page operation. You can update one page of an existing dashboard given a dashboard page entity GUID. You need to specify the complete, updated dashboard page elements, from metadata to widget configuration. dashboardUpdateWidgetsInPage() mutation Update widgets operation. You can update a set of existing widgets of a dashboard page given a dashboard page entity GUID. You need to specify the set of widgets to be updated and their complete configuration. dashboardAddWidgetsToPage() mutation Add widgets operation. You can add a set of new widgets to a dashboard page given a dashboard page entity GUID. You need to specify the set of new widgets and their complete configuration. Other operations Operation GraphQL operation type Notes dashboardCreateSnapshotUrl() mutation Create dashboard page snapshot operation. You can create a public URL for a given dashboard page entity GUID. The dashboard page can then be accessed in the form of a static snapshot in the resulting public URL. actor > dashboard > liveUrls() query List all live URLs operation. You can get the complete list of live URLs you have access to. A live URL is a mechanism that allows you to share dashboard pages and widgets publicly with up-to-date or live data. dashboardWidgetRevokeLiveUrl() mutation Revoke widget live URL operation. You can revoke a previously created live URL of a widget. As a result, the live URL will become unavailable to the public. Limits We have limited the values you can set to some of the dashboard properties. This allows us to keep dashboards in good shape while boosting their usability. Dashboard limits Limit Value Maximum number of pages in a dashboard 20 Maximum length of a dashboard name 255 Maximum length of a dashboard description 1024 Dashboard page limits Limit Value Maximum number of widgets in a dashboard page 100 Maximum length of a dashboard page name 255 Maximum length of a dashboard page description 1024 Widget limits Limit Value Maximum length of a widget title 255 Maximum number of entities linked to a widget 1 Maximum number of queries in a widget 20 Maximum layout column of a widget 12 Minimum layout column of a widget 1 Minimum layout row of a widget 1 Maximum layout width of a widget 12 Minimum layout width of a widget 1 Maximum layout height of a widget 32 Minimum layout height of a widget 1 Errors as first class citizens All dashboard mutations offer a way to ask for errors when being executed. This means that you can perform your dashboard mutations and check the response in order to detect expected potential issues. Every error has a type and a description to help you identify what’s the source of the problem. Errors as part of every mutation response mutation { dashboardMutation(guid: \"MY_EXISTING_DASHBOARD_GUID\") { mutationResult { result } errors { description type } } } Copy Keep in mind that these are expected errors that we are aware of in advance. You should also check for unexpected errors that will be returned in the standard GraphQL errors field.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 281.2509,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Dashboards</em> <em>API</em>",
        "sections": "<em>Dashboards</em> <em>API</em>",
        "tags": "<em>Dashboards</em> <em>API</em>",
        "body": "The <em>Dashboards</em> <em>API</em> allows you to create and manage <em>dashboards</em>. Starting out with <em>NerdGraph</em> If you&#x27;re new to <em>NerdGraph</em> and <em>Graph</em>QL, you may want to first read our Introduction to <em>NerdGraph</em>. If you’re already familiar with the <em>dashboards</em> <em>API</em>, you can read Create <em>dashboards</em> with <em>NerdGraph</em>. When using"
      },
      "id": "60dd3c8328ccbc8f1a71b46c"
    },
    {
      "sections": [
        "NerdGraph tutorial: View and manage workloads",
        "BETA FEATURE",
        "Important",
        "Get the workloads of an account",
        "Get the list of entities in a workload",
        "Get the status of a workload",
        "Create a workload",
        "Modify a workload",
        "Set a static status for a workload",
        "Modify the automatic status rules for a workload",
        "Duplicate a workload",
        "Delete a workload"
      ],
      "title": "NerdGraph tutorial: View and manage workloads",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "ffa158d197dbb207d50d48b813198842752d4b62",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/tutorials/nerdgraph-workloads-api-tutorials/",
      "published_at": "2021-09-14T20:37:24Z",
      "updated_at": "2021-09-14T20:37:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our NerdGraph API to do some workloads-related tasks: Get the workloads of an account Get the list of entities in a workload Get the status of a workload Create a workload Modify a workload Set a static status for a workload Modify the automatic status rules for a workload Duplicate a workload Delete a workload Important You can also use the CLI and Terraform resource to automate these tasks. Get the workloads of an account To get all workloads of an account, use the following GraphQL query and pass the account ID via the id field. In this example, we retrieve three basic fields: guid: the workload GUID. name: the workload name. permalink: the permanent URLs on the New Relic One UI. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collections { guid name permalink } } } } } Copy The response includes this type of data for each workload: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collections\": [ ..., { \"guid\": \"MTY...NTY\", \"name\": \"Acme Telco - Fulfillment Chain\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTY...NTY\" }, ... ] } } } }, \"extensions\": { ... } } Copy Get the list of entities in a workload You can get the entities that belong to a workload with the following query, just by passing the workload GUID (guid) as an argument. In this example we also retrieve some workload metadata: accountId: the workload account. name: the workload name. permalink: the workload permanent URL on the New Relic One UI. alertSeverity: the status of the workload. This value can have up to 10 minutes of delay; if you want to force the calculation of the workload status in query time, please use the Get the status of a workload example. The nested collection, members and results objects, which contain the actual list of entities: The name argument in the collection object takes the value WORKLOAD. count: Number of entities in the workload. { actor { entity(guid: \"YOUR_WORKLOAD_GUID\") { accountId name permalink ... on AlertableEntity { alertSeverity } ... on CollectionEntity { collection(name: \"WORKLOAD\") { members { count results { entities { accountId entityType name guid ... on AlertableEntityOutline { alertSeverity } } } } } } } } } Copy The query returns a list of entities that looks like this: { \"data\": { \"actor\": { \"entity\": { \"accountId\": 1606862, \"name\": \"Acme Telco - Ecommerce\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"alertSeverity\": \"CRITICAL\", \"collection\": { \"members\": { \"count\": 201, \"results\": { \"entities\": [ { \"accountId\": 1606862, \"alertSeverity\": \"CRITICAL\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"MTYwNjg2MnxBUE18QVBQTElDQVRJT058NDMxOTIwNTg\", \"name\": \"Fulfillment Service\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_HOST_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw3MDQzMzA2NzIyMjk2NDg4Mzc\", \"name\": \"ip-172-31-16-222\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_AWS_LAMBDA_FUNCTION_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw1MjMyNzM2ODgzNjAwNjYyMjE1\", \"name\": \"TelcoDT-purchase-log-lambda\" }, ... ] } } } } } } } Copy Get the status of a workload If you want to force the calculation of the status of a workload, you can use the following query, passing the account id (id) as the argument for the account field, and the workload GUID (guid) as the argument for the collection field. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collection(guid: \"YOUR_WORKLOAD_GUID\") { guid status { value } } } } } } Copy And this is what you'll get in the response: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collection\": { \"guid\": \"MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"status\": { \"value\": \"OPERATIONAL\" } } } } } } } Copy Note that the DISRUPTED status value is a synonym for CRITICAL status. Create a workload The following is an example NerdGraph call that creates a workload using the workloadCreate mutation query: mutation { workloadCreate( accountId: NEW_WORKLOAD_ACCOUNT_ID, workload: { name: \"NAME_OF_WORKLOAD\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(type = 'SERVICE') and tags.label.environment = 'production'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Some details on parts of this query: account: The workload account ID. Workloads can't be moved between accounts, so it's not possible to change this value later. name: A string with a user-friendly name for the workload. scopeAccounts: Scope accounts are the accounts where the entity data is fetched from. Scope accounts must belong to a group under the same parent account or enterprise partnership as the workload account. To define the entities in the workload, you can use one or both of these options: entitySearchQueries: This allows you to dynamically generate an array of entities. A name for each query is not needed. Here's an example dynamic query: (domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'production' Copy entityGuids: This is for choosing specific entity GUIDs for inclusion in the workload. guid: This returns the workload guid. Because NerdGraph provides schema stitching, you can get other details about the workload, like the permalink. Modify a workload To modify a workload, use the workloadUpdate mutation. You must know the workload's guid. The workload account can't be changed. For the fields you can modify, see Create workloads. These additional rules apply: entitySearchQueries: This field must contain all the queries as you expect them to be stored. If you want to add a new query, include it in the query field and don't provide any query id. If you want to modify an existing query, include it in the query field and provide its existing id. If you want to delete an existing query, just don't add any query with that id anymore. Here's an example of the workloadUpdate query: mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { name: \"A new name for the workload\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'staging'\" }, { id: AN_EXISTING_QUERY_ID, query: \"(type = 'SERVICE') and tags.label.environment = 'staging'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Set a static status for a workload You can set up a static status for a workload, which overrides any automatic status calculation. To set a static status, you must know the workload's guid and use the following fields: enabled: Remember to set this field to true to propagate the status value. status: The status value you want to set for this workload. Supported values are OPERATIONAL, DEGRADED or DISRUPTED. description: A text field to provide additional details. mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { statusConfig: { static: { enabled: true, status: DEGRADED, description: \"Game day. Expect some turbulence today between 8 and 9am PST.\" } } } ) { guid updatedAt status { value } } } Copy Modify the automatic status rules for a workload When you create a workload, you can use the statusConfig object to define which automatic rules you want to use to calculate the status of the workload. If you leave the rules array empty, no rules will be set up for your workload. However, if you just don't use the statusConfig object when you create a workload, the following rules will be added by default: \"statusConfig\": { \"automatic\": { \"enabled\": true, \"rules\": [ { \"entitySearchQueries\": [{\"query\": \"(domain = 'APM' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'MOBILE' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'BROWSER' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'SYNTH' and type = 'MONITOR')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } ], \"remainingEntitiesRule\": { \"rollup\": { \"groupBy\": \"ENTITY_TYPE\", \"strategy\": \"BEST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } } } Copy This is how you read the configuration: enabled: The automatic status calculation is enabled when this field is set to true. rules: An array of rules. In the default configuration, four rules are set for those entity types that are closer to the digital experience (that is, synthetic monitors, browser applications, mobile applications, and services). For each of these groups, the status of the unhealthiest rolls up. remainingEntitiesRule: This is the rule that will apply to all entities that haven't been evaluated in any other rule. In the default configuration, the remaining entities are grouped by entity type, and we make the status of each group to match that of its healthiest entity. If you want to modify these rules, you must use the workloadUpdate mutation, and send the complete new statusConfig object that you want to use. You can disable the automatic status calculation while keeping the configuration, by setting the statucConfig.automatic.enabled to false. Alternatively, you can delete all automatic regular rules by sending an empty array. And you can delete the rule for the remaining entities by just not adding the remainingEntitiesRule object. Duplicate a workload To duplicate a workload you first need to know its guid. In the workloadDuplicate mutation, you must pass as parameters: accountId: The account where you want to create the new workload. sourceGuid: the guid of the workload you want to duplicate. workload.name: Optional. You can specify a name for the new workload. If you don't specify one, the new workload will get the name of the original workload appended with - Copy. After duplicating a workload, you can modify it. mutation { workloadDuplicate( accountId: NEW_WORKLOAD_ACCOUNT_ID, sourceGuid: \"ORIGINAL_WORKLOAD_GUID\", workload: { name: \"New workload\" } ) { guid } } Copy Delete a workload To delete a workload, use the workloadDelete mutation and specify the workload GUID. When you delete a workload, all history and metadata is also deleted.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 239.39784,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View and manage workloads",
        "sections": "<em>NerdGraph</em> tutorial: View and manage workloads",
        "tags": "<em>NerdGraph</em>",
        "body": "BETA FEATURE This feature is currently in beta. New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our <em>NerdGraph</em> <em>API</em> to do some workloads-related tasks: Get"
      },
      "id": "603e9eb7e7b9d22a5f2f37b1"
    },
    {
      "sections": [
        "Introduction to NRQL, New Relic's query language",
        "What is NRQL?",
        "Where can you use NRQL?",
        "What data can you query with NRQL?",
        "Tip",
        "Start using NRQL",
        "Important",
        "NRQL query examples",
        "Basic NRQL query of browser data",
        "Attribute name with a space in it",
        "Querying multiple data sources",
        "Query returning multiple columns",
        "NRQL syntax"
      ],
      "title": "Introduction to NRQL, New Relic's query language",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "Get started"
      ],
      "external_id": "51e361ee5ec2a2379486d6686677e0383eb49163",
      "image": "https://docs.newrelic.com/static/04052353f8dbe132cd384d7472778b3f/c1b63/new-relic-view-chart-nrql-query_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language/",
      "published_at": "2021-09-14T06:11:16Z",
      "updated_at": "2021-09-12T01:46:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "One way to query your New Relic data is with the New Relic Query Language (NRQL). This resource explains what NRQL is, when and how you can use it, and basic syntax rules. For more detailed information on querying, including a listing of clauses and functions and example queries, see NRQL syntax, clauses, and functions. What is NRQL? NRQL is New Relic's SQL-like query language. You can use NRQL to retrieve detailed New Relic data and get insight into your applications, hosts, and business-important activity. Reasons to use NRQL include: To answer a question for the purpose of troubleshooting or business analysis To create a new chart To make API queries of New Relic data (for example, using our NerdGraph API) NRQL is used behind the scenes to generate some New Relic charts: Some New Relic charts are built using NRQL. One way to start using NRQL is to view a chart's query and then edit it to make your own custom chart. Where can you use NRQL? You can use NRQL in these places: New Relic One query builder NerdGraph: our GraphQL-format API, which includes options for making NRQL queries one.newrelic.com > Query your data: You can run a NRQL query in New Relic One. This NRQL query shows a count of distributed tracing spans faceted by their entity names. NRQL is one of several ways to query New Relic data. For more on all query options, see Query your data. What data can you query with NRQL? NRQL allows you to query these New Relic data types: Event data from all New Relic products, including: APM events, like Transaction Browser monitoring events, like PageView Mobile monitoring events, like Mobile Infrastructure events, like ProcessSample Synthetics events, like SyntheticCheck Custom events, like those reported by the Event API Metric timeslice data (metrics reported by APM, browser, and mobile) The Metric data type (metrics reported by the Metric API and data sources that use that API) The Span data type (distributed tracing data) The Log data type (data from New Relic Logs) Tip Some data, like relationships between monitored entities, is not available via NRQL but is available using our NerdGraph API. Start using NRQL One way to start using NRQL and to understand what data you have available is to go to a NRQL interface (for example, the New Relic One query builder), type FROM, and press space. The interface will suggest available types of data: To see the attributes available for a specific data type, type FROM DATA_TYPE SELECT and press space. The interface will suggest available attributes. For example: To see the complete JSON associated with a data type, including all of its attributes, use the keyset() attribute. For example: FROM Transaction SELECT keyset() Copy NRQL is used behind the scenes to build some New Relic charts and dashboards. One way to learn NRQL is to find one of these NRQL-generated charts and start playing with the NRQL to create new, customized queries and charts: Charts built with NRQL will have View query as an option. You can then edit and customize that query to see how your changes affect the resulting visualization. Important To explore your data without having to use NRQL, use the data explorer. Learn more about querying data in New Relic. NRQL query examples Here's an example NRQL query of Transaction data, which is reported by APM. FROM Transaction SELECT average(duration) FACET appName TIMESERIES auto Copy This would generate a chart that looks like: Here are some more query examples: Basic NRQL query of browser data Here's a NRQL query of PageView data from browser monitoring. SELECT uniqueCount(user) FROM PageView WHERE userAgentOS = 'Mac' FACET countryCode SINCE 1 day ago LIMIT 20 Copy Attribute name with a space in it If a custom attribute name has a space in it, use backticks around the attribute name: SELECT count(*) FROM Transaction FACET `Logged-in user` Copy Querying multiple data sources To return data from two data sources, separate their data types with a comma. For example, this query returns a count of all APM transactions and browser events over the last three days: SELECT count(*) FROM Transaction, PageView SINCE 3 days ago Copy Query returning multiple columns To return multiple columns from a dataset, separate the aggregator arguments with a comma: SELECT function(attribute), function(attribute) ... FROM ... Copy This query returns the minimum, average, and maximum duration for browser monitoring PageView events over the last week: SELECT min(duration), max(duration), average(duration) FROM PageView SINCE 1 week ago Copy See more NRQL query examples. NRQL syntax The syntax of a NRQL query is similar to standard SQL queries. Here is a breakdown of the structure of a NRQL query: SELECT function(attribute) [AS 'label'][, ...] FROM data type [WHERE attribute [comparison] [AND|OR ...]][AS 'label'][, ...] [FACET attribute | function(attribute)] [LIMIT number] [SINCE time] [UNTIL time] [WITH TIMEZONE timezone] [COMPARE WITH time] [TIMESERIES time] Copy Basic rules include: NRQL condition Details Required values The SELECT statement and FROM clause are required. All other clauses are optional. You can start your query with either SELECT or FROM. Query string size The query string must be less than 4 KB. Case sensitivity The data type names and attribute names are case sensitive. NRQL clauses and functions are not case sensitive. Syntax for strings NRQL uses single quotes to designate strings. For example: ... where traceId = '030a573f0df02c57' Copy Attribute names with spaces Use backticks `` to quote a custom attribute name that has a space in it. For example: ... FACET `Logged-in user` Copy Data type coercion Insights does not support data type \"coercion.\" For more information, see Data type conversion. Use of math functions Basic and advanced math functions are supported in the SELECT statement. JOIN functions NRQL does not have the equivalent of the SQL JOIN function, but you can simulate a JOIN with custom attributes. Read more about NRQL syntax and functions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.31374,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " or business analysis To create a new chart To make <em>API</em> queries of New Relic data (for example, using our <em>NerdGraph</em> <em>API</em>) NRQL is used behind the scenes to generate some New Relic charts: Some New Relic charts are built using NRQL. One way to start using NRQL is to view a chart&#x27;s query and then edit"
      },
      "id": "60445a0e196a67cb09960f6e"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts": [
    {
      "sections": [
        "What is an entity in New Relic?",
        "What's an entity?",
        "Find and explore entities and entity data",
        "Tip",
        "Group and organize entities",
        "Customize entity data with entity synthesis",
        "Reserved attributes for synthesized entities",
        "Entity relationships",
        "Important",
        "Which relationships are created?",
        "Source: New Relic agent",
        "Source: Infrastructure",
        "Source: Synthetics monitor",
        "Source: Kubernetes",
        "External services"
      ],
      "title": "What is an entity in New Relic?",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "52a3e08bc9103c717d27b153e4fd4f547d6ecc32",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-09-14T10:08:21Z",
      "updated_at": "2021-09-01T17:25:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic monitoring is built around the concept of entities. In this doc, you'll learn how we define entities, what you can do with them, and how you can create your own entities or groupings of entities. What's an entity? From a New Relic perspective, entity is purposefully a broad concept. An entity is anything that a) reports data to New Relic or that contains data that we have access to, and b) is something we've identified with a unique entity ID. For most entities, the ID is indicated by the attribute entityGuid. An entity can be any fundamental data-reporting component, like an application, a host, or a database service, but it can also refer to larger groupings of those components. For example, to monitor a data center, you could aggregate those hosts in New Relic to be a workload (a custom grouping of entities). That workload is, itself, also an entity. Also very important is the relationships between entities. Our behind-the-scenes relationship-mapping helps us understand how entities are connected, how they affect each other. And this allows us to give you the power to configure how any data you're bringing in is related to existing entities, or how it's related to other entities. Our focus on entities and their relationships is important because our goal is to give you practical information about your business-important entities, and not give you an unhelpfully huge stream of data from a huge list of monitored things. With more insight at the entity level, you can better monitor and troubleshoot complex, modern systems. Find and explore entities and entity data Tip You can create new entity types for monitoring any data source. Learn more about entity synthesis. Some tips for finding and understanding entity data: To find an entity's entityGuid and entityName and other metadata: from any list of monitored entities in the New Relic Explorer, click an entity's icon, and click See metadata and tags. For most entities, its GUID is reported as the attribute entityGuid. For workloads, it's workloadGuid. You can run NRQL queries to find entities by their GUID. To see connections between entities, you have several options: When viewing an entity in the UI, use the Related entities UI. Service maps. Distributed tracing. Our NerdGraph API. To group entities together, see Group entities. Customize entity definitions and relationships. To learn technical details about entity types, see our GitHub repo. In an entity type's definition file, you'll see information like: The domain: for example, APM, or Infra. Its type: for example, Application or AWSECSCONTAINERINSTANCE. Default tags. The entityExpirationTime: how long data from that entity lasts in the UI, which is different from database data retention. Group and organize entities You can place entities into groups that reflect business-important relationships in your organization. For example, you might group all entities related to a specific team or department, or related to a specific service. Or you might group multiple hosts together to reflect their grouping in a data center. To group your entities, see: Tag entities. Create workloads, which allow you to group business-important sets of entities. Create entities and customize entity data Customize entity data with entity synthesis If you have telemetry from any source that's not supported by New Relic out of the box, you can propose a mapping for it. Once approved, any telemetry received by New Relic that matches your definition file will be synthesized into an entity. To learn more: For reserved attributes and how entity relationships are defined, keep reading this doc. For how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Reserved attributes for synthesized entities These attributes are meant to be synthesized from the telemetry we receive. Do not set them unless you're aware of the implications and consequences. Attribute Description entity.guid Generally, you should not set this attribute field on your telemetry data. New Relic may add this field to ingested data to store a unique identifier for the entity associated with the data point. If telemetry arrives with the entity.guid attribute already present, then New Relic will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. One use case for passing this attribute is to associate ingested telemetry with an entity already created by New Relic. When the entity.guid attribute is sent, the value will override New Relic’s entity identification system (such as entity synthesis definitions) and instead will use the attribute as the data. entity.name This attribute shouldn't be put on ingested telemetry data unless you're trying to override the entity name that would have been selected by New Relic’s entity identification system. While New Relic won't change the value if it's already present on the data, New Relic may add the attribute to your data. Therefore invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. If this field is present on ingested telemetry, its value will be used to name the entity associated with the data point. This name will be used instead of the name selected by New Relic’s entity identification system (for example, entity synthesis definitions). Note that many entities use the name as part of their identification, so changing this field may result in the generation of a new entity. entity.type This attribute shouldn't be put on ingested telemetry data except for certain legacy cases where it's required to distinguish entity types. Passing this field may interfere with entity detection, particularly if unrecognized values are sent in this field. While New Relic won't change the value if already present on the data, the field is not guaranteed to provide unambiguous filtering of telemetry at query-time. Existing entity definitions already have overlapping values, and we recommend avoiding entity.type in favor of other fields for filtering telemetry queries. This field is used by New Relic, meaning that invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. To learn how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Entity relationships Connections between entities are automatically created by New Relic based on what we can infer from your telemetry. For example, when two services that communicate using HTTP are instrumented with New Relic, we infer a \"calls/called-by\" relationship between them. When viewing a specific entity in either the New Relic Explorer, Navigator, or Lookout, you can see its Related entities in the entity's mini overview. This gives a visualization of the various entities connected directly to the current entity. You can quickly view important metrics for these related entities and navigate from one entity to another, through all the connected parts of your stack. Tip Learn more about how entities are related with our NerdGraph API. When relationships are not automatically detected, you can manually create them using the \"Add/edit related entities\" link in Related entities. Important Currently, you can only manually create calls/called-by relationships between service entities. Tip To manage manual relationships, you need to have modify and delete capabilities on entity relationships. If you don’t see the edit relationships button, contact your account admin. Which relationships are created? These are the relationships created between entities: Source: New Relic agent Relationship source Relationship type Relationship target Why is the relationship created? Application instrumented with a New Relic agent CALLS Application instrumented with a New Relic agent Relationships between applications monitored by New Relic agents are reported using the DurationByCaller metric. The callee reports the metric. For example, the metric DurationByCaller/Mobile/100/1234/HTTP/all indicates that the caller is APPLICATION 1234 for account 100. Application instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent An application (caller) that calls a service (callee) monitored by New Relic creates a relationship that's reported by the caller using the ExternalApp metric. For example, the metric ExternalApp/dirac.vips.net/100#1234/all indicates that the callee is APPLICATION 1234 for account 100. The metric is reported if the callee successfully responds to the caller. Service instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent When a New Relic agent detects that a service (caller) calls another service (callee) instrumented by New Relic, the callee reports the metric ClientApplication. For example, the metric ClientApplication/100#1234/all indicates that the caller is APPLICATION 1234 for account 100. Service instrumented with a New Relic agent CALLS A datastore instance When an application calls a datastore instance it creates a relationship reported with the DatastoreInstance metric. For example, the metric Datastore/instance/MySQL/172.16.16.3/3306 indicates the datastore instance is vendor: MySQL, host: 172.16.16.3, port: 3306. This metric also supports the legacy datastore instance format Datastore/instance/MySQL/172.16.16.3:3306. Currently we cannot determine whether the datastore instance is instrumented by New Relic and has an entity associated to it. APM agent SERVES Browser agent This relationship is created when an APM agent injects the browser agent into a page. Workload entity CONTAINS Any entity When a workload is created or updated, relationships for each of the entities that belong to the workload are created. Because some workloads are “dynamic” (defined by tags), relationships are re-created every 5 minutes. This way entities can join or leave the workload. Source: Infrastructure Relationship source Relationship type Relationship target Why is the relationship created? Infrastructure host HOSTS Application This relationship is created when an application is running in one or more hosts, and the infra agent is running in those hosts. Infrastructure host HOSTS Container This relationship is created when containers are running in one or more hosts, and the host is instrumented with the infra agent. Source: Synthetics monitor Relationship source Relationship type Relationship target Why is the relationship created? Synthetics Monitor CALLS Browser agent This relationship is created when a synthetics monitor checks a page instrumented with the browser agent. Synthetics Monitor CALLS APM application Agent events that contain the attribute nr.syntheticsMonitorId have been described as synthetics monitors (the source) interacting with an APM application (the target). If the header exists and the APM application Id exists, a relationship is created between the monitor and the app. Source: Kubernetes Relationship source Relationship type Relationship target Why is the relationship created? Cluster CONTAINS Pod This relationship is created when a pod is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Deployment This relationship is created when a deployment is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS DaemonSet This relationship is created when a DaemonSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS StatefulSet This relationship is created when a StatefulSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Host This relationship is created when a host that's part of a cluster is instrumented with the New Relic Kubernetes integration. Deployment CONTAINS Pod This relationship is created when a deployment creates a pod in a cluster instrumented with the New Relic Kubernetes integration. DaemonSet CONTAINS Pod This relationship is created when a DaemonSet is created a pod in a cluster instrumented with the New Relic Kubernetes integration. StatefulSet CONTAINS Pod This relationship is created when a StatefulSet creates a pod in a cluster instrumented with the New Relic Kubernetes integration. Pod CONTAINS Container This relationship is created when a pod creates a container in a cluster instrumented with the New Relic Kubernetes integration. Host HOSTS Pod This relationship is created when a pod is running in a host that's part of a cluster instrumented with the New Relic Kubernetes integration. Container HOSTS Application This relationship is created when an application is running in docker, and the hosts where docker is running are instrumented by the the infra agent. External services Relationship source Relationship type Relationship target Why is the relationship created? External service CALLS External service When the relationship is created, the external service reports a span with its name on the service.name attribute and the name of the service that initiates the call in the parent.service.name attribute. Application IS External service A relationship between an application and an external service is created so that users can navigate between them using the related entities component. Browser application instrumented with a New Relic agent CALLS External service A browser application reports an Ajax/HostTransaction metric when calling an external service (URL). Example metric: Ajax/HostTransaction/api.segment.io:443/CallbackTime' Cluster CONTAINS External service When the relationship is created, the external service reports a span with the attribute k8s.cluster.name, the name of the cluster. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span. Pod HOSTS External service When the relationship is created, the external service reports a span with the following attributes: service.name: The name of the service. k8s.cluster.name: The name of the cluster. k8s.pod.name: The name of the pod that’s running the service. k8s.namespace.name: The namespace where the pod was created. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 273.17456,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What is an entity in <em>New</em> <em>Relic</em>?",
        "sections": "What is an entity in <em>New</em> <em>Relic</em>?",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": ". If telemetry arrives with the entity.guid attribute already present, then <em>New</em> <em>Relic</em> will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. <em>One</em> <em>use</em> case for passing this attribute is to associate"
      },
      "id": "603ec160e7b9d295f72a07fc"
    },
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-09-14T10:08:22Z",
      "updated_at": "2021-08-21T09:28:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. For APM agents, restart your service. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration, both methods require you to restart your service. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 241.49544,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Use</em> tags to help organize and find your data",
        "sections": "<em>Use</em> tags to help organize and find your data",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " to filter the UI <em>Use</em> the filter field at the top of the <em>New</em> <em>Relic</em> Explorer to filter down to the entities you care about. You can <em>use</em> multiple filter conditions. To filter down to certain entities using tags: From <em>one</em>.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "New Relic Lookout: Monitor your estate at a glance",
        "Why it matters",
        "Requirements",
        "Get started with New Relic Lookout",
        "Circle visualization and table view",
        "Abnormal golden signals",
        "Instant search",
        "Change view",
        "Drill down into the details",
        "Performance tab",
        "Abnormal History tab",
        "Correlations tab",
        "Profile tab",
        "Traces tab",
        "Create a custom view",
        "Query: Compare the last 15 minutes to the same time 1 day ago",
        "Query: Compare a specific time range to the same range a month ago",
        "Example: Unusual increases in error count"
      ],
      "title": "New Relic Lookout: Monitor your estate at a glance",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "9193dcc8851c185ff5d96f6f93ab412bd1be69e9",
      "image": "https://docs.newrelic.com/static/178b37068bad2a68cff027c8bdcf663a/c1b63/lookout-intro.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-lookout-monitor-your-estate-glance/",
      "published_at": "2021-09-14T07:54:08Z",
      "updated_at": "2021-08-21T09:27:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Lookout provides visibility into your entire estate. It doesn't require any configuration — you can query anything in your estate that matters to you right now and understand your system as a whole, or dive deep into causes and effects, so you can quickly get the data you need to take action. Know exactly where to focus your attention with New Relic Lookout. The brighter the color, the more severe the change, and the bigger the size, the bigger the scale. Then dig deeper with correlations and abnormal history to see how it impacts your whole system—no configuration needed. Why it matters New Relic Lookout helps software teams of any size discover potential issues before they have an impact. Fill gaps in monitoring with full coverage out-of-the-box, no configuration or setup required. Immediately see anything deviating from normal across your entire estate. Proactively spot emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in New Relic database (NRDB), including third-party, open, and custom data. Launch into other areas of New Relic One for deeper understanding Requirements New Relic Lookout requires Pro or Enterprise edition. If you are on Standard edition, you can still use the New Relic Lookout view in the New Relic Explorer. If you want to see data spanning 13-months, correlations, profiles, traces, and other details, you must upgrade to a higher edition. Get started with New Relic Lookout To access New Relic Lookout, click the Apps button in New Relic One and locate the New Relic Lookout launcher. You can also access New Relic Lookout directly from the New Relic One header bar, via the More dropdown. Enablement of key service performance indicator data is required for New Relic Lookout to provide value from the data you already have. The default view provides insight into three key Service performance indicators broken down by application: throughput, response time, and errors. These metrics are analyzed to show how the data has behaved during the last five minutes compared to the prior hour. one.newrelic.com > Apps > New Relic Lookout: Anything that significantly deviates from the trend is automatically discovered by New Relic Lookout, which doesn't require any configuration. Circle visualization and table view Each application (or other facet) is represented by a circle. The size of the circles indicate the magnitude of the signal for that application and the color indicates whether the value has significantly decreased or increased in the last five minutes, based on the standard deviation of the prior hour (default evaluation and comparison time windows.) Please note that the type of signal is important when interpreting your results. When you first look at the legend below, you might be tempted to interpret yellow as good and dark purple as bad, but that is not always the case. Here are some examples: In the APM/services golden signals, a dark yellow circle in Throughput might signify that something bad has occurred and led to a drop in traffic. At the same time, a dark purple circle might also be concerning due to unexpected load. Both are significant findings worth exploring. In browser golden signals, a dark purple circle in Page Views might be great, as you are seeing more traffic to your site! With errors golden signals (in all entity types), a large circle, even if gray (not deviating from normal volume), is worth exploring because a high count of errors in your system is important to investigate. The legend allows you to change the colors used to highlight deviating services To change the color palette, click the gear icon by the low-high color legend. This allows you to change the colors used to highlight deviating services. To get a table view of the same data, click the toggle on the right. You can also hover over each color to filter the view by degree lower or higher deviance. Abnormal golden signals On the right, New Relic Lookout displays the most significantly deviating applications (or other facet) in a side panel, weighted by both the magnitude of the performance indicators and the scale of their deviations. Details include the name of the key performance indicator, their magnitude during the recent time window, and the difference between the averages from one time compared to the other. Instant search Click the magnifying glass icon in the side panel to open a search box. Typing into the search box filters the circles, table, and abnormal signals to applications (or other facets) that contain the text. This is a good way to quickly zoom to various subsystems. New Relic Lookout doesn't rerun the analysis when using the instant search. Change view Click the Change View button on the right side panel. The panel that appears shows you all the entity-specific golden signals you can toggle between out of the box. By choosing the Browser Golden Signal or other views, you can change from the default view. Each new view will have the golden signals appropriate for that entity type. Drill down into the details To analyze an application or facet, click a circle, table row, or abnormal golden signal. The details panel shows the degree of deviation of the performance indicator, a link to the affected entity, and recent alert and deployment activity for that entity, when available. There’s also an indication of whether the selected evaluation time period would be abnormal or not in reference to other comparison time windows, such as the same time yesterday or the same time last week. This allows you to quickly see if the abnormal behavior is odd in general, or just based on the comparison time window. Performance tab The default tab shows charts for other key performance indicators for the selected application or facet. The charts compare the two time windows being analyzed. You can click their titles to rerun the analysis, focusing on the selected key performance indicator. When the target is a New Relic One application, we show the top transactions, error classes, external services, and database operations, alongside links to the relevant New Relic One features. Abnormal History tab This section analyzes past performance of the selected signal and calls out any time periods with notable abnormalities. Each card represents an abnormal time window and can be clicked for more details. The charts will display any relevant violations and deployments in New Relic. Correlations tab New Relic Lookout can find other signals that began behaving differently around the same time as the selected signal for that entity type. Clicking the name of the signal reruns the analysis, focusing on that key performance indicator. The chart titles link to New Relic One when there’s an associated entity in your account. Note that correlations currently do not analyze across accounts. The correlated signals displayed are for others in the account of the original application you are viewing. This helps focus the data on correlations that are more likely related to your issue. Profile tab Based on the same technology as New Relic’s error profiles, this tab compares the last five minutes to the prior hour by default (or whatever time windows you’ve selected with query editing) and surfaces any attributes that have significantly different distributions in the events being targeted by the selected signal. For example, if a custom attribute indicated that a recent throughput spike came from one user, that would surface highly in Profiles if most of the traffic usually comes from many users. Traces tab If the entity has distributed traces configured and available in the selected evaluated time window, the Traces section is enabled. Each card shows a summary of a trace and can be clicked for details. The Explore all traces links to the distributed traces application, filtered to the selected entity. Create a custom view To target signals and time windows beyond the default values, click the Change view button and select Custom view. To create your own view: Select the account or subaccount. Select the data type (metrics or events). Different functionality is available depending on the type. In View a chart with, select the metric or event you are interested in. Default is golden signals (throughput, response time, and errors). You can also build custom queries (filters) to target a signal that isn't on the list. In Facet by, select what the circles represent. Default is appName, but you can also choose host or any other facetable attribute available for the signal you’ve selected. If you plan to save/favorite this new view, provide a name in the Name your view box. Keep in mind that you can edit this view at any time using the pencil icon. The default time windows analyzed by New Relic Lookout are the last five minutes compared to the hour before. Use the time controls (View data from and Compare data to) to target other time windows. one.newrelic.com > Apps > New Relic Lookout: All event and metric data in the New Relic database can be queried using the Edit query feature. Click Analyze to begin analyzing the signal you’ve selected. You can also create your own query: Create your query. This query is comparing data from the past thirty minutes to data from the same range a day ago. Change from Basic to Advanced after clicking the Custom view button. Select the data type (metrics or events). Different functionality is available depending on the type. Enter your query using NRQL. Please note that not all NRQL features are available in the Lookout Advanced query feature. By default, the system will run this query using the last five minutes of data compared to the previous hour. Some examples of the syntax for changing the comparison and evaluation time windows are below. Click Analyze to begin analyzing the signal you’ve selected. Query: Compare the last 15 minutes to the same time 1 day ago Please note that the UNTIL NOW portion is required here unlike in standard NRQL. Without the UNTIL NOW added, the system will query a 5 minute slice of data starting 15 minutes ago SINCE 15 minutes AGO UNTIL NOW COMPARE WITH 1 day ago Copy Query: Compare a specific time range to the same range a month ago SINCE '2021-03-07 07:00:00-0500' UNTIL '2021-03-08 07:00:00-0500' COMPARE WITH 1 month ago Copy Or: SINCE 'today at midnight' UNTIL 'now' COMPARE WITH 1 MONTH AGO Copy Example: Unusual increases in error count The default view of New Relic Lookout shows application status across your estate, comparing the last five minutes to the hour before. Under regular operation, most large systems may have a handful of abnormalities, but usually most things will indicate normal behavior. Suddenly, several circles begin to change to red under the Errors section. This indicates that several applications are experiencing unusual increases in error count. It may be that one or two circles for important systems are red, and perhaps much larger than they usually appear. Clicking one of these can provide more information on what is happening. You might see that the error rate is substantially elevated, even thousands of percent higher than normal. To troubleshoot this issue, here's what you might discover in the New Relic Lookout tabs: Performance would show you data about other signals, illuminating the characteristics of the change in system dynamics. Correlations would surface other applications that are affected and how, as well as opportunities to pivot to other applications that may be closer to the underlying causes. Traces, in turn, would show distributed traces, which can provide specific examples of traffic running through those systems. Abnormal history would show other times in the past week with elevated errors, showing whether or not this problem happens regularly, such as every day at the same time or whenever there is a deployment. Profiles might show that all or most of the new errors share common properties, such as all being isolated to just one region/account/user. Combining the information from these sections, not only can you get a sense of what is going on, but also where to focus actions to resolve the problem.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 241.49419,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "sections": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in <em>New</em> <em>Relic</em> database (NRDB), including third-party, open, and custom data. Launch into other areas of <em>New</em> <em>Relic</em> <em>One</em> for deeper"
      },
      "id": "603e821e64441f5a444e8845"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-lookout-monitor-your-estate-glance": [
    {
      "sections": [
        "What is an entity in New Relic?",
        "What's an entity?",
        "Find and explore entities and entity data",
        "Tip",
        "Group and organize entities",
        "Customize entity data with entity synthesis",
        "Reserved attributes for synthesized entities",
        "Entity relationships",
        "Important",
        "Which relationships are created?",
        "Source: New Relic agent",
        "Source: Infrastructure",
        "Source: Synthetics monitor",
        "Source: Kubernetes",
        "External services"
      ],
      "title": "What is an entity in New Relic?",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "52a3e08bc9103c717d27b153e4fd4f547d6ecc32",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-09-14T10:08:21Z",
      "updated_at": "2021-09-01T17:25:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic monitoring is built around the concept of entities. In this doc, you'll learn how we define entities, what you can do with them, and how you can create your own entities or groupings of entities. What's an entity? From a New Relic perspective, entity is purposefully a broad concept. An entity is anything that a) reports data to New Relic or that contains data that we have access to, and b) is something we've identified with a unique entity ID. For most entities, the ID is indicated by the attribute entityGuid. An entity can be any fundamental data-reporting component, like an application, a host, or a database service, but it can also refer to larger groupings of those components. For example, to monitor a data center, you could aggregate those hosts in New Relic to be a workload (a custom grouping of entities). That workload is, itself, also an entity. Also very important is the relationships between entities. Our behind-the-scenes relationship-mapping helps us understand how entities are connected, how they affect each other. And this allows us to give you the power to configure how any data you're bringing in is related to existing entities, or how it's related to other entities. Our focus on entities and their relationships is important because our goal is to give you practical information about your business-important entities, and not give you an unhelpfully huge stream of data from a huge list of monitored things. With more insight at the entity level, you can better monitor and troubleshoot complex, modern systems. Find and explore entities and entity data Tip You can create new entity types for monitoring any data source. Learn more about entity synthesis. Some tips for finding and understanding entity data: To find an entity's entityGuid and entityName and other metadata: from any list of monitored entities in the New Relic Explorer, click an entity's icon, and click See metadata and tags. For most entities, its GUID is reported as the attribute entityGuid. For workloads, it's workloadGuid. You can run NRQL queries to find entities by their GUID. To see connections between entities, you have several options: When viewing an entity in the UI, use the Related entities UI. Service maps. Distributed tracing. Our NerdGraph API. To group entities together, see Group entities. Customize entity definitions and relationships. To learn technical details about entity types, see our GitHub repo. In an entity type's definition file, you'll see information like: The domain: for example, APM, or Infra. Its type: for example, Application or AWSECSCONTAINERINSTANCE. Default tags. The entityExpirationTime: how long data from that entity lasts in the UI, which is different from database data retention. Group and organize entities You can place entities into groups that reflect business-important relationships in your organization. For example, you might group all entities related to a specific team or department, or related to a specific service. Or you might group multiple hosts together to reflect their grouping in a data center. To group your entities, see: Tag entities. Create workloads, which allow you to group business-important sets of entities. Create entities and customize entity data Customize entity data with entity synthesis If you have telemetry from any source that's not supported by New Relic out of the box, you can propose a mapping for it. Once approved, any telemetry received by New Relic that matches your definition file will be synthesized into an entity. To learn more: For reserved attributes and how entity relationships are defined, keep reading this doc. For how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Reserved attributes for synthesized entities These attributes are meant to be synthesized from the telemetry we receive. Do not set them unless you're aware of the implications and consequences. Attribute Description entity.guid Generally, you should not set this attribute field on your telemetry data. New Relic may add this field to ingested data to store a unique identifier for the entity associated with the data point. If telemetry arrives with the entity.guid attribute already present, then New Relic will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. One use case for passing this attribute is to associate ingested telemetry with an entity already created by New Relic. When the entity.guid attribute is sent, the value will override New Relic’s entity identification system (such as entity synthesis definitions) and instead will use the attribute as the data. entity.name This attribute shouldn't be put on ingested telemetry data unless you're trying to override the entity name that would have been selected by New Relic’s entity identification system. While New Relic won't change the value if it's already present on the data, New Relic may add the attribute to your data. Therefore invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. If this field is present on ingested telemetry, its value will be used to name the entity associated with the data point. This name will be used instead of the name selected by New Relic’s entity identification system (for example, entity synthesis definitions). Note that many entities use the name as part of their identification, so changing this field may result in the generation of a new entity. entity.type This attribute shouldn't be put on ingested telemetry data except for certain legacy cases where it's required to distinguish entity types. Passing this field may interfere with entity detection, particularly if unrecognized values are sent in this field. While New Relic won't change the value if already present on the data, the field is not guaranteed to provide unambiguous filtering of telemetry at query-time. Existing entity definitions already have overlapping values, and we recommend avoiding entity.type in favor of other fields for filtering telemetry queries. This field is used by New Relic, meaning that invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. To learn how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Entity relationships Connections between entities are automatically created by New Relic based on what we can infer from your telemetry. For example, when two services that communicate using HTTP are instrumented with New Relic, we infer a \"calls/called-by\" relationship between them. When viewing a specific entity in either the New Relic Explorer, Navigator, or Lookout, you can see its Related entities in the entity's mini overview. This gives a visualization of the various entities connected directly to the current entity. You can quickly view important metrics for these related entities and navigate from one entity to another, through all the connected parts of your stack. Tip Learn more about how entities are related with our NerdGraph API. When relationships are not automatically detected, you can manually create them using the \"Add/edit related entities\" link in Related entities. Important Currently, you can only manually create calls/called-by relationships between service entities. Tip To manage manual relationships, you need to have modify and delete capabilities on entity relationships. If you don’t see the edit relationships button, contact your account admin. Which relationships are created? These are the relationships created between entities: Source: New Relic agent Relationship source Relationship type Relationship target Why is the relationship created? Application instrumented with a New Relic agent CALLS Application instrumented with a New Relic agent Relationships between applications monitored by New Relic agents are reported using the DurationByCaller metric. The callee reports the metric. For example, the metric DurationByCaller/Mobile/100/1234/HTTP/all indicates that the caller is APPLICATION 1234 for account 100. Application instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent An application (caller) that calls a service (callee) monitored by New Relic creates a relationship that's reported by the caller using the ExternalApp metric. For example, the metric ExternalApp/dirac.vips.net/100#1234/all indicates that the callee is APPLICATION 1234 for account 100. The metric is reported if the callee successfully responds to the caller. Service instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent When a New Relic agent detects that a service (caller) calls another service (callee) instrumented by New Relic, the callee reports the metric ClientApplication. For example, the metric ClientApplication/100#1234/all indicates that the caller is APPLICATION 1234 for account 100. Service instrumented with a New Relic agent CALLS A datastore instance When an application calls a datastore instance it creates a relationship reported with the DatastoreInstance metric. For example, the metric Datastore/instance/MySQL/172.16.16.3/3306 indicates the datastore instance is vendor: MySQL, host: 172.16.16.3, port: 3306. This metric also supports the legacy datastore instance format Datastore/instance/MySQL/172.16.16.3:3306. Currently we cannot determine whether the datastore instance is instrumented by New Relic and has an entity associated to it. APM agent SERVES Browser agent This relationship is created when an APM agent injects the browser agent into a page. Workload entity CONTAINS Any entity When a workload is created or updated, relationships for each of the entities that belong to the workload are created. Because some workloads are “dynamic” (defined by tags), relationships are re-created every 5 minutes. This way entities can join or leave the workload. Source: Infrastructure Relationship source Relationship type Relationship target Why is the relationship created? Infrastructure host HOSTS Application This relationship is created when an application is running in one or more hosts, and the infra agent is running in those hosts. Infrastructure host HOSTS Container This relationship is created when containers are running in one or more hosts, and the host is instrumented with the infra agent. Source: Synthetics monitor Relationship source Relationship type Relationship target Why is the relationship created? Synthetics Monitor CALLS Browser agent This relationship is created when a synthetics monitor checks a page instrumented with the browser agent. Synthetics Monitor CALLS APM application Agent events that contain the attribute nr.syntheticsMonitorId have been described as synthetics monitors (the source) interacting with an APM application (the target). If the header exists and the APM application Id exists, a relationship is created between the monitor and the app. Source: Kubernetes Relationship source Relationship type Relationship target Why is the relationship created? Cluster CONTAINS Pod This relationship is created when a pod is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Deployment This relationship is created when a deployment is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS DaemonSet This relationship is created when a DaemonSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS StatefulSet This relationship is created when a StatefulSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Host This relationship is created when a host that's part of a cluster is instrumented with the New Relic Kubernetes integration. Deployment CONTAINS Pod This relationship is created when a deployment creates a pod in a cluster instrumented with the New Relic Kubernetes integration. DaemonSet CONTAINS Pod This relationship is created when a DaemonSet is created a pod in a cluster instrumented with the New Relic Kubernetes integration. StatefulSet CONTAINS Pod This relationship is created when a StatefulSet creates a pod in a cluster instrumented with the New Relic Kubernetes integration. Pod CONTAINS Container This relationship is created when a pod creates a container in a cluster instrumented with the New Relic Kubernetes integration. Host HOSTS Pod This relationship is created when a pod is running in a host that's part of a cluster instrumented with the New Relic Kubernetes integration. Container HOSTS Application This relationship is created when an application is running in docker, and the hosts where docker is running are instrumented by the the infra agent. External services Relationship source Relationship type Relationship target Why is the relationship created? External service CALLS External service When the relationship is created, the external service reports a span with its name on the service.name attribute and the name of the service that initiates the call in the parent.service.name attribute. Application IS External service A relationship between an application and an external service is created so that users can navigate between them using the related entities component. Browser application instrumented with a New Relic agent CALLS External service A browser application reports an Ajax/HostTransaction metric when calling an external service (URL). Example metric: Ajax/HostTransaction/api.segment.io:443/CallbackTime' Cluster CONTAINS External service When the relationship is created, the external service reports a span with the attribute k8s.cluster.name, the name of the cluster. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span. Pod HOSTS External service When the relationship is created, the external service reports a span with the following attributes: service.name: The name of the service. k8s.cluster.name: The name of the cluster. k8s.pod.name: The name of the pod that’s running the service. k8s.namespace.name: The namespace where the pod was created. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 273.17456,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What is an entity in <em>New</em> <em>Relic</em>?",
        "sections": "What is an entity in <em>New</em> <em>Relic</em>?",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": ". If telemetry arrives with the entity.guid attribute already present, then <em>New</em> <em>Relic</em> will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. <em>One</em> <em>use</em> case for passing this attribute is to associate"
      },
      "id": "603ec160e7b9d295f72a07fc"
    },
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-09-14T10:08:22Z",
      "updated_at": "2021-08-21T09:28:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. For APM agents, restart your service. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration, both methods require you to restart your service. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 241.49544,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Use</em> tags to help organize and find your data",
        "sections": "<em>Use</em> tags to help organize and find your data",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " to filter the UI <em>Use</em> the filter field at the top of the <em>New</em> <em>Relic</em> Explorer to filter down to the entities you care about. You can <em>use</em> multiple filter conditions. To filter down to certain entities using tags: From <em>one</em>.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Why it matters",
        "View and connect the performance of your entities",
        "Tip",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-09-14T14:34:02Z",
      "updated_at": "2021-07-28T06:53:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities Access the New Relic Explorer at one.newrelic.com and see together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer's three views and the following features: one.newrelic.com > Explorer: Use the New Relic Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group, and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Saved views. Save your favorite filters as a view and recover them in a click each time you return to the Explorer. Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in one place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes. It allows you to see only entities of the selected type, as it updates the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The New Relic Explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention New Relic Explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.9679,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer&#x27;s three views and the following features: <em>one</em>.newrelic.com &gt; Explorer: <em>Use</em> the <em>New</em> <em>Relic</em> Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/core-concepts/transition-new-relic-one-insights": [
    {
      "sections": [
        "What is an entity in New Relic?",
        "What's an entity?",
        "Find and explore entities and entity data",
        "Tip",
        "Group and organize entities",
        "Customize entity data with entity synthesis",
        "Reserved attributes for synthesized entities",
        "Entity relationships",
        "Important",
        "Which relationships are created?",
        "Source: New Relic agent",
        "Source: Infrastructure",
        "Source: Synthetics monitor",
        "Source: Kubernetes",
        "External services"
      ],
      "title": "What is an entity in New Relic?",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "52a3e08bc9103c717d27b153e4fd4f547d6ecc32",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-09-14T10:08:21Z",
      "updated_at": "2021-09-01T17:25:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic monitoring is built around the concept of entities. In this doc, you'll learn how we define entities, what you can do with them, and how you can create your own entities or groupings of entities. What's an entity? From a New Relic perspective, entity is purposefully a broad concept. An entity is anything that a) reports data to New Relic or that contains data that we have access to, and b) is something we've identified with a unique entity ID. For most entities, the ID is indicated by the attribute entityGuid. An entity can be any fundamental data-reporting component, like an application, a host, or a database service, but it can also refer to larger groupings of those components. For example, to monitor a data center, you could aggregate those hosts in New Relic to be a workload (a custom grouping of entities). That workload is, itself, also an entity. Also very important is the relationships between entities. Our behind-the-scenes relationship-mapping helps us understand how entities are connected, how they affect each other. And this allows us to give you the power to configure how any data you're bringing in is related to existing entities, or how it's related to other entities. Our focus on entities and their relationships is important because our goal is to give you practical information about your business-important entities, and not give you an unhelpfully huge stream of data from a huge list of monitored things. With more insight at the entity level, you can better monitor and troubleshoot complex, modern systems. Find and explore entities and entity data Tip You can create new entity types for monitoring any data source. Learn more about entity synthesis. Some tips for finding and understanding entity data: To find an entity's entityGuid and entityName and other metadata: from any list of monitored entities in the New Relic Explorer, click an entity's icon, and click See metadata and tags. For most entities, its GUID is reported as the attribute entityGuid. For workloads, it's workloadGuid. You can run NRQL queries to find entities by their GUID. To see connections between entities, you have several options: When viewing an entity in the UI, use the Related entities UI. Service maps. Distributed tracing. Our NerdGraph API. To group entities together, see Group entities. Customize entity definitions and relationships. To learn technical details about entity types, see our GitHub repo. In an entity type's definition file, you'll see information like: The domain: for example, APM, or Infra. Its type: for example, Application or AWSECSCONTAINERINSTANCE. Default tags. The entityExpirationTime: how long data from that entity lasts in the UI, which is different from database data retention. Group and organize entities You can place entities into groups that reflect business-important relationships in your organization. For example, you might group all entities related to a specific team or department, or related to a specific service. Or you might group multiple hosts together to reflect their grouping in a data center. To group your entities, see: Tag entities. Create workloads, which allow you to group business-important sets of entities. Create entities and customize entity data Customize entity data with entity synthesis If you have telemetry from any source that's not supported by New Relic out of the box, you can propose a mapping for it. Once approved, any telemetry received by New Relic that matches your definition file will be synthesized into an entity. To learn more: For reserved attributes and how entity relationships are defined, keep reading this doc. For how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Reserved attributes for synthesized entities These attributes are meant to be synthesized from the telemetry we receive. Do not set them unless you're aware of the implications and consequences. Attribute Description entity.guid Generally, you should not set this attribute field on your telemetry data. New Relic may add this field to ingested data to store a unique identifier for the entity associated with the data point. If telemetry arrives with the entity.guid attribute already present, then New Relic will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. One use case for passing this attribute is to associate ingested telemetry with an entity already created by New Relic. When the entity.guid attribute is sent, the value will override New Relic’s entity identification system (such as entity synthesis definitions) and instead will use the attribute as the data. entity.name This attribute shouldn't be put on ingested telemetry data unless you're trying to override the entity name that would have been selected by New Relic’s entity identification system. While New Relic won't change the value if it's already present on the data, New Relic may add the attribute to your data. Therefore invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. If this field is present on ingested telemetry, its value will be used to name the entity associated with the data point. This name will be used instead of the name selected by New Relic’s entity identification system (for example, entity synthesis definitions). Note that many entities use the name as part of their identification, so changing this field may result in the generation of a new entity. entity.type This attribute shouldn't be put on ingested telemetry data except for certain legacy cases where it's required to distinguish entity types. Passing this field may interfere with entity detection, particularly if unrecognized values are sent in this field. While New Relic won't change the value if already present on the data, the field is not guaranteed to provide unambiguous filtering of telemetry at query-time. Existing entity definitions already have overlapping values, and we recommend avoiding entity.type in favor of other fields for filtering telemetry queries. This field is used by New Relic, meaning that invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. To learn how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Entity relationships Connections between entities are automatically created by New Relic based on what we can infer from your telemetry. For example, when two services that communicate using HTTP are instrumented with New Relic, we infer a \"calls/called-by\" relationship between them. When viewing a specific entity in either the New Relic Explorer, Navigator, or Lookout, you can see its Related entities in the entity's mini overview. This gives a visualization of the various entities connected directly to the current entity. You can quickly view important metrics for these related entities and navigate from one entity to another, through all the connected parts of your stack. Tip Learn more about how entities are related with our NerdGraph API. When relationships are not automatically detected, you can manually create them using the \"Add/edit related entities\" link in Related entities. Important Currently, you can only manually create calls/called-by relationships between service entities. Tip To manage manual relationships, you need to have modify and delete capabilities on entity relationships. If you don’t see the edit relationships button, contact your account admin. Which relationships are created? These are the relationships created between entities: Source: New Relic agent Relationship source Relationship type Relationship target Why is the relationship created? Application instrumented with a New Relic agent CALLS Application instrumented with a New Relic agent Relationships between applications monitored by New Relic agents are reported using the DurationByCaller metric. The callee reports the metric. For example, the metric DurationByCaller/Mobile/100/1234/HTTP/all indicates that the caller is APPLICATION 1234 for account 100. Application instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent An application (caller) that calls a service (callee) monitored by New Relic creates a relationship that's reported by the caller using the ExternalApp metric. For example, the metric ExternalApp/dirac.vips.net/100#1234/all indicates that the callee is APPLICATION 1234 for account 100. The metric is reported if the callee successfully responds to the caller. Service instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent When a New Relic agent detects that a service (caller) calls another service (callee) instrumented by New Relic, the callee reports the metric ClientApplication. For example, the metric ClientApplication/100#1234/all indicates that the caller is APPLICATION 1234 for account 100. Service instrumented with a New Relic agent CALLS A datastore instance When an application calls a datastore instance it creates a relationship reported with the DatastoreInstance metric. For example, the metric Datastore/instance/MySQL/172.16.16.3/3306 indicates the datastore instance is vendor: MySQL, host: 172.16.16.3, port: 3306. This metric also supports the legacy datastore instance format Datastore/instance/MySQL/172.16.16.3:3306. Currently we cannot determine whether the datastore instance is instrumented by New Relic and has an entity associated to it. APM agent SERVES Browser agent This relationship is created when an APM agent injects the browser agent into a page. Workload entity CONTAINS Any entity When a workload is created or updated, relationships for each of the entities that belong to the workload are created. Because some workloads are “dynamic” (defined by tags), relationships are re-created every 5 minutes. This way entities can join or leave the workload. Source: Infrastructure Relationship source Relationship type Relationship target Why is the relationship created? Infrastructure host HOSTS Application This relationship is created when an application is running in one or more hosts, and the infra agent is running in those hosts. Infrastructure host HOSTS Container This relationship is created when containers are running in one or more hosts, and the host is instrumented with the infra agent. Source: Synthetics monitor Relationship source Relationship type Relationship target Why is the relationship created? Synthetics Monitor CALLS Browser agent This relationship is created when a synthetics monitor checks a page instrumented with the browser agent. Synthetics Monitor CALLS APM application Agent events that contain the attribute nr.syntheticsMonitorId have been described as synthetics monitors (the source) interacting with an APM application (the target). If the header exists and the APM application Id exists, a relationship is created between the monitor and the app. Source: Kubernetes Relationship source Relationship type Relationship target Why is the relationship created? Cluster CONTAINS Pod This relationship is created when a pod is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Deployment This relationship is created when a deployment is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS DaemonSet This relationship is created when a DaemonSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS StatefulSet This relationship is created when a StatefulSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Host This relationship is created when a host that's part of a cluster is instrumented with the New Relic Kubernetes integration. Deployment CONTAINS Pod This relationship is created when a deployment creates a pod in a cluster instrumented with the New Relic Kubernetes integration. DaemonSet CONTAINS Pod This relationship is created when a DaemonSet is created a pod in a cluster instrumented with the New Relic Kubernetes integration. StatefulSet CONTAINS Pod This relationship is created when a StatefulSet creates a pod in a cluster instrumented with the New Relic Kubernetes integration. Pod CONTAINS Container This relationship is created when a pod creates a container in a cluster instrumented with the New Relic Kubernetes integration. Host HOSTS Pod This relationship is created when a pod is running in a host that's part of a cluster instrumented with the New Relic Kubernetes integration. Container HOSTS Application This relationship is created when an application is running in docker, and the hosts where docker is running are instrumented by the the infra agent. External services Relationship source Relationship type Relationship target Why is the relationship created? External service CALLS External service When the relationship is created, the external service reports a span with its name on the service.name attribute and the name of the service that initiates the call in the parent.service.name attribute. Application IS External service A relationship between an application and an external service is created so that users can navigate between them using the related entities component. Browser application instrumented with a New Relic agent CALLS External service A browser application reports an Ajax/HostTransaction metric when calling an external service (URL). Example metric: Ajax/HostTransaction/api.segment.io:443/CallbackTime' Cluster CONTAINS External service When the relationship is created, the external service reports a span with the attribute k8s.cluster.name, the name of the cluster. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span. Pod HOSTS External service When the relationship is created, the external service reports a span with the following attributes: service.name: The name of the service. k8s.cluster.name: The name of the cluster. k8s.pod.name: The name of the pod that’s running the service. k8s.namespace.name: The namespace where the pod was created. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 273.17453,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What is an entity in <em>New</em> <em>Relic</em>?",
        "sections": "What is an entity in <em>New</em> <em>Relic</em>?",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": ". If telemetry arrives with the entity.guid attribute already present, then <em>New</em> <em>Relic</em> will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. <em>One</em> <em>use</em> case for passing this attribute is to associate"
      },
      "id": "603ec160e7b9d295f72a07fc"
    },
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-09-14T10:08:22Z",
      "updated_at": "2021-08-21T09:28:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. For APM agents, restart your service. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration, both methods require you to restart your service. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 241.49542,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Use</em> tags to help organize and find your data",
        "sections": "<em>Use</em> tags to help organize and find your data",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " to filter the UI <em>Use</em> the filter field at the top of the <em>New</em> <em>Relic</em> Explorer to filter down to the entities you care about. You can <em>use</em> multiple filter conditions. To filter down to certain entities using tags: From <em>one</em>.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "New Relic Lookout: Monitor your estate at a glance",
        "Why it matters",
        "Requirements",
        "Get started with New Relic Lookout",
        "Circle visualization and table view",
        "Abnormal golden signals",
        "Instant search",
        "Change view",
        "Drill down into the details",
        "Performance tab",
        "Abnormal History tab",
        "Correlations tab",
        "Profile tab",
        "Traces tab",
        "Create a custom view",
        "Query: Compare the last 15 minutes to the same time 1 day ago",
        "Query: Compare a specific time range to the same range a month ago",
        "Example: Unusual increases in error count"
      ],
      "title": "New Relic Lookout: Monitor your estate at a glance",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "9193dcc8851c185ff5d96f6f93ab412bd1be69e9",
      "image": "https://docs.newrelic.com/static/178b37068bad2a68cff027c8bdcf663a/c1b63/lookout-intro.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-lookout-monitor-your-estate-glance/",
      "published_at": "2021-09-14T07:54:08Z",
      "updated_at": "2021-08-21T09:27:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Lookout provides visibility into your entire estate. It doesn't require any configuration — you can query anything in your estate that matters to you right now and understand your system as a whole, or dive deep into causes and effects, so you can quickly get the data you need to take action. Know exactly where to focus your attention with New Relic Lookout. The brighter the color, the more severe the change, and the bigger the size, the bigger the scale. Then dig deeper with correlations and abnormal history to see how it impacts your whole system—no configuration needed. Why it matters New Relic Lookout helps software teams of any size discover potential issues before they have an impact. Fill gaps in monitoring with full coverage out-of-the-box, no configuration or setup required. Immediately see anything deviating from normal across your entire estate. Proactively spot emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in New Relic database (NRDB), including third-party, open, and custom data. Launch into other areas of New Relic One for deeper understanding Requirements New Relic Lookout requires Pro or Enterprise edition. If you are on Standard edition, you can still use the New Relic Lookout view in the New Relic Explorer. If you want to see data spanning 13-months, correlations, profiles, traces, and other details, you must upgrade to a higher edition. Get started with New Relic Lookout To access New Relic Lookout, click the Apps button in New Relic One and locate the New Relic Lookout launcher. You can also access New Relic Lookout directly from the New Relic One header bar, via the More dropdown. Enablement of key service performance indicator data is required for New Relic Lookout to provide value from the data you already have. The default view provides insight into three key Service performance indicators broken down by application: throughput, response time, and errors. These metrics are analyzed to show how the data has behaved during the last five minutes compared to the prior hour. one.newrelic.com > Apps > New Relic Lookout: Anything that significantly deviates from the trend is automatically discovered by New Relic Lookout, which doesn't require any configuration. Circle visualization and table view Each application (or other facet) is represented by a circle. The size of the circles indicate the magnitude of the signal for that application and the color indicates whether the value has significantly decreased or increased in the last five minutes, based on the standard deviation of the prior hour (default evaluation and comparison time windows.) Please note that the type of signal is important when interpreting your results. When you first look at the legend below, you might be tempted to interpret yellow as good and dark purple as bad, but that is not always the case. Here are some examples: In the APM/services golden signals, a dark yellow circle in Throughput might signify that something bad has occurred and led to a drop in traffic. At the same time, a dark purple circle might also be concerning due to unexpected load. Both are significant findings worth exploring. In browser golden signals, a dark purple circle in Page Views might be great, as you are seeing more traffic to your site! With errors golden signals (in all entity types), a large circle, even if gray (not deviating from normal volume), is worth exploring because a high count of errors in your system is important to investigate. The legend allows you to change the colors used to highlight deviating services To change the color palette, click the gear icon by the low-high color legend. This allows you to change the colors used to highlight deviating services. To get a table view of the same data, click the toggle on the right. You can also hover over each color to filter the view by degree lower or higher deviance. Abnormal golden signals On the right, New Relic Lookout displays the most significantly deviating applications (or other facet) in a side panel, weighted by both the magnitude of the performance indicators and the scale of their deviations. Details include the name of the key performance indicator, their magnitude during the recent time window, and the difference between the averages from one time compared to the other. Instant search Click the magnifying glass icon in the side panel to open a search box. Typing into the search box filters the circles, table, and abnormal signals to applications (or other facets) that contain the text. This is a good way to quickly zoom to various subsystems. New Relic Lookout doesn't rerun the analysis when using the instant search. Change view Click the Change View button on the right side panel. The panel that appears shows you all the entity-specific golden signals you can toggle between out of the box. By choosing the Browser Golden Signal or other views, you can change from the default view. Each new view will have the golden signals appropriate for that entity type. Drill down into the details To analyze an application or facet, click a circle, table row, or abnormal golden signal. The details panel shows the degree of deviation of the performance indicator, a link to the affected entity, and recent alert and deployment activity for that entity, when available. There’s also an indication of whether the selected evaluation time period would be abnormal or not in reference to other comparison time windows, such as the same time yesterday or the same time last week. This allows you to quickly see if the abnormal behavior is odd in general, or just based on the comparison time window. Performance tab The default tab shows charts for other key performance indicators for the selected application or facet. The charts compare the two time windows being analyzed. You can click their titles to rerun the analysis, focusing on the selected key performance indicator. When the target is a New Relic One application, we show the top transactions, error classes, external services, and database operations, alongside links to the relevant New Relic One features. Abnormal History tab This section analyzes past performance of the selected signal and calls out any time periods with notable abnormalities. Each card represents an abnormal time window and can be clicked for more details. The charts will display any relevant violations and deployments in New Relic. Correlations tab New Relic Lookout can find other signals that began behaving differently around the same time as the selected signal for that entity type. Clicking the name of the signal reruns the analysis, focusing on that key performance indicator. The chart titles link to New Relic One when there’s an associated entity in your account. Note that correlations currently do not analyze across accounts. The correlated signals displayed are for others in the account of the original application you are viewing. This helps focus the data on correlations that are more likely related to your issue. Profile tab Based on the same technology as New Relic’s error profiles, this tab compares the last five minutes to the prior hour by default (or whatever time windows you’ve selected with query editing) and surfaces any attributes that have significantly different distributions in the events being targeted by the selected signal. For example, if a custom attribute indicated that a recent throughput spike came from one user, that would surface highly in Profiles if most of the traffic usually comes from many users. Traces tab If the entity has distributed traces configured and available in the selected evaluated time window, the Traces section is enabled. Each card shows a summary of a trace and can be clicked for details. The Explore all traces links to the distributed traces application, filtered to the selected entity. Create a custom view To target signals and time windows beyond the default values, click the Change view button and select Custom view. To create your own view: Select the account or subaccount. Select the data type (metrics or events). Different functionality is available depending on the type. In View a chart with, select the metric or event you are interested in. Default is golden signals (throughput, response time, and errors). You can also build custom queries (filters) to target a signal that isn't on the list. In Facet by, select what the circles represent. Default is appName, but you can also choose host or any other facetable attribute available for the signal you’ve selected. If you plan to save/favorite this new view, provide a name in the Name your view box. Keep in mind that you can edit this view at any time using the pencil icon. The default time windows analyzed by New Relic Lookout are the last five minutes compared to the hour before. Use the time controls (View data from and Compare data to) to target other time windows. one.newrelic.com > Apps > New Relic Lookout: All event and metric data in the New Relic database can be queried using the Edit query feature. Click Analyze to begin analyzing the signal you’ve selected. You can also create your own query: Create your query. This query is comparing data from the past thirty minutes to data from the same range a day ago. Change from Basic to Advanced after clicking the Custom view button. Select the data type (metrics or events). Different functionality is available depending on the type. Enter your query using NRQL. Please note that not all NRQL features are available in the Lookout Advanced query feature. By default, the system will run this query using the last five minutes of data compared to the previous hour. Some examples of the syntax for changing the comparison and evaluation time windows are below. Click Analyze to begin analyzing the signal you’ve selected. Query: Compare the last 15 minutes to the same time 1 day ago Please note that the UNTIL NOW portion is required here unlike in standard NRQL. Without the UNTIL NOW added, the system will query a 5 minute slice of data starting 15 minutes ago SINCE 15 minutes AGO UNTIL NOW COMPARE WITH 1 day ago Copy Query: Compare a specific time range to the same range a month ago SINCE '2021-03-07 07:00:00-0500' UNTIL '2021-03-08 07:00:00-0500' COMPARE WITH 1 month ago Copy Or: SINCE 'today at midnight' UNTIL 'now' COMPARE WITH 1 MONTH AGO Copy Example: Unusual increases in error count The default view of New Relic Lookout shows application status across your estate, comparing the last five minutes to the hour before. Under regular operation, most large systems may have a handful of abnormalities, but usually most things will indicate normal behavior. Suddenly, several circles begin to change to red under the Errors section. This indicates that several applications are experiencing unusual increases in error count. It may be that one or two circles for important systems are red, and perhaps much larger than they usually appear. Clicking one of these can provide more information on what is happening. You might see that the error rate is substantially elevated, even thousands of percent higher than normal. To troubleshoot this issue, here's what you might discover in the New Relic Lookout tabs: Performance would show you data about other signals, illuminating the characteristics of the change in system dynamics. Correlations would surface other applications that are affected and how, as well as opportunities to pivot to other applications that may be closer to the underlying causes. Traces, in turn, would show distributed traces, which can provide specific examples of traffic running through those systems. Abnormal history would show other times in the past week with elevated errors, showing whether or not this problem happens regularly, such as every day at the same time or whenever there is a deployment. Profiles might show that all or most of the new errors share common properties, such as all being isolated to just one region/account/user. Combining the information from these sections, not only can you get a sense of what is going on, but also where to focus actions to resolve the problem.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 241.49417,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "sections": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in <em>New</em> <em>Relic</em> database (NRDB), including third-party, open, and custom data. Launch into other areas of <em>New</em> <em>Relic</em> <em>One</em> for deeper"
      },
      "id": "603e821e64441f5a444e8845"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data": [
    {
      "sections": [
        "What is an entity in New Relic?",
        "What's an entity?",
        "Find and explore entities and entity data",
        "Tip",
        "Group and organize entities",
        "Customize entity data with entity synthesis",
        "Reserved attributes for synthesized entities",
        "Entity relationships",
        "Important",
        "Which relationships are created?",
        "Source: New Relic agent",
        "Source: Infrastructure",
        "Source: Synthetics monitor",
        "Source: Kubernetes",
        "External services"
      ],
      "title": "What is an entity in New Relic?",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "52a3e08bc9103c717d27b153e4fd4f547d6ecc32",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-09-14T10:08:21Z",
      "updated_at": "2021-09-01T17:25:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic monitoring is built around the concept of entities. In this doc, you'll learn how we define entities, what you can do with them, and how you can create your own entities or groupings of entities. What's an entity? From a New Relic perspective, entity is purposefully a broad concept. An entity is anything that a) reports data to New Relic or that contains data that we have access to, and b) is something we've identified with a unique entity ID. For most entities, the ID is indicated by the attribute entityGuid. An entity can be any fundamental data-reporting component, like an application, a host, or a database service, but it can also refer to larger groupings of those components. For example, to monitor a data center, you could aggregate those hosts in New Relic to be a workload (a custom grouping of entities). That workload is, itself, also an entity. Also very important is the relationships between entities. Our behind-the-scenes relationship-mapping helps us understand how entities are connected, how they affect each other. And this allows us to give you the power to configure how any data you're bringing in is related to existing entities, or how it's related to other entities. Our focus on entities and their relationships is important because our goal is to give you practical information about your business-important entities, and not give you an unhelpfully huge stream of data from a huge list of monitored things. With more insight at the entity level, you can better monitor and troubleshoot complex, modern systems. Find and explore entities and entity data Tip You can create new entity types for monitoring any data source. Learn more about entity synthesis. Some tips for finding and understanding entity data: To find an entity's entityGuid and entityName and other metadata: from any list of monitored entities in the New Relic Explorer, click an entity's icon, and click See metadata and tags. For most entities, its GUID is reported as the attribute entityGuid. For workloads, it's workloadGuid. You can run NRQL queries to find entities by their GUID. To see connections between entities, you have several options: When viewing an entity in the UI, use the Related entities UI. Service maps. Distributed tracing. Our NerdGraph API. To group entities together, see Group entities. Customize entity definitions and relationships. To learn technical details about entity types, see our GitHub repo. In an entity type's definition file, you'll see information like: The domain: for example, APM, or Infra. Its type: for example, Application or AWSECSCONTAINERINSTANCE. Default tags. The entityExpirationTime: how long data from that entity lasts in the UI, which is different from database data retention. Group and organize entities You can place entities into groups that reflect business-important relationships in your organization. For example, you might group all entities related to a specific team or department, or related to a specific service. Or you might group multiple hosts together to reflect their grouping in a data center. To group your entities, see: Tag entities. Create workloads, which allow you to group business-important sets of entities. Create entities and customize entity data Customize entity data with entity synthesis If you have telemetry from any source that's not supported by New Relic out of the box, you can propose a mapping for it. Once approved, any telemetry received by New Relic that matches your definition file will be synthesized into an entity. To learn more: For reserved attributes and how entity relationships are defined, keep reading this doc. For how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Reserved attributes for synthesized entities These attributes are meant to be synthesized from the telemetry we receive. Do not set them unless you're aware of the implications and consequences. Attribute Description entity.guid Generally, you should not set this attribute field on your telemetry data. New Relic may add this field to ingested data to store a unique identifier for the entity associated with the data point. If telemetry arrives with the entity.guid attribute already present, then New Relic will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. One use case for passing this attribute is to associate ingested telemetry with an entity already created by New Relic. When the entity.guid attribute is sent, the value will override New Relic’s entity identification system (such as entity synthesis definitions) and instead will use the attribute as the data. entity.name This attribute shouldn't be put on ingested telemetry data unless you're trying to override the entity name that would have been selected by New Relic’s entity identification system. While New Relic won't change the value if it's already present on the data, New Relic may add the attribute to your data. Therefore invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. If this field is present on ingested telemetry, its value will be used to name the entity associated with the data point. This name will be used instead of the name selected by New Relic’s entity identification system (for example, entity synthesis definitions). Note that many entities use the name as part of their identification, so changing this field may result in the generation of a new entity. entity.type This attribute shouldn't be put on ingested telemetry data except for certain legacy cases where it's required to distinguish entity types. Passing this field may interfere with entity detection, particularly if unrecognized values are sent in this field. While New Relic won't change the value if already present on the data, the field is not guaranteed to provide unambiguous filtering of telemetry at query-time. Existing entity definitions already have overlapping values, and we recommend avoiding entity.type in favor of other fields for filtering telemetry queries. This field is used by New Relic, meaning that invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. To learn how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Entity relationships Connections between entities are automatically created by New Relic based on what we can infer from your telemetry. For example, when two services that communicate using HTTP are instrumented with New Relic, we infer a \"calls/called-by\" relationship between them. When viewing a specific entity in either the New Relic Explorer, Navigator, or Lookout, you can see its Related entities in the entity's mini overview. This gives a visualization of the various entities connected directly to the current entity. You can quickly view important metrics for these related entities and navigate from one entity to another, through all the connected parts of your stack. Tip Learn more about how entities are related with our NerdGraph API. When relationships are not automatically detected, you can manually create them using the \"Add/edit related entities\" link in Related entities. Important Currently, you can only manually create calls/called-by relationships between service entities. Tip To manage manual relationships, you need to have modify and delete capabilities on entity relationships. If you don’t see the edit relationships button, contact your account admin. Which relationships are created? These are the relationships created between entities: Source: New Relic agent Relationship source Relationship type Relationship target Why is the relationship created? Application instrumented with a New Relic agent CALLS Application instrumented with a New Relic agent Relationships between applications monitored by New Relic agents are reported using the DurationByCaller metric. The callee reports the metric. For example, the metric DurationByCaller/Mobile/100/1234/HTTP/all indicates that the caller is APPLICATION 1234 for account 100. Application instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent An application (caller) that calls a service (callee) monitored by New Relic creates a relationship that's reported by the caller using the ExternalApp metric. For example, the metric ExternalApp/dirac.vips.net/100#1234/all indicates that the callee is APPLICATION 1234 for account 100. The metric is reported if the callee successfully responds to the caller. Service instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent When a New Relic agent detects that a service (caller) calls another service (callee) instrumented by New Relic, the callee reports the metric ClientApplication. For example, the metric ClientApplication/100#1234/all indicates that the caller is APPLICATION 1234 for account 100. Service instrumented with a New Relic agent CALLS A datastore instance When an application calls a datastore instance it creates a relationship reported with the DatastoreInstance metric. For example, the metric Datastore/instance/MySQL/172.16.16.3/3306 indicates the datastore instance is vendor: MySQL, host: 172.16.16.3, port: 3306. This metric also supports the legacy datastore instance format Datastore/instance/MySQL/172.16.16.3:3306. Currently we cannot determine whether the datastore instance is instrumented by New Relic and has an entity associated to it. APM agent SERVES Browser agent This relationship is created when an APM agent injects the browser agent into a page. Workload entity CONTAINS Any entity When a workload is created or updated, relationships for each of the entities that belong to the workload are created. Because some workloads are “dynamic” (defined by tags), relationships are re-created every 5 minutes. This way entities can join or leave the workload. Source: Infrastructure Relationship source Relationship type Relationship target Why is the relationship created? Infrastructure host HOSTS Application This relationship is created when an application is running in one or more hosts, and the infra agent is running in those hosts. Infrastructure host HOSTS Container This relationship is created when containers are running in one or more hosts, and the host is instrumented with the infra agent. Source: Synthetics monitor Relationship source Relationship type Relationship target Why is the relationship created? Synthetics Monitor CALLS Browser agent This relationship is created when a synthetics monitor checks a page instrumented with the browser agent. Synthetics Monitor CALLS APM application Agent events that contain the attribute nr.syntheticsMonitorId have been described as synthetics monitors (the source) interacting with an APM application (the target). If the header exists and the APM application Id exists, a relationship is created between the monitor and the app. Source: Kubernetes Relationship source Relationship type Relationship target Why is the relationship created? Cluster CONTAINS Pod This relationship is created when a pod is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Deployment This relationship is created when a deployment is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS DaemonSet This relationship is created when a DaemonSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS StatefulSet This relationship is created when a StatefulSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Host This relationship is created when a host that's part of a cluster is instrumented with the New Relic Kubernetes integration. Deployment CONTAINS Pod This relationship is created when a deployment creates a pod in a cluster instrumented with the New Relic Kubernetes integration. DaemonSet CONTAINS Pod This relationship is created when a DaemonSet is created a pod in a cluster instrumented with the New Relic Kubernetes integration. StatefulSet CONTAINS Pod This relationship is created when a StatefulSet creates a pod in a cluster instrumented with the New Relic Kubernetes integration. Pod CONTAINS Container This relationship is created when a pod creates a container in a cluster instrumented with the New Relic Kubernetes integration. Host HOSTS Pod This relationship is created when a pod is running in a host that's part of a cluster instrumented with the New Relic Kubernetes integration. Container HOSTS Application This relationship is created when an application is running in docker, and the hosts where docker is running are instrumented by the the infra agent. External services Relationship source Relationship type Relationship target Why is the relationship created? External service CALLS External service When the relationship is created, the external service reports a span with its name on the service.name attribute and the name of the service that initiates the call in the parent.service.name attribute. Application IS External service A relationship between an application and an external service is created so that users can navigate between them using the related entities component. Browser application instrumented with a New Relic agent CALLS External service A browser application reports an Ajax/HostTransaction metric when calling an external service (URL). Example metric: Ajax/HostTransaction/api.segment.io:443/CallbackTime' Cluster CONTAINS External service When the relationship is created, the external service reports a span with the attribute k8s.cluster.name, the name of the cluster. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span. Pod HOSTS External service When the relationship is created, the external service reports a span with the following attributes: service.name: The name of the service. k8s.cluster.name: The name of the cluster. k8s.pod.name: The name of the pod that’s running the service. k8s.namespace.name: The namespace where the pod was created. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 273.17453,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What is an entity in <em>New</em> <em>Relic</em>?",
        "sections": "What is an entity in <em>New</em> <em>Relic</em>?",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": ". If telemetry arrives with the entity.guid attribute already present, then <em>New</em> <em>Relic</em> will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. <em>One</em> <em>use</em> case for passing this attribute is to associate"
      },
      "id": "603ec160e7b9d295f72a07fc"
    },
    {
      "sections": [
        "New Relic Lookout: Monitor your estate at a glance",
        "Why it matters",
        "Requirements",
        "Get started with New Relic Lookout",
        "Circle visualization and table view",
        "Abnormal golden signals",
        "Instant search",
        "Change view",
        "Drill down into the details",
        "Performance tab",
        "Abnormal History tab",
        "Correlations tab",
        "Profile tab",
        "Traces tab",
        "Create a custom view",
        "Query: Compare the last 15 minutes to the same time 1 day ago",
        "Query: Compare a specific time range to the same range a month ago",
        "Example: Unusual increases in error count"
      ],
      "title": "New Relic Lookout: Monitor your estate at a glance",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "9193dcc8851c185ff5d96f6f93ab412bd1be69e9",
      "image": "https://docs.newrelic.com/static/178b37068bad2a68cff027c8bdcf663a/c1b63/lookout-intro.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-lookout-monitor-your-estate-glance/",
      "published_at": "2021-09-14T07:54:08Z",
      "updated_at": "2021-08-21T09:27:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Lookout provides visibility into your entire estate. It doesn't require any configuration — you can query anything in your estate that matters to you right now and understand your system as a whole, or dive deep into causes and effects, so you can quickly get the data you need to take action. Know exactly where to focus your attention with New Relic Lookout. The brighter the color, the more severe the change, and the bigger the size, the bigger the scale. Then dig deeper with correlations and abnormal history to see how it impacts your whole system—no configuration needed. Why it matters New Relic Lookout helps software teams of any size discover potential issues before they have an impact. Fill gaps in monitoring with full coverage out-of-the-box, no configuration or setup required. Immediately see anything deviating from normal across your entire estate. Proactively spot emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in New Relic database (NRDB), including third-party, open, and custom data. Launch into other areas of New Relic One for deeper understanding Requirements New Relic Lookout requires Pro or Enterprise edition. If you are on Standard edition, you can still use the New Relic Lookout view in the New Relic Explorer. If you want to see data spanning 13-months, correlations, profiles, traces, and other details, you must upgrade to a higher edition. Get started with New Relic Lookout To access New Relic Lookout, click the Apps button in New Relic One and locate the New Relic Lookout launcher. You can also access New Relic Lookout directly from the New Relic One header bar, via the More dropdown. Enablement of key service performance indicator data is required for New Relic Lookout to provide value from the data you already have. The default view provides insight into three key Service performance indicators broken down by application: throughput, response time, and errors. These metrics are analyzed to show how the data has behaved during the last five minutes compared to the prior hour. one.newrelic.com > Apps > New Relic Lookout: Anything that significantly deviates from the trend is automatically discovered by New Relic Lookout, which doesn't require any configuration. Circle visualization and table view Each application (or other facet) is represented by a circle. The size of the circles indicate the magnitude of the signal for that application and the color indicates whether the value has significantly decreased or increased in the last five minutes, based on the standard deviation of the prior hour (default evaluation and comparison time windows.) Please note that the type of signal is important when interpreting your results. When you first look at the legend below, you might be tempted to interpret yellow as good and dark purple as bad, but that is not always the case. Here are some examples: In the APM/services golden signals, a dark yellow circle in Throughput might signify that something bad has occurred and led to a drop in traffic. At the same time, a dark purple circle might also be concerning due to unexpected load. Both are significant findings worth exploring. In browser golden signals, a dark purple circle in Page Views might be great, as you are seeing more traffic to your site! With errors golden signals (in all entity types), a large circle, even if gray (not deviating from normal volume), is worth exploring because a high count of errors in your system is important to investigate. The legend allows you to change the colors used to highlight deviating services To change the color palette, click the gear icon by the low-high color legend. This allows you to change the colors used to highlight deviating services. To get a table view of the same data, click the toggle on the right. You can also hover over each color to filter the view by degree lower or higher deviance. Abnormal golden signals On the right, New Relic Lookout displays the most significantly deviating applications (or other facet) in a side panel, weighted by both the magnitude of the performance indicators and the scale of their deviations. Details include the name of the key performance indicator, their magnitude during the recent time window, and the difference between the averages from one time compared to the other. Instant search Click the magnifying glass icon in the side panel to open a search box. Typing into the search box filters the circles, table, and abnormal signals to applications (or other facets) that contain the text. This is a good way to quickly zoom to various subsystems. New Relic Lookout doesn't rerun the analysis when using the instant search. Change view Click the Change View button on the right side panel. The panel that appears shows you all the entity-specific golden signals you can toggle between out of the box. By choosing the Browser Golden Signal or other views, you can change from the default view. Each new view will have the golden signals appropriate for that entity type. Drill down into the details To analyze an application or facet, click a circle, table row, or abnormal golden signal. The details panel shows the degree of deviation of the performance indicator, a link to the affected entity, and recent alert and deployment activity for that entity, when available. There’s also an indication of whether the selected evaluation time period would be abnormal or not in reference to other comparison time windows, such as the same time yesterday or the same time last week. This allows you to quickly see if the abnormal behavior is odd in general, or just based on the comparison time window. Performance tab The default tab shows charts for other key performance indicators for the selected application or facet. The charts compare the two time windows being analyzed. You can click their titles to rerun the analysis, focusing on the selected key performance indicator. When the target is a New Relic One application, we show the top transactions, error classes, external services, and database operations, alongside links to the relevant New Relic One features. Abnormal History tab This section analyzes past performance of the selected signal and calls out any time periods with notable abnormalities. Each card represents an abnormal time window and can be clicked for more details. The charts will display any relevant violations and deployments in New Relic. Correlations tab New Relic Lookout can find other signals that began behaving differently around the same time as the selected signal for that entity type. Clicking the name of the signal reruns the analysis, focusing on that key performance indicator. The chart titles link to New Relic One when there’s an associated entity in your account. Note that correlations currently do not analyze across accounts. The correlated signals displayed are for others in the account of the original application you are viewing. This helps focus the data on correlations that are more likely related to your issue. Profile tab Based on the same technology as New Relic’s error profiles, this tab compares the last five minutes to the prior hour by default (or whatever time windows you’ve selected with query editing) and surfaces any attributes that have significantly different distributions in the events being targeted by the selected signal. For example, if a custom attribute indicated that a recent throughput spike came from one user, that would surface highly in Profiles if most of the traffic usually comes from many users. Traces tab If the entity has distributed traces configured and available in the selected evaluated time window, the Traces section is enabled. Each card shows a summary of a trace and can be clicked for details. The Explore all traces links to the distributed traces application, filtered to the selected entity. Create a custom view To target signals and time windows beyond the default values, click the Change view button and select Custom view. To create your own view: Select the account or subaccount. Select the data type (metrics or events). Different functionality is available depending on the type. In View a chart with, select the metric or event you are interested in. Default is golden signals (throughput, response time, and errors). You can also build custom queries (filters) to target a signal that isn't on the list. In Facet by, select what the circles represent. Default is appName, but you can also choose host or any other facetable attribute available for the signal you’ve selected. If you plan to save/favorite this new view, provide a name in the Name your view box. Keep in mind that you can edit this view at any time using the pencil icon. The default time windows analyzed by New Relic Lookout are the last five minutes compared to the hour before. Use the time controls (View data from and Compare data to) to target other time windows. one.newrelic.com > Apps > New Relic Lookout: All event and metric data in the New Relic database can be queried using the Edit query feature. Click Analyze to begin analyzing the signal you’ve selected. You can also create your own query: Create your query. This query is comparing data from the past thirty minutes to data from the same range a day ago. Change from Basic to Advanced after clicking the Custom view button. Select the data type (metrics or events). Different functionality is available depending on the type. Enter your query using NRQL. Please note that not all NRQL features are available in the Lookout Advanced query feature. By default, the system will run this query using the last five minutes of data compared to the previous hour. Some examples of the syntax for changing the comparison and evaluation time windows are below. Click Analyze to begin analyzing the signal you’ve selected. Query: Compare the last 15 minutes to the same time 1 day ago Please note that the UNTIL NOW portion is required here unlike in standard NRQL. Without the UNTIL NOW added, the system will query a 5 minute slice of data starting 15 minutes ago SINCE 15 minutes AGO UNTIL NOW COMPARE WITH 1 day ago Copy Query: Compare a specific time range to the same range a month ago SINCE '2021-03-07 07:00:00-0500' UNTIL '2021-03-08 07:00:00-0500' COMPARE WITH 1 month ago Copy Or: SINCE 'today at midnight' UNTIL 'now' COMPARE WITH 1 MONTH AGO Copy Example: Unusual increases in error count The default view of New Relic Lookout shows application status across your estate, comparing the last five minutes to the hour before. Under regular operation, most large systems may have a handful of abnormalities, but usually most things will indicate normal behavior. Suddenly, several circles begin to change to red under the Errors section. This indicates that several applications are experiencing unusual increases in error count. It may be that one or two circles for important systems are red, and perhaps much larger than they usually appear. Clicking one of these can provide more information on what is happening. You might see that the error rate is substantially elevated, even thousands of percent higher than normal. To troubleshoot this issue, here's what you might discover in the New Relic Lookout tabs: Performance would show you data about other signals, illuminating the characteristics of the change in system dynamics. Correlations would surface other applications that are affected and how, as well as opportunities to pivot to other applications that may be closer to the underlying causes. Traces, in turn, would show distributed traces, which can provide specific examples of traffic running through those systems. Abnormal history would show other times in the past week with elevated errors, showing whether or not this problem happens regularly, such as every day at the same time or whenever there is a deployment. Profiles might show that all or most of the new errors share common properties, such as all being isolated to just one region/account/user. Combining the information from these sections, not only can you get a sense of what is going on, but also where to focus actions to resolve the problem.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 241.49417,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "sections": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in <em>New</em> <em>Relic</em> database (NRDB), including third-party, open, and custom data. Launch into other areas of <em>New</em> <em>Relic</em> <em>One</em> for deeper"
      },
      "id": "603e821e64441f5a444e8845"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Why it matters",
        "View and connect the performance of your entities",
        "Tip",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-09-14T14:34:02Z",
      "updated_at": "2021-07-28T06:53:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities Access the New Relic Explorer at one.newrelic.com and see together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer's three views and the following features: one.newrelic.com > Explorer: Use the New Relic Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group, and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Saved views. Save your favorite filters as a view and recover them in a click each time you return to the Explorer. Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in one place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes. It allows you to see only entities of the selected type, as it updates the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The New Relic Explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention New Relic Explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.96788,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer&#x27;s three views and the following features: <em>one</em>.newrelic.com &gt; Explorer: <em>Use</em> the <em>New</em> <em>Relic</em> Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic": [
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-09-14T10:08:22Z",
      "updated_at": "2021-08-21T09:28:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. For APM agents, restart your service. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration, both methods require you to restart your service. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 241.49539,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Use</em> tags to help organize and find your data",
        "sections": "<em>Use</em> tags to help organize and find your data",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " to filter the UI <em>Use</em> the filter field at the top of the <em>New</em> <em>Relic</em> Explorer to filter down to the entities you care about. You can <em>use</em> multiple filter conditions. To filter down to certain entities using tags: From <em>one</em>.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "New Relic Lookout: Monitor your estate at a glance",
        "Why it matters",
        "Requirements",
        "Get started with New Relic Lookout",
        "Circle visualization and table view",
        "Abnormal golden signals",
        "Instant search",
        "Change view",
        "Drill down into the details",
        "Performance tab",
        "Abnormal History tab",
        "Correlations tab",
        "Profile tab",
        "Traces tab",
        "Create a custom view",
        "Query: Compare the last 15 minutes to the same time 1 day ago",
        "Query: Compare a specific time range to the same range a month ago",
        "Example: Unusual increases in error count"
      ],
      "title": "New Relic Lookout: Monitor your estate at a glance",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "9193dcc8851c185ff5d96f6f93ab412bd1be69e9",
      "image": "https://docs.newrelic.com/static/178b37068bad2a68cff027c8bdcf663a/c1b63/lookout-intro.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-lookout-monitor-your-estate-glance/",
      "published_at": "2021-09-14T07:54:08Z",
      "updated_at": "2021-08-21T09:27:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Lookout provides visibility into your entire estate. It doesn't require any configuration — you can query anything in your estate that matters to you right now and understand your system as a whole, or dive deep into causes and effects, so you can quickly get the data you need to take action. Know exactly where to focus your attention with New Relic Lookout. The brighter the color, the more severe the change, and the bigger the size, the bigger the scale. Then dig deeper with correlations and abnormal history to see how it impacts your whole system—no configuration needed. Why it matters New Relic Lookout helps software teams of any size discover potential issues before they have an impact. Fill gaps in monitoring with full coverage out-of-the-box, no configuration or setup required. Immediately see anything deviating from normal across your entire estate. Proactively spot emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in New Relic database (NRDB), including third-party, open, and custom data. Launch into other areas of New Relic One for deeper understanding Requirements New Relic Lookout requires Pro or Enterprise edition. If you are on Standard edition, you can still use the New Relic Lookout view in the New Relic Explorer. If you want to see data spanning 13-months, correlations, profiles, traces, and other details, you must upgrade to a higher edition. Get started with New Relic Lookout To access New Relic Lookout, click the Apps button in New Relic One and locate the New Relic Lookout launcher. You can also access New Relic Lookout directly from the New Relic One header bar, via the More dropdown. Enablement of key service performance indicator data is required for New Relic Lookout to provide value from the data you already have. The default view provides insight into three key Service performance indicators broken down by application: throughput, response time, and errors. These metrics are analyzed to show how the data has behaved during the last five minutes compared to the prior hour. one.newrelic.com > Apps > New Relic Lookout: Anything that significantly deviates from the trend is automatically discovered by New Relic Lookout, which doesn't require any configuration. Circle visualization and table view Each application (or other facet) is represented by a circle. The size of the circles indicate the magnitude of the signal for that application and the color indicates whether the value has significantly decreased or increased in the last five minutes, based on the standard deviation of the prior hour (default evaluation and comparison time windows.) Please note that the type of signal is important when interpreting your results. When you first look at the legend below, you might be tempted to interpret yellow as good and dark purple as bad, but that is not always the case. Here are some examples: In the APM/services golden signals, a dark yellow circle in Throughput might signify that something bad has occurred and led to a drop in traffic. At the same time, a dark purple circle might also be concerning due to unexpected load. Both are significant findings worth exploring. In browser golden signals, a dark purple circle in Page Views might be great, as you are seeing more traffic to your site! With errors golden signals (in all entity types), a large circle, even if gray (not deviating from normal volume), is worth exploring because a high count of errors in your system is important to investigate. The legend allows you to change the colors used to highlight deviating services To change the color palette, click the gear icon by the low-high color legend. This allows you to change the colors used to highlight deviating services. To get a table view of the same data, click the toggle on the right. You can also hover over each color to filter the view by degree lower or higher deviance. Abnormal golden signals On the right, New Relic Lookout displays the most significantly deviating applications (or other facet) in a side panel, weighted by both the magnitude of the performance indicators and the scale of their deviations. Details include the name of the key performance indicator, their magnitude during the recent time window, and the difference between the averages from one time compared to the other. Instant search Click the magnifying glass icon in the side panel to open a search box. Typing into the search box filters the circles, table, and abnormal signals to applications (or other facets) that contain the text. This is a good way to quickly zoom to various subsystems. New Relic Lookout doesn't rerun the analysis when using the instant search. Change view Click the Change View button on the right side panel. The panel that appears shows you all the entity-specific golden signals you can toggle between out of the box. By choosing the Browser Golden Signal or other views, you can change from the default view. Each new view will have the golden signals appropriate for that entity type. Drill down into the details To analyze an application or facet, click a circle, table row, or abnormal golden signal. The details panel shows the degree of deviation of the performance indicator, a link to the affected entity, and recent alert and deployment activity for that entity, when available. There’s also an indication of whether the selected evaluation time period would be abnormal or not in reference to other comparison time windows, such as the same time yesterday or the same time last week. This allows you to quickly see if the abnormal behavior is odd in general, or just based on the comparison time window. Performance tab The default tab shows charts for other key performance indicators for the selected application or facet. The charts compare the two time windows being analyzed. You can click their titles to rerun the analysis, focusing on the selected key performance indicator. When the target is a New Relic One application, we show the top transactions, error classes, external services, and database operations, alongside links to the relevant New Relic One features. Abnormal History tab This section analyzes past performance of the selected signal and calls out any time periods with notable abnormalities. Each card represents an abnormal time window and can be clicked for more details. The charts will display any relevant violations and deployments in New Relic. Correlations tab New Relic Lookout can find other signals that began behaving differently around the same time as the selected signal for that entity type. Clicking the name of the signal reruns the analysis, focusing on that key performance indicator. The chart titles link to New Relic One when there’s an associated entity in your account. Note that correlations currently do not analyze across accounts. The correlated signals displayed are for others in the account of the original application you are viewing. This helps focus the data on correlations that are more likely related to your issue. Profile tab Based on the same technology as New Relic’s error profiles, this tab compares the last five minutes to the prior hour by default (or whatever time windows you’ve selected with query editing) and surfaces any attributes that have significantly different distributions in the events being targeted by the selected signal. For example, if a custom attribute indicated that a recent throughput spike came from one user, that would surface highly in Profiles if most of the traffic usually comes from many users. Traces tab If the entity has distributed traces configured and available in the selected evaluated time window, the Traces section is enabled. Each card shows a summary of a trace and can be clicked for details. The Explore all traces links to the distributed traces application, filtered to the selected entity. Create a custom view To target signals and time windows beyond the default values, click the Change view button and select Custom view. To create your own view: Select the account or subaccount. Select the data type (metrics or events). Different functionality is available depending on the type. In View a chart with, select the metric or event you are interested in. Default is golden signals (throughput, response time, and errors). You can also build custom queries (filters) to target a signal that isn't on the list. In Facet by, select what the circles represent. Default is appName, but you can also choose host or any other facetable attribute available for the signal you’ve selected. If you plan to save/favorite this new view, provide a name in the Name your view box. Keep in mind that you can edit this view at any time using the pencil icon. The default time windows analyzed by New Relic Lookout are the last five minutes compared to the hour before. Use the time controls (View data from and Compare data to) to target other time windows. one.newrelic.com > Apps > New Relic Lookout: All event and metric data in the New Relic database can be queried using the Edit query feature. Click Analyze to begin analyzing the signal you’ve selected. You can also create your own query: Create your query. This query is comparing data from the past thirty minutes to data from the same range a day ago. Change from Basic to Advanced after clicking the Custom view button. Select the data type (metrics or events). Different functionality is available depending on the type. Enter your query using NRQL. Please note that not all NRQL features are available in the Lookout Advanced query feature. By default, the system will run this query using the last five minutes of data compared to the previous hour. Some examples of the syntax for changing the comparison and evaluation time windows are below. Click Analyze to begin analyzing the signal you’ve selected. Query: Compare the last 15 minutes to the same time 1 day ago Please note that the UNTIL NOW portion is required here unlike in standard NRQL. Without the UNTIL NOW added, the system will query a 5 minute slice of data starting 15 minutes ago SINCE 15 minutes AGO UNTIL NOW COMPARE WITH 1 day ago Copy Query: Compare a specific time range to the same range a month ago SINCE '2021-03-07 07:00:00-0500' UNTIL '2021-03-08 07:00:00-0500' COMPARE WITH 1 month ago Copy Or: SINCE 'today at midnight' UNTIL 'now' COMPARE WITH 1 MONTH AGO Copy Example: Unusual increases in error count The default view of New Relic Lookout shows application status across your estate, comparing the last five minutes to the hour before. Under regular operation, most large systems may have a handful of abnormalities, but usually most things will indicate normal behavior. Suddenly, several circles begin to change to red under the Errors section. This indicates that several applications are experiencing unusual increases in error count. It may be that one or two circles for important systems are red, and perhaps much larger than they usually appear. Clicking one of these can provide more information on what is happening. You might see that the error rate is substantially elevated, even thousands of percent higher than normal. To troubleshoot this issue, here's what you might discover in the New Relic Lookout tabs: Performance would show you data about other signals, illuminating the characteristics of the change in system dynamics. Correlations would surface other applications that are affected and how, as well as opportunities to pivot to other applications that may be closer to the underlying causes. Traces, in turn, would show distributed traces, which can provide specific examples of traffic running through those systems. Abnormal history would show other times in the past week with elevated errors, showing whether or not this problem happens regularly, such as every day at the same time or whenever there is a deployment. Profiles might show that all or most of the new errors share common properties, such as all being isolated to just one region/account/user. Combining the information from these sections, not only can you get a sense of what is going on, but also where to focus actions to resolve the problem.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 241.49414,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "sections": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in <em>New</em> <em>Relic</em> database (NRDB), including third-party, open, and custom data. Launch into other areas of <em>New</em> <em>Relic</em> <em>One</em> for deeper"
      },
      "id": "603e821e64441f5a444e8845"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Why it matters",
        "View and connect the performance of your entities",
        "Tip",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-09-14T14:34:02Z",
      "updated_at": "2021-07-28T06:53:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities Access the New Relic Explorer at one.newrelic.com and see together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer's three views and the following features: one.newrelic.com > Explorer: Use the New Relic Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group, and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Saved views. Save your favorite filters as a view and recover them in a click each time you return to the Explorer. Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in one place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes. It allows you to see only entities of the selected type, as it updates the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The New Relic Explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention New Relic Explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.96788,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " to monitor any data source. Learn more about entity synthesis. Toggle between the Explorer&#x27;s three views and the following features: <em>one</em>.newrelic.com &gt; Explorer: <em>Use</em> the <em>New</em> <em>Relic</em> Explorer to locate and examine the entities you monitor. List. Browse and filter from a list of all the entities in your"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one": [
    {
      "sections": [
        "What is an entity in New Relic?",
        "What's an entity?",
        "Find and explore entities and entity data",
        "Tip",
        "Group and organize entities",
        "Customize entity data with entity synthesis",
        "Reserved attributes for synthesized entities",
        "Entity relationships",
        "Important",
        "Which relationships are created?",
        "Source: New Relic agent",
        "Source: Infrastructure",
        "Source: Synthetics monitor",
        "Source: Kubernetes",
        "External services"
      ],
      "title": "What is an entity in New Relic?",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "52a3e08bc9103c717d27b153e4fd4f547d6ecc32",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-09-14T10:08:21Z",
      "updated_at": "2021-09-01T17:25:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic monitoring is built around the concept of entities. In this doc, you'll learn how we define entities, what you can do with them, and how you can create your own entities or groupings of entities. What's an entity? From a New Relic perspective, entity is purposefully a broad concept. An entity is anything that a) reports data to New Relic or that contains data that we have access to, and b) is something we've identified with a unique entity ID. For most entities, the ID is indicated by the attribute entityGuid. An entity can be any fundamental data-reporting component, like an application, a host, or a database service, but it can also refer to larger groupings of those components. For example, to monitor a data center, you could aggregate those hosts in New Relic to be a workload (a custom grouping of entities). That workload is, itself, also an entity. Also very important is the relationships between entities. Our behind-the-scenes relationship-mapping helps us understand how entities are connected, how they affect each other. And this allows us to give you the power to configure how any data you're bringing in is related to existing entities, or how it's related to other entities. Our focus on entities and their relationships is important because our goal is to give you practical information about your business-important entities, and not give you an unhelpfully huge stream of data from a huge list of monitored things. With more insight at the entity level, you can better monitor and troubleshoot complex, modern systems. Find and explore entities and entity data Tip You can create new entity types for monitoring any data source. Learn more about entity synthesis. Some tips for finding and understanding entity data: To find an entity's entityGuid and entityName and other metadata: from any list of monitored entities in the New Relic Explorer, click an entity's icon, and click See metadata and tags. For most entities, its GUID is reported as the attribute entityGuid. For workloads, it's workloadGuid. You can run NRQL queries to find entities by their GUID. To see connections between entities, you have several options: When viewing an entity in the UI, use the Related entities UI. Service maps. Distributed tracing. Our NerdGraph API. To group entities together, see Group entities. Customize entity definitions and relationships. To learn technical details about entity types, see our GitHub repo. In an entity type's definition file, you'll see information like: The domain: for example, APM, or Infra. Its type: for example, Application or AWSECSCONTAINERINSTANCE. Default tags. The entityExpirationTime: how long data from that entity lasts in the UI, which is different from database data retention. Group and organize entities You can place entities into groups that reflect business-important relationships in your organization. For example, you might group all entities related to a specific team or department, or related to a specific service. Or you might group multiple hosts together to reflect their grouping in a data center. To group your entities, see: Tag entities. Create workloads, which allow you to group business-important sets of entities. Create entities and customize entity data Customize entity data with entity synthesis If you have telemetry from any source that's not supported by New Relic out of the box, you can propose a mapping for it. Once approved, any telemetry received by New Relic that matches your definition file will be synthesized into an entity. To learn more: For reserved attributes and how entity relationships are defined, keep reading this doc. For how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Reserved attributes for synthesized entities These attributes are meant to be synthesized from the telemetry we receive. Do not set them unless you're aware of the implications and consequences. Attribute Description entity.guid Generally, you should not set this attribute field on your telemetry data. New Relic may add this field to ingested data to store a unique identifier for the entity associated with the data point. If telemetry arrives with the entity.guid attribute already present, then New Relic will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. One use case for passing this attribute is to associate ingested telemetry with an entity already created by New Relic. When the entity.guid attribute is sent, the value will override New Relic’s entity identification system (such as entity synthesis definitions) and instead will use the attribute as the data. entity.name This attribute shouldn't be put on ingested telemetry data unless you're trying to override the entity name that would have been selected by New Relic’s entity identification system. While New Relic won't change the value if it's already present on the data, New Relic may add the attribute to your data. Therefore invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. If this field is present on ingested telemetry, its value will be used to name the entity associated with the data point. This name will be used instead of the name selected by New Relic’s entity identification system (for example, entity synthesis definitions). Note that many entities use the name as part of their identification, so changing this field may result in the generation of a new entity. entity.type This attribute shouldn't be put on ingested telemetry data except for certain legacy cases where it's required to distinguish entity types. Passing this field may interfere with entity detection, particularly if unrecognized values are sent in this field. While New Relic won't change the value if already present on the data, the field is not guaranteed to provide unambiguous filtering of telemetry at query-time. Existing entity definitions already have overlapping values, and we recommend avoiding entity.type in favor of other fields for filtering telemetry queries. This field is used by New Relic, meaning that invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. To learn how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Entity relationships Connections between entities are automatically created by New Relic based on what we can infer from your telemetry. For example, when two services that communicate using HTTP are instrumented with New Relic, we infer a \"calls/called-by\" relationship between them. When viewing a specific entity in either the New Relic Explorer, Navigator, or Lookout, you can see its Related entities in the entity's mini overview. This gives a visualization of the various entities connected directly to the current entity. You can quickly view important metrics for these related entities and navigate from one entity to another, through all the connected parts of your stack. Tip Learn more about how entities are related with our NerdGraph API. When relationships are not automatically detected, you can manually create them using the \"Add/edit related entities\" link in Related entities. Important Currently, you can only manually create calls/called-by relationships between service entities. Tip To manage manual relationships, you need to have modify and delete capabilities on entity relationships. If you don’t see the edit relationships button, contact your account admin. Which relationships are created? These are the relationships created between entities: Source: New Relic agent Relationship source Relationship type Relationship target Why is the relationship created? Application instrumented with a New Relic agent CALLS Application instrumented with a New Relic agent Relationships between applications monitored by New Relic agents are reported using the DurationByCaller metric. The callee reports the metric. For example, the metric DurationByCaller/Mobile/100/1234/HTTP/all indicates that the caller is APPLICATION 1234 for account 100. Application instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent An application (caller) that calls a service (callee) monitored by New Relic creates a relationship that's reported by the caller using the ExternalApp metric. For example, the metric ExternalApp/dirac.vips.net/100#1234/all indicates that the callee is APPLICATION 1234 for account 100. The metric is reported if the callee successfully responds to the caller. Service instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent When a New Relic agent detects that a service (caller) calls another service (callee) instrumented by New Relic, the callee reports the metric ClientApplication. For example, the metric ClientApplication/100#1234/all indicates that the caller is APPLICATION 1234 for account 100. Service instrumented with a New Relic agent CALLS A datastore instance When an application calls a datastore instance it creates a relationship reported with the DatastoreInstance metric. For example, the metric Datastore/instance/MySQL/172.16.16.3/3306 indicates the datastore instance is vendor: MySQL, host: 172.16.16.3, port: 3306. This metric also supports the legacy datastore instance format Datastore/instance/MySQL/172.16.16.3:3306. Currently we cannot determine whether the datastore instance is instrumented by New Relic and has an entity associated to it. APM agent SERVES Browser agent This relationship is created when an APM agent injects the browser agent into a page. Workload entity CONTAINS Any entity When a workload is created or updated, relationships for each of the entities that belong to the workload are created. Because some workloads are “dynamic” (defined by tags), relationships are re-created every 5 minutes. This way entities can join or leave the workload. Source: Infrastructure Relationship source Relationship type Relationship target Why is the relationship created? Infrastructure host HOSTS Application This relationship is created when an application is running in one or more hosts, and the infra agent is running in those hosts. Infrastructure host HOSTS Container This relationship is created when containers are running in one or more hosts, and the host is instrumented with the infra agent. Source: Synthetics monitor Relationship source Relationship type Relationship target Why is the relationship created? Synthetics Monitor CALLS Browser agent This relationship is created when a synthetics monitor checks a page instrumented with the browser agent. Synthetics Monitor CALLS APM application Agent events that contain the attribute nr.syntheticsMonitorId have been described as synthetics monitors (the source) interacting with an APM application (the target). If the header exists and the APM application Id exists, a relationship is created between the monitor and the app. Source: Kubernetes Relationship source Relationship type Relationship target Why is the relationship created? Cluster CONTAINS Pod This relationship is created when a pod is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Deployment This relationship is created when a deployment is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS DaemonSet This relationship is created when a DaemonSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS StatefulSet This relationship is created when a StatefulSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Host This relationship is created when a host that's part of a cluster is instrumented with the New Relic Kubernetes integration. Deployment CONTAINS Pod This relationship is created when a deployment creates a pod in a cluster instrumented with the New Relic Kubernetes integration. DaemonSet CONTAINS Pod This relationship is created when a DaemonSet is created a pod in a cluster instrumented with the New Relic Kubernetes integration. StatefulSet CONTAINS Pod This relationship is created when a StatefulSet creates a pod in a cluster instrumented with the New Relic Kubernetes integration. Pod CONTAINS Container This relationship is created when a pod creates a container in a cluster instrumented with the New Relic Kubernetes integration. Host HOSTS Pod This relationship is created when a pod is running in a host that's part of a cluster instrumented with the New Relic Kubernetes integration. Container HOSTS Application This relationship is created when an application is running in docker, and the hosts where docker is running are instrumented by the the infra agent. External services Relationship source Relationship type Relationship target Why is the relationship created? External service CALLS External service When the relationship is created, the external service reports a span with its name on the service.name attribute and the name of the service that initiates the call in the parent.service.name attribute. Application IS External service A relationship between an application and an external service is created so that users can navigate between them using the related entities component. Browser application instrumented with a New Relic agent CALLS External service A browser application reports an Ajax/HostTransaction metric when calling an external service (URL). Example metric: Ajax/HostTransaction/api.segment.io:443/CallbackTime' Cluster CONTAINS External service When the relationship is created, the external service reports a span with the attribute k8s.cluster.name, the name of the cluster. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span. Pod HOSTS External service When the relationship is created, the external service reports a span with the following attributes: service.name: The name of the service. k8s.cluster.name: The name of the cluster. k8s.pod.name: The name of the pod that’s running the service. k8s.namespace.name: The namespace where the pod was created. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.8858,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What is an entity in <em>New</em> <em>Relic</em>?",
        "sections": "What is an entity in <em>New</em> <em>Relic</em>?",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": ". If telemetry arrives with the entity.guid attribute already present, then <em>New</em> <em>Relic</em> will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. <em>One</em> <em>use</em> case for passing this attribute is to associate"
      },
      "id": "603ec160e7b9d295f72a07fc"
    },
    {
      "sections": [
        "New Relic Lookout: Monitor your estate at a glance",
        "Why it matters",
        "Requirements",
        "Get started with New Relic Lookout",
        "Circle visualization and table view",
        "Abnormal golden signals",
        "Instant search",
        "Change view",
        "Drill down into the details",
        "Performance tab",
        "Abnormal History tab",
        "Correlations tab",
        "Profile tab",
        "Traces tab",
        "Create a custom view",
        "Query: Compare the last 15 minutes to the same time 1 day ago",
        "Query: Compare a specific time range to the same range a month ago",
        "Example: Unusual increases in error count"
      ],
      "title": "New Relic Lookout: Monitor your estate at a glance",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "9193dcc8851c185ff5d96f6f93ab412bd1be69e9",
      "image": "https://docs.newrelic.com/static/178b37068bad2a68cff027c8bdcf663a/c1b63/lookout-intro.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-lookout-monitor-your-estate-glance/",
      "published_at": "2021-09-14T07:54:08Z",
      "updated_at": "2021-08-21T09:27:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Lookout provides visibility into your entire estate. It doesn't require any configuration — you can query anything in your estate that matters to you right now and understand your system as a whole, or dive deep into causes and effects, so you can quickly get the data you need to take action. Know exactly where to focus your attention with New Relic Lookout. The brighter the color, the more severe the change, and the bigger the size, the bigger the scale. Then dig deeper with correlations and abnormal history to see how it impacts your whole system—no configuration needed. Why it matters New Relic Lookout helps software teams of any size discover potential issues before they have an impact. Fill gaps in monitoring with full coverage out-of-the-box, no configuration or setup required. Immediately see anything deviating from normal across your entire estate. Proactively spot emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in New Relic database (NRDB), including third-party, open, and custom data. Launch into other areas of New Relic One for deeper understanding Requirements New Relic Lookout requires Pro or Enterprise edition. If you are on Standard edition, you can still use the New Relic Lookout view in the New Relic Explorer. If you want to see data spanning 13-months, correlations, profiles, traces, and other details, you must upgrade to a higher edition. Get started with New Relic Lookout To access New Relic Lookout, click the Apps button in New Relic One and locate the New Relic Lookout launcher. You can also access New Relic Lookout directly from the New Relic One header bar, via the More dropdown. Enablement of key service performance indicator data is required for New Relic Lookout to provide value from the data you already have. The default view provides insight into three key Service performance indicators broken down by application: throughput, response time, and errors. These metrics are analyzed to show how the data has behaved during the last five minutes compared to the prior hour. one.newrelic.com > Apps > New Relic Lookout: Anything that significantly deviates from the trend is automatically discovered by New Relic Lookout, which doesn't require any configuration. Circle visualization and table view Each application (or other facet) is represented by a circle. The size of the circles indicate the magnitude of the signal for that application and the color indicates whether the value has significantly decreased or increased in the last five minutes, based on the standard deviation of the prior hour (default evaluation and comparison time windows.) Please note that the type of signal is important when interpreting your results. When you first look at the legend below, you might be tempted to interpret yellow as good and dark purple as bad, but that is not always the case. Here are some examples: In the APM/services golden signals, a dark yellow circle in Throughput might signify that something bad has occurred and led to a drop in traffic. At the same time, a dark purple circle might also be concerning due to unexpected load. Both are significant findings worth exploring. In browser golden signals, a dark purple circle in Page Views might be great, as you are seeing more traffic to your site! With errors golden signals (in all entity types), a large circle, even if gray (not deviating from normal volume), is worth exploring because a high count of errors in your system is important to investigate. The legend allows you to change the colors used to highlight deviating services To change the color palette, click the gear icon by the low-high color legend. This allows you to change the colors used to highlight deviating services. To get a table view of the same data, click the toggle on the right. You can also hover over each color to filter the view by degree lower or higher deviance. Abnormal golden signals On the right, New Relic Lookout displays the most significantly deviating applications (or other facet) in a side panel, weighted by both the magnitude of the performance indicators and the scale of their deviations. Details include the name of the key performance indicator, their magnitude during the recent time window, and the difference between the averages from one time compared to the other. Instant search Click the magnifying glass icon in the side panel to open a search box. Typing into the search box filters the circles, table, and abnormal signals to applications (or other facets) that contain the text. This is a good way to quickly zoom to various subsystems. New Relic Lookout doesn't rerun the analysis when using the instant search. Change view Click the Change View button on the right side panel. The panel that appears shows you all the entity-specific golden signals you can toggle between out of the box. By choosing the Browser Golden Signal or other views, you can change from the default view. Each new view will have the golden signals appropriate for that entity type. Drill down into the details To analyze an application or facet, click a circle, table row, or abnormal golden signal. The details panel shows the degree of deviation of the performance indicator, a link to the affected entity, and recent alert and deployment activity for that entity, when available. There’s also an indication of whether the selected evaluation time period would be abnormal or not in reference to other comparison time windows, such as the same time yesterday or the same time last week. This allows you to quickly see if the abnormal behavior is odd in general, or just based on the comparison time window. Performance tab The default tab shows charts for other key performance indicators for the selected application or facet. The charts compare the two time windows being analyzed. You can click their titles to rerun the analysis, focusing on the selected key performance indicator. When the target is a New Relic One application, we show the top transactions, error classes, external services, and database operations, alongside links to the relevant New Relic One features. Abnormal History tab This section analyzes past performance of the selected signal and calls out any time periods with notable abnormalities. Each card represents an abnormal time window and can be clicked for more details. The charts will display any relevant violations and deployments in New Relic. Correlations tab New Relic Lookout can find other signals that began behaving differently around the same time as the selected signal for that entity type. Clicking the name of the signal reruns the analysis, focusing on that key performance indicator. The chart titles link to New Relic One when there’s an associated entity in your account. Note that correlations currently do not analyze across accounts. The correlated signals displayed are for others in the account of the original application you are viewing. This helps focus the data on correlations that are more likely related to your issue. Profile tab Based on the same technology as New Relic’s error profiles, this tab compares the last five minutes to the prior hour by default (or whatever time windows you’ve selected with query editing) and surfaces any attributes that have significantly different distributions in the events being targeted by the selected signal. For example, if a custom attribute indicated that a recent throughput spike came from one user, that would surface highly in Profiles if most of the traffic usually comes from many users. Traces tab If the entity has distributed traces configured and available in the selected evaluated time window, the Traces section is enabled. Each card shows a summary of a trace and can be clicked for details. The Explore all traces links to the distributed traces application, filtered to the selected entity. Create a custom view To target signals and time windows beyond the default values, click the Change view button and select Custom view. To create your own view: Select the account or subaccount. Select the data type (metrics or events). Different functionality is available depending on the type. In View a chart with, select the metric or event you are interested in. Default is golden signals (throughput, response time, and errors). You can also build custom queries (filters) to target a signal that isn't on the list. In Facet by, select what the circles represent. Default is appName, but you can also choose host or any other facetable attribute available for the signal you’ve selected. If you plan to save/favorite this new view, provide a name in the Name your view box. Keep in mind that you can edit this view at any time using the pencil icon. The default time windows analyzed by New Relic Lookout are the last five minutes compared to the hour before. Use the time controls (View data from and Compare data to) to target other time windows. one.newrelic.com > Apps > New Relic Lookout: All event and metric data in the New Relic database can be queried using the Edit query feature. Click Analyze to begin analyzing the signal you’ve selected. You can also create your own query: Create your query. This query is comparing data from the past thirty minutes to data from the same range a day ago. Change from Basic to Advanced after clicking the Custom view button. Select the data type (metrics or events). Different functionality is available depending on the type. Enter your query using NRQL. Please note that not all NRQL features are available in the Lookout Advanced query feature. By default, the system will run this query using the last five minutes of data compared to the previous hour. Some examples of the syntax for changing the comparison and evaluation time windows are below. Click Analyze to begin analyzing the signal you’ve selected. Query: Compare the last 15 minutes to the same time 1 day ago Please note that the UNTIL NOW portion is required here unlike in standard NRQL. Without the UNTIL NOW added, the system will query a 5 minute slice of data starting 15 minutes ago SINCE 15 minutes AGO UNTIL NOW COMPARE WITH 1 day ago Copy Query: Compare a specific time range to the same range a month ago SINCE '2021-03-07 07:00:00-0500' UNTIL '2021-03-08 07:00:00-0500' COMPARE WITH 1 month ago Copy Or: SINCE 'today at midnight' UNTIL 'now' COMPARE WITH 1 MONTH AGO Copy Example: Unusual increases in error count The default view of New Relic Lookout shows application status across your estate, comparing the last five minutes to the hour before. Under regular operation, most large systems may have a handful of abnormalities, but usually most things will indicate normal behavior. Suddenly, several circles begin to change to red under the Errors section. This indicates that several applications are experiencing unusual increases in error count. It may be that one or two circles for important systems are red, and perhaps much larger than they usually appear. Clicking one of these can provide more information on what is happening. You might see that the error rate is substantially elevated, even thousands of percent higher than normal. To troubleshoot this issue, here's what you might discover in the New Relic Lookout tabs: Performance would show you data about other signals, illuminating the characteristics of the change in system dynamics. Correlations would surface other applications that are affected and how, as well as opportunities to pivot to other applications that may be closer to the underlying causes. Traces, in turn, would show distributed traces, which can provide specific examples of traffic running through those systems. Abnormal history would show other times in the past week with elevated errors, showing whether or not this problem happens regularly, such as every day at the same time or whenever there is a deployment. Profiles might show that all or most of the new errors share common properties, such as all being isolated to just one region/account/user. Combining the information from these sections, not only can you get a sense of what is going on, but also where to focus actions to resolve the problem.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.65561,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "sections": "<em>Get</em> <em>started</em> with <em>New</em> <em>Relic</em> Lookout",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " to a higher edition. <em>Get</em> <em>started</em> with <em>New</em> <em>Relic</em> Lookout To access <em>New</em> <em>Relic</em> Lookout, click the Apps button in <em>New</em> <em>Relic</em> <em>One</em> and locate the <em>New</em> <em>Relic</em> Lookout launcher. You can also access <em>New</em> <em>Relic</em> Lookout directly from the <em>New</em> <em>Relic</em> <em>One</em> header bar, via the More dropdown. Enablement of key service"
      },
      "id": "603e821e64441f5a444e8845"
    },
    {
      "sections": [
        "Basic platform UI: search, share, chart UI, customize navigation, and more",
        "Observe your platform",
        "Customize the navigation bar and shortcuts",
        "Light and dark mode",
        "Search accounts and entities",
        "Chart and query features",
        "Share New Relic views with others",
        "Account and user settings",
        "Other UI experiences"
      ],
      "title": "Basic platform UI: search, share, chart UI, customize navigation, and more",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "b3cdcfc60a2821dfa5bee9766aba483cc3389398",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-09-14T10:08:22Z",
      "updated_at": "2021-08-21T09:29:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One has some basic UI functions that are widely available across the platform. Understanding these features will help you find and analyze your data more easily. Observe your platform New Relic One gives you full access to the data from all the entities in your stack. Go to the New Relic Explorer at one.newrelic.com to see a full list of entities, identify overall behaviors, filter them to locate sources of performance issues, or plan improvements for your system. Customize the navigation bar and shortcuts Select the edit icon at the right end of the navigation bar to customize your view. Home, Explorer, Browse data, Dashboards, and Alerts & AI are fixed, but you can favorite up to six more elements to display on the bar as well. The rest will go on the More group. Navigation shortcuts are a faster way to find entities and apps that are relevant to you. Mouse over any menu item for quick access to your favorite entities, those you recently visited, or just to search without having to navigate to a specific section. If you click on an entity, you can choose to open it in the same browser tab or in a new one. Light and dark mode See Light and dark mode. Search accounts and entities Access Quick find clicking the button, near the top right of the New Relic One UI. Some details about your search: You can search across all accounts that you have been granted access to in your organization. For more about account access, see Factors affecting access. Entities that cease to exist are available in search for eight days. If your organization has multiple accounts, use the account picker at the top left corner to select accounts. Chart and query features You can add most charts to a new or existing dashboard. Here are some query and chart features available across all or most of the platform: If you want to... Do this... Start querying your data Mouse over Browse data and select metrics, events, logs, or traces for a direct access to any of those types of data. Also, at the top of any UI page, select Query your data to access the data explorer and query builder. View a chart's query For some charts, you can view the NRQL query used to generate that chart. This can help you understand a chart better or use it as the basis for a new query. Choose time range Drag across a section of a chart to zoom in on that time range. Or, use the time picker in the top right corner of the UI to select pre-set time ranges or set a custom one. View chart details Mouse over a chart to see a pop-up with more detail. For some charts, selecting a point on the chart will take you to a UI page with more information about that metric. Hide or return chart elements To hide or unhide a displayed chart element, select that element's name below the chart. The chart display will adjust to reflect the absence or presence of that element. Share New Relic views with others Here are some options for sharing New Relic UI pages and visualizations. If you want to... Do this... Share UI pages and dashboards To share an entire New Relic UI page, click Share near the top of the UI to copy the URL. Share charts If New Relic charts are built with NRQL queries, they have a menu that exposes various options, including sharing options like Get as image and Get chart link. Some notes about sharing: The person you share with may not have access to view the data from that account. To solve that, someone on your team with New Relic user management abilities must add that person to the account. If someone can't access a custom dashboard, it may be that it is set to private. Read more about dashboard permissions. Some sharing options have associated time ranges, which may impact later viewings of it. For example, if you use a chart's Get chart link option and that chart is set to 'Last 30 minutes', when viewed it will show the last 30 minutes, not the time range displayed when it was shared. To share a specific time range, you must select that time range in the UI. Account and user settings To find account settings and user preferences, use the account dropdown, located at the top right of the UI, beside your user name. Other UI experiences This has been a look at a few basic platform UI experiences. For more about the UI, search for docs related to the specific New Relic solution you're using.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.14185,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Share <em>New</em> <em>Relic</em> views with others",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> has some basic UI functions that are widely available across the platform. Understanding these features will help you find and analyze your data more easily. Observe your platform <em>New</em> <em>Relic</em> <em>One</em> gives you full access to the data from all the entities in your stack. Go to the <em>New</em> <em>Relic</em>"
      },
      "id": "603ec1f964441f5b0e4e8860"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features": [
    {
      "sections": [
        "Dependencies UI: View an entity's upstream and downstream dependencies",
        "Requirements",
        "View dependencies"
      ],
      "title": "Dependencies UI: View an entity's upstream and downstream dependencies",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "2b2f328a6281bb155bcde07efec7f42eae943048",
      "image": "https://docs.newrelic.com/static/aabc5f64a91cc01b6e226df53c62458f/c1b63/new-relic-one-dependencies-UI.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/explore-downstream-dependencies-new-relic-one/",
      "published_at": "2021-09-14T10:09:26Z",
      "updated_at": "2021-08-21T09:29:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the New Relic Explorer, an entity's Dependencies page shows a filterable list of all the applications, services, databases, and hosts connected to the entity. It shows upstream and downstream dependencies, and provides paths to explore them. Similar to service maps, the dependencies page helps you understand how all of your upstream and downstream services are connected. It also uses the same color coding system used by service maps to show you what's performing well and what isn't. Requirements To view an entity's dependencies, make sure your app uses the minimum required APM agent version: C 1.0.0 or higher Go 1.11 or higher Java 3.9.0 or higher .NET 4.2 or higher Node.js 2.0.0 or higher PHP 4.19.0 or higher Python 2.38.0.31 or higher Ruby 4.3.0 or higher View dependencies To view dependencies for applications, services, databases, and hosts connected to an entity: Go to one.newrelic.com, select Explorer, and select an entity. Select Dependencies. To drill down further, filter the apps, services, databases, or hosts. one.newrelic.com > Explorer > (select an entity) > Dependencies: View a filterable list of all the apps, services, databases, and hosts connected to an entity, and their color-coded health status. You can filter the dependencies page to view specific things that report to the entity. Dependencies include: Services: APM-monitored applications and services. Mobile applications: your mobile apps. Browser applications: your front-end browser apps. External services: external services monitored by APM. External services include out-of-process services such as web services, resources in the cloud, and any other network calls. Databases: your application's database and cache data. Databases are agentless. Because of this, alerts cannot be set for the database, as only the service call is reported to New Relic. Hosts: your infrastructure (servers and hosts).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.6123,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Dependencies <em>UI</em>: View an entity&#x27;s upstream <em>and</em> downstream dependencies",
        "sections": "Dependencies <em>UI</em>: View an entity&#x27;s upstream <em>and</em> downstream dependencies",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " services: external services monitored by APM. External services include out-of-process services such as web services, resources in the cloud, and any other network calls. Databases: your application&#x27;s database and cache <em>data</em>. Databases are agentless. Because of this, alerts cannot be set for the database, as only the service call is reported to <em>New</em> <em>Relic</em>. Hosts: your infrastructure (servers and hosts)."
      },
      "id": "603eb2e564441f0fe44e889b"
    },
    {
      "sections": [
        "New Relic feature end of life announcements July 2020",
        "Old Kubernetes integration agent versions",
        "Monitor listing page and Synthetic labels",
        "\"Rollup by\" in Synthetics",
        "Embedded charts",
        "Legacy distributed tracing UI",
        "Violations changes",
        "Connected agents page",
        "Inactive apps in New Relic One",
        "Synthetic monitor alert notifications and conditions"
      ],
      "title": "New Relic feature end of life announcements July 2020",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "1db1d6b3df6d5ac3b983f78f3264cab332cff05a",
      "image": "https://docs.newrelic.com/static/f2b139d12bd8cdc13a9907b7874a4452/0a867/nrone-embed-bb062520.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/new-relic-feature-end-life-announcements-july-2020/",
      "published_at": "2021-09-14T10:10:35Z",
      "updated_at": "2021-07-22T05:05:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In order to improve your New Relic experience we've made some big improvements to our platform. As a result, we'll be ending support for some old features over the next few weeks. Many have already been publicly announced as \"end-of-life.\" These changes represent our commitment to improve your interactions with our platform. Our mission is one observability platform that unites your telemetry data, connects your full stack, and helps you build more perfect software. To that end we're focusing on simplifying your experience for troubleshooting, alerting, and visualizing data. Here are more details on what's changed, with some helpful links and guides on how to take advantage of new capabilities to achieve the same goals. As always, we're here to help. Please connect with us in the Explorers Hub, or contact your account team with any questions. Old Kubernetes integration agent versions To improve our unified experience, starting from Wednesday, August 12, 2020, Kubernetes integrations that use v1.7 or older will be deprecated. The UI experience in the infrastructure.newrelic.com domain will no longer be available; it will only be available in New Relic One. If you are already using the latest Kubernetes agent version, no action is necessary. If you are using v1.7 or older, you must update your integration in order to continue viewing Kubernetes performance data. Follow the instructions in our documentation to upgrade to the latest version of the Kubernetes integration. Action items for a successful transition: Review the Kubernetes agent deprecation notice. Follow standard procedures to upgrade your Kubernetes agent to the latest version. Learn about the Kubernetes cluster explorer UI in New Relic One. For more information, see the Explorers Hub post. Monitor listing page and Synthetic labels To improve the experience of Synthetic monitors and labels, we've moved both experiences into the New Relic One platform. If you use the REST API for Synthetic label management, you must update to the tags API moving forward. The good news: with the NerdGraph tags API, you can organize and group all your entities in a single request. For more information about any of the following, see the Explorers Hub post. Action items for a successful transition: Synthetic monitors transition Comments Monitor index list When migration is completed, no action is needed on your part to use the new Synthetics entity listing pages. The new experience will be available to you automatically after July 20, 2020. For more information, learn how the explorer in New Relic One replaces the Synthetics monitors index. Existing Synthetics labels You may have already seen an option in the UI to migrate your Synthetics monitor labels to New Relic One tags. If you did not select that option, we've got you covered. Automatic migration from labels to tags starts begins July 8, 2020. For more information, learn how tagging in New Relic One replaces labels for Synthetics monitors. REST API If you use the REST API for Synthetics label management, follow these steps to update to the tags API: Learn more about NerdGraph. Review the NerdGraph tagging API tutorial. Make sure you have a Personal API key to use NerdGraph. Follow the procedures in the Explorers Hub post (look for the How do I transition my scripts from the Synthetics API to the tag API (NerdGraph)? section), and update your existing tags with the GraphiQL explorer at api.newrelic.com/graphiql. NerdGraph is our GraphQL API, a query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time. \"Rollup by\" in Synthetics Synthetics is moving to New Relic One to provide a single platform for observability of your complex software systems. To do this we are unifying the tools you use to tag (or label) your services, applications, and monitors. The specific feature that is end-of-life is the Rollup by feature under the Search monitors dropdown menu. You can group monitors by tags in New Relic One without needing a separate Rollup by dropdown. No changes will be required to use the new Synthetic monitor listing pages. The new experiences will be available to you after July 20, 2020. Documentation: Tagging in New Relic One replaces labels for Synthetics monitors. Explorer in New Relic One replaces Synthetics monitors index. Action items for a successful transition: If you currently use Synthetics rollups: Follow the procedures in the Explorer Hub post to recreate the rollups that are being retired. Go to the Explorers Hub post about the rollups EOL. In particular, look for How can New Relic Workloads help me visualize groups of applications and monitors? in the post's FAQs section. Follow the procedures in the Explorers Hub post to recreate the rollups that are being retired. Embedded charts In order to reduce redundancy and provide a more unified experience, the embedded charts functionality will be replaced by the New Relic One Get chart. Embedded charts currently in use and hosted outside the New Relic domain will continue to function. The changes will include: The name on the chart's menu that generates them will change from Embed to Get chart link. For charts that are no longer supported, Embed will be replaced with Get chart link is not supported for this chart. The APM UI page that lists all embedded chart links will no longer be available. Documentation: Explorers Hub post New Relic One's enhanced query builder functionality replaces the EOL embed chart functionality. Action items for a successful transition: You can generate a publicly accessible link to add to internal and external websites. Users do not need to be logged in to New Relic to see the chart link. The ability to embed a chart will remain, but instead of clicking Embed (which will be removed from the UI), you will click Get chart link (which is in the same location). This gives you the ability to get links with an even broader range of chart visuals and behaviors than the one we are retiring. Here's an example of how it looks in New Relic One: To replace existing chart links you created with Embed, create new URLs with New Relic One's Get chart link, and insert them in webpages where they're used. If you have an embedded chart and get the message Get chart link is not supported for this chart, simply run a different query, select an available chart type, and then select Embed. Legacy distributed tracing UI To standardize our user experience, we will be deprecating the older distributed tracing UI, which exists within the rpm.newrelic.com domain. You can access distributed tracing through New Relic One, which provides a superior experience with all the functionality supported in the duplicate UI that is end-of-life. Documentation: Global and service-specific distributed tracing views in New Relic One Deprecated distributed tracing UI Action items for a successful transition: No action required, but you can get ready for the new UI experience. New Relic One's distributed tracing page builds on capabilities you are already familiar with. Get acquainted with the enhanced distributed tracing features in New Relic One, including search and filter capabilities with cross-account trace details, query options with the NerdGraph API, and histogram charts (which can help you quickly understand trace distribution for important values such as duration). Review the trace sampling options available with head-based sampling (standard distributed tracing) and tail-based sampling (Infinite Tracing). Violations changes In order to provide a unified experience, we're deprecating browser, mobile, and synthetics monitor violations and replacing them with the New Relic One equivalent. New Relic One users can access violations by using any of these options: Click the Alerts and AI link in New Relic One's main UI. Review the entity list activity stream. See alert details from inside a specific entity via the new indicator for Operational, Warning, and Critical violations. You will see alert details automatically when navigating to one.newrelic.com. Documentation: Applied Intelligence and alerting in New Relic One Browser alert violations (moving to New Relic One) Mobile violations (moving to New Relic One) Monitor violations (moving to New Relic One) Action items for a successful transition: No action required, but you can get ready for the new UI experience. Here's an example of the detailed information about an Alerts violation for a selected entity in New Relic One. Violation details in New Relic One Comments Holistic view From New Relic One's homepage, the entity list presents an activity stream of all entities with alert violations. You no longer need to jump around individual lists of end-user, mobile, or monitor violations. Enhanced troubleshooting tools From New Relic One's homepage, you will also see an Alerts & AI (Applied Intelligence) link. From here you can solve problems faster with anomaly detection, incident correlation, and noise reduction. Specific violation From a selected entity, you will see a new button identifying the violation as Operational, Warning, or Critical, as well as entity metadata and useful details about the incident. Connected agents page Finding your connected agents has never been easier! You can already do this via the Query your data link in New Relic One. Simply run these NrDailyUsage queries to get a list of connected agents and hosts. The old Connected agents page is end-of-life and will be removed. Documentation: Explorers Hub post NRQL query tools NrDailyUsage data definition Action items for a successful transition: To query your connected apps and hosts, you can use existing NRQL query tools, such as New Relic One's query builder or the GraphQL API. Recommendation: For best results exploring comprehensive data about your apps and hosts, use the query builder in New Relic One or the NerdGraph API. Inactive apps in New Relic One Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI. However, key metrics will continue to be available via the New Relic REST API based on subscription level. This is why the application name will remain reserved until the application is permanently deleted via the REST API Explorer. Action items for a successful transition: If you want to reuse an app name for an old app that is no longer reporting data: Use the REST API v2 or API Explorer to get summary data, including app ID, name, health status (look for gray), last reported, etc. Uninstall the agent for your app. Use the REST API or API Explorer to delete the apps. Synthetic monitor alert notifications and conditions In order to provide a unified experience, we're deprecating Synthetics monitor alert notifications and condition violations. We are replacing these pages with a new Synthetics monitor overview experience in New Relic One. This new experience provides visibility into a monitor's open violations and alert conditions with the monitor results in a single view, removing the need to open multiple tabs to view violations or alert conditions. Action items for a successful transition: No action required, but you can get ready for the new UI experience by reviewing our documentation about New Relic Applied Intelligence, which includes: The alerting functionality you are already familiar with in New Relic Alerts, and more Incident Intelligence, which reduces noise and accelerates your incident resolution process Proactive Detection, which surfaces relevant issues and provides automatic explanations to their cause",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.82275,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> feature end of life announcements July 2020",
        "sections": "Inactive apps in <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " To improve our unified experience, starting from Wednesday, August 12, 2020, Kubernetes integrations that <em>use</em> v1.7 or older will be deprecated. The <em>UI</em> experience in the infrastructure.newrelic.com domain will no longer be available; it will only be available in <em>New</em> <em>Relic</em> <em>One</em>. If you are already using"
      },
      "id": "603e795364441ff1924e8872"
    },
    {
      "sections": [
        "Metric normalization rules",
        "Metric normalization rules management"
      ],
      "title": "Metric normalization rules",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "3c55e4717f145ac7ae0d88e860878f4e8d18cd6b",
      "image": "https://docs.newrelic.com/static/83edfb6f5b1b68712cac34d138bb8cb8/3996e/create-new-rule-window.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/metric-normalization-rules/",
      "published_at": "2021-09-14T10:10:37Z",
      "updated_at": "2021-03-29T20:39:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There may be cases where an application sends many individual metrics that could be better managed in groups. Most of these occur with web transactions metrics named from URLs. For more information on this issue, see Metric grouping issues (MGIs). To reduce high cardinality and prevent metric grouping issues, New Relic supports rules for grouping or filtering out metrics (normalization). In some cases, when MGIs with a significant high number of metrics are detected, a rule is created automatically to protect the platform from performance degradation. Metric normalization rules management You can create and manage new rules that deal with the noise produced from high cardinality metrics by using the metric normalization tool, which is accessible from each service dashboard in the New Relic Explorer. Once there, select Metric Normalization in the left sidebar. There you can see the existing rules or create new ones. Click a rule to modify it, or click Create a new rule to create a new one. A new pane to configure the rule will be displayed. Available fields are: Match expression: enter the regular expression to group all the metrics you want to include in the rule. Matches: here you will see a preview of the metrics matched by the regular expression above. Action: the action you want to perform on the metrics. Replace: replace the matched metrics by the regular expression with the value described in the Replacement field. Ignore: ignore any metric that matches the regular expression. Deny new metrics: only write metrics that have already been reported, and ignore those that match the regular expression. Replacement: only active when Replace is enabled. Matched metrics are replaced with the field's value. If the regular expression is capturing groups, you can use placeholders for them with \\1 or \\2 for the groups 1 and 2 respectively. Active: rules can’t be deleted, but can be deactivated. Click the toggle to enable or disable the rule. If you want the rule to be removed, reach out to New Relic's support. Notes: internal notes on the rule. Has no effect on the rule. Once you have set up the fields, click Create (or Edit in case you are editing an existing rule), and the rule will be applied immediately as long as it's Active.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.68855,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " grouping issues, <em>New</em> <em>Relic</em> supports rules for grouping or filtering out metrics (normalization). In some cases, when MGIs with a significant high number of metrics are detected, a rule is created automatically to protect the platform from performance degradation. Metric normalization rules management You"
      },
      "id": "603e810b64441ff3a74e8862"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/ui-data/explore-downstream-dependencies-new-relic-one": [
    {
      "sections": [
        "Basic platform UI: search, share, chart UI, customize navigation, and more",
        "Observe your platform",
        "Customize the navigation bar and shortcuts",
        "Light and dark mode",
        "Search accounts and entities",
        "Chart and query features",
        "Share New Relic views with others",
        "Account and user settings",
        "Other UI experiences"
      ],
      "title": "Basic platform UI: search, share, chart UI, customize navigation, and more",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "b3cdcfc60a2821dfa5bee9766aba483cc3389398",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-09-14T10:08:22Z",
      "updated_at": "2021-08-21T09:29:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One has some basic UI functions that are widely available across the platform. Understanding these features will help you find and analyze your data more easily. Observe your platform New Relic One gives you full access to the data from all the entities in your stack. Go to the New Relic Explorer at one.newrelic.com to see a full list of entities, identify overall behaviors, filter them to locate sources of performance issues, or plan improvements for your system. Customize the navigation bar and shortcuts Select the edit icon at the right end of the navigation bar to customize your view. Home, Explorer, Browse data, Dashboards, and Alerts & AI are fixed, but you can favorite up to six more elements to display on the bar as well. The rest will go on the More group. Navigation shortcuts are a faster way to find entities and apps that are relevant to you. Mouse over any menu item for quick access to your favorite entities, those you recently visited, or just to search without having to navigate to a specific section. If you click on an entity, you can choose to open it in the same browser tab or in a new one. Light and dark mode See Light and dark mode. Search accounts and entities Access Quick find clicking the button, near the top right of the New Relic One UI. Some details about your search: You can search across all accounts that you have been granted access to in your organization. For more about account access, see Factors affecting access. Entities that cease to exist are available in search for eight days. If your organization has multiple accounts, use the account picker at the top left corner to select accounts. Chart and query features You can add most charts to a new or existing dashboard. Here are some query and chart features available across all or most of the platform: If you want to... Do this... Start querying your data Mouse over Browse data and select metrics, events, logs, or traces for a direct access to any of those types of data. Also, at the top of any UI page, select Query your data to access the data explorer and query builder. View a chart's query For some charts, you can view the NRQL query used to generate that chart. This can help you understand a chart better or use it as the basis for a new query. Choose time range Drag across a section of a chart to zoom in on that time range. Or, use the time picker in the top right corner of the UI to select pre-set time ranges or set a custom one. View chart details Mouse over a chart to see a pop-up with more detail. For some charts, selecting a point on the chart will take you to a UI page with more information about that metric. Hide or return chart elements To hide or unhide a displayed chart element, select that element's name below the chart. The chart display will adjust to reflect the absence or presence of that element. Share New Relic views with others Here are some options for sharing New Relic UI pages and visualizations. If you want to... Do this... Share UI pages and dashboards To share an entire New Relic UI page, click Share near the top of the UI to copy the URL. Share charts If New Relic charts are built with NRQL queries, they have a menu that exposes various options, including sharing options like Get as image and Get chart link. Some notes about sharing: The person you share with may not have access to view the data from that account. To solve that, someone on your team with New Relic user management abilities must add that person to the account. If someone can't access a custom dashboard, it may be that it is set to private. Read more about dashboard permissions. Some sharing options have associated time ranges, which may impact later viewings of it. For example, if you use a chart's Get chart link option and that chart is set to 'Last 30 minutes', when viewed it will show the last 30 minutes, not the time range displayed when it was shared. To share a specific time range, you must select that time range in the UI. Account and user settings To find account settings and user preferences, use the account dropdown, located at the top right of the UI, beside your user name. Other UI experiences This has been a look at a few basic platform UI experiences. For more about the UI, search for docs related to the specific New Relic solution you're using.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.61227,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Basic platform <em>UI</em>: search, share, chart <em>UI</em>, customize navigation, <em>and</em> more",
        "sections": "Share <em>New</em> <em>Relic</em> views with others",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> has some basic <em>UI</em> functions that are widely available across the platform. Understanding these features will help you find and analyze your <em>data</em> more easily. Observe your platform <em>New</em> <em>Relic</em> <em>One</em> gives you full access to the <em>data</em> from all the entities in your stack. Go to the <em>New</em> <em>Relic</em>"
      },
      "id": "603ec1f964441f5b0e4e8860"
    },
    {
      "sections": [
        "New Relic feature end of life announcements July 2020",
        "Old Kubernetes integration agent versions",
        "Monitor listing page and Synthetic labels",
        "\"Rollup by\" in Synthetics",
        "Embedded charts",
        "Legacy distributed tracing UI",
        "Violations changes",
        "Connected agents page",
        "Inactive apps in New Relic One",
        "Synthetic monitor alert notifications and conditions"
      ],
      "title": "New Relic feature end of life announcements July 2020",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "1db1d6b3df6d5ac3b983f78f3264cab332cff05a",
      "image": "https://docs.newrelic.com/static/f2b139d12bd8cdc13a9907b7874a4452/0a867/nrone-embed-bb062520.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/new-relic-feature-end-life-announcements-july-2020/",
      "published_at": "2021-09-14T10:10:35Z",
      "updated_at": "2021-07-22T05:05:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In order to improve your New Relic experience we've made some big improvements to our platform. As a result, we'll be ending support for some old features over the next few weeks. Many have already been publicly announced as \"end-of-life.\" These changes represent our commitment to improve your interactions with our platform. Our mission is one observability platform that unites your telemetry data, connects your full stack, and helps you build more perfect software. To that end we're focusing on simplifying your experience for troubleshooting, alerting, and visualizing data. Here are more details on what's changed, with some helpful links and guides on how to take advantage of new capabilities to achieve the same goals. As always, we're here to help. Please connect with us in the Explorers Hub, or contact your account team with any questions. Old Kubernetes integration agent versions To improve our unified experience, starting from Wednesday, August 12, 2020, Kubernetes integrations that use v1.7 or older will be deprecated. The UI experience in the infrastructure.newrelic.com domain will no longer be available; it will only be available in New Relic One. If you are already using the latest Kubernetes agent version, no action is necessary. If you are using v1.7 or older, you must update your integration in order to continue viewing Kubernetes performance data. Follow the instructions in our documentation to upgrade to the latest version of the Kubernetes integration. Action items for a successful transition: Review the Kubernetes agent deprecation notice. Follow standard procedures to upgrade your Kubernetes agent to the latest version. Learn about the Kubernetes cluster explorer UI in New Relic One. For more information, see the Explorers Hub post. Monitor listing page and Synthetic labels To improve the experience of Synthetic monitors and labels, we've moved both experiences into the New Relic One platform. If you use the REST API for Synthetic label management, you must update to the tags API moving forward. The good news: with the NerdGraph tags API, you can organize and group all your entities in a single request. For more information about any of the following, see the Explorers Hub post. Action items for a successful transition: Synthetic monitors transition Comments Monitor index list When migration is completed, no action is needed on your part to use the new Synthetics entity listing pages. The new experience will be available to you automatically after July 20, 2020. For more information, learn how the explorer in New Relic One replaces the Synthetics monitors index. Existing Synthetics labels You may have already seen an option in the UI to migrate your Synthetics monitor labels to New Relic One tags. If you did not select that option, we've got you covered. Automatic migration from labels to tags starts begins July 8, 2020. For more information, learn how tagging in New Relic One replaces labels for Synthetics monitors. REST API If you use the REST API for Synthetics label management, follow these steps to update to the tags API: Learn more about NerdGraph. Review the NerdGraph tagging API tutorial. Make sure you have a Personal API key to use NerdGraph. Follow the procedures in the Explorers Hub post (look for the How do I transition my scripts from the Synthetics API to the tag API (NerdGraph)? section), and update your existing tags with the GraphiQL explorer at api.newrelic.com/graphiql. NerdGraph is our GraphQL API, a query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time. \"Rollup by\" in Synthetics Synthetics is moving to New Relic One to provide a single platform for observability of your complex software systems. To do this we are unifying the tools you use to tag (or label) your services, applications, and monitors. The specific feature that is end-of-life is the Rollup by feature under the Search monitors dropdown menu. You can group monitors by tags in New Relic One without needing a separate Rollup by dropdown. No changes will be required to use the new Synthetic monitor listing pages. The new experiences will be available to you after July 20, 2020. Documentation: Tagging in New Relic One replaces labels for Synthetics monitors. Explorer in New Relic One replaces Synthetics monitors index. Action items for a successful transition: If you currently use Synthetics rollups: Follow the procedures in the Explorer Hub post to recreate the rollups that are being retired. Go to the Explorers Hub post about the rollups EOL. In particular, look for How can New Relic Workloads help me visualize groups of applications and monitors? in the post's FAQs section. Follow the procedures in the Explorers Hub post to recreate the rollups that are being retired. Embedded charts In order to reduce redundancy and provide a more unified experience, the embedded charts functionality will be replaced by the New Relic One Get chart. Embedded charts currently in use and hosted outside the New Relic domain will continue to function. The changes will include: The name on the chart's menu that generates them will change from Embed to Get chart link. For charts that are no longer supported, Embed will be replaced with Get chart link is not supported for this chart. The APM UI page that lists all embedded chart links will no longer be available. Documentation: Explorers Hub post New Relic One's enhanced query builder functionality replaces the EOL embed chart functionality. Action items for a successful transition: You can generate a publicly accessible link to add to internal and external websites. Users do not need to be logged in to New Relic to see the chart link. The ability to embed a chart will remain, but instead of clicking Embed (which will be removed from the UI), you will click Get chart link (which is in the same location). This gives you the ability to get links with an even broader range of chart visuals and behaviors than the one we are retiring. Here's an example of how it looks in New Relic One: To replace existing chart links you created with Embed, create new URLs with New Relic One's Get chart link, and insert them in webpages where they're used. If you have an embedded chart and get the message Get chart link is not supported for this chart, simply run a different query, select an available chart type, and then select Embed. Legacy distributed tracing UI To standardize our user experience, we will be deprecating the older distributed tracing UI, which exists within the rpm.newrelic.com domain. You can access distributed tracing through New Relic One, which provides a superior experience with all the functionality supported in the duplicate UI that is end-of-life. Documentation: Global and service-specific distributed tracing views in New Relic One Deprecated distributed tracing UI Action items for a successful transition: No action required, but you can get ready for the new UI experience. New Relic One's distributed tracing page builds on capabilities you are already familiar with. Get acquainted with the enhanced distributed tracing features in New Relic One, including search and filter capabilities with cross-account trace details, query options with the NerdGraph API, and histogram charts (which can help you quickly understand trace distribution for important values such as duration). Review the trace sampling options available with head-based sampling (standard distributed tracing) and tail-based sampling (Infinite Tracing). Violations changes In order to provide a unified experience, we're deprecating browser, mobile, and synthetics monitor violations and replacing them with the New Relic One equivalent. New Relic One users can access violations by using any of these options: Click the Alerts and AI link in New Relic One's main UI. Review the entity list activity stream. See alert details from inside a specific entity via the new indicator for Operational, Warning, and Critical violations. You will see alert details automatically when navigating to one.newrelic.com. Documentation: Applied Intelligence and alerting in New Relic One Browser alert violations (moving to New Relic One) Mobile violations (moving to New Relic One) Monitor violations (moving to New Relic One) Action items for a successful transition: No action required, but you can get ready for the new UI experience. Here's an example of the detailed information about an Alerts violation for a selected entity in New Relic One. Violation details in New Relic One Comments Holistic view From New Relic One's homepage, the entity list presents an activity stream of all entities with alert violations. You no longer need to jump around individual lists of end-user, mobile, or monitor violations. Enhanced troubleshooting tools From New Relic One's homepage, you will also see an Alerts & AI (Applied Intelligence) link. From here you can solve problems faster with anomaly detection, incident correlation, and noise reduction. Specific violation From a selected entity, you will see a new button identifying the violation as Operational, Warning, or Critical, as well as entity metadata and useful details about the incident. Connected agents page Finding your connected agents has never been easier! You can already do this via the Query your data link in New Relic One. Simply run these NrDailyUsage queries to get a list of connected agents and hosts. The old Connected agents page is end-of-life and will be removed. Documentation: Explorers Hub post NRQL query tools NrDailyUsage data definition Action items for a successful transition: To query your connected apps and hosts, you can use existing NRQL query tools, such as New Relic One's query builder or the GraphQL API. Recommendation: For best results exploring comprehensive data about your apps and hosts, use the query builder in New Relic One or the NerdGraph API. Inactive apps in New Relic One Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI. However, key metrics will continue to be available via the New Relic REST API based on subscription level. This is why the application name will remain reserved until the application is permanently deleted via the REST API Explorer. Action items for a successful transition: If you want to reuse an app name for an old app that is no longer reporting data: Use the REST API v2 or API Explorer to get summary data, including app ID, name, health status (look for gray), last reported, etc. Uninstall the agent for your app. Use the REST API or API Explorer to delete the apps. Synthetic monitor alert notifications and conditions In order to provide a unified experience, we're deprecating Synthetics monitor alert notifications and condition violations. We are replacing these pages with a new Synthetics monitor overview experience in New Relic One. This new experience provides visibility into a monitor's open violations and alert conditions with the monitor results in a single view, removing the need to open multiple tabs to view violations or alert conditions. Action items for a successful transition: No action required, but you can get ready for the new UI experience by reviewing our documentation about New Relic Applied Intelligence, which includes: The alerting functionality you are already familiar with in New Relic Alerts, and more Incident Intelligence, which reduces noise and accelerates your incident resolution process Proactive Detection, which surfaces relevant issues and provides automatic explanations to their cause",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.82275,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> feature end of life announcements July 2020",
        "sections": "Inactive apps in <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " To improve our unified experience, starting from Wednesday, August 12, 2020, Kubernetes integrations that <em>use</em> v1.7 or older will be deprecated. The <em>UI</em> experience in the infrastructure.newrelic.com domain will no longer be available; it will only be available in <em>New</em> <em>Relic</em> <em>One</em>. If you are already using"
      },
      "id": "603e795364441ff1924e8872"
    },
    {
      "sections": [
        "Metric normalization rules",
        "Metric normalization rules management"
      ],
      "title": "Metric normalization rules",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "3c55e4717f145ac7ae0d88e860878f4e8d18cd6b",
      "image": "https://docs.newrelic.com/static/83edfb6f5b1b68712cac34d138bb8cb8/3996e/create-new-rule-window.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/metric-normalization-rules/",
      "published_at": "2021-09-14T10:10:37Z",
      "updated_at": "2021-03-29T20:39:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There may be cases where an application sends many individual metrics that could be better managed in groups. Most of these occur with web transactions metrics named from URLs. For more information on this issue, see Metric grouping issues (MGIs). To reduce high cardinality and prevent metric grouping issues, New Relic supports rules for grouping or filtering out metrics (normalization). In some cases, when MGIs with a significant high number of metrics are detected, a rule is created automatically to protect the platform from performance degradation. Metric normalization rules management You can create and manage new rules that deal with the noise produced from high cardinality metrics by using the metric normalization tool, which is accessible from each service dashboard in the New Relic Explorer. Once there, select Metric Normalization in the left sidebar. There you can see the existing rules or create new ones. Click a rule to modify it, or click Create a new rule to create a new one. A new pane to configure the rule will be displayed. Available fields are: Match expression: enter the regular expression to group all the metrics you want to include in the rule. Matches: here you will see a preview of the metrics matched by the regular expression above. Action: the action you want to perform on the metrics. Replace: replace the matched metrics by the regular expression with the value described in the Replacement field. Ignore: ignore any metric that matches the regular expression. Deny new metrics: only write metrics that have already been reported, and ignore those that match the regular expression. Replacement: only active when Replace is enabled. Matched metrics are replaced with the field's value. If the regular expression is capturing groups, you can use placeholders for them with \\1 or \\2 for the groups 1 and 2 respectively. Active: rules can’t be deleted, but can be deactivated. Click the toggle to enable or disable the rule. If you want the rule to be removed, reach out to New Relic's support. Notes: internal notes on the rule. Has no effect on the rule. Once you have set up the fields, click Create (or Edit in case you are editing an existing rule), and the rule will be applied immediately as long as it's Active.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.68855,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " grouping issues, <em>New</em> <em>Relic</em> supports rules for grouping or filtering out metrics (normalization). In some cases, when MGIs with a significant high number of metrics are detected, a rule is created automatically to protect the platform from performance degradation. Metric normalization rules management You"
      },
      "id": "603e810b64441ff3a74e8862"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/ui-data/maps-in-context": [
    {
      "sections": [
        "Map page for mobile apps (deprecated)",
        "Important",
        "View a map of your mobile app services"
      ],
      "title": "Map page for mobile apps (deprecated)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "a082467948ce481c9ecb544d26a802e8d5f3894b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/map-page-mobile-apps-deprecated/",
      "published_at": "2021-09-14T20:45:24Z",
      "updated_at": "2021-09-14T20:45:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important The mobile Maps UI is deprecated since December 22, 2020. Service maps are available in New Relic One's left navigation for each mobile entity, and they are a better way to visualize and customize representations of your architecture. For more information, see our Explorers Hub post. Maps help you find performance problems for a mobile app or its services. This gives you a clear picture of your app's relationships to other services and the influence of each service on the others. If one service fails, you can see at a glance which other services are affected. View a map of your mobile app services To view your mobile app and its related services as an architectural map, go to one.newrelic.com > Mobile > (select a mobile app) > Monitor > Service map. For more information, see the service maps documentation. If you need to use the deprecated mobile Map page, follow these steps: Go to one.newrelic.com > Mobile > (select an app) > Network > Map. To view HTTP request details for a service, select its name. To view details for an app monitored by APM that is related to the service, select the service's name below the associated hostname. To view throughput details as a chart, select the icon or the cpm bar below the service's name. To view detailed metrics for a service, mouse over the throughput chart. The Map page for mobile monitoring gives an architectural view of your mobile app and the services it uses,",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 231.33026,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Map</em> page for mobile apps (deprecated)",
        "sections": "<em>Map</em> page for mobile apps (deprecated)",
        "body": "Important The mobile <em>Maps</em> UI is deprecated since December 22, 2020. Service <em>maps</em> are available in New Relic One&#x27;s left navigation for each mobile <em>entity</em>, and they are a better way to visualize and customize representations of your architecture. For more information, see our Explorers Hub post. <em>Maps</em>"
      },
      "id": "6044141828ccbc0f862c60ae"
    },
    {
      "sections": [
        "NerdGraph tutorial: Understand entity relationships and dependencies",
        "Relationship types",
        "Read relationships of an entity"
      ],
      "title": "NerdGraph tutorial: Understand entity relationships and dependencies",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "3699777ea1a7bf17213ccdaad3b44793e1561948",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-relationships-api-tutorial/",
      "published_at": "2021-09-13T18:35:07Z",
      "updated_at": "2021-09-02T03:46:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "One way to understand how your entities relate to each other is using our NerdGraph API. You can use the relatedEntities field to see how pairs of entities interact and how they're related. This can help troubleshoot upstream and downstream services and understand how minor issues may have larger repercussions, similar to how service maps can be used. To learn general information about entities, their relationships, and how to use them, see Entities. Relationship types Relationship types provide additional information about how two entities are related. The supported relationship types are: Type Description CALLS The relationship between one service or application calling another. Used to display upstream and downstream services. CONTAINS The relationship and hierarchical use cases common to modern and cloud infrastructure. For example, this could indicate that the HOST contains a container. HOSTS The relationship between an application or process and the system it runs on. SERVES The relationship between a back-end application and the browser application it returns in the response. is The relationship between an entity captured as a separate entity by another telemetry data source in addition to the one you are currently viewing. Read relationships of an entity You can use NerdGraph to return the relationships between your monitored entities. The following example shows how to query an entity by its specific GUID, using the NerdGraph GraphiQL explorer. For more information, see Use NerdGraph to query entities. query{ actor{ entity(guid: YOUR_ENTITY_GUID){ name relatedEntities { results { source { entity { guid name } } target { entity { guid name } } type } } } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.21785,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NerdGraph tutorial: Understand <em>entity</em> <em>relationships</em> and dependencies",
        "sections": "NerdGraph tutorial: Understand <em>entity</em> <em>relationships</em> and dependencies",
        "body": " repercussions, similar to how service <em>maps</em> can be used. To learn general information about entities, their <em>relationships</em>, and how to use them, see Entities. <em>Relationship</em> types <em>Relationship</em> types provide additional information about how two entities are related. The supported <em>relationship</em> types"
      },
      "id": "603ec1c664441fb7ff4e8852"
    },
    {
      "sections": [
        "How to use service maps",
        "Requirements",
        "Minimum versions when distributed tracing is enabled",
        "Minimum versions when distributed tracing is NOT enabled",
        "Add or remove connections to an entity",
        "Color coded for alerts",
        "Understand dependencies using API",
        "Externals and databases in maps",
        "Missing nodes"
      ],
      "title": "How to use service maps",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Understand system dependencies",
        "Service maps"
      ],
      "external_id": "edc5ecde0c7ac8348afbcc6b82de546b0b60d349",
      "image": "",
      "url": "https://docs.newrelic.com/docs/understand-dependencies/understand-system-dependencies/service-maps/how-use-service-maps/",
      "published_at": "2021-09-14T07:17:02Z",
      "updated_at": "2021-08-21T10:54:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here is information about how to use the current service maps feature. For help using the earlier service maps feature, see Legacy APM service maps. Service maps helps you visualize dependencies quickly and easily across your environment. They help you see how all your entities work together across your system. You can use service maps to troubleshoot problems, see how your environment works together, and ensure that issues don’t have downstream repercussions. Service maps also supports cross-account access so help you see relationships between entities for all your accounts. Requirements Service maps work with distributed tracing to connect relationships between entities. Service maps are still functional if you have not enabled distributed tracing, but we recommend having distributed tracing enabled for all agents. This ensures a more consistent experience while using service maps. For best results, update existing agents to the latest version. The required minimum agent versions for maps are: Minimum versions when distributed tracing is enabled The required minimum agent versions for maps using distributed tracing are: C SDK 1.1.0 or higher Go agent 2.1.0 or higher Java agent 4.3.0 or higher .NET agent 8.6.45.0 or higher Node.js agent 4.7.0 or higher PHP agent 8.4 or higher Python agent 4.2.0.100 or higher Ruby agent 5.3.0.346 or higher Minimum versions when distributed tracing is NOT enabled The minimum version requirements for maps not using distributed tracing are: C SDK: not available Go 1.11 or higher Java 3.9.0 or higher .NET 4.2 or higher Node.js 2.0.0 or higher PHP 4.19.0 or higher Python 2.38.0.31 or higher Ruby 4.3.0 or higher Add or remove connections to an entity To view service maps, from one.newrelic.com click Explorer. Once you select an entity to view, you can select service maps from the sidebar. The map shows your upstream and downstream services: entities toward the left are upstream, entities toward the right are downstream. To add or remove connections to an entity: Hover over the entity in the map that you want to alter. Click add or remove more connections. In the connection list, keep boxes checked for the entities that you want to appear in the map. Unchecked entities will be removed from the map. Color coded for alerts Each entity in a map displays a color dependent on its performance. Green: there are currently no violations for this entities performance. Yellow: there is an open warning violation for this entity. Red: there is an open critical violation for this entity. Gray: no alert conditions have been set for the entity White: agent not reporting. This means that the agent installed on the entity is not reporting any data. This is expected behavior for databases or externals. Understand dependencies using API You can discover the same relationship connections available in service maps with NerdGraph. For more information and examples, see the NerdGraph GraphiQL relationships API tutorial. Externals and databases in maps In the New Relic UI, your out-of-process services are referred to as web external or background external data. Externals and databases have slightly different features in service maps than other entity types: Unlike other entities that appear in service maps, externals are aggregates. Clicking on an external service in the map shows you the list of all the external services that are rolled up into the one external entity. This is to reduce map clutter, as some entities can have dozens of externals being reported. Databases are agentless. Because of this, alerts cannot be set for the database, as only see the service call is reported to New Relic. Missing nodes If you are unable to view certain entities in New Relic One service maps, see Troubleshooting: Missing or obfuscated data in New Relic One.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 165.20697,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "How to use service <em>maps</em>",
        "sections": "Externals and databases <em>in</em> <em>maps</em>",
        "tags": "Service <em>maps</em>",
        "body": " to view, you can select service <em>maps</em> from the sidebar. The <em>map</em> shows your upstream and downstream services: entities toward the left are upstream, entities toward the right are downstream. To add or remove connections to an <em>entity</em>: Hover over the <em>entity</em> in the <em>map</em> that you want to alter. Click add"
      },
      "id": "603ec23264441fb02c4e8893"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/ui-data/metric-normalization-rules": [
    {
      "sections": [
        "Dependencies UI: View an entity's upstream and downstream dependencies",
        "Requirements",
        "View dependencies"
      ],
      "title": "Dependencies UI: View an entity's upstream and downstream dependencies",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "2b2f328a6281bb155bcde07efec7f42eae943048",
      "image": "https://docs.newrelic.com/static/aabc5f64a91cc01b6e226df53c62458f/c1b63/new-relic-one-dependencies-UI.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/explore-downstream-dependencies-new-relic-one/",
      "published_at": "2021-09-14T10:09:26Z",
      "updated_at": "2021-08-21T09:29:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the New Relic Explorer, an entity's Dependencies page shows a filterable list of all the applications, services, databases, and hosts connected to the entity. It shows upstream and downstream dependencies, and provides paths to explore them. Similar to service maps, the dependencies page helps you understand how all of your upstream and downstream services are connected. It also uses the same color coding system used by service maps to show you what's performing well and what isn't. Requirements To view an entity's dependencies, make sure your app uses the minimum required APM agent version: C 1.0.0 or higher Go 1.11 or higher Java 3.9.0 or higher .NET 4.2 or higher Node.js 2.0.0 or higher PHP 4.19.0 or higher Python 2.38.0.31 or higher Ruby 4.3.0 or higher View dependencies To view dependencies for applications, services, databases, and hosts connected to an entity: Go to one.newrelic.com, select Explorer, and select an entity. Select Dependencies. To drill down further, filter the apps, services, databases, or hosts. one.newrelic.com > Explorer > (select an entity) > Dependencies: View a filterable list of all the apps, services, databases, and hosts connected to an entity, and their color-coded health status. You can filter the dependencies page to view specific things that report to the entity. Dependencies include: Services: APM-monitored applications and services. Mobile applications: your mobile apps. Browser applications: your front-end browser apps. External services: external services monitored by APM. External services include out-of-process services such as web services, resources in the cloud, and any other network calls. Databases: your application's database and cache data. Databases are agentless. Because of this, alerts cannot be set for the database, as only the service call is reported to New Relic. Hosts: your infrastructure (servers and hosts).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.61226,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Dependencies <em>UI</em>: View an entity&#x27;s upstream <em>and</em> downstream dependencies",
        "sections": "Dependencies <em>UI</em>: View an entity&#x27;s upstream <em>and</em> downstream dependencies",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " services: external services monitored by APM. External services include out-of-process services such as web services, resources in the cloud, and any other network calls. Databases: your application&#x27;s database and cache <em>data</em>. Databases are agentless. Because of this, alerts cannot be set for the database, as only the service call is reported to <em>New</em> <em>Relic</em>. Hosts: your infrastructure (servers and hosts)."
      },
      "id": "603eb2e564441f0fe44e889b"
    },
    {
      "sections": [
        "Basic platform UI: search, share, chart UI, customize navigation, and more",
        "Observe your platform",
        "Customize the navigation bar and shortcuts",
        "Light and dark mode",
        "Search accounts and entities",
        "Chart and query features",
        "Share New Relic views with others",
        "Account and user settings",
        "Other UI experiences"
      ],
      "title": "Basic platform UI: search, share, chart UI, customize navigation, and more",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "b3cdcfc60a2821dfa5bee9766aba483cc3389398",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-09-14T10:08:22Z",
      "updated_at": "2021-08-21T09:29:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One has some basic UI functions that are widely available across the platform. Understanding these features will help you find and analyze your data more easily. Observe your platform New Relic One gives you full access to the data from all the entities in your stack. Go to the New Relic Explorer at one.newrelic.com to see a full list of entities, identify overall behaviors, filter them to locate sources of performance issues, or plan improvements for your system. Customize the navigation bar and shortcuts Select the edit icon at the right end of the navigation bar to customize your view. Home, Explorer, Browse data, Dashboards, and Alerts & AI are fixed, but you can favorite up to six more elements to display on the bar as well. The rest will go on the More group. Navigation shortcuts are a faster way to find entities and apps that are relevant to you. Mouse over any menu item for quick access to your favorite entities, those you recently visited, or just to search without having to navigate to a specific section. If you click on an entity, you can choose to open it in the same browser tab or in a new one. Light and dark mode See Light and dark mode. Search accounts and entities Access Quick find clicking the button, near the top right of the New Relic One UI. Some details about your search: You can search across all accounts that you have been granted access to in your organization. For more about account access, see Factors affecting access. Entities that cease to exist are available in search for eight days. If your organization has multiple accounts, use the account picker at the top left corner to select accounts. Chart and query features You can add most charts to a new or existing dashboard. Here are some query and chart features available across all or most of the platform: If you want to... Do this... Start querying your data Mouse over Browse data and select metrics, events, logs, or traces for a direct access to any of those types of data. Also, at the top of any UI page, select Query your data to access the data explorer and query builder. View a chart's query For some charts, you can view the NRQL query used to generate that chart. This can help you understand a chart better or use it as the basis for a new query. Choose time range Drag across a section of a chart to zoom in on that time range. Or, use the time picker in the top right corner of the UI to select pre-set time ranges or set a custom one. View chart details Mouse over a chart to see a pop-up with more detail. For some charts, selecting a point on the chart will take you to a UI page with more information about that metric. Hide or return chart elements To hide or unhide a displayed chart element, select that element's name below the chart. The chart display will adjust to reflect the absence or presence of that element. Share New Relic views with others Here are some options for sharing New Relic UI pages and visualizations. If you want to... Do this... Share UI pages and dashboards To share an entire New Relic UI page, click Share near the top of the UI to copy the URL. Share charts If New Relic charts are built with NRQL queries, they have a menu that exposes various options, including sharing options like Get as image and Get chart link. Some notes about sharing: The person you share with may not have access to view the data from that account. To solve that, someone on your team with New Relic user management abilities must add that person to the account. If someone can't access a custom dashboard, it may be that it is set to private. Read more about dashboard permissions. Some sharing options have associated time ranges, which may impact later viewings of it. For example, if you use a chart's Get chart link option and that chart is set to 'Last 30 minutes', when viewed it will show the last 30 minutes, not the time range displayed when it was shared. To share a specific time range, you must select that time range in the UI. Account and user settings To find account settings and user preferences, use the account dropdown, located at the top right of the UI, beside your user name. Other UI experiences This has been a look at a few basic platform UI experiences. For more about the UI, search for docs related to the specific New Relic solution you're using.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.61226,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Basic platform <em>UI</em>: search, share, chart <em>UI</em>, customize navigation, <em>and</em> more",
        "sections": "Share <em>New</em> <em>Relic</em> views with others",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> has some basic <em>UI</em> functions that are widely available across the platform. Understanding these features will help you find and analyze your <em>data</em> more easily. Observe your platform <em>New</em> <em>Relic</em> <em>One</em> gives you full access to the <em>data</em> from all the entities in your stack. Go to the <em>New</em> <em>Relic</em>"
      },
      "id": "603ec1f964441f5b0e4e8860"
    },
    {
      "sections": [
        "New Relic feature end of life announcements July 2020",
        "Old Kubernetes integration agent versions",
        "Monitor listing page and Synthetic labels",
        "\"Rollup by\" in Synthetics",
        "Embedded charts",
        "Legacy distributed tracing UI",
        "Violations changes",
        "Connected agents page",
        "Inactive apps in New Relic One",
        "Synthetic monitor alert notifications and conditions"
      ],
      "title": "New Relic feature end of life announcements July 2020",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "1db1d6b3df6d5ac3b983f78f3264cab332cff05a",
      "image": "https://docs.newrelic.com/static/f2b139d12bd8cdc13a9907b7874a4452/0a867/nrone-embed-bb062520.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/new-relic-feature-end-life-announcements-july-2020/",
      "published_at": "2021-09-14T10:10:35Z",
      "updated_at": "2021-07-22T05:05:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In order to improve your New Relic experience we've made some big improvements to our platform. As a result, we'll be ending support for some old features over the next few weeks. Many have already been publicly announced as \"end-of-life.\" These changes represent our commitment to improve your interactions with our platform. Our mission is one observability platform that unites your telemetry data, connects your full stack, and helps you build more perfect software. To that end we're focusing on simplifying your experience for troubleshooting, alerting, and visualizing data. Here are more details on what's changed, with some helpful links and guides on how to take advantage of new capabilities to achieve the same goals. As always, we're here to help. Please connect with us in the Explorers Hub, or contact your account team with any questions. Old Kubernetes integration agent versions To improve our unified experience, starting from Wednesday, August 12, 2020, Kubernetes integrations that use v1.7 or older will be deprecated. The UI experience in the infrastructure.newrelic.com domain will no longer be available; it will only be available in New Relic One. If you are already using the latest Kubernetes agent version, no action is necessary. If you are using v1.7 or older, you must update your integration in order to continue viewing Kubernetes performance data. Follow the instructions in our documentation to upgrade to the latest version of the Kubernetes integration. Action items for a successful transition: Review the Kubernetes agent deprecation notice. Follow standard procedures to upgrade your Kubernetes agent to the latest version. Learn about the Kubernetes cluster explorer UI in New Relic One. For more information, see the Explorers Hub post. Monitor listing page and Synthetic labels To improve the experience of Synthetic monitors and labels, we've moved both experiences into the New Relic One platform. If you use the REST API for Synthetic label management, you must update to the tags API moving forward. The good news: with the NerdGraph tags API, you can organize and group all your entities in a single request. For more information about any of the following, see the Explorers Hub post. Action items for a successful transition: Synthetic monitors transition Comments Monitor index list When migration is completed, no action is needed on your part to use the new Synthetics entity listing pages. The new experience will be available to you automatically after July 20, 2020. For more information, learn how the explorer in New Relic One replaces the Synthetics monitors index. Existing Synthetics labels You may have already seen an option in the UI to migrate your Synthetics monitor labels to New Relic One tags. If you did not select that option, we've got you covered. Automatic migration from labels to tags starts begins July 8, 2020. For more information, learn how tagging in New Relic One replaces labels for Synthetics monitors. REST API If you use the REST API for Synthetics label management, follow these steps to update to the tags API: Learn more about NerdGraph. Review the NerdGraph tagging API tutorial. Make sure you have a Personal API key to use NerdGraph. Follow the procedures in the Explorers Hub post (look for the How do I transition my scripts from the Synthetics API to the tag API (NerdGraph)? section), and update your existing tags with the GraphiQL explorer at api.newrelic.com/graphiql. NerdGraph is our GraphQL API, a query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time. \"Rollup by\" in Synthetics Synthetics is moving to New Relic One to provide a single platform for observability of your complex software systems. To do this we are unifying the tools you use to tag (or label) your services, applications, and monitors. The specific feature that is end-of-life is the Rollup by feature under the Search monitors dropdown menu. You can group monitors by tags in New Relic One without needing a separate Rollup by dropdown. No changes will be required to use the new Synthetic monitor listing pages. The new experiences will be available to you after July 20, 2020. Documentation: Tagging in New Relic One replaces labels for Synthetics monitors. Explorer in New Relic One replaces Synthetics monitors index. Action items for a successful transition: If you currently use Synthetics rollups: Follow the procedures in the Explorer Hub post to recreate the rollups that are being retired. Go to the Explorers Hub post about the rollups EOL. In particular, look for How can New Relic Workloads help me visualize groups of applications and monitors? in the post's FAQs section. Follow the procedures in the Explorers Hub post to recreate the rollups that are being retired. Embedded charts In order to reduce redundancy and provide a more unified experience, the embedded charts functionality will be replaced by the New Relic One Get chart. Embedded charts currently in use and hosted outside the New Relic domain will continue to function. The changes will include: The name on the chart's menu that generates them will change from Embed to Get chart link. For charts that are no longer supported, Embed will be replaced with Get chart link is not supported for this chart. The APM UI page that lists all embedded chart links will no longer be available. Documentation: Explorers Hub post New Relic One's enhanced query builder functionality replaces the EOL embed chart functionality. Action items for a successful transition: You can generate a publicly accessible link to add to internal and external websites. Users do not need to be logged in to New Relic to see the chart link. The ability to embed a chart will remain, but instead of clicking Embed (which will be removed from the UI), you will click Get chart link (which is in the same location). This gives you the ability to get links with an even broader range of chart visuals and behaviors than the one we are retiring. Here's an example of how it looks in New Relic One: To replace existing chart links you created with Embed, create new URLs with New Relic One's Get chart link, and insert them in webpages where they're used. If you have an embedded chart and get the message Get chart link is not supported for this chart, simply run a different query, select an available chart type, and then select Embed. Legacy distributed tracing UI To standardize our user experience, we will be deprecating the older distributed tracing UI, which exists within the rpm.newrelic.com domain. You can access distributed tracing through New Relic One, which provides a superior experience with all the functionality supported in the duplicate UI that is end-of-life. Documentation: Global and service-specific distributed tracing views in New Relic One Deprecated distributed tracing UI Action items for a successful transition: No action required, but you can get ready for the new UI experience. New Relic One's distributed tracing page builds on capabilities you are already familiar with. Get acquainted with the enhanced distributed tracing features in New Relic One, including search and filter capabilities with cross-account trace details, query options with the NerdGraph API, and histogram charts (which can help you quickly understand trace distribution for important values such as duration). Review the trace sampling options available with head-based sampling (standard distributed tracing) and tail-based sampling (Infinite Tracing). Violations changes In order to provide a unified experience, we're deprecating browser, mobile, and synthetics monitor violations and replacing them with the New Relic One equivalent. New Relic One users can access violations by using any of these options: Click the Alerts and AI link in New Relic One's main UI. Review the entity list activity stream. See alert details from inside a specific entity via the new indicator for Operational, Warning, and Critical violations. You will see alert details automatically when navigating to one.newrelic.com. Documentation: Applied Intelligence and alerting in New Relic One Browser alert violations (moving to New Relic One) Mobile violations (moving to New Relic One) Monitor violations (moving to New Relic One) Action items for a successful transition: No action required, but you can get ready for the new UI experience. Here's an example of the detailed information about an Alerts violation for a selected entity in New Relic One. Violation details in New Relic One Comments Holistic view From New Relic One's homepage, the entity list presents an activity stream of all entities with alert violations. You no longer need to jump around individual lists of end-user, mobile, or monitor violations. Enhanced troubleshooting tools From New Relic One's homepage, you will also see an Alerts & AI (Applied Intelligence) link. From here you can solve problems faster with anomaly detection, incident correlation, and noise reduction. Specific violation From a selected entity, you will see a new button identifying the violation as Operational, Warning, or Critical, as well as entity metadata and useful details about the incident. Connected agents page Finding your connected agents has never been easier! You can already do this via the Query your data link in New Relic One. Simply run these NrDailyUsage queries to get a list of connected agents and hosts. The old Connected agents page is end-of-life and will be removed. Documentation: Explorers Hub post NRQL query tools NrDailyUsage data definition Action items for a successful transition: To query your connected apps and hosts, you can use existing NRQL query tools, such as New Relic One's query builder or the GraphQL API. Recommendation: For best results exploring comprehensive data about your apps and hosts, use the query builder in New Relic One or the NerdGraph API. Inactive apps in New Relic One Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI. However, key metrics will continue to be available via the New Relic REST API based on subscription level. This is why the application name will remain reserved until the application is permanently deleted via the REST API Explorer. Action items for a successful transition: If you want to reuse an app name for an old app that is no longer reporting data: Use the REST API v2 or API Explorer to get summary data, including app ID, name, health status (look for gray), last reported, etc. Uninstall the agent for your app. Use the REST API or API Explorer to delete the apps. Synthetic monitor alert notifications and conditions In order to provide a unified experience, we're deprecating Synthetics monitor alert notifications and condition violations. We are replacing these pages with a new Synthetics monitor overview experience in New Relic One. This new experience provides visibility into a monitor's open violations and alert conditions with the monitor results in a single view, removing the need to open multiple tabs to view violations or alert conditions. Action items for a successful transition: No action required, but you can get ready for the new UI experience by reviewing our documentation about New Relic Applied Intelligence, which includes: The alerting functionality you are already familiar with in New Relic Alerts, and more Incident Intelligence, which reduces noise and accelerates your incident resolution process Proactive Detection, which surfaces relevant issues and provides automatic explanations to their cause",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.82275,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> feature end of life announcements July 2020",
        "sections": "Inactive apps in <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " To improve our unified experience, starting from Wednesday, August 12, 2020, Kubernetes integrations that <em>use</em> v1.7 or older will be deprecated. The <em>UI</em> experience in the infrastructure.newrelic.com domain will no longer be available; it will only be available in <em>New</em> <em>Relic</em> <em>One</em>. If you are already using"
      },
      "id": "603e795364441ff1924e8872"
    }
  ]
}