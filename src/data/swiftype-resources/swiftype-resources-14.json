{
  "/docs/logs/forward-logs/logstash-plugin-log-forwarding": [
    {
      "sections": [
        "AWS Lambda for sending CloudWatch logs",
        "Install and configure the Cloudwatch logs Lambda function",
        "Create a Lambda trigger",
        "Configure retries (optional)",
        "Tip",
        "Resources created by the SAM template",
        "View log data",
        "What's next?"
      ],
      "title": "AWS Lambda for sending CloudWatch logs",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Enable log monitoring in New Relic"
      ],
      "external_id": "69c310375d48a667779ffabead6f920eb6a34004",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/forward-logs/aws-lambda-sending-cloudwatch-logs/",
      "published_at": "2021-12-04T21:55:34Z",
      "updated_at": "2021-12-04T21:55:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can send your Amazon CloudWatch logs to New Relic using our AWS Lambda function, newrelic-log-ingestion. This can be easily deployed from the AWS Serverless application repository. Forwarding your CloudWatch logs to New Relic will give you enhanced log management capabilities to collect, process, explore, query, and alert on your log data. Install and configure the Cloudwatch logs Lambda function The following setup shows one approach for configuring environment variables. You can also configure them from the Functions page. Complete the following: Make sure you have a New Relic license key. Open the AWS Serverless Application Repository in your browser. Search for newrelic and check Show apps that create custom IAM roles or resource policies to find newrelic-log-ingestion. Open the newrelic-log-ingestion details and click Deploy. In the function's Configure menu, go to Environment Variables and configure log forwarding using the following environment variables: Key Description DEBUG_LOGGING_ENABLED A boolean to determine if you want to output debug messages in the CloudWatch console. Optional. To turn on debug logs, set this to true. Default is false. LICENSE_KEY New Relic license key is used for sending data to New Relic. Required. LOGGING_ENABLED Determines if logs are forwarded to New Relic. Required. To turn on logging, set this to true. NR_LOGGING_ENDPOINT New Relic ingestion endpoint for logs. Required. Two endpoints are available: US: https://log-api.newrelic.com/log/v1 EU: https://log-api.eu.newrelic.com/log/v1 NR_TAGS Specify tags to be added to all log events. Optional. Each tag is composed of a colon-delimited key and value. Multiple key-value pairs are semicolon-delimited; for example, env:prod;team:myTeam. Acknowledge that the app creates custom IAM roles, and then click Deploy. Once the process completes, create a Lambda trigger to link your Lambda function to CloudWatch logs. Create a Lambda trigger To get your logs streaming to New Relic, attach a trigger to the Lambda: From the left side menu, select Functions. Find and select the previously created newrelic-log-ingestion function. Under Designer, click Add Triggers, and select Cloudwatch Logs from the dropdown. Select the the appropriate Log group for your application. Enter a name for your filter. Optional: Enter a filter pattern. Check the Enable trigger checkbox, then click Add to create the trigger. Configure retries (optional) You can configure the number of retries you want to perform in case the function fails to send the data in case of communication issues. Recommended number is 3 retries, but you can change the retry behavior by changing the below parameters: Tip The more the number of retries there are can make the function run for longer times. This increases the probability of having higher costs for Lambda. However, decreasing the number of retries could increase the probability of data loss. MAX_RETRIES = 3 # Defines the number of retries after lambda failure to deliver data INITIAL_BACKOFF = 1 # Defines the initial wait seconds until next retry is executed BACKOFF_MULTIPLIER = 2 # Time multiplier between the retries As an example, in default above configuration, first retry will happen after 1 second, second retry after 2 seconds and third retry will happen after 4 seconds. Copy Resources created by the SAM template When you create the application from the repository, the following resources are also created: The Lambda function itself A role used to give execution permissions to the Lambda function based in CloudWatch Logs. All other Lambda configurations not listed can be left as the defaults. View log data If everything is configured correctly and your data is being collected, you should see data logs in both of these places: New Relic Logs UI New Relic tools for running NRQL queries. For example, you can execute a query like this: SELECT * FROM Log Copy If no data appears after you enable our log management capabilities, follow our standard log troubleshooting procedures. What's next? Explore logging data across your platform with the New Relic One UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our logs in context capabilities. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 348.03848,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "AWS Lambda for sending CloudWatch <em>logs</em>",
        "sections": "<em>Install</em> and configure the Cloudwatch <em>logs</em> Lambda function",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": " this: SELECT * FROM <em>Log</em> Copy If no data appears after you <em>enable</em> our <em>log</em> <em>management</em> capabilities, follow our standard <em>log</em> troubleshooting procedures. What&#x27;s next? Explore logging data across your platform with the <em>New</em> <em>Relic</em> One UI. Get deeper visibility into both your application and your platform performance data by forwarding your <em>logs</em> with our <em>logs</em> in context capabilities. Set up alerts. Query your data and create dashboards."
      },
      "id": "603ea6bb28ccbc228deba74c"
    },
    {
      "sections": [
        "Forward your logs using the infrastructure agent",
        "Basic process",
        "System requirements",
        "Important",
        "Install the infrastructure agent",
        "Configure the infrastructure agent",
        "Log forwarding parameters",
        "Name (required)",
        "Log source (required)",
        "file",
        "systemd",
        "syslog",
        "tcp",
        "winlog",
        "Optional configuration",
        "attributes",
        "attributes automatically inserted by the infrastructure agent",
        "pattern",
        "max_line_kb",
        "fluentbit",
        "Sample configuration file",
        "logging.d/sample.yaml",
        "View your log data",
        "Troubleshooting",
        "No log data",
        "No data appears when tailing a file",
        "No data appears when capturing via a Syslog socket",
        "No data appears using infrastructure agent proxy",
        "Sending the infrastructure agent's logs to New Relic",
        "Caution",
        "Fluent Bit does not start with the infra agent",
        "Runtime error on Windows",
        "Errors when tailing a large amount of log files (Linux)",
        "Uninstall log forwarding",
        "What's next?"
      ],
      "title": "Forward your logs using the infrastructure agent",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Enable log monitoring in New Relic"
      ],
      "external_id": "a1deac410f0eedfb819348524a85a73bbb9d9daf",
      "image": "https://docs.newrelic.com/static/63ba6c3dc400e3cc4fb21668d5e7ba2a/c1b63/infrastructure-lic.png",
      "url": "https://docs.newrelic.com/docs/logs/forward-logs/forward-your-logs-using-infrastructure-agent/",
      "published_at": "2021-12-08T01:44:17Z",
      "updated_at": "2021-12-04T13:38:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can forward your logs to New Relic using our infrastructure monitoring agent. This makes all of your logging data available in one location and provides deeper visibility into both your application and your platform performance data. Forwarding your logs to New Relic will give you enhanced log management capabilities to collect, process, explore, query, and alert on your log data. Basic process To forward your logs through our infrastructure monitoring agent: If you haven't already, create a New Relic account. It's free, forever. Verify the system requirements needed for configuring logs. Ensure you have installed the infrastructure agent, version 1.11.4 or higher. Create a logging.yml configuration file in the infrastructure agent's logging.d directory. Configure your log sources and other parameters. Generate some traffic and wait a few minutes, then check your account for data. Explore your log data in the Logs UI and benefit from the log attributes automatically inserted by the infrastructure agent. Here is an example of where you can see logs in context of your infrastructure monitoring details in New Relic One. System requirements To use the log forwarder of the infrastructure agent, make sure you meet the following requirements: Infrastructure agent version 1.11.4 or higher OpenSSL library 1.1.0 or higher is required by Infrastructure agent starting from 1.16.4. Built-in support for ARM64 architecture on Linux systems (in example, AWS Graviton architecture) added in Infrastructure agent 1.26.0. Important The log forwarding feature is not supported with the Docker container for infrastructure monitoring agents. The log forwarding feature is compatible with the following operating systems: Operating system Supported version Amazon Linux Amazon Linux 2 CentOS Version 7 or higher Debian Version 9 (\"Stretch\") or higher Exception: Version 11 is not supported. Red Hat Enterprise Linux (RHEL) Version 7 or higher SUSE Linux Enterprise Server (SLES) Version 12 Ubuntu Versions 16.04.x, 18.04.x and 20.04.x (LTS versions) Windows Windows Server 2012, 2016, and 2019, and their service packs. Windows 10 Install the infrastructure agent Starting with version 1.11.4, the infrastructure agent can forward logs to New Relic. To install and run the agent, use a package manager (Linux) or the MSI installer (Windows). Important The log forwarding feature is not included when the infrastructure agent is implemented using Linux tarball or Windows ZIP installations. To use the following links, make sure you are logged to your New Relic account. Amazon Linux CentOS Debian RHEL SLES Ubuntu Windows If you don't have a New Relic account yet, or if you prefer to follow the procedure manually, see our tutorial to install the package manager. Configure the infrastructure agent Configuration files describe which log sources are forwarded. Our infrastructure agent uses .yml files to configure logging. You can add as many config files as you want. To add a new configuration file for the log forwarding feature: Navigate to the log forwarder configuration folder: Linux: /etc/newrelic-infra/logging.d/ Windows: C:\\Program Files\\New Relic\\newrelic-infra\\logging.d\\ Create a logging.yml configuration file, and add the parameters you need. The logging.d directory has various .yml.example files you can use as a reference or starting point. The agent automatically processes new configuration files without having to restart the infrastructure monitoring service. The only exception to this is when configuring a custom Fluent Bit configuration. Log forwarding parameters The infrastructure log forwarding .yml config supports the following parameters: Name (required) To start, define a name of the log or logs you want to forward to New Relic. Log source (required) What you use for the log source will depend on where you want to forward your logs from. Available options include: file Path to the log file or files. The agent tracks changes on the log files in a way similar to tail -f shell. Example: logs: - name: example-log file: /var/log/example.log # Path to a single log file - name: example-log-two file: /var/log/example-two.log # Path to another single log file Copy The file parameter can point to a specific log file or multiple files by using wildcards applied to names and extensions; for example, /logs/*.log. You can use wildcards in place of directories in a file path, which can be used to tail files located in different directories. Example: logs: - name: docker-logs file: /var/lib/docker/containers/*/*.log # Path to multiple folders and files Copy Important Use of wildcards may significantly increase the number of file descriptors and inotify watches the Fluent Bit process keeps open, which can interfere with log collection if the host's file descriptor limit is reached. Tailing a large number of files may require you to increase the maximum number of file descriptors and inotify watchers allowed by the operating system. Please refer to Errors when tailing a large amount of log files for more details on how to increase them. systemd Use the systemd parameter to forward log messages that are collected by the journald daemon in Linux environments. This input type requires the agent to run in root mode. Example: logs: - name: systemd-example systemd: cupsd Copy syslog Syslog data source. Parameters: uri: Syslog socket. Format varies depending on the protocol: TCP/UDP network sockets: [tcp/udp]://LISTEN_ADDRESS:PORT Unix domain sockets: unix_[tcp/udp]:// + /socket/path parser: Syslog parser. Default is rfc3164. Use rfc5424 if your messages include fractional seconds. Note: rfc3164 currently does not work on SuSE. unix_permissions: default is 0644 for domain sockets; this limits entries to processes running as root. You can use 0666 to listen for non-root processes, at your own risk. When running the agent in privileged mode, ports and sockets must be available or owned by nri-agent, with 0666 file permissions, so that other processes can write logs to the sockets. logs: # TCP network socket - name: syslog-tcp-test syslog: uri: tcp://0.0.0.0:5140 # Use the tcp://LISTEN_ADDRESS:PORT format parser: rfc5424 # Default syslog parser is rfc3164 # UDP network socket - name: syslog-udp-test syslog: uri: udp://0.0.0.0:6140 # Use the udp://LISTEN_ADDRESS:PORT format max_line_kb: 35 # Unix TCP domain socket - name: syslog-unix-tcp-test syslog: uri: unix_tcp:///var/unix-tcp-socket-test unix_permissions: 0666 # Default is 0644. Change at your own risk # Unix UDP domain socket - name: syslog-unix-udp-test syslog: uri: unix_udp:///var/unix-udp-socket-test parser: rfc5424 Copy tcp Logs retrieved over TCP connections. Parameters: uri: TCP/IP socket to listen for incoming data. The URI format is tcp://LISTEN_ADDRESS:PORT format: format of the data. It can be json or none. separator: If format: none is used, you can define a separator string for splitting records (default: \\n). logs: - name: tcp-simple-test tcp: uri: tcp://0.0.0.0:1234 # Use the tcp://LISTEN_ADDRESS:PORT format format: none # Raw text - this is default for 'tcp' separator: \\t # String for separating raw text entries max_line_kb: 32 - name: tcp-json-test tcp: uri: tcp://0.0.0.0:2345 # Use the tcp://LISTEN_ADDRESS:PORT format format: json Copy winlog Collect events from Windows log channels. Parameters: channel: name of the channel logs will be collected from. collect-eventids: a list of Windows Event IDs to be collected and forwarded to New Relic. Event ID ranges are supported. exclude-eventids: a list of Windows Event IDs to be excluded from collection. Event ID ranges are supported. All events are collected from the specified channel by default. Configure the collect-eventids and exclude-eventids sections to avoid sending unwanted logs to your New Relic account. Add event IDs or ranges to collect-eventids or exclude-eventids to forward or drop specific events. exclude-eventids takes precedence over collect-eventids if the same event ID is present in both sections. Example: logs: # Winlog log ingestion with eventId filters. - name: windows-security winlog: channel: Security collect-eventids: - 4624 - 4265 - 4700-4800 exclude-eventids: - 4735 # entries for the application, system, powershell, and SCOM channels - name: windows-application winlog: channel: Application - name: windows-system winlog: channel: System - name: windows-pshell winlog: channel: Windows Powershell - name: scom winlog: channel: Operations Manager # Entry for Windows Defender Logs - name: windows-defender winlog: channel: Microsoft-Windows-Windows Defender/Operational # Entry for Windows Clustering Logs - name: windows-clustering winlog: channel: Microsoft-Windows-FailoverClustering/Operational # Entry for IIS logs with logtype attribute for automatic parsing - name: iis-log file: C:\\inetpub\\logs\\LogFiles\\w3svc.log attributes: logtype: iis_w3c Copy Optional configuration The following configuration parameters are not required but are still recommended. attributes List of custom attributes specified as key-value pairs that can be used to send additional data with the logs which you can then query. The attributes configuration parameter can be used with any log source. One common use of the attributes configuration parameter is to specify the logtype attribute. This attribute allows leveraging one of the built-in parsing rules supported by New Relic Logs. Example: logs: - name: example-file-attributes file: /var/log/example.log attributes: logtype: nginx region: example-us-02 team: A-team - name: example-tcp-attributes tcp: uri: tcp://0.0.0.0:2345 format: json attributes: logtype: nginx region: example-us-02 team: B-team Copy attributes automatically inserted by the infrastructure agent The infrastructure agent automatically inserts log attributes for your convenience. Some of them are inserted for any log record, while others depend on the configuration parameters you used while setting up the log forwarder. Attribute name Description entity.guids Always inserted. The infrastructure agent inserts the Entity GUID assigned by New Relic to identify the host where it's running. It is available in the entity.guids field. Note: If the captured logs belong to an application instrumented using APM, the entity.guids field contains both the entity GUID of infrastructure, as well as the GUID of APM, separated by a pipe ( | ) delimiter. fb.input Always inserted. The underlying Fluent Bit input plugin type used to capture the logs. Currently its values are tail, systemd, winlog, syslog, and tcp. filePath Inserted when sing the file input type. Absolute file path of the file being monitored. hostname Always inserted. The hostname of the machine/VM/container executing the infrastructure agent. plugin.type Always inserted. Indicates the utility used to capture the logs. In this case, it is the infrastructure agent itself, so this attribute always has the value nri-agent. pattern Regular expression for filtering records. Only supported for the tail, systemd, syslog, and tcp (only with format none) sources. This field works in a way similar to grep -E in Unix systems. For example, for a given file being captured, you can filter for records containing either WARN or ERROR using: - name: only-records-with-warn-and-error file: /var/log/logFile.log pattern: WARN|ERROR Copy No filtering is applied by default. max_line_kb Maximum size of log entries/lines in KB. If log entries exceed the limit, they are skipped. Default is 128. fluentbit External Fluent Bit configuration and parser files. If defined, they are merged with the existing configuration and parser files generated by the infrastructure agent. The infrastructure agent processes the configuration files located in the logging.d directory and will generate a run-time Fluent Bit configuration file that contains the appropriate [INPUT], [FILTER] and [OUTPUT] sections. Optionally, it will also declare an @INCLUDE in case you provided an external Fluent Bit configuration file via the fluentbit option. The runtime file does not define a [SERVICE] section, leaving all default Fluent Bit configuration values. You can still override Fluent Bit's default settings by defining your own [SERVICE] section in your external Fluent Bit configuration file and include it via the fluentbit option. Parameters: config_file: path to an existing Fluent Bit configuration file. Note that any overlapping source results in duplicate messages in New Relic Logs. parsers_file: path to an existing Fluent Bit parsers file. The following parser names are reserved: rfc3164, rfc3164-local and rfc5424. Sample configuration file Here is an example of a logging.d/ configuration file in YAML format. For more configuration examples, see the infrastructure agent repository. logging.d/sample.yaml # Remember to only use spaces for indentation logs: # Example of 'file' source - name: file-with-attributes file: /var/log/test.log # Path to a single file or pattern attributes: # You can use custom attributes to enrich your data logtype: nginx team: The A Team pattern: Error # Regular expression to filter log entries # Example of 'systemd' source (Linux only) - name: systemd-example systemd: cupsd # Examples of 'syslog' source, one per protocol # TCP network socket - name: syslog-tcp-test syslog: uri: tcp://0.0.0.0:5140 # Use the tcp://LISTEN_ADDRESS:PORT format parser: rfc5424 # Default syslog parser is rfc3164 # UDP network socket - name: syslog-udp-test syslog: uri: udp://0.0.0.0:6140 # Use the udp://LISTEN_ADDRESS:PORT format max_line_kb: 35 # Paths for Unix sockets are defined by combining protocol and path: # unix_udp:// + /path/socket - for example, unix_udp:///tmp/socket # Unix TCP domain socket - name: syslog-unix-tcp-test syslog: uri: unix_tcp:///var/unix-tcp-socket-test unix_permissions: 0666 # Default is 0644. Change at your own risk # Unix UDP domain socket - name: syslog-unix-udp-test syslog: uri: unix_udp:///var/unix-udp-socket-test parser: rfc5424 # Examples of 'tcp' source for formats 'none' and 'json' - name: tcp-simple-test tcp: uri: tcp://0.0.0.0:1234 # Use the tcp://LISTEN_ADDRESS:PORT format format: none # Raw text - this is default for 'tcp' separator: \\t # String for separating raw text entries attributes: # You can add custom attributes to any source of logs tcpFormat: none someOtherAttribute: associatedValue max_line_kb: 32 - name: tcp-json-test tcp: uri: tcp://0.0.0.0:2345 # Use the tcp://LISTEN_ADDRESS:PORT format format: json attributes: tcpFormat: json yetAnotherAttribute: 12345 # Example of Fluent Bit configuration import - name: fluentbit-import fluentbit: config_file: /path/to/fluentbit.config parsers_file: /path/to/fluentbit/parsers.conf Copy View your log data If everything is configured correctly and your data is being collected, you should see logs data in both of these places: New Relic Logs UI New Relic tools for running NRQL queries. For example, you can execute a query like this: SELECT * FROM Log Copy Troubleshooting If you encounter problems with configuring your log forwarder, try these troubleshooting tips. No log data If no data appears after you enable our log management capabilities, follow our standard log troubleshooting procedures. No data appears when tailing a file The log forwarding feature requires the agent to have permission to read the data sources. When running the infrastructure agent in privileged or non-privileged modes, make sure that the log files you want to forward (and any intermediary directory in its path) are readable by the user running nri-agent. Example: Check file access under Linux Let's check whether the file /var/log/restrictedLogs/logFile.log can be monitored by the nri-agent user. In Linux, you can do a quick check with the namei command: sudo -u nri-agent namei -ml /var/log/restrictedLogs/logFile.log f: /var/log/restrictedLogs/logFile.log drwxr-xr-x root root / drwxr-xr-x root root var drwxrwxr-x root syslog log drwxr--r-- root root restrictedLogs logFile.log - No such file or directory Copy This command failed because the file is not visible to the nri-agent user. By inspecting the previous output, we can detect that the restrictedLogs directory is missing the execution flag for others. To fix this, execute: sudo chmod 755 /var/log/restrictedLogs Copy And then check for file access again: # sudo -u nri-agent namei -ml /var/log/restrictedLogs/logFile.log f: /var/log/restrictedLogs/logFile.log drwxr-xr-x root root / drwxr-xr-x root root var drwxrwxr-x root syslog log drwxr-xr-x root root restrictedLogs -rw-r----- vagrant vagrant logFile.log Copy The file is now visible to the nri-agent user. You must ensure that the file is also readable by the nri-agent user. To check this, use: # sudo -u nri-agent head /var/log/restrictedLogs/logFile.log head: cannot open '/var/log/restrictedLogs/logFile.log' for reading: Permission denied Copy In this example, the file is missing the read rights for the others group (users other than vagrant and the vagrant user group). You could fix this by granting read permissions to others, but the application could change these permissions upon restart. To avoid this, a better approach is to add the nri-agent user to the vagrant user group. No data appears when capturing via a Syslog socket The log forwarding feature requires that the agent has permission to read the data sources. When running the infrastructure agent in privileged or non-privileged modes: If you're using Unix domain socket files, make sure that the nri-agent user can access these files (please refer to the previous section) and that they have read and write permissions (666) so that other users than nri-agent can write to them. If you're using IP sockets, ensure that the port that you are using is not a system reserved one (like port 80, for example). If no data appears after you enable log management, follow standard log management troubleshooting procedures. No data appears using infrastructure agent proxy As explained in the infrastructure agent configuration guidelines, the proxy parameter must use either HTTP or HTTPS and be in the form https://user:password@hostname:port. The agent can parse the parameter without the HTTP or HTTPS, but the log forwarder cannot. You will see an error like the following in the agent verbose logs: [ERROR] building HTTP transport: parse \\\"hostname:port\\\": first path segment in URL cannot contain colon Copy To solve this problem, check your newrelic-infra.yml file, and ensure the proxy parameter adheres to this form. If you're using caBundleFile or caBundleDir in order to specify any certificate, we recommend to follow the below rules for each OS: Linux For HTTP proxies you don't need to setup any certificates. The plugin loads the system certificates and New Relic sends logs into the logging endpoint. However, you can specify the proxy self-signed certificate (PEM file) using either the caBundleFile or caBundleDir parameters. Windows For HTTP proxies you don't need to setup any certificates. The plugin loads the system certificates. For HTTPS, you can configure it in one of the following ways: Import the proxy certificate to the system pool (Recommended) Import the proxy self-signed certificate (PEM file) by using the MMC tool. Refer to this link, and in Step 2 ensure to import it in your Trusted Root Certification Authorities, instead of in the Intermediate Certification Authorities. Using the caBundleFile and caBundleDir parameters On Windows, we cannot load both the certificates from the system certificate pool and the ones specified with the caBundleFile caBundleDir parameters. So, if you are using caBundleFile or caBundleDir, ensure that the following certificates are placed in the same PEM file (when using caBundleFile) or in the same directory (when using caBundleDir): The Proxy certificate (because it's an HTTPS proxy). The Logging Endpoint certificate (eg. https://log-api.newrelic.com/log/v1). The Infrastructure Agent certificate (eg. https://infra-api.newrelic.com). You can check the certificates by running: # openssl s_client -connect log-api.newrelic.com:443 -servername log-api.newrelic.com Copy Sending the infrastructure agent's logs to New Relic You can configure the infrastructure agent to send its own logs to New Relic. This is useful for troubleshooting issues with log forwarding, the agent, or when contacting support. To forward the infrastructure agent logs to New Relic: Edit your newrelic-infra.yml file. Enable agent logging in troubleshooting mode by adding verbose: 3. On Windows and systems that don't use systemd or where journald is inaccessible, verbose:3 causes the agent to write the logs on the disk. Revert to verbose:0 to prevent this. (Recommended): Enable agent logging in JSON format to log_format: json. Restart the agent to load the new settings. This configuration sets up the agent in troubleshooting mode, but the log forwarder (based on Fluent Bit) will continue in a non-verbose mode. Sometimes you can have issues with the log forwarder itself. For example, there may be problems accessing a specific channel when shipping Windows log events or when accessing a particular log file. In these situations, you can also enable the verbose mode for the log forwarder: Set verbose to a value other than 0. Add the configuration option: trace: [\"log.fw\"]. Caution Check whether you are using the [fluentbit] option. When setting verbose: 3 and trace: [\"log.fw\"], ensure that you don't define any [OUTPUT] section pointing to stdout in an external Fluent Bit configuration file, Fluent Bit does not start with the infra agent Important Fluent Bit's tail plugin does not support network drives. For Linux versions prior to 2016, you may need to update the OpenSSL library to 1.1.0 (or higher). To check if you have this problem: See if infra-agent has started Fluent Bit by running: ps -aux | grep fluent-bi Copy If it isn't running go to /var/db/newrelic-infra/newrelic-integrations/logging and run: ./fluent-bit -i systemd -o stdout Copy If you get the following error, update OpenSSL to 1.1.0 or higher: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory Copy Runtime error on Windows One of the following error messages may appear when enabling log forwarding on Windows: The code execution cannot proceed because VCRUNTIME140.dll was not found. Copy OR error=\"exit status 3221225781\" process=log-forwarder Copy This is caused by a missing DLL. To solve the issue, install the Microsoft Visual C++ Redistributable as applicable: x64 x86 Errors when tailing a large amount of log files (Linux) It's common to face either one of the following error messages when attempting to tail a large amount of files: Too many open files The user limit on the total number of inotify watches was reached or the kernel failed to allocate a needed resource The operating system defines a maximum amount of allocatable file descriptors (typically 1024 by default), and a maximum amount of allocatable inotify watches (typically 8192 by default). Any process attempting to go above these limits will fail, returning one of the errors above. The underlying technology we use to forward logs, Fluent Bit, opens one file descriptor and sets an inotify watch for each file you configure to be forwarded. Moreover, at the time of writing this section, Fluent Bit uses an extra set of 32 file descriptors for its normal operation, with another extra file descriptor when it shuts down. Therefore, to capture a large amount of files you need to ensure that both the file descriptor and inotify watch limits are slightly greater than the amount of log files you wish to tail. The following instructions summarize how to increase these limits if you want to tail 10,000 log files. Also, it assumes the infrastructure agent is installed in root running mode, and therefore must be run using the root user. Check which is the current hard limit for the amount of file descriptors per process. Typically, this limit should be quite high and should not need to be modified. ulimit -Hn Copy Add the following line to /etc/security/limits.conf. We specified a limit of 10100 here instead of just 10000 to allow Fluent Bit to allocate the extra file descriptors it may need to work. root soft nofile 10100 # replace root by nri-agent for non-root (privileged and unprivileged) installations Copy Add the following line to /etc/pam.d/common-session so that the previous limit is applied upon restart: session required pam_limits.so Copy Add the following line to /etc/sysctl.conf to increase the amount of allowed inotify watchers per user. We specified a limit of 18192 here instead of just 10000 so that the root user will still have 8192 available inotify watches (the default value). fs.inotify.max_user_watches=18192 Copy Restart your system. Ensure that the new limits have been enforced by running: ulimit -Sn # Should return 10100 cat /proc/sys/fs/inotify/max_user_watches # Should return 18192 Copy Learn more on how to increase open file limits, or on how to increase the inotify watches. Uninstall log forwarding To uninstall log forwarding capabilities, go to your logging.d directory, and remove files with the .yml extension that were originally added during the configuration process. Linux: /etc/newrelic-infra/logging.d/ Windows: C:\\Program Files\\New Relic\\newrelic-infra\\logging.d\\ What's next? Explore logging data across your platform with the New Relic One UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our logs in context capabilities. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 343.02722,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Forward your <em>logs</em> using the <em>infrastructure</em> agent",
        "sections": "Sending the <em>infrastructure</em> agent&#x27;s <em>logs</em> to <em>New</em> <em>Relic</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": " <em>management</em> capabilities to collect, process, explore, query, and alert on your <em>log</em> data. Basic process To forward your <em>logs</em> through our infrastructure <em>monitoring</em> agent: If you haven&#x27;t already, create a <em>New</em> <em>Relic</em> account. It&#x27;s free, forever. Verify the system requirements needed for configuring <em>logs</em>"
      },
      "id": "603e9df164441f6b6f4e8843"
    },
    {
      "sections": [
        "Stream logs using Kinesis Data Firehose",
        "Create the delivery stream for New Relic",
        "Configure your stream to send logs to EU accounts",
        "View log data",
        "What's next?"
      ],
      "title": "Stream logs using Kinesis Data Firehose",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Enable log monitoring in New Relic"
      ],
      "external_id": "5fbb75b1eb9e180f1aabfa0f0e803ae5562b5977",
      "image": "https://docs.newrelic.com/static/ef38529dfbd5e54cbe001c347c5f528b/c1b63/3rd-party-firehose.png",
      "url": "https://docs.newrelic.com/docs/logs/forward-logs/stream-logs-using-kinesis-data-firehose/",
      "published_at": "2021-12-04T21:58:41Z",
      "updated_at": "2021-11-24T09:27:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If your log data is already being monitored by Amazon CloudWatch Logs, you can use our Kinesis Data Firehose integration to forward and enrich your log data in New Relic. Kinesis Data Firehose is a service that can stream data in real time to a variety of destinations, including our platform. Forwarding your CloudWatch Logs or other logs compatible with a Kinesis stream to New Relic will give you enhanced log management capabilities to collect, process, explore, query, and alert on your log data. Create the delivery stream for New Relic To forward your logs from Kinesis Data Firehose to New Relic: Make sure you have a New Relic license key. Follow the procedures to create an Amazon Kinesis Data Firehose delivery stream, and select New Relic as the destination: In the AWS Management Console, go to Amazon Kinesis. Select Kinesis Data Firehose and click Create delivery stream. Enter a name for the stream and select your data source. When selecting the destination, click Third-party partner and then New Relic. Under HTTP endpoint URL, select New Relic logs - US from the dropdown. Note: To send your logs to the EU, complete the remaining steps in this section, then proceed to the configuration procedures for EU accounts. Paste your license key in the API key field. Configure and review the remaining settings. Configure your stream to send logs to EU accounts If you have a New Relic account in our EU data center: Follow standard procedures to create your delivery stream. Once your stream has been created, navigate to the Amazon Kinesis Console, and click Delivery streams. Click the name of your newly created delivery stream, and select the Configuration tab. Next to the Destination settings section, click Edit. Update the value for HTTP endpoint URL to our Firehose endpoint for EU accounts: https://aws-api.eu.newrelic.com/firehose/v1 Copy Click Save changes to ensure your stream is updated. View log data If everything is configured correctly and your data is being collected, you should see data logs in both of these places: New Relic Logs UI New Relic tools for running NRQL queries. For example, you can execute a query like this: SELECT * FROM Log Copy If no data appears after you enable our log management capabilities, follow our standard log troubleshooting procedures. What's next? Explore logging data across your platform with the New Relic One UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our logs in context capabilities. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 266.20477,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Stream <em>logs</em> using Kinesis Data Firehose",
        "sections": "Create the delivery stream for <em>New</em> <em>Relic</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": ". Forwarding your CloudWatch <em>Logs</em> or other <em>logs</em> compatible with a Kinesis stream to <em>New</em> <em>Relic</em> will give you enhanced <em>log</em> <em>management</em> capabilities to collect, process, explore, query, and alert on your <em>log</em> data. Create the delivery stream for <em>New</em> <em>Relic</em> To forward your <em>logs</em> from Kinesis Data Firehose to <em>New</em>"
      },
      "id": "603e96be64441f41584e8858"
    }
  ],
  "/docs/logs/forward-logs/stream-logs-using-kinesis-data-firehose": [
    {
      "sections": [
        "AWS Lambda for sending CloudWatch logs",
        "Install and configure the Cloudwatch logs Lambda function",
        "Create a Lambda trigger",
        "Configure retries (optional)",
        "Tip",
        "Resources created by the SAM template",
        "View log data",
        "What's next?"
      ],
      "title": "AWS Lambda for sending CloudWatch logs",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Enable log monitoring in New Relic"
      ],
      "external_id": "69c310375d48a667779ffabead6f920eb6a34004",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/forward-logs/aws-lambda-sending-cloudwatch-logs/",
      "published_at": "2021-12-04T21:55:34Z",
      "updated_at": "2021-12-04T21:55:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can send your Amazon CloudWatch logs to New Relic using our AWS Lambda function, newrelic-log-ingestion. This can be easily deployed from the AWS Serverless application repository. Forwarding your CloudWatch logs to New Relic will give you enhanced log management capabilities to collect, process, explore, query, and alert on your log data. Install and configure the Cloudwatch logs Lambda function The following setup shows one approach for configuring environment variables. You can also configure them from the Functions page. Complete the following: Make sure you have a New Relic license key. Open the AWS Serverless Application Repository in your browser. Search for newrelic and check Show apps that create custom IAM roles or resource policies to find newrelic-log-ingestion. Open the newrelic-log-ingestion details and click Deploy. In the function's Configure menu, go to Environment Variables and configure log forwarding using the following environment variables: Key Description DEBUG_LOGGING_ENABLED A boolean to determine if you want to output debug messages in the CloudWatch console. Optional. To turn on debug logs, set this to true. Default is false. LICENSE_KEY New Relic license key is used for sending data to New Relic. Required. LOGGING_ENABLED Determines if logs are forwarded to New Relic. Required. To turn on logging, set this to true. NR_LOGGING_ENDPOINT New Relic ingestion endpoint for logs. Required. Two endpoints are available: US: https://log-api.newrelic.com/log/v1 EU: https://log-api.eu.newrelic.com/log/v1 NR_TAGS Specify tags to be added to all log events. Optional. Each tag is composed of a colon-delimited key and value. Multiple key-value pairs are semicolon-delimited; for example, env:prod;team:myTeam. Acknowledge that the app creates custom IAM roles, and then click Deploy. Once the process completes, create a Lambda trigger to link your Lambda function to CloudWatch logs. Create a Lambda trigger To get your logs streaming to New Relic, attach a trigger to the Lambda: From the left side menu, select Functions. Find and select the previously created newrelic-log-ingestion function. Under Designer, click Add Triggers, and select Cloudwatch Logs from the dropdown. Select the the appropriate Log group for your application. Enter a name for your filter. Optional: Enter a filter pattern. Check the Enable trigger checkbox, then click Add to create the trigger. Configure retries (optional) You can configure the number of retries you want to perform in case the function fails to send the data in case of communication issues. Recommended number is 3 retries, but you can change the retry behavior by changing the below parameters: Tip The more the number of retries there are can make the function run for longer times. This increases the probability of having higher costs for Lambda. However, decreasing the number of retries could increase the probability of data loss. MAX_RETRIES = 3 # Defines the number of retries after lambda failure to deliver data INITIAL_BACKOFF = 1 # Defines the initial wait seconds until next retry is executed BACKOFF_MULTIPLIER = 2 # Time multiplier between the retries As an example, in default above configuration, first retry will happen after 1 second, second retry after 2 seconds and third retry will happen after 4 seconds. Copy Resources created by the SAM template When you create the application from the repository, the following resources are also created: The Lambda function itself A role used to give execution permissions to the Lambda function based in CloudWatch Logs. All other Lambda configurations not listed can be left as the defaults. View log data If everything is configured correctly and your data is being collected, you should see data logs in both of these places: New Relic Logs UI New Relic tools for running NRQL queries. For example, you can execute a query like this: SELECT * FROM Log Copy If no data appears after you enable our log management capabilities, follow our standard log troubleshooting procedures. What's next? Explore logging data across your platform with the New Relic One UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our logs in context capabilities. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 348.03848,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "AWS Lambda for sending CloudWatch <em>logs</em>",
        "sections": "<em>Install</em> and configure the Cloudwatch <em>logs</em> Lambda function",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": " this: SELECT * FROM <em>Log</em> Copy If no data appears after you <em>enable</em> our <em>log</em> <em>management</em> capabilities, follow our standard <em>log</em> troubleshooting procedures. What&#x27;s next? Explore logging data across your platform with the <em>New</em> <em>Relic</em> One UI. Get deeper visibility into both your application and your platform performance data by forwarding your <em>logs</em> with our <em>logs</em> in context capabilities. Set up alerts. Query your data and create dashboards."
      },
      "id": "603ea6bb28ccbc228deba74c"
    },
    {
      "sections": [
        "Forward your logs using the infrastructure agent",
        "Basic process",
        "System requirements",
        "Important",
        "Install the infrastructure agent",
        "Configure the infrastructure agent",
        "Log forwarding parameters",
        "Name (required)",
        "Log source (required)",
        "file",
        "systemd",
        "syslog",
        "tcp",
        "winlog",
        "Optional configuration",
        "attributes",
        "attributes automatically inserted by the infrastructure agent",
        "pattern",
        "max_line_kb",
        "fluentbit",
        "Sample configuration file",
        "logging.d/sample.yaml",
        "View your log data",
        "Troubleshooting",
        "No log data",
        "No data appears when tailing a file",
        "No data appears when capturing via a Syslog socket",
        "No data appears using infrastructure agent proxy",
        "Sending the infrastructure agent's logs to New Relic",
        "Caution",
        "Fluent Bit does not start with the infra agent",
        "Runtime error on Windows",
        "Errors when tailing a large amount of log files (Linux)",
        "Uninstall log forwarding",
        "What's next?"
      ],
      "title": "Forward your logs using the infrastructure agent",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Enable log monitoring in New Relic"
      ],
      "external_id": "a1deac410f0eedfb819348524a85a73bbb9d9daf",
      "image": "https://docs.newrelic.com/static/63ba6c3dc400e3cc4fb21668d5e7ba2a/c1b63/infrastructure-lic.png",
      "url": "https://docs.newrelic.com/docs/logs/forward-logs/forward-your-logs-using-infrastructure-agent/",
      "published_at": "2021-12-08T01:44:17Z",
      "updated_at": "2021-12-04T13:38:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can forward your logs to New Relic using our infrastructure monitoring agent. This makes all of your logging data available in one location and provides deeper visibility into both your application and your platform performance data. Forwarding your logs to New Relic will give you enhanced log management capabilities to collect, process, explore, query, and alert on your log data. Basic process To forward your logs through our infrastructure monitoring agent: If you haven't already, create a New Relic account. It's free, forever. Verify the system requirements needed for configuring logs. Ensure you have installed the infrastructure agent, version 1.11.4 or higher. Create a logging.yml configuration file in the infrastructure agent's logging.d directory. Configure your log sources and other parameters. Generate some traffic and wait a few minutes, then check your account for data. Explore your log data in the Logs UI and benefit from the log attributes automatically inserted by the infrastructure agent. Here is an example of where you can see logs in context of your infrastructure monitoring details in New Relic One. System requirements To use the log forwarder of the infrastructure agent, make sure you meet the following requirements: Infrastructure agent version 1.11.4 or higher OpenSSL library 1.1.0 or higher is required by Infrastructure agent starting from 1.16.4. Built-in support for ARM64 architecture on Linux systems (in example, AWS Graviton architecture) added in Infrastructure agent 1.26.0. Important The log forwarding feature is not supported with the Docker container for infrastructure monitoring agents. The log forwarding feature is compatible with the following operating systems: Operating system Supported version Amazon Linux Amazon Linux 2 CentOS Version 7 or higher Debian Version 9 (\"Stretch\") or higher Exception: Version 11 is not supported. Red Hat Enterprise Linux (RHEL) Version 7 or higher SUSE Linux Enterprise Server (SLES) Version 12 Ubuntu Versions 16.04.x, 18.04.x and 20.04.x (LTS versions) Windows Windows Server 2012, 2016, and 2019, and their service packs. Windows 10 Install the infrastructure agent Starting with version 1.11.4, the infrastructure agent can forward logs to New Relic. To install and run the agent, use a package manager (Linux) or the MSI installer (Windows). Important The log forwarding feature is not included when the infrastructure agent is implemented using Linux tarball or Windows ZIP installations. To use the following links, make sure you are logged to your New Relic account. Amazon Linux CentOS Debian RHEL SLES Ubuntu Windows If you don't have a New Relic account yet, or if you prefer to follow the procedure manually, see our tutorial to install the package manager. Configure the infrastructure agent Configuration files describe which log sources are forwarded. Our infrastructure agent uses .yml files to configure logging. You can add as many config files as you want. To add a new configuration file for the log forwarding feature: Navigate to the log forwarder configuration folder: Linux: /etc/newrelic-infra/logging.d/ Windows: C:\\Program Files\\New Relic\\newrelic-infra\\logging.d\\ Create a logging.yml configuration file, and add the parameters you need. The logging.d directory has various .yml.example files you can use as a reference or starting point. The agent automatically processes new configuration files without having to restart the infrastructure monitoring service. The only exception to this is when configuring a custom Fluent Bit configuration. Log forwarding parameters The infrastructure log forwarding .yml config supports the following parameters: Name (required) To start, define a name of the log or logs you want to forward to New Relic. Log source (required) What you use for the log source will depend on where you want to forward your logs from. Available options include: file Path to the log file or files. The agent tracks changes on the log files in a way similar to tail -f shell. Example: logs: - name: example-log file: /var/log/example.log # Path to a single log file - name: example-log-two file: /var/log/example-two.log # Path to another single log file Copy The file parameter can point to a specific log file or multiple files by using wildcards applied to names and extensions; for example, /logs/*.log. You can use wildcards in place of directories in a file path, which can be used to tail files located in different directories. Example: logs: - name: docker-logs file: /var/lib/docker/containers/*/*.log # Path to multiple folders and files Copy Important Use of wildcards may significantly increase the number of file descriptors and inotify watches the Fluent Bit process keeps open, which can interfere with log collection if the host's file descriptor limit is reached. Tailing a large number of files may require you to increase the maximum number of file descriptors and inotify watchers allowed by the operating system. Please refer to Errors when tailing a large amount of log files for more details on how to increase them. systemd Use the systemd parameter to forward log messages that are collected by the journald daemon in Linux environments. This input type requires the agent to run in root mode. Example: logs: - name: systemd-example systemd: cupsd Copy syslog Syslog data source. Parameters: uri: Syslog socket. Format varies depending on the protocol: TCP/UDP network sockets: [tcp/udp]://LISTEN_ADDRESS:PORT Unix domain sockets: unix_[tcp/udp]:// + /socket/path parser: Syslog parser. Default is rfc3164. Use rfc5424 if your messages include fractional seconds. Note: rfc3164 currently does not work on SuSE. unix_permissions: default is 0644 for domain sockets; this limits entries to processes running as root. You can use 0666 to listen for non-root processes, at your own risk. When running the agent in privileged mode, ports and sockets must be available or owned by nri-agent, with 0666 file permissions, so that other processes can write logs to the sockets. logs: # TCP network socket - name: syslog-tcp-test syslog: uri: tcp://0.0.0.0:5140 # Use the tcp://LISTEN_ADDRESS:PORT format parser: rfc5424 # Default syslog parser is rfc3164 # UDP network socket - name: syslog-udp-test syslog: uri: udp://0.0.0.0:6140 # Use the udp://LISTEN_ADDRESS:PORT format max_line_kb: 35 # Unix TCP domain socket - name: syslog-unix-tcp-test syslog: uri: unix_tcp:///var/unix-tcp-socket-test unix_permissions: 0666 # Default is 0644. Change at your own risk # Unix UDP domain socket - name: syslog-unix-udp-test syslog: uri: unix_udp:///var/unix-udp-socket-test parser: rfc5424 Copy tcp Logs retrieved over TCP connections. Parameters: uri: TCP/IP socket to listen for incoming data. The URI format is tcp://LISTEN_ADDRESS:PORT format: format of the data. It can be json or none. separator: If format: none is used, you can define a separator string for splitting records (default: \\n). logs: - name: tcp-simple-test tcp: uri: tcp://0.0.0.0:1234 # Use the tcp://LISTEN_ADDRESS:PORT format format: none # Raw text - this is default for 'tcp' separator: \\t # String for separating raw text entries max_line_kb: 32 - name: tcp-json-test tcp: uri: tcp://0.0.0.0:2345 # Use the tcp://LISTEN_ADDRESS:PORT format format: json Copy winlog Collect events from Windows log channels. Parameters: channel: name of the channel logs will be collected from. collect-eventids: a list of Windows Event IDs to be collected and forwarded to New Relic. Event ID ranges are supported. exclude-eventids: a list of Windows Event IDs to be excluded from collection. Event ID ranges are supported. All events are collected from the specified channel by default. Configure the collect-eventids and exclude-eventids sections to avoid sending unwanted logs to your New Relic account. Add event IDs or ranges to collect-eventids or exclude-eventids to forward or drop specific events. exclude-eventids takes precedence over collect-eventids if the same event ID is present in both sections. Example: logs: # Winlog log ingestion with eventId filters. - name: windows-security winlog: channel: Security collect-eventids: - 4624 - 4265 - 4700-4800 exclude-eventids: - 4735 # entries for the application, system, powershell, and SCOM channels - name: windows-application winlog: channel: Application - name: windows-system winlog: channel: System - name: windows-pshell winlog: channel: Windows Powershell - name: scom winlog: channel: Operations Manager # Entry for Windows Defender Logs - name: windows-defender winlog: channel: Microsoft-Windows-Windows Defender/Operational # Entry for Windows Clustering Logs - name: windows-clustering winlog: channel: Microsoft-Windows-FailoverClustering/Operational # Entry for IIS logs with logtype attribute for automatic parsing - name: iis-log file: C:\\inetpub\\logs\\LogFiles\\w3svc.log attributes: logtype: iis_w3c Copy Optional configuration The following configuration parameters are not required but are still recommended. attributes List of custom attributes specified as key-value pairs that can be used to send additional data with the logs which you can then query. The attributes configuration parameter can be used with any log source. One common use of the attributes configuration parameter is to specify the logtype attribute. This attribute allows leveraging one of the built-in parsing rules supported by New Relic Logs. Example: logs: - name: example-file-attributes file: /var/log/example.log attributes: logtype: nginx region: example-us-02 team: A-team - name: example-tcp-attributes tcp: uri: tcp://0.0.0.0:2345 format: json attributes: logtype: nginx region: example-us-02 team: B-team Copy attributes automatically inserted by the infrastructure agent The infrastructure agent automatically inserts log attributes for your convenience. Some of them are inserted for any log record, while others depend on the configuration parameters you used while setting up the log forwarder. Attribute name Description entity.guids Always inserted. The infrastructure agent inserts the Entity GUID assigned by New Relic to identify the host where it's running. It is available in the entity.guids field. Note: If the captured logs belong to an application instrumented using APM, the entity.guids field contains both the entity GUID of infrastructure, as well as the GUID of APM, separated by a pipe ( | ) delimiter. fb.input Always inserted. The underlying Fluent Bit input plugin type used to capture the logs. Currently its values are tail, systemd, winlog, syslog, and tcp. filePath Inserted when sing the file input type. Absolute file path of the file being monitored. hostname Always inserted. The hostname of the machine/VM/container executing the infrastructure agent. plugin.type Always inserted. Indicates the utility used to capture the logs. In this case, it is the infrastructure agent itself, so this attribute always has the value nri-agent. pattern Regular expression for filtering records. Only supported for the tail, systemd, syslog, and tcp (only with format none) sources. This field works in a way similar to grep -E in Unix systems. For example, for a given file being captured, you can filter for records containing either WARN or ERROR using: - name: only-records-with-warn-and-error file: /var/log/logFile.log pattern: WARN|ERROR Copy No filtering is applied by default. max_line_kb Maximum size of log entries/lines in KB. If log entries exceed the limit, they are skipped. Default is 128. fluentbit External Fluent Bit configuration and parser files. If defined, they are merged with the existing configuration and parser files generated by the infrastructure agent. The infrastructure agent processes the configuration files located in the logging.d directory and will generate a run-time Fluent Bit configuration file that contains the appropriate [INPUT], [FILTER] and [OUTPUT] sections. Optionally, it will also declare an @INCLUDE in case you provided an external Fluent Bit configuration file via the fluentbit option. The runtime file does not define a [SERVICE] section, leaving all default Fluent Bit configuration values. You can still override Fluent Bit's default settings by defining your own [SERVICE] section in your external Fluent Bit configuration file and include it via the fluentbit option. Parameters: config_file: path to an existing Fluent Bit configuration file. Note that any overlapping source results in duplicate messages in New Relic Logs. parsers_file: path to an existing Fluent Bit parsers file. The following parser names are reserved: rfc3164, rfc3164-local and rfc5424. Sample configuration file Here is an example of a logging.d/ configuration file in YAML format. For more configuration examples, see the infrastructure agent repository. logging.d/sample.yaml # Remember to only use spaces for indentation logs: # Example of 'file' source - name: file-with-attributes file: /var/log/test.log # Path to a single file or pattern attributes: # You can use custom attributes to enrich your data logtype: nginx team: The A Team pattern: Error # Regular expression to filter log entries # Example of 'systemd' source (Linux only) - name: systemd-example systemd: cupsd # Examples of 'syslog' source, one per protocol # TCP network socket - name: syslog-tcp-test syslog: uri: tcp://0.0.0.0:5140 # Use the tcp://LISTEN_ADDRESS:PORT format parser: rfc5424 # Default syslog parser is rfc3164 # UDP network socket - name: syslog-udp-test syslog: uri: udp://0.0.0.0:6140 # Use the udp://LISTEN_ADDRESS:PORT format max_line_kb: 35 # Paths for Unix sockets are defined by combining protocol and path: # unix_udp:// + /path/socket - for example, unix_udp:///tmp/socket # Unix TCP domain socket - name: syslog-unix-tcp-test syslog: uri: unix_tcp:///var/unix-tcp-socket-test unix_permissions: 0666 # Default is 0644. Change at your own risk # Unix UDP domain socket - name: syslog-unix-udp-test syslog: uri: unix_udp:///var/unix-udp-socket-test parser: rfc5424 # Examples of 'tcp' source for formats 'none' and 'json' - name: tcp-simple-test tcp: uri: tcp://0.0.0.0:1234 # Use the tcp://LISTEN_ADDRESS:PORT format format: none # Raw text - this is default for 'tcp' separator: \\t # String for separating raw text entries attributes: # You can add custom attributes to any source of logs tcpFormat: none someOtherAttribute: associatedValue max_line_kb: 32 - name: tcp-json-test tcp: uri: tcp://0.0.0.0:2345 # Use the tcp://LISTEN_ADDRESS:PORT format format: json attributes: tcpFormat: json yetAnotherAttribute: 12345 # Example of Fluent Bit configuration import - name: fluentbit-import fluentbit: config_file: /path/to/fluentbit.config parsers_file: /path/to/fluentbit/parsers.conf Copy View your log data If everything is configured correctly and your data is being collected, you should see logs data in both of these places: New Relic Logs UI New Relic tools for running NRQL queries. For example, you can execute a query like this: SELECT * FROM Log Copy Troubleshooting If you encounter problems with configuring your log forwarder, try these troubleshooting tips. No log data If no data appears after you enable our log management capabilities, follow our standard log troubleshooting procedures. No data appears when tailing a file The log forwarding feature requires the agent to have permission to read the data sources. When running the infrastructure agent in privileged or non-privileged modes, make sure that the log files you want to forward (and any intermediary directory in its path) are readable by the user running nri-agent. Example: Check file access under Linux Let's check whether the file /var/log/restrictedLogs/logFile.log can be monitored by the nri-agent user. In Linux, you can do a quick check with the namei command: sudo -u nri-agent namei -ml /var/log/restrictedLogs/logFile.log f: /var/log/restrictedLogs/logFile.log drwxr-xr-x root root / drwxr-xr-x root root var drwxrwxr-x root syslog log drwxr--r-- root root restrictedLogs logFile.log - No such file or directory Copy This command failed because the file is not visible to the nri-agent user. By inspecting the previous output, we can detect that the restrictedLogs directory is missing the execution flag for others. To fix this, execute: sudo chmod 755 /var/log/restrictedLogs Copy And then check for file access again: # sudo -u nri-agent namei -ml /var/log/restrictedLogs/logFile.log f: /var/log/restrictedLogs/logFile.log drwxr-xr-x root root / drwxr-xr-x root root var drwxrwxr-x root syslog log drwxr-xr-x root root restrictedLogs -rw-r----- vagrant vagrant logFile.log Copy The file is now visible to the nri-agent user. You must ensure that the file is also readable by the nri-agent user. To check this, use: # sudo -u nri-agent head /var/log/restrictedLogs/logFile.log head: cannot open '/var/log/restrictedLogs/logFile.log' for reading: Permission denied Copy In this example, the file is missing the read rights for the others group (users other than vagrant and the vagrant user group). You could fix this by granting read permissions to others, but the application could change these permissions upon restart. To avoid this, a better approach is to add the nri-agent user to the vagrant user group. No data appears when capturing via a Syslog socket The log forwarding feature requires that the agent has permission to read the data sources. When running the infrastructure agent in privileged or non-privileged modes: If you're using Unix domain socket files, make sure that the nri-agent user can access these files (please refer to the previous section) and that they have read and write permissions (666) so that other users than nri-agent can write to them. If you're using IP sockets, ensure that the port that you are using is not a system reserved one (like port 80, for example). If no data appears after you enable log management, follow standard log management troubleshooting procedures. No data appears using infrastructure agent proxy As explained in the infrastructure agent configuration guidelines, the proxy parameter must use either HTTP or HTTPS and be in the form https://user:password@hostname:port. The agent can parse the parameter without the HTTP or HTTPS, but the log forwarder cannot. You will see an error like the following in the agent verbose logs: [ERROR] building HTTP transport: parse \\\"hostname:port\\\": first path segment in URL cannot contain colon Copy To solve this problem, check your newrelic-infra.yml file, and ensure the proxy parameter adheres to this form. If you're using caBundleFile or caBundleDir in order to specify any certificate, we recommend to follow the below rules for each OS: Linux For HTTP proxies you don't need to setup any certificates. The plugin loads the system certificates and New Relic sends logs into the logging endpoint. However, you can specify the proxy self-signed certificate (PEM file) using either the caBundleFile or caBundleDir parameters. Windows For HTTP proxies you don't need to setup any certificates. The plugin loads the system certificates. For HTTPS, you can configure it in one of the following ways: Import the proxy certificate to the system pool (Recommended) Import the proxy self-signed certificate (PEM file) by using the MMC tool. Refer to this link, and in Step 2 ensure to import it in your Trusted Root Certification Authorities, instead of in the Intermediate Certification Authorities. Using the caBundleFile and caBundleDir parameters On Windows, we cannot load both the certificates from the system certificate pool and the ones specified with the caBundleFile caBundleDir parameters. So, if you are using caBundleFile or caBundleDir, ensure that the following certificates are placed in the same PEM file (when using caBundleFile) or in the same directory (when using caBundleDir): The Proxy certificate (because it's an HTTPS proxy). The Logging Endpoint certificate (eg. https://log-api.newrelic.com/log/v1). The Infrastructure Agent certificate (eg. https://infra-api.newrelic.com). You can check the certificates by running: # openssl s_client -connect log-api.newrelic.com:443 -servername log-api.newrelic.com Copy Sending the infrastructure agent's logs to New Relic You can configure the infrastructure agent to send its own logs to New Relic. This is useful for troubleshooting issues with log forwarding, the agent, or when contacting support. To forward the infrastructure agent logs to New Relic: Edit your newrelic-infra.yml file. Enable agent logging in troubleshooting mode by adding verbose: 3. On Windows and systems that don't use systemd or where journald is inaccessible, verbose:3 causes the agent to write the logs on the disk. Revert to verbose:0 to prevent this. (Recommended): Enable agent logging in JSON format to log_format: json. Restart the agent to load the new settings. This configuration sets up the agent in troubleshooting mode, but the log forwarder (based on Fluent Bit) will continue in a non-verbose mode. Sometimes you can have issues with the log forwarder itself. For example, there may be problems accessing a specific channel when shipping Windows log events or when accessing a particular log file. In these situations, you can also enable the verbose mode for the log forwarder: Set verbose to a value other than 0. Add the configuration option: trace: [\"log.fw\"]. Caution Check whether you are using the [fluentbit] option. When setting verbose: 3 and trace: [\"log.fw\"], ensure that you don't define any [OUTPUT] section pointing to stdout in an external Fluent Bit configuration file, Fluent Bit does not start with the infra agent Important Fluent Bit's tail plugin does not support network drives. For Linux versions prior to 2016, you may need to update the OpenSSL library to 1.1.0 (or higher). To check if you have this problem: See if infra-agent has started Fluent Bit by running: ps -aux | grep fluent-bi Copy If it isn't running go to /var/db/newrelic-infra/newrelic-integrations/logging and run: ./fluent-bit -i systemd -o stdout Copy If you get the following error, update OpenSSL to 1.1.0 or higher: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory Copy Runtime error on Windows One of the following error messages may appear when enabling log forwarding on Windows: The code execution cannot proceed because VCRUNTIME140.dll was not found. Copy OR error=\"exit status 3221225781\" process=log-forwarder Copy This is caused by a missing DLL. To solve the issue, install the Microsoft Visual C++ Redistributable as applicable: x64 x86 Errors when tailing a large amount of log files (Linux) It's common to face either one of the following error messages when attempting to tail a large amount of files: Too many open files The user limit on the total number of inotify watches was reached or the kernel failed to allocate a needed resource The operating system defines a maximum amount of allocatable file descriptors (typically 1024 by default), and a maximum amount of allocatable inotify watches (typically 8192 by default). Any process attempting to go above these limits will fail, returning one of the errors above. The underlying technology we use to forward logs, Fluent Bit, opens one file descriptor and sets an inotify watch for each file you configure to be forwarded. Moreover, at the time of writing this section, Fluent Bit uses an extra set of 32 file descriptors for its normal operation, with another extra file descriptor when it shuts down. Therefore, to capture a large amount of files you need to ensure that both the file descriptor and inotify watch limits are slightly greater than the amount of log files you wish to tail. The following instructions summarize how to increase these limits if you want to tail 10,000 log files. Also, it assumes the infrastructure agent is installed in root running mode, and therefore must be run using the root user. Check which is the current hard limit for the amount of file descriptors per process. Typically, this limit should be quite high and should not need to be modified. ulimit -Hn Copy Add the following line to /etc/security/limits.conf. We specified a limit of 10100 here instead of just 10000 to allow Fluent Bit to allocate the extra file descriptors it may need to work. root soft nofile 10100 # replace root by nri-agent for non-root (privileged and unprivileged) installations Copy Add the following line to /etc/pam.d/common-session so that the previous limit is applied upon restart: session required pam_limits.so Copy Add the following line to /etc/sysctl.conf to increase the amount of allowed inotify watchers per user. We specified a limit of 18192 here instead of just 10000 so that the root user will still have 8192 available inotify watches (the default value). fs.inotify.max_user_watches=18192 Copy Restart your system. Ensure that the new limits have been enforced by running: ulimit -Sn # Should return 10100 cat /proc/sys/fs/inotify/max_user_watches # Should return 18192 Copy Learn more on how to increase open file limits, or on how to increase the inotify watches. Uninstall log forwarding To uninstall log forwarding capabilities, go to your logging.d directory, and remove files with the .yml extension that were originally added during the configuration process. Linux: /etc/newrelic-infra/logging.d/ Windows: C:\\Program Files\\New Relic\\newrelic-infra\\logging.d\\ What's next? Explore logging data across your platform with the New Relic One UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our logs in context capabilities. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 343.02722,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Forward your <em>logs</em> using the <em>infrastructure</em> agent",
        "sections": "Sending the <em>infrastructure</em> agent&#x27;s <em>logs</em> to <em>New</em> <em>Relic</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": " <em>management</em> capabilities to collect, process, explore, query, and alert on your <em>log</em> data. Basic process To forward your <em>logs</em> through our infrastructure <em>monitoring</em> agent: If you haven&#x27;t already, create a <em>New</em> <em>Relic</em> account. It&#x27;s free, forever. Verify the system requirements needed for configuring <em>logs</em>"
      },
      "id": "603e9df164441f6b6f4e8843"
    },
    {
      "sections": [
        "Forward logs from Google Cloud Platform",
        "Select an option",
        "Use headerless API",
        "1. Generate a GCP Pub/Sub ingest URL.",
        "2. Create a GCP Pub/Sub Topic.",
        "3. Prepare GCP Pub/Sub Topic to forward logs to New Relic.",
        "4. Create routing sink to forward logs to New Relic.",
        "Use Dataflow job",
        "1. Log into your Google Cloud Platform account.",
        "2. Clone the DataflowTemplates GitHub repository.",
        "3. Compile and run the Dataflow forwarder.",
        "4. Create a GCP bucket for the Dataflow template.",
        "5. Create a service account.",
        "6. Compile and publish the PubsubToNewRelic template.",
        "7. Run the template as a Dataflow job.",
        "8. Optional: Tune up your Dataflow log forwarder job.",
        "What's next?"
      ],
      "title": "Forward logs from Google Cloud Platform",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Enable log monitoring in New Relic",
        "GCP",
        "Dataflow"
      ],
      "external_id": "468037bc9c5a2039d0f964af9f947c2bee1a58da",
      "image": "https://docs.newrelic.com/static/3cf698759572f3f93a807069a7d1cc2d/c1b63/gcp-create-sink.png",
      "url": "https://docs.newrelic.com/docs/logs/forward-logs/google-cloud-platform-log-forwarding/",
      "published_at": "2021-12-04T21:58:42Z",
      "updated_at": "2021-11-24T05:03:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We support two different methods to forward your logs from a Google Cloud Platform Pub/Sub topic to New Relic. Select an option The following may help you decide which option is best for your business needs. GCP log forwarding options Considerations Headerless API Best suited for low log volumes, since it performs one API call for each log record it sends. Does not incur any extra cost to your GCP subscription. If your log volume increases, this solution might hit the quota limits of your New Relic account. Dataflow job Best suited for larger log volumes, since it groups log records in batches before sending them to New Relic. Reduces the number of API calls and allows you to reduce your quota usage. May incur extra costs at your GCP subscription, due to the execution of a Dataflow job in your premises. Use headerless API To send your GCP logs to New Relic using our headerless API: 1. Generate a GCP Pub/Sub ingest URL. Start by creating an ingest URL for your GCP Pub/Sub topic. Navigate to Logs in New Relic One, and click Add more data sources. Click Google Cloud Platform, then select your New Relic account where you want to forward logs, and click Continue. Optional: Configure metadata (attribute-value pairs) to be included in every log event sent to the ingest URL you will generate in the next step. Click Generate URL. Copy your newly generated ingest URL and keep it in a safe place. You will use your new ingest URL to configure a Pub/Sub topic that sends logs to New Relic. 2. Create a GCP Pub/Sub Topic. Next you will create the GCP Pub/Sub topic that your ingest URL will use. Navigate to the GCP Pub/Sub Console. Click Create Topic. Enter a meaningful Topic ID, then configure other options as needed. Click Create Topic. 3. Prepare GCP Pub/Sub Topic to forward logs to New Relic. Once you have created your Pub/Sub topic, create a subscription for it. Return to the GCP Pub/Sub Console. Click the Pub/Sub topic you previously created. Scroll down and select the Subscriptions tab, then click Create Subscription and select Create a simple subscription. Enter a Subscription ID. Then, under Delivery Type, select Push. In the Endpoint URL field, paste the ingest URL you previously generated. Configure remaining settings as needed, and click Create. 4. Create routing sink to forward logs to New Relic. To finish setup, create a routing sink for your GCP Pub/Sub topic that will forward your logs to New Relic. Navigate to the GCP Logs Router Console. Click Create Sink. Enter a Sink name and Sink description, then click Next. Under Select sink service, select Cloud Pub/Sub topic, and select the Pub/Sub topic you previously created. Configure remaining filters as needed, then click Create sink to complete setup. Use Dataflow job To send your GCP logs to New Relic using a Dataflow job, you will use our Dataflow template. Before you begin, make sure you have the following tools on your local computer: A Unix terminal for Linux or macOS Git Java JDK 8 or higher Apache Maven 3.2 or higher. We've seen earlier versions fail during the compilation process. The Google Cloud SDK, which includes gcloud and gsutil command line tools 1. Log into your Google Cloud Platform account. Run the following command and follow the prompts to log into GCP and select your cloud project: gcloud init Copy Using the wizard, you will select a cloud project to use, and you will be able to optionally select a default compute region and zone for the resources you create using gcloud or gsutil. We will not presume a default project, location or region for the following commands. 2. Clone the DataflowTemplates GitHub repository. Clone the DataflowTemplates GitHub repository using the following command: git clone https://github.com/newrelic-forks/DataflowTemplates.git Copy Enter the directory you just created: cd DataflowTemplates Copy Then continue with the next section to execute additional commands. 3. Compile and run the Dataflow forwarder. To set the required configuration to compile and run the Dataflow forwarder, run the following commands in your DataflowTemplates directory. The only required values are: PROJECT_ID BUCKET_NAME NR_LICENSE_KEY INPUT_SUBSCRIPTION_NAME You can leave the other default values as is. bash Copy $ # The Google Cloud Platform project id where your logs are and where the Dataflow log forwarder will run $ PROJECT_ID=<your_project_id> $ # Temporary bucket that will store intermediary files as a result of compiling the Dataflow template. Its name must be unique. $ BUCKET_NAME=<a_nonexisting_gcs_bucket_name> $ # New Relic license key $ NR_LICENSE_KEY=<your_newrelic_license_key> $ Input PubSub subscription to read logs from $ INPUT_SUBSCRIPTION_NAME=<your_pubsub_input_subscription_name> $ $ # Region where the created resources will be placed $ REGION=us-west1 $ # Service account used to execute the Dataflow template $ SERVICE_ACCOUNT_NAME=nr-dataflow-forwarder-sa $ # File name where the service account credentials will be stored $ SERVICE_ACCOUNT_KEY_FILENAME=service-account-key.json $ # The name your Dataflow log forwarder job will have $ JOB_NAME=nr-log-forwarder 4. Create a GCP bucket for the Dataflow template. Create a bucket in GCP to hold the generated Dataflow template by running the following command: bash Copy $ gsutil mb -p ${PROJECT_ID} -l ${REGION} gs://${BUCKET_NAME} 5. Create a service account. Execute the following commands: Create the service account: bash Copy $ gcloud iam service-accounts create ${SERVICE_ACCOUNT_NAME} Grant permissions to the service account: bash Copy $ gcloud projects add-iam-policy-binding ${PROJECT_ID} --member=\"serviceAccount:${SERVICE_ACCOUNT_NAME}@${PROJECT_ID}.iam.gserviceaccount.com\" --role=\"roles/owner\" Generate the service account key file: bash Copy $ gcloud iam service-accounts keys create ${SERVICE_ACCOUNT_KEY_FILENAME} --iam-account=${SERVICE_ACCOUNT_NAME}@${PROJECT_ID}.iam.gserviceaccount.com Reference your service account key file using the GOOGLE_APPLICATION_CREDENTIALS environment variable, as it will be used by subsequent commands: bash Copy $ export GOOGLE_APPLICATION_CREDENTIALS=${SERVICE_ACCOUNT_KEY_FILENAME} 6. Compile and publish the PubsubToNewRelic template. Execute the following command: bash Copy $ mvn compile exec:java \\ > -Dexec.mainClass=com.google.cloud.teleport.templates.PubsubToNewRelic \\ > -Dexec.cleanupDaemonThreads=false \\ > -Dexec.args=\" \\ > --project=${PROJECT_ID} \\ > --region=${REGION} \\ > --enableStreamingEngine \\ > --stagingLocation=gs://${BUCKET_NAME}/staging/ \\ > --gcpTempLocation=gs://${BUCKET_NAME}/temp/ \\ > --templateLocation=gs://${BUCKET_NAME}/template/PubsubToNewRelic \\ > --runner=DataflowRunner \\ > \" 7. Run the template as a Dataflow job. Execute the following command to start shipping logs using a Dataflow job that reads from your Pub/Sub topic: bash Copy $ gcloud dataflow jobs run ${JOB_NAME} \\ > --gcs-location=gs://${BUCKET_NAME}/template/PubsubToNewRelic \\ > --region=${REGION} \\ > --parameters \"inputSubscription=projects/${PROJECT_ID}/subscriptions/${INPUT_SUBSCRIPTION_NAME},licenseKey=${NR_LICENSE_KEY}\" This command only requires these two values: The input PubSub subscription used to read log messages The New Relic license key used to send your logs For other values, the command uses default configuration settings that you can further customize as needed. 8. Optional: Tune up your Dataflow log forwarder job. Here is a reference of available options you can use to further tune up the execution of your Dataflow log forwarder job. Configuration parameter Description licenseKey Required. New Relic license key. inputSubscription Required. The Cloud Pub/Sub subscription used to consume logs. Use this format: projects/<project-id>/subscriptions/<subscription-name> Copy logsApiUrl New Relic's URL for the Log API. This routes from the VPC where the Dataflow pipeline runs. Default: https://log-api.newrelic.com/log/v1 Copy batchCount Maximum number of log records to aggregate into a batch before sending them to New Relic in a single HTTP POST request. Default: 100 flushDelay Number of seconds to wait for additional logs (up to batchCount) since the reception of the last log record in non-full batch, before flushing them to New Relic. Default: 2 parallelism Maximum number of parallel requests. Default: 1 disableCertificateValidation Disable SSL certificate validation. Default: false useCompression Compress (in GZIP) the payloads sent to the New Relic Logs API. Default: true tokenKMSEncryptionKey KMS Encryption Key for the token. Use this format: projects/{gcp_project}/locations/{key_region}/keyRings/{key_ring}/cryptoKeys/{kms_key_name} Copy Default: null What's next? Explore logging data across your platform with the New Relic One UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our logs in context capabilities. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 265.46634,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Forward <em>logs</em> from Google Cloud Platform",
        "sections": "3. Prepare GCP Pub&#x2F;Sub Topic to forward <em>logs</em> to <em>New</em> <em>Relic</em>.",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": "We support two different methods to forward your <em>logs</em> from a Google Cloud Platform Pub&#x2F;Sub topic to <em>New</em> <em>Relic</em>. Select an option The following may help you decide which option is best for your business needs. GCP <em>log</em> forwarding options Considerations Headerless API Best suited for low <em>log</em> volumes"
      },
      "id": "61740cdc28ccbc5833c6a8c2"
    }
  ],
  "/docs/logs/forward-logs/vector-output-sink-log-forwarding": [
    {
      "sections": [
        "AWS Lambda for sending CloudWatch logs",
        "Install and configure the Cloudwatch logs Lambda function",
        "Create a Lambda trigger",
        "Configure retries (optional)",
        "Tip",
        "Resources created by the SAM template",
        "View log data",
        "What's next?"
      ],
      "title": "AWS Lambda for sending CloudWatch logs",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Enable log monitoring in New Relic"
      ],
      "external_id": "69c310375d48a667779ffabead6f920eb6a34004",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/forward-logs/aws-lambda-sending-cloudwatch-logs/",
      "published_at": "2021-12-04T21:55:34Z",
      "updated_at": "2021-12-04T21:55:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can send your Amazon CloudWatch logs to New Relic using our AWS Lambda function, newrelic-log-ingestion. This can be easily deployed from the AWS Serverless application repository. Forwarding your CloudWatch logs to New Relic will give you enhanced log management capabilities to collect, process, explore, query, and alert on your log data. Install and configure the Cloudwatch logs Lambda function The following setup shows one approach for configuring environment variables. You can also configure them from the Functions page. Complete the following: Make sure you have a New Relic license key. Open the AWS Serverless Application Repository in your browser. Search for newrelic and check Show apps that create custom IAM roles or resource policies to find newrelic-log-ingestion. Open the newrelic-log-ingestion details and click Deploy. In the function's Configure menu, go to Environment Variables and configure log forwarding using the following environment variables: Key Description DEBUG_LOGGING_ENABLED A boolean to determine if you want to output debug messages in the CloudWatch console. Optional. To turn on debug logs, set this to true. Default is false. LICENSE_KEY New Relic license key is used for sending data to New Relic. Required. LOGGING_ENABLED Determines if logs are forwarded to New Relic. Required. To turn on logging, set this to true. NR_LOGGING_ENDPOINT New Relic ingestion endpoint for logs. Required. Two endpoints are available: US: https://log-api.newrelic.com/log/v1 EU: https://log-api.eu.newrelic.com/log/v1 NR_TAGS Specify tags to be added to all log events. Optional. Each tag is composed of a colon-delimited key and value. Multiple key-value pairs are semicolon-delimited; for example, env:prod;team:myTeam. Acknowledge that the app creates custom IAM roles, and then click Deploy. Once the process completes, create a Lambda trigger to link your Lambda function to CloudWatch logs. Create a Lambda trigger To get your logs streaming to New Relic, attach a trigger to the Lambda: From the left side menu, select Functions. Find and select the previously created newrelic-log-ingestion function. Under Designer, click Add Triggers, and select Cloudwatch Logs from the dropdown. Select the the appropriate Log group for your application. Enter a name for your filter. Optional: Enter a filter pattern. Check the Enable trigger checkbox, then click Add to create the trigger. Configure retries (optional) You can configure the number of retries you want to perform in case the function fails to send the data in case of communication issues. Recommended number is 3 retries, but you can change the retry behavior by changing the below parameters: Tip The more the number of retries there are can make the function run for longer times. This increases the probability of having higher costs for Lambda. However, decreasing the number of retries could increase the probability of data loss. MAX_RETRIES = 3 # Defines the number of retries after lambda failure to deliver data INITIAL_BACKOFF = 1 # Defines the initial wait seconds until next retry is executed BACKOFF_MULTIPLIER = 2 # Time multiplier between the retries As an example, in default above configuration, first retry will happen after 1 second, second retry after 2 seconds and third retry will happen after 4 seconds. Copy Resources created by the SAM template When you create the application from the repository, the following resources are also created: The Lambda function itself A role used to give execution permissions to the Lambda function based in CloudWatch Logs. All other Lambda configurations not listed can be left as the defaults. View log data If everything is configured correctly and your data is being collected, you should see data logs in both of these places: New Relic Logs UI New Relic tools for running NRQL queries. For example, you can execute a query like this: SELECT * FROM Log Copy If no data appears after you enable our log management capabilities, follow our standard log troubleshooting procedures. What's next? Explore logging data across your platform with the New Relic One UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our logs in context capabilities. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 348.0383,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "AWS Lambda for sending CloudWatch <em>logs</em>",
        "sections": "<em>Install</em> and configure the Cloudwatch <em>logs</em> Lambda function",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": " this: SELECT * FROM <em>Log</em> Copy If no data appears after you <em>enable</em> our <em>log</em> <em>management</em> capabilities, follow our standard <em>log</em> troubleshooting procedures. What&#x27;s next? Explore logging data across your platform with the <em>New</em> <em>Relic</em> One UI. Get deeper visibility into both your application and your platform performance data by forwarding your <em>logs</em> with our <em>logs</em> in context capabilities. Set up alerts. Query your data and create dashboards."
      },
      "id": "603ea6bb28ccbc228deba74c"
    },
    {
      "sections": [
        "Forward your logs using the infrastructure agent",
        "Basic process",
        "System requirements",
        "Important",
        "Install the infrastructure agent",
        "Configure the infrastructure agent",
        "Log forwarding parameters",
        "Name (required)",
        "Log source (required)",
        "file",
        "systemd",
        "syslog",
        "tcp",
        "winlog",
        "Optional configuration",
        "attributes",
        "attributes automatically inserted by the infrastructure agent",
        "pattern",
        "max_line_kb",
        "fluentbit",
        "Sample configuration file",
        "logging.d/sample.yaml",
        "View your log data",
        "Troubleshooting",
        "No log data",
        "No data appears when tailing a file",
        "No data appears when capturing via a Syslog socket",
        "No data appears using infrastructure agent proxy",
        "Sending the infrastructure agent's logs to New Relic",
        "Caution",
        "Fluent Bit does not start with the infra agent",
        "Runtime error on Windows",
        "Errors when tailing a large amount of log files (Linux)",
        "Uninstall log forwarding",
        "What's next?"
      ],
      "title": "Forward your logs using the infrastructure agent",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Enable log monitoring in New Relic"
      ],
      "external_id": "a1deac410f0eedfb819348524a85a73bbb9d9daf",
      "image": "https://docs.newrelic.com/static/63ba6c3dc400e3cc4fb21668d5e7ba2a/c1b63/infrastructure-lic.png",
      "url": "https://docs.newrelic.com/docs/logs/forward-logs/forward-your-logs-using-infrastructure-agent/",
      "published_at": "2021-12-08T01:44:17Z",
      "updated_at": "2021-12-04T13:38:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can forward your logs to New Relic using our infrastructure monitoring agent. This makes all of your logging data available in one location and provides deeper visibility into both your application and your platform performance data. Forwarding your logs to New Relic will give you enhanced log management capabilities to collect, process, explore, query, and alert on your log data. Basic process To forward your logs through our infrastructure monitoring agent: If you haven't already, create a New Relic account. It's free, forever. Verify the system requirements needed for configuring logs. Ensure you have installed the infrastructure agent, version 1.11.4 or higher. Create a logging.yml configuration file in the infrastructure agent's logging.d directory. Configure your log sources and other parameters. Generate some traffic and wait a few minutes, then check your account for data. Explore your log data in the Logs UI and benefit from the log attributes automatically inserted by the infrastructure agent. Here is an example of where you can see logs in context of your infrastructure monitoring details in New Relic One. System requirements To use the log forwarder of the infrastructure agent, make sure you meet the following requirements: Infrastructure agent version 1.11.4 or higher OpenSSL library 1.1.0 or higher is required by Infrastructure agent starting from 1.16.4. Built-in support for ARM64 architecture on Linux systems (in example, AWS Graviton architecture) added in Infrastructure agent 1.26.0. Important The log forwarding feature is not supported with the Docker container for infrastructure monitoring agents. The log forwarding feature is compatible with the following operating systems: Operating system Supported version Amazon Linux Amazon Linux 2 CentOS Version 7 or higher Debian Version 9 (\"Stretch\") or higher Exception: Version 11 is not supported. Red Hat Enterprise Linux (RHEL) Version 7 or higher SUSE Linux Enterprise Server (SLES) Version 12 Ubuntu Versions 16.04.x, 18.04.x and 20.04.x (LTS versions) Windows Windows Server 2012, 2016, and 2019, and their service packs. Windows 10 Install the infrastructure agent Starting with version 1.11.4, the infrastructure agent can forward logs to New Relic. To install and run the agent, use a package manager (Linux) or the MSI installer (Windows). Important The log forwarding feature is not included when the infrastructure agent is implemented using Linux tarball or Windows ZIP installations. To use the following links, make sure you are logged to your New Relic account. Amazon Linux CentOS Debian RHEL SLES Ubuntu Windows If you don't have a New Relic account yet, or if you prefer to follow the procedure manually, see our tutorial to install the package manager. Configure the infrastructure agent Configuration files describe which log sources are forwarded. Our infrastructure agent uses .yml files to configure logging. You can add as many config files as you want. To add a new configuration file for the log forwarding feature: Navigate to the log forwarder configuration folder: Linux: /etc/newrelic-infra/logging.d/ Windows: C:\\Program Files\\New Relic\\newrelic-infra\\logging.d\\ Create a logging.yml configuration file, and add the parameters you need. The logging.d directory has various .yml.example files you can use as a reference or starting point. The agent automatically processes new configuration files without having to restart the infrastructure monitoring service. The only exception to this is when configuring a custom Fluent Bit configuration. Log forwarding parameters The infrastructure log forwarding .yml config supports the following parameters: Name (required) To start, define a name of the log or logs you want to forward to New Relic. Log source (required) What you use for the log source will depend on where you want to forward your logs from. Available options include: file Path to the log file or files. The agent tracks changes on the log files in a way similar to tail -f shell. Example: logs: - name: example-log file: /var/log/example.log # Path to a single log file - name: example-log-two file: /var/log/example-two.log # Path to another single log file Copy The file parameter can point to a specific log file or multiple files by using wildcards applied to names and extensions; for example, /logs/*.log. You can use wildcards in place of directories in a file path, which can be used to tail files located in different directories. Example: logs: - name: docker-logs file: /var/lib/docker/containers/*/*.log # Path to multiple folders and files Copy Important Use of wildcards may significantly increase the number of file descriptors and inotify watches the Fluent Bit process keeps open, which can interfere with log collection if the host's file descriptor limit is reached. Tailing a large number of files may require you to increase the maximum number of file descriptors and inotify watchers allowed by the operating system. Please refer to Errors when tailing a large amount of log files for more details on how to increase them. systemd Use the systemd parameter to forward log messages that are collected by the journald daemon in Linux environments. This input type requires the agent to run in root mode. Example: logs: - name: systemd-example systemd: cupsd Copy syslog Syslog data source. Parameters: uri: Syslog socket. Format varies depending on the protocol: TCP/UDP network sockets: [tcp/udp]://LISTEN_ADDRESS:PORT Unix domain sockets: unix_[tcp/udp]:// + /socket/path parser: Syslog parser. Default is rfc3164. Use rfc5424 if your messages include fractional seconds. Note: rfc3164 currently does not work on SuSE. unix_permissions: default is 0644 for domain sockets; this limits entries to processes running as root. You can use 0666 to listen for non-root processes, at your own risk. When running the agent in privileged mode, ports and sockets must be available or owned by nri-agent, with 0666 file permissions, so that other processes can write logs to the sockets. logs: # TCP network socket - name: syslog-tcp-test syslog: uri: tcp://0.0.0.0:5140 # Use the tcp://LISTEN_ADDRESS:PORT format parser: rfc5424 # Default syslog parser is rfc3164 # UDP network socket - name: syslog-udp-test syslog: uri: udp://0.0.0.0:6140 # Use the udp://LISTEN_ADDRESS:PORT format max_line_kb: 35 # Unix TCP domain socket - name: syslog-unix-tcp-test syslog: uri: unix_tcp:///var/unix-tcp-socket-test unix_permissions: 0666 # Default is 0644. Change at your own risk # Unix UDP domain socket - name: syslog-unix-udp-test syslog: uri: unix_udp:///var/unix-udp-socket-test parser: rfc5424 Copy tcp Logs retrieved over TCP connections. Parameters: uri: TCP/IP socket to listen for incoming data. The URI format is tcp://LISTEN_ADDRESS:PORT format: format of the data. It can be json or none. separator: If format: none is used, you can define a separator string for splitting records (default: \\n). logs: - name: tcp-simple-test tcp: uri: tcp://0.0.0.0:1234 # Use the tcp://LISTEN_ADDRESS:PORT format format: none # Raw text - this is default for 'tcp' separator: \\t # String for separating raw text entries max_line_kb: 32 - name: tcp-json-test tcp: uri: tcp://0.0.0.0:2345 # Use the tcp://LISTEN_ADDRESS:PORT format format: json Copy winlog Collect events from Windows log channels. Parameters: channel: name of the channel logs will be collected from. collect-eventids: a list of Windows Event IDs to be collected and forwarded to New Relic. Event ID ranges are supported. exclude-eventids: a list of Windows Event IDs to be excluded from collection. Event ID ranges are supported. All events are collected from the specified channel by default. Configure the collect-eventids and exclude-eventids sections to avoid sending unwanted logs to your New Relic account. Add event IDs or ranges to collect-eventids or exclude-eventids to forward or drop specific events. exclude-eventids takes precedence over collect-eventids if the same event ID is present in both sections. Example: logs: # Winlog log ingestion with eventId filters. - name: windows-security winlog: channel: Security collect-eventids: - 4624 - 4265 - 4700-4800 exclude-eventids: - 4735 # entries for the application, system, powershell, and SCOM channels - name: windows-application winlog: channel: Application - name: windows-system winlog: channel: System - name: windows-pshell winlog: channel: Windows Powershell - name: scom winlog: channel: Operations Manager # Entry for Windows Defender Logs - name: windows-defender winlog: channel: Microsoft-Windows-Windows Defender/Operational # Entry for Windows Clustering Logs - name: windows-clustering winlog: channel: Microsoft-Windows-FailoverClustering/Operational # Entry for IIS logs with logtype attribute for automatic parsing - name: iis-log file: C:\\inetpub\\logs\\LogFiles\\w3svc.log attributes: logtype: iis_w3c Copy Optional configuration The following configuration parameters are not required but are still recommended. attributes List of custom attributes specified as key-value pairs that can be used to send additional data with the logs which you can then query. The attributes configuration parameter can be used with any log source. One common use of the attributes configuration parameter is to specify the logtype attribute. This attribute allows leveraging one of the built-in parsing rules supported by New Relic Logs. Example: logs: - name: example-file-attributes file: /var/log/example.log attributes: logtype: nginx region: example-us-02 team: A-team - name: example-tcp-attributes tcp: uri: tcp://0.0.0.0:2345 format: json attributes: logtype: nginx region: example-us-02 team: B-team Copy attributes automatically inserted by the infrastructure agent The infrastructure agent automatically inserts log attributes for your convenience. Some of them are inserted for any log record, while others depend on the configuration parameters you used while setting up the log forwarder. Attribute name Description entity.guids Always inserted. The infrastructure agent inserts the Entity GUID assigned by New Relic to identify the host where it's running. It is available in the entity.guids field. Note: If the captured logs belong to an application instrumented using APM, the entity.guids field contains both the entity GUID of infrastructure, as well as the GUID of APM, separated by a pipe ( | ) delimiter. fb.input Always inserted. The underlying Fluent Bit input plugin type used to capture the logs. Currently its values are tail, systemd, winlog, syslog, and tcp. filePath Inserted when sing the file input type. Absolute file path of the file being monitored. hostname Always inserted. The hostname of the machine/VM/container executing the infrastructure agent. plugin.type Always inserted. Indicates the utility used to capture the logs. In this case, it is the infrastructure agent itself, so this attribute always has the value nri-agent. pattern Regular expression for filtering records. Only supported for the tail, systemd, syslog, and tcp (only with format none) sources. This field works in a way similar to grep -E in Unix systems. For example, for a given file being captured, you can filter for records containing either WARN or ERROR using: - name: only-records-with-warn-and-error file: /var/log/logFile.log pattern: WARN|ERROR Copy No filtering is applied by default. max_line_kb Maximum size of log entries/lines in KB. If log entries exceed the limit, they are skipped. Default is 128. fluentbit External Fluent Bit configuration and parser files. If defined, they are merged with the existing configuration and parser files generated by the infrastructure agent. The infrastructure agent processes the configuration files located in the logging.d directory and will generate a run-time Fluent Bit configuration file that contains the appropriate [INPUT], [FILTER] and [OUTPUT] sections. Optionally, it will also declare an @INCLUDE in case you provided an external Fluent Bit configuration file via the fluentbit option. The runtime file does not define a [SERVICE] section, leaving all default Fluent Bit configuration values. You can still override Fluent Bit's default settings by defining your own [SERVICE] section in your external Fluent Bit configuration file and include it via the fluentbit option. Parameters: config_file: path to an existing Fluent Bit configuration file. Note that any overlapping source results in duplicate messages in New Relic Logs. parsers_file: path to an existing Fluent Bit parsers file. The following parser names are reserved: rfc3164, rfc3164-local and rfc5424. Sample configuration file Here is an example of a logging.d/ configuration file in YAML format. For more configuration examples, see the infrastructure agent repository. logging.d/sample.yaml # Remember to only use spaces for indentation logs: # Example of 'file' source - name: file-with-attributes file: /var/log/test.log # Path to a single file or pattern attributes: # You can use custom attributes to enrich your data logtype: nginx team: The A Team pattern: Error # Regular expression to filter log entries # Example of 'systemd' source (Linux only) - name: systemd-example systemd: cupsd # Examples of 'syslog' source, one per protocol # TCP network socket - name: syslog-tcp-test syslog: uri: tcp://0.0.0.0:5140 # Use the tcp://LISTEN_ADDRESS:PORT format parser: rfc5424 # Default syslog parser is rfc3164 # UDP network socket - name: syslog-udp-test syslog: uri: udp://0.0.0.0:6140 # Use the udp://LISTEN_ADDRESS:PORT format max_line_kb: 35 # Paths for Unix sockets are defined by combining protocol and path: # unix_udp:// + /path/socket - for example, unix_udp:///tmp/socket # Unix TCP domain socket - name: syslog-unix-tcp-test syslog: uri: unix_tcp:///var/unix-tcp-socket-test unix_permissions: 0666 # Default is 0644. Change at your own risk # Unix UDP domain socket - name: syslog-unix-udp-test syslog: uri: unix_udp:///var/unix-udp-socket-test parser: rfc5424 # Examples of 'tcp' source for formats 'none' and 'json' - name: tcp-simple-test tcp: uri: tcp://0.0.0.0:1234 # Use the tcp://LISTEN_ADDRESS:PORT format format: none # Raw text - this is default for 'tcp' separator: \\t # String for separating raw text entries attributes: # You can add custom attributes to any source of logs tcpFormat: none someOtherAttribute: associatedValue max_line_kb: 32 - name: tcp-json-test tcp: uri: tcp://0.0.0.0:2345 # Use the tcp://LISTEN_ADDRESS:PORT format format: json attributes: tcpFormat: json yetAnotherAttribute: 12345 # Example of Fluent Bit configuration import - name: fluentbit-import fluentbit: config_file: /path/to/fluentbit.config parsers_file: /path/to/fluentbit/parsers.conf Copy View your log data If everything is configured correctly and your data is being collected, you should see logs data in both of these places: New Relic Logs UI New Relic tools for running NRQL queries. For example, you can execute a query like this: SELECT * FROM Log Copy Troubleshooting If you encounter problems with configuring your log forwarder, try these troubleshooting tips. No log data If no data appears after you enable our log management capabilities, follow our standard log troubleshooting procedures. No data appears when tailing a file The log forwarding feature requires the agent to have permission to read the data sources. When running the infrastructure agent in privileged or non-privileged modes, make sure that the log files you want to forward (and any intermediary directory in its path) are readable by the user running nri-agent. Example: Check file access under Linux Let's check whether the file /var/log/restrictedLogs/logFile.log can be monitored by the nri-agent user. In Linux, you can do a quick check with the namei command: sudo -u nri-agent namei -ml /var/log/restrictedLogs/logFile.log f: /var/log/restrictedLogs/logFile.log drwxr-xr-x root root / drwxr-xr-x root root var drwxrwxr-x root syslog log drwxr--r-- root root restrictedLogs logFile.log - No such file or directory Copy This command failed because the file is not visible to the nri-agent user. By inspecting the previous output, we can detect that the restrictedLogs directory is missing the execution flag for others. To fix this, execute: sudo chmod 755 /var/log/restrictedLogs Copy And then check for file access again: # sudo -u nri-agent namei -ml /var/log/restrictedLogs/logFile.log f: /var/log/restrictedLogs/logFile.log drwxr-xr-x root root / drwxr-xr-x root root var drwxrwxr-x root syslog log drwxr-xr-x root root restrictedLogs -rw-r----- vagrant vagrant logFile.log Copy The file is now visible to the nri-agent user. You must ensure that the file is also readable by the nri-agent user. To check this, use: # sudo -u nri-agent head /var/log/restrictedLogs/logFile.log head: cannot open '/var/log/restrictedLogs/logFile.log' for reading: Permission denied Copy In this example, the file is missing the read rights for the others group (users other than vagrant and the vagrant user group). You could fix this by granting read permissions to others, but the application could change these permissions upon restart. To avoid this, a better approach is to add the nri-agent user to the vagrant user group. No data appears when capturing via a Syslog socket The log forwarding feature requires that the agent has permission to read the data sources. When running the infrastructure agent in privileged or non-privileged modes: If you're using Unix domain socket files, make sure that the nri-agent user can access these files (please refer to the previous section) and that they have read and write permissions (666) so that other users than nri-agent can write to them. If you're using IP sockets, ensure that the port that you are using is not a system reserved one (like port 80, for example). If no data appears after you enable log management, follow standard log management troubleshooting procedures. No data appears using infrastructure agent proxy As explained in the infrastructure agent configuration guidelines, the proxy parameter must use either HTTP or HTTPS and be in the form https://user:password@hostname:port. The agent can parse the parameter without the HTTP or HTTPS, but the log forwarder cannot. You will see an error like the following in the agent verbose logs: [ERROR] building HTTP transport: parse \\\"hostname:port\\\": first path segment in URL cannot contain colon Copy To solve this problem, check your newrelic-infra.yml file, and ensure the proxy parameter adheres to this form. If you're using caBundleFile or caBundleDir in order to specify any certificate, we recommend to follow the below rules for each OS: Linux For HTTP proxies you don't need to setup any certificates. The plugin loads the system certificates and New Relic sends logs into the logging endpoint. However, you can specify the proxy self-signed certificate (PEM file) using either the caBundleFile or caBundleDir parameters. Windows For HTTP proxies you don't need to setup any certificates. The plugin loads the system certificates. For HTTPS, you can configure it in one of the following ways: Import the proxy certificate to the system pool (Recommended) Import the proxy self-signed certificate (PEM file) by using the MMC tool. Refer to this link, and in Step 2 ensure to import it in your Trusted Root Certification Authorities, instead of in the Intermediate Certification Authorities. Using the caBundleFile and caBundleDir parameters On Windows, we cannot load both the certificates from the system certificate pool and the ones specified with the caBundleFile caBundleDir parameters. So, if you are using caBundleFile or caBundleDir, ensure that the following certificates are placed in the same PEM file (when using caBundleFile) or in the same directory (when using caBundleDir): The Proxy certificate (because it's an HTTPS proxy). The Logging Endpoint certificate (eg. https://log-api.newrelic.com/log/v1). The Infrastructure Agent certificate (eg. https://infra-api.newrelic.com). You can check the certificates by running: # openssl s_client -connect log-api.newrelic.com:443 -servername log-api.newrelic.com Copy Sending the infrastructure agent's logs to New Relic You can configure the infrastructure agent to send its own logs to New Relic. This is useful for troubleshooting issues with log forwarding, the agent, or when contacting support. To forward the infrastructure agent logs to New Relic: Edit your newrelic-infra.yml file. Enable agent logging in troubleshooting mode by adding verbose: 3. On Windows and systems that don't use systemd or where journald is inaccessible, verbose:3 causes the agent to write the logs on the disk. Revert to verbose:0 to prevent this. (Recommended): Enable agent logging in JSON format to log_format: json. Restart the agent to load the new settings. This configuration sets up the agent in troubleshooting mode, but the log forwarder (based on Fluent Bit) will continue in a non-verbose mode. Sometimes you can have issues with the log forwarder itself. For example, there may be problems accessing a specific channel when shipping Windows log events or when accessing a particular log file. In these situations, you can also enable the verbose mode for the log forwarder: Set verbose to a value other than 0. Add the configuration option: trace: [\"log.fw\"]. Caution Check whether you are using the [fluentbit] option. When setting verbose: 3 and trace: [\"log.fw\"], ensure that you don't define any [OUTPUT] section pointing to stdout in an external Fluent Bit configuration file, Fluent Bit does not start with the infra agent Important Fluent Bit's tail plugin does not support network drives. For Linux versions prior to 2016, you may need to update the OpenSSL library to 1.1.0 (or higher). To check if you have this problem: See if infra-agent has started Fluent Bit by running: ps -aux | grep fluent-bi Copy If it isn't running go to /var/db/newrelic-infra/newrelic-integrations/logging and run: ./fluent-bit -i systemd -o stdout Copy If you get the following error, update OpenSSL to 1.1.0 or higher: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory Copy Runtime error on Windows One of the following error messages may appear when enabling log forwarding on Windows: The code execution cannot proceed because VCRUNTIME140.dll was not found. Copy OR error=\"exit status 3221225781\" process=log-forwarder Copy This is caused by a missing DLL. To solve the issue, install the Microsoft Visual C++ Redistributable as applicable: x64 x86 Errors when tailing a large amount of log files (Linux) It's common to face either one of the following error messages when attempting to tail a large amount of files: Too many open files The user limit on the total number of inotify watches was reached or the kernel failed to allocate a needed resource The operating system defines a maximum amount of allocatable file descriptors (typically 1024 by default), and a maximum amount of allocatable inotify watches (typically 8192 by default). Any process attempting to go above these limits will fail, returning one of the errors above. The underlying technology we use to forward logs, Fluent Bit, opens one file descriptor and sets an inotify watch for each file you configure to be forwarded. Moreover, at the time of writing this section, Fluent Bit uses an extra set of 32 file descriptors for its normal operation, with another extra file descriptor when it shuts down. Therefore, to capture a large amount of files you need to ensure that both the file descriptor and inotify watch limits are slightly greater than the amount of log files you wish to tail. The following instructions summarize how to increase these limits if you want to tail 10,000 log files. Also, it assumes the infrastructure agent is installed in root running mode, and therefore must be run using the root user. Check which is the current hard limit for the amount of file descriptors per process. Typically, this limit should be quite high and should not need to be modified. ulimit -Hn Copy Add the following line to /etc/security/limits.conf. We specified a limit of 10100 here instead of just 10000 to allow Fluent Bit to allocate the extra file descriptors it may need to work. root soft nofile 10100 # replace root by nri-agent for non-root (privileged and unprivileged) installations Copy Add the following line to /etc/pam.d/common-session so that the previous limit is applied upon restart: session required pam_limits.so Copy Add the following line to /etc/sysctl.conf to increase the amount of allowed inotify watchers per user. We specified a limit of 18192 here instead of just 10000 so that the root user will still have 8192 available inotify watches (the default value). fs.inotify.max_user_watches=18192 Copy Restart your system. Ensure that the new limits have been enforced by running: ulimit -Sn # Should return 10100 cat /proc/sys/fs/inotify/max_user_watches # Should return 18192 Copy Learn more on how to increase open file limits, or on how to increase the inotify watches. Uninstall log forwarding To uninstall log forwarding capabilities, go to your logging.d directory, and remove files with the .yml extension that were originally added during the configuration process. Linux: /etc/newrelic-infra/logging.d/ Windows: C:\\Program Files\\New Relic\\newrelic-infra\\logging.d\\ What's next? Explore logging data across your platform with the New Relic One UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our logs in context capabilities. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 343.02704,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Forward your <em>logs</em> using the <em>infrastructure</em> agent",
        "sections": "Sending the <em>infrastructure</em> agent&#x27;s <em>logs</em> to <em>New</em> <em>Relic</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": " <em>management</em> capabilities to collect, process, explore, query, and alert on your <em>log</em> data. Basic process To forward your <em>logs</em> through our infrastructure <em>monitoring</em> agent: If you haven&#x27;t already, create a <em>New</em> <em>Relic</em> account. It&#x27;s free, forever. Verify the system requirements needed for configuring <em>logs</em>"
      },
      "id": "603e9df164441f6b6f4e8843"
    },
    {
      "sections": [
        "Stream logs using Kinesis Data Firehose",
        "Create the delivery stream for New Relic",
        "Configure your stream to send logs to EU accounts",
        "View log data",
        "What's next?"
      ],
      "title": "Stream logs using Kinesis Data Firehose",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Enable log monitoring in New Relic"
      ],
      "external_id": "5fbb75b1eb9e180f1aabfa0f0e803ae5562b5977",
      "image": "https://docs.newrelic.com/static/ef38529dfbd5e54cbe001c347c5f528b/c1b63/3rd-party-firehose.png",
      "url": "https://docs.newrelic.com/docs/logs/forward-logs/stream-logs-using-kinesis-data-firehose/",
      "published_at": "2021-12-04T21:58:41Z",
      "updated_at": "2021-11-24T09:27:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If your log data is already being monitored by Amazon CloudWatch Logs, you can use our Kinesis Data Firehose integration to forward and enrich your log data in New Relic. Kinesis Data Firehose is a service that can stream data in real time to a variety of destinations, including our platform. Forwarding your CloudWatch Logs or other logs compatible with a Kinesis stream to New Relic will give you enhanced log management capabilities to collect, process, explore, query, and alert on your log data. Create the delivery stream for New Relic To forward your logs from Kinesis Data Firehose to New Relic: Make sure you have a New Relic license key. Follow the procedures to create an Amazon Kinesis Data Firehose delivery stream, and select New Relic as the destination: In the AWS Management Console, go to Amazon Kinesis. Select Kinesis Data Firehose and click Create delivery stream. Enter a name for the stream and select your data source. When selecting the destination, click Third-party partner and then New Relic. Under HTTP endpoint URL, select New Relic logs - US from the dropdown. Note: To send your logs to the EU, complete the remaining steps in this section, then proceed to the configuration procedures for EU accounts. Paste your license key in the API key field. Configure and review the remaining settings. Configure your stream to send logs to EU accounts If you have a New Relic account in our EU data center: Follow standard procedures to create your delivery stream. Once your stream has been created, navigate to the Amazon Kinesis Console, and click Delivery streams. Click the name of your newly created delivery stream, and select the Configuration tab. Next to the Destination settings section, click Edit. Update the value for HTTP endpoint URL to our Firehose endpoint for EU accounts: https://aws-api.eu.newrelic.com/firehose/v1 Copy Click Save changes to ensure your stream is updated. View log data If everything is configured correctly and your data is being collected, you should see data logs in both of these places: New Relic Logs UI New Relic tools for running NRQL queries. For example, you can execute a query like this: SELECT * FROM Log Copy If no data appears after you enable our log management capabilities, follow our standard log troubleshooting procedures. What's next? Explore logging data across your platform with the New Relic One UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our logs in context capabilities. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 266.2047,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Stream <em>logs</em> using Kinesis Data Firehose",
        "sections": "Create the delivery stream for <em>New</em> <em>Relic</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": ". Forwarding your CloudWatch <em>Logs</em> or other <em>logs</em> compatible with a Kinesis stream to <em>New</em> <em>Relic</em> will give you enhanced <em>log</em> <em>management</em> capabilities to collect, process, explore, query, and alert on your <em>log</em> data. Create the delivery stream for <em>New</em> <em>Relic</em> To forward your <em>logs</em> from Kinesis Data Firehose to <em>New</em>"
      },
      "id": "603e96be64441f41584e8858"
    }
  ],
  "/docs/logs/get-started/get-started-log-management": [
    {
      "sections": [
        "New Relic's log management security and privacy",
        "Automatic obfuscation",
        "Customize your security settings"
      ],
      "title": "New Relic's log management security and privacy",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "Get started"
      ],
      "external_id": "719109386a9ba6d1e67aae9204911b0a1c0fb48f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/get-started/new-relics-log-management-security-privacy/",
      "published_at": "2021-12-04T21:59:18Z",
      "updated_at": "2021-11-13T21:28:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With our log management solution, you have direct control over what data is reported to New Relic. To ensure data privacy, and to limit the types of information New Relic receives, no customer data is captured except what you supply in API calls or log forwarder configuration. All data for the logs service is then reported to New Relic over HTTPS. This document describes additional security considerations for your logging data. For more information about New Relic's security measures: See our security and privacy documentation. Visit the New Relic security website. Read this blog post that explains how you can use our log management tools to gain visibility into some of the most severe threats to modern digital businesses. Automatic obfuscation The log management service automatically masks number patterns that appear to be for items such as credit cards or Social Security numbers. All integers, including spaces and hyphens that may be used as delimiters, are replaced with a string of Xes. Numbers that appear to be a credit card (thirteen to sixteen digits) are obfuscated as XXXXXXXXXXXXXXXX. For example: Numbers with hyphens, such as 4111-1111-1111-1111 Numbers with spaces, such as 4111 1111 1111 1111 Numbers with thirteen (Visa), fourteen (Diner's Club), fifteen (American Express, JCB), or sixteen digits (Visa, Mastercard, Discover, JCB), such as 4111111111111111 Nine-digit numbers with hyphens that appear to be Social Security numbers, such as 123-45-6789, are obfuscated as XXXXXXXXX. Nine-digit numbers with spaces, such as 123 45 6789, or hyphens in a different pattern, such as 12-345-67-89, are not automatically obfuscated. If you need to opt out of automatic obfuscation, get support at support.newrelic.com. Customize your security settings The data you send to New Relic, including any additional filtering, is controlled by the configuration of the log forwarder you use. You control what customer data is logged, so be sure to follow your organization's security guidelines to mask, obfuscate, or prevent sending any sensitive data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.77707,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic&#x27;s <em>log</em> <em>management</em> security and privacy",
        "sections": "New Relic&#x27;s <em>log</em> <em>management</em> security and privacy",
        "tags": "<em>Log</em> <em>management</em>",
        "body": "With our <em>log</em> <em>management</em> solution, you have direct control over what data is reported to New Relic. To ensure data privacy, and to limit the types of information New Relic receives, no customer data is captured except what you supply in API calls or <em>log</em> forwarder configuration. All data for the <em>logs</em>"
      },
      "id": "603ea3dc64441f0bc14e884f"
    },
    {
      "sections": [
        "PHP: Configure logs in context",
        "Set up your PHP app",
        "PHP configuration with Monolog",
        "Tip",
        "PHP configuration with other log forwarders",
        "What's next?"
      ],
      "title": "PHP: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context for PHP"
      ],
      "external_id": "bddc3ec75de7bde2b5eff995d85d11715fd61be9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/configure-logs-context-php/",
      "published_at": "2021-12-04T22:02:35Z",
      "updated_at": "2021-12-04T22:02:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the PHP agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your PHP app To enable logs in context for APM apps monitored by PHP: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest PHP agent version, and enable distributed tracing. Use PHP agent version 9.13.0.270 or higher for logs in context. Install Monolog version 1 or 2, or use a compatible log forwarding plugin if you are not using the built-in Monolog Handler for New Relic. Configure logs in context for PHP using the Monolog extension, if used. PHP configuration with Monolog You must install the Monolog log enricher package before you can configure Monolog for New Relic logs in context. This is done by using Composer to install the newrelic/monolog-enricher package. In most cases, use the Processor and Handler classes provided by the log enricher package in conjunction with Monolog's built-in BufferHandler. The Processor adds the contextual metadata required for New Relic logs in context to operate. The Handler sends the log records to New Relic Logs. The BufferHandler ensures that the logs are delivered with as little overhead as possible. At the point where you create the Monolog\\Logger object, add the following pushProcessor and pushHandler calls to add the Processor and Handler: <?php use Monolog\\Handler\\BufferHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Handler, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $log->pushHandler(new BufferHandler(new Handler)); Copy Tip You can use the Processor and Handler in conjunction with any existing Monolog setup. You do not need to remove your existing processors and handlers. PHP configuration with other log forwarders If you use Monolog to send logs to a compatible log forwarder, and if you have already configured that tool to send logs to New Relic, you can use the Processor and Formatter solely for that tool. This option prevents additional overhead of sending logs directly to New Relic with the Handler. You will need to be using a handler that supports the setFormatter() method, and your logging tool must be able to ingest JSON logs. Here's an example of configuring Monolog to handle other log forwarders: <?php use Monolog\\Handler\\StreamHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Formatter, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $handler = new StreamHandler('php://stderr'); $handler->setFormatter(new Formatter); $log->pushHandler($handler); Copy To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. If the logs from your application do not include fields like trace.id and span.id, there may be a problem with the configuration of the Monolog log enricher. In this situation: Check that the PHP agent for your app has been installed and is configured to enable distributed tracing. Check that your application is using the Monolog logger object when sending log records, not syslog(). Check that another Monolog handler is not preventing the log record from bubbling. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. View your logs in context data in distributed tracing. Note that for PHP, logs in context data doesn't appear in the Logs tab of the APM UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.33813,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "PHP: Configure <em>logs</em> in context",
        "sections": "PHP: Configure <em>logs</em> in context",
        "tags": "Enable <em>log</em> <em>management</em> in New Relic",
        "body": "<em>Logs</em> in context for the PHP agent connects your <em>logs</em> and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly <em>get</em> to the root cause of an issue and find the <em>log</em> lines that you need to identify and resolve a problem. Set up your PHP app To enable <em>logs</em>"
      },
      "id": "612b7ab4196a6714904948ae"
    },
    {
      "sections": [
        "Use APM agent APIs with logs in context",
        "APM agent trace metadata and linking metadata APIs",
        "Resources for correctly annotating logs"
      ],
      "title": "Use APM agent APIs with logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context with agent APIs"
      ],
      "external_id": "ebc829a1c1b74c866f5326f90a6d5119fdcfae10",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/annotate-logs-logs-context-using-apm-agent-apis/",
      "published_at": "2021-12-06T01:43:28Z",
      "updated_at": "2021-12-04T22:00:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To correlate log data with other telemetry data, such as errors and distributed traces in APM, you can use our logs in context solutions. If your logging framework is not available with our existing logs in context solutions, you can configure your logging libraries by using API calls to annotate your logs. APM agent trace metadata and linking metadata APIs To get properly annotated logs for logs in context, use the following API calls for your APM agent. These APIs pass the required trace metadata and linking metadata to link your log data to other New Relic data. APM agent APIs: APM agent API calls C SDK (n/a) See our Log API documentation. Go GetTraceMetadata GetLinkingMetadata Java getTraceMetadata getLinkingMetadata .NET TraceMetadata GetLinkingMetadata Node.js newrelic.getTraceMetadata newrelic.getLinkingMetadata PHP newrelic_get_trace_metadata newrelic_get_linking_metadata For PHP, logs in context is only supported from the distributed tracing UI, not in the Logs tab of the APM UI. Python get_linking_metadata Ruby linking_metadata current_trace_id current_span_id Resources for correctly annotating logs For more information about using the trace metadata and linking metadata APIs to annotate logs for logs in context, review the APM agent specifications in GitHub. These specifications include the required fields and properly formatted output. Also, review the source code for our own logs in context extensions to see how we use these APIs: C SDK: n/a Go: Logrus extension Java: Log4j2 extension .NET: Serilog extension Node.js: Winston extension PHP: Monolog extension Python: Streamhandler example Ruby: logging.rb extension",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.33035,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use APM agent APIs with <em>logs</em> in context",
        "sections": "Use APM agent APIs with <em>logs</em> in context",
        "tags": "Enable <em>log</em> <em>management</em> in New Relic",
        "body": " your <em>logs</em>. APM agent trace metadata and linking metadata APIs To <em>get</em> properly annotated <em>logs</em> for <em>logs</em> in context, use the following API calls for your APM agent. These APIs pass the required trace metadata and linking metadata to link your <em>log</em> data to other New Relic data. APM agent APIs: APM agent"
      },
      "id": "61505693196a670394b70d61"
    }
  ],
  "/docs/logs/get-started/new-relics-log-management-security-privacy": [
    {
      "sections": [
        "Get started with log management",
        "Find problems faster, reduce context switching",
        "Bring in your logging data",
        "View your logging data in New Relic",
        "What's next"
      ],
      "title": "Get started with log management",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "Get started"
      ],
      "external_id": "1335d59906e840e38d6ef8572c31baea338f0b49",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/get-started/get-started-log-management/",
      "published_at": "2021-12-04T21:59:18Z",
      "updated_at": "2021-11-13T21:28:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "As applications move towards the cloud, microservices architecture is becoming more dispersed, making the ability to monitor logs essential. New Relic offers a fast, scalable log management platform so you can connect your logs with the rest of your telemetry and infrastructure data in a single place. See how it works with this video (approx. 2 minutes). Our log management solution provides deeper visibility into application and infrastructure performance data (events and errors) to reduce mean-time-to-resolve (MTTR) and quickly troubleshoot production incidents. Find problems faster, reduce context switching Log management provides a way to connect your log data with the rest of your application and infrastructure data. You can get to the root cause of problems quickly, without losing context switching between tools. Log management features include: Instantly search through your logs. Visualize your log data directly from the Logs UI. Use logging data to create custom charts, dashboards, and alerts. Troubleshoot performance issues without switching between tools. Visualize everything in a single place. Bring in your logging data To forward your log data to New Relic, you can: Use our infrastructure monitoring agent as a lightweight data collector, without having to install additional software. Select from a wide range of log forwarding plugins, including Amazon, Microsoft, Fluentd, Fluent Bit, Kubernetes, Logstash, and more. Use our OpenTelemetry solutions. Send your log data by using the Log API or TCP endpoint. Once log management is enabled, you can also connect your logs with your APM agent, Kubernetes clusters, or distributed tracing to get additional contextual logging data with our logs in context extensions. View your logging data in New Relic You can explore your logging data in the UI or by API: Logs UI at one.newrelic.com Logs UI for EU region data center if applicable: one.eu.newrelic.com You can also query the Log data type. For example, use NRQL to run: SELECT * FROM Log Copy You can also use NerdGraph, our GraphQL-format API, to request the exact data you need. What's next Ready to get started with our log management solutions? If you don't have one already, create a New Relic account. It's free, forever. Forward your logs to New Relic. Recommendation: Use our infrastructure agent as your log forwarder, so you can get logs in context of your platform and services directly in our UI. For apps monitored by a New Relic APM agent, configure logs in context. Explore the logging data across your platform with our Logs UI in New Relic One, where you can add alerts, query your data, and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.7764,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> <em>started</em> with <em>log</em> <em>management</em>",
        "sections": "<em>Get</em> <em>started</em> with <em>log</em> <em>management</em>",
        "tags": "<em>Log</em> <em>management</em>",
        "body": " data you need. What&#x27;s next Ready to <em>get</em> <em>started</em> with our <em>log</em> <em>management</em> solutions? If you don&#x27;t have one already, create a New Relic account. It&#x27;s free, forever. Forward your <em>logs</em> to New Relic. Recommendation: Use our infrastructure agent as your <em>log</em> forwarder, so you can <em>get</em> <em>logs</em> in context of your"
      },
      "id": "603ea62ee7b9d249432a07e2"
    },
    {
      "sections": [
        "PHP: Configure logs in context",
        "Set up your PHP app",
        "PHP configuration with Monolog",
        "Tip",
        "PHP configuration with other log forwarders",
        "What's next?"
      ],
      "title": "PHP: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context for PHP"
      ],
      "external_id": "bddc3ec75de7bde2b5eff995d85d11715fd61be9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/configure-logs-context-php/",
      "published_at": "2021-12-04T22:02:35Z",
      "updated_at": "2021-12-04T22:02:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the PHP agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your PHP app To enable logs in context for APM apps monitored by PHP: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest PHP agent version, and enable distributed tracing. Use PHP agent version 9.13.0.270 or higher for logs in context. Install Monolog version 1 or 2, or use a compatible log forwarding plugin if you are not using the built-in Monolog Handler for New Relic. Configure logs in context for PHP using the Monolog extension, if used. PHP configuration with Monolog You must install the Monolog log enricher package before you can configure Monolog for New Relic logs in context. This is done by using Composer to install the newrelic/monolog-enricher package. In most cases, use the Processor and Handler classes provided by the log enricher package in conjunction with Monolog's built-in BufferHandler. The Processor adds the contextual metadata required for New Relic logs in context to operate. The Handler sends the log records to New Relic Logs. The BufferHandler ensures that the logs are delivered with as little overhead as possible. At the point where you create the Monolog\\Logger object, add the following pushProcessor and pushHandler calls to add the Processor and Handler: <?php use Monolog\\Handler\\BufferHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Handler, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $log->pushHandler(new BufferHandler(new Handler)); Copy Tip You can use the Processor and Handler in conjunction with any existing Monolog setup. You do not need to remove your existing processors and handlers. PHP configuration with other log forwarders If you use Monolog to send logs to a compatible log forwarder, and if you have already configured that tool to send logs to New Relic, you can use the Processor and Formatter solely for that tool. This option prevents additional overhead of sending logs directly to New Relic with the Handler. You will need to be using a handler that supports the setFormatter() method, and your logging tool must be able to ingest JSON logs. Here's an example of configuring Monolog to handle other log forwarders: <?php use Monolog\\Handler\\StreamHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Formatter, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $handler = new StreamHandler('php://stderr'); $handler->setFormatter(new Formatter); $log->pushHandler($handler); Copy To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. If the logs from your application do not include fields like trace.id and span.id, there may be a problem with the configuration of the Monolog log enricher. In this situation: Check that the PHP agent for your app has been installed and is configured to enable distributed tracing. Check that your application is using the Monolog logger object when sending log records, not syslog(). Check that another Monolog handler is not preventing the log record from bubbling. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. View your logs in context data in distributed tracing. Note that for PHP, logs in context data doesn't appear in the Logs tab of the APM UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.33813,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "PHP: Configure <em>logs</em> in context",
        "sections": "PHP: Configure <em>logs</em> in context",
        "tags": "Enable <em>log</em> <em>management</em> in New Relic",
        "body": "<em>Logs</em> in context for the PHP agent connects your <em>logs</em> and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly <em>get</em> to the root cause of an issue and find the <em>log</em> lines that you need to identify and resolve a problem. Set up your PHP app To enable <em>logs</em>"
      },
      "id": "612b7ab4196a6714904948ae"
    },
    {
      "sections": [
        "Use APM agent APIs with logs in context",
        "APM agent trace metadata and linking metadata APIs",
        "Resources for correctly annotating logs"
      ],
      "title": "Use APM agent APIs with logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context with agent APIs"
      ],
      "external_id": "ebc829a1c1b74c866f5326f90a6d5119fdcfae10",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/annotate-logs-logs-context-using-apm-agent-apis/",
      "published_at": "2021-12-06T01:43:28Z",
      "updated_at": "2021-12-04T22:00:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To correlate log data with other telemetry data, such as errors and distributed traces in APM, you can use our logs in context solutions. If your logging framework is not available with our existing logs in context solutions, you can configure your logging libraries by using API calls to annotate your logs. APM agent trace metadata and linking metadata APIs To get properly annotated logs for logs in context, use the following API calls for your APM agent. These APIs pass the required trace metadata and linking metadata to link your log data to other New Relic data. APM agent APIs: APM agent API calls C SDK (n/a) See our Log API documentation. Go GetTraceMetadata GetLinkingMetadata Java getTraceMetadata getLinkingMetadata .NET TraceMetadata GetLinkingMetadata Node.js newrelic.getTraceMetadata newrelic.getLinkingMetadata PHP newrelic_get_trace_metadata newrelic_get_linking_metadata For PHP, logs in context is only supported from the distributed tracing UI, not in the Logs tab of the APM UI. Python get_linking_metadata Ruby linking_metadata current_trace_id current_span_id Resources for correctly annotating logs For more information about using the trace metadata and linking metadata APIs to annotate logs for logs in context, review the APM agent specifications in GitHub. These specifications include the required fields and properly formatted output. Also, review the source code for our own logs in context extensions to see how we use these APIs: C SDK: n/a Go: Logrus extension Java: Log4j2 extension .NET: Serilog extension Node.js: Winston extension PHP: Monolog extension Python: Streamhandler example Ruby: logging.rb extension",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.33035,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use APM agent APIs with <em>logs</em> in context",
        "sections": "Use APM agent APIs with <em>logs</em> in context",
        "tags": "Enable <em>log</em> <em>management</em> in New Relic",
        "body": " your <em>logs</em>. APM agent trace metadata and linking metadata APIs To <em>get</em> properly annotated <em>logs</em> for <em>logs</em> in context, use the following API calls for your APM agent. These APIs pass the required trace metadata and linking metadata to link your <em>log</em> data to other New Relic data. APM agent APIs: APM agent"
      },
      "id": "61505693196a670394b70d61"
    }
  ],
  "/docs/logs/index": [
    {
      "sections": [
        "PHP: Configure logs in context",
        "Set up your PHP app",
        "PHP configuration with Monolog",
        "Tip",
        "PHP configuration with other log forwarders",
        "What's next?"
      ],
      "title": "PHP: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context for PHP"
      ],
      "external_id": "bddc3ec75de7bde2b5eff995d85d11715fd61be9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/configure-logs-context-php/",
      "published_at": "2021-12-04T22:02:35Z",
      "updated_at": "2021-12-04T22:02:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the PHP agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your PHP app To enable logs in context for APM apps monitored by PHP: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest PHP agent version, and enable distributed tracing. Use PHP agent version 9.13.0.270 or higher for logs in context. Install Monolog version 1 or 2, or use a compatible log forwarding plugin if you are not using the built-in Monolog Handler for New Relic. Configure logs in context for PHP using the Monolog extension, if used. PHP configuration with Monolog You must install the Monolog log enricher package before you can configure Monolog for New Relic logs in context. This is done by using Composer to install the newrelic/monolog-enricher package. In most cases, use the Processor and Handler classes provided by the log enricher package in conjunction with Monolog's built-in BufferHandler. The Processor adds the contextual metadata required for New Relic logs in context to operate. The Handler sends the log records to New Relic Logs. The BufferHandler ensures that the logs are delivered with as little overhead as possible. At the point where you create the Monolog\\Logger object, add the following pushProcessor and pushHandler calls to add the Processor and Handler: <?php use Monolog\\Handler\\BufferHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Handler, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $log->pushHandler(new BufferHandler(new Handler)); Copy Tip You can use the Processor and Handler in conjunction with any existing Monolog setup. You do not need to remove your existing processors and handlers. PHP configuration with other log forwarders If you use Monolog to send logs to a compatible log forwarder, and if you have already configured that tool to send logs to New Relic, you can use the Processor and Formatter solely for that tool. This option prevents additional overhead of sending logs directly to New Relic with the Handler. You will need to be using a handler that supports the setFormatter() method, and your logging tool must be able to ingest JSON logs. Here's an example of configuring Monolog to handle other log forwarders: <?php use Monolog\\Handler\\StreamHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Formatter, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $handler = new StreamHandler('php://stderr'); $handler->setFormatter(new Formatter); $log->pushHandler($handler); Copy To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. If the logs from your application do not include fields like trace.id and span.id, there may be a problem with the configuration of the Monolog log enricher. In this situation: Check that the PHP agent for your app has been installed and is configured to enable distributed tracing. Check that your application is using the Monolog logger object when sending log records, not syslog(). Check that another Monolog handler is not preventing the log record from bubbling. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. View your logs in context data in distributed tracing. Note that for PHP, logs in context data doesn't appear in the Logs tab of the APM UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 67.993034,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "PHP: Configure <em>logs</em> in context",
        "sections": "PHP: Configure <em>logs</em> in context",
        "tags": "<em>Logs</em>",
        "body": "<em>Logs</em> in context for the PHP agent connects your <em>logs</em> and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the <em>log</em> lines that you need to identify and resolve a problem. Set up your PHP app To enable <em>logs</em>"
      },
      "id": "612b7ab4196a6714904948ae"
    },
    {
      "sections": [
        "Use APM agent APIs with logs in context",
        "APM agent trace metadata and linking metadata APIs",
        "Resources for correctly annotating logs"
      ],
      "title": "Use APM agent APIs with logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context with agent APIs"
      ],
      "external_id": "ebc829a1c1b74c866f5326f90a6d5119fdcfae10",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/annotate-logs-logs-context-using-apm-agent-apis/",
      "published_at": "2021-12-06T01:43:28Z",
      "updated_at": "2021-12-04T22:00:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To correlate log data with other telemetry data, such as errors and distributed traces in APM, you can use our logs in context solutions. If your logging framework is not available with our existing logs in context solutions, you can configure your logging libraries by using API calls to annotate your logs. APM agent trace metadata and linking metadata APIs To get properly annotated logs for logs in context, use the following API calls for your APM agent. These APIs pass the required trace metadata and linking metadata to link your log data to other New Relic data. APM agent APIs: APM agent API calls C SDK (n/a) See our Log API documentation. Go GetTraceMetadata GetLinkingMetadata Java getTraceMetadata getLinkingMetadata .NET TraceMetadata GetLinkingMetadata Node.js newrelic.getTraceMetadata newrelic.getLinkingMetadata PHP newrelic_get_trace_metadata newrelic_get_linking_metadata For PHP, logs in context is only supported from the distributed tracing UI, not in the Logs tab of the APM UI. Python get_linking_metadata Ruby linking_metadata current_trace_id current_span_id Resources for correctly annotating logs For more information about using the trace metadata and linking metadata APIs to annotate logs for logs in context, review the APM agent specifications in GitHub. These specifications include the required fields and properly formatted output. Also, review the source code for our own logs in context extensions to see how we use these APIs: C SDK: n/a Go: Logrus extension Java: Log4j2 extension .NET: Serilog extension Node.js: Winston extension PHP: Monolog extension Python: Streamhandler example Ruby: logging.rb extension",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 67.98921,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use APM agent APIs with <em>logs</em> in context",
        "sections": "Use APM agent APIs with <em>logs</em> in context",
        "tags": "<em>Logs</em>",
        "body": "To correlate <em>log</em> data with other telemetry data, such as errors and distributed traces in APM, you can use our <em>logs</em> in context solutions. If your logging framework is not available with our existing <em>logs</em> in context solutions, you can configure your logging libraries by using API calls to annotate"
      },
      "id": "61505693196a670394b70d61"
    },
    {
      "sections": [
        "AWS Lambda for sending CloudWatch logs",
        "Install and configure the Cloudwatch logs Lambda function",
        "Create a Lambda trigger",
        "Configure retries (optional)",
        "Tip",
        "Resources created by the SAM template",
        "View log data",
        "What's next?"
      ],
      "title": "AWS Lambda for sending CloudWatch logs",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Enable log monitoring in New Relic"
      ],
      "external_id": "69c310375d48a667779ffabead6f920eb6a34004",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/forward-logs/aws-lambda-sending-cloudwatch-logs/",
      "published_at": "2021-12-04T21:55:34Z",
      "updated_at": "2021-12-04T21:55:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can send your Amazon CloudWatch logs to New Relic using our AWS Lambda function, newrelic-log-ingestion. This can be easily deployed from the AWS Serverless application repository. Forwarding your CloudWatch logs to New Relic will give you enhanced log management capabilities to collect, process, explore, query, and alert on your log data. Install and configure the Cloudwatch logs Lambda function The following setup shows one approach for configuring environment variables. You can also configure them from the Functions page. Complete the following: Make sure you have a New Relic license key. Open the AWS Serverless Application Repository in your browser. Search for newrelic and check Show apps that create custom IAM roles or resource policies to find newrelic-log-ingestion. Open the newrelic-log-ingestion details and click Deploy. In the function's Configure menu, go to Environment Variables and configure log forwarding using the following environment variables: Key Description DEBUG_LOGGING_ENABLED A boolean to determine if you want to output debug messages in the CloudWatch console. Optional. To turn on debug logs, set this to true. Default is false. LICENSE_KEY New Relic license key is used for sending data to New Relic. Required. LOGGING_ENABLED Determines if logs are forwarded to New Relic. Required. To turn on logging, set this to true. NR_LOGGING_ENDPOINT New Relic ingestion endpoint for logs. Required. Two endpoints are available: US: https://log-api.newrelic.com/log/v1 EU: https://log-api.eu.newrelic.com/log/v1 NR_TAGS Specify tags to be added to all log events. Optional. Each tag is composed of a colon-delimited key and value. Multiple key-value pairs are semicolon-delimited; for example, env:prod;team:myTeam. Acknowledge that the app creates custom IAM roles, and then click Deploy. Once the process completes, create a Lambda trigger to link your Lambda function to CloudWatch logs. Create a Lambda trigger To get your logs streaming to New Relic, attach a trigger to the Lambda: From the left side menu, select Functions. Find and select the previously created newrelic-log-ingestion function. Under Designer, click Add Triggers, and select Cloudwatch Logs from the dropdown. Select the the appropriate Log group for your application. Enter a name for your filter. Optional: Enter a filter pattern. Check the Enable trigger checkbox, then click Add to create the trigger. Configure retries (optional) You can configure the number of retries you want to perform in case the function fails to send the data in case of communication issues. Recommended number is 3 retries, but you can change the retry behavior by changing the below parameters: Tip The more the number of retries there are can make the function run for longer times. This increases the probability of having higher costs for Lambda. However, decreasing the number of retries could increase the probability of data loss. MAX_RETRIES = 3 # Defines the number of retries after lambda failure to deliver data INITIAL_BACKOFF = 1 # Defines the initial wait seconds until next retry is executed BACKOFF_MULTIPLIER = 2 # Time multiplier between the retries As an example, in default above configuration, first retry will happen after 1 second, second retry after 2 seconds and third retry will happen after 4 seconds. Copy Resources created by the SAM template When you create the application from the repository, the following resources are also created: The Lambda function itself A role used to give execution permissions to the Lambda function based in CloudWatch Logs. All other Lambda configurations not listed can be left as the defaults. View log data If everything is configured correctly and your data is being collected, you should see data logs in both of these places: New Relic Logs UI New Relic tools for running NRQL queries. For example, you can execute a query like this: SELECT * FROM Log Copy If no data appears after you enable our log management capabilities, follow our standard log troubleshooting procedures. What's next? Explore logging data across your platform with the New Relic One UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our logs in context capabilities. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 57.105583,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "AWS Lambda for sending CloudWatch <em>logs</em>",
        "sections": "AWS Lambda for sending CloudWatch <em>logs</em>",
        "tags": "<em>Logs</em>",
        "body": "You can send your Amazon CloudWatch <em>logs</em> to New Relic using our AWS Lambda function, newrelic-<em>log</em>-ingestion. This can be easily deployed from the AWS Serverless application repository. Forwarding your CloudWatch <em>logs</em> to New Relic will give you enhanced <em>log</em> management capabilities to collect"
      },
      "id": "603ea6bb28ccbc228deba74c"
    }
  ],
  "/docs/logs/log-api/introduction-log-api": [
    {
      "sections": [
        "Use TCP endpoint to forward logs to New Relic",
        "Compatibility and requirements",
        "Important",
        "Configure rsyslog",
        "Legacy config file for rsyslog 7 or earlier",
        "Configure syslog-ng",
        "Tip"
      ],
      "title": "Use TCP endpoint to forward logs to New Relic",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "Log API"
      ],
      "external_id": "8eb69d218bfcc3dd6a27ac28de97146f00672361",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/log-api/use-tcp-endpoint-forward-logs-new-relic/",
      "published_at": "2021-12-04T22:00:43Z",
      "updated_at": "2021-11-13T21:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We offer a wide range of solutions to get your log data into New Relic. But in other situations where you don't have log forwarders (such as CDNs, hardware devices, or managed services), you can use syslog protocols via a TCP endpoint. You can forward your logs to New Relic using syslog clients such as rsyslog and syslog-ng. Compatibility and requirements To forward logs to New Relic using a syslog client, you need: A valid New Relic license key for the account you want to send logs to Some minor changes to the syslog client's configuration, as explained in this document Important Currently, our syslog endpoint only supports accounts in our US data center. Configure rsyslog To forward logs to New Relic with rsyslog: Install packages required to allow rsyslog to send logs using TLS encryption: sudo yum install rsyslog-gnutls ca-certificates Copy Optional: Configure rsyslog to tail log files and forward their contents to New Relic. Add the following to the /etc/rsyslog.conf file in order to enable its text file input module: module(load=\"imfile\" PollingInterval=\"10\" statefile.directory=\"/var/spool/rsyslog\" ) Copy In the /etc/rsyslog.d/ directory, create a text file named newrelic.conf. Explicitly include the newly created newrelic.conf to the /etc/rsyslog.d/ file: include(file=\"/etc/rsyslog.conf.d/newrelic.conf\") Copy Add the following to newrelic.conf, replacing YOUR_LICENSE_KEY with your New Relic license key: ## Specify each of the files to be tailed in case step 1 is done input(type=\"imfile\" ruleset=\"infiles\" Tag=\"<YOUR_FILE_TAG>\" File=\"<PATH_TO_FILE>\" StateFile=\"<UNIQUE_STATEFILE_NAME >\") ## Template expected by the New Relic Syslog endpoint template(name=\"newrelic-rfc5424\" type=\"string\" string=\"<YOUR_LICENSE_KEY> <%pri%>%protocol-version% %timestamp:::date-rfc3339% %hostname% %app-name% %procid% %msgid% %structured-data% %msg%\\n\" ) ## Configure TLS and log forwarding global(DefaultNetstreamDriver=\"gtls\" DefaultNetstreamDriverCAFile=\"/etc/ssl/certs/ca-certificates.crt\" ) action(type=\"omfwd\" Target=\"newrelic.syslog.nr-data.net\" Port=\"6514\" Protocol=\"tcp\" Template=\"newrelic-rfc5424\" ResendLastMSGOnReconnect=\"on\" StreamDriver=\"gtls\" StreamDriverAuthMode=\"x509/name\" StreamDriverPermittedPeers=\"*.syslog.nr-data.net\" StreamDriverMode=\"1\" ) Copy Restart the rsyslog service by running: sudo systemctl restart rsyslog Copy Check your New Relic account for logs. Legacy config file for rsyslog 7 or earlier If you are using rsyslog version 7 or below, the configuration files need to be adapted to the obsolete legacy format. This format is only kept for retro compatibility purposes. We strongly recommend to avoid using it, as stated in the rsyslog documentation. Install packages required to allow rsyslog to send logs using TLS encryption: sudo yum install rsyslog-gnutls ca-certificates Copy Optional: Configure rsyslog to tail log files and forward their contents to New Relic. Add the following to the /etc/rsyslog.conf file in order to enable its text file input module: $ModLoad imfile $InputFilePollInterval 10 $PrivDropToGroup adm $WorkDirectory /var/spool/rsyslog Copy In the /etc/rsyslog.d/ directory, create a text file named newrelic.conf. Explicitly include the newly created newrelic.conf to the /etc/rsyslog.d/ file: $IncludeConfig /etc/rsyslog.conf.d/newrelic.conf Copy Add the following to newrelic.conf, replacing `YOUR_LICENSE_KEY with your New Relic license key: ## Template expected by the New Relic Syslog endpoint $template NRLogFormat,\"YOUR_LICENSE_KEY <%pri%>%protocol-version% %timestamp:::date-rfc3339% %hostname% %app-name% %procid% %msgid% %structured-data% %msg%\\n\" ## Specify each of the files to be tailed in case step 1 is done $InputFileName /path/to/file $InputFileTag <YOUR_FILE_TAG> $InputFileStateFile <UNIQUE_STATEFILE_NAME> $InputFileSeverity info $InputRunFileMonitor ## Configure TLS and log forwarding $DefaultNetstreamDriverCAFile /etc/ssl/certs/ca-certificates.crt $ActionSendStreamDriver gtls $ActionSendStreamDriverMode 1 $ActionSendStreamDriverAuthMode x509/name $ActionSendStreamDriverPermittedPeer *.syslog.nr-data.net *.* @@newrelic.syslog.nr-data.net:6514;NRLogFormat Copy Restart the rsyslog service by running: sudo systemctl restart rsyslog Copy Check your New Relic account for logs. Configure syslog-ng To forward logs to New Relic with syslog-ng: Install ca-certificates required to allow syslog-ng to send logs using TLS encryption: sudo yum install ca-certificates Copy Open the syslog-ng configuration file (/etc/syslog-ng/syslog-ng.conf) in a text editor. Define the sources to be monitored by adding: source s_src { internal(); }; Copy Optional: Configure syslog-ng to tail files by adding the following to the Sources configuration block: source s_files { file(\"<PATH_TO_FILE>\"); }; Copy Define the New Relic syslog format and add your New Relic license key: template NRFormat { template(\"YOUR_LICENSE_KEY <${PRI}>1 ${ISODATE} ${HOST:--} ${PROGRAM:--} ${PID:--} ${MSGID:--} ${SDATA:--} $MSG\\n\"); template_escape(no); }; Copy Add the New Relic Syslog endpoint: destination d_newrelic { network(\"newrelic.syslog.nr-data.net\" port(6514) transport(\"tls\") tls(peer-verify(no)) template(NRFormat) ); }; Copy Add the following output to the log path configuration block: log { source(s_src); source(s_files); ## in case step 4 is implemented. destination(d_newrelic); }; Copy Restart syslog-ng by running: sudo service syslog-ng restart Copy Check your New Relic account for logs. Tip If you are running syslog-ng from a Docker container and experience issues, check balait/syslog image documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 201.6568,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use TCP endpoint to forward <em>logs</em> to New Relic",
        "sections": "Use TCP endpoint to forward <em>logs</em> to New Relic",
        "tags": "<em>Log</em> <em>management</em>",
        "body": "We offer a wide range of solutions to get your <em>log</em> data into New Relic. But in other situations where you don&#x27;t have <em>log</em> forwarders (such as CDNs, hardware devices, or managed services), you can use syslog protocols via a TCP endpoint. You can forward your <em>logs</em> to New Relic using syslog clients"
      },
      "id": "603e7d6764441f1a774e88a0"
    },
    {
      "sections": [
        "Use APM agent APIs with logs in context",
        "APM agent trace metadata and linking metadata APIs",
        "Resources for correctly annotating logs"
      ],
      "title": "Use APM agent APIs with logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context with agent APIs"
      ],
      "external_id": "ebc829a1c1b74c866f5326f90a6d5119fdcfae10",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/annotate-logs-logs-context-using-apm-agent-apis/",
      "published_at": "2021-12-06T01:43:28Z",
      "updated_at": "2021-12-04T22:00:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To correlate log data with other telemetry data, such as errors and distributed traces in APM, you can use our logs in context solutions. If your logging framework is not available with our existing logs in context solutions, you can configure your logging libraries by using API calls to annotate your logs. APM agent trace metadata and linking metadata APIs To get properly annotated logs for logs in context, use the following API calls for your APM agent. These APIs pass the required trace metadata and linking metadata to link your log data to other New Relic data. APM agent APIs: APM agent API calls C SDK (n/a) See our Log API documentation. Go GetTraceMetadata GetLinkingMetadata Java getTraceMetadata getLinkingMetadata .NET TraceMetadata GetLinkingMetadata Node.js newrelic.getTraceMetadata newrelic.getLinkingMetadata PHP newrelic_get_trace_metadata newrelic_get_linking_metadata For PHP, logs in context is only supported from the distributed tracing UI, not in the Logs tab of the APM UI. Python get_linking_metadata Ruby linking_metadata current_trace_id current_span_id Resources for correctly annotating logs For more information about using the trace metadata and linking metadata APIs to annotate logs for logs in context, review the APM agent specifications in GitHub. These specifications include the required fields and properly formatted output. Also, review the source code for our own logs in context extensions to see how we use these APIs: C SDK: n/a Go: Logrus extension Java: Log4j2 extension .NET: Serilog extension Node.js: Winston extension PHP: Monolog extension Python: Streamhandler example Ruby: logging.rb extension",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.29031,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use APM agent <em>APIs</em> with <em>logs</em> in context",
        "sections": "Use APM agent <em>APIs</em> with <em>logs</em> in context",
        "tags": "Enable <em>log</em> <em>management</em> in New Relic",
        "body": "To correlate <em>log</em> data with other telemetry data, such as errors and distributed traces in APM, you can use our <em>logs</em> in context solutions. If your logging framework is not available with our existing <em>logs</em> in context solutions, you can configure your logging libraries by using <em>API</em> calls to annotate"
      },
      "id": "61505693196a670394b70d61"
    },
    {
      "sections": [
        "AWS Lambda for sending CloudWatch logs",
        "Install and configure the Cloudwatch logs Lambda function",
        "Create a Lambda trigger",
        "Configure retries (optional)",
        "Tip",
        "Resources created by the SAM template",
        "View log data",
        "What's next?"
      ],
      "title": "AWS Lambda for sending CloudWatch logs",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Enable log monitoring in New Relic"
      ],
      "external_id": "69c310375d48a667779ffabead6f920eb6a34004",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/forward-logs/aws-lambda-sending-cloudwatch-logs/",
      "published_at": "2021-12-04T21:55:34Z",
      "updated_at": "2021-12-04T21:55:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can send your Amazon CloudWatch logs to New Relic using our AWS Lambda function, newrelic-log-ingestion. This can be easily deployed from the AWS Serverless application repository. Forwarding your CloudWatch logs to New Relic will give you enhanced log management capabilities to collect, process, explore, query, and alert on your log data. Install and configure the Cloudwatch logs Lambda function The following setup shows one approach for configuring environment variables. You can also configure them from the Functions page. Complete the following: Make sure you have a New Relic license key. Open the AWS Serverless Application Repository in your browser. Search for newrelic and check Show apps that create custom IAM roles or resource policies to find newrelic-log-ingestion. Open the newrelic-log-ingestion details and click Deploy. In the function's Configure menu, go to Environment Variables and configure log forwarding using the following environment variables: Key Description DEBUG_LOGGING_ENABLED A boolean to determine if you want to output debug messages in the CloudWatch console. Optional. To turn on debug logs, set this to true. Default is false. LICENSE_KEY New Relic license key is used for sending data to New Relic. Required. LOGGING_ENABLED Determines if logs are forwarded to New Relic. Required. To turn on logging, set this to true. NR_LOGGING_ENDPOINT New Relic ingestion endpoint for logs. Required. Two endpoints are available: US: https://log-api.newrelic.com/log/v1 EU: https://log-api.eu.newrelic.com/log/v1 NR_TAGS Specify tags to be added to all log events. Optional. Each tag is composed of a colon-delimited key and value. Multiple key-value pairs are semicolon-delimited; for example, env:prod;team:myTeam. Acknowledge that the app creates custom IAM roles, and then click Deploy. Once the process completes, create a Lambda trigger to link your Lambda function to CloudWatch logs. Create a Lambda trigger To get your logs streaming to New Relic, attach a trigger to the Lambda: From the left side menu, select Functions. Find and select the previously created newrelic-log-ingestion function. Under Designer, click Add Triggers, and select Cloudwatch Logs from the dropdown. Select the the appropriate Log group for your application. Enter a name for your filter. Optional: Enter a filter pattern. Check the Enable trigger checkbox, then click Add to create the trigger. Configure retries (optional) You can configure the number of retries you want to perform in case the function fails to send the data in case of communication issues. Recommended number is 3 retries, but you can change the retry behavior by changing the below parameters: Tip The more the number of retries there are can make the function run for longer times. This increases the probability of having higher costs for Lambda. However, decreasing the number of retries could increase the probability of data loss. MAX_RETRIES = 3 # Defines the number of retries after lambda failure to deliver data INITIAL_BACKOFF = 1 # Defines the initial wait seconds until next retry is executed BACKOFF_MULTIPLIER = 2 # Time multiplier between the retries As an example, in default above configuration, first retry will happen after 1 second, second retry after 2 seconds and third retry will happen after 4 seconds. Copy Resources created by the SAM template When you create the application from the repository, the following resources are also created: The Lambda function itself A role used to give execution permissions to the Lambda function based in CloudWatch Logs. All other Lambda configurations not listed can be left as the defaults. View log data If everything is configured correctly and your data is being collected, you should see data logs in both of these places: New Relic Logs UI New Relic tools for running NRQL queries. For example, you can execute a query like this: SELECT * FROM Log Copy If no data appears after you enable our log management capabilities, follow our standard log troubleshooting procedures. What's next? Explore logging data across your platform with the New Relic One UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our logs in context capabilities. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 161.33907,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "AWS Lambda for sending CloudWatch <em>logs</em>",
        "sections": "AWS Lambda for sending CloudWatch <em>logs</em>",
        "tags": "Enable <em>log</em> <em>management</em> in New Relic",
        "body": "You can send your Amazon CloudWatch <em>logs</em> to New Relic using our AWS Lambda function, newrelic-<em>log</em>-ingestion. This can be easily deployed from the AWS Serverless application repository. Forwarding your CloudWatch <em>logs</em> to New Relic will give you enhanced <em>log</em> <em>management</em> capabilities to collect"
      },
      "id": "603ea6bb28ccbc228deba74c"
    }
  ],
  "/docs/logs/log-api/log-event-data": [
    {
      "sections": [
        "Find data in long logs (blobs)",
        "How blobs work",
        "Tip",
        "Query your data for blobs",
        "Data retention for long logs"
      ],
      "title": "Find data in long logs (blobs)",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "413651f55060d47b3b2c3a939d9f4f576467e405",
      "image": "https://docs.newrelic.com/static/25249afab9ba5695a0764e676d14dfb3/c1b63/log-blob-query.png",
      "url": "https://docs.newrelic.com/docs/logs/ui-data/long-logs-blobs/",
      "published_at": "2021-12-04T22:05:37Z",
      "updated_at": "2021-11-14T08:46:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Extensive log data can help you troubleshoot issues. But what if an attribute in your log contains thousands of characters? How much of this data can New Relic store? And how can you find useful information in all this data? How blobs work For lengthy string values that are longer than can be stored in NRDB (4,094 characters), we store the long string in three pieces: Long log sections Description First 4,094 characters The first 4,094 characters are stored in a Log event field with the same name. So a long message value would have its first 4,094 characters stored in a message field. Next 128,000 UTF-8 bytes The next 128,000 UTF-8 bytes of the string are stored in a blob field with the name with newrelic.ext. prepended. So a long message value would have characters past the first 4,094 characters stored in a newrelic.ext.message field as a blob. The actual number of characters stored depends on the UTF-8 representation of the characters. UTF-8 represents Unicode characters as one to four bytes, so we will store anywhere between 32,000 and 128,000 characters past the first 4,094 characters. Remaining characters Any characters past 4,094 characters plus 128,000 bytes are dropped and not stored. So the long message field would be stored as: message: <first 4,094 characters as a string> newrelic.ext.message: <next 128,000 bytes as a 'blob'> Copy Tip You can search the first 4,094 characters of a string attribute. You can also create alerts for the first 4,094 characters. However, since 'blob' storage is not searchable, text beyond the first 4,094 characters is not searchable or alertable. Query your data for blobs To query for any log data in New Relic, run the following query: SELECT * FROM Log Copy To expand the blob data, run the following query, using message or any other attribute. Be sure to enclose the blob's attribute with backticks. For example: SELECT message, another-attribute, blob(`newrelic.ext.message`), blob(`newrelic.ext.another-attribute) FROM Log Copy To query extended blob data in your logs, be sure to include backticks in your attribute's blob syntax. This expands the data in the blob so you can see (but not search) it. For example, New Relic returns: { \"message\": <first 4,094 characters> \"newrelic.ext.message\": <the next 128,000 bytes as Base64> \"another-attribute\": <first 4,094 characters> \"newrelic.ext.another-attribute\": <the next 128,000 bytes as Base64> } Copy The Logs UI automatically stitches the original value back together when looking at the Log Detail View. When querying using NRQL directly, you need to manually stitch the information together by: Decoding the Base64 of the newrelic.ext. attribute value Converting the resulting UTF-8 into a string Appending that string to the first 4,094 characters in the \"main\" attribute Data retention for long logs NRDB retains your blob records for a month. If you have existing long log messages stored as LogExtendedRecord, that data will also continue to be available for a month in NRDB. After a month passes, no more new LogExtendedRecord attributes will be created. They will all be stored in NRDB as blobs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.90727,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Find <em>data</em> in long <em>logs</em> (blobs)",
        "sections": "Find <em>data</em> in long <em>logs</em> (blobs)",
        "tags": "<em>Log</em> <em>management</em>",
        "body": " other attribute. Be sure to enclose the blob&#x27;s attribute with backticks. For example: SELECT message, another-attribute, blob(`newrelic.ext.message`), blob(`newrelic.ext.another-attribute) FROM <em>Log</em> Copy To query extended blob <em>data</em> in your <em>logs</em>, be sure to include backticks in your attribute&#x27;s blob"
      },
      "id": "6150569228ccbcf314f21423"
    },
    {
      "sections": [
        "Organize data with partitions",
        "Plan your partition",
        "Important",
        "Required roles and permissions",
        "Sizing and organizing a partition",
        "Choosing a namespace",
        "Create partition rules",
        "Search data partitions",
        "Manage data partitions programatically with NerdGraph"
      ],
      "title": "Organize data with partitions",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "620ba43370a8ca4900a02cd4ccc6fefa7f5cf8d7",
      "image": "https://docs.newrelic.com/static/7815845d8068377477aa26f8571d5907/c1b63/log-partitions-crop.png",
      "url": "https://docs.newrelic.com/docs/logs/ui-data/data-partitions/",
      "published_at": "2021-12-04T22:05:01Z",
      "updated_at": "2021-11-14T07:18:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Data partitions are a way to group or organize log data for faster and more efficient querying. When a query targets a single partition, New Relic's Logs UI: Scans less unrelated data. Returns results faster. Accounts can have multiple partitions, and multiple partitions can be queried at the same time. Data partitions also allow data to be mapped to an alternative, or “secondary” namespace with a fixed 30-day retention. This is useful for maintaining compliance with privacy-centric regulations and standards like the General Data Protection Regulation (GDPR). Plan your partition Before you start creating partitions, make sure you have the right permissions and a partition plan. Important Logs are routed to partitions during the ingestion process, before data is written to NRDB. Partition rules will not affect logs that were ingested before the rule was created. Required roles and permissions Users require an Admin role to create and modify partition rules. Sizing and organizing a partition You can gain significant performance improvements with proper use of data partitions. Organizing your data into discrete partitions enables you to query them separately or all together. The goals of partitioning your data should be: Create data partitions that align with concepts in your environment or organization that are static or change infrequently (for example, by business unit, team, environment, service, etc.). Ensure each partition remains below 1 TB of daily ingest for optimal performance. Having more partitions allows for more targeted searches, but creating too many partitions can make logs hard to find and increase administrative overhead. Finding the right balance is important. We support 100 partitions maximum per account, but the optimal number for most accounts is 10 to 15 partitions. Choosing a namespace A partition’s namespace determines its retention period. We offer two retention options: Standard: The account’s default retention determined by your New Relic subscription. This is the maximum retention period available in your account and is the namespace you'll select for most of your partitions. Secondary: 30-day retention. All logs sent to a partition that's a member of the Secondary namespace will be purged on a rolling basis 30 days after having been ingested. Secondary retention is not a cost control mechanism; data is billed on ingest. Create partition rules From the left nav in the Logs UI, select Data partitions, then create a Log_ partition name with the retention namespace, optional description, and matching criteria. To create a new partition rule: Go to one.newrelic.com > Logs. From Manage Data on the left nav of the Logs UI, click Data partitions, then click Create partition rule. Define a Partition name as an alphanumeric string that begins with Log_. Add an optional description. Select the retention namespace for the partition. Set your rule's Matching criteria: Select EQUALS to target logs that match your criteria exactly, or select LIKE to apply a fuzzy match. Click the Enable Rule slider, and click Create. To view a list of data partitions: From Manage Data on the left nav of the Logs UI, click Data partitions. Search data partitions The default partition for all Logs accounts is Log. Any log that is not affected by a partition rule will be stored in the Log partition by default. You can query multiple partitions simultaneously. For best performance, select the smallest number of partitions possible. To search data partitions: From Views and Attributes on the left nav of the Logs UI, click Select partitions. Click one or more partitions you want to query, or search for a partition name. Click Query logs to search your selected partitions. Manage data partitions programatically with NerdGraph If you want to manage your data partitions programatically, you can use NerdGraph, our GraphQL-format API. This tutorial shows how to query, create, and delete data partitions using our API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.80017,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Organize <em>data</em> with partitions",
        "sections": "<em>Manage</em> <em>data</em> partitions programatically with NerdGraph",
        "tags": "<em>Log</em> <em>management</em>",
        "body": "<em>Data</em> partitions are a way to group or organize <em>log</em> <em>data</em> for faster and more efficient querying. When a query targets a single partition, New Relic&#x27;s <em>Logs</em> <em>UI</em>: Scans less unrelated <em>data</em>. Returns results faster. Accounts can have multiple partitions, and multiple partitions can be queried at the same"
      },
      "id": "6087e311e7b9d2f90ba5c6a4"
    },
    {
      "sections": [
        "Built-in log parsing rules",
        "Apache",
        "Application Load Balancer",
        "Cloudfront",
        "Elastic Load Balancer",
        "Microsoft IIS",
        "Monit",
        "MySQL Error",
        "NGINX",
        "NGINX Error",
        "Route 53",
        "Syslog RFC-5424"
      ],
      "title": "Built-in log parsing rules",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "ae238defe10615c8767ea24f74b3c416190f4b49",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/ui-data/built-log-parsing-rules/",
      "published_at": "2021-12-04T22:06:50Z",
      "updated_at": "2021-11-14T07:16:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic can parse common log formats according to built-in rules, so that you don't have to create your own parsing rules. Here are the log parsing rules, their Grok patterns, and what fields are parsed. To enable built-in log parsing, see our documentation for adding the logtype attribute. To manage your parsing rules programmatically, use NerdGraph, our GraphQL-format API, at api.newrelic.com/graphiql. For more information, see the NerdGraph tutorial to create, query, and delete your parsing rules. Apache Source: logtype = 'apache' Grok: %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \\[%{HTTPDATE:timestamp}\\] \"(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})\" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer} %{QS:agent} Copy Results: clientip: The IP address of the client. verb: The HTTP verb ident: The user identity of the client making the request response: The HTTP status code of the response request: The URI and request being made httpversion: The HTTP version of the request rawrequest: The raw HTTP request if data is posted bytes: The number of bytes sent referrer: The HTTP referrer agent: The client's user agent Application Load Balancer Source: logtype = 'alb' Grok: ^%{NOTSPACE:type} %{TIMESTAMP_ISO8601:time} %{NOTSPACE:elb} %{NOTSPACE:client_ip}:%{NOTSPACE:client_port} ((%{NOTSPACE:target_ip}:%{NOTSPACE:target_port})|-) %{NOTSPACE:request_processing_time} %{NOTSPACE:target_processing_time} %{NOTSPACE:response_processing_time} %{NOTSPACE:elb_status_code} %{NOTSPACE:target_status_code} %{NOTSPACE:received_bytes} %{NOTSPACE:sent_bytes} \"%{DATA:request}\" \"%{DATA:user_agent}\" %{NOTSPACE:ssl_cipher} %{NOTSPACE:ssl_protocol} %{NOTSPACE:target_group_arn} \"%{DATA:trace_id}\" \"%{NOTSPACE:domain_name}\" \"%{NOTSPACE:chosen_cert_arn}\" %{NOTSPACE:matched_rule_priority} %{TIMESTAMP_ISO8601:request_creation_time} \"%{NOTSPACE:actions_executed}\" \"%{NOTSPACE:redirect_url}\" \"%{NOTSPACE:error_reason}\" (?:\"|)%{DATA:target_port_list}(?:\"|) (?:\"|)%{DATA:target_status_code_list}(?:\"|) \"%{NOTSPACE:classification}\" \"%{NOTSPACE:classification_reason}\" Copy Results: Field Definition type The type of request or connection. Possible values are: http: HTTP https: HTTP over SSL/TLS h2: HTTP/2 over SSL/TLS ws: WebSockets wss: WebSockets over SSL/TLS elb The resource ID of the load balancer. If you are parsing access log entries, note that resources IDs can contain forward slashes (/). client The IP address and port of the requesting client target The IP address and port of the target that processed this request. If the client didn't send a full request, the load balancer can't dispatch the request to a target, and this value is set to -. If the target is a Lambda function, this value is set to -. If the request is blocked by AWS WAF, this value is set to -, and the value of elb_status_code is set to 403. request_processing_time The total time elapsed (in seconds, with millisecond precision) from the time the load balancer received the request until the time it sent it to a target. This value is set to -1 if the load balancer can't dispatch the request to a target. This can happen if the target closes the connection before the idle timeout or if the client sends a malformed request. This value can also be set to -1 if the registered target does not respond before the idle timeout. target_processing_time The total time elapsed (in seconds, with millisecond precision) from the time the load balancer sent the request to a target until the target started to send the response headers. This value is set to -1 if the load balancer can't dispatch the request to a target. This can happen if the target closes the connection before the idle timeout or if the client sends a malformed request. This value can also be set to -1 if the registered target does not respond before the idle timeout. response_processing_time The total time elapsed (in seconds, with millisecond precision) from the time the load balancer received the response header from the target until it started to send the response to the client. This includes both the queuing time at the load balancer and the connection acquisition time from the load balancer to the client. This value is set to -1 if the load balancer can't send the request to a target. This can happen if the target closes the connection before the idle timeout or if the client sends a malformed request. elb_status_code The status code of the response from the load balancer target_status_code The status code of the response from the target. This value is recorded only if a connection was established to the target and the target sent a response. Otherwise, it is set to -. received_bytes The size of the request, in bytes, received from the client (requester). For HTTP requests, this includes the headers. For WebSockets, this is the total number of bytes received from the client on the connection. sent_bytes The size of the response, in bytes, sent to the client (requester). For HTTP requests, this includes the headers. For WebSockets, this is the total number of bytes sent to the client on the connection. method The HTTP verb of the request uri The URI the request was targeting http_version The HTTP version number of the request user_agent User-Agent string that identifies the client that originated the request, enclosed in double quotes. The string consists of one or more product identifiers, product/version. If the string is longer than 8 KB, it is truncated. ssl_cipher The SSL cipher. This value is set to - if the listener is not an HTTPS listener. ssl_protocol The SSL protocol. This value is set to - if the listener is not an HTTPS listener. target_group_arn The Amazon Resource Name (ARN) of the target group trace_id The contents of the X-Amzn-Trace-Id header, enclosed in double quotes domain_name The SNI domain provided by the client during the TLS handshake, enclosed in double quotes. This value is set to - if the client doesn't support SNI or the domain doesn't match a certificate and the default certificate is presented to the client. chosen_cert_arn The ARN of the certificate presented to the client, enclosed in double quotes. Set to session-reused if the session is reused. Set to - if the listener is not an HTTPS listener. matched_rule_priority The priority value of the rule that matched the request. If a rule matched, this is a value from 1 to 50000. If no rule matched and the default action was taken, this value is set to 0. If an error occurs during rules evaluation, it is set to -1. For any other error, it is set to -. request_creation_time The time when the load balancer received the request from the client, in ISO 8601 format. actions_executed The actions taken when processing the request, enclosed in double quotes. This value is a comma-separated list that can include the values described in actions_taken. If no action was taken, such as for a malformed request, this value is set to -. redirect_url The URL of the redirect target for the location header of the HTTP response, enclosed in double quotes. If no redirect actions were taken, this value is set to -. error_reason The error reason code, enclosed in double quotes. If the request failed, this is one of the error codes described in Error Reason Codes. If the actions taken do not include an authenticate action or the target is not a Lambda function, this value is set to -. Cloudfront Source: logtype = 'cloudfront-web' Grok: ^%{NOTSPACE:date}%{SPACE}%{NOTSPACE:time}%{SPACE}%{NOTSPACE:x_edge_location}%{SPACE}%{NOTSPACE:sc_bytes}%{SPACE}%{NOTSPACE:c_ip}%{SPACE}%{NOTSPACE:cs_method}%{SPACE}%{NOTSPACE:cs_host}%{SPACE}%{NOTSPACE:cs_uri_stem}%{SPACE}%{NOTSPACE:sc_status}%{SPACE}%{NOTSPACE:cs_referer}%{SPACE}%{NOTSPACE:cs_user_agent}%{SPACE}%{NOTSPACE:cs_uri_query}%{SPACE}%{NOTSPACE:cs_Cookie}%{SPACE}%{NOTSPACE:x_edge_result_type}%{SPACE}%{NOTSPACE:x_edge_request_id}%{SPACE}%{NOTSPACE:x_host_header}%{SPACE}%{NOTSPACE:cs_protocol}%{SPACE}%{NOTSPACE:cs_bytes}%{SPACE}%{NOTSPACE:time_taken}%{SPACE}%{NOTSPACE:x_forwarded_for}%{SPACE}%{NOTSPACE:ssl_protocol}%{SPACE}%{NOTSPACE:ssl_cipher}%{SPACE}%{NOTSPACE:x_edge_response_result_type}%{SPACE}%{NOTSPACE:cs_protocol_version}%{SPACE}%{NOTSPACE:fle_status}%{SPACE}%{NOTSPACE:fle_encrypted_fields}%{SPACE}%{NOTSPACE:c_port}%{SPACE}%{NOTSPACE:time_to_first_byte}%{SPACE}%{NOTSPACE:x_edge_detailed_result_type}%{SPACE}%{NOTSPACE:sc_content_type}%{SPACE}%{NOTSPACE:sc_content_len}%{SPACE}%{NOTSPACE:sc_range_start}%{SPACE}%{NOTSPACE:sc_range_end} Copy Results: Field Definition x_edge_location The edge location that served the request. Each edge location is identified by a three-letter code and an arbitrarily assigned number; for example, DFW3. The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.) sc_bytes The total number of bytes that CloudFront served to the viewer in response to the request, including headers; for example, 1045619. For WebSocket connections, this is the total number of bytes sent from the server to the client through the connection. c_ip The IP address of the viewer that made the request, either in IPv4 or IPv6 format. If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip is the IP address of the proxy or load balancer. See also X-Forwarded-For. cs_method The HTTP request method: DELETE, GET, HEAD, OPTIONS, PATCH, POST, or PUT. cs_host The domain name of the CloudFront distribution; for example, d111111abcdef8.cloudfront.net. cs_uri_stem The portion of the URI that identifies the path and object; for example, /images/cat.jpg. Question marks in URLs and query strings are not included. sc_status An HTTP status code; for example, 200. Status code 000 indicates the viewer closed the connection (for example, closed the browser tab) before CloudFront could respond to a request. If the viewer closes the connection after CloudFront starts to send the response, the log contains the applicable HTTP status code. cs_referer The name of the domain that originated the request. Common referrers include search engines, other websites that link directly to your objects, and your own website. cs_user_agent The value of the User-Agent header in the request. The User-Agent header identifies the source of the request, such as the type of device and browser that submitted the request, and which search engine if applicable. cs_uri_query The query string portion of the URI, if any. When a URI doesn't contain a query string, this field's value is a hyphen (-). cs_cookie The cookie header in the request, including name-value pairs and the associated attributes. If you enable cookie logging, CloudFront logs the cookies in all requests regardless of which cookies you choose to forward to the origin. If a request doesn't include a cookie header, this field's value is a hyphen (-). x_edge_result_type How CloudFront classifies the response after the last byte left the edge location. In some cases, the result type can change between the time that CloudFront is ready to send the response and the time that CloudFront has finished sending the response. x_edge_request_id An encrypted string that uniquely identifies a request. In the response header, this is x-amz-cf-id. x_host_header The value that the viewer included in the Host header for this request. This is the domain name in the request. If you're using the CloudFront domain name in your object URLs, this field contains that domain name. If you're using alternate domain names in your object URLs, such as http://example.com/logo.png, this field contains the alternate domain name, such as example.com. To use alternate domain names, you must add them to your distribution. cs_protocol The protocol that the viewer specified in the request: http, https, ws, or wss. cs_bytes The number of bytes of data that the viewer included in the request, including headers. For WebSocket connections, this is the total number of bytes sent from the client to the server on the connection. time_taken The number of seconds (to the thousandth of a second; for example, 0.002) between the time that a CloudFront edge server receives a viewer's request and the time that CloudFront writes the last byte of the response to the edge server's output queue as measured on the server. From the perspective of the viewer, the total time to get the full object will be longer than this value due to network latency and TCP buffering. x_forwarded_for If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip in field 5 is the IP address of the proxy or load balancer. In that case, this field is the IP address of the viewer that originated the request. This field contains IPv4 and IPv6 addresses as applicable. If the viewer did not use an HTTP proxy or a load balancer, the value of x_forwarded_for is a hyphen (-). ssl_protocol When cs_protocol in field 17 is https, this field contains the SSL/TLS protocol that the client and CloudFront negotiated for transmitting the request and response. Possible values include: SSLv3 TLSv1 TLSv1.1 TLSv1.2 When cs_protocol in field 17 is http, the value for this field is a hyphen (-). ssl_cipher When cs_protocol in field 17 is https, this field contains the SSL/TLS cipher that the client and CloudFront negotiated for encrypting the request and response. Possible values include: ECDHE-RSA-AES128-GCM-SHA256 ECDHE-RSA-AES128-SHA256 ECDHE-RSA-AES128-SHA ECDHE-RSA-AES256-GCM-SHA384 ECDHE-RSA-AES256-SHA384 ECDHE-RSA-AES256-SHA AES128-GCM-SHA256 AES256-GCM-SHA384 AES128-SHA256 AES256-SHA AES128-SHA DES-CBC3-SHA RC4-MD5 When cs_protocol in field 17 is http, the value for this field is a hyphen (-). x_edge_response_result_type How CloudFront classified the response just before returning the response to the viewer. Possible values include: Hit: CloudFront served the object to the viewer from the edge cache. RefreshHit: CloudFront found the object in the edge cache but it had expired, so CloudFront contacted the origin to verify that the cache has the latest version of the object. Miss: The request could not be satisfied by an object in the edge cache, so CloudFront forwarded the request to the origin server and returned the result to the viewer. LimitExceeded: The request was denied because a CloudFront limit was exceeded. CapacityExceeded: CloudFront returned a 503 error because the edge location didn't have enough capacity at the time of the request to serve the object. Error: Typically this means the request resulted in a client error (sc_status is 4xx) or a server error (sc_status is 5xx). If the value of x_edge_result_type is Error and the value of this field is not Error, the client disconnected before finishing the download. Redirect: CloudFront redirects from HTTP to HTTPS. If sc_status is 403 and you configured CloudFront to restrict the geographic distribution of your content, the request might have come from a restricted location. cs_protocol_version The HTTP version that the viewer specified in the request. Possible values include: HTTP/0.9 HTTP/1.0 HTTP/1.1 HTTP/2.0 fle_status When field-level encryption is configured for a distribution, this field contains a code that indicates whether the request body was successfully processed. If field-level encryption is not configured for the distribution, the value is a hyphen (-). fle-encrypted-fields The number of fields that CloudFront encrypted and forwarded to the origin. CloudFront streams the processed request to the origin as it encrypts data, so fle-encrypted-fields can have a value even if the value of fle-status is an error. If field-level encryption is not configured for the distribution, the value of fle-encrypted-fields is a hyphen (-). c_port The port number of the request from the viewer. time_to_first_byte The number of seconds between receiving the request and writing the first byte of the response, as measured on the server. x_edge_detailed_result_type When x-edge-result-type is not Error, this field contains the same value as x-edge-result-type. When x-edge-result-type is Error, this field contains the specific type of error. sc_content_type The value of the HTTP Content-Type header of the response. sc_content_len The value of the HTTP Content-Length header of the response. sc_range_start When the response contains the HTTP Content-Range header, this field contains the range start value. sc-range-end When the response contains the HTTP Content-Range header, this field contains the range end value. Elastic Load Balancer Source: logtype = 'elb' Grok: ^%{TIMESTAMP_ISO8601:time} %{NOTSPACE:elb} %{NOTSPACE:client_ip}:%{NOTSPACE:client_port} ((%{NOTSPACE:backend_ip}:%{NOTSPACE:backend_port})|-) %{NOTSPACE:request_processing_time} %{NOTSPACE:backend_processing_time} %{NOTSPACE:response_processing_time} %{NOTSPACE:elb_status_code} %{NOTSPACE:backend_status_code} %{NOTSPACE:received_bytes} %{NOTSPACE:sent_bytes} \"%{DATA:request}\" \"%{DATA:user_agent}\" %{NOTSPACE:ssl_cipher} %{NOTSPACE:ssl_protocol} Copy Results: Field Definition x_edge_location The edge location that served the request. Each edge location is identified by a three-letter code and an arbitrarily assigned number; for example, DFW3. The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.) sc_bytes The total number of bytes that CloudFront served to the viewer in response to the request, including headers; for example, 1045619. For WebSocket connections, this is the total number of bytes sent from the server to the client through the connection. c_ip The IP address of the viewer that made the request. If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip is the IP address of the proxy or load balancer. cs_method The HTTP request method: DELETE, GET, HEAD, OPTIONS, PATCH, POST, or PUT. cs_host The domain name of the CloudFront distribution; for example, d111111abcdef8.cloudfront.net. cs_uri_stem The portion of the URI that identifies the path and object; for example, /images/cat.jpg. Question marks (?) in URLs and query strings are not included in the log. sc_status An HTTP status code (for example, 200). Status code 000 indicates that the viewer closed the connection (for example, closed the browser tab) before CloudFront could respond to a request. If the viewer closes the connection after CloudFront starts to send the response, the log contains the applicable HTTP status code. cs_referer he name of the domain that originated the request. Common referrers include search engines, other websites that link directly to your objects, and your own website. cs_user_agent The value of the User-Agent header in the request. The User-Agent header identifies the source of the request, such as the type of device and browser that submitted the request and which search engine if applicable. cs_uri_query The query string portion of the URI, if any. When a URI doesn't contain a query string, this field's value is a hyphen (-). cs_cookie The cookie header in the request, including name-value pairs and the associated attributes. If you enable cookie logging, CloudFront logs the cookies in all requests, regardless of which cookies you choose to forward to the origin. If a request doesn't include a cookie header, this field's value is a hyphen (-). x_edge_result_type How CloudFront classifies the response after the last byte left the edge location. In some cases, the result type can change between the time that CloudFront is ready to send the response and the time that CloudFront has finished sending the response. x_edge_request_id An encrypted string that uniquely identifies a request. In the response header, this is x-amz-cf-id. x_host_header The value that the viewer included in the Host header for this request. This is the domain name in the request. If you're using the CloudFront domain name in your object URLs, this field contains that domain name. If you're using alternate domain names in your object URLs, such as [http://example.com/logo.png, this field contains the alternate domain name, such as example.com. To use alternate domain names, you must add them to your distribution. cs_protocol The protocol that the viewer specified in the request: http, https, ws, or wss. cs_bytes The number of bytes of data that the viewer included in the request, including headers. For WebSocket connections, this is the total number of bytes sent from the client to the server on the connection. time_taken The number of seconds (to the thousandth of a second; for example, 0.002) between the time that a CloudFront edge server receives a viewer's request and the time that CloudFront writes the last byte of the response to the edge server's output queue as measured on the server. From the perspective of the viewer, the total time to get the full object will be longer than this value due to network latency and TCP buffering. x_forwarded_for If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip in field 5 is the IP address of the proxy or load balancer. In that case, this field is the IP address of the viewer that originated the request. This field contains IPv4 and IPv6 addresses as applicable. If the viewer did not use an HTTP proxy or a load balancer, the value of x_forwarded_for is a hyphen (-). ssl_protocol When cs_protocol in field 17 is https, this field contains the SSL/TLS protocol that the client and CloudFront negotiated for transmitting the request and response. Possible values include: SSLv3 TLSv1 TLSv1.1 TLSv1.2 When cs_protocol in field 17 is http, the value for this field is a hyphen (-). ssl_cipher When cs_protocol in field 17 is https, this field contains the SSL/TLS cipher that the client and CloudFront negotiated for encrypting the request and response. Possible values include: ECDHE-RSA-AES128-GCM-SHA256 ECDHE-RSA-AES128-SHA256 ECDHE-RSA-AES128-SHA ECDHE-RSA-AES256-GCM-SHA384 ECDHE-RSA-AES256-SHA384 ECDHE-RSA-AES256-SHA AES128-GCM-SHA256 AES256-GCM-SHA384 AES128-SHA256 AES256-SHA AES128-SHA DES-CBC3-SHA RC4-MD5 When cs_protocol is http, the value for this field is a hyphen (-). x_edge_response_result_type How CloudFront classified the response just before returning the response to the viewer. Possible values include: Hit: CloudFront served the object to the viewer from the edge cache. RefreshHit: CloudFront found the object in the edge cache but it had expired, so CloudFront contacted the origin to verify that the cache has the latest version of the object. Miss: The request could not be satisfied by an object in the edge cache, so CloudFront forwarded the request to the origin server and returned the result to the viewer. LimitExceeded: The request was denied because a CloudFront limit was exceeded. CapacityExceeded: CloudFront returned a 503 error because the edge location didn't have enough capacity at the time of the request to serve the object. Error: Typically this means the request resulted in a client error (sc_status is 4xx) or a server error (sc_status is 5xx). If the value of x_edge_result_type is Error and the value of this field is not Error, the client disconnected before finishing the download. Redirect: CloudFront redirects from HTTP to HTTPS. If sc_status is 403 and you configured CloudFront to restrict the geographic distribution of your content, the request might have come from a restricted location. cs_protocol_version The HTTP version that the viewer specified in the request. Possible values include: HTTP/0.9 HTTP/1.0 HTTP/1.1 HTTP/2.0 fle_status When field-level encryption is configured for a distribution, this field contains a code that indicates whether the request body was successfully processed. If field-level encryption is not configured for the distribution, the value of this field is a hyphen (-). When CloudFront successfully processes the request body, encrypts values in the specified fields, and forwards the request to the origin, the value of this field is Processed. The value of x_edge_result_type can still indicate a client-side or server-side error in this case. If the request exceeds a field-level encryption limit, fle-status contains one of the following error codes, and CloudFront returns HTTP status code 400 to the viewer. fle-encrypted-fields The number of fields that CloudFront encrypted and forwarded to the origin. CloudFront streams the processed request to the origin as it encrypts data, so fle_encrypted_fields can have a value even if the value of fle_status is an error. If field-level encryption is not configured for the distribution, the value of fle_encrypted_fields is a hyphen (-). c_port The port number of the request from the viewer. time_to_first_byte The number of seconds between receiving the request and writing the first byte of the response, as measured on the server. x_edge_detailed_result_type When x_edge_result_type is not Error, this field contains the same value as x_edge_result_type. When x_edge_result_type is Error, this field contains the specific type of error. sc_content_type The value of the HTTP Content-Type header of the response. sc_content_len The value of the HTTP Content-Length header of the response. sc_range_start When the response contains the HTTP Content-Range header, this field contains the range start value. sc-range-end When the response contains the HTTP Content-Range header, this field contains the range end value. Microsoft IIS Source: logtype = 'iis_w3c' Grok: %{TIMESTAMP_ISO8601:log_timestamp} %{NOTSPACE:server_ip} %{WORD:method} %{NOTSPACE:uri} %{NOTSPACE:uri_query} %{NOTSPACE:server_port} %{NOTSPACE:username} %{NOTSPACE:client_ip} %{NOTSPACE:user_agent} %{NOTSPACE:referer} %{NOTSPACE:status} %{NOTSPACE:substatus} %{NOTSPACE:win32_status} %{NOTSPACE:time_taken} Copy Monit Source: logtype = 'monit' Grok: \\\\[%{NOTSPACE:tz} %{SYSLOGTIMESTAMP:nr_timestamp}\\\\] %{WORD:state}%{SPACE}: %{GREEDYDATA:message} Copy Results: state: The severity of the log line message: The message MySQL Error Source: logtype = 'mysql-error' Grok: \\\\[%{WORD:log_level}\\\\] Copy Results: log_level: The severity of the log line NGINX Source: logtype = 'nginx' Grok: %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \\[%{HTTPDATE:timestamp}\\] \"(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})\" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer} %{QS:agent} Copy Results: clientip: The IP address of the client verb: The HTTP verb ident: The user identity of the client making the request response: The HTTP status code of the response request: The URI and request being made httpversion: The HTTP version of the request rawrequest: The raw HTTP request if data is posted bytes: The number of bytes sent referrer: The HTTP referrer agent: The client's user agent NGINX Error Source: logtype = 'nginx-error' Grok: ^(?<timestamp>%{YEAR:year}[./-]%{MONTHNUM:month}[./-]%{MONTHDAY:day}[- ]%{TIME:time}) \\\\[%{LOGLEVEL:severity}\\\\] %{POSINT:pid}#%{NUMBER}: %{GREEDYDATA:errormessage}(?:, client: (?<client>%{IP:clientip}|%{HOSTNAME:hostname}))(?:, server: %{IPORHOSTORUNDERSCORE:server})(?:, request: %{QS:request})?(?:, upstream: \\\"%{URI:upstream}\\\")?(?:, host: %{QS:host})?(?:, referrer: \\\"%{URI:referrer}\\\")?$ Copy Results: severity: The severity of the log line pid: The server process ID errormessage: The error message clientip: The IP address of the calling client server: The server IP address request: The full request upstream: The upstream URI host: The server's hostname referrer: The HTTP referrer Route 53 Source: logtype = 'route-53' Grok: %{NUMBER:log_format_version} %{TIMESTAMP_ISO8601} %{WORD:zone_id} %{IPORHOST:query} %{WORD:query_type} %{WORD:response_code} %{WORD:protocol} %{WORD:edge_location} %{IP:resolver_ip} %{GREEDYDATA:edns_client_subnet} Copy Results: log_format_version: A versioned format for the log. zone_id: The ID of the hosted zone that is associated with all the DNS queries in this log. query: The domain or subdomain that was specified in the request. query_type: Either the DNS record type that was specified in the request, or ANY. response_code: The DNS response code that Route 53 returned in response to the DNS query. protocol: The protocol that was used to submit the query, either TCP or UDP. edge_location: The Route 53 edge location that responded to the query. Each edge location is identified by a three-letter code and an arbitrary number; for example, DFW3. The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.) resolver_ip: The IP address of the DNS resolver that submitted the request to Route 53. edns_client_subnet: A partial IP address for the client that the request originated from, if available from the DNS resolver. Syslog RFC-5424 Source: logtype = 'syslog-rfc5424' Grok: <%{NONNEGINT:pri}>%{NONNEGINT:version} +(?:%{TIMESTAMP_ISO8601:log.timestamp}|-) +(?:%{HOSTNAME:hostname}|-) +(?:\\\\-|%{NOTSPACE:app.name}) +(?:\\\\-|%{NOTSPACE:procid}) (?:\\\\-|%{NOTSPACE:msgid}) +(?:\\[%{DATA:structured.data}\\]|-|) +%{GREEDYDATA:message} Copy Results: pri: The priority represents both the message facility and severity. version: Syslog protocol version. log.timestamp: Original timestamp. hostname: The machine that originally sent the Syslog message. app.name: The device or application that originated the message. procid: The process name or process ID associated with a Syslog system. msgid: Identifies the type of message. structured.data: Structured data string value. sd.<var>sd-id</var>.<var>sd-param-name</var>: The structured.data content is also parsed into separate attributes following a predefined naming convention: sd.<var>sd-id</var>.<var>sd-param-name</var>. See the structured data parsing examples, which follow. message: Free-form message that provides information about the event. Structured data parsing examples: The structured data [example one=\"1\" two=\"2\"] would be parsed into two different attributes: sd.example.one: \"1\" sd.example.two: \"2\" Copy If the same structured data block contains duplicate param names, it also appends an index-based suffix on the attribute name. For example, the structured data [example number=\"1\" number=\"2\"] would be parsed as: sd.example.number.0: \"1\" sd.example.number.1: \"2\" Copy For structured data with enterprise numbers assigned, an extra attribute is also parsed. For example, the structured data [example@123 number=\"1\"] would be parsed as: sd.example.enterprise.number: 123 sd.example.number: \"1\" Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.79716,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Built-in <em>log</em> parsing rules",
        "sections": "Built-in <em>log</em> parsing rules",
        "tags": "<em>Log</em> <em>management</em>",
        "body": " RFC-5424 Source: logtype = &#x27;syslog-rfc5424&#x27; Grok: &lt;%{NONNEGINT:pri}&gt;%{NONNEGINT:version} +(?:%{TIMESTAMP_ISO8601:<em>log</em>.timestamp}|-) +(?:%{HOSTNAME:hostname}|-) +(?:\\\\-|%{NOTSPACE:app.name}) +(?:\\\\-|%{NOTSPACE:procid}) (?:\\\\-|%{NOTSPACE:msgid}) +(?:\\[%{<em>DATA:structured.data</em>}\\]|-|) +%{GREEDYDATA:message"
      },
      "id": "603e7b9164441f1b2d4e8872"
    }
  ],
  "/docs/logs/log-api/use-tcp-endpoint-forward-logs-new-relic": [
    {
      "sections": [
        "Introduction to the Log API",
        "HTTP endpoint",
        "HTTP setup",
        "HTTP headers",
        "HTTP query parameters",
        "JSON body",
        "Simplified JSON body message",
        "Detailed JSON body message",
        "Limits and restricted characters",
        "Caution",
        "Important",
        "Rate limit violations",
        "HTTP requests per minute",
        "JSON bytes per minute",
        "Log payload format",
        "JSON message attributes",
        "Common block attributes",
        "Logs block attributes",
        "JSON message attribute parsing",
        "Log JSON examples",
        "Log POST message example",
        "JSON POST request example",
        "What's next?"
      ],
      "title": "Introduction to the Log API",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "Log API"
      ],
      "external_id": "576e06ac550560552b78c0960b22cafcb5df3dde",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/log-api/introduction-log-api/",
      "published_at": "2021-12-04T22:01:20Z",
      "updated_at": "2021-11-13T21:31:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If our log forwarding solutions don't meet your needs, you can use our Log API to send log data directly to New Relic via an HTTP endpoint. Want to try out our Log API? Create a New Relic account for free! No credit card required. HTTP endpoint Use the endpoint that's applicable for your New Relic account: United States (US) endpoint: https://log-api.newrelic.com/log/v1 Copy European Union (EU) endpoint: https://log-api.eu.newrelic.com/log/v1 Copy HTTP setup To send log data to your New Relic account via the Log API: Get your New Relic license key. Review the limits and restricted characters for your JSON payload. Generate the JSON message using the required headers and body fields. Ensure that your Api-Key or License-Key is included in your headers or query parameters. Refer to the log JSON examples. Send your JSON message to the appropriate HTTP endpoint for your New Relic account in a POST request. US: https://log-api.newrelic.com/log/v1 EU: https://log-api.eu.newrelic.com/log/v1 Generate some traffic and wait a few minutes, then check your account for data. If no data appears after you enable our log management capabilities, follow our troubleshooting procedures. HTTP headers When creating your HTTP headers, use these guidelines: Header Supported values Content-Type Required application/json json application/gzip gzip Api-Key Required A New Relic license key. You can also send this via query parameter. You can also use an Insights insert key but the license key is preferred. Gzipped JSON formatting is accepted. If sending compressed JSON, please include the Content-Type: application/json and Content-Encoding: gzip headers. HTTP query parameters The license key can also be passed as a query string parameter. This can be useful when sending logs from cloud-based sources that don't allow custom HTTP request headers. Query parameter Value Api-Key Your license key. Use this key whenever you send a header. You can also use an Insights insert key but the license key is preferred. JSON body You can send your JSON message using either a simplified or detailed set of attributes: Simplified JSON body message When using the simplified format to create your JSON message, send a single JSON object with the following: Field Value type Format Required Notes \"timestamp\" Integer Either milliseconds or seconds since epoch No If the field is not specific as millisecond or seconds since epoch, the message will be timestamped using the ingest time \"message\" String any string No This is the main log message field that is searched by default \"logtype\" String any string No Primary field for identifying logs and matching parsing rules other_fields (must not contain white space) String any string No These will become attributes of the log message. Note: Log management does not support white space in attribute names. Detailed JSON body message When using the detailed format to create your body, it must be a JSON array containing one or more JSON objects, each of which with the following format: Field Value type Format Required Notes \"common\" Object See common. No Any attributes that are common to all log messages \"logs\" Array See logs. Yes Array with the log entries Limits and restricted characters Caution Avoid calling our API from within the code of a customer-facing application. This can cause performance issues or block your application if response time is slow. If you need to do it this way, call our API asynchronously to avoid these performance issues. Restrictions on logs sent to the Log API: Payload total size: 1MB(10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. Number of attributes per event: 255 maximum. Length of attribute name: 255 characters. Length of attribute value: The first 4,094 characters are stored in NRDB as a Log event field with the same name, such as message. If the string value exceeds 4,094 characters, we store the long string as a blob. Some specific attributes have additional restrictions: accountId: This is a reserved attribute name. If it is included, it will be dropped during ingest. entity.guid, entity.name, and entity.type: These attributes are used internally to identify entities. Any values submitted with these keys in the attributes section of a metric data point may cause undefined behavior such as missing entities in the UI or telemetry not associating with the expected entities. For more information please refer to Entity synthesis. eventType: This is a reserved attribute name. If it is included, it will be dropped during ingest. timestamp: Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. Important Payloads with timestamps older than 48 hours may be dropped. Rate limits on logs sent to the Log API: Maximum rate for HTTP requests sent to the Log API: 300,000 requests per minute Maximum rate of uncompressed Log JSON bytes sent to the Log API: 10 GB per minute Rate limit violations Exceeding rate limits affects how the Log API behaves. Follow these instructions if this happens. HTTP requests per minute When the maximum request rate limit is exceeded for an account, the New Relic Log API returns a 429 response for the remainder of the minute. This response includes a Retry-After header indicating how long to wait in seconds before resubmitting or sending new data. To resolve this issue, either reduce the number of data points you are sending, or request a rate limit change. Subsequent subscription changes do not impact modified rate limits. If an account change impacts your rate limit, you must notify us to adjust your rate limit. To request rate limit changes, contact your New Relic account representative, or visit our Support portal. JSON bytes per minute When the maximum Log JSON byte limit is exceeded for an account, the New Relic Log API returns a 429 response for the remainder of the minute. This response includes a Retry-After header indicating how long to wait in seconds before resubmitting or sending new data. To resolve this issue, try to reduce the amount of log data you are sending, or spread it out over a larger period of time. To request rate limit changes, contact your New Relic account representative, or visit our Support portal. Log payload format We accept any valid JSON payload. The payload must encoded as UTF-8. Important Log management does not support white space in attribute names. For example, {\"Sample Attribute\": \"Value\"} would cause errors. JSON message attributes Common block attributes This is a block containing attributes that will be common to all log entries in logs: Field Value type Format Required Notes \"timestamp\" Integer Milliseconds or seconds since epoch No Message timestamp default to ingest time \"attributes\" Object JSON No This sub-object contains all other attributes of the message Logs block attributes This is an array containing log entries with the following format: Field Value type Format Required Notes \"timestamp\" Integer Milliseconds or seconds since epoch No Message timestamp default to ingest time \"attributes\" Object JSON No This sub-object contains all other attributes of the message \"message\" String (any string) Yes This is the main log message field that is searched by default \"log\" String (any string) No We will rewrite this string as the field message on ingest \"LOG\" String (any string) No We will rewrite this string as the field message on ingest \"MESSAGE\" String (any string) No We will rewrite this string as the field message on ingest JSON message attribute parsing Our log management capabilities will parse any message attribute as JSON. The resulting JSON attributes in the parsed message will be added to the event. If the message attribute is not JSON, it is left as is. Important White space in an attribute name is not supported. For example, {\"Sample Attribute\": \"Value\"} would cause errors. Instead, use something like {\"Sample_Attribute\":\"Value\"}. Here is an example message attribute: { \"timestamp\": 1562767499238, \"message\": \"{\\\"service-name\\\": \\\"login-service\\\", \\\"user\\\": {\\\"id\\\": 123, \\\"name\\\": \\\"alice\\\"}}\" } Copy This will be treated as: { \"timestamp\": 1562767499238, \"message\": \"{\\\"service-name\\\": \\\"my-service\\\", \\\"user\\\": {\\\"id\\\": 123, \\\"name\\\": \\\"alice\\\"}}\", \"service-name\": \"my-service\", \"user\": { \"id\": 123, \"name\": \"alice\" } } Copy Log JSON examples Attributes can be scalar JSON types like string and number. They can also be compound (or nested) objects. Compound attributes will have their associated attributes stored with flattened names. For example, here is a compound user attribute in a log entry's attributes: \"attributes\": { \"action\": \"login\", \"user\": { \"id\": 123, \"name\": \"alice\" } } Copy This will result in the following attributes being stored with the log event: Attribute Value \"action\" \"login\" \"user.id\" 123 \"user.name\" \"alice\" Log POST message example Log POST message example: POST /log/v1 HTTP/1.1 Host: log-api.newrelic.com Content-Type: application/json X-License-Key: <YOUR_LICENSE_KEY> Accept: */* Content-Length: 319 [{ \"common\": { \"attributes\": { \"logtype\": \"accesslogs\", \"service\": \"login-service\", \"hostname\": \"login.example.com\" } }, \"logs\": [{ \"timestamp\": <TIMESTAMP_IN_UNIX_EPOCH>, \"message\": \"User 'xyz' logged in\" },{ \"timestamp\": <TIMESTAMP_IN_UNIX_EPOCH>, \"message\": \"User 'xyz' logged out\", \"attributes\": { \"auditId\": 123 } }] }] Copy This POST message would result in the following log messages being stored in New Relic: Attribute Value \"logtype\" \"accesslogs\" \"service\" \"login-service\" \"hostname\" \"login.example.com\" Here's an example of stored logs block attributes: Attribute Value \"timestamp\" 1550086450124 \"message\" \"User 'xyz' logged out\" \"auditId\" 123 JSON POST request example Here's an example of a JSON POST request: POST /log/v1 HTTP/1.1 Host: log-api.newrelic.com Content-Type: application/json X-License-Key: <YOUR_LICENSE_KEY> Accept: */* Content-Length: 133 { \"timestamp\": <TIMESTAMP_IN_UNIX_EPOCH>, \"message\": \"User 'xyz' logged in\", \"logtype\": \"accesslogs\", \"service\": \"login-service\", \"hostname\": \"login.example.com\" } Copy What's next? Explore logging data across your platform with the New Relic One UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our logs in context capabilities. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 201.65778,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the <em>Log</em> <em>API</em>",
        "sections": "Introduction to the <em>Log</em> <em>API</em>",
        "tags": "<em>Log</em> <em>management</em>",
        "body": " in a POST request. US: https:&#x2F;&#x2F;<em>log</em>-<em>api</em>.newrelic.com&#x2F;<em>log</em>&#x2F;v1 EU: https:&#x2F;&#x2F;<em>log</em>-<em>api</em>.eu.newrelic.com&#x2F;<em>log</em>&#x2F;v1 Generate some traffic and wait a few minutes, then check your account for data. If no data appears after you enable our <em>log</em> <em>management</em> capabilities, follow our troubleshooting procedures. HTTP headers"
      },
      "id": "61902eb9196a6776c0e7277b"
    },
    {
      "sections": [
        "Use APM agent APIs with logs in context",
        "APM agent trace metadata and linking metadata APIs",
        "Resources for correctly annotating logs"
      ],
      "title": "Use APM agent APIs with logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context with agent APIs"
      ],
      "external_id": "ebc829a1c1b74c866f5326f90a6d5119fdcfae10",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/annotate-logs-logs-context-using-apm-agent-apis/",
      "published_at": "2021-12-06T01:43:28Z",
      "updated_at": "2021-12-04T22:00:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To correlate log data with other telemetry data, such as errors and distributed traces in APM, you can use our logs in context solutions. If your logging framework is not available with our existing logs in context solutions, you can configure your logging libraries by using API calls to annotate your logs. APM agent trace metadata and linking metadata APIs To get properly annotated logs for logs in context, use the following API calls for your APM agent. These APIs pass the required trace metadata and linking metadata to link your log data to other New Relic data. APM agent APIs: APM agent API calls C SDK (n/a) See our Log API documentation. Go GetTraceMetadata GetLinkingMetadata Java getTraceMetadata getLinkingMetadata .NET TraceMetadata GetLinkingMetadata Node.js newrelic.getTraceMetadata newrelic.getLinkingMetadata PHP newrelic_get_trace_metadata newrelic_get_linking_metadata For PHP, logs in context is only supported from the distributed tracing UI, not in the Logs tab of the APM UI. Python get_linking_metadata Ruby linking_metadata current_trace_id current_span_id Resources for correctly annotating logs For more information about using the trace metadata and linking metadata APIs to annotate logs for logs in context, review the APM agent specifications in GitHub. These specifications include the required fields and properly formatted output. Also, review the source code for our own logs in context extensions to see how we use these APIs: C SDK: n/a Go: Logrus extension Java: Log4j2 extension .NET: Serilog extension Node.js: Winston extension PHP: Monolog extension Python: Streamhandler example Ruby: logging.rb extension",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.29022,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use APM agent <em>APIs</em> with <em>logs</em> in context",
        "sections": "Use APM agent <em>APIs</em> with <em>logs</em> in context",
        "tags": "Enable <em>log</em> <em>management</em> in New Relic",
        "body": "To correlate <em>log</em> data with other telemetry data, such as errors and distributed traces in APM, you can use our <em>logs</em> in context solutions. If your logging framework is not available with our existing <em>logs</em> in context solutions, you can configure your logging libraries by using <em>API</em> calls to annotate"
      },
      "id": "61505693196a670394b70d61"
    },
    {
      "sections": [
        "AWS Lambda for sending CloudWatch logs",
        "Install and configure the Cloudwatch logs Lambda function",
        "Create a Lambda trigger",
        "Configure retries (optional)",
        "Tip",
        "Resources created by the SAM template",
        "View log data",
        "What's next?"
      ],
      "title": "AWS Lambda for sending CloudWatch logs",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Enable log monitoring in New Relic"
      ],
      "external_id": "69c310375d48a667779ffabead6f920eb6a34004",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/forward-logs/aws-lambda-sending-cloudwatch-logs/",
      "published_at": "2021-12-04T21:55:34Z",
      "updated_at": "2021-12-04T21:55:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can send your Amazon CloudWatch logs to New Relic using our AWS Lambda function, newrelic-log-ingestion. This can be easily deployed from the AWS Serverless application repository. Forwarding your CloudWatch logs to New Relic will give you enhanced log management capabilities to collect, process, explore, query, and alert on your log data. Install and configure the Cloudwatch logs Lambda function The following setup shows one approach for configuring environment variables. You can also configure them from the Functions page. Complete the following: Make sure you have a New Relic license key. Open the AWS Serverless Application Repository in your browser. Search for newrelic and check Show apps that create custom IAM roles or resource policies to find newrelic-log-ingestion. Open the newrelic-log-ingestion details and click Deploy. In the function's Configure menu, go to Environment Variables and configure log forwarding using the following environment variables: Key Description DEBUG_LOGGING_ENABLED A boolean to determine if you want to output debug messages in the CloudWatch console. Optional. To turn on debug logs, set this to true. Default is false. LICENSE_KEY New Relic license key is used for sending data to New Relic. Required. LOGGING_ENABLED Determines if logs are forwarded to New Relic. Required. To turn on logging, set this to true. NR_LOGGING_ENDPOINT New Relic ingestion endpoint for logs. Required. Two endpoints are available: US: https://log-api.newrelic.com/log/v1 EU: https://log-api.eu.newrelic.com/log/v1 NR_TAGS Specify tags to be added to all log events. Optional. Each tag is composed of a colon-delimited key and value. Multiple key-value pairs are semicolon-delimited; for example, env:prod;team:myTeam. Acknowledge that the app creates custom IAM roles, and then click Deploy. Once the process completes, create a Lambda trigger to link your Lambda function to CloudWatch logs. Create a Lambda trigger To get your logs streaming to New Relic, attach a trigger to the Lambda: From the left side menu, select Functions. Find and select the previously created newrelic-log-ingestion function. Under Designer, click Add Triggers, and select Cloudwatch Logs from the dropdown. Select the the appropriate Log group for your application. Enter a name for your filter. Optional: Enter a filter pattern. Check the Enable trigger checkbox, then click Add to create the trigger. Configure retries (optional) You can configure the number of retries you want to perform in case the function fails to send the data in case of communication issues. Recommended number is 3 retries, but you can change the retry behavior by changing the below parameters: Tip The more the number of retries there are can make the function run for longer times. This increases the probability of having higher costs for Lambda. However, decreasing the number of retries could increase the probability of data loss. MAX_RETRIES = 3 # Defines the number of retries after lambda failure to deliver data INITIAL_BACKOFF = 1 # Defines the initial wait seconds until next retry is executed BACKOFF_MULTIPLIER = 2 # Time multiplier between the retries As an example, in default above configuration, first retry will happen after 1 second, second retry after 2 seconds and third retry will happen after 4 seconds. Copy Resources created by the SAM template When you create the application from the repository, the following resources are also created: The Lambda function itself A role used to give execution permissions to the Lambda function based in CloudWatch Logs. All other Lambda configurations not listed can be left as the defaults. View log data If everything is configured correctly and your data is being collected, you should see data logs in both of these places: New Relic Logs UI New Relic tools for running NRQL queries. For example, you can execute a query like this: SELECT * FROM Log Copy If no data appears after you enable our log management capabilities, follow our standard log troubleshooting procedures. What's next? Explore logging data across your platform with the New Relic One UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our logs in context capabilities. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 161.33899,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "AWS Lambda for sending CloudWatch <em>logs</em>",
        "sections": "AWS Lambda for sending CloudWatch <em>logs</em>",
        "tags": "Enable <em>log</em> <em>management</em> in New Relic",
        "body": "You can send your Amazon CloudWatch <em>logs</em> to New Relic using our AWS Lambda function, newrelic-<em>log</em>-ingestion. This can be easily deployed from the AWS Serverless application repository. Forwarding your CloudWatch <em>logs</em> to New Relic will give you enhanced <em>log</em> <em>management</em> capabilities to collect"
      },
      "id": "603ea6bb28ccbc228deba74c"
    }
  ],
  "/docs/logs/logs-context/annotate-logs-logs-context-using-apm-agent-apis": [
    {
      "sections": [
        "PHP: Configure logs in context",
        "Set up your PHP app",
        "PHP configuration with Monolog",
        "Tip",
        "PHP configuration with other log forwarders",
        "What's next?"
      ],
      "title": "PHP: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context for PHP"
      ],
      "external_id": "bddc3ec75de7bde2b5eff995d85d11715fd61be9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/configure-logs-context-php/",
      "published_at": "2021-12-04T22:02:35Z",
      "updated_at": "2021-12-04T22:02:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the PHP agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your PHP app To enable logs in context for APM apps monitored by PHP: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest PHP agent version, and enable distributed tracing. Use PHP agent version 9.13.0.270 or higher for logs in context. Install Monolog version 1 or 2, or use a compatible log forwarding plugin if you are not using the built-in Monolog Handler for New Relic. Configure logs in context for PHP using the Monolog extension, if used. PHP configuration with Monolog You must install the Monolog log enricher package before you can configure Monolog for New Relic logs in context. This is done by using Composer to install the newrelic/monolog-enricher package. In most cases, use the Processor and Handler classes provided by the log enricher package in conjunction with Monolog's built-in BufferHandler. The Processor adds the contextual metadata required for New Relic logs in context to operate. The Handler sends the log records to New Relic Logs. The BufferHandler ensures that the logs are delivered with as little overhead as possible. At the point where you create the Monolog\\Logger object, add the following pushProcessor and pushHandler calls to add the Processor and Handler: <?php use Monolog\\Handler\\BufferHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Handler, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $log->pushHandler(new BufferHandler(new Handler)); Copy Tip You can use the Processor and Handler in conjunction with any existing Monolog setup. You do not need to remove your existing processors and handlers. PHP configuration with other log forwarders If you use Monolog to send logs to a compatible log forwarder, and if you have already configured that tool to send logs to New Relic, you can use the Processor and Formatter solely for that tool. This option prevents additional overhead of sending logs directly to New Relic with the Handler. You will need to be using a handler that supports the setFormatter() method, and your logging tool must be able to ingest JSON logs. Here's an example of configuring Monolog to handle other log forwarders: <?php use Monolog\\Handler\\StreamHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Formatter, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $handler = new StreamHandler('php://stderr'); $handler->setFormatter(new Formatter); $log->pushHandler($handler); Copy To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. If the logs from your application do not include fields like trace.id and span.id, there may be a problem with the configuration of the Monolog log enricher. In this situation: Check that the PHP agent for your app has been installed and is configured to enable distributed tracing. Check that your application is using the Monolog logger object when sending log records, not syslog(). Check that another Monolog handler is not preventing the log record from bubbling. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. View your logs in context data in distributed tracing. Note that for PHP, logs in context data doesn't appear in the Logs tab of the APM UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 249.05544,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "PHP: Configure <em>logs</em> <em>in</em> <em>context</em>",
        "sections": "PHP: Configure <em>logs</em> <em>in</em> <em>context</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": "<em>Logs</em> in <em>context</em> for the PHP <em>agent</em> connects your <em>logs</em> and APM data in <em>New</em> <em>Relic</em>. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the <em>log</em> lines that you need to identify and resolve a problem. Set up your PHP app To <em>enable</em> <em>logs</em>"
      },
      "id": "612b7ab4196a6714904948ae"
    },
    {
      "sections": [
        "AWS Lambda for sending CloudWatch logs",
        "Install and configure the Cloudwatch logs Lambda function",
        "Create a Lambda trigger",
        "Configure retries (optional)",
        "Tip",
        "Resources created by the SAM template",
        "View log data",
        "What's next?"
      ],
      "title": "AWS Lambda for sending CloudWatch logs",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Enable log monitoring in New Relic"
      ],
      "external_id": "69c310375d48a667779ffabead6f920eb6a34004",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/forward-logs/aws-lambda-sending-cloudwatch-logs/",
      "published_at": "2021-12-04T21:55:34Z",
      "updated_at": "2021-12-04T21:55:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can send your Amazon CloudWatch logs to New Relic using our AWS Lambda function, newrelic-log-ingestion. This can be easily deployed from the AWS Serverless application repository. Forwarding your CloudWatch logs to New Relic will give you enhanced log management capabilities to collect, process, explore, query, and alert on your log data. Install and configure the Cloudwatch logs Lambda function The following setup shows one approach for configuring environment variables. You can also configure them from the Functions page. Complete the following: Make sure you have a New Relic license key. Open the AWS Serverless Application Repository in your browser. Search for newrelic and check Show apps that create custom IAM roles or resource policies to find newrelic-log-ingestion. Open the newrelic-log-ingestion details and click Deploy. In the function's Configure menu, go to Environment Variables and configure log forwarding using the following environment variables: Key Description DEBUG_LOGGING_ENABLED A boolean to determine if you want to output debug messages in the CloudWatch console. Optional. To turn on debug logs, set this to true. Default is false. LICENSE_KEY New Relic license key is used for sending data to New Relic. Required. LOGGING_ENABLED Determines if logs are forwarded to New Relic. Required. To turn on logging, set this to true. NR_LOGGING_ENDPOINT New Relic ingestion endpoint for logs. Required. Two endpoints are available: US: https://log-api.newrelic.com/log/v1 EU: https://log-api.eu.newrelic.com/log/v1 NR_TAGS Specify tags to be added to all log events. Optional. Each tag is composed of a colon-delimited key and value. Multiple key-value pairs are semicolon-delimited; for example, env:prod;team:myTeam. Acknowledge that the app creates custom IAM roles, and then click Deploy. Once the process completes, create a Lambda trigger to link your Lambda function to CloudWatch logs. Create a Lambda trigger To get your logs streaming to New Relic, attach a trigger to the Lambda: From the left side menu, select Functions. Find and select the previously created newrelic-log-ingestion function. Under Designer, click Add Triggers, and select Cloudwatch Logs from the dropdown. Select the the appropriate Log group for your application. Enter a name for your filter. Optional: Enter a filter pattern. Check the Enable trigger checkbox, then click Add to create the trigger. Configure retries (optional) You can configure the number of retries you want to perform in case the function fails to send the data in case of communication issues. Recommended number is 3 retries, but you can change the retry behavior by changing the below parameters: Tip The more the number of retries there are can make the function run for longer times. This increases the probability of having higher costs for Lambda. However, decreasing the number of retries could increase the probability of data loss. MAX_RETRIES = 3 # Defines the number of retries after lambda failure to deliver data INITIAL_BACKOFF = 1 # Defines the initial wait seconds until next retry is executed BACKOFF_MULTIPLIER = 2 # Time multiplier between the retries As an example, in default above configuration, first retry will happen after 1 second, second retry after 2 seconds and third retry will happen after 4 seconds. Copy Resources created by the SAM template When you create the application from the repository, the following resources are also created: The Lambda function itself A role used to give execution permissions to the Lambda function based in CloudWatch Logs. All other Lambda configurations not listed can be left as the defaults. View log data If everything is configured correctly and your data is being collected, you should see data logs in both of these places: New Relic Logs UI New Relic tools for running NRQL queries. For example, you can execute a query like this: SELECT * FROM Log Copy If no data appears after you enable our log management capabilities, follow our standard log troubleshooting procedures. What's next? Explore logging data across your platform with the New Relic One UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our logs in context capabilities. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.59698,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "AWS Lambda for sending CloudWatch <em>logs</em>",
        "sections": "<em>Install</em> and configure the Cloudwatch <em>logs</em> Lambda function",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": " this: SELECT * FROM <em>Log</em> Copy If no data appears after you <em>enable</em> our <em>log</em> <em>management</em> capabilities, follow our standard <em>log</em> troubleshooting procedures. What&#x27;s next? Explore logging data across your platform with the <em>New</em> <em>Relic</em> One UI. Get deeper visibility into both your application and your platform performance data by forwarding your <em>logs</em> with our <em>logs</em> in <em>context</em> capabilities. Set up alerts. Query your data and create dashboards."
      },
      "id": "603ea6bb28ccbc228deba74c"
    },
    {
      "sections": [
        "Forward your logs using the infrastructure agent",
        "Basic process",
        "System requirements",
        "Important",
        "Install the infrastructure agent",
        "Configure the infrastructure agent",
        "Log forwarding parameters",
        "Name (required)",
        "Log source (required)",
        "file",
        "systemd",
        "syslog",
        "tcp",
        "winlog",
        "Optional configuration",
        "attributes",
        "attributes automatically inserted by the infrastructure agent",
        "pattern",
        "max_line_kb",
        "fluentbit",
        "Sample configuration file",
        "logging.d/sample.yaml",
        "View your log data",
        "Troubleshooting",
        "No log data",
        "No data appears when tailing a file",
        "No data appears when capturing via a Syslog socket",
        "No data appears using infrastructure agent proxy",
        "Sending the infrastructure agent's logs to New Relic",
        "Caution",
        "Fluent Bit does not start with the infra agent",
        "Runtime error on Windows",
        "Errors when tailing a large amount of log files (Linux)",
        "Uninstall log forwarding",
        "What's next?"
      ],
      "title": "Forward your logs using the infrastructure agent",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Enable log monitoring in New Relic"
      ],
      "external_id": "a1deac410f0eedfb819348524a85a73bbb9d9daf",
      "image": "https://docs.newrelic.com/static/63ba6c3dc400e3cc4fb21668d5e7ba2a/c1b63/infrastructure-lic.png",
      "url": "https://docs.newrelic.com/docs/logs/forward-logs/forward-your-logs-using-infrastructure-agent/",
      "published_at": "2021-12-08T01:44:17Z",
      "updated_at": "2021-12-04T13:38:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can forward your logs to New Relic using our infrastructure monitoring agent. This makes all of your logging data available in one location and provides deeper visibility into both your application and your platform performance data. Forwarding your logs to New Relic will give you enhanced log management capabilities to collect, process, explore, query, and alert on your log data. Basic process To forward your logs through our infrastructure monitoring agent: If you haven't already, create a New Relic account. It's free, forever. Verify the system requirements needed for configuring logs. Ensure you have installed the infrastructure agent, version 1.11.4 or higher. Create a logging.yml configuration file in the infrastructure agent's logging.d directory. Configure your log sources and other parameters. Generate some traffic and wait a few minutes, then check your account for data. Explore your log data in the Logs UI and benefit from the log attributes automatically inserted by the infrastructure agent. Here is an example of where you can see logs in context of your infrastructure monitoring details in New Relic One. System requirements To use the log forwarder of the infrastructure agent, make sure you meet the following requirements: Infrastructure agent version 1.11.4 or higher OpenSSL library 1.1.0 or higher is required by Infrastructure agent starting from 1.16.4. Built-in support for ARM64 architecture on Linux systems (in example, AWS Graviton architecture) added in Infrastructure agent 1.26.0. Important The log forwarding feature is not supported with the Docker container for infrastructure monitoring agents. The log forwarding feature is compatible with the following operating systems: Operating system Supported version Amazon Linux Amazon Linux 2 CentOS Version 7 or higher Debian Version 9 (\"Stretch\") or higher Exception: Version 11 is not supported. Red Hat Enterprise Linux (RHEL) Version 7 or higher SUSE Linux Enterprise Server (SLES) Version 12 Ubuntu Versions 16.04.x, 18.04.x and 20.04.x (LTS versions) Windows Windows Server 2012, 2016, and 2019, and their service packs. Windows 10 Install the infrastructure agent Starting with version 1.11.4, the infrastructure agent can forward logs to New Relic. To install and run the agent, use a package manager (Linux) or the MSI installer (Windows). Important The log forwarding feature is not included when the infrastructure agent is implemented using Linux tarball or Windows ZIP installations. To use the following links, make sure you are logged to your New Relic account. Amazon Linux CentOS Debian RHEL SLES Ubuntu Windows If you don't have a New Relic account yet, or if you prefer to follow the procedure manually, see our tutorial to install the package manager. Configure the infrastructure agent Configuration files describe which log sources are forwarded. Our infrastructure agent uses .yml files to configure logging. You can add as many config files as you want. To add a new configuration file for the log forwarding feature: Navigate to the log forwarder configuration folder: Linux: /etc/newrelic-infra/logging.d/ Windows: C:\\Program Files\\New Relic\\newrelic-infra\\logging.d\\ Create a logging.yml configuration file, and add the parameters you need. The logging.d directory has various .yml.example files you can use as a reference or starting point. The agent automatically processes new configuration files without having to restart the infrastructure monitoring service. The only exception to this is when configuring a custom Fluent Bit configuration. Log forwarding parameters The infrastructure log forwarding .yml config supports the following parameters: Name (required) To start, define a name of the log or logs you want to forward to New Relic. Log source (required) What you use for the log source will depend on where you want to forward your logs from. Available options include: file Path to the log file or files. The agent tracks changes on the log files in a way similar to tail -f shell. Example: logs: - name: example-log file: /var/log/example.log # Path to a single log file - name: example-log-two file: /var/log/example-two.log # Path to another single log file Copy The file parameter can point to a specific log file or multiple files by using wildcards applied to names and extensions; for example, /logs/*.log. You can use wildcards in place of directories in a file path, which can be used to tail files located in different directories. Example: logs: - name: docker-logs file: /var/lib/docker/containers/*/*.log # Path to multiple folders and files Copy Important Use of wildcards may significantly increase the number of file descriptors and inotify watches the Fluent Bit process keeps open, which can interfere with log collection if the host's file descriptor limit is reached. Tailing a large number of files may require you to increase the maximum number of file descriptors and inotify watchers allowed by the operating system. Please refer to Errors when tailing a large amount of log files for more details on how to increase them. systemd Use the systemd parameter to forward log messages that are collected by the journald daemon in Linux environments. This input type requires the agent to run in root mode. Example: logs: - name: systemd-example systemd: cupsd Copy syslog Syslog data source. Parameters: uri: Syslog socket. Format varies depending on the protocol: TCP/UDP network sockets: [tcp/udp]://LISTEN_ADDRESS:PORT Unix domain sockets: unix_[tcp/udp]:// + /socket/path parser: Syslog parser. Default is rfc3164. Use rfc5424 if your messages include fractional seconds. Note: rfc3164 currently does not work on SuSE. unix_permissions: default is 0644 for domain sockets; this limits entries to processes running as root. You can use 0666 to listen for non-root processes, at your own risk. When running the agent in privileged mode, ports and sockets must be available or owned by nri-agent, with 0666 file permissions, so that other processes can write logs to the sockets. logs: # TCP network socket - name: syslog-tcp-test syslog: uri: tcp://0.0.0.0:5140 # Use the tcp://LISTEN_ADDRESS:PORT format parser: rfc5424 # Default syslog parser is rfc3164 # UDP network socket - name: syslog-udp-test syslog: uri: udp://0.0.0.0:6140 # Use the udp://LISTEN_ADDRESS:PORT format max_line_kb: 35 # Unix TCP domain socket - name: syslog-unix-tcp-test syslog: uri: unix_tcp:///var/unix-tcp-socket-test unix_permissions: 0666 # Default is 0644. Change at your own risk # Unix UDP domain socket - name: syslog-unix-udp-test syslog: uri: unix_udp:///var/unix-udp-socket-test parser: rfc5424 Copy tcp Logs retrieved over TCP connections. Parameters: uri: TCP/IP socket to listen for incoming data. The URI format is tcp://LISTEN_ADDRESS:PORT format: format of the data. It can be json or none. separator: If format: none is used, you can define a separator string for splitting records (default: \\n). logs: - name: tcp-simple-test tcp: uri: tcp://0.0.0.0:1234 # Use the tcp://LISTEN_ADDRESS:PORT format format: none # Raw text - this is default for 'tcp' separator: \\t # String for separating raw text entries max_line_kb: 32 - name: tcp-json-test tcp: uri: tcp://0.0.0.0:2345 # Use the tcp://LISTEN_ADDRESS:PORT format format: json Copy winlog Collect events from Windows log channels. Parameters: channel: name of the channel logs will be collected from. collect-eventids: a list of Windows Event IDs to be collected and forwarded to New Relic. Event ID ranges are supported. exclude-eventids: a list of Windows Event IDs to be excluded from collection. Event ID ranges are supported. All events are collected from the specified channel by default. Configure the collect-eventids and exclude-eventids sections to avoid sending unwanted logs to your New Relic account. Add event IDs or ranges to collect-eventids or exclude-eventids to forward or drop specific events. exclude-eventids takes precedence over collect-eventids if the same event ID is present in both sections. Example: logs: # Winlog log ingestion with eventId filters. - name: windows-security winlog: channel: Security collect-eventids: - 4624 - 4265 - 4700-4800 exclude-eventids: - 4735 # entries for the application, system, powershell, and SCOM channels - name: windows-application winlog: channel: Application - name: windows-system winlog: channel: System - name: windows-pshell winlog: channel: Windows Powershell - name: scom winlog: channel: Operations Manager # Entry for Windows Defender Logs - name: windows-defender winlog: channel: Microsoft-Windows-Windows Defender/Operational # Entry for Windows Clustering Logs - name: windows-clustering winlog: channel: Microsoft-Windows-FailoverClustering/Operational # Entry for IIS logs with logtype attribute for automatic parsing - name: iis-log file: C:\\inetpub\\logs\\LogFiles\\w3svc.log attributes: logtype: iis_w3c Copy Optional configuration The following configuration parameters are not required but are still recommended. attributes List of custom attributes specified as key-value pairs that can be used to send additional data with the logs which you can then query. The attributes configuration parameter can be used with any log source. One common use of the attributes configuration parameter is to specify the logtype attribute. This attribute allows leveraging one of the built-in parsing rules supported by New Relic Logs. Example: logs: - name: example-file-attributes file: /var/log/example.log attributes: logtype: nginx region: example-us-02 team: A-team - name: example-tcp-attributes tcp: uri: tcp://0.0.0.0:2345 format: json attributes: logtype: nginx region: example-us-02 team: B-team Copy attributes automatically inserted by the infrastructure agent The infrastructure agent automatically inserts log attributes for your convenience. Some of them are inserted for any log record, while others depend on the configuration parameters you used while setting up the log forwarder. Attribute name Description entity.guids Always inserted. The infrastructure agent inserts the Entity GUID assigned by New Relic to identify the host where it's running. It is available in the entity.guids field. Note: If the captured logs belong to an application instrumented using APM, the entity.guids field contains both the entity GUID of infrastructure, as well as the GUID of APM, separated by a pipe ( | ) delimiter. fb.input Always inserted. The underlying Fluent Bit input plugin type used to capture the logs. Currently its values are tail, systemd, winlog, syslog, and tcp. filePath Inserted when sing the file input type. Absolute file path of the file being monitored. hostname Always inserted. The hostname of the machine/VM/container executing the infrastructure agent. plugin.type Always inserted. Indicates the utility used to capture the logs. In this case, it is the infrastructure agent itself, so this attribute always has the value nri-agent. pattern Regular expression for filtering records. Only supported for the tail, systemd, syslog, and tcp (only with format none) sources. This field works in a way similar to grep -E in Unix systems. For example, for a given file being captured, you can filter for records containing either WARN or ERROR using: - name: only-records-with-warn-and-error file: /var/log/logFile.log pattern: WARN|ERROR Copy No filtering is applied by default. max_line_kb Maximum size of log entries/lines in KB. If log entries exceed the limit, they are skipped. Default is 128. fluentbit External Fluent Bit configuration and parser files. If defined, they are merged with the existing configuration and parser files generated by the infrastructure agent. The infrastructure agent processes the configuration files located in the logging.d directory and will generate a run-time Fluent Bit configuration file that contains the appropriate [INPUT], [FILTER] and [OUTPUT] sections. Optionally, it will also declare an @INCLUDE in case you provided an external Fluent Bit configuration file via the fluentbit option. The runtime file does not define a [SERVICE] section, leaving all default Fluent Bit configuration values. You can still override Fluent Bit's default settings by defining your own [SERVICE] section in your external Fluent Bit configuration file and include it via the fluentbit option. Parameters: config_file: path to an existing Fluent Bit configuration file. Note that any overlapping source results in duplicate messages in New Relic Logs. parsers_file: path to an existing Fluent Bit parsers file. The following parser names are reserved: rfc3164, rfc3164-local and rfc5424. Sample configuration file Here is an example of a logging.d/ configuration file in YAML format. For more configuration examples, see the infrastructure agent repository. logging.d/sample.yaml # Remember to only use spaces for indentation logs: # Example of 'file' source - name: file-with-attributes file: /var/log/test.log # Path to a single file or pattern attributes: # You can use custom attributes to enrich your data logtype: nginx team: The A Team pattern: Error # Regular expression to filter log entries # Example of 'systemd' source (Linux only) - name: systemd-example systemd: cupsd # Examples of 'syslog' source, one per protocol # TCP network socket - name: syslog-tcp-test syslog: uri: tcp://0.0.0.0:5140 # Use the tcp://LISTEN_ADDRESS:PORT format parser: rfc5424 # Default syslog parser is rfc3164 # UDP network socket - name: syslog-udp-test syslog: uri: udp://0.0.0.0:6140 # Use the udp://LISTEN_ADDRESS:PORT format max_line_kb: 35 # Paths for Unix sockets are defined by combining protocol and path: # unix_udp:// + /path/socket - for example, unix_udp:///tmp/socket # Unix TCP domain socket - name: syslog-unix-tcp-test syslog: uri: unix_tcp:///var/unix-tcp-socket-test unix_permissions: 0666 # Default is 0644. Change at your own risk # Unix UDP domain socket - name: syslog-unix-udp-test syslog: uri: unix_udp:///var/unix-udp-socket-test parser: rfc5424 # Examples of 'tcp' source for formats 'none' and 'json' - name: tcp-simple-test tcp: uri: tcp://0.0.0.0:1234 # Use the tcp://LISTEN_ADDRESS:PORT format format: none # Raw text - this is default for 'tcp' separator: \\t # String for separating raw text entries attributes: # You can add custom attributes to any source of logs tcpFormat: none someOtherAttribute: associatedValue max_line_kb: 32 - name: tcp-json-test tcp: uri: tcp://0.0.0.0:2345 # Use the tcp://LISTEN_ADDRESS:PORT format format: json attributes: tcpFormat: json yetAnotherAttribute: 12345 # Example of Fluent Bit configuration import - name: fluentbit-import fluentbit: config_file: /path/to/fluentbit.config parsers_file: /path/to/fluentbit/parsers.conf Copy View your log data If everything is configured correctly and your data is being collected, you should see logs data in both of these places: New Relic Logs UI New Relic tools for running NRQL queries. For example, you can execute a query like this: SELECT * FROM Log Copy Troubleshooting If you encounter problems with configuring your log forwarder, try these troubleshooting tips. No log data If no data appears after you enable our log management capabilities, follow our standard log troubleshooting procedures. No data appears when tailing a file The log forwarding feature requires the agent to have permission to read the data sources. When running the infrastructure agent in privileged or non-privileged modes, make sure that the log files you want to forward (and any intermediary directory in its path) are readable by the user running nri-agent. Example: Check file access under Linux Let's check whether the file /var/log/restrictedLogs/logFile.log can be monitored by the nri-agent user. In Linux, you can do a quick check with the namei command: sudo -u nri-agent namei -ml /var/log/restrictedLogs/logFile.log f: /var/log/restrictedLogs/logFile.log drwxr-xr-x root root / drwxr-xr-x root root var drwxrwxr-x root syslog log drwxr--r-- root root restrictedLogs logFile.log - No such file or directory Copy This command failed because the file is not visible to the nri-agent user. By inspecting the previous output, we can detect that the restrictedLogs directory is missing the execution flag for others. To fix this, execute: sudo chmod 755 /var/log/restrictedLogs Copy And then check for file access again: # sudo -u nri-agent namei -ml /var/log/restrictedLogs/logFile.log f: /var/log/restrictedLogs/logFile.log drwxr-xr-x root root / drwxr-xr-x root root var drwxrwxr-x root syslog log drwxr-xr-x root root restrictedLogs -rw-r----- vagrant vagrant logFile.log Copy The file is now visible to the nri-agent user. You must ensure that the file is also readable by the nri-agent user. To check this, use: # sudo -u nri-agent head /var/log/restrictedLogs/logFile.log head: cannot open '/var/log/restrictedLogs/logFile.log' for reading: Permission denied Copy In this example, the file is missing the read rights for the others group (users other than vagrant and the vagrant user group). You could fix this by granting read permissions to others, but the application could change these permissions upon restart. To avoid this, a better approach is to add the nri-agent user to the vagrant user group. No data appears when capturing via a Syslog socket The log forwarding feature requires that the agent has permission to read the data sources. When running the infrastructure agent in privileged or non-privileged modes: If you're using Unix domain socket files, make sure that the nri-agent user can access these files (please refer to the previous section) and that they have read and write permissions (666) so that other users than nri-agent can write to them. If you're using IP sockets, ensure that the port that you are using is not a system reserved one (like port 80, for example). If no data appears after you enable log management, follow standard log management troubleshooting procedures. No data appears using infrastructure agent proxy As explained in the infrastructure agent configuration guidelines, the proxy parameter must use either HTTP or HTTPS and be in the form https://user:password@hostname:port. The agent can parse the parameter without the HTTP or HTTPS, but the log forwarder cannot. You will see an error like the following in the agent verbose logs: [ERROR] building HTTP transport: parse \\\"hostname:port\\\": first path segment in URL cannot contain colon Copy To solve this problem, check your newrelic-infra.yml file, and ensure the proxy parameter adheres to this form. If you're using caBundleFile or caBundleDir in order to specify any certificate, we recommend to follow the below rules for each OS: Linux For HTTP proxies you don't need to setup any certificates. The plugin loads the system certificates and New Relic sends logs into the logging endpoint. However, you can specify the proxy self-signed certificate (PEM file) using either the caBundleFile or caBundleDir parameters. Windows For HTTP proxies you don't need to setup any certificates. The plugin loads the system certificates. For HTTPS, you can configure it in one of the following ways: Import the proxy certificate to the system pool (Recommended) Import the proxy self-signed certificate (PEM file) by using the MMC tool. Refer to this link, and in Step 2 ensure to import it in your Trusted Root Certification Authorities, instead of in the Intermediate Certification Authorities. Using the caBundleFile and caBundleDir parameters On Windows, we cannot load both the certificates from the system certificate pool and the ones specified with the caBundleFile caBundleDir parameters. So, if you are using caBundleFile or caBundleDir, ensure that the following certificates are placed in the same PEM file (when using caBundleFile) or in the same directory (when using caBundleDir): The Proxy certificate (because it's an HTTPS proxy). The Logging Endpoint certificate (eg. https://log-api.newrelic.com/log/v1). The Infrastructure Agent certificate (eg. https://infra-api.newrelic.com). You can check the certificates by running: # openssl s_client -connect log-api.newrelic.com:443 -servername log-api.newrelic.com Copy Sending the infrastructure agent's logs to New Relic You can configure the infrastructure agent to send its own logs to New Relic. This is useful for troubleshooting issues with log forwarding, the agent, or when contacting support. To forward the infrastructure agent logs to New Relic: Edit your newrelic-infra.yml file. Enable agent logging in troubleshooting mode by adding verbose: 3. On Windows and systems that don't use systemd or where journald is inaccessible, verbose:3 causes the agent to write the logs on the disk. Revert to verbose:0 to prevent this. (Recommended): Enable agent logging in JSON format to log_format: json. Restart the agent to load the new settings. This configuration sets up the agent in troubleshooting mode, but the log forwarder (based on Fluent Bit) will continue in a non-verbose mode. Sometimes you can have issues with the log forwarder itself. For example, there may be problems accessing a specific channel when shipping Windows log events or when accessing a particular log file. In these situations, you can also enable the verbose mode for the log forwarder: Set verbose to a value other than 0. Add the configuration option: trace: [\"log.fw\"]. Caution Check whether you are using the [fluentbit] option. When setting verbose: 3 and trace: [\"log.fw\"], ensure that you don't define any [OUTPUT] section pointing to stdout in an external Fluent Bit configuration file, Fluent Bit does not start with the infra agent Important Fluent Bit's tail plugin does not support network drives. For Linux versions prior to 2016, you may need to update the OpenSSL library to 1.1.0 (or higher). To check if you have this problem: See if infra-agent has started Fluent Bit by running: ps -aux | grep fluent-bi Copy If it isn't running go to /var/db/newrelic-infra/newrelic-integrations/logging and run: ./fluent-bit -i systemd -o stdout Copy If you get the following error, update OpenSSL to 1.1.0 or higher: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory Copy Runtime error on Windows One of the following error messages may appear when enabling log forwarding on Windows: The code execution cannot proceed because VCRUNTIME140.dll was not found. Copy OR error=\"exit status 3221225781\" process=log-forwarder Copy This is caused by a missing DLL. To solve the issue, install the Microsoft Visual C++ Redistributable as applicable: x64 x86 Errors when tailing a large amount of log files (Linux) It's common to face either one of the following error messages when attempting to tail a large amount of files: Too many open files The user limit on the total number of inotify watches was reached or the kernel failed to allocate a needed resource The operating system defines a maximum amount of allocatable file descriptors (typically 1024 by default), and a maximum amount of allocatable inotify watches (typically 8192 by default). Any process attempting to go above these limits will fail, returning one of the errors above. The underlying technology we use to forward logs, Fluent Bit, opens one file descriptor and sets an inotify watch for each file you configure to be forwarded. Moreover, at the time of writing this section, Fluent Bit uses an extra set of 32 file descriptors for its normal operation, with another extra file descriptor when it shuts down. Therefore, to capture a large amount of files you need to ensure that both the file descriptor and inotify watch limits are slightly greater than the amount of log files you wish to tail. The following instructions summarize how to increase these limits if you want to tail 10,000 log files. Also, it assumes the infrastructure agent is installed in root running mode, and therefore must be run using the root user. Check which is the current hard limit for the amount of file descriptors per process. Typically, this limit should be quite high and should not need to be modified. ulimit -Hn Copy Add the following line to /etc/security/limits.conf. We specified a limit of 10100 here instead of just 10000 to allow Fluent Bit to allocate the extra file descriptors it may need to work. root soft nofile 10100 # replace root by nri-agent for non-root (privileged and unprivileged) installations Copy Add the following line to /etc/pam.d/common-session so that the previous limit is applied upon restart: session required pam_limits.so Copy Add the following line to /etc/sysctl.conf to increase the amount of allowed inotify watchers per user. We specified a limit of 18192 here instead of just 10000 so that the root user will still have 8192 available inotify watches (the default value). fs.inotify.max_user_watches=18192 Copy Restart your system. Ensure that the new limits have been enforced by running: ulimit -Sn # Should return 10100 cat /proc/sys/fs/inotify/max_user_watches # Should return 18192 Copy Learn more on how to increase open file limits, or on how to increase the inotify watches. Uninstall log forwarding To uninstall log forwarding capabilities, go to your logging.d directory, and remove files with the .yml extension that were originally added during the configuration process. Linux: /etc/newrelic-infra/logging.d/ Windows: C:\\Program Files\\New Relic\\newrelic-infra\\logging.d\\ What's next? Explore logging data across your platform with the New Relic One UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our logs in context capabilities. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.85269,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Forward your <em>logs</em> using the <em>infrastructure</em> <em>agent</em>",
        "sections": "Sending the <em>infrastructure</em> <em>agent&#x27;s</em> <em>logs</em> to <em>New</em> <em>Relic</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": " <em>management</em> capabilities to collect, process, explore, query, and alert on your <em>log</em> data. Basic process To forward your <em>logs</em> through our infrastructure monitoring <em>agent</em>: If you haven&#x27;t already, create a <em>New</em> <em>Relic</em> account. It&#x27;s free, forever. Verify the system requirements needed for configuring <em>logs</em>"
      },
      "id": "603e9df164441f6b6f4e8843"
    }
  ],
  "/docs/logs/logs-context/c-sdk-configure-logs-context": [
    {
      "sections": [
        "PHP: Configure logs in context",
        "Set up your PHP app",
        "PHP configuration with Monolog",
        "Tip",
        "PHP configuration with other log forwarders",
        "What's next?"
      ],
      "title": "PHP: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context for PHP"
      ],
      "external_id": "bddc3ec75de7bde2b5eff995d85d11715fd61be9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/configure-logs-context-php/",
      "published_at": "2021-12-04T22:02:35Z",
      "updated_at": "2021-12-04T22:02:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the PHP agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your PHP app To enable logs in context for APM apps monitored by PHP: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest PHP agent version, and enable distributed tracing. Use PHP agent version 9.13.0.270 or higher for logs in context. Install Monolog version 1 or 2, or use a compatible log forwarding plugin if you are not using the built-in Monolog Handler for New Relic. Configure logs in context for PHP using the Monolog extension, if used. PHP configuration with Monolog You must install the Monolog log enricher package before you can configure Monolog for New Relic logs in context. This is done by using Composer to install the newrelic/monolog-enricher package. In most cases, use the Processor and Handler classes provided by the log enricher package in conjunction with Monolog's built-in BufferHandler. The Processor adds the contextual metadata required for New Relic logs in context to operate. The Handler sends the log records to New Relic Logs. The BufferHandler ensures that the logs are delivered with as little overhead as possible. At the point where you create the Monolog\\Logger object, add the following pushProcessor and pushHandler calls to add the Processor and Handler: <?php use Monolog\\Handler\\BufferHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Handler, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $log->pushHandler(new BufferHandler(new Handler)); Copy Tip You can use the Processor and Handler in conjunction with any existing Monolog setup. You do not need to remove your existing processors and handlers. PHP configuration with other log forwarders If you use Monolog to send logs to a compatible log forwarder, and if you have already configured that tool to send logs to New Relic, you can use the Processor and Formatter solely for that tool. This option prevents additional overhead of sending logs directly to New Relic with the Handler. You will need to be using a handler that supports the setFormatter() method, and your logging tool must be able to ingest JSON logs. Here's an example of configuring Monolog to handle other log forwarders: <?php use Monolog\\Handler\\StreamHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Formatter, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $handler = new StreamHandler('php://stderr'); $handler->setFormatter(new Formatter); $log->pushHandler($handler); Copy To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. If the logs from your application do not include fields like trace.id and span.id, there may be a problem with the configuration of the Monolog log enricher. In this situation: Check that the PHP agent for your app has been installed and is configured to enable distributed tracing. Check that your application is using the Monolog logger object when sending log records, not syslog(). Check that another Monolog handler is not preventing the log record from bubbling. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. View your logs in context data in distributed tracing. Note that for PHP, logs in context data doesn't appear in the Logs tab of the APM UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 320.5087,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "PHP: <em>Configure</em> <em>logs</em> <em>in</em> <em>context</em>",
        "sections": "PHP: <em>Configure</em> <em>logs</em> <em>in</em> <em>context</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": "<em>Logs</em> in <em>context</em> for the PHP agent connects your <em>logs</em> and APM data in <em>New</em> <em>Relic</em>. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the <em>log</em> lines that you need to identify and resolve a problem. Set up your PHP app To <em>enable</em> <em>logs</em>"
      },
      "id": "612b7ab4196a6714904948ae"
    },
    {
      "sections": [
        "Logs in context of apps and hosts",
        "See the root cause of issues across your platform",
        "Basic process to enable logs in context",
        "API and other options",
        "What's next?"
      ],
      "title": "Logs in context of apps and hosts",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Configure logs in context"
      ],
      "external_id": "7f77d1e4599c8f7b9b2a44bc817f328f11410651",
      "image": "https://docs.newrelic.com/static/49f9b37d2957292090bdbf226eadacea/c1b63/new-relic-logs-in-context-diagram.png",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/configure-logs-context-apm-agents/",
      "published_at": "2021-12-04T22:01:19Z",
      "updated_at": "2021-11-06T13:15:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you need to correlate log data with other telemetry data, enable logs in context in New Relic. Logs in context adds metadata that links your logs with related APM data, like errors or distributed traces, or your platform performance data from infrastructure monitoring logs in New Relic One. See the root cause of issues across your platform By bringing all of your application and infrastructure data together in a single solution, you can get to the root cause of issues faster. Logs in context help you quickly see meaningful patterns and trends. The following diagram shows the lifecycle of a log message, from enrichment with agent metadata (contextual logging), to formatting and forwarding the log data to New Relic: This diagram illustrates the flow of log messages through New Relic. Don't spend extra time trying to narrow down all your logs from different parts of your platform. Instead, enable logs in context to see the exact log lines you need to identify and resolve a problem. Basic process to enable logs in context The process to enable logs in context is basically the same, regardless of which APM agent you use to monitor your application: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Update to a supported APM agent version for your app, and enable distributed tracing. Configure logs in context for your APM agent or for your infrastructure monitoring agent. View your logs within the context of your apps or infrastructure in New Relic One. The main differences in this procedure are which log appenders you can use to extend and enrich your log data, and how to configure the log appender you select for your APM agent. For detailed information, see the logs-in-context procedures for: C SDK Go Java .NET Node.js PHP Python Ruby Infrastructure monitoring agent API and other options If our logging solutions don't meet your needs, you can use other options to send your log data to New Relic: Logging extensions via agent API calls HTTP endpoint via our Log API Syslog protocols via TCP endpoint (useful for CDNs, hardware devices, or managed services) What's next? Here is an example of logs in context for app trace details, visible in the APM UI. After you set up logs in context for APM or infrastructuring monitoring, make the most of your logging data in the New Relic One UI: Explore the logging data across your platform with our Logs UI. See your logs in context of your app's performance in the APM UI. Troubleshoot errors with distributed tracing, stack traces, application logs, and more. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 264.491,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Logs</em> <em>in</em> <em>context</em> of apps and hosts",
        "sections": "Basic process to <em>enable</em> <em>logs</em> <em>in</em> <em>context</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": " up logging in <em>New</em> <em>Relic</em>. This includes configuring a supported <em>log</em> forwarder that collects your application <em>logs</em> and extends the metadata that is forwarded to <em>New</em> <em>Relic</em>. Update to a supported APM agent version for your app, and <em>enable</em> distributed tracing. <em>Configure</em> <em>logs</em> in <em>context</em> for your APM agent"
      },
      "id": "603ea62e196a6749f8a83dc9"
    },
    {
      "sections": [
        "Java: Configure logs in context",
        "Set up your Java app",
        "Dropwizard 1.3 or higher",
        "java.util.logging",
        "java.util.logging classpath additions",
        "Log4j 1.x",
        "Log4j 2.x",
        "Logback version 1.2.0 or higher",
        "Spring and Springboot",
        "View logs in UI",
        "What's next?"
      ],
      "title": "Java: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Configure logs in context"
      ],
      "external_id": "b9fbeafa564247287e5d6466630d5bdcdb85affb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/java-configure-logs-context-all/",
      "published_at": "2021-12-04T22:03:53Z",
      "updated_at": "2021-10-31T06:46:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the Java agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your Java app To enable logs in context for APM apps monitored by Java: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest Java agent version. Use Java agent version 5.6.0 or higher for logs in context. Enable the JVM argument -javaagent, and enable distributed tracing. Configure logs in context for Java to enrich your log data, using any of the following extensions as applicable. If you use Spring or Spring Boot and aren't sure which extension you need, see our Spring documentation. Dropwizard 1.3 or higher We offer a Dropwizard extension for logs in context with the Java agent. To get started, review the code and an example application on GitHub. To configure logs in context for your Java app with the DropWizard extension: Make sure you have the Dropwizard 1.3 or higher package installed and working on your application. Use the original Dropwizard appenders and logging factory installed and working on the application. Make sure you have the New Relic Java agent version 5.6.0 or higher installed on your application, and that you have enabled the JVM argument -javaagent. Update your project's dependencies to include the Dropwizard 1.3 extension as applicable: Gradle: Add the following to your build.gradle file: dependencies { implementation(\"com.newrelic.logging:dropwizard:2.0\") } Copy Maven: Add the following to your pom.xml file: <dependencies> <dependency> <groupId>com.newrelic.logging</groupId> <artifactId>dropwizard</artifactId> <version>2.0</version> </dependency> </dependencies> Copy Update your Dropwizard .yaml configuration file with a newrelic-json layout, replacing the currently used type: console or type: file with either type: newrelic-console or type: newrelic-file as appropriate. For example: logging: appenders: - type: newrelic-console # Add the two lines below if you don't have a layout specified on the appender. # If you have a layout, remove all parameters to the layout and set the type. layout: type: newrelic-json Copy The New Relic Dropwizard extension also supports a log-format layout type that uses the standard Dropwizard logging. For testing purposes, you can change the type of the layout with a one-line change: logging: appenders: - type: newrelic-file # This format will be ignored by the newrelic-json layout, but used by the log-format layout. logFormat: \"%date{ISO8601} %c %-5p: %m trace.id=%mdc{trace.id} span.id=%mdc{span.id}%n\" layout: # type: newrelic-json type: log-format Copy java.util.logging We offer a java.util.logging extension for logs in context with the Java agent. To get started, review the code and an example application on GitHub. To configure logs in context for your Java app with with the java.util.logging extension: Make sure you have the java.util.logging package installed and working on the application. Make sure you have the New Relic Java agent version 5.6.0 or higher installed on your application, and that you have enabled the JVM argument -javaagent. Update your project's dependencies to include the java.util.logging extension as applicable. If you can't edit these files, you can instead add the jars directly to the application classpath. Gradle: Add the following to your build.gradle file: dependencies { implementation(\"com.newrelic.logging:jul:2.0\") } Copy Maven: Add the following to your pom.xml file: <dependencies> <dependency> <groupId>com.newrelic.logging</groupId> <artifactId>jul</artifactId> <version>2.0</version> </dependency> </dependencies> Copy Check if your logging file's handlers property is set to something other than NewRelicMemoryHandler. Look for a line listing the root logger's handlers, like this: handlers = java.util.logging.FileHandler Copy Update your logging properties file to set the root logger's handler to NewRelicMemoryHandler so it intercepts messages destined for another handler: handlers = com.newrelic.logging.jul.NewRelicMemoryHandler Copy Configure the NewRelicMemoryHandler by setting the target to the handler that was previously assigned to the root logger, so it captures data New Relic needs on the thread the log message is coming from: com.newrelic.logging.jul.NewRelicMemoryHandler.target = java.util.logging.FileHandler Copy Use a NewRelicFormatter for the final handler. Update your logging properties file to set the formatter property like the following example. Make sure the handler where you set the formatter is the target handler from the previous step (java.util.logging.FileHandler in this example). java.util.logging.FileHandler.formatter = com.newrelic.logging.jul. NewRelicFormatter Copy The New Relic log format is JSON with telemetry metadata we use to correlate transactions and logs together. Currently we do not support any customization of that format. Once complete, JSON is logged instead of text. The JSON should be formatted as single objects, one per line, and should contain fields like log.level and thread.name. The trace.id, which is required for logs in context, should only have a value for log messages that occur within a transaction. java.util.logging classpath additions The most direct way to get the logs-in-context extensions is to add these dependencies to Maven's pom.xml or Gradle's build.gradle. This allows the packaging tools to pick up the correct dependencies. If you can't edit these files, you can instead add the jars directly to the application classpath for your logging framework's configuration. Before you modify the classpath: Enable the JVM argument -javaagent on your app's Java agent. Verify which logging framework the application is using. Make sure you are able to change your logging framework's configuration. Add the following three jars to the classpath if they aren't already present. Generally, we recommend taking the latest versions published on Maven Central. Group ID com.newrelic.logging and Artifact ID: Select the artifact named after your application's logging framework in Maven. Group ID com.fasterxml.jackson.core and Artifact ID: Use jackson-core. Group ID com.newrelic.agent.java and Artifact ID: Use newrelic-api. Log4j 1.x We offer a Log4j 1.x extension extension for logs in context with the Java agent. To get started, review the code and an example application on GitHub. To configure logs in context for your Java app with with the Log4j 1.x extension, you must configure the Log4j extension in code or via XML. Properties files are not supported because AsyncAppender instances can only be automatically configured via XML. Make sure you have the Log4j 1.x package installed and working on the application. Make sure you have the New Relic Java agent version 5.6.0 or higher installed on your application, and that you have enabled the JVM argument -javaagent. Update your project's dependencies to include the Log4j 1.x extension as applicable. Gradle: Add the following to your build.gradle file: dependencies { implementation(\"com.newrelic.logging:log4j1:2.0\") } Copy Maven: Add the following to your pom.xml file: <dependencies> <dependency> <groupId>com.newrelic.logging</groupId> <artifactId>log4j1</artifactId> <version>2.0</version> </dependency> </dependencies> Copy In your logging configuration XML file, update your <appender> element with a NewRelicLayout, adding <layout class=\"com.newrelic.logging.log4j1.NewRelicLayout\"/>: <appender name=\" TypicalFile \" class=\"org.apache.log4j.FileAppender\"> <param name=\"file\" value=\"logs/log4j1-app.log\"/> <param name=\"append\" value=\"false\"/> <layout class=\" com.newrelic.logging.log4j1.NewRelicLayout \"/> <!-- only this line needs to be added --> </appender> Copy Use NewRelicAsyncAppender to wrap any appenders that will target New Relic's log forwarder. For example: <appender name=\" NewRelicFile \" class=\"com.newrelic.logging.log4j1.NewRelicAsyncAppender\"> <appender-ref ref=\" TypicalFile \" /> </appender> Copy Use the async appender on the root logger. For example: <root> <appender-ref ref=\" NewRelicFile \" /> </root> Copy Example configuration file for the Log4j 1.x extension: <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <!DOCTYPE log4j:configuration SYSTEM \"log4j.dtd\"> <log4j:configuration debug=\"false\"> <appender name=\"TypicalFile\" class=\"org.apache.log4j.FileAppender\"> <param name=\"file\" value=\"logs/log4j1-app.log\"/> <param name=\"append\" value=\"false\"/> <!-- layout has been replaced --> <layout class=\"com.newrelic.logging.log4j1.NewRelicLayout\"/> </appender> <!-- this appender was added --> <appender name=\"NewRelicFile\" class=\"com.newrelic.logging.log4j1.NewRelicAsyncAppender\"> <appender-ref ref=\"TypicalFile\" /> </appender> <appender name=\"TypicalConsole\" class=\"org.apache.log4j.ConsoleAppender\"> <layout class=\"org.apache.log4j.PatternLayout\"> <param name=\"ConversionPattern\" value=\"%-5p %c{1} - %m%n\"/> </layout> </appender> <root> ​ <!-- the new appender was used here -->​​ <appender-ref ref=\"NewRelicFile\" /> <appender-ref ref=\"TypicalConsole\" /> </root> </log4j:configuration> Copy Log4j 2.x We offer a Log4j 2.x extension for logs in context with the Java agent. To get started, review the code and an example application on GitHub. To configure logs in context for your Java app with with the Log4j 2.x extension: Make sure you have the Log4j 2.x or Logs4j 2 binding package installed and working on your application. Make sure you have the New Relic Java agent version 5.6.0 or higher installed on your application, and that you have enabled the JVM argument -javaagent. Update your project's dependencies to include the Log4j 2.x extension as applicable: Gradle: Add the highlighted section to your build.gradle file: dependencies { implementation(\"com.newrelic.logging:log4j2:2.0\") } Copy Maven: Add the highlighted section to your pom.xml file: <dependencies> <dependency> <groupId>com.newrelic.logging</groupId> <artifactId>log4j2</artifactId> <version>2.0</version> </dependency> </dependencies> Copy In your logging configuration XML file, update your <configuration> element by adding the highlighted section: <Configuration xmlns=\"http://logging.apache.org/log4j/2.0/config\" packages=\"com.newrelic.logging.log4j2\" > Copy If you're using a properties file, add packages=com.newrelic.logging.log4j2. Add <NewRelicLayout/> to use a NewRelicLayout element within one of the appenders. For example: <File name=\"MyFile\" fileName=\"logs/app-log-file.log\"> <NewRelicLayout/> </File> Copy If you're using a properties file, only change the layout.type: appender.console.type = Console appender.console.name = STDOUT appender.console.layout.type = NewRelicLayout Copy If you only modified an existing appender, skip this step. If you added a new appender, add <AppenderRef/> within <Root> to use this appender. Use the ref attribute to refer to appender name you created in the previous step. For example: <Root level=\"info\"> <AppenderRef ref=\"MyFile\"/> </Root> Copy If you're using a properties file and added a new appender, add: rootLogger.level = info rootLogger.appenderRef.stdout.ref = STDOUT ​​​​​ Copy Logback version 1.2.0 or higher We offer a Logback extension for logs in context with the Java agent. To get started, review the code and an example application on GitHub. To configure logs in context for your Java app with Logback: Make sure you have Logback version 1.2.0 or higher and the New Relic Java agent version 5.6.0 or higher installed and working on your application. Make sure you have the New Relic Java agent version 5.6.0 or higher installed on your application, and that you have enabled the JVM argument -javaagent. Update your project's dependencies to include the Logback extension as applicable: Gradle: Add the highlighted section to your build.gradle file: dependencies { implementation(\"com.newrelic.logging:logback:2.0\") } Copy Maven: Add the highlighted section to your pom.xml file: <dependencies> <dependency> <groupId>com.newrelic.logging</groupId> <artifactId>logback</artifactId> <version>2.0</version> </dependency> </dependencies> Copy Update your logging configuration xml to replace any existing <encoder> element. If you're logging to the console (stdout/stderr), look for ConsoleAppender and replace: <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"> <encoder class=\"com.newrelic.logging.logback.NewRelicEncoder\"/> </appender> Copy If you're logging to a file, look for FileAppender and replace <encoder>: <appender name=\"LOG_FILE\" class=\"ch.qos.logback.core.FileAppender\"> <file>logs/app-log-file.log</file> <encoder class=\"com.newrelic.logging.logback.NewRelicEncoder\"/> </appender> Copy Update your logging configuration xml with the NewRelicAsyncAppender. To ensure that NewRelicAsyncAppender wraps any appenders that will target New Relic's log forwarder, add the following section. Change \"LOG_FILE\" to the name of the appender you updated in the previous step. <appender name=\"ASYNC\" class=\"com.newrelic.logging.logback.NewRelicAsyncAppender\"> <appender-ref ref=\"LOG_FILE\" /> </appender> Copy Make sure NewRelicAsyncAppender is the first appender used in your logger. Replace your root logger’s appenders with the ASYNC appender created in the previous step. Then list any other appenders after the NewRelicAsyncAppender in the <root> list. <root> <appender-ref ref=\"ASYNC\" /> </root> Copy Here are examples of an updated logging .xml file for the Logback extension. You can also see a working example in GitHub. Single console appender example Example configuration file after adding in the logging extension information: <configuration> <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"> <!-- changed the encoder --> <encoder class=\"com.newrelic.logging.logback.NewRelicEncoder\"/> </appender> <!-- added the ASYNC appender --> <appender name=\"ASYNC\" class=\"com.newrelic.logging.logback.NewRelicAsyncAppender\"> <appender-ref ref=\"STDOUT\" /> </appender> <root level=\"debug\"> <!-- changed the root logger --> <appender-ref ref=\"ASYNC\" /> </root> </configuration> Copy Two console appenders example This example sends New Relic logging to a file, but still sends standard logging to the console: <configuration> <appender name=\"FILE\" class=\"ch.qos.logback.core.FileAppender\"> <file>myApp.log</file> <!-- encoder changed --> <encoder class=\"com.newrelic.logging.logback.NewRelicEncoder\"/> </appender> <!-- this appender does normal console logging --> <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"> <encoder> <pattern>%msg%n</pattern> </encoder> </appender> <!-- The required New Relic ASYNC appender wraps the FILE appender --> <appender name=\"ASYNC\" class=\"com.newrelic.logging.logback.NewRelicAsyncAppender\"> <appender-ref ref=\"FILE\" /> </appender> <root level=\"debug\"> <!-- ASYNC is one of the main appenders --> <appender-ref ref=\"ASYNC\" /> <!-- Send every message to normal console logging, as well. --> <appender-ref ref=\"STDOUT\" /> </root> </configuration> Copy Spring and Springboot We offer extensions for current versions of Spring and Spring Boot. If you already know the logging library, you can skip directly to that documentation: java.util.logging log4j 1 log4j 2 logback The extensions support default configurations only on Spring Boot 2.0 and higher. With Spring Boot: Here are tips to determine which logging library you have: If you have spring-boot-starter-log4j2 in your dependencies, you're using log4j 2.x. Refer to the Spring Boot log4j 2.x documentation for basic configuration, and the New Relic log4j 2 extension for customizing your configuration. If you're using Spring Boot but not the starter-log4j2, you're using logback by default. Refer to Spring Boot logback documentation for basic configuration, and the New Relic logback extension for customizing your configuration. With Spring (but not Spring Boot): Spring 5 or higher: Spring implements a bridge to other logging libraries that will automatically find them. However, those individual libraries must be configured and explicitly included in your project dependencies. To identify your logging dependency, consult your Gradle, Maven, or other build tool's dependency tree. Then follow the procedures to configure logs in context for your Java app with that extension. Spring 4 or lower: Spring version 4 and lower uses Apache Commons Logging for its bridge. Refer to the Spring documentation for information on configuring its bridge. View logs in UI To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. See your logs in context of your app's performance in the APM UI. Troubleshoot errors with distributed tracing, stack traces, application logs, and more. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 256.69666,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Java: <em>Configure</em> <em>logs</em> <em>in</em> <em>context</em>",
        "sections": "Java: <em>Configure</em> <em>logs</em> <em>in</em> <em>context</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": "<em>Logs</em> in <em>context</em> for the Java agent connects your <em>logs</em> and APM data in <em>New</em> <em>Relic</em>. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the <em>log</em> lines that you need to identify and resolve a problem. Set up your Java app To <em>enable</em> <em>logs</em>"
      },
      "id": "612efca3e7b9d2f718b6f223"
    }
  ],
  "/docs/logs/logs-context/configure-logs-context-apm-agents": [
    {
      "sections": [
        "PHP: Configure logs in context",
        "Set up your PHP app",
        "PHP configuration with Monolog",
        "Tip",
        "PHP configuration with other log forwarders",
        "What's next?"
      ],
      "title": "PHP: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context for PHP"
      ],
      "external_id": "bddc3ec75de7bde2b5eff995d85d11715fd61be9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/configure-logs-context-php/",
      "published_at": "2021-12-04T22:02:35Z",
      "updated_at": "2021-12-04T22:02:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the PHP agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your PHP app To enable logs in context for APM apps monitored by PHP: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest PHP agent version, and enable distributed tracing. Use PHP agent version 9.13.0.270 or higher for logs in context. Install Monolog version 1 or 2, or use a compatible log forwarding plugin if you are not using the built-in Monolog Handler for New Relic. Configure logs in context for PHP using the Monolog extension, if used. PHP configuration with Monolog You must install the Monolog log enricher package before you can configure Monolog for New Relic logs in context. This is done by using Composer to install the newrelic/monolog-enricher package. In most cases, use the Processor and Handler classes provided by the log enricher package in conjunction with Monolog's built-in BufferHandler. The Processor adds the contextual metadata required for New Relic logs in context to operate. The Handler sends the log records to New Relic Logs. The BufferHandler ensures that the logs are delivered with as little overhead as possible. At the point where you create the Monolog\\Logger object, add the following pushProcessor and pushHandler calls to add the Processor and Handler: <?php use Monolog\\Handler\\BufferHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Handler, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $log->pushHandler(new BufferHandler(new Handler)); Copy Tip You can use the Processor and Handler in conjunction with any existing Monolog setup. You do not need to remove your existing processors and handlers. PHP configuration with other log forwarders If you use Monolog to send logs to a compatible log forwarder, and if you have already configured that tool to send logs to New Relic, you can use the Processor and Formatter solely for that tool. This option prevents additional overhead of sending logs directly to New Relic with the Handler. You will need to be using a handler that supports the setFormatter() method, and your logging tool must be able to ingest JSON logs. Here's an example of configuring Monolog to handle other log forwarders: <?php use Monolog\\Handler\\StreamHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Formatter, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $handler = new StreamHandler('php://stderr'); $handler->setFormatter(new Formatter); $log->pushHandler($handler); Copy To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. If the logs from your application do not include fields like trace.id and span.id, there may be a problem with the configuration of the Monolog log enricher. In this situation: Check that the PHP agent for your app has been installed and is configured to enable distributed tracing. Check that your application is using the Monolog logger object when sending log records, not syslog(). Check that another Monolog handler is not preventing the log record from bubbling. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. View your logs in context data in distributed tracing. Note that for PHP, logs in context data doesn't appear in the Logs tab of the APM UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 320.50854,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "PHP: <em>Configure</em> <em>logs</em> <em>in</em> <em>context</em>",
        "sections": "PHP: <em>Configure</em> <em>logs</em> <em>in</em> <em>context</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": "<em>Logs</em> in <em>context</em> for the PHP agent connects your <em>logs</em> and APM data in <em>New</em> <em>Relic</em>. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the <em>log</em> lines that you need to identify and resolve a problem. Set up your PHP app To <em>enable</em> <em>logs</em>"
      },
      "id": "612b7ab4196a6714904948ae"
    },
    {
      "sections": [
        "Java: Configure logs in context",
        "Set up your Java app",
        "Dropwizard 1.3 or higher",
        "java.util.logging",
        "java.util.logging classpath additions",
        "Log4j 1.x",
        "Log4j 2.x",
        "Logback version 1.2.0 or higher",
        "Spring and Springboot",
        "View logs in UI",
        "What's next?"
      ],
      "title": "Java: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Configure logs in context"
      ],
      "external_id": "b9fbeafa564247287e5d6466630d5bdcdb85affb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/java-configure-logs-context-all/",
      "published_at": "2021-12-04T22:03:53Z",
      "updated_at": "2021-10-31T06:46:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the Java agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your Java app To enable logs in context for APM apps monitored by Java: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest Java agent version. Use Java agent version 5.6.0 or higher for logs in context. Enable the JVM argument -javaagent, and enable distributed tracing. Configure logs in context for Java to enrich your log data, using any of the following extensions as applicable. If you use Spring or Spring Boot and aren't sure which extension you need, see our Spring documentation. Dropwizard 1.3 or higher We offer a Dropwizard extension for logs in context with the Java agent. To get started, review the code and an example application on GitHub. To configure logs in context for your Java app with the DropWizard extension: Make sure you have the Dropwizard 1.3 or higher package installed and working on your application. Use the original Dropwizard appenders and logging factory installed and working on the application. Make sure you have the New Relic Java agent version 5.6.0 or higher installed on your application, and that you have enabled the JVM argument -javaagent. Update your project's dependencies to include the Dropwizard 1.3 extension as applicable: Gradle: Add the following to your build.gradle file: dependencies { implementation(\"com.newrelic.logging:dropwizard:2.0\") } Copy Maven: Add the following to your pom.xml file: <dependencies> <dependency> <groupId>com.newrelic.logging</groupId> <artifactId>dropwizard</artifactId> <version>2.0</version> </dependency> </dependencies> Copy Update your Dropwizard .yaml configuration file with a newrelic-json layout, replacing the currently used type: console or type: file with either type: newrelic-console or type: newrelic-file as appropriate. For example: logging: appenders: - type: newrelic-console # Add the two lines below if you don't have a layout specified on the appender. # If you have a layout, remove all parameters to the layout and set the type. layout: type: newrelic-json Copy The New Relic Dropwizard extension also supports a log-format layout type that uses the standard Dropwizard logging. For testing purposes, you can change the type of the layout with a one-line change: logging: appenders: - type: newrelic-file # This format will be ignored by the newrelic-json layout, but used by the log-format layout. logFormat: \"%date{ISO8601} %c %-5p: %m trace.id=%mdc{trace.id} span.id=%mdc{span.id}%n\" layout: # type: newrelic-json type: log-format Copy java.util.logging We offer a java.util.logging extension for logs in context with the Java agent. To get started, review the code and an example application on GitHub. To configure logs in context for your Java app with with the java.util.logging extension: Make sure you have the java.util.logging package installed and working on the application. Make sure you have the New Relic Java agent version 5.6.0 or higher installed on your application, and that you have enabled the JVM argument -javaagent. Update your project's dependencies to include the java.util.logging extension as applicable. If you can't edit these files, you can instead add the jars directly to the application classpath. Gradle: Add the following to your build.gradle file: dependencies { implementation(\"com.newrelic.logging:jul:2.0\") } Copy Maven: Add the following to your pom.xml file: <dependencies> <dependency> <groupId>com.newrelic.logging</groupId> <artifactId>jul</artifactId> <version>2.0</version> </dependency> </dependencies> Copy Check if your logging file's handlers property is set to something other than NewRelicMemoryHandler. Look for a line listing the root logger's handlers, like this: handlers = java.util.logging.FileHandler Copy Update your logging properties file to set the root logger's handler to NewRelicMemoryHandler so it intercepts messages destined for another handler: handlers = com.newrelic.logging.jul.NewRelicMemoryHandler Copy Configure the NewRelicMemoryHandler by setting the target to the handler that was previously assigned to the root logger, so it captures data New Relic needs on the thread the log message is coming from: com.newrelic.logging.jul.NewRelicMemoryHandler.target = java.util.logging.FileHandler Copy Use a NewRelicFormatter for the final handler. Update your logging properties file to set the formatter property like the following example. Make sure the handler where you set the formatter is the target handler from the previous step (java.util.logging.FileHandler in this example). java.util.logging.FileHandler.formatter = com.newrelic.logging.jul. NewRelicFormatter Copy The New Relic log format is JSON with telemetry metadata we use to correlate transactions and logs together. Currently we do not support any customization of that format. Once complete, JSON is logged instead of text. The JSON should be formatted as single objects, one per line, and should contain fields like log.level and thread.name. The trace.id, which is required for logs in context, should only have a value for log messages that occur within a transaction. java.util.logging classpath additions The most direct way to get the logs-in-context extensions is to add these dependencies to Maven's pom.xml or Gradle's build.gradle. This allows the packaging tools to pick up the correct dependencies. If you can't edit these files, you can instead add the jars directly to the application classpath for your logging framework's configuration. Before you modify the classpath: Enable the JVM argument -javaagent on your app's Java agent. Verify which logging framework the application is using. Make sure you are able to change your logging framework's configuration. Add the following three jars to the classpath if they aren't already present. Generally, we recommend taking the latest versions published on Maven Central. Group ID com.newrelic.logging and Artifact ID: Select the artifact named after your application's logging framework in Maven. Group ID com.fasterxml.jackson.core and Artifact ID: Use jackson-core. Group ID com.newrelic.agent.java and Artifact ID: Use newrelic-api. Log4j 1.x We offer a Log4j 1.x extension extension for logs in context with the Java agent. To get started, review the code and an example application on GitHub. To configure logs in context for your Java app with with the Log4j 1.x extension, you must configure the Log4j extension in code or via XML. Properties files are not supported because AsyncAppender instances can only be automatically configured via XML. Make sure you have the Log4j 1.x package installed and working on the application. Make sure you have the New Relic Java agent version 5.6.0 or higher installed on your application, and that you have enabled the JVM argument -javaagent. Update your project's dependencies to include the Log4j 1.x extension as applicable. Gradle: Add the following to your build.gradle file: dependencies { implementation(\"com.newrelic.logging:log4j1:2.0\") } Copy Maven: Add the following to your pom.xml file: <dependencies> <dependency> <groupId>com.newrelic.logging</groupId> <artifactId>log4j1</artifactId> <version>2.0</version> </dependency> </dependencies> Copy In your logging configuration XML file, update your <appender> element with a NewRelicLayout, adding <layout class=\"com.newrelic.logging.log4j1.NewRelicLayout\"/>: <appender name=\" TypicalFile \" class=\"org.apache.log4j.FileAppender\"> <param name=\"file\" value=\"logs/log4j1-app.log\"/> <param name=\"append\" value=\"false\"/> <layout class=\" com.newrelic.logging.log4j1.NewRelicLayout \"/> <!-- only this line needs to be added --> </appender> Copy Use NewRelicAsyncAppender to wrap any appenders that will target New Relic's log forwarder. For example: <appender name=\" NewRelicFile \" class=\"com.newrelic.logging.log4j1.NewRelicAsyncAppender\"> <appender-ref ref=\" TypicalFile \" /> </appender> Copy Use the async appender on the root logger. For example: <root> <appender-ref ref=\" NewRelicFile \" /> </root> Copy Example configuration file for the Log4j 1.x extension: <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <!DOCTYPE log4j:configuration SYSTEM \"log4j.dtd\"> <log4j:configuration debug=\"false\"> <appender name=\"TypicalFile\" class=\"org.apache.log4j.FileAppender\"> <param name=\"file\" value=\"logs/log4j1-app.log\"/> <param name=\"append\" value=\"false\"/> <!-- layout has been replaced --> <layout class=\"com.newrelic.logging.log4j1.NewRelicLayout\"/> </appender> <!-- this appender was added --> <appender name=\"NewRelicFile\" class=\"com.newrelic.logging.log4j1.NewRelicAsyncAppender\"> <appender-ref ref=\"TypicalFile\" /> </appender> <appender name=\"TypicalConsole\" class=\"org.apache.log4j.ConsoleAppender\"> <layout class=\"org.apache.log4j.PatternLayout\"> <param name=\"ConversionPattern\" value=\"%-5p %c{1} - %m%n\"/> </layout> </appender> <root> ​ <!-- the new appender was used here -->​​ <appender-ref ref=\"NewRelicFile\" /> <appender-ref ref=\"TypicalConsole\" /> </root> </log4j:configuration> Copy Log4j 2.x We offer a Log4j 2.x extension for logs in context with the Java agent. To get started, review the code and an example application on GitHub. To configure logs in context for your Java app with with the Log4j 2.x extension: Make sure you have the Log4j 2.x or Logs4j 2 binding package installed and working on your application. Make sure you have the New Relic Java agent version 5.6.0 or higher installed on your application, and that you have enabled the JVM argument -javaagent. Update your project's dependencies to include the Log4j 2.x extension as applicable: Gradle: Add the highlighted section to your build.gradle file: dependencies { implementation(\"com.newrelic.logging:log4j2:2.0\") } Copy Maven: Add the highlighted section to your pom.xml file: <dependencies> <dependency> <groupId>com.newrelic.logging</groupId> <artifactId>log4j2</artifactId> <version>2.0</version> </dependency> </dependencies> Copy In your logging configuration XML file, update your <configuration> element by adding the highlighted section: <Configuration xmlns=\"http://logging.apache.org/log4j/2.0/config\" packages=\"com.newrelic.logging.log4j2\" > Copy If you're using a properties file, add packages=com.newrelic.logging.log4j2. Add <NewRelicLayout/> to use a NewRelicLayout element within one of the appenders. For example: <File name=\"MyFile\" fileName=\"logs/app-log-file.log\"> <NewRelicLayout/> </File> Copy If you're using a properties file, only change the layout.type: appender.console.type = Console appender.console.name = STDOUT appender.console.layout.type = NewRelicLayout Copy If you only modified an existing appender, skip this step. If you added a new appender, add <AppenderRef/> within <Root> to use this appender. Use the ref attribute to refer to appender name you created in the previous step. For example: <Root level=\"info\"> <AppenderRef ref=\"MyFile\"/> </Root> Copy If you're using a properties file and added a new appender, add: rootLogger.level = info rootLogger.appenderRef.stdout.ref = STDOUT ​​​​​ Copy Logback version 1.2.0 or higher We offer a Logback extension for logs in context with the Java agent. To get started, review the code and an example application on GitHub. To configure logs in context for your Java app with Logback: Make sure you have Logback version 1.2.0 or higher and the New Relic Java agent version 5.6.0 or higher installed and working on your application. Make sure you have the New Relic Java agent version 5.6.0 or higher installed on your application, and that you have enabled the JVM argument -javaagent. Update your project's dependencies to include the Logback extension as applicable: Gradle: Add the highlighted section to your build.gradle file: dependencies { implementation(\"com.newrelic.logging:logback:2.0\") } Copy Maven: Add the highlighted section to your pom.xml file: <dependencies> <dependency> <groupId>com.newrelic.logging</groupId> <artifactId>logback</artifactId> <version>2.0</version> </dependency> </dependencies> Copy Update your logging configuration xml to replace any existing <encoder> element. If you're logging to the console (stdout/stderr), look for ConsoleAppender and replace: <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"> <encoder class=\"com.newrelic.logging.logback.NewRelicEncoder\"/> </appender> Copy If you're logging to a file, look for FileAppender and replace <encoder>: <appender name=\"LOG_FILE\" class=\"ch.qos.logback.core.FileAppender\"> <file>logs/app-log-file.log</file> <encoder class=\"com.newrelic.logging.logback.NewRelicEncoder\"/> </appender> Copy Update your logging configuration xml with the NewRelicAsyncAppender. To ensure that NewRelicAsyncAppender wraps any appenders that will target New Relic's log forwarder, add the following section. Change \"LOG_FILE\" to the name of the appender you updated in the previous step. <appender name=\"ASYNC\" class=\"com.newrelic.logging.logback.NewRelicAsyncAppender\"> <appender-ref ref=\"LOG_FILE\" /> </appender> Copy Make sure NewRelicAsyncAppender is the first appender used in your logger. Replace your root logger’s appenders with the ASYNC appender created in the previous step. Then list any other appenders after the NewRelicAsyncAppender in the <root> list. <root> <appender-ref ref=\"ASYNC\" /> </root> Copy Here are examples of an updated logging .xml file for the Logback extension. You can also see a working example in GitHub. Single console appender example Example configuration file after adding in the logging extension information: <configuration> <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"> <!-- changed the encoder --> <encoder class=\"com.newrelic.logging.logback.NewRelicEncoder\"/> </appender> <!-- added the ASYNC appender --> <appender name=\"ASYNC\" class=\"com.newrelic.logging.logback.NewRelicAsyncAppender\"> <appender-ref ref=\"STDOUT\" /> </appender> <root level=\"debug\"> <!-- changed the root logger --> <appender-ref ref=\"ASYNC\" /> </root> </configuration> Copy Two console appenders example This example sends New Relic logging to a file, but still sends standard logging to the console: <configuration> <appender name=\"FILE\" class=\"ch.qos.logback.core.FileAppender\"> <file>myApp.log</file> <!-- encoder changed --> <encoder class=\"com.newrelic.logging.logback.NewRelicEncoder\"/> </appender> <!-- this appender does normal console logging --> <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"> <encoder> <pattern>%msg%n</pattern> </encoder> </appender> <!-- The required New Relic ASYNC appender wraps the FILE appender --> <appender name=\"ASYNC\" class=\"com.newrelic.logging.logback.NewRelicAsyncAppender\"> <appender-ref ref=\"FILE\" /> </appender> <root level=\"debug\"> <!-- ASYNC is one of the main appenders --> <appender-ref ref=\"ASYNC\" /> <!-- Send every message to normal console logging, as well. --> <appender-ref ref=\"STDOUT\" /> </root> </configuration> Copy Spring and Springboot We offer extensions for current versions of Spring and Spring Boot. If you already know the logging library, you can skip directly to that documentation: java.util.logging log4j 1 log4j 2 logback The extensions support default configurations only on Spring Boot 2.0 and higher. With Spring Boot: Here are tips to determine which logging library you have: If you have spring-boot-starter-log4j2 in your dependencies, you're using log4j 2.x. Refer to the Spring Boot log4j 2.x documentation for basic configuration, and the New Relic log4j 2 extension for customizing your configuration. If you're using Spring Boot but not the starter-log4j2, you're using logback by default. Refer to Spring Boot logback documentation for basic configuration, and the New Relic logback extension for customizing your configuration. With Spring (but not Spring Boot): Spring 5 or higher: Spring implements a bridge to other logging libraries that will automatically find them. However, those individual libraries must be configured and explicitly included in your project dependencies. To identify your logging dependency, consult your Gradle, Maven, or other build tool's dependency tree. Then follow the procedures to configure logs in context for your Java app with that extension. Spring 4 or lower: Spring version 4 and lower uses Apache Commons Logging for its bridge. Refer to the Spring documentation for information on configuring its bridge. View logs in UI To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. See your logs in context of your app's performance in the APM UI. Troubleshoot errors with distributed tracing, stack traces, application logs, and more. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 256.69666,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Java: <em>Configure</em> <em>logs</em> <em>in</em> <em>context</em>",
        "sections": "Java: <em>Configure</em> <em>logs</em> <em>in</em> <em>context</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": "<em>Logs</em> in <em>context</em> for the Java agent connects your <em>logs</em> and APM data in <em>New</em> <em>Relic</em>. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the <em>log</em> lines that you need to identify and resolve a problem. Set up your Java app To <em>enable</em> <em>logs</em>"
      },
      "id": "612efca3e7b9d2f718b6f223"
    },
    {
      "sections": [
        ".NET: Configure logs in context",
        "Set up your .NET app",
        "Configure log4net extension",
        "log4net workflow diagram",
        "log4net 2.0.8 or higher configuration",
        "Configure NLog extension",
        "Nlog workflow diagram",
        "Nlog 4.5 or higher configuration",
        "Nlog file-based configuration",
        "Configure Serilog 2.5 or higher extension",
        "Serilog workflow diagram",
        "Serilog 2.5 or higher configuration",
        "Serilog file-based configuration",
        "View logs in the UI",
        "What's next?"
      ],
      "title": ".NET: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Configure logs in context"
      ],
      "external_id": "69a3fc9dab232e3ebfdeccceace39b1014b70beb",
      "image": "https://docs.newrelic.com/static/a3260353a0e479f8512b94e9eb3adb11/c1b63/LogsInContext-Log4Net.png",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/net-configure-logs-context-all/",
      "published_at": "2021-12-04T22:03:15Z",
      "updated_at": "2021-10-24T23:38:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the .NET agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your .NET app To enable logs in context for APM apps monitored by .NET: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest .NET agent version, and enable distributed tracing. Use .NET agent version 8.21 or higher and the New Relic .NET agent API version 8.21 or higher for logs in context. Install or update to Microsoft .NET Framework 4.5 or higher or .NET Core 2.0 or higher. Install and configure any of the following logging extensions to enrich your log data, including: log4net NLog Serilog Check your log data in the New Relic UI. Configure log4net extension You can use the Apache log4net version 2.0.8 or higher extension to link your log data with related data across the rest of the New Relic platform. log4net workflow diagram The following diagram illustrates the flow of log messages through Apache log4net, highlighting specific components of the New Relic log4net extension. Many log forwarders are available. This example uses Fluentd. Appender: The NewRelicAppender adds contextual information from the .NET agent (using the API) to the log events generated by the application. This contextual information, known as linking metadata, is used by New Relic to link log messages to the transactions and spans from which they were created. This appender will pass the enriched log events to downstream appenders for further processing. Since the NewRelicAppender is ForwardingAppender type, it needs to be the first appender in the chain. It also requires another appender that can write to an actual output destination as its child in order to work. Layout: The NewRelicLayout formats the enriched log events into the JSON format expected by New Relic. The appender, which this layout is assigned to, instructs log4net to output the JSON to a file in the location that the log forwarder expects. Log Forwarder: The log forwarder monitors an output folder and incrementally sends the properly formatted and enriched log information to the New Relic logging endpoint. log4net 2.0.8 or higher configuration Log4net uses appender and layout to store and format log messages. NewRelicAppender enriches log messages with contextual information from the New Relic .NET agent if it is attached to your application. The appender passes enriched log messages to downstream appenders to handle specific use cases for log messages. For more information about logging with log4net, see the Apache log4net Getting started documentation. To configure logs in context with the log4net extension: Using the Visual Studio NuGet Package Manager, locate and install the NewRelic.LogEnrichers.Log4Net package. In your log4net configuration file, update your logging configuration to use the NewRelicAppender as the first level appender, and reference your existing appenders as its children. Also replace the layout of the appender that writes log messages to an output destination with the NewRelicLayout. The following log4net configuration example enriches log events with New Relic linking metadata. In addition to the existing log files, it outputs new log files in a specific JSON format at C:\\logs\\log4netExample.log.json for consumption by the log forwarder: <log4net> <root> <level value=\"ALL\" /> <appender-ref ref=\"NewRelicAppender\" /> </root> <appender name=\"NewRelicAppender\" type=\"NewRelic.LogEnrichers.Log4Net.NewRelicAppender, NewRelic.LogEnrichers.Log4Net\" > <threshold value=\"ALL\"/> <appender-ref ref=\"FileAppender\" /> </appender> <appender name=\"FileAppender\" type=\"log4net.Appender.FileAppender\"> <file value=\"C:\\logs\\log4netExample.log.json\" /> <param name=\"AppendToFile\" value=\"true\" /> <layout type=\"NewRelic.LogEnrichers.Log4Net.NewRelicLayout, NewRelic.LogEnrichers.Log4Net\"> </layout> </appender> </log4net> Copy After you configure the log4net extension and update your logging file, you can configure your extension to send data to New Relic. Here is an example configuration using the Fluentd plugin for New Relic Logs: <!--NewRelicLoggingExample.conf--> <source> @type tail path C:\\logs\\log4netExample.log.json pos_file C:\\logs\\log4netExample.log.json.pos tag logfile.* <parse> @type json </parse> </source> <match **> @type newrelic license_key <YOUR NEW_RELIC_LICENSE_KEY> base_uri https://log-api.newrelic.com/log/v1 </match> Copy Configure NLog extension You can use our NLog 4.5 or higher extension to link to your log data with related data across the rest of the New Relic platform. Nlog workflow diagram The New Relic NLog extension provides a NewRelicJsonLayout that formats a log event in the way required by the New Relic logging endpoint. Next, it adds contextual information from the .NET agent when attached to your application. Then, a target can be configured to write logging data to an output folder. The log forwarder can monitor this folder and incrementally send log information to New Relic. The following diagram illustrates the flow of log messages through NLog, highlighting specific components of the New Relic NLog extension. New Relic JSON Layout: The NewRelicJsonLayout adds contextual information from the .NET agent (using the API) to the log events generated by the application, and outputs log messages in the JSON format expected by New Relic. This contextual information, known as linking metadata, is used by New Relic to link log messages to the transactions and spans where they were created. Since the NewRelicAppender is ForwardingAppender type, it needs to be the first appender in the chain. It also requires another appender that can write to an actual output destination as its child in order to work. File Target: A FileTarget defines a file on disk where log messages are written. Adding the NewRelicJsonLayout to that target allows the output to be formatted correctly for forwarding to New Relic. Log Forwarder: The log forwarder is configured to send the properly formatted and enriched log data from the FileTarget output to the New Relic logging endpoint. For more information about logging with NLog, see the nlog-project.org documentation. Nlog 4.5 or higher configuration Use our NLog 4.5 or higher extension to link to your log data with related data across the rest of the New Relic platform. Using the Visual Studio NuGet Package Manager, locate and install the NewRelic.LogEnrichers.NLog package. In your application code, update your logging configuration to add the NewRelicJsonLayout and decide if you want to collect MappedDiagnosticsContext (MDC) or the MappedDiagnosticsLogicalContext (MDLC) data. The following configuration examples result in new JSON files that are written to disk. Some of these configuration options may be useful for managing the amount of disk space used and/or the performance of the target. archiveAboveSize maxArchiveFiles bufferSize enableArchiveFileCompression autoFlush concurrentWrites Although the NLog AsyncWrapper Target is not required, it may help improve performance by performing formatting and output of log files on a different thread. Don't collect MDC or the MDLC data (default): The following code example enriches log events with New Relic linking metadata, but not with MDC or the MDLC data. In addition to the existing log files, it outputs new log files in a specific JSON format at C:\\logs\\NLogExample.log.json for consumption by the log forwarder: var loggerConfig = new LoggingConfiguration(); var newRelicFileTarget = new FileTarget(\"NewRelicFileTarget\"); newRelicFileTarget.Layout = new NewRelicJsonLayout(); newRelicFileTarget.FileName = \"C:\\logs\\NLogExample.json\"; loggerConfig.AddTarget(newRelicFileTarget); loggerConfig.AddRuleForAllLevels(\"NewRelicFileTarget\"); LogManager.Configuration = loggerConfig; var logger = LogManager.GetLogger(\"Example\"); Copy Collect MDC or the MDLC data: If your application uses the MDC or the MDLC, you can configure the NewRelicJsonLayout to include items in those collections. The following code example adds the additional configuration to enable collecting MDC and MDLC data. As in the previous example, it outputs new log files in a specific JSON format at C:\\logs\\NLogExample.log.json for consumption by the log forwarder: var loggerConfig = new LoggingConfiguration(); var newRelicFileTarget = new FileTarget(\"NewRelicFileTarget\"); var newRelicLayout = new NewRelicJsonLayout { IncludeMdc = `true,` IncludeMdlc = `true` }; newRelicFileTarget.Layout = newRelicLayout; newRelicFileTarget.FileName = \"C:\\logs\\NLogExample.json\"; loggerConfig.AddTarget(newRelicFileTarget); loggerConfig.AddRuleForAllLevels(\"NewRelicFileTarget\"); LogManager.Configuration = loggerConfig; var logger = LogManager.GetLogger(\"Example\"); Copy Once you have configured the NLog extension and updated your logging file, you can configure your extension to send data to New Relic. Here is an example configuration using the Fluentd plugin to forward logs to New Relic: <!--NewRelicLoggingExample.conf--> <source> @type tail path C:\\logs\\NLogExample.log.json pos_file C:\\logs\\NLogExample.log.json.pos tag logfile.* <parse> @type json </parse> </source> <match **> @type newrelic license_key <YOUR NEW_RELIC_LICENSE_KEY> base_uri https://log-api.newrelic.com/log/v1 </match> Copy Nlog file-based configuration You can also configure the New Relic NLog extension with file-based configuration providers. The folowing example code creates a logger based on settings contained in an App.config file. Instantiating Logger using .config file var logger = LogManager.GetLogger(\"NewRelicLog\"); logger.Info(\"Hello, New Relic!\"); Copy Sample App.config file <?xml version=\"1.0\" encoding=\"utf-8\" ?> <configuration> <configSections> <section name=\"nlog\" type=\"NLog.Config.ConfigSectionHandler, NLog\"/> </configSections> <startup> <supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.5\" /> </startup> <nlog xmlns=\"http://www.nlog-project.org/schemas/NLog.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"> <extensions> <add assembly=\"NewRelic.LogEnrichers.NLog\" /> </extensions> <targets> <target name=\"NewRelicLogFile\" xsi:type=\"File\" fileName=\"C:/path/to/NewRelicLog.json\"> <layout xsi:type=\"newrelic-jsonlayout\"> </layout> </target> </targets> <rules> <logger name=\"NewRelicLog\" minlevel=\"Info\" writeTo=\"newRelicLogFile\" /> </rules> </nlog> </configuration> Copy Configure Serilog 2.5 or higher extension You can use our Serilog extension to link to your log data with related data across the rest of the New Relic platform. This requires: Serilog 2.5 or higher Serilog File Sinks v4.0 or higher Serilog workflow diagram Serilog is a structured logging framework that records log messages from your application and creates a LogEvent to store the message data. Using Enrichers, you can add additional information to the log events. Sinks and Formatters allow you to format and output those log events for downstream consumption and viewing. The following diagram illustrates the flow of log messages through Serilog, highlighting specific components of the New Relic Serilog extension. Many log forwarders are available. This example uses Fluentd. New Relic Enricher: The NewRelicEnricher adds contextual information from the .NET agent (using the API) to the log events generated by the application. This contextual information, called linking metadata, is used by New Relic to link log messages to the transactions and spans where they were created. New Relic Formatter: The NewRelicFormatter translates enriched log events into the JSON format expected by New Relic. A sink instructs Serilog to output the JSON to a file in the location that the log forwarder expects. New Relic Log Forwarder: The log forwarder is configured to send the properly formatted and enriched log data from the FileTarget output to the New Relic logging endpoint. For more information about Serilog log events, see the Serilog documentation on GitHub. Serilog 2.5 or higher configuration To configure logs in context with the Serilog extension: Use the Visual Studio NuGet Package Manager to locate and install the NewRelic.LogEnrichers.Serilog package. In your application code, update your logging configuration to add the NewRelicEnricher and NewRelicFormatter. The following code example enriches log events with New Relic linking metadata. In addition to the existing log files, it outputs new log files in a specific JSON format at C:\\logs\\SerilogExample.log.json for consumption by the log forwarder: var loggerConfig = new LoggerConfiguration() loggerConfig .Enrich.WithThreadName() .Enrich.WithThreadId() .Enrich.WithNewRelicLogsInContext() .WriteTo.File( path: @\"C:\\logs\\ExistingLoggingOutput.txt\") .WriteTo.File( formatter: new NewRelicFormatter(), path: @\"C:\\logs\\SerilogExample.log.json\"); var log = loggerConfig.CreateLogger(); Copy This configuration results in new JSON files that are written to disk. Some of these configuration options may be useful for managing the amount of disk space used and/or the performance of the sink. restrictedToMinimumLevel buffered rollingInterval rollOnFileSizeLimit retainedFileCountLimit Although not required, using the Serilog Asynchronous Sink Wrapper may help improve the performance by performing formatting and output of log files on a different thread. Once you have configured the Serilog extension and updated your logging file, you can configure your extension to send data to New Relic. Here is an example configuration using the Fluentd plugin to forward logs to New Relic: <!--NewRelicLoggingExample.conf--> <source> @type tail path C:\\logs\\SerilogExample.log.json pos_file C:\\logs\\SerilogExample.log.json.pos tag logfile.* <parse> @type json </parse> </source> <match **> @type newrelic license_key <YOUR NEW_RELIC_LICENSE_KEY> base_uri https://log-api.newrelic.com/log/v1 </match> Copy Serilog file-based configuration You can also configure the New Relic Serilog extension with file-based configuration providers.The following additional NuGet Packages are required: Microsoft.Extensions.Configuration Serilog.Settings.Configuration The following example code creates a logger based on settings contained in an appSettings.json file. Instantiating logger using appsettings.json var builder = new ConfigurationBuilder() .AddJsonFile(\"appsettings.json\"); var configuration = builder.Build(); var logger = new LoggerConfiguration() .ReadFrom.Configuration(configuration) .CreateLogger(); Copy Sample appsettings.json file { \"Serilog\": { \"Using\": [ \"Serilog.Sinks.Console\", \"Serilog.Sinks.File\", \"NewRelic.LogEnrichers.Serilog\" ], \"MinimumLevel\": \"Debug\", \"Enrich\": [ \"WithNewRelicLogsInContext\" ], \"WriteTo\": [ { \"Name\": \"File\", \"Args\": { \"path\": \"C:\\\\Logs\\\\SerilogExample.log.json\", \"formatter\": \"NewRelic.LogEnrichers.Serilog.NewRelicFormatter, NewRelic.LogEnrichers.Serilog\" } } ], \"Properties\": { \"Application\": \"NewRelic Logging Serilog Example\" } } } Copy The following example code creates a logger based on settings contained in a web.config file. The Serilog.Settings.AppSettings NuGet Package is required. Instantiating logger using .config file var logger = new LoggerConfiguration() .ReadFrom.AppSettings() .CreateLogger(); Copy Sample web.config file <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <appSettings> <add key=\"serilog:using:NewRelic\" value=\"NewRelic.LogEnrichers.Serilog\" /> <add key=\"serilog:using:File\" value=\"Serilog.Sinks.File\" /> <!--Add other enrichers here--> <add key=\"serilog:enrich:WithNewRelicLogsInContext\" /> <add key=\"serilog:write-to:File.path\" value=\"C:\\logs\\SerilogExample.log.json\" /> <add key=\"serilog:write-to:File.formatter\" value=\"NewRelic.LogEnrichers.Serilog.NewRelicFormatter, NewRelic.LogEnrichers.Serilog\" /> </appSettings> Copy View logs in the UI To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. See your logs in context of your app's performance in the APM UI. Troubleshoot errors with distributed tracing, stack traces, application logs, and more. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 250.7478,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".NET: <em>Configure</em> <em>logs</em> <em>in</em> <em>context</em>",
        "sections": ".NET: <em>Configure</em> <em>logs</em> <em>in</em> <em>context</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": "<em>Logs</em> in <em>context</em> for the .NET agent connects your <em>logs</em> and APM data in <em>New</em> <em>Relic</em>. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the <em>log</em> lines that you need to identify and resolve a problem. Set up your .NET app To <em>enable</em> <em>logs</em>"
      },
      "id": "612efe5764441ff155424352"
    }
  ],
  "/docs/logs/logs-context/configure-logs-context-go": [
    {
      "sections": [
        "PHP: Configure logs in context",
        "Set up your PHP app",
        "PHP configuration with Monolog",
        "Tip",
        "PHP configuration with other log forwarders",
        "What's next?"
      ],
      "title": "PHP: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context for PHP"
      ],
      "external_id": "bddc3ec75de7bde2b5eff995d85d11715fd61be9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/configure-logs-context-php/",
      "published_at": "2021-12-04T22:02:35Z",
      "updated_at": "2021-12-04T22:02:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the PHP agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your PHP app To enable logs in context for APM apps monitored by PHP: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest PHP agent version, and enable distributed tracing. Use PHP agent version 9.13.0.270 or higher for logs in context. Install Monolog version 1 or 2, or use a compatible log forwarding plugin if you are not using the built-in Monolog Handler for New Relic. Configure logs in context for PHP using the Monolog extension, if used. PHP configuration with Monolog You must install the Monolog log enricher package before you can configure Monolog for New Relic logs in context. This is done by using Composer to install the newrelic/monolog-enricher package. In most cases, use the Processor and Handler classes provided by the log enricher package in conjunction with Monolog's built-in BufferHandler. The Processor adds the contextual metadata required for New Relic logs in context to operate. The Handler sends the log records to New Relic Logs. The BufferHandler ensures that the logs are delivered with as little overhead as possible. At the point where you create the Monolog\\Logger object, add the following pushProcessor and pushHandler calls to add the Processor and Handler: <?php use Monolog\\Handler\\BufferHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Handler, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $log->pushHandler(new BufferHandler(new Handler)); Copy Tip You can use the Processor and Handler in conjunction with any existing Monolog setup. You do not need to remove your existing processors and handlers. PHP configuration with other log forwarders If you use Monolog to send logs to a compatible log forwarder, and if you have already configured that tool to send logs to New Relic, you can use the Processor and Formatter solely for that tool. This option prevents additional overhead of sending logs directly to New Relic with the Handler. You will need to be using a handler that supports the setFormatter() method, and your logging tool must be able to ingest JSON logs. Here's an example of configuring Monolog to handle other log forwarders: <?php use Monolog\\Handler\\StreamHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Formatter, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $handler = new StreamHandler('php://stderr'); $handler->setFormatter(new Formatter); $log->pushHandler($handler); Copy To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. If the logs from your application do not include fields like trace.id and span.id, there may be a problem with the configuration of the Monolog log enricher. In this situation: Check that the PHP agent for your app has been installed and is configured to enable distributed tracing. Check that your application is using the Monolog logger object when sending log records, not syslog(). Check that another Monolog handler is not preventing the log record from bubbling. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. View your logs in context data in distributed tracing. Note that for PHP, logs in context data doesn't appear in the Logs tab of the APM UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 260.65656,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "PHP: Configure <em>logs</em> <em>in</em> <em>context</em>",
        "sections": "PHP: Configure <em>logs</em> <em>in</em> <em>context</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": "<em>Logs</em> in <em>context</em> for the PHP agent connects your <em>logs</em> and APM data in <em>New</em> <em>Relic</em>. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the <em>log</em> lines that you need to identify and resolve a problem. Set up your PHP app To <em>enable</em> <em>logs</em>"
      },
      "id": "612b7ab4196a6714904948ae"
    },
    {
      "sections": [
        "Use APM agent APIs with logs in context",
        "APM agent trace metadata and linking metadata APIs",
        "Resources for correctly annotating logs"
      ],
      "title": "Use APM agent APIs with logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context with agent APIs"
      ],
      "external_id": "ebc829a1c1b74c866f5326f90a6d5119fdcfae10",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/annotate-logs-logs-context-using-apm-agent-apis/",
      "published_at": "2021-12-06T01:43:28Z",
      "updated_at": "2021-12-04T22:00:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To correlate log data with other telemetry data, such as errors and distributed traces in APM, you can use our logs in context solutions. If your logging framework is not available with our existing logs in context solutions, you can configure your logging libraries by using API calls to annotate your logs. APM agent trace metadata and linking metadata APIs To get properly annotated logs for logs in context, use the following API calls for your APM agent. These APIs pass the required trace metadata and linking metadata to link your log data to other New Relic data. APM agent APIs: APM agent API calls C SDK (n/a) See our Log API documentation. Go GetTraceMetadata GetLinkingMetadata Java getTraceMetadata getLinkingMetadata .NET TraceMetadata GetLinkingMetadata Node.js newrelic.getTraceMetadata newrelic.getLinkingMetadata PHP newrelic_get_trace_metadata newrelic_get_linking_metadata For PHP, logs in context is only supported from the distributed tracing UI, not in the Logs tab of the APM UI. Python get_linking_metadata Ruby linking_metadata current_trace_id current_span_id Resources for correctly annotating logs For more information about using the trace metadata and linking metadata APIs to annotate logs for logs in context, review the APM agent specifications in GitHub. These specifications include the required fields and properly formatted output. Also, review the source code for our own logs in context extensions to see how we use these APIs: C SDK: n/a Go: Logrus extension Java: Log4j2 extension .NET: Serilog extension Node.js: Winston extension PHP: Monolog extension Python: Streamhandler example Ruby: logging.rb extension",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 240.36938,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use APM agent APIs with <em>logs</em> <em>in</em> <em>context</em>",
        "sections": "Use APM agent APIs with <em>logs</em> <em>in</em> <em>context</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": " your <em>logs</em>. APM agent trace metadata and linking metadata APIs To get properly annotated <em>logs</em> for <em>logs</em> in <em>context</em>, use the following API calls for your APM agent. These APIs pass the required trace metadata and linking metadata to link your <em>log</em> data to other <em>New</em> <em>Relic</em> data. APM agent APIs: APM agent"
      },
      "id": "61505693196a670394b70d61"
    },
    {
      "sections": [
        "AWS Lambda for sending CloudWatch logs",
        "Install and configure the Cloudwatch logs Lambda function",
        "Create a Lambda trigger",
        "Configure retries (optional)",
        "Tip",
        "Resources created by the SAM template",
        "View log data",
        "What's next?"
      ],
      "title": "AWS Lambda for sending CloudWatch logs",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Enable log monitoring in New Relic"
      ],
      "external_id": "69c310375d48a667779ffabead6f920eb6a34004",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/forward-logs/aws-lambda-sending-cloudwatch-logs/",
      "published_at": "2021-12-04T21:55:34Z",
      "updated_at": "2021-12-04T21:55:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can send your Amazon CloudWatch logs to New Relic using our AWS Lambda function, newrelic-log-ingestion. This can be easily deployed from the AWS Serverless application repository. Forwarding your CloudWatch logs to New Relic will give you enhanced log management capabilities to collect, process, explore, query, and alert on your log data. Install and configure the Cloudwatch logs Lambda function The following setup shows one approach for configuring environment variables. You can also configure them from the Functions page. Complete the following: Make sure you have a New Relic license key. Open the AWS Serverless Application Repository in your browser. Search for newrelic and check Show apps that create custom IAM roles or resource policies to find newrelic-log-ingestion. Open the newrelic-log-ingestion details and click Deploy. In the function's Configure menu, go to Environment Variables and configure log forwarding using the following environment variables: Key Description DEBUG_LOGGING_ENABLED A boolean to determine if you want to output debug messages in the CloudWatch console. Optional. To turn on debug logs, set this to true. Default is false. LICENSE_KEY New Relic license key is used for sending data to New Relic. Required. LOGGING_ENABLED Determines if logs are forwarded to New Relic. Required. To turn on logging, set this to true. NR_LOGGING_ENDPOINT New Relic ingestion endpoint for logs. Required. Two endpoints are available: US: https://log-api.newrelic.com/log/v1 EU: https://log-api.eu.newrelic.com/log/v1 NR_TAGS Specify tags to be added to all log events. Optional. Each tag is composed of a colon-delimited key and value. Multiple key-value pairs are semicolon-delimited; for example, env:prod;team:myTeam. Acknowledge that the app creates custom IAM roles, and then click Deploy. Once the process completes, create a Lambda trigger to link your Lambda function to CloudWatch logs. Create a Lambda trigger To get your logs streaming to New Relic, attach a trigger to the Lambda: From the left side menu, select Functions. Find and select the previously created newrelic-log-ingestion function. Under Designer, click Add Triggers, and select Cloudwatch Logs from the dropdown. Select the the appropriate Log group for your application. Enter a name for your filter. Optional: Enter a filter pattern. Check the Enable trigger checkbox, then click Add to create the trigger. Configure retries (optional) You can configure the number of retries you want to perform in case the function fails to send the data in case of communication issues. Recommended number is 3 retries, but you can change the retry behavior by changing the below parameters: Tip The more the number of retries there are can make the function run for longer times. This increases the probability of having higher costs for Lambda. However, decreasing the number of retries could increase the probability of data loss. MAX_RETRIES = 3 # Defines the number of retries after lambda failure to deliver data INITIAL_BACKOFF = 1 # Defines the initial wait seconds until next retry is executed BACKOFF_MULTIPLIER = 2 # Time multiplier between the retries As an example, in default above configuration, first retry will happen after 1 second, second retry after 2 seconds and third retry will happen after 4 seconds. Copy Resources created by the SAM template When you create the application from the repository, the following resources are also created: The Lambda function itself A role used to give execution permissions to the Lambda function based in CloudWatch Logs. All other Lambda configurations not listed can be left as the defaults. View log data If everything is configured correctly and your data is being collected, you should see data logs in both of these places: New Relic Logs UI New Relic tools for running NRQL queries. For example, you can execute a query like this: SELECT * FROM Log Copy If no data appears after you enable our log management capabilities, follow our standard log troubleshooting procedures. What's next? Explore logging data across your platform with the New Relic One UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our logs in context capabilities. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 199.28146,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "AWS Lambda <em>for</em> sending CloudWatch <em>logs</em>",
        "sections": "AWS Lambda <em>for</em> sending CloudWatch <em>logs</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": " this: SELECT * FROM <em>Log</em> Copy If no data appears after you <em>enable</em> our <em>log</em> <em>management</em> capabilities, follow our standard <em>log</em> troubleshooting procedures. What&#x27;s next? Explore logging data across your platform with the <em>New</em> <em>Relic</em> One UI. Get deeper visibility into both your application and your platform performance data by forwarding your <em>logs</em> with our <em>logs</em> in <em>context</em> capabilities. Set up alerts. Query your data and create dashboards."
      },
      "id": "603ea6bb28ccbc228deba74c"
    }
  ],
  "/docs/logs/logs-context/configure-logs-context-nodejs": [
    {
      "sections": [
        "PHP: Configure logs in context",
        "Set up your PHP app",
        "PHP configuration with Monolog",
        "Tip",
        "PHP configuration with other log forwarders",
        "What's next?"
      ],
      "title": "PHP: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context for PHP"
      ],
      "external_id": "bddc3ec75de7bde2b5eff995d85d11715fd61be9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/configure-logs-context-php/",
      "published_at": "2021-12-04T22:02:35Z",
      "updated_at": "2021-12-04T22:02:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the PHP agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your PHP app To enable logs in context for APM apps monitored by PHP: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest PHP agent version, and enable distributed tracing. Use PHP agent version 9.13.0.270 or higher for logs in context. Install Monolog version 1 or 2, or use a compatible log forwarding plugin if you are not using the built-in Monolog Handler for New Relic. Configure logs in context for PHP using the Monolog extension, if used. PHP configuration with Monolog You must install the Monolog log enricher package before you can configure Monolog for New Relic logs in context. This is done by using Composer to install the newrelic/monolog-enricher package. In most cases, use the Processor and Handler classes provided by the log enricher package in conjunction with Monolog's built-in BufferHandler. The Processor adds the contextual metadata required for New Relic logs in context to operate. The Handler sends the log records to New Relic Logs. The BufferHandler ensures that the logs are delivered with as little overhead as possible. At the point where you create the Monolog\\Logger object, add the following pushProcessor and pushHandler calls to add the Processor and Handler: <?php use Monolog\\Handler\\BufferHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Handler, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $log->pushHandler(new BufferHandler(new Handler)); Copy Tip You can use the Processor and Handler in conjunction with any existing Monolog setup. You do not need to remove your existing processors and handlers. PHP configuration with other log forwarders If you use Monolog to send logs to a compatible log forwarder, and if you have already configured that tool to send logs to New Relic, you can use the Processor and Formatter solely for that tool. This option prevents additional overhead of sending logs directly to New Relic with the Handler. You will need to be using a handler that supports the setFormatter() method, and your logging tool must be able to ingest JSON logs. Here's an example of configuring Monolog to handle other log forwarders: <?php use Monolog\\Handler\\StreamHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Formatter, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $handler = new StreamHandler('php://stderr'); $handler->setFormatter(new Formatter); $log->pushHandler($handler); Copy To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. If the logs from your application do not include fields like trace.id and span.id, there may be a problem with the configuration of the Monolog log enricher. In this situation: Check that the PHP agent for your app has been installed and is configured to enable distributed tracing. Check that your application is using the Monolog logger object when sending log records, not syslog(). Check that another Monolog handler is not preventing the log record from bubbling. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. View your logs in context data in distributed tracing. Note that for PHP, logs in context data doesn't appear in the Logs tab of the APM UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 249.05531,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "PHP: Configure <em>logs</em> <em>in</em> <em>context</em>",
        "sections": "PHP: Configure <em>logs</em> <em>in</em> <em>context</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": "<em>Logs</em> in <em>context</em> for the PHP agent connects your <em>logs</em> and APM data in <em>New</em> <em>Relic</em>. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the <em>log</em> lines that you need to identify and resolve a problem. Set up your PHP app To <em>enable</em> <em>logs</em>"
      },
      "id": "612b7ab4196a6714904948ae"
    },
    {
      "sections": [
        "Use APM agent APIs with logs in context",
        "APM agent trace metadata and linking metadata APIs",
        "Resources for correctly annotating logs"
      ],
      "title": "Use APM agent APIs with logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context with agent APIs"
      ],
      "external_id": "ebc829a1c1b74c866f5326f90a6d5119fdcfae10",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/annotate-logs-logs-context-using-apm-agent-apis/",
      "published_at": "2021-12-06T01:43:28Z",
      "updated_at": "2021-12-04T22:00:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To correlate log data with other telemetry data, such as errors and distributed traces in APM, you can use our logs in context solutions. If your logging framework is not available with our existing logs in context solutions, you can configure your logging libraries by using API calls to annotate your logs. APM agent trace metadata and linking metadata APIs To get properly annotated logs for logs in context, use the following API calls for your APM agent. These APIs pass the required trace metadata and linking metadata to link your log data to other New Relic data. APM agent APIs: APM agent API calls C SDK (n/a) See our Log API documentation. Go GetTraceMetadata GetLinkingMetadata Java getTraceMetadata getLinkingMetadata .NET TraceMetadata GetLinkingMetadata Node.js newrelic.getTraceMetadata newrelic.getLinkingMetadata PHP newrelic_get_trace_metadata newrelic_get_linking_metadata For PHP, logs in context is only supported from the distributed tracing UI, not in the Logs tab of the APM UI. Python get_linking_metadata Ruby linking_metadata current_trace_id current_span_id Resources for correctly annotating logs For more information about using the trace metadata and linking metadata APIs to annotate logs for logs in context, review the APM agent specifications in GitHub. These specifications include the required fields and properly formatted output. Also, review the source code for our own logs in context extensions to see how we use these APIs: C SDK: n/a Go: Logrus extension Java: Log4j2 extension .NET: Serilog extension Node.js: Winston extension PHP: Monolog extension Python: Streamhandler example Ruby: logging.rb extension",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 228.16823,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use APM agent APIs with <em>logs</em> <em>in</em> <em>context</em>",
        "sections": "Use APM agent APIs with <em>logs</em> <em>in</em> <em>context</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": " APIs to annotate <em>logs</em> for <em>logs</em> in <em>context</em>, review the APM agent specifications in GitHub. These specifications include the required fields and properly formatted output. Also, review the source code for our own <em>logs</em> in <em>context</em> extensions to see how we use these APIs: C SDK: n&#x2F;a Go: Logrus extension Java: <em>Log</em>4j2 extension .NET: Serilog extension <em>Node.js</em>: Winston extension PHP: Monolog extension Python: Streamhandler example Ruby: logging.rb extension"
      },
      "id": "61505693196a670394b70d61"
    },
    {
      "sections": [
        "AWS Lambda for sending CloudWatch logs",
        "Install and configure the Cloudwatch logs Lambda function",
        "Create a Lambda trigger",
        "Configure retries (optional)",
        "Tip",
        "Resources created by the SAM template",
        "View log data",
        "What's next?"
      ],
      "title": "AWS Lambda for sending CloudWatch logs",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Enable log monitoring in New Relic"
      ],
      "external_id": "69c310375d48a667779ffabead6f920eb6a34004",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/forward-logs/aws-lambda-sending-cloudwatch-logs/",
      "published_at": "2021-12-04T21:55:34Z",
      "updated_at": "2021-12-04T21:55:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can send your Amazon CloudWatch logs to New Relic using our AWS Lambda function, newrelic-log-ingestion. This can be easily deployed from the AWS Serverless application repository. Forwarding your CloudWatch logs to New Relic will give you enhanced log management capabilities to collect, process, explore, query, and alert on your log data. Install and configure the Cloudwatch logs Lambda function The following setup shows one approach for configuring environment variables. You can also configure them from the Functions page. Complete the following: Make sure you have a New Relic license key. Open the AWS Serverless Application Repository in your browser. Search for newrelic and check Show apps that create custom IAM roles or resource policies to find newrelic-log-ingestion. Open the newrelic-log-ingestion details and click Deploy. In the function's Configure menu, go to Environment Variables and configure log forwarding using the following environment variables: Key Description DEBUG_LOGGING_ENABLED A boolean to determine if you want to output debug messages in the CloudWatch console. Optional. To turn on debug logs, set this to true. Default is false. LICENSE_KEY New Relic license key is used for sending data to New Relic. Required. LOGGING_ENABLED Determines if logs are forwarded to New Relic. Required. To turn on logging, set this to true. NR_LOGGING_ENDPOINT New Relic ingestion endpoint for logs. Required. Two endpoints are available: US: https://log-api.newrelic.com/log/v1 EU: https://log-api.eu.newrelic.com/log/v1 NR_TAGS Specify tags to be added to all log events. Optional. Each tag is composed of a colon-delimited key and value. Multiple key-value pairs are semicolon-delimited; for example, env:prod;team:myTeam. Acknowledge that the app creates custom IAM roles, and then click Deploy. Once the process completes, create a Lambda trigger to link your Lambda function to CloudWatch logs. Create a Lambda trigger To get your logs streaming to New Relic, attach a trigger to the Lambda: From the left side menu, select Functions. Find and select the previously created newrelic-log-ingestion function. Under Designer, click Add Triggers, and select Cloudwatch Logs from the dropdown. Select the the appropriate Log group for your application. Enter a name for your filter. Optional: Enter a filter pattern. Check the Enable trigger checkbox, then click Add to create the trigger. Configure retries (optional) You can configure the number of retries you want to perform in case the function fails to send the data in case of communication issues. Recommended number is 3 retries, but you can change the retry behavior by changing the below parameters: Tip The more the number of retries there are can make the function run for longer times. This increases the probability of having higher costs for Lambda. However, decreasing the number of retries could increase the probability of data loss. MAX_RETRIES = 3 # Defines the number of retries after lambda failure to deliver data INITIAL_BACKOFF = 1 # Defines the initial wait seconds until next retry is executed BACKOFF_MULTIPLIER = 2 # Time multiplier between the retries As an example, in default above configuration, first retry will happen after 1 second, second retry after 2 seconds and third retry will happen after 4 seconds. Copy Resources created by the SAM template When you create the application from the repository, the following resources are also created: The Lambda function itself A role used to give execution permissions to the Lambda function based in CloudWatch Logs. All other Lambda configurations not listed can be left as the defaults. View log data If everything is configured correctly and your data is being collected, you should see data logs in both of these places: New Relic Logs UI New Relic tools for running NRQL queries. For example, you can execute a query like this: SELECT * FROM Log Copy If no data appears after you enable our log management capabilities, follow our standard log troubleshooting procedures. What's next? Explore logging data across your platform with the New Relic One UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our logs in context capabilities. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.5969,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "AWS Lambda <em>for</em> sending CloudWatch <em>logs</em>",
        "sections": "AWS Lambda <em>for</em> sending CloudWatch <em>logs</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": " this: SELECT * FROM <em>Log</em> Copy If no data appears after you <em>enable</em> our <em>log</em> <em>management</em> capabilities, follow our standard <em>log</em> troubleshooting procedures. What&#x27;s next? Explore logging data across your platform with the <em>New</em> <em>Relic</em> One UI. Get deeper visibility into both your application and your platform performance data by forwarding your <em>logs</em> with our <em>logs</em> in <em>context</em> capabilities. Set up alerts. Query your data and create dashboards."
      },
      "id": "603ea6bb28ccbc228deba74c"
    }
  ],
  "/docs/logs/logs-context/configure-logs-context-php": [
    {
      "sections": [
        "Use APM agent APIs with logs in context",
        "APM agent trace metadata and linking metadata APIs",
        "Resources for correctly annotating logs"
      ],
      "title": "Use APM agent APIs with logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context with agent APIs"
      ],
      "external_id": "ebc829a1c1b74c866f5326f90a6d5119fdcfae10",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/annotate-logs-logs-context-using-apm-agent-apis/",
      "published_at": "2021-12-06T01:43:28Z",
      "updated_at": "2021-12-04T22:00:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To correlate log data with other telemetry data, such as errors and distributed traces in APM, you can use our logs in context solutions. If your logging framework is not available with our existing logs in context solutions, you can configure your logging libraries by using API calls to annotate your logs. APM agent trace metadata and linking metadata APIs To get properly annotated logs for logs in context, use the following API calls for your APM agent. These APIs pass the required trace metadata and linking metadata to link your log data to other New Relic data. APM agent APIs: APM agent API calls C SDK (n/a) See our Log API documentation. Go GetTraceMetadata GetLinkingMetadata Java getTraceMetadata getLinkingMetadata .NET TraceMetadata GetLinkingMetadata Node.js newrelic.getTraceMetadata newrelic.getLinkingMetadata PHP newrelic_get_trace_metadata newrelic_get_linking_metadata For PHP, logs in context is only supported from the distributed tracing UI, not in the Logs tab of the APM UI. Python get_linking_metadata Ruby linking_metadata current_trace_id current_span_id Resources for correctly annotating logs For more information about using the trace metadata and linking metadata APIs to annotate logs for logs in context, review the APM agent specifications in GitHub. These specifications include the required fields and properly formatted output. Also, review the source code for our own logs in context extensions to see how we use these APIs: C SDK: n/a Go: Logrus extension Java: Log4j2 extension .NET: Serilog extension Node.js: Winston extension PHP: Monolog extension Python: Streamhandler example Ruby: logging.rb extension",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 228.16812,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use APM agent APIs with <em>logs</em> <em>in</em> <em>context</em>",
        "sections": "Use APM agent APIs with <em>logs</em> <em>in</em> <em>context</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": " your <em>logs</em>. APM agent trace metadata and linking metadata APIs To get properly annotated <em>logs</em> for <em>logs</em> in <em>context</em>, use the following API calls for your APM agent. These APIs pass the required trace metadata and linking metadata to link your <em>log</em> data to other <em>New</em> <em>Relic</em> data. APM agent APIs: APM agent"
      },
      "id": "61505693196a670394b70d61"
    },
    {
      "sections": [
        "AWS Lambda for sending CloudWatch logs",
        "Install and configure the Cloudwatch logs Lambda function",
        "Create a Lambda trigger",
        "Configure retries (optional)",
        "Tip",
        "Resources created by the SAM template",
        "View log data",
        "What's next?"
      ],
      "title": "AWS Lambda for sending CloudWatch logs",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Enable log monitoring in New Relic"
      ],
      "external_id": "69c310375d48a667779ffabead6f920eb6a34004",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/forward-logs/aws-lambda-sending-cloudwatch-logs/",
      "published_at": "2021-12-04T21:55:34Z",
      "updated_at": "2021-12-04T21:55:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can send your Amazon CloudWatch logs to New Relic using our AWS Lambda function, newrelic-log-ingestion. This can be easily deployed from the AWS Serverless application repository. Forwarding your CloudWatch logs to New Relic will give you enhanced log management capabilities to collect, process, explore, query, and alert on your log data. Install and configure the Cloudwatch logs Lambda function The following setup shows one approach for configuring environment variables. You can also configure them from the Functions page. Complete the following: Make sure you have a New Relic license key. Open the AWS Serverless Application Repository in your browser. Search for newrelic and check Show apps that create custom IAM roles or resource policies to find newrelic-log-ingestion. Open the newrelic-log-ingestion details and click Deploy. In the function's Configure menu, go to Environment Variables and configure log forwarding using the following environment variables: Key Description DEBUG_LOGGING_ENABLED A boolean to determine if you want to output debug messages in the CloudWatch console. Optional. To turn on debug logs, set this to true. Default is false. LICENSE_KEY New Relic license key is used for sending data to New Relic. Required. LOGGING_ENABLED Determines if logs are forwarded to New Relic. Required. To turn on logging, set this to true. NR_LOGGING_ENDPOINT New Relic ingestion endpoint for logs. Required. Two endpoints are available: US: https://log-api.newrelic.com/log/v1 EU: https://log-api.eu.newrelic.com/log/v1 NR_TAGS Specify tags to be added to all log events. Optional. Each tag is composed of a colon-delimited key and value. Multiple key-value pairs are semicolon-delimited; for example, env:prod;team:myTeam. Acknowledge that the app creates custom IAM roles, and then click Deploy. Once the process completes, create a Lambda trigger to link your Lambda function to CloudWatch logs. Create a Lambda trigger To get your logs streaming to New Relic, attach a trigger to the Lambda: From the left side menu, select Functions. Find and select the previously created newrelic-log-ingestion function. Under Designer, click Add Triggers, and select Cloudwatch Logs from the dropdown. Select the the appropriate Log group for your application. Enter a name for your filter. Optional: Enter a filter pattern. Check the Enable trigger checkbox, then click Add to create the trigger. Configure retries (optional) You can configure the number of retries you want to perform in case the function fails to send the data in case of communication issues. Recommended number is 3 retries, but you can change the retry behavior by changing the below parameters: Tip The more the number of retries there are can make the function run for longer times. This increases the probability of having higher costs for Lambda. However, decreasing the number of retries could increase the probability of data loss. MAX_RETRIES = 3 # Defines the number of retries after lambda failure to deliver data INITIAL_BACKOFF = 1 # Defines the initial wait seconds until next retry is executed BACKOFF_MULTIPLIER = 2 # Time multiplier between the retries As an example, in default above configuration, first retry will happen after 1 second, second retry after 2 seconds and third retry will happen after 4 seconds. Copy Resources created by the SAM template When you create the application from the repository, the following resources are also created: The Lambda function itself A role used to give execution permissions to the Lambda function based in CloudWatch Logs. All other Lambda configurations not listed can be left as the defaults. View log data If everything is configured correctly and your data is being collected, you should see data logs in both of these places: New Relic Logs UI New Relic tools for running NRQL queries. For example, you can execute a query like this: SELECT * FROM Log Copy If no data appears after you enable our log management capabilities, follow our standard log troubleshooting procedures. What's next? Explore logging data across your platform with the New Relic One UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our logs in context capabilities. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.5968,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "AWS Lambda <em>for</em> sending CloudWatch <em>logs</em>",
        "sections": "AWS Lambda <em>for</em> sending CloudWatch <em>logs</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": " this: SELECT * FROM <em>Log</em> Copy If no data appears after you <em>enable</em> our <em>log</em> <em>management</em> capabilities, follow our standard <em>log</em> troubleshooting procedures. What&#x27;s next? Explore logging data across your platform with the <em>New</em> <em>Relic</em> One UI. Get deeper visibility into both your application and your platform performance data by forwarding your <em>logs</em> with our <em>logs</em> in <em>context</em> capabilities. Set up alerts. Query your data and create dashboards."
      },
      "id": "603ea6bb28ccbc228deba74c"
    },
    {
      "sections": [
        "Forward your logs using the infrastructure agent",
        "Basic process",
        "System requirements",
        "Important",
        "Install the infrastructure agent",
        "Configure the infrastructure agent",
        "Log forwarding parameters",
        "Name (required)",
        "Log source (required)",
        "file",
        "systemd",
        "syslog",
        "tcp",
        "winlog",
        "Optional configuration",
        "attributes",
        "attributes automatically inserted by the infrastructure agent",
        "pattern",
        "max_line_kb",
        "fluentbit",
        "Sample configuration file",
        "logging.d/sample.yaml",
        "View your log data",
        "Troubleshooting",
        "No log data",
        "No data appears when tailing a file",
        "No data appears when capturing via a Syslog socket",
        "No data appears using infrastructure agent proxy",
        "Sending the infrastructure agent's logs to New Relic",
        "Caution",
        "Fluent Bit does not start with the infra agent",
        "Runtime error on Windows",
        "Errors when tailing a large amount of log files (Linux)",
        "Uninstall log forwarding",
        "What's next?"
      ],
      "title": "Forward your logs using the infrastructure agent",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Enable log monitoring in New Relic"
      ],
      "external_id": "a1deac410f0eedfb819348524a85a73bbb9d9daf",
      "image": "https://docs.newrelic.com/static/63ba6c3dc400e3cc4fb21668d5e7ba2a/c1b63/infrastructure-lic.png",
      "url": "https://docs.newrelic.com/docs/logs/forward-logs/forward-your-logs-using-infrastructure-agent/",
      "published_at": "2021-12-08T01:44:17Z",
      "updated_at": "2021-12-04T13:38:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can forward your logs to New Relic using our infrastructure monitoring agent. This makes all of your logging data available in one location and provides deeper visibility into both your application and your platform performance data. Forwarding your logs to New Relic will give you enhanced log management capabilities to collect, process, explore, query, and alert on your log data. Basic process To forward your logs through our infrastructure monitoring agent: If you haven't already, create a New Relic account. It's free, forever. Verify the system requirements needed for configuring logs. Ensure you have installed the infrastructure agent, version 1.11.4 or higher. Create a logging.yml configuration file in the infrastructure agent's logging.d directory. Configure your log sources and other parameters. Generate some traffic and wait a few minutes, then check your account for data. Explore your log data in the Logs UI and benefit from the log attributes automatically inserted by the infrastructure agent. Here is an example of where you can see logs in context of your infrastructure monitoring details in New Relic One. System requirements To use the log forwarder of the infrastructure agent, make sure you meet the following requirements: Infrastructure agent version 1.11.4 or higher OpenSSL library 1.1.0 or higher is required by Infrastructure agent starting from 1.16.4. Built-in support for ARM64 architecture on Linux systems (in example, AWS Graviton architecture) added in Infrastructure agent 1.26.0. Important The log forwarding feature is not supported with the Docker container for infrastructure monitoring agents. The log forwarding feature is compatible with the following operating systems: Operating system Supported version Amazon Linux Amazon Linux 2 CentOS Version 7 or higher Debian Version 9 (\"Stretch\") or higher Exception: Version 11 is not supported. Red Hat Enterprise Linux (RHEL) Version 7 or higher SUSE Linux Enterprise Server (SLES) Version 12 Ubuntu Versions 16.04.x, 18.04.x and 20.04.x (LTS versions) Windows Windows Server 2012, 2016, and 2019, and their service packs. Windows 10 Install the infrastructure agent Starting with version 1.11.4, the infrastructure agent can forward logs to New Relic. To install and run the agent, use a package manager (Linux) or the MSI installer (Windows). Important The log forwarding feature is not included when the infrastructure agent is implemented using Linux tarball or Windows ZIP installations. To use the following links, make sure you are logged to your New Relic account. Amazon Linux CentOS Debian RHEL SLES Ubuntu Windows If you don't have a New Relic account yet, or if you prefer to follow the procedure manually, see our tutorial to install the package manager. Configure the infrastructure agent Configuration files describe which log sources are forwarded. Our infrastructure agent uses .yml files to configure logging. You can add as many config files as you want. To add a new configuration file for the log forwarding feature: Navigate to the log forwarder configuration folder: Linux: /etc/newrelic-infra/logging.d/ Windows: C:\\Program Files\\New Relic\\newrelic-infra\\logging.d\\ Create a logging.yml configuration file, and add the parameters you need. The logging.d directory has various .yml.example files you can use as a reference or starting point. The agent automatically processes new configuration files without having to restart the infrastructure monitoring service. The only exception to this is when configuring a custom Fluent Bit configuration. Log forwarding parameters The infrastructure log forwarding .yml config supports the following parameters: Name (required) To start, define a name of the log or logs you want to forward to New Relic. Log source (required) What you use for the log source will depend on where you want to forward your logs from. Available options include: file Path to the log file or files. The agent tracks changes on the log files in a way similar to tail -f shell. Example: logs: - name: example-log file: /var/log/example.log # Path to a single log file - name: example-log-two file: /var/log/example-two.log # Path to another single log file Copy The file parameter can point to a specific log file or multiple files by using wildcards applied to names and extensions; for example, /logs/*.log. You can use wildcards in place of directories in a file path, which can be used to tail files located in different directories. Example: logs: - name: docker-logs file: /var/lib/docker/containers/*/*.log # Path to multiple folders and files Copy Important Use of wildcards may significantly increase the number of file descriptors and inotify watches the Fluent Bit process keeps open, which can interfere with log collection if the host's file descriptor limit is reached. Tailing a large number of files may require you to increase the maximum number of file descriptors and inotify watchers allowed by the operating system. Please refer to Errors when tailing a large amount of log files for more details on how to increase them. systemd Use the systemd parameter to forward log messages that are collected by the journald daemon in Linux environments. This input type requires the agent to run in root mode. Example: logs: - name: systemd-example systemd: cupsd Copy syslog Syslog data source. Parameters: uri: Syslog socket. Format varies depending on the protocol: TCP/UDP network sockets: [tcp/udp]://LISTEN_ADDRESS:PORT Unix domain sockets: unix_[tcp/udp]:// + /socket/path parser: Syslog parser. Default is rfc3164. Use rfc5424 if your messages include fractional seconds. Note: rfc3164 currently does not work on SuSE. unix_permissions: default is 0644 for domain sockets; this limits entries to processes running as root. You can use 0666 to listen for non-root processes, at your own risk. When running the agent in privileged mode, ports and sockets must be available or owned by nri-agent, with 0666 file permissions, so that other processes can write logs to the sockets. logs: # TCP network socket - name: syslog-tcp-test syslog: uri: tcp://0.0.0.0:5140 # Use the tcp://LISTEN_ADDRESS:PORT format parser: rfc5424 # Default syslog parser is rfc3164 # UDP network socket - name: syslog-udp-test syslog: uri: udp://0.0.0.0:6140 # Use the udp://LISTEN_ADDRESS:PORT format max_line_kb: 35 # Unix TCP domain socket - name: syslog-unix-tcp-test syslog: uri: unix_tcp:///var/unix-tcp-socket-test unix_permissions: 0666 # Default is 0644. Change at your own risk # Unix UDP domain socket - name: syslog-unix-udp-test syslog: uri: unix_udp:///var/unix-udp-socket-test parser: rfc5424 Copy tcp Logs retrieved over TCP connections. Parameters: uri: TCP/IP socket to listen for incoming data. The URI format is tcp://LISTEN_ADDRESS:PORT format: format of the data. It can be json or none. separator: If format: none is used, you can define a separator string for splitting records (default: \\n). logs: - name: tcp-simple-test tcp: uri: tcp://0.0.0.0:1234 # Use the tcp://LISTEN_ADDRESS:PORT format format: none # Raw text - this is default for 'tcp' separator: \\t # String for separating raw text entries max_line_kb: 32 - name: tcp-json-test tcp: uri: tcp://0.0.0.0:2345 # Use the tcp://LISTEN_ADDRESS:PORT format format: json Copy winlog Collect events from Windows log channels. Parameters: channel: name of the channel logs will be collected from. collect-eventids: a list of Windows Event IDs to be collected and forwarded to New Relic. Event ID ranges are supported. exclude-eventids: a list of Windows Event IDs to be excluded from collection. Event ID ranges are supported. All events are collected from the specified channel by default. Configure the collect-eventids and exclude-eventids sections to avoid sending unwanted logs to your New Relic account. Add event IDs or ranges to collect-eventids or exclude-eventids to forward or drop specific events. exclude-eventids takes precedence over collect-eventids if the same event ID is present in both sections. Example: logs: # Winlog log ingestion with eventId filters. - name: windows-security winlog: channel: Security collect-eventids: - 4624 - 4265 - 4700-4800 exclude-eventids: - 4735 # entries for the application, system, powershell, and SCOM channels - name: windows-application winlog: channel: Application - name: windows-system winlog: channel: System - name: windows-pshell winlog: channel: Windows Powershell - name: scom winlog: channel: Operations Manager # Entry for Windows Defender Logs - name: windows-defender winlog: channel: Microsoft-Windows-Windows Defender/Operational # Entry for Windows Clustering Logs - name: windows-clustering winlog: channel: Microsoft-Windows-FailoverClustering/Operational # Entry for IIS logs with logtype attribute for automatic parsing - name: iis-log file: C:\\inetpub\\logs\\LogFiles\\w3svc.log attributes: logtype: iis_w3c Copy Optional configuration The following configuration parameters are not required but are still recommended. attributes List of custom attributes specified as key-value pairs that can be used to send additional data with the logs which you can then query. The attributes configuration parameter can be used with any log source. One common use of the attributes configuration parameter is to specify the logtype attribute. This attribute allows leveraging one of the built-in parsing rules supported by New Relic Logs. Example: logs: - name: example-file-attributes file: /var/log/example.log attributes: logtype: nginx region: example-us-02 team: A-team - name: example-tcp-attributes tcp: uri: tcp://0.0.0.0:2345 format: json attributes: logtype: nginx region: example-us-02 team: B-team Copy attributes automatically inserted by the infrastructure agent The infrastructure agent automatically inserts log attributes for your convenience. Some of them are inserted for any log record, while others depend on the configuration parameters you used while setting up the log forwarder. Attribute name Description entity.guids Always inserted. The infrastructure agent inserts the Entity GUID assigned by New Relic to identify the host where it's running. It is available in the entity.guids field. Note: If the captured logs belong to an application instrumented using APM, the entity.guids field contains both the entity GUID of infrastructure, as well as the GUID of APM, separated by a pipe ( | ) delimiter. fb.input Always inserted. The underlying Fluent Bit input plugin type used to capture the logs. Currently its values are tail, systemd, winlog, syslog, and tcp. filePath Inserted when sing the file input type. Absolute file path of the file being monitored. hostname Always inserted. The hostname of the machine/VM/container executing the infrastructure agent. plugin.type Always inserted. Indicates the utility used to capture the logs. In this case, it is the infrastructure agent itself, so this attribute always has the value nri-agent. pattern Regular expression for filtering records. Only supported for the tail, systemd, syslog, and tcp (only with format none) sources. This field works in a way similar to grep -E in Unix systems. For example, for a given file being captured, you can filter for records containing either WARN or ERROR using: - name: only-records-with-warn-and-error file: /var/log/logFile.log pattern: WARN|ERROR Copy No filtering is applied by default. max_line_kb Maximum size of log entries/lines in KB. If log entries exceed the limit, they are skipped. Default is 128. fluentbit External Fluent Bit configuration and parser files. If defined, they are merged with the existing configuration and parser files generated by the infrastructure agent. The infrastructure agent processes the configuration files located in the logging.d directory and will generate a run-time Fluent Bit configuration file that contains the appropriate [INPUT], [FILTER] and [OUTPUT] sections. Optionally, it will also declare an @INCLUDE in case you provided an external Fluent Bit configuration file via the fluentbit option. The runtime file does not define a [SERVICE] section, leaving all default Fluent Bit configuration values. You can still override Fluent Bit's default settings by defining your own [SERVICE] section in your external Fluent Bit configuration file and include it via the fluentbit option. Parameters: config_file: path to an existing Fluent Bit configuration file. Note that any overlapping source results in duplicate messages in New Relic Logs. parsers_file: path to an existing Fluent Bit parsers file. The following parser names are reserved: rfc3164, rfc3164-local and rfc5424. Sample configuration file Here is an example of a logging.d/ configuration file in YAML format. For more configuration examples, see the infrastructure agent repository. logging.d/sample.yaml # Remember to only use spaces for indentation logs: # Example of 'file' source - name: file-with-attributes file: /var/log/test.log # Path to a single file or pattern attributes: # You can use custom attributes to enrich your data logtype: nginx team: The A Team pattern: Error # Regular expression to filter log entries # Example of 'systemd' source (Linux only) - name: systemd-example systemd: cupsd # Examples of 'syslog' source, one per protocol # TCP network socket - name: syslog-tcp-test syslog: uri: tcp://0.0.0.0:5140 # Use the tcp://LISTEN_ADDRESS:PORT format parser: rfc5424 # Default syslog parser is rfc3164 # UDP network socket - name: syslog-udp-test syslog: uri: udp://0.0.0.0:6140 # Use the udp://LISTEN_ADDRESS:PORT format max_line_kb: 35 # Paths for Unix sockets are defined by combining protocol and path: # unix_udp:// + /path/socket - for example, unix_udp:///tmp/socket # Unix TCP domain socket - name: syslog-unix-tcp-test syslog: uri: unix_tcp:///var/unix-tcp-socket-test unix_permissions: 0666 # Default is 0644. Change at your own risk # Unix UDP domain socket - name: syslog-unix-udp-test syslog: uri: unix_udp:///var/unix-udp-socket-test parser: rfc5424 # Examples of 'tcp' source for formats 'none' and 'json' - name: tcp-simple-test tcp: uri: tcp://0.0.0.0:1234 # Use the tcp://LISTEN_ADDRESS:PORT format format: none # Raw text - this is default for 'tcp' separator: \\t # String for separating raw text entries attributes: # You can add custom attributes to any source of logs tcpFormat: none someOtherAttribute: associatedValue max_line_kb: 32 - name: tcp-json-test tcp: uri: tcp://0.0.0.0:2345 # Use the tcp://LISTEN_ADDRESS:PORT format format: json attributes: tcpFormat: json yetAnotherAttribute: 12345 # Example of Fluent Bit configuration import - name: fluentbit-import fluentbit: config_file: /path/to/fluentbit.config parsers_file: /path/to/fluentbit/parsers.conf Copy View your log data If everything is configured correctly and your data is being collected, you should see logs data in both of these places: New Relic Logs UI New Relic tools for running NRQL queries. For example, you can execute a query like this: SELECT * FROM Log Copy Troubleshooting If you encounter problems with configuring your log forwarder, try these troubleshooting tips. No log data If no data appears after you enable our log management capabilities, follow our standard log troubleshooting procedures. No data appears when tailing a file The log forwarding feature requires the agent to have permission to read the data sources. When running the infrastructure agent in privileged or non-privileged modes, make sure that the log files you want to forward (and any intermediary directory in its path) are readable by the user running nri-agent. Example: Check file access under Linux Let's check whether the file /var/log/restrictedLogs/logFile.log can be monitored by the nri-agent user. In Linux, you can do a quick check with the namei command: sudo -u nri-agent namei -ml /var/log/restrictedLogs/logFile.log f: /var/log/restrictedLogs/logFile.log drwxr-xr-x root root / drwxr-xr-x root root var drwxrwxr-x root syslog log drwxr--r-- root root restrictedLogs logFile.log - No such file or directory Copy This command failed because the file is not visible to the nri-agent user. By inspecting the previous output, we can detect that the restrictedLogs directory is missing the execution flag for others. To fix this, execute: sudo chmod 755 /var/log/restrictedLogs Copy And then check for file access again: # sudo -u nri-agent namei -ml /var/log/restrictedLogs/logFile.log f: /var/log/restrictedLogs/logFile.log drwxr-xr-x root root / drwxr-xr-x root root var drwxrwxr-x root syslog log drwxr-xr-x root root restrictedLogs -rw-r----- vagrant vagrant logFile.log Copy The file is now visible to the nri-agent user. You must ensure that the file is also readable by the nri-agent user. To check this, use: # sudo -u nri-agent head /var/log/restrictedLogs/logFile.log head: cannot open '/var/log/restrictedLogs/logFile.log' for reading: Permission denied Copy In this example, the file is missing the read rights for the others group (users other than vagrant and the vagrant user group). You could fix this by granting read permissions to others, but the application could change these permissions upon restart. To avoid this, a better approach is to add the nri-agent user to the vagrant user group. No data appears when capturing via a Syslog socket The log forwarding feature requires that the agent has permission to read the data sources. When running the infrastructure agent in privileged or non-privileged modes: If you're using Unix domain socket files, make sure that the nri-agent user can access these files (please refer to the previous section) and that they have read and write permissions (666) so that other users than nri-agent can write to them. If you're using IP sockets, ensure that the port that you are using is not a system reserved one (like port 80, for example). If no data appears after you enable log management, follow standard log management troubleshooting procedures. No data appears using infrastructure agent proxy As explained in the infrastructure agent configuration guidelines, the proxy parameter must use either HTTP or HTTPS and be in the form https://user:password@hostname:port. The agent can parse the parameter without the HTTP or HTTPS, but the log forwarder cannot. You will see an error like the following in the agent verbose logs: [ERROR] building HTTP transport: parse \\\"hostname:port\\\": first path segment in URL cannot contain colon Copy To solve this problem, check your newrelic-infra.yml file, and ensure the proxy parameter adheres to this form. If you're using caBundleFile or caBundleDir in order to specify any certificate, we recommend to follow the below rules for each OS: Linux For HTTP proxies you don't need to setup any certificates. The plugin loads the system certificates and New Relic sends logs into the logging endpoint. However, you can specify the proxy self-signed certificate (PEM file) using either the caBundleFile or caBundleDir parameters. Windows For HTTP proxies you don't need to setup any certificates. The plugin loads the system certificates. For HTTPS, you can configure it in one of the following ways: Import the proxy certificate to the system pool (Recommended) Import the proxy self-signed certificate (PEM file) by using the MMC tool. Refer to this link, and in Step 2 ensure to import it in your Trusted Root Certification Authorities, instead of in the Intermediate Certification Authorities. Using the caBundleFile and caBundleDir parameters On Windows, we cannot load both the certificates from the system certificate pool and the ones specified with the caBundleFile caBundleDir parameters. So, if you are using caBundleFile or caBundleDir, ensure that the following certificates are placed in the same PEM file (when using caBundleFile) or in the same directory (when using caBundleDir): The Proxy certificate (because it's an HTTPS proxy). The Logging Endpoint certificate (eg. https://log-api.newrelic.com/log/v1). The Infrastructure Agent certificate (eg. https://infra-api.newrelic.com). You can check the certificates by running: # openssl s_client -connect log-api.newrelic.com:443 -servername log-api.newrelic.com Copy Sending the infrastructure agent's logs to New Relic You can configure the infrastructure agent to send its own logs to New Relic. This is useful for troubleshooting issues with log forwarding, the agent, or when contacting support. To forward the infrastructure agent logs to New Relic: Edit your newrelic-infra.yml file. Enable agent logging in troubleshooting mode by adding verbose: 3. On Windows and systems that don't use systemd or where journald is inaccessible, verbose:3 causes the agent to write the logs on the disk. Revert to verbose:0 to prevent this. (Recommended): Enable agent logging in JSON format to log_format: json. Restart the agent to load the new settings. This configuration sets up the agent in troubleshooting mode, but the log forwarder (based on Fluent Bit) will continue in a non-verbose mode. Sometimes you can have issues with the log forwarder itself. For example, there may be problems accessing a specific channel when shipping Windows log events or when accessing a particular log file. In these situations, you can also enable the verbose mode for the log forwarder: Set verbose to a value other than 0. Add the configuration option: trace: [\"log.fw\"]. Caution Check whether you are using the [fluentbit] option. When setting verbose: 3 and trace: [\"log.fw\"], ensure that you don't define any [OUTPUT] section pointing to stdout in an external Fluent Bit configuration file, Fluent Bit does not start with the infra agent Important Fluent Bit's tail plugin does not support network drives. For Linux versions prior to 2016, you may need to update the OpenSSL library to 1.1.0 (or higher). To check if you have this problem: See if infra-agent has started Fluent Bit by running: ps -aux | grep fluent-bi Copy If it isn't running go to /var/db/newrelic-infra/newrelic-integrations/logging and run: ./fluent-bit -i systemd -o stdout Copy If you get the following error, update OpenSSL to 1.1.0 or higher: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory Copy Runtime error on Windows One of the following error messages may appear when enabling log forwarding on Windows: The code execution cannot proceed because VCRUNTIME140.dll was not found. Copy OR error=\"exit status 3221225781\" process=log-forwarder Copy This is caused by a missing DLL. To solve the issue, install the Microsoft Visual C++ Redistributable as applicable: x64 x86 Errors when tailing a large amount of log files (Linux) It's common to face either one of the following error messages when attempting to tail a large amount of files: Too many open files The user limit on the total number of inotify watches was reached or the kernel failed to allocate a needed resource The operating system defines a maximum amount of allocatable file descriptors (typically 1024 by default), and a maximum amount of allocatable inotify watches (typically 8192 by default). Any process attempting to go above these limits will fail, returning one of the errors above. The underlying technology we use to forward logs, Fluent Bit, opens one file descriptor and sets an inotify watch for each file you configure to be forwarded. Moreover, at the time of writing this section, Fluent Bit uses an extra set of 32 file descriptors for its normal operation, with another extra file descriptor when it shuts down. Therefore, to capture a large amount of files you need to ensure that both the file descriptor and inotify watch limits are slightly greater than the amount of log files you wish to tail. The following instructions summarize how to increase these limits if you want to tail 10,000 log files. Also, it assumes the infrastructure agent is installed in root running mode, and therefore must be run using the root user. Check which is the current hard limit for the amount of file descriptors per process. Typically, this limit should be quite high and should not need to be modified. ulimit -Hn Copy Add the following line to /etc/security/limits.conf. We specified a limit of 10100 here instead of just 10000 to allow Fluent Bit to allocate the extra file descriptors it may need to work. root soft nofile 10100 # replace root by nri-agent for non-root (privileged and unprivileged) installations Copy Add the following line to /etc/pam.d/common-session so that the previous limit is applied upon restart: session required pam_limits.so Copy Add the following line to /etc/sysctl.conf to increase the amount of allowed inotify watchers per user. We specified a limit of 18192 here instead of just 10000 so that the root user will still have 8192 available inotify watches (the default value). fs.inotify.max_user_watches=18192 Copy Restart your system. Ensure that the new limits have been enforced by running: ulimit -Sn # Should return 10100 cat /proc/sys/fs/inotify/max_user_watches # Should return 18192 Copy Learn more on how to increase open file limits, or on how to increase the inotify watches. Uninstall log forwarding To uninstall log forwarding capabilities, go to your logging.d directory, and remove files with the .yml extension that were originally added during the configuration process. Linux: /etc/newrelic-infra/logging.d/ Windows: C:\\Program Files\\New Relic\\newrelic-infra\\logging.d\\ What's next? Explore logging data across your platform with the New Relic One UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our logs in context capabilities. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.85251,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Forward</em> your <em>logs</em> using the <em>infrastructure</em> agent",
        "sections": "Sending the <em>infrastructure</em> agent&#x27;s <em>logs</em> to <em>New</em> <em>Relic</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": " <em>management</em> capabilities to collect, process, explore, query, and alert on your <em>log</em> data. Basic process To forward your <em>logs</em> through our infrastructure monitoring agent: If you haven&#x27;t already, create a <em>New</em> <em>Relic</em> account. It&#x27;s free, forever. Verify the system requirements needed for configuring <em>logs</em>"
      },
      "id": "603e9df164441f6b6f4e8843"
    }
  ],
  "/docs/logs/logs-context/configure-logs-context-python": [
    {
      "sections": [
        "PHP: Configure logs in context",
        "Set up your PHP app",
        "PHP configuration with Monolog",
        "Tip",
        "PHP configuration with other log forwarders",
        "What's next?"
      ],
      "title": "PHP: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context for PHP"
      ],
      "external_id": "bddc3ec75de7bde2b5eff995d85d11715fd61be9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/configure-logs-context-php/",
      "published_at": "2021-12-04T22:02:35Z",
      "updated_at": "2021-12-04T22:02:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the PHP agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your PHP app To enable logs in context for APM apps monitored by PHP: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest PHP agent version, and enable distributed tracing. Use PHP agent version 9.13.0.270 or higher for logs in context. Install Monolog version 1 or 2, or use a compatible log forwarding plugin if you are not using the built-in Monolog Handler for New Relic. Configure logs in context for PHP using the Monolog extension, if used. PHP configuration with Monolog You must install the Monolog log enricher package before you can configure Monolog for New Relic logs in context. This is done by using Composer to install the newrelic/monolog-enricher package. In most cases, use the Processor and Handler classes provided by the log enricher package in conjunction with Monolog's built-in BufferHandler. The Processor adds the contextual metadata required for New Relic logs in context to operate. The Handler sends the log records to New Relic Logs. The BufferHandler ensures that the logs are delivered with as little overhead as possible. At the point where you create the Monolog\\Logger object, add the following pushProcessor and pushHandler calls to add the Processor and Handler: <?php use Monolog\\Handler\\BufferHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Handler, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $log->pushHandler(new BufferHandler(new Handler)); Copy Tip You can use the Processor and Handler in conjunction with any existing Monolog setup. You do not need to remove your existing processors and handlers. PHP configuration with other log forwarders If you use Monolog to send logs to a compatible log forwarder, and if you have already configured that tool to send logs to New Relic, you can use the Processor and Formatter solely for that tool. This option prevents additional overhead of sending logs directly to New Relic with the Handler. You will need to be using a handler that supports the setFormatter() method, and your logging tool must be able to ingest JSON logs. Here's an example of configuring Monolog to handle other log forwarders: <?php use Monolog\\Handler\\StreamHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Formatter, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $handler = new StreamHandler('php://stderr'); $handler->setFormatter(new Formatter); $log->pushHandler($handler); Copy To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. If the logs from your application do not include fields like trace.id and span.id, there may be a problem with the configuration of the Monolog log enricher. In this situation: Check that the PHP agent for your app has been installed and is configured to enable distributed tracing. Check that your application is using the Monolog logger object when sending log records, not syslog(). Check that another Monolog handler is not preventing the log record from bubbling. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. View your logs in context data in distributed tracing. Note that for PHP, logs in context data doesn't appear in the Logs tab of the APM UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 249.05519,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "PHP: Configure <em>logs</em> <em>in</em> <em>context</em>",
        "sections": "PHP: Configure <em>logs</em> <em>in</em> <em>context</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": "<em>Logs</em> in <em>context</em> for the PHP agent connects your <em>logs</em> and APM data in <em>New</em> <em>Relic</em>. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the <em>log</em> lines that you need to identify and resolve a problem. Set up your PHP app To <em>enable</em> <em>logs</em>"
      },
      "id": "612b7ab4196a6714904948ae"
    },
    {
      "sections": [
        "Use APM agent APIs with logs in context",
        "APM agent trace metadata and linking metadata APIs",
        "Resources for correctly annotating logs"
      ],
      "title": "Use APM agent APIs with logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context with agent APIs"
      ],
      "external_id": "ebc829a1c1b74c866f5326f90a6d5119fdcfae10",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/annotate-logs-logs-context-using-apm-agent-apis/",
      "published_at": "2021-12-06T01:43:28Z",
      "updated_at": "2021-12-04T22:00:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To correlate log data with other telemetry data, such as errors and distributed traces in APM, you can use our logs in context solutions. If your logging framework is not available with our existing logs in context solutions, you can configure your logging libraries by using API calls to annotate your logs. APM agent trace metadata and linking metadata APIs To get properly annotated logs for logs in context, use the following API calls for your APM agent. These APIs pass the required trace metadata and linking metadata to link your log data to other New Relic data. APM agent APIs: APM agent API calls C SDK (n/a) See our Log API documentation. Go GetTraceMetadata GetLinkingMetadata Java getTraceMetadata getLinkingMetadata .NET TraceMetadata GetLinkingMetadata Node.js newrelic.getTraceMetadata newrelic.getLinkingMetadata PHP newrelic_get_trace_metadata newrelic_get_linking_metadata For PHP, logs in context is only supported from the distributed tracing UI, not in the Logs tab of the APM UI. Python get_linking_metadata Ruby linking_metadata current_trace_id current_span_id Resources for correctly annotating logs For more information about using the trace metadata and linking metadata APIs to annotate logs for logs in context, review the APM agent specifications in GitHub. These specifications include the required fields and properly formatted output. Also, review the source code for our own logs in context extensions to see how we use these APIs: C SDK: n/a Go: Logrus extension Java: Log4j2 extension .NET: Serilog extension Node.js: Winston extension PHP: Monolog extension Python: Streamhandler example Ruby: logging.rb extension",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 228.16812,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use APM agent APIs with <em>logs</em> <em>in</em> <em>context</em>",
        "sections": "Use APM agent APIs with <em>logs</em> <em>in</em> <em>context</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": " your <em>logs</em>. APM agent trace metadata and linking metadata APIs To get properly annotated <em>logs</em> for <em>logs</em> in <em>context</em>, use the following API calls for your APM agent. These APIs pass the required trace metadata and linking metadata to link your <em>log</em> data to other <em>New</em> <em>Relic</em> data. APM agent APIs: APM agent"
      },
      "id": "61505693196a670394b70d61"
    },
    {
      "sections": [
        "AWS Lambda for sending CloudWatch logs",
        "Install and configure the Cloudwatch logs Lambda function",
        "Create a Lambda trigger",
        "Configure retries (optional)",
        "Tip",
        "Resources created by the SAM template",
        "View log data",
        "What's next?"
      ],
      "title": "AWS Lambda for sending CloudWatch logs",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Enable log monitoring in New Relic"
      ],
      "external_id": "69c310375d48a667779ffabead6f920eb6a34004",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/forward-logs/aws-lambda-sending-cloudwatch-logs/",
      "published_at": "2021-12-04T21:55:34Z",
      "updated_at": "2021-12-04T21:55:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can send your Amazon CloudWatch logs to New Relic using our AWS Lambda function, newrelic-log-ingestion. This can be easily deployed from the AWS Serverless application repository. Forwarding your CloudWatch logs to New Relic will give you enhanced log management capabilities to collect, process, explore, query, and alert on your log data. Install and configure the Cloudwatch logs Lambda function The following setup shows one approach for configuring environment variables. You can also configure them from the Functions page. Complete the following: Make sure you have a New Relic license key. Open the AWS Serverless Application Repository in your browser. Search for newrelic and check Show apps that create custom IAM roles or resource policies to find newrelic-log-ingestion. Open the newrelic-log-ingestion details and click Deploy. In the function's Configure menu, go to Environment Variables and configure log forwarding using the following environment variables: Key Description DEBUG_LOGGING_ENABLED A boolean to determine if you want to output debug messages in the CloudWatch console. Optional. To turn on debug logs, set this to true. Default is false. LICENSE_KEY New Relic license key is used for sending data to New Relic. Required. LOGGING_ENABLED Determines if logs are forwarded to New Relic. Required. To turn on logging, set this to true. NR_LOGGING_ENDPOINT New Relic ingestion endpoint for logs. Required. Two endpoints are available: US: https://log-api.newrelic.com/log/v1 EU: https://log-api.eu.newrelic.com/log/v1 NR_TAGS Specify tags to be added to all log events. Optional. Each tag is composed of a colon-delimited key and value. Multiple key-value pairs are semicolon-delimited; for example, env:prod;team:myTeam. Acknowledge that the app creates custom IAM roles, and then click Deploy. Once the process completes, create a Lambda trigger to link your Lambda function to CloudWatch logs. Create a Lambda trigger To get your logs streaming to New Relic, attach a trigger to the Lambda: From the left side menu, select Functions. Find and select the previously created newrelic-log-ingestion function. Under Designer, click Add Triggers, and select Cloudwatch Logs from the dropdown. Select the the appropriate Log group for your application. Enter a name for your filter. Optional: Enter a filter pattern. Check the Enable trigger checkbox, then click Add to create the trigger. Configure retries (optional) You can configure the number of retries you want to perform in case the function fails to send the data in case of communication issues. Recommended number is 3 retries, but you can change the retry behavior by changing the below parameters: Tip The more the number of retries there are can make the function run for longer times. This increases the probability of having higher costs for Lambda. However, decreasing the number of retries could increase the probability of data loss. MAX_RETRIES = 3 # Defines the number of retries after lambda failure to deliver data INITIAL_BACKOFF = 1 # Defines the initial wait seconds until next retry is executed BACKOFF_MULTIPLIER = 2 # Time multiplier between the retries As an example, in default above configuration, first retry will happen after 1 second, second retry after 2 seconds and third retry will happen after 4 seconds. Copy Resources created by the SAM template When you create the application from the repository, the following resources are also created: The Lambda function itself A role used to give execution permissions to the Lambda function based in CloudWatch Logs. All other Lambda configurations not listed can be left as the defaults. View log data If everything is configured correctly and your data is being collected, you should see data logs in both of these places: New Relic Logs UI New Relic tools for running NRQL queries. For example, you can execute a query like this: SELECT * FROM Log Copy If no data appears after you enable our log management capabilities, follow our standard log troubleshooting procedures. What's next? Explore logging data across your platform with the New Relic One UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our logs in context capabilities. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.5968,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "AWS Lambda <em>for</em> sending CloudWatch <em>logs</em>",
        "sections": "AWS Lambda <em>for</em> sending CloudWatch <em>logs</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": " this: SELECT * FROM <em>Log</em> Copy If no data appears after you <em>enable</em> our <em>log</em> <em>management</em> capabilities, follow our standard <em>log</em> troubleshooting procedures. What&#x27;s next? Explore logging data across your platform with the <em>New</em> <em>Relic</em> One UI. Get deeper visibility into both your application and your platform performance data by forwarding your <em>logs</em> with our <em>logs</em> in <em>context</em> capabilities. Set up alerts. Query your data and create dashboards."
      },
      "id": "603ea6bb28ccbc228deba74c"
    }
  ],
  "/docs/logs/logs-context/configure-logs-context-ruby": [
    {
      "sections": [
        "PHP: Configure logs in context",
        "Set up your PHP app",
        "PHP configuration with Monolog",
        "Tip",
        "PHP configuration with other log forwarders",
        "What's next?"
      ],
      "title": "PHP: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context for PHP"
      ],
      "external_id": "bddc3ec75de7bde2b5eff995d85d11715fd61be9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/configure-logs-context-php/",
      "published_at": "2021-12-04T22:02:35Z",
      "updated_at": "2021-12-04T22:02:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the PHP agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your PHP app To enable logs in context for APM apps monitored by PHP: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest PHP agent version, and enable distributed tracing. Use PHP agent version 9.13.0.270 or higher for logs in context. Install Monolog version 1 or 2, or use a compatible log forwarding plugin if you are not using the built-in Monolog Handler for New Relic. Configure logs in context for PHP using the Monolog extension, if used. PHP configuration with Monolog You must install the Monolog log enricher package before you can configure Monolog for New Relic logs in context. This is done by using Composer to install the newrelic/monolog-enricher package. In most cases, use the Processor and Handler classes provided by the log enricher package in conjunction with Monolog's built-in BufferHandler. The Processor adds the contextual metadata required for New Relic logs in context to operate. The Handler sends the log records to New Relic Logs. The BufferHandler ensures that the logs are delivered with as little overhead as possible. At the point where you create the Monolog\\Logger object, add the following pushProcessor and pushHandler calls to add the Processor and Handler: <?php use Monolog\\Handler\\BufferHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Handler, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $log->pushHandler(new BufferHandler(new Handler)); Copy Tip You can use the Processor and Handler in conjunction with any existing Monolog setup. You do not need to remove your existing processors and handlers. PHP configuration with other log forwarders If you use Monolog to send logs to a compatible log forwarder, and if you have already configured that tool to send logs to New Relic, you can use the Processor and Formatter solely for that tool. This option prevents additional overhead of sending logs directly to New Relic with the Handler. You will need to be using a handler that supports the setFormatter() method, and your logging tool must be able to ingest JSON logs. Here's an example of configuring Monolog to handle other log forwarders: <?php use Monolog\\Handler\\StreamHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Formatter, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $handler = new StreamHandler('php://stderr'); $handler->setFormatter(new Formatter); $log->pushHandler($handler); Copy To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. If the logs from your application do not include fields like trace.id and span.id, there may be a problem with the configuration of the Monolog log enricher. In this situation: Check that the PHP agent for your app has been installed and is configured to enable distributed tracing. Check that your application is using the Monolog logger object when sending log records, not syslog(). Check that another Monolog handler is not preventing the log record from bubbling. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. View your logs in context data in distributed tracing. Note that for PHP, logs in context data doesn't appear in the Logs tab of the APM UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 249.05505,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "PHP: Configure <em>logs</em> <em>in</em> <em>context</em>",
        "sections": "PHP: Configure <em>logs</em> <em>in</em> <em>context</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": "<em>Logs</em> in <em>context</em> for the PHP agent connects your <em>logs</em> and APM data in <em>New</em> <em>Relic</em>. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the <em>log</em> lines that you need to identify and resolve a problem. Set up your PHP app To <em>enable</em> <em>logs</em>"
      },
      "id": "612b7ab4196a6714904948ae"
    },
    {
      "sections": [
        "Use APM agent APIs with logs in context",
        "APM agent trace metadata and linking metadata APIs",
        "Resources for correctly annotating logs"
      ],
      "title": "Use APM agent APIs with logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context with agent APIs"
      ],
      "external_id": "ebc829a1c1b74c866f5326f90a6d5119fdcfae10",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/annotate-logs-logs-context-using-apm-agent-apis/",
      "published_at": "2021-12-06T01:43:28Z",
      "updated_at": "2021-12-04T22:00:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To correlate log data with other telemetry data, such as errors and distributed traces in APM, you can use our logs in context solutions. If your logging framework is not available with our existing logs in context solutions, you can configure your logging libraries by using API calls to annotate your logs. APM agent trace metadata and linking metadata APIs To get properly annotated logs for logs in context, use the following API calls for your APM agent. These APIs pass the required trace metadata and linking metadata to link your log data to other New Relic data. APM agent APIs: APM agent API calls C SDK (n/a) See our Log API documentation. Go GetTraceMetadata GetLinkingMetadata Java getTraceMetadata getLinkingMetadata .NET TraceMetadata GetLinkingMetadata Node.js newrelic.getTraceMetadata newrelic.getLinkingMetadata PHP newrelic_get_trace_metadata newrelic_get_linking_metadata For PHP, logs in context is only supported from the distributed tracing UI, not in the Logs tab of the APM UI. Python get_linking_metadata Ruby linking_metadata current_trace_id current_span_id Resources for correctly annotating logs For more information about using the trace metadata and linking metadata APIs to annotate logs for logs in context, review the APM agent specifications in GitHub. These specifications include the required fields and properly formatted output. Also, review the source code for our own logs in context extensions to see how we use these APIs: C SDK: n/a Go: Logrus extension Java: Log4j2 extension .NET: Serilog extension Node.js: Winston extension PHP: Monolog extension Python: Streamhandler example Ruby: logging.rb extension",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 228.168,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use APM agent APIs with <em>logs</em> <em>in</em> <em>context</em>",
        "sections": "Use APM agent APIs with <em>logs</em> <em>in</em> <em>context</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": " your <em>logs</em>. APM agent trace metadata and linking metadata APIs To get properly annotated <em>logs</em> for <em>logs</em> in <em>context</em>, use the following API calls for your APM agent. These APIs pass the required trace metadata and linking metadata to link your <em>log</em> data to other <em>New</em> <em>Relic</em> data. APM agent APIs: APM agent"
      },
      "id": "61505693196a670394b70d61"
    },
    {
      "sections": [
        "AWS Lambda for sending CloudWatch logs",
        "Install and configure the Cloudwatch logs Lambda function",
        "Create a Lambda trigger",
        "Configure retries (optional)",
        "Tip",
        "Resources created by the SAM template",
        "View log data",
        "What's next?"
      ],
      "title": "AWS Lambda for sending CloudWatch logs",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Enable log monitoring in New Relic"
      ],
      "external_id": "69c310375d48a667779ffabead6f920eb6a34004",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/forward-logs/aws-lambda-sending-cloudwatch-logs/",
      "published_at": "2021-12-04T21:55:34Z",
      "updated_at": "2021-12-04T21:55:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can send your Amazon CloudWatch logs to New Relic using our AWS Lambda function, newrelic-log-ingestion. This can be easily deployed from the AWS Serverless application repository. Forwarding your CloudWatch logs to New Relic will give you enhanced log management capabilities to collect, process, explore, query, and alert on your log data. Install and configure the Cloudwatch logs Lambda function The following setup shows one approach for configuring environment variables. You can also configure them from the Functions page. Complete the following: Make sure you have a New Relic license key. Open the AWS Serverless Application Repository in your browser. Search for newrelic and check Show apps that create custom IAM roles or resource policies to find newrelic-log-ingestion. Open the newrelic-log-ingestion details and click Deploy. In the function's Configure menu, go to Environment Variables and configure log forwarding using the following environment variables: Key Description DEBUG_LOGGING_ENABLED A boolean to determine if you want to output debug messages in the CloudWatch console. Optional. To turn on debug logs, set this to true. Default is false. LICENSE_KEY New Relic license key is used for sending data to New Relic. Required. LOGGING_ENABLED Determines if logs are forwarded to New Relic. Required. To turn on logging, set this to true. NR_LOGGING_ENDPOINT New Relic ingestion endpoint for logs. Required. Two endpoints are available: US: https://log-api.newrelic.com/log/v1 EU: https://log-api.eu.newrelic.com/log/v1 NR_TAGS Specify tags to be added to all log events. Optional. Each tag is composed of a colon-delimited key and value. Multiple key-value pairs are semicolon-delimited; for example, env:prod;team:myTeam. Acknowledge that the app creates custom IAM roles, and then click Deploy. Once the process completes, create a Lambda trigger to link your Lambda function to CloudWatch logs. Create a Lambda trigger To get your logs streaming to New Relic, attach a trigger to the Lambda: From the left side menu, select Functions. Find and select the previously created newrelic-log-ingestion function. Under Designer, click Add Triggers, and select Cloudwatch Logs from the dropdown. Select the the appropriate Log group for your application. Enter a name for your filter. Optional: Enter a filter pattern. Check the Enable trigger checkbox, then click Add to create the trigger. Configure retries (optional) You can configure the number of retries you want to perform in case the function fails to send the data in case of communication issues. Recommended number is 3 retries, but you can change the retry behavior by changing the below parameters: Tip The more the number of retries there are can make the function run for longer times. This increases the probability of having higher costs for Lambda. However, decreasing the number of retries could increase the probability of data loss. MAX_RETRIES = 3 # Defines the number of retries after lambda failure to deliver data INITIAL_BACKOFF = 1 # Defines the initial wait seconds until next retry is executed BACKOFF_MULTIPLIER = 2 # Time multiplier between the retries As an example, in default above configuration, first retry will happen after 1 second, second retry after 2 seconds and third retry will happen after 4 seconds. Copy Resources created by the SAM template When you create the application from the repository, the following resources are also created: The Lambda function itself A role used to give execution permissions to the Lambda function based in CloudWatch Logs. All other Lambda configurations not listed can be left as the defaults. View log data If everything is configured correctly and your data is being collected, you should see data logs in both of these places: New Relic Logs UI New Relic tools for running NRQL queries. For example, you can execute a query like this: SELECT * FROM Log Copy If no data appears after you enable our log management capabilities, follow our standard log troubleshooting procedures. What's next? Explore logging data across your platform with the New Relic One UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our logs in context capabilities. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.59671,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "AWS Lambda <em>for</em> sending CloudWatch <em>logs</em>",
        "sections": "AWS Lambda <em>for</em> sending CloudWatch <em>logs</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": " this: SELECT * FROM <em>Log</em> Copy If no data appears after you <em>enable</em> our <em>log</em> <em>management</em> capabilities, follow our standard <em>log</em> troubleshooting procedures. What&#x27;s next? Explore logging data across your platform with the <em>New</em> <em>Relic</em> One UI. Get deeper visibility into both your application and your platform performance data by forwarding your <em>logs</em> with our <em>logs</em> in <em>context</em> capabilities. Set up alerts. Query your data and create dashboards."
      },
      "id": "603ea6bb28ccbc228deba74c"
    }
  ],
  "/docs/logs/logs-context/java-configure-logs-context-all": [
    {
      "sections": [
        "PHP: Configure logs in context",
        "Set up your PHP app",
        "PHP configuration with Monolog",
        "Tip",
        "PHP configuration with other log forwarders",
        "What's next?"
      ],
      "title": "PHP: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context for PHP"
      ],
      "external_id": "bddc3ec75de7bde2b5eff995d85d11715fd61be9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/configure-logs-context-php/",
      "published_at": "2021-12-04T22:02:35Z",
      "updated_at": "2021-12-04T22:02:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the PHP agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your PHP app To enable logs in context for APM apps monitored by PHP: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest PHP agent version, and enable distributed tracing. Use PHP agent version 9.13.0.270 or higher for logs in context. Install Monolog version 1 or 2, or use a compatible log forwarding plugin if you are not using the built-in Monolog Handler for New Relic. Configure logs in context for PHP using the Monolog extension, if used. PHP configuration with Monolog You must install the Monolog log enricher package before you can configure Monolog for New Relic logs in context. This is done by using Composer to install the newrelic/monolog-enricher package. In most cases, use the Processor and Handler classes provided by the log enricher package in conjunction with Monolog's built-in BufferHandler. The Processor adds the contextual metadata required for New Relic logs in context to operate. The Handler sends the log records to New Relic Logs. The BufferHandler ensures that the logs are delivered with as little overhead as possible. At the point where you create the Monolog\\Logger object, add the following pushProcessor and pushHandler calls to add the Processor and Handler: <?php use Monolog\\Handler\\BufferHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Handler, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $log->pushHandler(new BufferHandler(new Handler)); Copy Tip You can use the Processor and Handler in conjunction with any existing Monolog setup. You do not need to remove your existing processors and handlers. PHP configuration with other log forwarders If you use Monolog to send logs to a compatible log forwarder, and if you have already configured that tool to send logs to New Relic, you can use the Processor and Formatter solely for that tool. This option prevents additional overhead of sending logs directly to New Relic with the Handler. You will need to be using a handler that supports the setFormatter() method, and your logging tool must be able to ingest JSON logs. Here's an example of configuring Monolog to handle other log forwarders: <?php use Monolog\\Handler\\StreamHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Formatter, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $handler = new StreamHandler('php://stderr'); $handler->setFormatter(new Formatter); $log->pushHandler($handler); Copy To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. If the logs from your application do not include fields like trace.id and span.id, there may be a problem with the configuration of the Monolog log enricher. In this situation: Check that the PHP agent for your app has been installed and is configured to enable distributed tracing. Check that your application is using the Monolog logger object when sending log records, not syslog(). Check that another Monolog handler is not preventing the log record from bubbling. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. View your logs in context data in distributed tracing. Note that for PHP, logs in context data doesn't appear in the Logs tab of the APM UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 320.50824,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "PHP: <em>Configure</em> <em>logs</em> <em>in</em> <em>context</em>",
        "sections": "PHP: <em>Configure</em> <em>logs</em> <em>in</em> <em>context</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": "<em>Logs</em> in <em>context</em> for the PHP agent connects your <em>logs</em> and APM data in <em>New</em> <em>Relic</em>. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the <em>log</em> lines that you need to identify and resolve a problem. Set up your PHP app To <em>enable</em> <em>logs</em>"
      },
      "id": "612b7ab4196a6714904948ae"
    },
    {
      "sections": [
        "Logs in context of apps and hosts",
        "See the root cause of issues across your platform",
        "Basic process to enable logs in context",
        "API and other options",
        "What's next?"
      ],
      "title": "Logs in context of apps and hosts",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Configure logs in context"
      ],
      "external_id": "7f77d1e4599c8f7b9b2a44bc817f328f11410651",
      "image": "https://docs.newrelic.com/static/49f9b37d2957292090bdbf226eadacea/c1b63/new-relic-logs-in-context-diagram.png",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/configure-logs-context-apm-agents/",
      "published_at": "2021-12-04T22:01:19Z",
      "updated_at": "2021-11-06T13:15:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you need to correlate log data with other telemetry data, enable logs in context in New Relic. Logs in context adds metadata that links your logs with related APM data, like errors or distributed traces, or your platform performance data from infrastructure monitoring logs in New Relic One. See the root cause of issues across your platform By bringing all of your application and infrastructure data together in a single solution, you can get to the root cause of issues faster. Logs in context help you quickly see meaningful patterns and trends. The following diagram shows the lifecycle of a log message, from enrichment with agent metadata (contextual logging), to formatting and forwarding the log data to New Relic: This diagram illustrates the flow of log messages through New Relic. Don't spend extra time trying to narrow down all your logs from different parts of your platform. Instead, enable logs in context to see the exact log lines you need to identify and resolve a problem. Basic process to enable logs in context The process to enable logs in context is basically the same, regardless of which APM agent you use to monitor your application: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Update to a supported APM agent version for your app, and enable distributed tracing. Configure logs in context for your APM agent or for your infrastructure monitoring agent. View your logs within the context of your apps or infrastructure in New Relic One. The main differences in this procedure are which log appenders you can use to extend and enrich your log data, and how to configure the log appender you select for your APM agent. For detailed information, see the logs-in-context procedures for: C SDK Go Java .NET Node.js PHP Python Ruby Infrastructure monitoring agent API and other options If our logging solutions don't meet your needs, you can use other options to send your log data to New Relic: Logging extensions via agent API calls HTTP endpoint via our Log API Syslog protocols via TCP endpoint (useful for CDNs, hardware devices, or managed services) What's next? Here is an example of logs in context for app trace details, visible in the APM UI. After you set up logs in context for APM or infrastructuring monitoring, make the most of your logging data in the New Relic One UI: Explore the logging data across your platform with our Logs UI. See your logs in context of your app's performance in the APM UI. Troubleshoot errors with distributed tracing, stack traces, application logs, and more. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 264.49097,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Logs</em> <em>in</em> <em>context</em> of apps and hosts",
        "sections": "Basic process to <em>enable</em> <em>logs</em> <em>in</em> <em>context</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": " up logging in <em>New</em> <em>Relic</em>. This includes configuring a supported <em>log</em> forwarder that collects your application <em>logs</em> and extends the metadata that is forwarded to <em>New</em> <em>Relic</em>. Update to a supported APM agent version for your app, and <em>enable</em> distributed tracing. <em>Configure</em> <em>logs</em> in <em>context</em> for your APM agent"
      },
      "id": "603ea62e196a6749f8a83dc9"
    },
    {
      "sections": [
        ".NET: Configure logs in context",
        "Set up your .NET app",
        "Configure log4net extension",
        "log4net workflow diagram",
        "log4net 2.0.8 or higher configuration",
        "Configure NLog extension",
        "Nlog workflow diagram",
        "Nlog 4.5 or higher configuration",
        "Nlog file-based configuration",
        "Configure Serilog 2.5 or higher extension",
        "Serilog workflow diagram",
        "Serilog 2.5 or higher configuration",
        "Serilog file-based configuration",
        "View logs in the UI",
        "What's next?"
      ],
      "title": ".NET: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Configure logs in context"
      ],
      "external_id": "69a3fc9dab232e3ebfdeccceace39b1014b70beb",
      "image": "https://docs.newrelic.com/static/a3260353a0e479f8512b94e9eb3adb11/c1b63/LogsInContext-Log4Net.png",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/net-configure-logs-context-all/",
      "published_at": "2021-12-04T22:03:15Z",
      "updated_at": "2021-10-24T23:38:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the .NET agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your .NET app To enable logs in context for APM apps monitored by .NET: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest .NET agent version, and enable distributed tracing. Use .NET agent version 8.21 or higher and the New Relic .NET agent API version 8.21 or higher for logs in context. Install or update to Microsoft .NET Framework 4.5 or higher or .NET Core 2.0 or higher. Install and configure any of the following logging extensions to enrich your log data, including: log4net NLog Serilog Check your log data in the New Relic UI. Configure log4net extension You can use the Apache log4net version 2.0.8 or higher extension to link your log data with related data across the rest of the New Relic platform. log4net workflow diagram The following diagram illustrates the flow of log messages through Apache log4net, highlighting specific components of the New Relic log4net extension. Many log forwarders are available. This example uses Fluentd. Appender: The NewRelicAppender adds contextual information from the .NET agent (using the API) to the log events generated by the application. This contextual information, known as linking metadata, is used by New Relic to link log messages to the transactions and spans from which they were created. This appender will pass the enriched log events to downstream appenders for further processing. Since the NewRelicAppender is ForwardingAppender type, it needs to be the first appender in the chain. It also requires another appender that can write to an actual output destination as its child in order to work. Layout: The NewRelicLayout formats the enriched log events into the JSON format expected by New Relic. The appender, which this layout is assigned to, instructs log4net to output the JSON to a file in the location that the log forwarder expects. Log Forwarder: The log forwarder monitors an output folder and incrementally sends the properly formatted and enriched log information to the New Relic logging endpoint. log4net 2.0.8 or higher configuration Log4net uses appender and layout to store and format log messages. NewRelicAppender enriches log messages with contextual information from the New Relic .NET agent if it is attached to your application. The appender passes enriched log messages to downstream appenders to handle specific use cases for log messages. For more information about logging with log4net, see the Apache log4net Getting started documentation. To configure logs in context with the log4net extension: Using the Visual Studio NuGet Package Manager, locate and install the NewRelic.LogEnrichers.Log4Net package. In your log4net configuration file, update your logging configuration to use the NewRelicAppender as the first level appender, and reference your existing appenders as its children. Also replace the layout of the appender that writes log messages to an output destination with the NewRelicLayout. The following log4net configuration example enriches log events with New Relic linking metadata. In addition to the existing log files, it outputs new log files in a specific JSON format at C:\\logs\\log4netExample.log.json for consumption by the log forwarder: <log4net> <root> <level value=\"ALL\" /> <appender-ref ref=\"NewRelicAppender\" /> </root> <appender name=\"NewRelicAppender\" type=\"NewRelic.LogEnrichers.Log4Net.NewRelicAppender, NewRelic.LogEnrichers.Log4Net\" > <threshold value=\"ALL\"/> <appender-ref ref=\"FileAppender\" /> </appender> <appender name=\"FileAppender\" type=\"log4net.Appender.FileAppender\"> <file value=\"C:\\logs\\log4netExample.log.json\" /> <param name=\"AppendToFile\" value=\"true\" /> <layout type=\"NewRelic.LogEnrichers.Log4Net.NewRelicLayout, NewRelic.LogEnrichers.Log4Net\"> </layout> </appender> </log4net> Copy After you configure the log4net extension and update your logging file, you can configure your extension to send data to New Relic. Here is an example configuration using the Fluentd plugin for New Relic Logs: <!--NewRelicLoggingExample.conf--> <source> @type tail path C:\\logs\\log4netExample.log.json pos_file C:\\logs\\log4netExample.log.json.pos tag logfile.* <parse> @type json </parse> </source> <match **> @type newrelic license_key <YOUR NEW_RELIC_LICENSE_KEY> base_uri https://log-api.newrelic.com/log/v1 </match> Copy Configure NLog extension You can use our NLog 4.5 or higher extension to link to your log data with related data across the rest of the New Relic platform. Nlog workflow diagram The New Relic NLog extension provides a NewRelicJsonLayout that formats a log event in the way required by the New Relic logging endpoint. Next, it adds contextual information from the .NET agent when attached to your application. Then, a target can be configured to write logging data to an output folder. The log forwarder can monitor this folder and incrementally send log information to New Relic. The following diagram illustrates the flow of log messages through NLog, highlighting specific components of the New Relic NLog extension. New Relic JSON Layout: The NewRelicJsonLayout adds contextual information from the .NET agent (using the API) to the log events generated by the application, and outputs log messages in the JSON format expected by New Relic. This contextual information, known as linking metadata, is used by New Relic to link log messages to the transactions and spans where they were created. Since the NewRelicAppender is ForwardingAppender type, it needs to be the first appender in the chain. It also requires another appender that can write to an actual output destination as its child in order to work. File Target: A FileTarget defines a file on disk where log messages are written. Adding the NewRelicJsonLayout to that target allows the output to be formatted correctly for forwarding to New Relic. Log Forwarder: The log forwarder is configured to send the properly formatted and enriched log data from the FileTarget output to the New Relic logging endpoint. For more information about logging with NLog, see the nlog-project.org documentation. Nlog 4.5 or higher configuration Use our NLog 4.5 or higher extension to link to your log data with related data across the rest of the New Relic platform. Using the Visual Studio NuGet Package Manager, locate and install the NewRelic.LogEnrichers.NLog package. In your application code, update your logging configuration to add the NewRelicJsonLayout and decide if you want to collect MappedDiagnosticsContext (MDC) or the MappedDiagnosticsLogicalContext (MDLC) data. The following configuration examples result in new JSON files that are written to disk. Some of these configuration options may be useful for managing the amount of disk space used and/or the performance of the target. archiveAboveSize maxArchiveFiles bufferSize enableArchiveFileCompression autoFlush concurrentWrites Although the NLog AsyncWrapper Target is not required, it may help improve performance by performing formatting and output of log files on a different thread. Don't collect MDC or the MDLC data (default): The following code example enriches log events with New Relic linking metadata, but not with MDC or the MDLC data. In addition to the existing log files, it outputs new log files in a specific JSON format at C:\\logs\\NLogExample.log.json for consumption by the log forwarder: var loggerConfig = new LoggingConfiguration(); var newRelicFileTarget = new FileTarget(\"NewRelicFileTarget\"); newRelicFileTarget.Layout = new NewRelicJsonLayout(); newRelicFileTarget.FileName = \"C:\\logs\\NLogExample.json\"; loggerConfig.AddTarget(newRelicFileTarget); loggerConfig.AddRuleForAllLevels(\"NewRelicFileTarget\"); LogManager.Configuration = loggerConfig; var logger = LogManager.GetLogger(\"Example\"); Copy Collect MDC or the MDLC data: If your application uses the MDC or the MDLC, you can configure the NewRelicJsonLayout to include items in those collections. The following code example adds the additional configuration to enable collecting MDC and MDLC data. As in the previous example, it outputs new log files in a specific JSON format at C:\\logs\\NLogExample.log.json for consumption by the log forwarder: var loggerConfig = new LoggingConfiguration(); var newRelicFileTarget = new FileTarget(\"NewRelicFileTarget\"); var newRelicLayout = new NewRelicJsonLayout { IncludeMdc = `true,` IncludeMdlc = `true` }; newRelicFileTarget.Layout = newRelicLayout; newRelicFileTarget.FileName = \"C:\\logs\\NLogExample.json\"; loggerConfig.AddTarget(newRelicFileTarget); loggerConfig.AddRuleForAllLevels(\"NewRelicFileTarget\"); LogManager.Configuration = loggerConfig; var logger = LogManager.GetLogger(\"Example\"); Copy Once you have configured the NLog extension and updated your logging file, you can configure your extension to send data to New Relic. Here is an example configuration using the Fluentd plugin to forward logs to New Relic: <!--NewRelicLoggingExample.conf--> <source> @type tail path C:\\logs\\NLogExample.log.json pos_file C:\\logs\\NLogExample.log.json.pos tag logfile.* <parse> @type json </parse> </source> <match **> @type newrelic license_key <YOUR NEW_RELIC_LICENSE_KEY> base_uri https://log-api.newrelic.com/log/v1 </match> Copy Nlog file-based configuration You can also configure the New Relic NLog extension with file-based configuration providers. The folowing example code creates a logger based on settings contained in an App.config file. Instantiating Logger using .config file var logger = LogManager.GetLogger(\"NewRelicLog\"); logger.Info(\"Hello, New Relic!\"); Copy Sample App.config file <?xml version=\"1.0\" encoding=\"utf-8\" ?> <configuration> <configSections> <section name=\"nlog\" type=\"NLog.Config.ConfigSectionHandler, NLog\"/> </configSections> <startup> <supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.5\" /> </startup> <nlog xmlns=\"http://www.nlog-project.org/schemas/NLog.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"> <extensions> <add assembly=\"NewRelic.LogEnrichers.NLog\" /> </extensions> <targets> <target name=\"NewRelicLogFile\" xsi:type=\"File\" fileName=\"C:/path/to/NewRelicLog.json\"> <layout xsi:type=\"newrelic-jsonlayout\"> </layout> </target> </targets> <rules> <logger name=\"NewRelicLog\" minlevel=\"Info\" writeTo=\"newRelicLogFile\" /> </rules> </nlog> </configuration> Copy Configure Serilog 2.5 or higher extension You can use our Serilog extension to link to your log data with related data across the rest of the New Relic platform. This requires: Serilog 2.5 or higher Serilog File Sinks v4.0 or higher Serilog workflow diagram Serilog is a structured logging framework that records log messages from your application and creates a LogEvent to store the message data. Using Enrichers, you can add additional information to the log events. Sinks and Formatters allow you to format and output those log events for downstream consumption and viewing. The following diagram illustrates the flow of log messages through Serilog, highlighting specific components of the New Relic Serilog extension. Many log forwarders are available. This example uses Fluentd. New Relic Enricher: The NewRelicEnricher adds contextual information from the .NET agent (using the API) to the log events generated by the application. This contextual information, called linking metadata, is used by New Relic to link log messages to the transactions and spans where they were created. New Relic Formatter: The NewRelicFormatter translates enriched log events into the JSON format expected by New Relic. A sink instructs Serilog to output the JSON to a file in the location that the log forwarder expects. New Relic Log Forwarder: The log forwarder is configured to send the properly formatted and enriched log data from the FileTarget output to the New Relic logging endpoint. For more information about Serilog log events, see the Serilog documentation on GitHub. Serilog 2.5 or higher configuration To configure logs in context with the Serilog extension: Use the Visual Studio NuGet Package Manager to locate and install the NewRelic.LogEnrichers.Serilog package. In your application code, update your logging configuration to add the NewRelicEnricher and NewRelicFormatter. The following code example enriches log events with New Relic linking metadata. In addition to the existing log files, it outputs new log files in a specific JSON format at C:\\logs\\SerilogExample.log.json for consumption by the log forwarder: var loggerConfig = new LoggerConfiguration() loggerConfig .Enrich.WithThreadName() .Enrich.WithThreadId() .Enrich.WithNewRelicLogsInContext() .WriteTo.File( path: @\"C:\\logs\\ExistingLoggingOutput.txt\") .WriteTo.File( formatter: new NewRelicFormatter(), path: @\"C:\\logs\\SerilogExample.log.json\"); var log = loggerConfig.CreateLogger(); Copy This configuration results in new JSON files that are written to disk. Some of these configuration options may be useful for managing the amount of disk space used and/or the performance of the sink. restrictedToMinimumLevel buffered rollingInterval rollOnFileSizeLimit retainedFileCountLimit Although not required, using the Serilog Asynchronous Sink Wrapper may help improve the performance by performing formatting and output of log files on a different thread. Once you have configured the Serilog extension and updated your logging file, you can configure your extension to send data to New Relic. Here is an example configuration using the Fluentd plugin to forward logs to New Relic: <!--NewRelicLoggingExample.conf--> <source> @type tail path C:\\logs\\SerilogExample.log.json pos_file C:\\logs\\SerilogExample.log.json.pos tag logfile.* <parse> @type json </parse> </source> <match **> @type newrelic license_key <YOUR NEW_RELIC_LICENSE_KEY> base_uri https://log-api.newrelic.com/log/v1 </match> Copy Serilog file-based configuration You can also configure the New Relic Serilog extension with file-based configuration providers.The following additional NuGet Packages are required: Microsoft.Extensions.Configuration Serilog.Settings.Configuration The following example code creates a logger based on settings contained in an appSettings.json file. Instantiating logger using appsettings.json var builder = new ConfigurationBuilder() .AddJsonFile(\"appsettings.json\"); var configuration = builder.Build(); var logger = new LoggerConfiguration() .ReadFrom.Configuration(configuration) .CreateLogger(); Copy Sample appsettings.json file { \"Serilog\": { \"Using\": [ \"Serilog.Sinks.Console\", \"Serilog.Sinks.File\", \"NewRelic.LogEnrichers.Serilog\" ], \"MinimumLevel\": \"Debug\", \"Enrich\": [ \"WithNewRelicLogsInContext\" ], \"WriteTo\": [ { \"Name\": \"File\", \"Args\": { \"path\": \"C:\\\\Logs\\\\SerilogExample.log.json\", \"formatter\": \"NewRelic.LogEnrichers.Serilog.NewRelicFormatter, NewRelic.LogEnrichers.Serilog\" } } ], \"Properties\": { \"Application\": \"NewRelic Logging Serilog Example\" } } } Copy The following example code creates a logger based on settings contained in a web.config file. The Serilog.Settings.AppSettings NuGet Package is required. Instantiating logger using .config file var logger = new LoggerConfiguration() .ReadFrom.AppSettings() .CreateLogger(); Copy Sample web.config file <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <appSettings> <add key=\"serilog:using:NewRelic\" value=\"NewRelic.LogEnrichers.Serilog\" /> <add key=\"serilog:using:File\" value=\"Serilog.Sinks.File\" /> <!--Add other enrichers here--> <add key=\"serilog:enrich:WithNewRelicLogsInContext\" /> <add key=\"serilog:write-to:File.path\" value=\"C:\\logs\\SerilogExample.log.json\" /> <add key=\"serilog:write-to:File.formatter\" value=\"NewRelic.LogEnrichers.Serilog.NewRelicFormatter, NewRelic.LogEnrichers.Serilog\" /> </appSettings> Copy View logs in the UI To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. See your logs in context of your app's performance in the APM UI. Troubleshoot errors with distributed tracing, stack traces, application logs, and more. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 250.74777,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".NET: <em>Configure</em> <em>logs</em> <em>in</em> <em>context</em>",
        "sections": ".NET: <em>Configure</em> <em>logs</em> <em>in</em> <em>context</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": "<em>Logs</em> in <em>context</em> for the .NET agent connects your <em>logs</em> and APM data in <em>New</em> <em>Relic</em>. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the <em>log</em> lines that you need to identify and resolve a problem. Set up your .NET app To <em>enable</em> <em>logs</em>"
      },
      "id": "612efe5764441ff155424352"
    }
  ],
  "/docs/logs/logs-context/net-configure-logs-context-all": [
    {
      "sections": [
        "PHP: Configure logs in context",
        "Set up your PHP app",
        "PHP configuration with Monolog",
        "Tip",
        "PHP configuration with other log forwarders",
        "What's next?"
      ],
      "title": "PHP: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context for PHP"
      ],
      "external_id": "bddc3ec75de7bde2b5eff995d85d11715fd61be9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/configure-logs-context-php/",
      "published_at": "2021-12-04T22:02:35Z",
      "updated_at": "2021-12-04T22:02:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the PHP agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your PHP app To enable logs in context for APM apps monitored by PHP: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest PHP agent version, and enable distributed tracing. Use PHP agent version 9.13.0.270 or higher for logs in context. Install Monolog version 1 or 2, or use a compatible log forwarding plugin if you are not using the built-in Monolog Handler for New Relic. Configure logs in context for PHP using the Monolog extension, if used. PHP configuration with Monolog You must install the Monolog log enricher package before you can configure Monolog for New Relic logs in context. This is done by using Composer to install the newrelic/monolog-enricher package. In most cases, use the Processor and Handler classes provided by the log enricher package in conjunction with Monolog's built-in BufferHandler. The Processor adds the contextual metadata required for New Relic logs in context to operate. The Handler sends the log records to New Relic Logs. The BufferHandler ensures that the logs are delivered with as little overhead as possible. At the point where you create the Monolog\\Logger object, add the following pushProcessor and pushHandler calls to add the Processor and Handler: <?php use Monolog\\Handler\\BufferHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Handler, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $log->pushHandler(new BufferHandler(new Handler)); Copy Tip You can use the Processor and Handler in conjunction with any existing Monolog setup. You do not need to remove your existing processors and handlers. PHP configuration with other log forwarders If you use Monolog to send logs to a compatible log forwarder, and if you have already configured that tool to send logs to New Relic, you can use the Processor and Formatter solely for that tool. This option prevents additional overhead of sending logs directly to New Relic with the Handler. You will need to be using a handler that supports the setFormatter() method, and your logging tool must be able to ingest JSON logs. Here's an example of configuring Monolog to handle other log forwarders: <?php use Monolog\\Handler\\StreamHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Formatter, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $handler = new StreamHandler('php://stderr'); $handler->setFormatter(new Formatter); $log->pushHandler($handler); Copy To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. If the logs from your application do not include fields like trace.id and span.id, there may be a problem with the configuration of the Monolog log enricher. In this situation: Check that the PHP agent for your app has been installed and is configured to enable distributed tracing. Check that your application is using the Monolog logger object when sending log records, not syslog(). Check that another Monolog handler is not preventing the log record from bubbling. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. View your logs in context data in distributed tracing. Note that for PHP, logs in context data doesn't appear in the Logs tab of the APM UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 320.50806,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "PHP: <em>Configure</em> <em>logs</em> <em>in</em> <em>context</em>",
        "sections": "PHP: <em>Configure</em> <em>logs</em> <em>in</em> <em>context</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": "<em>Logs</em> in <em>context</em> for the PHP agent connects your <em>logs</em> and APM data in <em>New</em> <em>Relic</em>. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the <em>log</em> lines that you need to identify and resolve a problem. Set up your PHP app To <em>enable</em> <em>logs</em>"
      },
      "id": "612b7ab4196a6714904948ae"
    },
    {
      "sections": [
        "Logs in context of apps and hosts",
        "See the root cause of issues across your platform",
        "Basic process to enable logs in context",
        "API and other options",
        "What's next?"
      ],
      "title": "Logs in context of apps and hosts",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Configure logs in context"
      ],
      "external_id": "7f77d1e4599c8f7b9b2a44bc817f328f11410651",
      "image": "https://docs.newrelic.com/static/49f9b37d2957292090bdbf226eadacea/c1b63/new-relic-logs-in-context-diagram.png",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/configure-logs-context-apm-agents/",
      "published_at": "2021-12-04T22:01:19Z",
      "updated_at": "2021-11-06T13:15:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you need to correlate log data with other telemetry data, enable logs in context in New Relic. Logs in context adds metadata that links your logs with related APM data, like errors or distributed traces, or your platform performance data from infrastructure monitoring logs in New Relic One. See the root cause of issues across your platform By bringing all of your application and infrastructure data together in a single solution, you can get to the root cause of issues faster. Logs in context help you quickly see meaningful patterns and trends. The following diagram shows the lifecycle of a log message, from enrichment with agent metadata (contextual logging), to formatting and forwarding the log data to New Relic: This diagram illustrates the flow of log messages through New Relic. Don't spend extra time trying to narrow down all your logs from different parts of your platform. Instead, enable logs in context to see the exact log lines you need to identify and resolve a problem. Basic process to enable logs in context The process to enable logs in context is basically the same, regardless of which APM agent you use to monitor your application: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Update to a supported APM agent version for your app, and enable distributed tracing. Configure logs in context for your APM agent or for your infrastructure monitoring agent. View your logs within the context of your apps or infrastructure in New Relic One. The main differences in this procedure are which log appenders you can use to extend and enrich your log data, and how to configure the log appender you select for your APM agent. For detailed information, see the logs-in-context procedures for: C SDK Go Java .NET Node.js PHP Python Ruby Infrastructure monitoring agent API and other options If our logging solutions don't meet your needs, you can use other options to send your log data to New Relic: Logging extensions via agent API calls HTTP endpoint via our Log API Syslog protocols via TCP endpoint (useful for CDNs, hardware devices, or managed services) What's next? Here is an example of logs in context for app trace details, visible in the APM UI. After you set up logs in context for APM or infrastructuring monitoring, make the most of your logging data in the New Relic One UI: Explore the logging data across your platform with our Logs UI. See your logs in context of your app's performance in the APM UI. Troubleshoot errors with distributed tracing, stack traces, application logs, and more. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 264.49094,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Logs</em> <em>in</em> <em>context</em> of apps and hosts",
        "sections": "Basic process to <em>enable</em> <em>logs</em> <em>in</em> <em>context</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": " up logging in <em>New</em> <em>Relic</em>. This includes configuring a supported <em>log</em> forwarder that collects your application <em>logs</em> and extends the metadata that is forwarded to <em>New</em> <em>Relic</em>. Update to a supported APM agent version for your app, and <em>enable</em> distributed tracing. <em>Configure</em> <em>logs</em> in <em>context</em> for your APM agent"
      },
      "id": "603ea62e196a6749f8a83dc9"
    },
    {
      "sections": [
        "Java: Configure logs in context",
        "Set up your Java app",
        "Dropwizard 1.3 or higher",
        "java.util.logging",
        "java.util.logging classpath additions",
        "Log4j 1.x",
        "Log4j 2.x",
        "Logback version 1.2.0 or higher",
        "Spring and Springboot",
        "View logs in UI",
        "What's next?"
      ],
      "title": "Java: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Configure logs in context"
      ],
      "external_id": "b9fbeafa564247287e5d6466630d5bdcdb85affb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/java-configure-logs-context-all/",
      "published_at": "2021-12-04T22:03:53Z",
      "updated_at": "2021-10-31T06:46:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the Java agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your Java app To enable logs in context for APM apps monitored by Java: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest Java agent version. Use Java agent version 5.6.0 or higher for logs in context. Enable the JVM argument -javaagent, and enable distributed tracing. Configure logs in context for Java to enrich your log data, using any of the following extensions as applicable. If you use Spring or Spring Boot and aren't sure which extension you need, see our Spring documentation. Dropwizard 1.3 or higher We offer a Dropwizard extension for logs in context with the Java agent. To get started, review the code and an example application on GitHub. To configure logs in context for your Java app with the DropWizard extension: Make sure you have the Dropwizard 1.3 or higher package installed and working on your application. Use the original Dropwizard appenders and logging factory installed and working on the application. Make sure you have the New Relic Java agent version 5.6.0 or higher installed on your application, and that you have enabled the JVM argument -javaagent. Update your project's dependencies to include the Dropwizard 1.3 extension as applicable: Gradle: Add the following to your build.gradle file: dependencies { implementation(\"com.newrelic.logging:dropwizard:2.0\") } Copy Maven: Add the following to your pom.xml file: <dependencies> <dependency> <groupId>com.newrelic.logging</groupId> <artifactId>dropwizard</artifactId> <version>2.0</version> </dependency> </dependencies> Copy Update your Dropwizard .yaml configuration file with a newrelic-json layout, replacing the currently used type: console or type: file with either type: newrelic-console or type: newrelic-file as appropriate. For example: logging: appenders: - type: newrelic-console # Add the two lines below if you don't have a layout specified on the appender. # If you have a layout, remove all parameters to the layout and set the type. layout: type: newrelic-json Copy The New Relic Dropwizard extension also supports a log-format layout type that uses the standard Dropwizard logging. For testing purposes, you can change the type of the layout with a one-line change: logging: appenders: - type: newrelic-file # This format will be ignored by the newrelic-json layout, but used by the log-format layout. logFormat: \"%date{ISO8601} %c %-5p: %m trace.id=%mdc{trace.id} span.id=%mdc{span.id}%n\" layout: # type: newrelic-json type: log-format Copy java.util.logging We offer a java.util.logging extension for logs in context with the Java agent. To get started, review the code and an example application on GitHub. To configure logs in context for your Java app with with the java.util.logging extension: Make sure you have the java.util.logging package installed and working on the application. Make sure you have the New Relic Java agent version 5.6.0 or higher installed on your application, and that you have enabled the JVM argument -javaagent. Update your project's dependencies to include the java.util.logging extension as applicable. If you can't edit these files, you can instead add the jars directly to the application classpath. Gradle: Add the following to your build.gradle file: dependencies { implementation(\"com.newrelic.logging:jul:2.0\") } Copy Maven: Add the following to your pom.xml file: <dependencies> <dependency> <groupId>com.newrelic.logging</groupId> <artifactId>jul</artifactId> <version>2.0</version> </dependency> </dependencies> Copy Check if your logging file's handlers property is set to something other than NewRelicMemoryHandler. Look for a line listing the root logger's handlers, like this: handlers = java.util.logging.FileHandler Copy Update your logging properties file to set the root logger's handler to NewRelicMemoryHandler so it intercepts messages destined for another handler: handlers = com.newrelic.logging.jul.NewRelicMemoryHandler Copy Configure the NewRelicMemoryHandler by setting the target to the handler that was previously assigned to the root logger, so it captures data New Relic needs on the thread the log message is coming from: com.newrelic.logging.jul.NewRelicMemoryHandler.target = java.util.logging.FileHandler Copy Use a NewRelicFormatter for the final handler. Update your logging properties file to set the formatter property like the following example. Make sure the handler where you set the formatter is the target handler from the previous step (java.util.logging.FileHandler in this example). java.util.logging.FileHandler.formatter = com.newrelic.logging.jul. NewRelicFormatter Copy The New Relic log format is JSON with telemetry metadata we use to correlate transactions and logs together. Currently we do not support any customization of that format. Once complete, JSON is logged instead of text. The JSON should be formatted as single objects, one per line, and should contain fields like log.level and thread.name. The trace.id, which is required for logs in context, should only have a value for log messages that occur within a transaction. java.util.logging classpath additions The most direct way to get the logs-in-context extensions is to add these dependencies to Maven's pom.xml or Gradle's build.gradle. This allows the packaging tools to pick up the correct dependencies. If you can't edit these files, you can instead add the jars directly to the application classpath for your logging framework's configuration. Before you modify the classpath: Enable the JVM argument -javaagent on your app's Java agent. Verify which logging framework the application is using. Make sure you are able to change your logging framework's configuration. Add the following three jars to the classpath if they aren't already present. Generally, we recommend taking the latest versions published on Maven Central. Group ID com.newrelic.logging and Artifact ID: Select the artifact named after your application's logging framework in Maven. Group ID com.fasterxml.jackson.core and Artifact ID: Use jackson-core. Group ID com.newrelic.agent.java and Artifact ID: Use newrelic-api. Log4j 1.x We offer a Log4j 1.x extension extension for logs in context with the Java agent. To get started, review the code and an example application on GitHub. To configure logs in context for your Java app with with the Log4j 1.x extension, you must configure the Log4j extension in code or via XML. Properties files are not supported because AsyncAppender instances can only be automatically configured via XML. Make sure you have the Log4j 1.x package installed and working on the application. Make sure you have the New Relic Java agent version 5.6.0 or higher installed on your application, and that you have enabled the JVM argument -javaagent. Update your project's dependencies to include the Log4j 1.x extension as applicable. Gradle: Add the following to your build.gradle file: dependencies { implementation(\"com.newrelic.logging:log4j1:2.0\") } Copy Maven: Add the following to your pom.xml file: <dependencies> <dependency> <groupId>com.newrelic.logging</groupId> <artifactId>log4j1</artifactId> <version>2.0</version> </dependency> </dependencies> Copy In your logging configuration XML file, update your <appender> element with a NewRelicLayout, adding <layout class=\"com.newrelic.logging.log4j1.NewRelicLayout\"/>: <appender name=\" TypicalFile \" class=\"org.apache.log4j.FileAppender\"> <param name=\"file\" value=\"logs/log4j1-app.log\"/> <param name=\"append\" value=\"false\"/> <layout class=\" com.newrelic.logging.log4j1.NewRelicLayout \"/> <!-- only this line needs to be added --> </appender> Copy Use NewRelicAsyncAppender to wrap any appenders that will target New Relic's log forwarder. For example: <appender name=\" NewRelicFile \" class=\"com.newrelic.logging.log4j1.NewRelicAsyncAppender\"> <appender-ref ref=\" TypicalFile \" /> </appender> Copy Use the async appender on the root logger. For example: <root> <appender-ref ref=\" NewRelicFile \" /> </root> Copy Example configuration file for the Log4j 1.x extension: <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <!DOCTYPE log4j:configuration SYSTEM \"log4j.dtd\"> <log4j:configuration debug=\"false\"> <appender name=\"TypicalFile\" class=\"org.apache.log4j.FileAppender\"> <param name=\"file\" value=\"logs/log4j1-app.log\"/> <param name=\"append\" value=\"false\"/> <!-- layout has been replaced --> <layout class=\"com.newrelic.logging.log4j1.NewRelicLayout\"/> </appender> <!-- this appender was added --> <appender name=\"NewRelicFile\" class=\"com.newrelic.logging.log4j1.NewRelicAsyncAppender\"> <appender-ref ref=\"TypicalFile\" /> </appender> <appender name=\"TypicalConsole\" class=\"org.apache.log4j.ConsoleAppender\"> <layout class=\"org.apache.log4j.PatternLayout\"> <param name=\"ConversionPattern\" value=\"%-5p %c{1} - %m%n\"/> </layout> </appender> <root> ​ <!-- the new appender was used here -->​​ <appender-ref ref=\"NewRelicFile\" /> <appender-ref ref=\"TypicalConsole\" /> </root> </log4j:configuration> Copy Log4j 2.x We offer a Log4j 2.x extension for logs in context with the Java agent. To get started, review the code and an example application on GitHub. To configure logs in context for your Java app with with the Log4j 2.x extension: Make sure you have the Log4j 2.x or Logs4j 2 binding package installed and working on your application. Make sure you have the New Relic Java agent version 5.6.0 or higher installed on your application, and that you have enabled the JVM argument -javaagent. Update your project's dependencies to include the Log4j 2.x extension as applicable: Gradle: Add the highlighted section to your build.gradle file: dependencies { implementation(\"com.newrelic.logging:log4j2:2.0\") } Copy Maven: Add the highlighted section to your pom.xml file: <dependencies> <dependency> <groupId>com.newrelic.logging</groupId> <artifactId>log4j2</artifactId> <version>2.0</version> </dependency> </dependencies> Copy In your logging configuration XML file, update your <configuration> element by adding the highlighted section: <Configuration xmlns=\"http://logging.apache.org/log4j/2.0/config\" packages=\"com.newrelic.logging.log4j2\" > Copy If you're using a properties file, add packages=com.newrelic.logging.log4j2. Add <NewRelicLayout/> to use a NewRelicLayout element within one of the appenders. For example: <File name=\"MyFile\" fileName=\"logs/app-log-file.log\"> <NewRelicLayout/> </File> Copy If you're using a properties file, only change the layout.type: appender.console.type = Console appender.console.name = STDOUT appender.console.layout.type = NewRelicLayout Copy If you only modified an existing appender, skip this step. If you added a new appender, add <AppenderRef/> within <Root> to use this appender. Use the ref attribute to refer to appender name you created in the previous step. For example: <Root level=\"info\"> <AppenderRef ref=\"MyFile\"/> </Root> Copy If you're using a properties file and added a new appender, add: rootLogger.level = info rootLogger.appenderRef.stdout.ref = STDOUT ​​​​​ Copy Logback version 1.2.0 or higher We offer a Logback extension for logs in context with the Java agent. To get started, review the code and an example application on GitHub. To configure logs in context for your Java app with Logback: Make sure you have Logback version 1.2.0 or higher and the New Relic Java agent version 5.6.0 or higher installed and working on your application. Make sure you have the New Relic Java agent version 5.6.0 or higher installed on your application, and that you have enabled the JVM argument -javaagent. Update your project's dependencies to include the Logback extension as applicable: Gradle: Add the highlighted section to your build.gradle file: dependencies { implementation(\"com.newrelic.logging:logback:2.0\") } Copy Maven: Add the highlighted section to your pom.xml file: <dependencies> <dependency> <groupId>com.newrelic.logging</groupId> <artifactId>logback</artifactId> <version>2.0</version> </dependency> </dependencies> Copy Update your logging configuration xml to replace any existing <encoder> element. If you're logging to the console (stdout/stderr), look for ConsoleAppender and replace: <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"> <encoder class=\"com.newrelic.logging.logback.NewRelicEncoder\"/> </appender> Copy If you're logging to a file, look for FileAppender and replace <encoder>: <appender name=\"LOG_FILE\" class=\"ch.qos.logback.core.FileAppender\"> <file>logs/app-log-file.log</file> <encoder class=\"com.newrelic.logging.logback.NewRelicEncoder\"/> </appender> Copy Update your logging configuration xml with the NewRelicAsyncAppender. To ensure that NewRelicAsyncAppender wraps any appenders that will target New Relic's log forwarder, add the following section. Change \"LOG_FILE\" to the name of the appender you updated in the previous step. <appender name=\"ASYNC\" class=\"com.newrelic.logging.logback.NewRelicAsyncAppender\"> <appender-ref ref=\"LOG_FILE\" /> </appender> Copy Make sure NewRelicAsyncAppender is the first appender used in your logger. Replace your root logger’s appenders with the ASYNC appender created in the previous step. Then list any other appenders after the NewRelicAsyncAppender in the <root> list. <root> <appender-ref ref=\"ASYNC\" /> </root> Copy Here are examples of an updated logging .xml file for the Logback extension. You can also see a working example in GitHub. Single console appender example Example configuration file after adding in the logging extension information: <configuration> <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"> <!-- changed the encoder --> <encoder class=\"com.newrelic.logging.logback.NewRelicEncoder\"/> </appender> <!-- added the ASYNC appender --> <appender name=\"ASYNC\" class=\"com.newrelic.logging.logback.NewRelicAsyncAppender\"> <appender-ref ref=\"STDOUT\" /> </appender> <root level=\"debug\"> <!-- changed the root logger --> <appender-ref ref=\"ASYNC\" /> </root> </configuration> Copy Two console appenders example This example sends New Relic logging to a file, but still sends standard logging to the console: <configuration> <appender name=\"FILE\" class=\"ch.qos.logback.core.FileAppender\"> <file>myApp.log</file> <!-- encoder changed --> <encoder class=\"com.newrelic.logging.logback.NewRelicEncoder\"/> </appender> <!-- this appender does normal console logging --> <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"> <encoder> <pattern>%msg%n</pattern> </encoder> </appender> <!-- The required New Relic ASYNC appender wraps the FILE appender --> <appender name=\"ASYNC\" class=\"com.newrelic.logging.logback.NewRelicAsyncAppender\"> <appender-ref ref=\"FILE\" /> </appender> <root level=\"debug\"> <!-- ASYNC is one of the main appenders --> <appender-ref ref=\"ASYNC\" /> <!-- Send every message to normal console logging, as well. --> <appender-ref ref=\"STDOUT\" /> </root> </configuration> Copy Spring and Springboot We offer extensions for current versions of Spring and Spring Boot. If you already know the logging library, you can skip directly to that documentation: java.util.logging log4j 1 log4j 2 logback The extensions support default configurations only on Spring Boot 2.0 and higher. With Spring Boot: Here are tips to determine which logging library you have: If you have spring-boot-starter-log4j2 in your dependencies, you're using log4j 2.x. Refer to the Spring Boot log4j 2.x documentation for basic configuration, and the New Relic log4j 2 extension for customizing your configuration. If you're using Spring Boot but not the starter-log4j2, you're using logback by default. Refer to Spring Boot logback documentation for basic configuration, and the New Relic logback extension for customizing your configuration. With Spring (but not Spring Boot): Spring 5 or higher: Spring implements a bridge to other logging libraries that will automatically find them. However, those individual libraries must be configured and explicitly included in your project dependencies. To identify your logging dependency, consult your Gradle, Maven, or other build tool's dependency tree. Then follow the procedures to configure logs in context for your Java app with that extension. Spring 4 or lower: Spring version 4 and lower uses Apache Commons Logging for its bridge. Refer to the Spring documentation for information on configuring its bridge. View logs in UI To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. See your logs in context of your app's performance in the APM UI. Troubleshoot errors with distributed tracing, stack traces, application logs, and more. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 256.69662,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Java: <em>Configure</em> <em>logs</em> <em>in</em> <em>context</em>",
        "sections": "Java: <em>Configure</em> <em>logs</em> <em>in</em> <em>context</em>",
        "tags": "<em>Enable</em> <em>log</em> <em>management</em> <em>in</em> <em>New</em> <em>Relic</em>",
        "body": "<em>Logs</em> in <em>context</em> for the Java agent connects your <em>logs</em> and APM data in <em>New</em> <em>Relic</em>. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the <em>log</em> lines that you need to identify and resolve a problem. Set up your Java app To <em>enable</em> <em>logs</em>"
      },
      "id": "612efca3e7b9d2f718b6f223"
    }
  ],
  "/docs/logs/troubleshooting/find-issues-cause-or-impact-surrounding-logs": [
    {
      "sections": [
        "PHP: Configure logs in context",
        "Set up your PHP app",
        "PHP configuration with Monolog",
        "Tip",
        "PHP configuration with other log forwarders",
        "What's next?"
      ],
      "title": "PHP: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context for PHP"
      ],
      "external_id": "bddc3ec75de7bde2b5eff995d85d11715fd61be9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/configure-logs-context-php/",
      "published_at": "2021-12-04T22:02:35Z",
      "updated_at": "2021-12-04T22:02:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the PHP agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your PHP app To enable logs in context for APM apps monitored by PHP: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest PHP agent version, and enable distributed tracing. Use PHP agent version 9.13.0.270 or higher for logs in context. Install Monolog version 1 or 2, or use a compatible log forwarding plugin if you are not using the built-in Monolog Handler for New Relic. Configure logs in context for PHP using the Monolog extension, if used. PHP configuration with Monolog You must install the Monolog log enricher package before you can configure Monolog for New Relic logs in context. This is done by using Composer to install the newrelic/monolog-enricher package. In most cases, use the Processor and Handler classes provided by the log enricher package in conjunction with Monolog's built-in BufferHandler. The Processor adds the contextual metadata required for New Relic logs in context to operate. The Handler sends the log records to New Relic Logs. The BufferHandler ensures that the logs are delivered with as little overhead as possible. At the point where you create the Monolog\\Logger object, add the following pushProcessor and pushHandler calls to add the Processor and Handler: <?php use Monolog\\Handler\\BufferHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Handler, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $log->pushHandler(new BufferHandler(new Handler)); Copy Tip You can use the Processor and Handler in conjunction with any existing Monolog setup. You do not need to remove your existing processors and handlers. PHP configuration with other log forwarders If you use Monolog to send logs to a compatible log forwarder, and if you have already configured that tool to send logs to New Relic, you can use the Processor and Formatter solely for that tool. This option prevents additional overhead of sending logs directly to New Relic with the Handler. You will need to be using a handler that supports the setFormatter() method, and your logging tool must be able to ingest JSON logs. Here's an example of configuring Monolog to handle other log forwarders: <?php use Monolog\\Handler\\StreamHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Formatter, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $handler = new StreamHandler('php://stderr'); $handler->setFormatter(new Formatter); $log->pushHandler($handler); Copy To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. If the logs from your application do not include fields like trace.id and span.id, there may be a problem with the configuration of the Monolog log enricher. In this situation: Check that the PHP agent for your app has been installed and is configured to enable distributed tracing. Check that your application is using the Monolog logger object when sending log records, not syslog(). Check that another Monolog handler is not preventing the log record from bubbling. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. View your logs in context data in distributed tracing. Note that for PHP, logs in context data doesn't appear in the Logs tab of the APM UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.89325,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "PHP: Configure <em>logs</em> in context",
        "sections": "PHP: Configure <em>logs</em> in context",
        "tags": "Enable <em>log</em> <em>management</em> in New Relic",
        "body": " the <em>troubleshooting</em> procedures. If the <em>logs</em> from your application do not include fields like trace.id and span.id, there may be a problem with the configuration of the Monolog <em>log</em> enricher. In this situation: Check that the PHP agent for your app has been installed and is configured to enable distributed"
      },
      "id": "612b7ab4196a6714904948ae"
    },
    {
      "sections": [
        "No log data appears in the UI",
        "Problem",
        "Solution"
      ],
      "title": "No log data appears in the UI",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "Troubleshooting"
      ],
      "external_id": "888cbbec2e57196e85dee7aab4fbe02864dff9ee",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/troubleshooting/no-log-data-appears-ui/",
      "published_at": "2021-12-04T22:04:27Z",
      "updated_at": "2021-11-14T08:10:25Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After enabling log management capabilities in New Relic, no data appears in your Logs UI after about five minutes. Solution If no data appears after you send some log payloads and wait about five minutes, try the following: Logs troubleshooting Comments Access to data See Factors affecting access to features and data. Compatibility Make sure you've installed a compatible log forwarder. Status codes Check the response status code being returned from the New Relic log collection endpoint. For example, you might see: HTTP Error 403: Forbidden. Review your license key. Copy This error means that you're using an invalid security key. New Relic requires a license key to enable log shipping. An HTTP 202 response indicates success. Errors Run a query using the NrIntegrationErrors event to see if any errors are related to logging. For example, look for messages like: Error unmarshalling message payload Copy Query Log Try querying the Log data type in New Relic One: SELECT * FROM Log Copy If no data appears in the query builder, then no data will appear in the Logs UI. For more information, see our documentation about data query options in New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 155.4286,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No <em>log</em> data appears in the UI",
        "sections": "No <em>log</em> data appears in the UI",
        "tags": "<em>Log</em> <em>management</em>",
        "body": "Problem After enabling <em>log</em> <em>management</em> capabilities in New Relic, no data appears in your <em>Logs</em> UI after about five minutes. Solution If no data appears after you send some <em>log</em> payloads and wait about five minutes, try the following: <em>Logs</em> <em>troubleshooting</em> Comments Access to data See Factors affecting"
      },
      "id": "6044181d64441f9138378f05"
    },
    {
      "sections": [
        "Log message is truncated",
        "Problem",
        "Solution"
      ],
      "title": "Log message is truncated",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "Troubleshooting"
      ],
      "external_id": "cd916262bec5bc9123b6ad18fc6f121cb4785a71",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/troubleshooting/log-message-truncated/",
      "published_at": "2021-12-04T22:04:27Z",
      "updated_at": "2021-11-14T07:15:39Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem Not all log data in a message or for a specific attribute is being displayed. The log data ends with an ellipses (...) and the remaining data isn't shown. Solution This occurs because the logs datastore in New Relic limits the field length to 4,096 characters. Any data longer than that is truncated during ingestion. If you have values exceeding the character limit, here are some options to try: Troubleshooting tips Comments Parse long messages Parse your log message into shorter key/value pairs. A common example is a single log line from an NGINX access log. That log message can be parsed using built-in parsing via Logstash, Fluentd, or Fluent Bit. For more information, see our documentation about parsing log data. Use JSON output Use JSON as an output format instead of plain text. JSON log messages will automatically be parsed into key/value pairs, which makes it much less likely to hit the character limit. Expand blob data The first 4,094 characters in a log message are stored as a string. The next 128,000 bytes are stored as a blob. To query for any log data in New Relic, run the following query: SELECT * FROM Log Copy To expand the blob data, run the following query, using message or any other attribute. Be sure to enclose the blob's attribute with backticks. For example: SELECT message, another-attribute, blob(`newrelic.ext.message`), blob(`newrelic.ext.another-attribute) FROM Log Copy For more information, see our documentation about long messages stored as blobs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 155.38142,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Log</em> message is truncated",
        "sections": "<em>Log</em> message is truncated",
        "tags": "<em>Log</em> <em>management</em>",
        "body": "Problem Not all <em>log</em> data in a message or for a specific attribute is being displayed. The <em>log</em> data ends with an ellipses (...) and the remaining data isn&#x27;t shown. Solution This occurs because the <em>logs</em> datastore in New Relic limits the field length to 4,096 characters. Any data longer than"
      },
      "id": "604413de196a67578c960f79"
    }
  ],
  "/docs/logs/troubleshooting/json-message-not-parsed": [
    {
      "sections": [
        "PHP: Configure logs in context",
        "Set up your PHP app",
        "PHP configuration with Monolog",
        "Tip",
        "PHP configuration with other log forwarders",
        "What's next?"
      ],
      "title": "PHP: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context for PHP"
      ],
      "external_id": "bddc3ec75de7bde2b5eff995d85d11715fd61be9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/configure-logs-context-php/",
      "published_at": "2021-12-04T22:02:35Z",
      "updated_at": "2021-12-04T22:02:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the PHP agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your PHP app To enable logs in context for APM apps monitored by PHP: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest PHP agent version, and enable distributed tracing. Use PHP agent version 9.13.0.270 or higher for logs in context. Install Monolog version 1 or 2, or use a compatible log forwarding plugin if you are not using the built-in Monolog Handler for New Relic. Configure logs in context for PHP using the Monolog extension, if used. PHP configuration with Monolog You must install the Monolog log enricher package before you can configure Monolog for New Relic logs in context. This is done by using Composer to install the newrelic/monolog-enricher package. In most cases, use the Processor and Handler classes provided by the log enricher package in conjunction with Monolog's built-in BufferHandler. The Processor adds the contextual metadata required for New Relic logs in context to operate. The Handler sends the log records to New Relic Logs. The BufferHandler ensures that the logs are delivered with as little overhead as possible. At the point where you create the Monolog\\Logger object, add the following pushProcessor and pushHandler calls to add the Processor and Handler: <?php use Monolog\\Handler\\BufferHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Handler, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $log->pushHandler(new BufferHandler(new Handler)); Copy Tip You can use the Processor and Handler in conjunction with any existing Monolog setup. You do not need to remove your existing processors and handlers. PHP configuration with other log forwarders If you use Monolog to send logs to a compatible log forwarder, and if you have already configured that tool to send logs to New Relic, you can use the Processor and Formatter solely for that tool. This option prevents additional overhead of sending logs directly to New Relic with the Handler. You will need to be using a handler that supports the setFormatter() method, and your logging tool must be able to ingest JSON logs. Here's an example of configuring Monolog to handle other log forwarders: <?php use Monolog\\Handler\\StreamHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Formatter, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $handler = new StreamHandler('php://stderr'); $handler->setFormatter(new Formatter); $log->pushHandler($handler); Copy To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. If the logs from your application do not include fields like trace.id and span.id, there may be a problem with the configuration of the Monolog log enricher. In this situation: Check that the PHP agent for your app has been installed and is configured to enable distributed tracing. Check that your application is using the Monolog logger object when sending log records, not syslog(). Check that another Monolog handler is not preventing the log record from bubbling. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. View your logs in context data in distributed tracing. Note that for PHP, logs in context data doesn't appear in the Logs tab of the APM UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.89325,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "PHP: Configure <em>logs</em> in context",
        "sections": "PHP: Configure <em>logs</em> in context",
        "tags": "Enable <em>log</em> <em>management</em> in New Relic",
        "body": " the <em>troubleshooting</em> procedures. If the <em>logs</em> from your application do not include fields like trace.id and span.id, there may be a problem with the configuration of the Monolog <em>log</em> enricher. In this situation: Check that the PHP agent for your app has been installed and is configured to enable distributed"
      },
      "id": "612b7ab4196a6714904948ae"
    },
    {
      "sections": [
        "No log data appears in the UI",
        "Problem",
        "Solution"
      ],
      "title": "No log data appears in the UI",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "Troubleshooting"
      ],
      "external_id": "888cbbec2e57196e85dee7aab4fbe02864dff9ee",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/troubleshooting/no-log-data-appears-ui/",
      "published_at": "2021-12-04T22:04:27Z",
      "updated_at": "2021-11-14T08:10:25Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After enabling log management capabilities in New Relic, no data appears in your Logs UI after about five minutes. Solution If no data appears after you send some log payloads and wait about five minutes, try the following: Logs troubleshooting Comments Access to data See Factors affecting access to features and data. Compatibility Make sure you've installed a compatible log forwarder. Status codes Check the response status code being returned from the New Relic log collection endpoint. For example, you might see: HTTP Error 403: Forbidden. Review your license key. Copy This error means that you're using an invalid security key. New Relic requires a license key to enable log shipping. An HTTP 202 response indicates success. Errors Run a query using the NrIntegrationErrors event to see if any errors are related to logging. For example, look for messages like: Error unmarshalling message payload Copy Query Log Try querying the Log data type in New Relic One: SELECT * FROM Log Copy If no data appears in the query builder, then no data will appear in the Logs UI. For more information, see our documentation about data query options in New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 155.4286,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No <em>log</em> data appears in the UI",
        "sections": "No <em>log</em> data appears in the UI",
        "tags": "<em>Log</em> <em>management</em>",
        "body": "Problem After enabling <em>log</em> <em>management</em> capabilities in New Relic, no data appears in your <em>Logs</em> UI after about five minutes. Solution If no data appears after you send some <em>log</em> payloads and wait about five minutes, try the following: <em>Logs</em> <em>troubleshooting</em> Comments Access to data See Factors affecting"
      },
      "id": "6044181d64441f9138378f05"
    },
    {
      "sections": [
        "Log message is truncated",
        "Problem",
        "Solution"
      ],
      "title": "Log message is truncated",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "Troubleshooting"
      ],
      "external_id": "cd916262bec5bc9123b6ad18fc6f121cb4785a71",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/troubleshooting/log-message-truncated/",
      "published_at": "2021-12-04T22:04:27Z",
      "updated_at": "2021-11-14T07:15:39Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem Not all log data in a message or for a specific attribute is being displayed. The log data ends with an ellipses (...) and the remaining data isn't shown. Solution This occurs because the logs datastore in New Relic limits the field length to 4,096 characters. Any data longer than that is truncated during ingestion. If you have values exceeding the character limit, here are some options to try: Troubleshooting tips Comments Parse long messages Parse your log message into shorter key/value pairs. A common example is a single log line from an NGINX access log. That log message can be parsed using built-in parsing via Logstash, Fluentd, or Fluent Bit. For more information, see our documentation about parsing log data. Use JSON output Use JSON as an output format instead of plain text. JSON log messages will automatically be parsed into key/value pairs, which makes it much less likely to hit the character limit. Expand blob data The first 4,094 characters in a log message are stored as a string. The next 128,000 bytes are stored as a blob. To query for any log data in New Relic, run the following query: SELECT * FROM Log Copy To expand the blob data, run the following query, using message or any other attribute. Be sure to enclose the blob's attribute with backticks. For example: SELECT message, another-attribute, blob(`newrelic.ext.message`), blob(`newrelic.ext.another-attribute) FROM Log Copy For more information, see our documentation about long messages stored as blobs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 155.38142,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Log</em> message is truncated",
        "sections": "<em>Log</em> message is truncated",
        "tags": "<em>Log</em> <em>management</em>",
        "body": "Problem Not all <em>log</em> data in a message or for a specific attribute is being displayed. The <em>log</em> data ends with an ellipses (...) and the remaining data isn&#x27;t shown. Solution This occurs because the <em>logs</em> datastore in New Relic limits the field length to 4,096 characters. Any data longer than"
      },
      "id": "604413de196a67578c960f79"
    }
  ],
  "/docs/logs/troubleshooting/log-message-truncated": [
    {
      "sections": [
        "PHP: Configure logs in context",
        "Set up your PHP app",
        "PHP configuration with Monolog",
        "Tip",
        "PHP configuration with other log forwarders",
        "What's next?"
      ],
      "title": "PHP: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context for PHP"
      ],
      "external_id": "bddc3ec75de7bde2b5eff995d85d11715fd61be9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/configure-logs-context-php/",
      "published_at": "2021-12-04T22:02:35Z",
      "updated_at": "2021-12-04T22:02:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the PHP agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your PHP app To enable logs in context for APM apps monitored by PHP: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest PHP agent version, and enable distributed tracing. Use PHP agent version 9.13.0.270 or higher for logs in context. Install Monolog version 1 or 2, or use a compatible log forwarding plugin if you are not using the built-in Monolog Handler for New Relic. Configure logs in context for PHP using the Monolog extension, if used. PHP configuration with Monolog You must install the Monolog log enricher package before you can configure Monolog for New Relic logs in context. This is done by using Composer to install the newrelic/monolog-enricher package. In most cases, use the Processor and Handler classes provided by the log enricher package in conjunction with Monolog's built-in BufferHandler. The Processor adds the contextual metadata required for New Relic logs in context to operate. The Handler sends the log records to New Relic Logs. The BufferHandler ensures that the logs are delivered with as little overhead as possible. At the point where you create the Monolog\\Logger object, add the following pushProcessor and pushHandler calls to add the Processor and Handler: <?php use Monolog\\Handler\\BufferHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Handler, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $log->pushHandler(new BufferHandler(new Handler)); Copy Tip You can use the Processor and Handler in conjunction with any existing Monolog setup. You do not need to remove your existing processors and handlers. PHP configuration with other log forwarders If you use Monolog to send logs to a compatible log forwarder, and if you have already configured that tool to send logs to New Relic, you can use the Processor and Formatter solely for that tool. This option prevents additional overhead of sending logs directly to New Relic with the Handler. You will need to be using a handler that supports the setFormatter() method, and your logging tool must be able to ingest JSON logs. Here's an example of configuring Monolog to handle other log forwarders: <?php use Monolog\\Handler\\StreamHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Formatter, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $handler = new StreamHandler('php://stderr'); $handler->setFormatter(new Formatter); $log->pushHandler($handler); Copy To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. If the logs from your application do not include fields like trace.id and span.id, there may be a problem with the configuration of the Monolog log enricher. In this situation: Check that the PHP agent for your app has been installed and is configured to enable distributed tracing. Check that your application is using the Monolog logger object when sending log records, not syslog(). Check that another Monolog handler is not preventing the log record from bubbling. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. View your logs in context data in distributed tracing. Note that for PHP, logs in context data doesn't appear in the Logs tab of the APM UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.89317,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "PHP: Configure <em>logs</em> in context",
        "sections": "PHP: Configure <em>logs</em> in context",
        "tags": "Enable <em>log</em> <em>management</em> in New Relic",
        "body": " the <em>troubleshooting</em> procedures. If the <em>logs</em> from your application do not include fields like trace.id and span.id, there may be a problem with the configuration of the Monolog <em>log</em> enricher. In this situation: Check that the PHP agent for your app has been installed and is configured to enable distributed"
      },
      "id": "612b7ab4196a6714904948ae"
    },
    {
      "sections": [
        "No log data appears in the UI",
        "Problem",
        "Solution"
      ],
      "title": "No log data appears in the UI",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "Troubleshooting"
      ],
      "external_id": "888cbbec2e57196e85dee7aab4fbe02864dff9ee",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/troubleshooting/no-log-data-appears-ui/",
      "published_at": "2021-12-04T22:04:27Z",
      "updated_at": "2021-11-14T08:10:25Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After enabling log management capabilities in New Relic, no data appears in your Logs UI after about five minutes. Solution If no data appears after you send some log payloads and wait about five minutes, try the following: Logs troubleshooting Comments Access to data See Factors affecting access to features and data. Compatibility Make sure you've installed a compatible log forwarder. Status codes Check the response status code being returned from the New Relic log collection endpoint. For example, you might see: HTTP Error 403: Forbidden. Review your license key. Copy This error means that you're using an invalid security key. New Relic requires a license key to enable log shipping. An HTTP 202 response indicates success. Errors Run a query using the NrIntegrationErrors event to see if any errors are related to logging. For example, look for messages like: Error unmarshalling message payload Copy Query Log Try querying the Log data type in New Relic One: SELECT * FROM Log Copy If no data appears in the query builder, then no data will appear in the Logs UI. For more information, see our documentation about data query options in New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 155.42859,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No <em>log</em> data appears in the UI",
        "sections": "No <em>log</em> data appears in the UI",
        "tags": "<em>Log</em> <em>management</em>",
        "body": "Problem After enabling <em>log</em> <em>management</em> capabilities in New Relic, no data appears in your <em>Logs</em> UI after about five minutes. Solution If no data appears after you send some <em>log</em> payloads and wait about five minutes, try the following: <em>Logs</em> <em>troubleshooting</em> Comments Access to data See Factors affecting"
      },
      "id": "6044181d64441f9138378f05"
    },
    {
      "sections": [
        "JSON message is not parsed",
        "Problem",
        "Solution"
      ],
      "title": "JSON message is not parsed",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "Troubleshooting"
      ],
      "external_id": "751496c28463190b70092648012bcbbc35563580",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/troubleshooting/json-message-not-parsed/",
      "published_at": "2021-12-04T22:03:15Z",
      "updated_at": "2021-11-13T21:37:38Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When JSON content is sent in the log's message field, it's not automatically parsed, and it's not stored as attributes (key/value pairs). Instead, the content remains in the message. It also may be truncated if the message exceeds the character limit. Solution Reasons this may be happening: If the content is not valid JSON, it won't be parsed. Instead, it will be stored as a string and truncated if it exceeds the character limit. If the content is valid JSON, it may have been \"stringified\" with escape characters. If that's the case, it will first be evaluated as a string, meaning that it will be truncated to 4,096 characters before being evaluated as JSON. The result of the truncation will be invalid JSON, and the data will be stored as a string. To solve this problem, send messages containing JSON that haven't been converted to a string. This content will be parsed even if the total length exceeds the character limit. If the JSON contains arrays, they'll be flattened and stored as unparsed strings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.8902,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Log</em> <em>management</em>",
        "body": "Problem When JSON content is sent in the <em>log</em>&#x27;s message field, it&#x27;s not automatically parsed, and it&#x27;s not stored as attributes (key&#x2F;value pairs). Instead, the content remains in the message. It also may be truncated if the message exceeds the character limit. Solution Reasons this may be happening"
      },
      "id": "614fd9ffe7b9d23e7a8de34a"
    }
  ],
  "/docs/logs/troubleshooting/no-log-data-appears-ui": [
    {
      "sections": [
        "PHP: Configure logs in context",
        "Set up your PHP app",
        "PHP configuration with Monolog",
        "Tip",
        "PHP configuration with other log forwarders",
        "What's next?"
      ],
      "title": "PHP: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context for PHP"
      ],
      "external_id": "bddc3ec75de7bde2b5eff995d85d11715fd61be9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/configure-logs-context-php/",
      "published_at": "2021-12-04T22:02:35Z",
      "updated_at": "2021-12-04T22:02:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the PHP agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your PHP app To enable logs in context for APM apps monitored by PHP: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest PHP agent version, and enable distributed tracing. Use PHP agent version 9.13.0.270 or higher for logs in context. Install Monolog version 1 or 2, or use a compatible log forwarding plugin if you are not using the built-in Monolog Handler for New Relic. Configure logs in context for PHP using the Monolog extension, if used. PHP configuration with Monolog You must install the Monolog log enricher package before you can configure Monolog for New Relic logs in context. This is done by using Composer to install the newrelic/monolog-enricher package. In most cases, use the Processor and Handler classes provided by the log enricher package in conjunction with Monolog's built-in BufferHandler. The Processor adds the contextual metadata required for New Relic logs in context to operate. The Handler sends the log records to New Relic Logs. The BufferHandler ensures that the logs are delivered with as little overhead as possible. At the point where you create the Monolog\\Logger object, add the following pushProcessor and pushHandler calls to add the Processor and Handler: <?php use Monolog\\Handler\\BufferHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Handler, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $log->pushHandler(new BufferHandler(new Handler)); Copy Tip You can use the Processor and Handler in conjunction with any existing Monolog setup. You do not need to remove your existing processors and handlers. PHP configuration with other log forwarders If you use Monolog to send logs to a compatible log forwarder, and if you have already configured that tool to send logs to New Relic, you can use the Processor and Formatter solely for that tool. This option prevents additional overhead of sending logs directly to New Relic with the Handler. You will need to be using a handler that supports the setFormatter() method, and your logging tool must be able to ingest JSON logs. Here's an example of configuring Monolog to handle other log forwarders: <?php use Monolog\\Handler\\StreamHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Formatter, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $handler = new StreamHandler('php://stderr'); $handler->setFormatter(new Formatter); $log->pushHandler($handler); Copy To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. If the logs from your application do not include fields like trace.id and span.id, there may be a problem with the configuration of the Monolog log enricher. In this situation: Check that the PHP agent for your app has been installed and is configured to enable distributed tracing. Check that your application is using the Monolog logger object when sending log records, not syslog(). Check that another Monolog handler is not preventing the log record from bubbling. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. View your logs in context data in distributed tracing. Note that for PHP, logs in context data doesn't appear in the Logs tab of the APM UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.89317,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "PHP: Configure <em>logs</em> in context",
        "sections": "PHP: Configure <em>logs</em> in context",
        "tags": "Enable <em>log</em> <em>management</em> in New Relic",
        "body": " the <em>troubleshooting</em> procedures. If the <em>logs</em> from your application do not include fields like trace.id and span.id, there may be a problem with the configuration of the Monolog <em>log</em> enricher. In this situation: Check that the PHP agent for your app has been installed and is configured to enable distributed"
      },
      "id": "612b7ab4196a6714904948ae"
    },
    {
      "sections": [
        "Log message is truncated",
        "Problem",
        "Solution"
      ],
      "title": "Log message is truncated",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "Troubleshooting"
      ],
      "external_id": "cd916262bec5bc9123b6ad18fc6f121cb4785a71",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/troubleshooting/log-message-truncated/",
      "published_at": "2021-12-04T22:04:27Z",
      "updated_at": "2021-11-14T07:15:39Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem Not all log data in a message or for a specific attribute is being displayed. The log data ends with an ellipses (...) and the remaining data isn't shown. Solution This occurs because the logs datastore in New Relic limits the field length to 4,096 characters. Any data longer than that is truncated during ingestion. If you have values exceeding the character limit, here are some options to try: Troubleshooting tips Comments Parse long messages Parse your log message into shorter key/value pairs. A common example is a single log line from an NGINX access log. That log message can be parsed using built-in parsing via Logstash, Fluentd, or Fluent Bit. For more information, see our documentation about parsing log data. Use JSON output Use JSON as an output format instead of plain text. JSON log messages will automatically be parsed into key/value pairs, which makes it much less likely to hit the character limit. Expand blob data The first 4,094 characters in a log message are stored as a string. The next 128,000 bytes are stored as a blob. To query for any log data in New Relic, run the following query: SELECT * FROM Log Copy To expand the blob data, run the following query, using message or any other attribute. Be sure to enclose the blob's attribute with backticks. For example: SELECT message, another-attribute, blob(`newrelic.ext.message`), blob(`newrelic.ext.another-attribute) FROM Log Copy For more information, see our documentation about long messages stored as blobs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 155.38141,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Log</em> message is truncated",
        "sections": "<em>Log</em> message is truncated",
        "tags": "<em>Log</em> <em>management</em>",
        "body": "Problem Not all <em>log</em> data in a message or for a specific attribute is being displayed. The <em>log</em> data ends with an ellipses (...) and the remaining data isn&#x27;t shown. Solution This occurs because the <em>logs</em> datastore in New Relic limits the field length to 4,096 characters. Any data longer than"
      },
      "id": "604413de196a67578c960f79"
    },
    {
      "sections": [
        "JSON message is not parsed",
        "Problem",
        "Solution"
      ],
      "title": "JSON message is not parsed",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "Troubleshooting"
      ],
      "external_id": "751496c28463190b70092648012bcbbc35563580",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/troubleshooting/json-message-not-parsed/",
      "published_at": "2021-12-04T22:03:15Z",
      "updated_at": "2021-11-13T21:37:38Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When JSON content is sent in the log's message field, it's not automatically parsed, and it's not stored as attributes (key/value pairs). Instead, the content remains in the message. It also may be truncated if the message exceeds the character limit. Solution Reasons this may be happening: If the content is not valid JSON, it won't be parsed. Instead, it will be stored as a string and truncated if it exceeds the character limit. If the content is valid JSON, it may have been \"stringified\" with escape characters. If that's the case, it will first be evaluated as a string, meaning that it will be truncated to 4,096 characters before being evaluated as JSON. The result of the truncation will be invalid JSON, and the data will be stored as a string. To solve this problem, send messages containing JSON that haven't been converted to a string. This content will be parsed even if the total length exceeds the character limit. If the JSON contains arrays, they'll be flattened and stored as unparsed strings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.8902,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Log</em> <em>management</em>",
        "body": "Problem When JSON content is sent in the <em>log</em>&#x27;s message field, it&#x27;s not automatically parsed, and it&#x27;s not stored as attributes (key&#x2F;value pairs). Instead, the content remains in the message. It also may be truncated if the message exceeds the character limit. Solution Reasons this may be happening"
      },
      "id": "614fd9ffe7b9d23e7a8de34a"
    }
  ],
  "/docs/logs/troubleshooting/view-log-messages-real-time-live-tail": [
    {
      "sections": [
        "PHP: Configure logs in context",
        "Set up your PHP app",
        "PHP configuration with Monolog",
        "Tip",
        "PHP configuration with other log forwarders",
        "What's next?"
      ],
      "title": "PHP: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context for PHP"
      ],
      "external_id": "bddc3ec75de7bde2b5eff995d85d11715fd61be9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/configure-logs-context-php/",
      "published_at": "2021-12-04T22:02:35Z",
      "updated_at": "2021-12-04T22:02:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the PHP agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your PHP app To enable logs in context for APM apps monitored by PHP: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest PHP agent version, and enable distributed tracing. Use PHP agent version 9.13.0.270 or higher for logs in context. Install Monolog version 1 or 2, or use a compatible log forwarding plugin if you are not using the built-in Monolog Handler for New Relic. Configure logs in context for PHP using the Monolog extension, if used. PHP configuration with Monolog You must install the Monolog log enricher package before you can configure Monolog for New Relic logs in context. This is done by using Composer to install the newrelic/monolog-enricher package. In most cases, use the Processor and Handler classes provided by the log enricher package in conjunction with Monolog's built-in BufferHandler. The Processor adds the contextual metadata required for New Relic logs in context to operate. The Handler sends the log records to New Relic Logs. The BufferHandler ensures that the logs are delivered with as little overhead as possible. At the point where you create the Monolog\\Logger object, add the following pushProcessor and pushHandler calls to add the Processor and Handler: <?php use Monolog\\Handler\\BufferHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Handler, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $log->pushHandler(new BufferHandler(new Handler)); Copy Tip You can use the Processor and Handler in conjunction with any existing Monolog setup. You do not need to remove your existing processors and handlers. PHP configuration with other log forwarders If you use Monolog to send logs to a compatible log forwarder, and if you have already configured that tool to send logs to New Relic, you can use the Processor and Formatter solely for that tool. This option prevents additional overhead of sending logs directly to New Relic with the Handler. You will need to be using a handler that supports the setFormatter() method, and your logging tool must be able to ingest JSON logs. Here's an example of configuring Monolog to handle other log forwarders: <?php use Monolog\\Handler\\StreamHandler; use Monolog\\Logger; use NewRelic\\Monolog\\Enricher\\{Formatter, Processor}; $log = new Logger('log'); $log->pushProcessor(new Processor); $handler = new StreamHandler('php://stderr'); $handler->setFormatter(new Formatter); $log->pushHandler($handler); Copy To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. If the logs from your application do not include fields like trace.id and span.id, there may be a problem with the configuration of the Monolog log enricher. In this situation: Check that the PHP agent for your app has been installed and is configured to enable distributed tracing. Check that your application is using the Monolog logger object when sending log records, not syslog(). Check that another Monolog handler is not preventing the log record from bubbling. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. View your logs in context data in distributed tracing. Note that for PHP, logs in context data doesn't appear in the Logs tab of the APM UI. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.8931,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "PHP: Configure <em>logs</em> in context",
        "sections": "PHP: Configure <em>logs</em> in context",
        "tags": "Enable <em>log</em> <em>management</em> in New Relic",
        "body": " the <em>troubleshooting</em> procedures. If the <em>logs</em> from your application do not include fields like trace.id and span.id, there may be a problem with the configuration of the Monolog <em>log</em> enricher. In this situation: Check that the PHP agent for your app has been installed and is configured to enable distributed"
      },
      "id": "612b7ab4196a6714904948ae"
    },
    {
      "sections": [
        "No log data appears in the UI",
        "Problem",
        "Solution"
      ],
      "title": "No log data appears in the UI",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "Troubleshooting"
      ],
      "external_id": "888cbbec2e57196e85dee7aab4fbe02864dff9ee",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/troubleshooting/no-log-data-appears-ui/",
      "published_at": "2021-12-04T22:04:27Z",
      "updated_at": "2021-11-14T08:10:25Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After enabling log management capabilities in New Relic, no data appears in your Logs UI after about five minutes. Solution If no data appears after you send some log payloads and wait about five minutes, try the following: Logs troubleshooting Comments Access to data See Factors affecting access to features and data. Compatibility Make sure you've installed a compatible log forwarder. Status codes Check the response status code being returned from the New Relic log collection endpoint. For example, you might see: HTTP Error 403: Forbidden. Review your license key. Copy This error means that you're using an invalid security key. New Relic requires a license key to enable log shipping. An HTTP 202 response indicates success. Errors Run a query using the NrIntegrationErrors event to see if any errors are related to logging. For example, look for messages like: Error unmarshalling message payload Copy Query Log Try querying the Log data type in New Relic One: SELECT * FROM Log Copy If no data appears in the query builder, then no data will appear in the Logs UI. For more information, see our documentation about data query options in New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 155.42857,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No <em>log</em> data appears in the UI",
        "sections": "No <em>log</em> data appears in the UI",
        "tags": "<em>Log</em> <em>management</em>",
        "body": "Problem After enabling <em>log</em> <em>management</em> capabilities in New Relic, no data appears in your <em>Logs</em> UI after about five minutes. Solution If no data appears after you send some <em>log</em> payloads and wait about five minutes, try the following: <em>Logs</em> <em>troubleshooting</em> Comments Access to data See Factors affecting"
      },
      "id": "6044181d64441f9138378f05"
    },
    {
      "sections": [
        "Log message is truncated",
        "Problem",
        "Solution"
      ],
      "title": "Log message is truncated",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "Troubleshooting"
      ],
      "external_id": "cd916262bec5bc9123b6ad18fc6f121cb4785a71",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/troubleshooting/log-message-truncated/",
      "published_at": "2021-12-04T22:04:27Z",
      "updated_at": "2021-11-14T07:15:39Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem Not all log data in a message or for a specific attribute is being displayed. The log data ends with an ellipses (...) and the remaining data isn't shown. Solution This occurs because the logs datastore in New Relic limits the field length to 4,096 characters. Any data longer than that is truncated during ingestion. If you have values exceeding the character limit, here are some options to try: Troubleshooting tips Comments Parse long messages Parse your log message into shorter key/value pairs. A common example is a single log line from an NGINX access log. That log message can be parsed using built-in parsing via Logstash, Fluentd, or Fluent Bit. For more information, see our documentation about parsing log data. Use JSON output Use JSON as an output format instead of plain text. JSON log messages will automatically be parsed into key/value pairs, which makes it much less likely to hit the character limit. Expand blob data The first 4,094 characters in a log message are stored as a string. The next 128,000 bytes are stored as a blob. To query for any log data in New Relic, run the following query: SELECT * FROM Log Copy To expand the blob data, run the following query, using message or any other attribute. Be sure to enclose the blob's attribute with backticks. For example: SELECT message, another-attribute, blob(`newrelic.ext.message`), blob(`newrelic.ext.another-attribute) FROM Log Copy For more information, see our documentation about long messages stored as blobs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 155.3814,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Log</em> message is truncated",
        "sections": "<em>Log</em> message is truncated",
        "tags": "<em>Log</em> <em>management</em>",
        "body": "Problem Not all <em>log</em> data in a message or for a specific attribute is being displayed. The <em>log</em> data ends with an ellipses (...) and the remaining data isn&#x27;t shown. Solution This occurs because the <em>logs</em> datastore in New Relic limits the field length to 4,096 characters. Any data longer than"
      },
      "id": "604413de196a67578c960f79"
    }
  ],
  "/docs/logs/ui-data/built-log-parsing-rules": [
    {
      "sections": [
        "Find data in long logs (blobs)",
        "How blobs work",
        "Tip",
        "Query your data for blobs",
        "Data retention for long logs"
      ],
      "title": "Find data in long logs (blobs)",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "413651f55060d47b3b2c3a939d9f4f576467e405",
      "image": "https://docs.newrelic.com/static/25249afab9ba5695a0764e676d14dfb3/c1b63/log-blob-query.png",
      "url": "https://docs.newrelic.com/docs/logs/ui-data/long-logs-blobs/",
      "published_at": "2021-12-04T22:05:37Z",
      "updated_at": "2021-11-14T08:46:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Extensive log data can help you troubleshoot issues. But what if an attribute in your log contains thousands of characters? How much of this data can New Relic store? And how can you find useful information in all this data? How blobs work For lengthy string values that are longer than can be stored in NRDB (4,094 characters), we store the long string in three pieces: Long log sections Description First 4,094 characters The first 4,094 characters are stored in a Log event field with the same name. So a long message value would have its first 4,094 characters stored in a message field. Next 128,000 UTF-8 bytes The next 128,000 UTF-8 bytes of the string are stored in a blob field with the name with newrelic.ext. prepended. So a long message value would have characters past the first 4,094 characters stored in a newrelic.ext.message field as a blob. The actual number of characters stored depends on the UTF-8 representation of the characters. UTF-8 represents Unicode characters as one to four bytes, so we will store anywhere between 32,000 and 128,000 characters past the first 4,094 characters. Remaining characters Any characters past 4,094 characters plus 128,000 bytes are dropped and not stored. So the long message field would be stored as: message: <first 4,094 characters as a string> newrelic.ext.message: <next 128,000 bytes as a 'blob'> Copy Tip You can search the first 4,094 characters of a string attribute. You can also create alerts for the first 4,094 characters. However, since 'blob' storage is not searchable, text beyond the first 4,094 characters is not searchable or alertable. Query your data for blobs To query for any log data in New Relic, run the following query: SELECT * FROM Log Copy To expand the blob data, run the following query, using message or any other attribute. Be sure to enclose the blob's attribute with backticks. For example: SELECT message, another-attribute, blob(`newrelic.ext.message`), blob(`newrelic.ext.another-attribute) FROM Log Copy To query extended blob data in your logs, be sure to include backticks in your attribute's blob syntax. This expands the data in the blob so you can see (but not search) it. For example, New Relic returns: { \"message\": <first 4,094 characters> \"newrelic.ext.message\": <the next 128,000 bytes as Base64> \"another-attribute\": <first 4,094 characters> \"newrelic.ext.another-attribute\": <the next 128,000 bytes as Base64> } Copy The Logs UI automatically stitches the original value back together when looking at the Log Detail View. When querying using NRQL directly, you need to manually stitch the information together by: Decoding the Base64 of the newrelic.ext. attribute value Converting the resulting UTF-8 into a string Appending that string to the first 4,094 characters in the \"main\" attribute Data retention for long logs NRDB retains your blob records for a month. If you have existing long log messages stored as LogExtendedRecord, that data will also continue to be available for a month in NRDB. After a month passes, no more new LogExtendedRecord attributes will be created. They will all be stored in NRDB as blobs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.90712,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Find <em>data</em> in long <em>logs</em> (blobs)",
        "sections": "Find <em>data</em> in long <em>logs</em> (blobs)",
        "tags": "<em>Log</em> <em>management</em>",
        "body": " other attribute. Be sure to enclose the blob&#x27;s attribute with backticks. For example: SELECT message, another-attribute, blob(`newrelic.ext.message`), blob(`newrelic.ext.another-attribute) FROM <em>Log</em> Copy To query extended blob <em>data</em> in your <em>logs</em>, be sure to include backticks in your attribute&#x27;s blob"
      },
      "id": "6150569228ccbcf314f21423"
    },
    {
      "sections": [
        "Organize data with partitions",
        "Plan your partition",
        "Important",
        "Required roles and permissions",
        "Sizing and organizing a partition",
        "Choosing a namespace",
        "Create partition rules",
        "Search data partitions",
        "Manage data partitions programatically with NerdGraph"
      ],
      "title": "Organize data with partitions",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "620ba43370a8ca4900a02cd4ccc6fefa7f5cf8d7",
      "image": "https://docs.newrelic.com/static/7815845d8068377477aa26f8571d5907/c1b63/log-partitions-crop.png",
      "url": "https://docs.newrelic.com/docs/logs/ui-data/data-partitions/",
      "published_at": "2021-12-04T22:05:01Z",
      "updated_at": "2021-11-14T07:18:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Data partitions are a way to group or organize log data for faster and more efficient querying. When a query targets a single partition, New Relic's Logs UI: Scans less unrelated data. Returns results faster. Accounts can have multiple partitions, and multiple partitions can be queried at the same time. Data partitions also allow data to be mapped to an alternative, or “secondary” namespace with a fixed 30-day retention. This is useful for maintaining compliance with privacy-centric regulations and standards like the General Data Protection Regulation (GDPR). Plan your partition Before you start creating partitions, make sure you have the right permissions and a partition plan. Important Logs are routed to partitions during the ingestion process, before data is written to NRDB. Partition rules will not affect logs that were ingested before the rule was created. Required roles and permissions Users require an Admin role to create and modify partition rules. Sizing and organizing a partition You can gain significant performance improvements with proper use of data partitions. Organizing your data into discrete partitions enables you to query them separately or all together. The goals of partitioning your data should be: Create data partitions that align with concepts in your environment or organization that are static or change infrequently (for example, by business unit, team, environment, service, etc.). Ensure each partition remains below 1 TB of daily ingest for optimal performance. Having more partitions allows for more targeted searches, but creating too many partitions can make logs hard to find and increase administrative overhead. Finding the right balance is important. We support 100 partitions maximum per account, but the optimal number for most accounts is 10 to 15 partitions. Choosing a namespace A partition’s namespace determines its retention period. We offer two retention options: Standard: The account’s default retention determined by your New Relic subscription. This is the maximum retention period available in your account and is the namespace you'll select for most of your partitions. Secondary: 30-day retention. All logs sent to a partition that's a member of the Secondary namespace will be purged on a rolling basis 30 days after having been ingested. Secondary retention is not a cost control mechanism; data is billed on ingest. Create partition rules From the left nav in the Logs UI, select Data partitions, then create a Log_ partition name with the retention namespace, optional description, and matching criteria. To create a new partition rule: Go to one.newrelic.com > Logs. From Manage Data on the left nav of the Logs UI, click Data partitions, then click Create partition rule. Define a Partition name as an alphanumeric string that begins with Log_. Add an optional description. Select the retention namespace for the partition. Set your rule's Matching criteria: Select EQUALS to target logs that match your criteria exactly, or select LIKE to apply a fuzzy match. Click the Enable Rule slider, and click Create. To view a list of data partitions: From Manage Data on the left nav of the Logs UI, click Data partitions. Search data partitions The default partition for all Logs accounts is Log. Any log that is not affected by a partition rule will be stored in the Log partition by default. You can query multiple partitions simultaneously. For best performance, select the smallest number of partitions possible. To search data partitions: From Views and Attributes on the left nav of the Logs UI, click Select partitions. Click one or more partitions you want to query, or search for a partition name. Click Query logs to search your selected partitions. Manage data partitions programatically with NerdGraph If you want to manage your data partitions programatically, you can use NerdGraph, our GraphQL-format API. This tutorial shows how to query, create, and delete data partitions using our API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.80002,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Organize <em>data</em> with partitions",
        "sections": "<em>Manage</em> <em>data</em> partitions programatically with NerdGraph",
        "tags": "<em>Log</em> <em>management</em>",
        "body": "<em>Data</em> partitions are a way to group or organize <em>log</em> <em>data</em> for faster and more efficient querying. When a query targets a single partition, New Relic&#x27;s <em>Logs</em> <em>UI</em>: Scans less unrelated <em>data</em>. Returns results faster. Accounts can have multiple partitions, and multiple partitions can be queried at the same"
      },
      "id": "6087e311e7b9d2f90ba5c6a4"
    },
    {
      "sections": [
        "Drop data with drop filter rules",
        "Savings, security, speed",
        "Caution",
        "How drop filter rules work",
        "Cautions when dropping data",
        "Create drop filter rules",
        "Manage drop filter rules via NerdGraph API",
        "Types of drop filter rules",
        "Drop log events",
        "Drop attributes",
        "Tip",
        "View or delete drop filter rules"
      ],
      "title": "Drop data with drop filter rules",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "41ef69e9d8d23b2ab732b489bb5e0cb47b8c16b6",
      "image": "https://docs.newrelic.com/static/db4b077fafd911b9f5019b022b3048ab/b04e4/ingest-pipeline.png",
      "url": "https://docs.newrelic.com/docs/logs/ui-data/drop-data-drop-filter-rules/",
      "published_at": "2021-12-04T22:05:01Z",
      "updated_at": "2021-11-14T07:15:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After log event data has been shipped to New Relic, it can either be stored in our NRDB database or dropped (discarded). We can drop both log events and event attributes via drop filter rules. You can manage drop filter rules using our Logs UI, as explained in this document. You can also use NerdGraph, our GraphQL-format API explorer. Savings, security, speed Drop filter rules help you accomplish several important goals: Lower costs by storing only logs relevant to your account. Protect privacy and security by removing personal identifiable information (PII). Reduce noise by removing irrelevant events and attributes. Caution Use caution when deciding to drop data. The data you drop is not recoverable. Before using this feature, review the responsibilities and considerations for dropping data. How drop filter rules work A drop filter rule matches data based on a query. When triggered, the drop filter rule removes the matching data from the ingestion pipeline before it is written to NRDB. This creates an explicit demarcation between the logs being forwarded from your domain and the data that New Relic collects. Since the data removed by the drop filter rule doesn't reach our backend, it cannot be queried: the data is gone and cannot be restored. During the ingestion process, customer log data can be parsed, transformed, or dropped before being stored in New Relic's database. Cautions when dropping data When creating drop rules, you are responsible for ensuring that the rules accurately identify and discard the data that meets the conditions that you have established. You are also responsible for monitoring the rule, as well as the data you disclose to New Relic. New Relic cannot guarantee that this functionality will completely resolve data disclosure concerns you may have. New Relic doesn't review or monitor how effective the rules you develop are. Creating rules about sensitive data can leak information about what kinds of data you maintain, including the format of your data or systems (for example, through referencing email addresses or specific credit card numbers). Any user with the relevant role-based access control permissions can view and edit all information in the rules you create. Create drop filter rules To create and edit drop filters, you must have admin permissions in New Relic, or you must be a member of a role with create and edit permissions for Insights > NRQL Drop Rules. Once a drop filter rule is active, it's applied to all log events ingested from that point onwards. Rules are not applied retroactively. Logs collected before creating a rule are not filtered by that rule. Filter or query the set of logs that contain the data you want to drop. Then, from Manage Data on the left nav of the Logs UI, click Create drop filter. To create a new drop filter rule, you can use new or existing log queries. Go to one.newrelic.com > Logs. Filter or query to the specific set of logs that contain the data to be dropped. Once the query is active, from Manage Data on the left nav of the Logs UI, click Create drop filter. Recommendation: Change the drop rule's default name to a meaningful name. Choose to either drop the entire log event that matches the query or just a specific subset of attributes in the matching events. Review the log partitions where this drop rule applies. Save the drop filter rule. Manage drop filter rules via NerdGraph API If you want to manage your drop filter rules programmatically, you can use NerdGraph, our graphQL-format API, at api.newrelic.com/graphiql. For more information, see the NerdGraph tutorial to create, query, and delete your drop filter rules. Types of drop filter rules The drop filters UI prompts you to select whether to drop logs based on the query or on specific attributes. Drop log events The default type of drop filter rule is to drop logs. This option drops the entire log events that match the filter or query. When creating a rule, try to provide a specific query that only matches log data that should be dropped. Our drop filters process won't let you create drop filter rules without values in the matching query. This prevents badly formed rules from dropping all log data. Drop attributes You can specify attributes to be dropped in a log event that matches your query. At least one or more attributes must be selected. Any attribute which is selected will be dropped; all remaining attributes will be kept and stored in NRDB. Tip We recommend this method for removing fields that could contain personal identifiable information (PII) or other sensitive attributes without losing valuable monitoring data. View or delete drop filter rules To view or delete a drop filter rule: Go to one.newrelic.com > Logs. From Manage Data on the left nav of the Logs UI, click Drop filters. Click the delete icon next to the drop filter rule you want to remove. Once deleted, rules no longer filter ingested log events.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.79596,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Drop <em>data</em> with drop filter rules",
        "sections": "Drop <em>data</em> with drop filter rules",
        "tags": "<em>Log</em> <em>management</em>",
        "body": "After <em>log</em> event <em>data</em> has been shipped to New Relic, it can either be stored in our NRDB database or dropped (discarded). We can drop both <em>log</em> events and event attributes via drop filter rules. You can manage drop filter rules using our <em>Logs</em> <em>UI</em>, as explained in this document. You can also use"
      },
      "id": "603e813f28ccbc08c1eba787"
    }
  ],
  "/docs/logs/ui-data/data-partitions": [
    {
      "sections": [
        "Find data in long logs (blobs)",
        "How blobs work",
        "Tip",
        "Query your data for blobs",
        "Data retention for long logs"
      ],
      "title": "Find data in long logs (blobs)",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "413651f55060d47b3b2c3a939d9f4f576467e405",
      "image": "https://docs.newrelic.com/static/25249afab9ba5695a0764e676d14dfb3/c1b63/log-blob-query.png",
      "url": "https://docs.newrelic.com/docs/logs/ui-data/long-logs-blobs/",
      "published_at": "2021-12-04T22:05:37Z",
      "updated_at": "2021-11-14T08:46:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Extensive log data can help you troubleshoot issues. But what if an attribute in your log contains thousands of characters? How much of this data can New Relic store? And how can you find useful information in all this data? How blobs work For lengthy string values that are longer than can be stored in NRDB (4,094 characters), we store the long string in three pieces: Long log sections Description First 4,094 characters The first 4,094 characters are stored in a Log event field with the same name. So a long message value would have its first 4,094 characters stored in a message field. Next 128,000 UTF-8 bytes The next 128,000 UTF-8 bytes of the string are stored in a blob field with the name with newrelic.ext. prepended. So a long message value would have characters past the first 4,094 characters stored in a newrelic.ext.message field as a blob. The actual number of characters stored depends on the UTF-8 representation of the characters. UTF-8 represents Unicode characters as one to four bytes, so we will store anywhere between 32,000 and 128,000 characters past the first 4,094 characters. Remaining characters Any characters past 4,094 characters plus 128,000 bytes are dropped and not stored. So the long message field would be stored as: message: <first 4,094 characters as a string> newrelic.ext.message: <next 128,000 bytes as a 'blob'> Copy Tip You can search the first 4,094 characters of a string attribute. You can also create alerts for the first 4,094 characters. However, since 'blob' storage is not searchable, text beyond the first 4,094 characters is not searchable or alertable. Query your data for blobs To query for any log data in New Relic, run the following query: SELECT * FROM Log Copy To expand the blob data, run the following query, using message or any other attribute. Be sure to enclose the blob's attribute with backticks. For example: SELECT message, another-attribute, blob(`newrelic.ext.message`), blob(`newrelic.ext.another-attribute) FROM Log Copy To query extended blob data in your logs, be sure to include backticks in your attribute's blob syntax. This expands the data in the blob so you can see (but not search) it. For example, New Relic returns: { \"message\": <first 4,094 characters> \"newrelic.ext.message\": <the next 128,000 bytes as Base64> \"another-attribute\": <first 4,094 characters> \"newrelic.ext.another-attribute\": <the next 128,000 bytes as Base64> } Copy The Logs UI automatically stitches the original value back together when looking at the Log Detail View. When querying using NRQL directly, you need to manually stitch the information together by: Decoding the Base64 of the newrelic.ext. attribute value Converting the resulting UTF-8 into a string Appending that string to the first 4,094 characters in the \"main\" attribute Data retention for long logs NRDB retains your blob records for a month. If you have existing long log messages stored as LogExtendedRecord, that data will also continue to be available for a month in NRDB. After a month passes, no more new LogExtendedRecord attributes will be created. They will all be stored in NRDB as blobs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.90712,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Find <em>data</em> in long <em>logs</em> (blobs)",
        "sections": "Find <em>data</em> in long <em>logs</em> (blobs)",
        "tags": "<em>Log</em> <em>management</em>",
        "body": " other attribute. Be sure to enclose the blob&#x27;s attribute with backticks. For example: SELECT message, another-attribute, blob(`newrelic.ext.message`), blob(`newrelic.ext.another-attribute) FROM <em>Log</em> Copy To query extended blob <em>data</em> in your <em>logs</em>, be sure to include backticks in your attribute&#x27;s blob"
      },
      "id": "6150569228ccbcf314f21423"
    },
    {
      "sections": [
        "Built-in log parsing rules",
        "Apache",
        "Application Load Balancer",
        "Cloudfront",
        "Elastic Load Balancer",
        "Microsoft IIS",
        "Monit",
        "MySQL Error",
        "NGINX",
        "NGINX Error",
        "Route 53",
        "Syslog RFC-5424"
      ],
      "title": "Built-in log parsing rules",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "ae238defe10615c8767ea24f74b3c416190f4b49",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/ui-data/built-log-parsing-rules/",
      "published_at": "2021-12-04T22:06:50Z",
      "updated_at": "2021-11-14T07:16:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic can parse common log formats according to built-in rules, so that you don't have to create your own parsing rules. Here are the log parsing rules, their Grok patterns, and what fields are parsed. To enable built-in log parsing, see our documentation for adding the logtype attribute. To manage your parsing rules programmatically, use NerdGraph, our GraphQL-format API, at api.newrelic.com/graphiql. For more information, see the NerdGraph tutorial to create, query, and delete your parsing rules. Apache Source: logtype = 'apache' Grok: %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \\[%{HTTPDATE:timestamp}\\] \"(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})\" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer} %{QS:agent} Copy Results: clientip: The IP address of the client. verb: The HTTP verb ident: The user identity of the client making the request response: The HTTP status code of the response request: The URI and request being made httpversion: The HTTP version of the request rawrequest: The raw HTTP request if data is posted bytes: The number of bytes sent referrer: The HTTP referrer agent: The client's user agent Application Load Balancer Source: logtype = 'alb' Grok: ^%{NOTSPACE:type} %{TIMESTAMP_ISO8601:time} %{NOTSPACE:elb} %{NOTSPACE:client_ip}:%{NOTSPACE:client_port} ((%{NOTSPACE:target_ip}:%{NOTSPACE:target_port})|-) %{NOTSPACE:request_processing_time} %{NOTSPACE:target_processing_time} %{NOTSPACE:response_processing_time} %{NOTSPACE:elb_status_code} %{NOTSPACE:target_status_code} %{NOTSPACE:received_bytes} %{NOTSPACE:sent_bytes} \"%{DATA:request}\" \"%{DATA:user_agent}\" %{NOTSPACE:ssl_cipher} %{NOTSPACE:ssl_protocol} %{NOTSPACE:target_group_arn} \"%{DATA:trace_id}\" \"%{NOTSPACE:domain_name}\" \"%{NOTSPACE:chosen_cert_arn}\" %{NOTSPACE:matched_rule_priority} %{TIMESTAMP_ISO8601:request_creation_time} \"%{NOTSPACE:actions_executed}\" \"%{NOTSPACE:redirect_url}\" \"%{NOTSPACE:error_reason}\" (?:\"|)%{DATA:target_port_list}(?:\"|) (?:\"|)%{DATA:target_status_code_list}(?:\"|) \"%{NOTSPACE:classification}\" \"%{NOTSPACE:classification_reason}\" Copy Results: Field Definition type The type of request or connection. Possible values are: http: HTTP https: HTTP over SSL/TLS h2: HTTP/2 over SSL/TLS ws: WebSockets wss: WebSockets over SSL/TLS elb The resource ID of the load balancer. If you are parsing access log entries, note that resources IDs can contain forward slashes (/). client The IP address and port of the requesting client target The IP address and port of the target that processed this request. If the client didn't send a full request, the load balancer can't dispatch the request to a target, and this value is set to -. If the target is a Lambda function, this value is set to -. If the request is blocked by AWS WAF, this value is set to -, and the value of elb_status_code is set to 403. request_processing_time The total time elapsed (in seconds, with millisecond precision) from the time the load balancer received the request until the time it sent it to a target. This value is set to -1 if the load balancer can't dispatch the request to a target. This can happen if the target closes the connection before the idle timeout or if the client sends a malformed request. This value can also be set to -1 if the registered target does not respond before the idle timeout. target_processing_time The total time elapsed (in seconds, with millisecond precision) from the time the load balancer sent the request to a target until the target started to send the response headers. This value is set to -1 if the load balancer can't dispatch the request to a target. This can happen if the target closes the connection before the idle timeout or if the client sends a malformed request. This value can also be set to -1 if the registered target does not respond before the idle timeout. response_processing_time The total time elapsed (in seconds, with millisecond precision) from the time the load balancer received the response header from the target until it started to send the response to the client. This includes both the queuing time at the load balancer and the connection acquisition time from the load balancer to the client. This value is set to -1 if the load balancer can't send the request to a target. This can happen if the target closes the connection before the idle timeout or if the client sends a malformed request. elb_status_code The status code of the response from the load balancer target_status_code The status code of the response from the target. This value is recorded only if a connection was established to the target and the target sent a response. Otherwise, it is set to -. received_bytes The size of the request, in bytes, received from the client (requester). For HTTP requests, this includes the headers. For WebSockets, this is the total number of bytes received from the client on the connection. sent_bytes The size of the response, in bytes, sent to the client (requester). For HTTP requests, this includes the headers. For WebSockets, this is the total number of bytes sent to the client on the connection. method The HTTP verb of the request uri The URI the request was targeting http_version The HTTP version number of the request user_agent User-Agent string that identifies the client that originated the request, enclosed in double quotes. The string consists of one or more product identifiers, product/version. If the string is longer than 8 KB, it is truncated. ssl_cipher The SSL cipher. This value is set to - if the listener is not an HTTPS listener. ssl_protocol The SSL protocol. This value is set to - if the listener is not an HTTPS listener. target_group_arn The Amazon Resource Name (ARN) of the target group trace_id The contents of the X-Amzn-Trace-Id header, enclosed in double quotes domain_name The SNI domain provided by the client during the TLS handshake, enclosed in double quotes. This value is set to - if the client doesn't support SNI or the domain doesn't match a certificate and the default certificate is presented to the client. chosen_cert_arn The ARN of the certificate presented to the client, enclosed in double quotes. Set to session-reused if the session is reused. Set to - if the listener is not an HTTPS listener. matched_rule_priority The priority value of the rule that matched the request. If a rule matched, this is a value from 1 to 50000. If no rule matched and the default action was taken, this value is set to 0. If an error occurs during rules evaluation, it is set to -1. For any other error, it is set to -. request_creation_time The time when the load balancer received the request from the client, in ISO 8601 format. actions_executed The actions taken when processing the request, enclosed in double quotes. This value is a comma-separated list that can include the values described in actions_taken. If no action was taken, such as for a malformed request, this value is set to -. redirect_url The URL of the redirect target for the location header of the HTTP response, enclosed in double quotes. If no redirect actions were taken, this value is set to -. error_reason The error reason code, enclosed in double quotes. If the request failed, this is one of the error codes described in Error Reason Codes. If the actions taken do not include an authenticate action or the target is not a Lambda function, this value is set to -. Cloudfront Source: logtype = 'cloudfront-web' Grok: ^%{NOTSPACE:date}%{SPACE}%{NOTSPACE:time}%{SPACE}%{NOTSPACE:x_edge_location}%{SPACE}%{NOTSPACE:sc_bytes}%{SPACE}%{NOTSPACE:c_ip}%{SPACE}%{NOTSPACE:cs_method}%{SPACE}%{NOTSPACE:cs_host}%{SPACE}%{NOTSPACE:cs_uri_stem}%{SPACE}%{NOTSPACE:sc_status}%{SPACE}%{NOTSPACE:cs_referer}%{SPACE}%{NOTSPACE:cs_user_agent}%{SPACE}%{NOTSPACE:cs_uri_query}%{SPACE}%{NOTSPACE:cs_Cookie}%{SPACE}%{NOTSPACE:x_edge_result_type}%{SPACE}%{NOTSPACE:x_edge_request_id}%{SPACE}%{NOTSPACE:x_host_header}%{SPACE}%{NOTSPACE:cs_protocol}%{SPACE}%{NOTSPACE:cs_bytes}%{SPACE}%{NOTSPACE:time_taken}%{SPACE}%{NOTSPACE:x_forwarded_for}%{SPACE}%{NOTSPACE:ssl_protocol}%{SPACE}%{NOTSPACE:ssl_cipher}%{SPACE}%{NOTSPACE:x_edge_response_result_type}%{SPACE}%{NOTSPACE:cs_protocol_version}%{SPACE}%{NOTSPACE:fle_status}%{SPACE}%{NOTSPACE:fle_encrypted_fields}%{SPACE}%{NOTSPACE:c_port}%{SPACE}%{NOTSPACE:time_to_first_byte}%{SPACE}%{NOTSPACE:x_edge_detailed_result_type}%{SPACE}%{NOTSPACE:sc_content_type}%{SPACE}%{NOTSPACE:sc_content_len}%{SPACE}%{NOTSPACE:sc_range_start}%{SPACE}%{NOTSPACE:sc_range_end} Copy Results: Field Definition x_edge_location The edge location that served the request. Each edge location is identified by a three-letter code and an arbitrarily assigned number; for example, DFW3. The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.) sc_bytes The total number of bytes that CloudFront served to the viewer in response to the request, including headers; for example, 1045619. For WebSocket connections, this is the total number of bytes sent from the server to the client through the connection. c_ip The IP address of the viewer that made the request, either in IPv4 or IPv6 format. If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip is the IP address of the proxy or load balancer. See also X-Forwarded-For. cs_method The HTTP request method: DELETE, GET, HEAD, OPTIONS, PATCH, POST, or PUT. cs_host The domain name of the CloudFront distribution; for example, d111111abcdef8.cloudfront.net. cs_uri_stem The portion of the URI that identifies the path and object; for example, /images/cat.jpg. Question marks in URLs and query strings are not included. sc_status An HTTP status code; for example, 200. Status code 000 indicates the viewer closed the connection (for example, closed the browser tab) before CloudFront could respond to a request. If the viewer closes the connection after CloudFront starts to send the response, the log contains the applicable HTTP status code. cs_referer The name of the domain that originated the request. Common referrers include search engines, other websites that link directly to your objects, and your own website. cs_user_agent The value of the User-Agent header in the request. The User-Agent header identifies the source of the request, such as the type of device and browser that submitted the request, and which search engine if applicable. cs_uri_query The query string portion of the URI, if any. When a URI doesn't contain a query string, this field's value is a hyphen (-). cs_cookie The cookie header in the request, including name-value pairs and the associated attributes. If you enable cookie logging, CloudFront logs the cookies in all requests regardless of which cookies you choose to forward to the origin. If a request doesn't include a cookie header, this field's value is a hyphen (-). x_edge_result_type How CloudFront classifies the response after the last byte left the edge location. In some cases, the result type can change between the time that CloudFront is ready to send the response and the time that CloudFront has finished sending the response. x_edge_request_id An encrypted string that uniquely identifies a request. In the response header, this is x-amz-cf-id. x_host_header The value that the viewer included in the Host header for this request. This is the domain name in the request. If you're using the CloudFront domain name in your object URLs, this field contains that domain name. If you're using alternate domain names in your object URLs, such as http://example.com/logo.png, this field contains the alternate domain name, such as example.com. To use alternate domain names, you must add them to your distribution. cs_protocol The protocol that the viewer specified in the request: http, https, ws, or wss. cs_bytes The number of bytes of data that the viewer included in the request, including headers. For WebSocket connections, this is the total number of bytes sent from the client to the server on the connection. time_taken The number of seconds (to the thousandth of a second; for example, 0.002) between the time that a CloudFront edge server receives a viewer's request and the time that CloudFront writes the last byte of the response to the edge server's output queue as measured on the server. From the perspective of the viewer, the total time to get the full object will be longer than this value due to network latency and TCP buffering. x_forwarded_for If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip in field 5 is the IP address of the proxy or load balancer. In that case, this field is the IP address of the viewer that originated the request. This field contains IPv4 and IPv6 addresses as applicable. If the viewer did not use an HTTP proxy or a load balancer, the value of x_forwarded_for is a hyphen (-). ssl_protocol When cs_protocol in field 17 is https, this field contains the SSL/TLS protocol that the client and CloudFront negotiated for transmitting the request and response. Possible values include: SSLv3 TLSv1 TLSv1.1 TLSv1.2 When cs_protocol in field 17 is http, the value for this field is a hyphen (-). ssl_cipher When cs_protocol in field 17 is https, this field contains the SSL/TLS cipher that the client and CloudFront negotiated for encrypting the request and response. Possible values include: ECDHE-RSA-AES128-GCM-SHA256 ECDHE-RSA-AES128-SHA256 ECDHE-RSA-AES128-SHA ECDHE-RSA-AES256-GCM-SHA384 ECDHE-RSA-AES256-SHA384 ECDHE-RSA-AES256-SHA AES128-GCM-SHA256 AES256-GCM-SHA384 AES128-SHA256 AES256-SHA AES128-SHA DES-CBC3-SHA RC4-MD5 When cs_protocol in field 17 is http, the value for this field is a hyphen (-). x_edge_response_result_type How CloudFront classified the response just before returning the response to the viewer. Possible values include: Hit: CloudFront served the object to the viewer from the edge cache. RefreshHit: CloudFront found the object in the edge cache but it had expired, so CloudFront contacted the origin to verify that the cache has the latest version of the object. Miss: The request could not be satisfied by an object in the edge cache, so CloudFront forwarded the request to the origin server and returned the result to the viewer. LimitExceeded: The request was denied because a CloudFront limit was exceeded. CapacityExceeded: CloudFront returned a 503 error because the edge location didn't have enough capacity at the time of the request to serve the object. Error: Typically this means the request resulted in a client error (sc_status is 4xx) or a server error (sc_status is 5xx). If the value of x_edge_result_type is Error and the value of this field is not Error, the client disconnected before finishing the download. Redirect: CloudFront redirects from HTTP to HTTPS. If sc_status is 403 and you configured CloudFront to restrict the geographic distribution of your content, the request might have come from a restricted location. cs_protocol_version The HTTP version that the viewer specified in the request. Possible values include: HTTP/0.9 HTTP/1.0 HTTP/1.1 HTTP/2.0 fle_status When field-level encryption is configured for a distribution, this field contains a code that indicates whether the request body was successfully processed. If field-level encryption is not configured for the distribution, the value is a hyphen (-). fle-encrypted-fields The number of fields that CloudFront encrypted and forwarded to the origin. CloudFront streams the processed request to the origin as it encrypts data, so fle-encrypted-fields can have a value even if the value of fle-status is an error. If field-level encryption is not configured for the distribution, the value of fle-encrypted-fields is a hyphen (-). c_port The port number of the request from the viewer. time_to_first_byte The number of seconds between receiving the request and writing the first byte of the response, as measured on the server. x_edge_detailed_result_type When x-edge-result-type is not Error, this field contains the same value as x-edge-result-type. When x-edge-result-type is Error, this field contains the specific type of error. sc_content_type The value of the HTTP Content-Type header of the response. sc_content_len The value of the HTTP Content-Length header of the response. sc_range_start When the response contains the HTTP Content-Range header, this field contains the range start value. sc-range-end When the response contains the HTTP Content-Range header, this field contains the range end value. Elastic Load Balancer Source: logtype = 'elb' Grok: ^%{TIMESTAMP_ISO8601:time} %{NOTSPACE:elb} %{NOTSPACE:client_ip}:%{NOTSPACE:client_port} ((%{NOTSPACE:backend_ip}:%{NOTSPACE:backend_port})|-) %{NOTSPACE:request_processing_time} %{NOTSPACE:backend_processing_time} %{NOTSPACE:response_processing_time} %{NOTSPACE:elb_status_code} %{NOTSPACE:backend_status_code} %{NOTSPACE:received_bytes} %{NOTSPACE:sent_bytes} \"%{DATA:request}\" \"%{DATA:user_agent}\" %{NOTSPACE:ssl_cipher} %{NOTSPACE:ssl_protocol} Copy Results: Field Definition x_edge_location The edge location that served the request. Each edge location is identified by a three-letter code and an arbitrarily assigned number; for example, DFW3. The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.) sc_bytes The total number of bytes that CloudFront served to the viewer in response to the request, including headers; for example, 1045619. For WebSocket connections, this is the total number of bytes sent from the server to the client through the connection. c_ip The IP address of the viewer that made the request. If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip is the IP address of the proxy or load balancer. cs_method The HTTP request method: DELETE, GET, HEAD, OPTIONS, PATCH, POST, or PUT. cs_host The domain name of the CloudFront distribution; for example, d111111abcdef8.cloudfront.net. cs_uri_stem The portion of the URI that identifies the path and object; for example, /images/cat.jpg. Question marks (?) in URLs and query strings are not included in the log. sc_status An HTTP status code (for example, 200). Status code 000 indicates that the viewer closed the connection (for example, closed the browser tab) before CloudFront could respond to a request. If the viewer closes the connection after CloudFront starts to send the response, the log contains the applicable HTTP status code. cs_referer he name of the domain that originated the request. Common referrers include search engines, other websites that link directly to your objects, and your own website. cs_user_agent The value of the User-Agent header in the request. The User-Agent header identifies the source of the request, such as the type of device and browser that submitted the request and which search engine if applicable. cs_uri_query The query string portion of the URI, if any. When a URI doesn't contain a query string, this field's value is a hyphen (-). cs_cookie The cookie header in the request, including name-value pairs and the associated attributes. If you enable cookie logging, CloudFront logs the cookies in all requests, regardless of which cookies you choose to forward to the origin. If a request doesn't include a cookie header, this field's value is a hyphen (-). x_edge_result_type How CloudFront classifies the response after the last byte left the edge location. In some cases, the result type can change between the time that CloudFront is ready to send the response and the time that CloudFront has finished sending the response. x_edge_request_id An encrypted string that uniquely identifies a request. In the response header, this is x-amz-cf-id. x_host_header The value that the viewer included in the Host header for this request. This is the domain name in the request. If you're using the CloudFront domain name in your object URLs, this field contains that domain name. If you're using alternate domain names in your object URLs, such as [http://example.com/logo.png, this field contains the alternate domain name, such as example.com. To use alternate domain names, you must add them to your distribution. cs_protocol The protocol that the viewer specified in the request: http, https, ws, or wss. cs_bytes The number of bytes of data that the viewer included in the request, including headers. For WebSocket connections, this is the total number of bytes sent from the client to the server on the connection. time_taken The number of seconds (to the thousandth of a second; for example, 0.002) between the time that a CloudFront edge server receives a viewer's request and the time that CloudFront writes the last byte of the response to the edge server's output queue as measured on the server. From the perspective of the viewer, the total time to get the full object will be longer than this value due to network latency and TCP buffering. x_forwarded_for If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip in field 5 is the IP address of the proxy or load balancer. In that case, this field is the IP address of the viewer that originated the request. This field contains IPv4 and IPv6 addresses as applicable. If the viewer did not use an HTTP proxy or a load balancer, the value of x_forwarded_for is a hyphen (-). ssl_protocol When cs_protocol in field 17 is https, this field contains the SSL/TLS protocol that the client and CloudFront negotiated for transmitting the request and response. Possible values include: SSLv3 TLSv1 TLSv1.1 TLSv1.2 When cs_protocol in field 17 is http, the value for this field is a hyphen (-). ssl_cipher When cs_protocol in field 17 is https, this field contains the SSL/TLS cipher that the client and CloudFront negotiated for encrypting the request and response. Possible values include: ECDHE-RSA-AES128-GCM-SHA256 ECDHE-RSA-AES128-SHA256 ECDHE-RSA-AES128-SHA ECDHE-RSA-AES256-GCM-SHA384 ECDHE-RSA-AES256-SHA384 ECDHE-RSA-AES256-SHA AES128-GCM-SHA256 AES256-GCM-SHA384 AES128-SHA256 AES256-SHA AES128-SHA DES-CBC3-SHA RC4-MD5 When cs_protocol is http, the value for this field is a hyphen (-). x_edge_response_result_type How CloudFront classified the response just before returning the response to the viewer. Possible values include: Hit: CloudFront served the object to the viewer from the edge cache. RefreshHit: CloudFront found the object in the edge cache but it had expired, so CloudFront contacted the origin to verify that the cache has the latest version of the object. Miss: The request could not be satisfied by an object in the edge cache, so CloudFront forwarded the request to the origin server and returned the result to the viewer. LimitExceeded: The request was denied because a CloudFront limit was exceeded. CapacityExceeded: CloudFront returned a 503 error because the edge location didn't have enough capacity at the time of the request to serve the object. Error: Typically this means the request resulted in a client error (sc_status is 4xx) or a server error (sc_status is 5xx). If the value of x_edge_result_type is Error and the value of this field is not Error, the client disconnected before finishing the download. Redirect: CloudFront redirects from HTTP to HTTPS. If sc_status is 403 and you configured CloudFront to restrict the geographic distribution of your content, the request might have come from a restricted location. cs_protocol_version The HTTP version that the viewer specified in the request. Possible values include: HTTP/0.9 HTTP/1.0 HTTP/1.1 HTTP/2.0 fle_status When field-level encryption is configured for a distribution, this field contains a code that indicates whether the request body was successfully processed. If field-level encryption is not configured for the distribution, the value of this field is a hyphen (-). When CloudFront successfully processes the request body, encrypts values in the specified fields, and forwards the request to the origin, the value of this field is Processed. The value of x_edge_result_type can still indicate a client-side or server-side error in this case. If the request exceeds a field-level encryption limit, fle-status contains one of the following error codes, and CloudFront returns HTTP status code 400 to the viewer. fle-encrypted-fields The number of fields that CloudFront encrypted and forwarded to the origin. CloudFront streams the processed request to the origin as it encrypts data, so fle_encrypted_fields can have a value even if the value of fle_status is an error. If field-level encryption is not configured for the distribution, the value of fle_encrypted_fields is a hyphen (-). c_port The port number of the request from the viewer. time_to_first_byte The number of seconds between receiving the request and writing the first byte of the response, as measured on the server. x_edge_detailed_result_type When x_edge_result_type is not Error, this field contains the same value as x_edge_result_type. When x_edge_result_type is Error, this field contains the specific type of error. sc_content_type The value of the HTTP Content-Type header of the response. sc_content_len The value of the HTTP Content-Length header of the response. sc_range_start When the response contains the HTTP Content-Range header, this field contains the range start value. sc-range-end When the response contains the HTTP Content-Range header, this field contains the range end value. Microsoft IIS Source: logtype = 'iis_w3c' Grok: %{TIMESTAMP_ISO8601:log_timestamp} %{NOTSPACE:server_ip} %{WORD:method} %{NOTSPACE:uri} %{NOTSPACE:uri_query} %{NOTSPACE:server_port} %{NOTSPACE:username} %{NOTSPACE:client_ip} %{NOTSPACE:user_agent} %{NOTSPACE:referer} %{NOTSPACE:status} %{NOTSPACE:substatus} %{NOTSPACE:win32_status} %{NOTSPACE:time_taken} Copy Monit Source: logtype = 'monit' Grok: \\\\[%{NOTSPACE:tz} %{SYSLOGTIMESTAMP:nr_timestamp}\\\\] %{WORD:state}%{SPACE}: %{GREEDYDATA:message} Copy Results: state: The severity of the log line message: The message MySQL Error Source: logtype = 'mysql-error' Grok: \\\\[%{WORD:log_level}\\\\] Copy Results: log_level: The severity of the log line NGINX Source: logtype = 'nginx' Grok: %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \\[%{HTTPDATE:timestamp}\\] \"(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})\" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer} %{QS:agent} Copy Results: clientip: The IP address of the client verb: The HTTP verb ident: The user identity of the client making the request response: The HTTP status code of the response request: The URI and request being made httpversion: The HTTP version of the request rawrequest: The raw HTTP request if data is posted bytes: The number of bytes sent referrer: The HTTP referrer agent: The client's user agent NGINX Error Source: logtype = 'nginx-error' Grok: ^(?<timestamp>%{YEAR:year}[./-]%{MONTHNUM:month}[./-]%{MONTHDAY:day}[- ]%{TIME:time}) \\\\[%{LOGLEVEL:severity}\\\\] %{POSINT:pid}#%{NUMBER}: %{GREEDYDATA:errormessage}(?:, client: (?<client>%{IP:clientip}|%{HOSTNAME:hostname}))(?:, server: %{IPORHOSTORUNDERSCORE:server})(?:, request: %{QS:request})?(?:, upstream: \\\"%{URI:upstream}\\\")?(?:, host: %{QS:host})?(?:, referrer: \\\"%{URI:referrer}\\\")?$ Copy Results: severity: The severity of the log line pid: The server process ID errormessage: The error message clientip: The IP address of the calling client server: The server IP address request: The full request upstream: The upstream URI host: The server's hostname referrer: The HTTP referrer Route 53 Source: logtype = 'route-53' Grok: %{NUMBER:log_format_version} %{TIMESTAMP_ISO8601} %{WORD:zone_id} %{IPORHOST:query} %{WORD:query_type} %{WORD:response_code} %{WORD:protocol} %{WORD:edge_location} %{IP:resolver_ip} %{GREEDYDATA:edns_client_subnet} Copy Results: log_format_version: A versioned format for the log. zone_id: The ID of the hosted zone that is associated with all the DNS queries in this log. query: The domain or subdomain that was specified in the request. query_type: Either the DNS record type that was specified in the request, or ANY. response_code: The DNS response code that Route 53 returned in response to the DNS query. protocol: The protocol that was used to submit the query, either TCP or UDP. edge_location: The Route 53 edge location that responded to the query. Each edge location is identified by a three-letter code and an arbitrary number; for example, DFW3. The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.) resolver_ip: The IP address of the DNS resolver that submitted the request to Route 53. edns_client_subnet: A partial IP address for the client that the request originated from, if available from the DNS resolver. Syslog RFC-5424 Source: logtype = 'syslog-rfc5424' Grok: <%{NONNEGINT:pri}>%{NONNEGINT:version} +(?:%{TIMESTAMP_ISO8601:log.timestamp}|-) +(?:%{HOSTNAME:hostname}|-) +(?:\\\\-|%{NOTSPACE:app.name}) +(?:\\\\-|%{NOTSPACE:procid}) (?:\\\\-|%{NOTSPACE:msgid}) +(?:\\[%{DATA:structured.data}\\]|-|) +%{GREEDYDATA:message} Copy Results: pri: The priority represents both the message facility and severity. version: Syslog protocol version. log.timestamp: Original timestamp. hostname: The machine that originally sent the Syslog message. app.name: The device or application that originated the message. procid: The process name or process ID associated with a Syslog system. msgid: Identifies the type of message. structured.data: Structured data string value. sd.<var>sd-id</var>.<var>sd-param-name</var>: The structured.data content is also parsed into separate attributes following a predefined naming convention: sd.<var>sd-id</var>.<var>sd-param-name</var>. See the structured data parsing examples, which follow. message: Free-form message that provides information about the event. Structured data parsing examples: The structured data [example one=\"1\" two=\"2\"] would be parsed into two different attributes: sd.example.one: \"1\" sd.example.two: \"2\" Copy If the same structured data block contains duplicate param names, it also appends an index-based suffix on the attribute name. For example, the structured data [example number=\"1\" number=\"2\"] would be parsed as: sd.example.number.0: \"1\" sd.example.number.1: \"2\" Copy For structured data with enterprise numbers assigned, an extra attribute is also parsed. For example, the structured data [example@123 number=\"1\"] would be parsed as: sd.example.enterprise.number: 123 sd.example.number: \"1\" Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.79703,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Built-in <em>log</em> parsing rules",
        "sections": "Built-in <em>log</em> parsing rules",
        "tags": "<em>Log</em> <em>management</em>",
        "body": " RFC-5424 Source: logtype = &#x27;syslog-rfc5424&#x27; Grok: &lt;%{NONNEGINT:pri}&gt;%{NONNEGINT:version} +(?:%{TIMESTAMP_ISO8601:<em>log</em>.timestamp}|-) +(?:%{HOSTNAME:hostname}|-) +(?:\\\\-|%{NOTSPACE:app.name}) +(?:\\\\-|%{NOTSPACE:procid}) (?:\\\\-|%{NOTSPACE:msgid}) +(?:\\[%{<em>DATA:structured.data</em>}\\]|-|) +%{GREEDYDATA:message"
      },
      "id": "603e7b9164441f1b2d4e8872"
    },
    {
      "sections": [
        "Drop data with drop filter rules",
        "Savings, security, speed",
        "Caution",
        "How drop filter rules work",
        "Cautions when dropping data",
        "Create drop filter rules",
        "Manage drop filter rules via NerdGraph API",
        "Types of drop filter rules",
        "Drop log events",
        "Drop attributes",
        "Tip",
        "View or delete drop filter rules"
      ],
      "title": "Drop data with drop filter rules",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "41ef69e9d8d23b2ab732b489bb5e0cb47b8c16b6",
      "image": "https://docs.newrelic.com/static/db4b077fafd911b9f5019b022b3048ab/b04e4/ingest-pipeline.png",
      "url": "https://docs.newrelic.com/docs/logs/ui-data/drop-data-drop-filter-rules/",
      "published_at": "2021-12-04T22:05:01Z",
      "updated_at": "2021-11-14T07:15:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After log event data has been shipped to New Relic, it can either be stored in our NRDB database or dropped (discarded). We can drop both log events and event attributes via drop filter rules. You can manage drop filter rules using our Logs UI, as explained in this document. You can also use NerdGraph, our GraphQL-format API explorer. Savings, security, speed Drop filter rules help you accomplish several important goals: Lower costs by storing only logs relevant to your account. Protect privacy and security by removing personal identifiable information (PII). Reduce noise by removing irrelevant events and attributes. Caution Use caution when deciding to drop data. The data you drop is not recoverable. Before using this feature, review the responsibilities and considerations for dropping data. How drop filter rules work A drop filter rule matches data based on a query. When triggered, the drop filter rule removes the matching data from the ingestion pipeline before it is written to NRDB. This creates an explicit demarcation between the logs being forwarded from your domain and the data that New Relic collects. Since the data removed by the drop filter rule doesn't reach our backend, it cannot be queried: the data is gone and cannot be restored. During the ingestion process, customer log data can be parsed, transformed, or dropped before being stored in New Relic's database. Cautions when dropping data When creating drop rules, you are responsible for ensuring that the rules accurately identify and discard the data that meets the conditions that you have established. You are also responsible for monitoring the rule, as well as the data you disclose to New Relic. New Relic cannot guarantee that this functionality will completely resolve data disclosure concerns you may have. New Relic doesn't review or monitor how effective the rules you develop are. Creating rules about sensitive data can leak information about what kinds of data you maintain, including the format of your data or systems (for example, through referencing email addresses or specific credit card numbers). Any user with the relevant role-based access control permissions can view and edit all information in the rules you create. Create drop filter rules To create and edit drop filters, you must have admin permissions in New Relic, or you must be a member of a role with create and edit permissions for Insights > NRQL Drop Rules. Once a drop filter rule is active, it's applied to all log events ingested from that point onwards. Rules are not applied retroactively. Logs collected before creating a rule are not filtered by that rule. Filter or query the set of logs that contain the data you want to drop. Then, from Manage Data on the left nav of the Logs UI, click Create drop filter. To create a new drop filter rule, you can use new or existing log queries. Go to one.newrelic.com > Logs. Filter or query to the specific set of logs that contain the data to be dropped. Once the query is active, from Manage Data on the left nav of the Logs UI, click Create drop filter. Recommendation: Change the drop rule's default name to a meaningful name. Choose to either drop the entire log event that matches the query or just a specific subset of attributes in the matching events. Review the log partitions where this drop rule applies. Save the drop filter rule. Manage drop filter rules via NerdGraph API If you want to manage your drop filter rules programmatically, you can use NerdGraph, our graphQL-format API, at api.newrelic.com/graphiql. For more information, see the NerdGraph tutorial to create, query, and delete your drop filter rules. Types of drop filter rules The drop filters UI prompts you to select whether to drop logs based on the query or on specific attributes. Drop log events The default type of drop filter rule is to drop logs. This option drops the entire log events that match the filter or query. When creating a rule, try to provide a specific query that only matches log data that should be dropped. Our drop filters process won't let you create drop filter rules without values in the matching query. This prevents badly formed rules from dropping all log data. Drop attributes You can specify attributes to be dropped in a log event that matches your query. At least one or more attributes must be selected. Any attribute which is selected will be dropped; all remaining attributes will be kept and stored in NRDB. Tip We recommend this method for removing fields that could contain personal identifiable information (PII) or other sensitive attributes without losing valuable monitoring data. View or delete drop filter rules To view or delete a drop filter rule: Go to one.newrelic.com > Logs. From Manage Data on the left nav of the Logs UI, click Drop filters. Click the delete icon next to the drop filter rule you want to remove. Once deleted, rules no longer filter ingested log events.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.79596,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Drop <em>data</em> with drop filter rules",
        "sections": "Drop <em>data</em> with drop filter rules",
        "tags": "<em>Log</em> <em>management</em>",
        "body": "After <em>log</em> event <em>data</em> has been shipped to New Relic, it can either be stored in our NRDB database or dropped (discarded). We can drop both <em>log</em> events and event attributes via drop filter rules. You can manage drop filter rules using our <em>Logs</em> <em>UI</em>, as explained in this document. You can also use"
      },
      "id": "603e813f28ccbc08c1eba787"
    }
  ],
  "/docs/logs/ui-data/drop-data-drop-filter-rules": [
    {
      "sections": [
        "Find data in long logs (blobs)",
        "How blobs work",
        "Tip",
        "Query your data for blobs",
        "Data retention for long logs"
      ],
      "title": "Find data in long logs (blobs)",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "413651f55060d47b3b2c3a939d9f4f576467e405",
      "image": "https://docs.newrelic.com/static/25249afab9ba5695a0764e676d14dfb3/c1b63/log-blob-query.png",
      "url": "https://docs.newrelic.com/docs/logs/ui-data/long-logs-blobs/",
      "published_at": "2021-12-04T22:05:37Z",
      "updated_at": "2021-11-14T08:46:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Extensive log data can help you troubleshoot issues. But what if an attribute in your log contains thousands of characters? How much of this data can New Relic store? And how can you find useful information in all this data? How blobs work For lengthy string values that are longer than can be stored in NRDB (4,094 characters), we store the long string in three pieces: Long log sections Description First 4,094 characters The first 4,094 characters are stored in a Log event field with the same name. So a long message value would have its first 4,094 characters stored in a message field. Next 128,000 UTF-8 bytes The next 128,000 UTF-8 bytes of the string are stored in a blob field with the name with newrelic.ext. prepended. So a long message value would have characters past the first 4,094 characters stored in a newrelic.ext.message field as a blob. The actual number of characters stored depends on the UTF-8 representation of the characters. UTF-8 represents Unicode characters as one to four bytes, so we will store anywhere between 32,000 and 128,000 characters past the first 4,094 characters. Remaining characters Any characters past 4,094 characters plus 128,000 bytes are dropped and not stored. So the long message field would be stored as: message: <first 4,094 characters as a string> newrelic.ext.message: <next 128,000 bytes as a 'blob'> Copy Tip You can search the first 4,094 characters of a string attribute. You can also create alerts for the first 4,094 characters. However, since 'blob' storage is not searchable, text beyond the first 4,094 characters is not searchable or alertable. Query your data for blobs To query for any log data in New Relic, run the following query: SELECT * FROM Log Copy To expand the blob data, run the following query, using message or any other attribute. Be sure to enclose the blob's attribute with backticks. For example: SELECT message, another-attribute, blob(`newrelic.ext.message`), blob(`newrelic.ext.another-attribute) FROM Log Copy To query extended blob data in your logs, be sure to include backticks in your attribute's blob syntax. This expands the data in the blob so you can see (but not search) it. For example, New Relic returns: { \"message\": <first 4,094 characters> \"newrelic.ext.message\": <the next 128,000 bytes as Base64> \"another-attribute\": <first 4,094 characters> \"newrelic.ext.another-attribute\": <the next 128,000 bytes as Base64> } Copy The Logs UI automatically stitches the original value back together when looking at the Log Detail View. When querying using NRQL directly, you need to manually stitch the information together by: Decoding the Base64 of the newrelic.ext. attribute value Converting the resulting UTF-8 into a string Appending that string to the first 4,094 characters in the \"main\" attribute Data retention for long logs NRDB retains your blob records for a month. If you have existing long log messages stored as LogExtendedRecord, that data will also continue to be available for a month in NRDB. After a month passes, no more new LogExtendedRecord attributes will be created. They will all be stored in NRDB as blobs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.9071,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Find <em>data</em> in long <em>logs</em> (blobs)",
        "sections": "Find <em>data</em> in long <em>logs</em> (blobs)",
        "tags": "<em>Log</em> <em>management</em>",
        "body": " other attribute. Be sure to enclose the blob&#x27;s attribute with backticks. For example: SELECT message, another-attribute, blob(`newrelic.ext.message`), blob(`newrelic.ext.another-attribute) FROM <em>Log</em> Copy To query extended blob <em>data</em> in your <em>logs</em>, be sure to include backticks in your attribute&#x27;s blob"
      },
      "id": "6150569228ccbcf314f21423"
    },
    {
      "sections": [
        "Organize data with partitions",
        "Plan your partition",
        "Important",
        "Required roles and permissions",
        "Sizing and organizing a partition",
        "Choosing a namespace",
        "Create partition rules",
        "Search data partitions",
        "Manage data partitions programatically with NerdGraph"
      ],
      "title": "Organize data with partitions",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "620ba43370a8ca4900a02cd4ccc6fefa7f5cf8d7",
      "image": "https://docs.newrelic.com/static/7815845d8068377477aa26f8571d5907/c1b63/log-partitions-crop.png",
      "url": "https://docs.newrelic.com/docs/logs/ui-data/data-partitions/",
      "published_at": "2021-12-04T22:05:01Z",
      "updated_at": "2021-11-14T07:18:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Data partitions are a way to group or organize log data for faster and more efficient querying. When a query targets a single partition, New Relic's Logs UI: Scans less unrelated data. Returns results faster. Accounts can have multiple partitions, and multiple partitions can be queried at the same time. Data partitions also allow data to be mapped to an alternative, or “secondary” namespace with a fixed 30-day retention. This is useful for maintaining compliance with privacy-centric regulations and standards like the General Data Protection Regulation (GDPR). Plan your partition Before you start creating partitions, make sure you have the right permissions and a partition plan. Important Logs are routed to partitions during the ingestion process, before data is written to NRDB. Partition rules will not affect logs that were ingested before the rule was created. Required roles and permissions Users require an Admin role to create and modify partition rules. Sizing and organizing a partition You can gain significant performance improvements with proper use of data partitions. Organizing your data into discrete partitions enables you to query them separately or all together. The goals of partitioning your data should be: Create data partitions that align with concepts in your environment or organization that are static or change infrequently (for example, by business unit, team, environment, service, etc.). Ensure each partition remains below 1 TB of daily ingest for optimal performance. Having more partitions allows for more targeted searches, but creating too many partitions can make logs hard to find and increase administrative overhead. Finding the right balance is important. We support 100 partitions maximum per account, but the optimal number for most accounts is 10 to 15 partitions. Choosing a namespace A partition’s namespace determines its retention period. We offer two retention options: Standard: The account’s default retention determined by your New Relic subscription. This is the maximum retention period available in your account and is the namespace you'll select for most of your partitions. Secondary: 30-day retention. All logs sent to a partition that's a member of the Secondary namespace will be purged on a rolling basis 30 days after having been ingested. Secondary retention is not a cost control mechanism; data is billed on ingest. Create partition rules From the left nav in the Logs UI, select Data partitions, then create a Log_ partition name with the retention namespace, optional description, and matching criteria. To create a new partition rule: Go to one.newrelic.com > Logs. From Manage Data on the left nav of the Logs UI, click Data partitions, then click Create partition rule. Define a Partition name as an alphanumeric string that begins with Log_. Add an optional description. Select the retention namespace for the partition. Set your rule's Matching criteria: Select EQUALS to target logs that match your criteria exactly, or select LIKE to apply a fuzzy match. Click the Enable Rule slider, and click Create. To view a list of data partitions: From Manage Data on the left nav of the Logs UI, click Data partitions. Search data partitions The default partition for all Logs accounts is Log. Any log that is not affected by a partition rule will be stored in the Log partition by default. You can query multiple partitions simultaneously. For best performance, select the smallest number of partitions possible. To search data partitions: From Views and Attributes on the left nav of the Logs UI, click Select partitions. Click one or more partitions you want to query, or search for a partition name. Click Query logs to search your selected partitions. Manage data partitions programatically with NerdGraph If you want to manage your data partitions programatically, you can use NerdGraph, our GraphQL-format API. This tutorial shows how to query, create, and delete data partitions using our API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.8,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Organize <em>data</em> with partitions",
        "sections": "<em>Manage</em> <em>data</em> partitions programatically with NerdGraph",
        "tags": "<em>Log</em> <em>management</em>",
        "body": "<em>Data</em> partitions are a way to group or organize <em>log</em> <em>data</em> for faster and more efficient querying. When a query targets a single partition, New Relic&#x27;s <em>Logs</em> <em>UI</em>: Scans less unrelated <em>data</em>. Returns results faster. Accounts can have multiple partitions, and multiple partitions can be queried at the same"
      },
      "id": "6087e311e7b9d2f90ba5c6a4"
    },
    {
      "sections": [
        "Built-in log parsing rules",
        "Apache",
        "Application Load Balancer",
        "Cloudfront",
        "Elastic Load Balancer",
        "Microsoft IIS",
        "Monit",
        "MySQL Error",
        "NGINX",
        "NGINX Error",
        "Route 53",
        "Syslog RFC-5424"
      ],
      "title": "Built-in log parsing rules",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "ae238defe10615c8767ea24f74b3c416190f4b49",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/ui-data/built-log-parsing-rules/",
      "published_at": "2021-12-04T22:06:50Z",
      "updated_at": "2021-11-14T07:16:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic can parse common log formats according to built-in rules, so that you don't have to create your own parsing rules. Here are the log parsing rules, their Grok patterns, and what fields are parsed. To enable built-in log parsing, see our documentation for adding the logtype attribute. To manage your parsing rules programmatically, use NerdGraph, our GraphQL-format API, at api.newrelic.com/graphiql. For more information, see the NerdGraph tutorial to create, query, and delete your parsing rules. Apache Source: logtype = 'apache' Grok: %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \\[%{HTTPDATE:timestamp}\\] \"(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})\" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer} %{QS:agent} Copy Results: clientip: The IP address of the client. verb: The HTTP verb ident: The user identity of the client making the request response: The HTTP status code of the response request: The URI and request being made httpversion: The HTTP version of the request rawrequest: The raw HTTP request if data is posted bytes: The number of bytes sent referrer: The HTTP referrer agent: The client's user agent Application Load Balancer Source: logtype = 'alb' Grok: ^%{NOTSPACE:type} %{TIMESTAMP_ISO8601:time} %{NOTSPACE:elb} %{NOTSPACE:client_ip}:%{NOTSPACE:client_port} ((%{NOTSPACE:target_ip}:%{NOTSPACE:target_port})|-) %{NOTSPACE:request_processing_time} %{NOTSPACE:target_processing_time} %{NOTSPACE:response_processing_time} %{NOTSPACE:elb_status_code} %{NOTSPACE:target_status_code} %{NOTSPACE:received_bytes} %{NOTSPACE:sent_bytes} \"%{DATA:request}\" \"%{DATA:user_agent}\" %{NOTSPACE:ssl_cipher} %{NOTSPACE:ssl_protocol} %{NOTSPACE:target_group_arn} \"%{DATA:trace_id}\" \"%{NOTSPACE:domain_name}\" \"%{NOTSPACE:chosen_cert_arn}\" %{NOTSPACE:matched_rule_priority} %{TIMESTAMP_ISO8601:request_creation_time} \"%{NOTSPACE:actions_executed}\" \"%{NOTSPACE:redirect_url}\" \"%{NOTSPACE:error_reason}\" (?:\"|)%{DATA:target_port_list}(?:\"|) (?:\"|)%{DATA:target_status_code_list}(?:\"|) \"%{NOTSPACE:classification}\" \"%{NOTSPACE:classification_reason}\" Copy Results: Field Definition type The type of request or connection. Possible values are: http: HTTP https: HTTP over SSL/TLS h2: HTTP/2 over SSL/TLS ws: WebSockets wss: WebSockets over SSL/TLS elb The resource ID of the load balancer. If you are parsing access log entries, note that resources IDs can contain forward slashes (/). client The IP address and port of the requesting client target The IP address and port of the target that processed this request. If the client didn't send a full request, the load balancer can't dispatch the request to a target, and this value is set to -. If the target is a Lambda function, this value is set to -. If the request is blocked by AWS WAF, this value is set to -, and the value of elb_status_code is set to 403. request_processing_time The total time elapsed (in seconds, with millisecond precision) from the time the load balancer received the request until the time it sent it to a target. This value is set to -1 if the load balancer can't dispatch the request to a target. This can happen if the target closes the connection before the idle timeout or if the client sends a malformed request. This value can also be set to -1 if the registered target does not respond before the idle timeout. target_processing_time The total time elapsed (in seconds, with millisecond precision) from the time the load balancer sent the request to a target until the target started to send the response headers. This value is set to -1 if the load balancer can't dispatch the request to a target. This can happen if the target closes the connection before the idle timeout or if the client sends a malformed request. This value can also be set to -1 if the registered target does not respond before the idle timeout. response_processing_time The total time elapsed (in seconds, with millisecond precision) from the time the load balancer received the response header from the target until it started to send the response to the client. This includes both the queuing time at the load balancer and the connection acquisition time from the load balancer to the client. This value is set to -1 if the load balancer can't send the request to a target. This can happen if the target closes the connection before the idle timeout or if the client sends a malformed request. elb_status_code The status code of the response from the load balancer target_status_code The status code of the response from the target. This value is recorded only if a connection was established to the target and the target sent a response. Otherwise, it is set to -. received_bytes The size of the request, in bytes, received from the client (requester). For HTTP requests, this includes the headers. For WebSockets, this is the total number of bytes received from the client on the connection. sent_bytes The size of the response, in bytes, sent to the client (requester). For HTTP requests, this includes the headers. For WebSockets, this is the total number of bytes sent to the client on the connection. method The HTTP verb of the request uri The URI the request was targeting http_version The HTTP version number of the request user_agent User-Agent string that identifies the client that originated the request, enclosed in double quotes. The string consists of one or more product identifiers, product/version. If the string is longer than 8 KB, it is truncated. ssl_cipher The SSL cipher. This value is set to - if the listener is not an HTTPS listener. ssl_protocol The SSL protocol. This value is set to - if the listener is not an HTTPS listener. target_group_arn The Amazon Resource Name (ARN) of the target group trace_id The contents of the X-Amzn-Trace-Id header, enclosed in double quotes domain_name The SNI domain provided by the client during the TLS handshake, enclosed in double quotes. This value is set to - if the client doesn't support SNI or the domain doesn't match a certificate and the default certificate is presented to the client. chosen_cert_arn The ARN of the certificate presented to the client, enclosed in double quotes. Set to session-reused if the session is reused. Set to - if the listener is not an HTTPS listener. matched_rule_priority The priority value of the rule that matched the request. If a rule matched, this is a value from 1 to 50000. If no rule matched and the default action was taken, this value is set to 0. If an error occurs during rules evaluation, it is set to -1. For any other error, it is set to -. request_creation_time The time when the load balancer received the request from the client, in ISO 8601 format. actions_executed The actions taken when processing the request, enclosed in double quotes. This value is a comma-separated list that can include the values described in actions_taken. If no action was taken, such as for a malformed request, this value is set to -. redirect_url The URL of the redirect target for the location header of the HTTP response, enclosed in double quotes. If no redirect actions were taken, this value is set to -. error_reason The error reason code, enclosed in double quotes. If the request failed, this is one of the error codes described in Error Reason Codes. If the actions taken do not include an authenticate action or the target is not a Lambda function, this value is set to -. Cloudfront Source: logtype = 'cloudfront-web' Grok: ^%{NOTSPACE:date}%{SPACE}%{NOTSPACE:time}%{SPACE}%{NOTSPACE:x_edge_location}%{SPACE}%{NOTSPACE:sc_bytes}%{SPACE}%{NOTSPACE:c_ip}%{SPACE}%{NOTSPACE:cs_method}%{SPACE}%{NOTSPACE:cs_host}%{SPACE}%{NOTSPACE:cs_uri_stem}%{SPACE}%{NOTSPACE:sc_status}%{SPACE}%{NOTSPACE:cs_referer}%{SPACE}%{NOTSPACE:cs_user_agent}%{SPACE}%{NOTSPACE:cs_uri_query}%{SPACE}%{NOTSPACE:cs_Cookie}%{SPACE}%{NOTSPACE:x_edge_result_type}%{SPACE}%{NOTSPACE:x_edge_request_id}%{SPACE}%{NOTSPACE:x_host_header}%{SPACE}%{NOTSPACE:cs_protocol}%{SPACE}%{NOTSPACE:cs_bytes}%{SPACE}%{NOTSPACE:time_taken}%{SPACE}%{NOTSPACE:x_forwarded_for}%{SPACE}%{NOTSPACE:ssl_protocol}%{SPACE}%{NOTSPACE:ssl_cipher}%{SPACE}%{NOTSPACE:x_edge_response_result_type}%{SPACE}%{NOTSPACE:cs_protocol_version}%{SPACE}%{NOTSPACE:fle_status}%{SPACE}%{NOTSPACE:fle_encrypted_fields}%{SPACE}%{NOTSPACE:c_port}%{SPACE}%{NOTSPACE:time_to_first_byte}%{SPACE}%{NOTSPACE:x_edge_detailed_result_type}%{SPACE}%{NOTSPACE:sc_content_type}%{SPACE}%{NOTSPACE:sc_content_len}%{SPACE}%{NOTSPACE:sc_range_start}%{SPACE}%{NOTSPACE:sc_range_end} Copy Results: Field Definition x_edge_location The edge location that served the request. Each edge location is identified by a three-letter code and an arbitrarily assigned number; for example, DFW3. The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.) sc_bytes The total number of bytes that CloudFront served to the viewer in response to the request, including headers; for example, 1045619. For WebSocket connections, this is the total number of bytes sent from the server to the client through the connection. c_ip The IP address of the viewer that made the request, either in IPv4 or IPv6 format. If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip is the IP address of the proxy or load balancer. See also X-Forwarded-For. cs_method The HTTP request method: DELETE, GET, HEAD, OPTIONS, PATCH, POST, or PUT. cs_host The domain name of the CloudFront distribution; for example, d111111abcdef8.cloudfront.net. cs_uri_stem The portion of the URI that identifies the path and object; for example, /images/cat.jpg. Question marks in URLs and query strings are not included. sc_status An HTTP status code; for example, 200. Status code 000 indicates the viewer closed the connection (for example, closed the browser tab) before CloudFront could respond to a request. If the viewer closes the connection after CloudFront starts to send the response, the log contains the applicable HTTP status code. cs_referer The name of the domain that originated the request. Common referrers include search engines, other websites that link directly to your objects, and your own website. cs_user_agent The value of the User-Agent header in the request. The User-Agent header identifies the source of the request, such as the type of device and browser that submitted the request, and which search engine if applicable. cs_uri_query The query string portion of the URI, if any. When a URI doesn't contain a query string, this field's value is a hyphen (-). cs_cookie The cookie header in the request, including name-value pairs and the associated attributes. If you enable cookie logging, CloudFront logs the cookies in all requests regardless of which cookies you choose to forward to the origin. If a request doesn't include a cookie header, this field's value is a hyphen (-). x_edge_result_type How CloudFront classifies the response after the last byte left the edge location. In some cases, the result type can change between the time that CloudFront is ready to send the response and the time that CloudFront has finished sending the response. x_edge_request_id An encrypted string that uniquely identifies a request. In the response header, this is x-amz-cf-id. x_host_header The value that the viewer included in the Host header for this request. This is the domain name in the request. If you're using the CloudFront domain name in your object URLs, this field contains that domain name. If you're using alternate domain names in your object URLs, such as http://example.com/logo.png, this field contains the alternate domain name, such as example.com. To use alternate domain names, you must add them to your distribution. cs_protocol The protocol that the viewer specified in the request: http, https, ws, or wss. cs_bytes The number of bytes of data that the viewer included in the request, including headers. For WebSocket connections, this is the total number of bytes sent from the client to the server on the connection. time_taken The number of seconds (to the thousandth of a second; for example, 0.002) between the time that a CloudFront edge server receives a viewer's request and the time that CloudFront writes the last byte of the response to the edge server's output queue as measured on the server. From the perspective of the viewer, the total time to get the full object will be longer than this value due to network latency and TCP buffering. x_forwarded_for If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip in field 5 is the IP address of the proxy or load balancer. In that case, this field is the IP address of the viewer that originated the request. This field contains IPv4 and IPv6 addresses as applicable. If the viewer did not use an HTTP proxy or a load balancer, the value of x_forwarded_for is a hyphen (-). ssl_protocol When cs_protocol in field 17 is https, this field contains the SSL/TLS protocol that the client and CloudFront negotiated for transmitting the request and response. Possible values include: SSLv3 TLSv1 TLSv1.1 TLSv1.2 When cs_protocol in field 17 is http, the value for this field is a hyphen (-). ssl_cipher When cs_protocol in field 17 is https, this field contains the SSL/TLS cipher that the client and CloudFront negotiated for encrypting the request and response. Possible values include: ECDHE-RSA-AES128-GCM-SHA256 ECDHE-RSA-AES128-SHA256 ECDHE-RSA-AES128-SHA ECDHE-RSA-AES256-GCM-SHA384 ECDHE-RSA-AES256-SHA384 ECDHE-RSA-AES256-SHA AES128-GCM-SHA256 AES256-GCM-SHA384 AES128-SHA256 AES256-SHA AES128-SHA DES-CBC3-SHA RC4-MD5 When cs_protocol in field 17 is http, the value for this field is a hyphen (-). x_edge_response_result_type How CloudFront classified the response just before returning the response to the viewer. Possible values include: Hit: CloudFront served the object to the viewer from the edge cache. RefreshHit: CloudFront found the object in the edge cache but it had expired, so CloudFront contacted the origin to verify that the cache has the latest version of the object. Miss: The request could not be satisfied by an object in the edge cache, so CloudFront forwarded the request to the origin server and returned the result to the viewer. LimitExceeded: The request was denied because a CloudFront limit was exceeded. CapacityExceeded: CloudFront returned a 503 error because the edge location didn't have enough capacity at the time of the request to serve the object. Error: Typically this means the request resulted in a client error (sc_status is 4xx) or a server error (sc_status is 5xx). If the value of x_edge_result_type is Error and the value of this field is not Error, the client disconnected before finishing the download. Redirect: CloudFront redirects from HTTP to HTTPS. If sc_status is 403 and you configured CloudFront to restrict the geographic distribution of your content, the request might have come from a restricted location. cs_protocol_version The HTTP version that the viewer specified in the request. Possible values include: HTTP/0.9 HTTP/1.0 HTTP/1.1 HTTP/2.0 fle_status When field-level encryption is configured for a distribution, this field contains a code that indicates whether the request body was successfully processed. If field-level encryption is not configured for the distribution, the value is a hyphen (-). fle-encrypted-fields The number of fields that CloudFront encrypted and forwarded to the origin. CloudFront streams the processed request to the origin as it encrypts data, so fle-encrypted-fields can have a value even if the value of fle-status is an error. If field-level encryption is not configured for the distribution, the value of fle-encrypted-fields is a hyphen (-). c_port The port number of the request from the viewer. time_to_first_byte The number of seconds between receiving the request and writing the first byte of the response, as measured on the server. x_edge_detailed_result_type When x-edge-result-type is not Error, this field contains the same value as x-edge-result-type. When x-edge-result-type is Error, this field contains the specific type of error. sc_content_type The value of the HTTP Content-Type header of the response. sc_content_len The value of the HTTP Content-Length header of the response. sc_range_start When the response contains the HTTP Content-Range header, this field contains the range start value. sc-range-end When the response contains the HTTP Content-Range header, this field contains the range end value. Elastic Load Balancer Source: logtype = 'elb' Grok: ^%{TIMESTAMP_ISO8601:time} %{NOTSPACE:elb} %{NOTSPACE:client_ip}:%{NOTSPACE:client_port} ((%{NOTSPACE:backend_ip}:%{NOTSPACE:backend_port})|-) %{NOTSPACE:request_processing_time} %{NOTSPACE:backend_processing_time} %{NOTSPACE:response_processing_time} %{NOTSPACE:elb_status_code} %{NOTSPACE:backend_status_code} %{NOTSPACE:received_bytes} %{NOTSPACE:sent_bytes} \"%{DATA:request}\" \"%{DATA:user_agent}\" %{NOTSPACE:ssl_cipher} %{NOTSPACE:ssl_protocol} Copy Results: Field Definition x_edge_location The edge location that served the request. Each edge location is identified by a three-letter code and an arbitrarily assigned number; for example, DFW3. The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.) sc_bytes The total number of bytes that CloudFront served to the viewer in response to the request, including headers; for example, 1045619. For WebSocket connections, this is the total number of bytes sent from the server to the client through the connection. c_ip The IP address of the viewer that made the request. If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip is the IP address of the proxy or load balancer. cs_method The HTTP request method: DELETE, GET, HEAD, OPTIONS, PATCH, POST, or PUT. cs_host The domain name of the CloudFront distribution; for example, d111111abcdef8.cloudfront.net. cs_uri_stem The portion of the URI that identifies the path and object; for example, /images/cat.jpg. Question marks (?) in URLs and query strings are not included in the log. sc_status An HTTP status code (for example, 200). Status code 000 indicates that the viewer closed the connection (for example, closed the browser tab) before CloudFront could respond to a request. If the viewer closes the connection after CloudFront starts to send the response, the log contains the applicable HTTP status code. cs_referer he name of the domain that originated the request. Common referrers include search engines, other websites that link directly to your objects, and your own website. cs_user_agent The value of the User-Agent header in the request. The User-Agent header identifies the source of the request, such as the type of device and browser that submitted the request and which search engine if applicable. cs_uri_query The query string portion of the URI, if any. When a URI doesn't contain a query string, this field's value is a hyphen (-). cs_cookie The cookie header in the request, including name-value pairs and the associated attributes. If you enable cookie logging, CloudFront logs the cookies in all requests, regardless of which cookies you choose to forward to the origin. If a request doesn't include a cookie header, this field's value is a hyphen (-). x_edge_result_type How CloudFront classifies the response after the last byte left the edge location. In some cases, the result type can change between the time that CloudFront is ready to send the response and the time that CloudFront has finished sending the response. x_edge_request_id An encrypted string that uniquely identifies a request. In the response header, this is x-amz-cf-id. x_host_header The value that the viewer included in the Host header for this request. This is the domain name in the request. If you're using the CloudFront domain name in your object URLs, this field contains that domain name. If you're using alternate domain names in your object URLs, such as [http://example.com/logo.png, this field contains the alternate domain name, such as example.com. To use alternate domain names, you must add them to your distribution. cs_protocol The protocol that the viewer specified in the request: http, https, ws, or wss. cs_bytes The number of bytes of data that the viewer included in the request, including headers. For WebSocket connections, this is the total number of bytes sent from the client to the server on the connection. time_taken The number of seconds (to the thousandth of a second; for example, 0.002) between the time that a CloudFront edge server receives a viewer's request and the time that CloudFront writes the last byte of the response to the edge server's output queue as measured on the server. From the perspective of the viewer, the total time to get the full object will be longer than this value due to network latency and TCP buffering. x_forwarded_for If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip in field 5 is the IP address of the proxy or load balancer. In that case, this field is the IP address of the viewer that originated the request. This field contains IPv4 and IPv6 addresses as applicable. If the viewer did not use an HTTP proxy or a load balancer, the value of x_forwarded_for is a hyphen (-). ssl_protocol When cs_protocol in field 17 is https, this field contains the SSL/TLS protocol that the client and CloudFront negotiated for transmitting the request and response. Possible values include: SSLv3 TLSv1 TLSv1.1 TLSv1.2 When cs_protocol in field 17 is http, the value for this field is a hyphen (-). ssl_cipher When cs_protocol in field 17 is https, this field contains the SSL/TLS cipher that the client and CloudFront negotiated for encrypting the request and response. Possible values include: ECDHE-RSA-AES128-GCM-SHA256 ECDHE-RSA-AES128-SHA256 ECDHE-RSA-AES128-SHA ECDHE-RSA-AES256-GCM-SHA384 ECDHE-RSA-AES256-SHA384 ECDHE-RSA-AES256-SHA AES128-GCM-SHA256 AES256-GCM-SHA384 AES128-SHA256 AES256-SHA AES128-SHA DES-CBC3-SHA RC4-MD5 When cs_protocol is http, the value for this field is a hyphen (-). x_edge_response_result_type How CloudFront classified the response just before returning the response to the viewer. Possible values include: Hit: CloudFront served the object to the viewer from the edge cache. RefreshHit: CloudFront found the object in the edge cache but it had expired, so CloudFront contacted the origin to verify that the cache has the latest version of the object. Miss: The request could not be satisfied by an object in the edge cache, so CloudFront forwarded the request to the origin server and returned the result to the viewer. LimitExceeded: The request was denied because a CloudFront limit was exceeded. CapacityExceeded: CloudFront returned a 503 error because the edge location didn't have enough capacity at the time of the request to serve the object. Error: Typically this means the request resulted in a client error (sc_status is 4xx) or a server error (sc_status is 5xx). If the value of x_edge_result_type is Error and the value of this field is not Error, the client disconnected before finishing the download. Redirect: CloudFront redirects from HTTP to HTTPS. If sc_status is 403 and you configured CloudFront to restrict the geographic distribution of your content, the request might have come from a restricted location. cs_protocol_version The HTTP version that the viewer specified in the request. Possible values include: HTTP/0.9 HTTP/1.0 HTTP/1.1 HTTP/2.0 fle_status When field-level encryption is configured for a distribution, this field contains a code that indicates whether the request body was successfully processed. If field-level encryption is not configured for the distribution, the value of this field is a hyphen (-). When CloudFront successfully processes the request body, encrypts values in the specified fields, and forwards the request to the origin, the value of this field is Processed. The value of x_edge_result_type can still indicate a client-side or server-side error in this case. If the request exceeds a field-level encryption limit, fle-status contains one of the following error codes, and CloudFront returns HTTP status code 400 to the viewer. fle-encrypted-fields The number of fields that CloudFront encrypted and forwarded to the origin. CloudFront streams the processed request to the origin as it encrypts data, so fle_encrypted_fields can have a value even if the value of fle_status is an error. If field-level encryption is not configured for the distribution, the value of fle_encrypted_fields is a hyphen (-). c_port The port number of the request from the viewer. time_to_first_byte The number of seconds between receiving the request and writing the first byte of the response, as measured on the server. x_edge_detailed_result_type When x_edge_result_type is not Error, this field contains the same value as x_edge_result_type. When x_edge_result_type is Error, this field contains the specific type of error. sc_content_type The value of the HTTP Content-Type header of the response. sc_content_len The value of the HTTP Content-Length header of the response. sc_range_start When the response contains the HTTP Content-Range header, this field contains the range start value. sc-range-end When the response contains the HTTP Content-Range header, this field contains the range end value. Microsoft IIS Source: logtype = 'iis_w3c' Grok: %{TIMESTAMP_ISO8601:log_timestamp} %{NOTSPACE:server_ip} %{WORD:method} %{NOTSPACE:uri} %{NOTSPACE:uri_query} %{NOTSPACE:server_port} %{NOTSPACE:username} %{NOTSPACE:client_ip} %{NOTSPACE:user_agent} %{NOTSPACE:referer} %{NOTSPACE:status} %{NOTSPACE:substatus} %{NOTSPACE:win32_status} %{NOTSPACE:time_taken} Copy Monit Source: logtype = 'monit' Grok: \\\\[%{NOTSPACE:tz} %{SYSLOGTIMESTAMP:nr_timestamp}\\\\] %{WORD:state}%{SPACE}: %{GREEDYDATA:message} Copy Results: state: The severity of the log line message: The message MySQL Error Source: logtype = 'mysql-error' Grok: \\\\[%{WORD:log_level}\\\\] Copy Results: log_level: The severity of the log line NGINX Source: logtype = 'nginx' Grok: %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \\[%{HTTPDATE:timestamp}\\] \"(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})\" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer} %{QS:agent} Copy Results: clientip: The IP address of the client verb: The HTTP verb ident: The user identity of the client making the request response: The HTTP status code of the response request: The URI and request being made httpversion: The HTTP version of the request rawrequest: The raw HTTP request if data is posted bytes: The number of bytes sent referrer: The HTTP referrer agent: The client's user agent NGINX Error Source: logtype = 'nginx-error' Grok: ^(?<timestamp>%{YEAR:year}[./-]%{MONTHNUM:month}[./-]%{MONTHDAY:day}[- ]%{TIME:time}) \\\\[%{LOGLEVEL:severity}\\\\] %{POSINT:pid}#%{NUMBER}: %{GREEDYDATA:errormessage}(?:, client: (?<client>%{IP:clientip}|%{HOSTNAME:hostname}))(?:, server: %{IPORHOSTORUNDERSCORE:server})(?:, request: %{QS:request})?(?:, upstream: \\\"%{URI:upstream}\\\")?(?:, host: %{QS:host})?(?:, referrer: \\\"%{URI:referrer}\\\")?$ Copy Results: severity: The severity of the log line pid: The server process ID errormessage: The error message clientip: The IP address of the calling client server: The server IP address request: The full request upstream: The upstream URI host: The server's hostname referrer: The HTTP referrer Route 53 Source: logtype = 'route-53' Grok: %{NUMBER:log_format_version} %{TIMESTAMP_ISO8601} %{WORD:zone_id} %{IPORHOST:query} %{WORD:query_type} %{WORD:response_code} %{WORD:protocol} %{WORD:edge_location} %{IP:resolver_ip} %{GREEDYDATA:edns_client_subnet} Copy Results: log_format_version: A versioned format for the log. zone_id: The ID of the hosted zone that is associated with all the DNS queries in this log. query: The domain or subdomain that was specified in the request. query_type: Either the DNS record type that was specified in the request, or ANY. response_code: The DNS response code that Route 53 returned in response to the DNS query. protocol: The protocol that was used to submit the query, either TCP or UDP. edge_location: The Route 53 edge location that responded to the query. Each edge location is identified by a three-letter code and an arbitrary number; for example, DFW3. The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.) resolver_ip: The IP address of the DNS resolver that submitted the request to Route 53. edns_client_subnet: A partial IP address for the client that the request originated from, if available from the DNS resolver. Syslog RFC-5424 Source: logtype = 'syslog-rfc5424' Grok: <%{NONNEGINT:pri}>%{NONNEGINT:version} +(?:%{TIMESTAMP_ISO8601:log.timestamp}|-) +(?:%{HOSTNAME:hostname}|-) +(?:\\\\-|%{NOTSPACE:app.name}) +(?:\\\\-|%{NOTSPACE:procid}) (?:\\\\-|%{NOTSPACE:msgid}) +(?:\\[%{DATA:structured.data}\\]|-|) +%{GREEDYDATA:message} Copy Results: pri: The priority represents both the message facility and severity. version: Syslog protocol version. log.timestamp: Original timestamp. hostname: The machine that originally sent the Syslog message. app.name: The device or application that originated the message. procid: The process name or process ID associated with a Syslog system. msgid: Identifies the type of message. structured.data: Structured data string value. sd.<var>sd-id</var>.<var>sd-param-name</var>: The structured.data content is also parsed into separate attributes following a predefined naming convention: sd.<var>sd-id</var>.<var>sd-param-name</var>. See the structured data parsing examples, which follow. message: Free-form message that provides information about the event. Structured data parsing examples: The structured data [example one=\"1\" two=\"2\"] would be parsed into two different attributes: sd.example.one: \"1\" sd.example.two: \"2\" Copy If the same structured data block contains duplicate param names, it also appends an index-based suffix on the attribute name. For example, the structured data [example number=\"1\" number=\"2\"] would be parsed as: sd.example.number.0: \"1\" sd.example.number.1: \"2\" Copy For structured data with enterprise numbers assigned, an extra attribute is also parsed. For example, the structured data [example@123 number=\"1\"] would be parsed as: sd.example.enterprise.number: 123 sd.example.number: \"1\" Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.797,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Built-in <em>log</em> parsing rules",
        "sections": "Built-in <em>log</em> parsing rules",
        "tags": "<em>Log</em> <em>management</em>",
        "body": " RFC-5424 Source: logtype = &#x27;syslog-rfc5424&#x27; Grok: &lt;%{NONNEGINT:pri}&gt;%{NONNEGINT:version} +(?:%{TIMESTAMP_ISO8601:<em>log</em>.timestamp}|-) +(?:%{HOSTNAME:hostname}|-) +(?:\\\\-|%{NOTSPACE:app.name}) +(?:\\\\-|%{NOTSPACE:procid}) (?:\\\\-|%{NOTSPACE:msgid}) +(?:\\[%{<em>DATA:structured.data</em>}\\]|-|) +%{GREEDYDATA:message"
      },
      "id": "603e7b9164441f1b2d4e8872"
    }
  ],
  "/docs/logs/ui-data/find-unusual-logs-log-patterns": [
    {
      "sections": [
        "Find data in long logs (blobs)",
        "How blobs work",
        "Tip",
        "Query your data for blobs",
        "Data retention for long logs"
      ],
      "title": "Find data in long logs (blobs)",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "413651f55060d47b3b2c3a939d9f4f576467e405",
      "image": "https://docs.newrelic.com/static/25249afab9ba5695a0764e676d14dfb3/c1b63/log-blob-query.png",
      "url": "https://docs.newrelic.com/docs/logs/ui-data/long-logs-blobs/",
      "published_at": "2021-12-04T22:05:37Z",
      "updated_at": "2021-11-14T08:46:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Extensive log data can help you troubleshoot issues. But what if an attribute in your log contains thousands of characters? How much of this data can New Relic store? And how can you find useful information in all this data? How blobs work For lengthy string values that are longer than can be stored in NRDB (4,094 characters), we store the long string in three pieces: Long log sections Description First 4,094 characters The first 4,094 characters are stored in a Log event field with the same name. So a long message value would have its first 4,094 characters stored in a message field. Next 128,000 UTF-8 bytes The next 128,000 UTF-8 bytes of the string are stored in a blob field with the name with newrelic.ext. prepended. So a long message value would have characters past the first 4,094 characters stored in a newrelic.ext.message field as a blob. The actual number of characters stored depends on the UTF-8 representation of the characters. UTF-8 represents Unicode characters as one to four bytes, so we will store anywhere between 32,000 and 128,000 characters past the first 4,094 characters. Remaining characters Any characters past 4,094 characters plus 128,000 bytes are dropped and not stored. So the long message field would be stored as: message: <first 4,094 characters as a string> newrelic.ext.message: <next 128,000 bytes as a 'blob'> Copy Tip You can search the first 4,094 characters of a string attribute. You can also create alerts for the first 4,094 characters. However, since 'blob' storage is not searchable, text beyond the first 4,094 characters is not searchable or alertable. Query your data for blobs To query for any log data in New Relic, run the following query: SELECT * FROM Log Copy To expand the blob data, run the following query, using message or any other attribute. Be sure to enclose the blob's attribute with backticks. For example: SELECT message, another-attribute, blob(`newrelic.ext.message`), blob(`newrelic.ext.another-attribute) FROM Log Copy To query extended blob data in your logs, be sure to include backticks in your attribute's blob syntax. This expands the data in the blob so you can see (but not search) it. For example, New Relic returns: { \"message\": <first 4,094 characters> \"newrelic.ext.message\": <the next 128,000 bytes as Base64> \"another-attribute\": <first 4,094 characters> \"newrelic.ext.another-attribute\": <the next 128,000 bytes as Base64> } Copy The Logs UI automatically stitches the original value back together when looking at the Log Detail View. When querying using NRQL directly, you need to manually stitch the information together by: Decoding the Base64 of the newrelic.ext. attribute value Converting the resulting UTF-8 into a string Appending that string to the first 4,094 characters in the \"main\" attribute Data retention for long logs NRDB retains your blob records for a month. If you have existing long log messages stored as LogExtendedRecord, that data will also continue to be available for a month in NRDB. After a month passes, no more new LogExtendedRecord attributes will be created. They will all be stored in NRDB as blobs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.9071,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Find <em>data</em> in long <em>logs</em> (blobs)",
        "sections": "Find <em>data</em> in long <em>logs</em> (blobs)",
        "tags": "<em>Log</em> <em>management</em>",
        "body": " other attribute. Be sure to enclose the blob&#x27;s attribute with backticks. For example: SELECT message, another-attribute, blob(`newrelic.ext.message`), blob(`newrelic.ext.another-attribute) FROM <em>Log</em> Copy To query extended blob <em>data</em> in your <em>logs</em>, be sure to include backticks in your attribute&#x27;s blob"
      },
      "id": "6150569228ccbcf314f21423"
    },
    {
      "sections": [
        "Organize data with partitions",
        "Plan your partition",
        "Important",
        "Required roles and permissions",
        "Sizing and organizing a partition",
        "Choosing a namespace",
        "Create partition rules",
        "Search data partitions",
        "Manage data partitions programatically with NerdGraph"
      ],
      "title": "Organize data with partitions",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "620ba43370a8ca4900a02cd4ccc6fefa7f5cf8d7",
      "image": "https://docs.newrelic.com/static/7815845d8068377477aa26f8571d5907/c1b63/log-partitions-crop.png",
      "url": "https://docs.newrelic.com/docs/logs/ui-data/data-partitions/",
      "published_at": "2021-12-04T22:05:01Z",
      "updated_at": "2021-11-14T07:18:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Data partitions are a way to group or organize log data for faster and more efficient querying. When a query targets a single partition, New Relic's Logs UI: Scans less unrelated data. Returns results faster. Accounts can have multiple partitions, and multiple partitions can be queried at the same time. Data partitions also allow data to be mapped to an alternative, or “secondary” namespace with a fixed 30-day retention. This is useful for maintaining compliance with privacy-centric regulations and standards like the General Data Protection Regulation (GDPR). Plan your partition Before you start creating partitions, make sure you have the right permissions and a partition plan. Important Logs are routed to partitions during the ingestion process, before data is written to NRDB. Partition rules will not affect logs that were ingested before the rule was created. Required roles and permissions Users require an Admin role to create and modify partition rules. Sizing and organizing a partition You can gain significant performance improvements with proper use of data partitions. Organizing your data into discrete partitions enables you to query them separately or all together. The goals of partitioning your data should be: Create data partitions that align with concepts in your environment or organization that are static or change infrequently (for example, by business unit, team, environment, service, etc.). Ensure each partition remains below 1 TB of daily ingest for optimal performance. Having more partitions allows for more targeted searches, but creating too many partitions can make logs hard to find and increase administrative overhead. Finding the right balance is important. We support 100 partitions maximum per account, but the optimal number for most accounts is 10 to 15 partitions. Choosing a namespace A partition’s namespace determines its retention period. We offer two retention options: Standard: The account’s default retention determined by your New Relic subscription. This is the maximum retention period available in your account and is the namespace you'll select for most of your partitions. Secondary: 30-day retention. All logs sent to a partition that's a member of the Secondary namespace will be purged on a rolling basis 30 days after having been ingested. Secondary retention is not a cost control mechanism; data is billed on ingest. Create partition rules From the left nav in the Logs UI, select Data partitions, then create a Log_ partition name with the retention namespace, optional description, and matching criteria. To create a new partition rule: Go to one.newrelic.com > Logs. From Manage Data on the left nav of the Logs UI, click Data partitions, then click Create partition rule. Define a Partition name as an alphanumeric string that begins with Log_. Add an optional description. Select the retention namespace for the partition. Set your rule's Matching criteria: Select EQUALS to target logs that match your criteria exactly, or select LIKE to apply a fuzzy match. Click the Enable Rule slider, and click Create. To view a list of data partitions: From Manage Data on the left nav of the Logs UI, click Data partitions. Search data partitions The default partition for all Logs accounts is Log. Any log that is not affected by a partition rule will be stored in the Log partition by default. You can query multiple partitions simultaneously. For best performance, select the smallest number of partitions possible. To search data partitions: From Views and Attributes on the left nav of the Logs UI, click Select partitions. Click one or more partitions you want to query, or search for a partition name. Click Query logs to search your selected partitions. Manage data partitions programatically with NerdGraph If you want to manage your data partitions programatically, you can use NerdGraph, our GraphQL-format API. This tutorial shows how to query, create, and delete data partitions using our API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.8,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Organize <em>data</em> with partitions",
        "sections": "<em>Manage</em> <em>data</em> partitions programatically with NerdGraph",
        "tags": "<em>Log</em> <em>management</em>",
        "body": "<em>Data</em> partitions are a way to group or organize <em>log</em> <em>data</em> for faster and more efficient querying. When a query targets a single partition, New Relic&#x27;s <em>Logs</em> <em>UI</em>: Scans less unrelated <em>data</em>. Returns results faster. Accounts can have multiple partitions, and multiple partitions can be queried at the same"
      },
      "id": "6087e311e7b9d2f90ba5c6a4"
    },
    {
      "sections": [
        "Built-in log parsing rules",
        "Apache",
        "Application Load Balancer",
        "Cloudfront",
        "Elastic Load Balancer",
        "Microsoft IIS",
        "Monit",
        "MySQL Error",
        "NGINX",
        "NGINX Error",
        "Route 53",
        "Syslog RFC-5424"
      ],
      "title": "Built-in log parsing rules",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "ae238defe10615c8767ea24f74b3c416190f4b49",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/ui-data/built-log-parsing-rules/",
      "published_at": "2021-12-04T22:06:50Z",
      "updated_at": "2021-11-14T07:16:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic can parse common log formats according to built-in rules, so that you don't have to create your own parsing rules. Here are the log parsing rules, their Grok patterns, and what fields are parsed. To enable built-in log parsing, see our documentation for adding the logtype attribute. To manage your parsing rules programmatically, use NerdGraph, our GraphQL-format API, at api.newrelic.com/graphiql. For more information, see the NerdGraph tutorial to create, query, and delete your parsing rules. Apache Source: logtype = 'apache' Grok: %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \\[%{HTTPDATE:timestamp}\\] \"(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})\" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer} %{QS:agent} Copy Results: clientip: The IP address of the client. verb: The HTTP verb ident: The user identity of the client making the request response: The HTTP status code of the response request: The URI and request being made httpversion: The HTTP version of the request rawrequest: The raw HTTP request if data is posted bytes: The number of bytes sent referrer: The HTTP referrer agent: The client's user agent Application Load Balancer Source: logtype = 'alb' Grok: ^%{NOTSPACE:type} %{TIMESTAMP_ISO8601:time} %{NOTSPACE:elb} %{NOTSPACE:client_ip}:%{NOTSPACE:client_port} ((%{NOTSPACE:target_ip}:%{NOTSPACE:target_port})|-) %{NOTSPACE:request_processing_time} %{NOTSPACE:target_processing_time} %{NOTSPACE:response_processing_time} %{NOTSPACE:elb_status_code} %{NOTSPACE:target_status_code} %{NOTSPACE:received_bytes} %{NOTSPACE:sent_bytes} \"%{DATA:request}\" \"%{DATA:user_agent}\" %{NOTSPACE:ssl_cipher} %{NOTSPACE:ssl_protocol} %{NOTSPACE:target_group_arn} \"%{DATA:trace_id}\" \"%{NOTSPACE:domain_name}\" \"%{NOTSPACE:chosen_cert_arn}\" %{NOTSPACE:matched_rule_priority} %{TIMESTAMP_ISO8601:request_creation_time} \"%{NOTSPACE:actions_executed}\" \"%{NOTSPACE:redirect_url}\" \"%{NOTSPACE:error_reason}\" (?:\"|)%{DATA:target_port_list}(?:\"|) (?:\"|)%{DATA:target_status_code_list}(?:\"|) \"%{NOTSPACE:classification}\" \"%{NOTSPACE:classification_reason}\" Copy Results: Field Definition type The type of request or connection. Possible values are: http: HTTP https: HTTP over SSL/TLS h2: HTTP/2 over SSL/TLS ws: WebSockets wss: WebSockets over SSL/TLS elb The resource ID of the load balancer. If you are parsing access log entries, note that resources IDs can contain forward slashes (/). client The IP address and port of the requesting client target The IP address and port of the target that processed this request. If the client didn't send a full request, the load balancer can't dispatch the request to a target, and this value is set to -. If the target is a Lambda function, this value is set to -. If the request is blocked by AWS WAF, this value is set to -, and the value of elb_status_code is set to 403. request_processing_time The total time elapsed (in seconds, with millisecond precision) from the time the load balancer received the request until the time it sent it to a target. This value is set to -1 if the load balancer can't dispatch the request to a target. This can happen if the target closes the connection before the idle timeout or if the client sends a malformed request. This value can also be set to -1 if the registered target does not respond before the idle timeout. target_processing_time The total time elapsed (in seconds, with millisecond precision) from the time the load balancer sent the request to a target until the target started to send the response headers. This value is set to -1 if the load balancer can't dispatch the request to a target. This can happen if the target closes the connection before the idle timeout or if the client sends a malformed request. This value can also be set to -1 if the registered target does not respond before the idle timeout. response_processing_time The total time elapsed (in seconds, with millisecond precision) from the time the load balancer received the response header from the target until it started to send the response to the client. This includes both the queuing time at the load balancer and the connection acquisition time from the load balancer to the client. This value is set to -1 if the load balancer can't send the request to a target. This can happen if the target closes the connection before the idle timeout or if the client sends a malformed request. elb_status_code The status code of the response from the load balancer target_status_code The status code of the response from the target. This value is recorded only if a connection was established to the target and the target sent a response. Otherwise, it is set to -. received_bytes The size of the request, in bytes, received from the client (requester). For HTTP requests, this includes the headers. For WebSockets, this is the total number of bytes received from the client on the connection. sent_bytes The size of the response, in bytes, sent to the client (requester). For HTTP requests, this includes the headers. For WebSockets, this is the total number of bytes sent to the client on the connection. method The HTTP verb of the request uri The URI the request was targeting http_version The HTTP version number of the request user_agent User-Agent string that identifies the client that originated the request, enclosed in double quotes. The string consists of one or more product identifiers, product/version. If the string is longer than 8 KB, it is truncated. ssl_cipher The SSL cipher. This value is set to - if the listener is not an HTTPS listener. ssl_protocol The SSL protocol. This value is set to - if the listener is not an HTTPS listener. target_group_arn The Amazon Resource Name (ARN) of the target group trace_id The contents of the X-Amzn-Trace-Id header, enclosed in double quotes domain_name The SNI domain provided by the client during the TLS handshake, enclosed in double quotes. This value is set to - if the client doesn't support SNI or the domain doesn't match a certificate and the default certificate is presented to the client. chosen_cert_arn The ARN of the certificate presented to the client, enclosed in double quotes. Set to session-reused if the session is reused. Set to - if the listener is not an HTTPS listener. matched_rule_priority The priority value of the rule that matched the request. If a rule matched, this is a value from 1 to 50000. If no rule matched and the default action was taken, this value is set to 0. If an error occurs during rules evaluation, it is set to -1. For any other error, it is set to -. request_creation_time The time when the load balancer received the request from the client, in ISO 8601 format. actions_executed The actions taken when processing the request, enclosed in double quotes. This value is a comma-separated list that can include the values described in actions_taken. If no action was taken, such as for a malformed request, this value is set to -. redirect_url The URL of the redirect target for the location header of the HTTP response, enclosed in double quotes. If no redirect actions were taken, this value is set to -. error_reason The error reason code, enclosed in double quotes. If the request failed, this is one of the error codes described in Error Reason Codes. If the actions taken do not include an authenticate action or the target is not a Lambda function, this value is set to -. Cloudfront Source: logtype = 'cloudfront-web' Grok: ^%{NOTSPACE:date}%{SPACE}%{NOTSPACE:time}%{SPACE}%{NOTSPACE:x_edge_location}%{SPACE}%{NOTSPACE:sc_bytes}%{SPACE}%{NOTSPACE:c_ip}%{SPACE}%{NOTSPACE:cs_method}%{SPACE}%{NOTSPACE:cs_host}%{SPACE}%{NOTSPACE:cs_uri_stem}%{SPACE}%{NOTSPACE:sc_status}%{SPACE}%{NOTSPACE:cs_referer}%{SPACE}%{NOTSPACE:cs_user_agent}%{SPACE}%{NOTSPACE:cs_uri_query}%{SPACE}%{NOTSPACE:cs_Cookie}%{SPACE}%{NOTSPACE:x_edge_result_type}%{SPACE}%{NOTSPACE:x_edge_request_id}%{SPACE}%{NOTSPACE:x_host_header}%{SPACE}%{NOTSPACE:cs_protocol}%{SPACE}%{NOTSPACE:cs_bytes}%{SPACE}%{NOTSPACE:time_taken}%{SPACE}%{NOTSPACE:x_forwarded_for}%{SPACE}%{NOTSPACE:ssl_protocol}%{SPACE}%{NOTSPACE:ssl_cipher}%{SPACE}%{NOTSPACE:x_edge_response_result_type}%{SPACE}%{NOTSPACE:cs_protocol_version}%{SPACE}%{NOTSPACE:fle_status}%{SPACE}%{NOTSPACE:fle_encrypted_fields}%{SPACE}%{NOTSPACE:c_port}%{SPACE}%{NOTSPACE:time_to_first_byte}%{SPACE}%{NOTSPACE:x_edge_detailed_result_type}%{SPACE}%{NOTSPACE:sc_content_type}%{SPACE}%{NOTSPACE:sc_content_len}%{SPACE}%{NOTSPACE:sc_range_start}%{SPACE}%{NOTSPACE:sc_range_end} Copy Results: Field Definition x_edge_location The edge location that served the request. Each edge location is identified by a three-letter code and an arbitrarily assigned number; for example, DFW3. The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.) sc_bytes The total number of bytes that CloudFront served to the viewer in response to the request, including headers; for example, 1045619. For WebSocket connections, this is the total number of bytes sent from the server to the client through the connection. c_ip The IP address of the viewer that made the request, either in IPv4 or IPv6 format. If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip is the IP address of the proxy or load balancer. See also X-Forwarded-For. cs_method The HTTP request method: DELETE, GET, HEAD, OPTIONS, PATCH, POST, or PUT. cs_host The domain name of the CloudFront distribution; for example, d111111abcdef8.cloudfront.net. cs_uri_stem The portion of the URI that identifies the path and object; for example, /images/cat.jpg. Question marks in URLs and query strings are not included. sc_status An HTTP status code; for example, 200. Status code 000 indicates the viewer closed the connection (for example, closed the browser tab) before CloudFront could respond to a request. If the viewer closes the connection after CloudFront starts to send the response, the log contains the applicable HTTP status code. cs_referer The name of the domain that originated the request. Common referrers include search engines, other websites that link directly to your objects, and your own website. cs_user_agent The value of the User-Agent header in the request. The User-Agent header identifies the source of the request, such as the type of device and browser that submitted the request, and which search engine if applicable. cs_uri_query The query string portion of the URI, if any. When a URI doesn't contain a query string, this field's value is a hyphen (-). cs_cookie The cookie header in the request, including name-value pairs and the associated attributes. If you enable cookie logging, CloudFront logs the cookies in all requests regardless of which cookies you choose to forward to the origin. If a request doesn't include a cookie header, this field's value is a hyphen (-). x_edge_result_type How CloudFront classifies the response after the last byte left the edge location. In some cases, the result type can change between the time that CloudFront is ready to send the response and the time that CloudFront has finished sending the response. x_edge_request_id An encrypted string that uniquely identifies a request. In the response header, this is x-amz-cf-id. x_host_header The value that the viewer included in the Host header for this request. This is the domain name in the request. If you're using the CloudFront domain name in your object URLs, this field contains that domain name. If you're using alternate domain names in your object URLs, such as http://example.com/logo.png, this field contains the alternate domain name, such as example.com. To use alternate domain names, you must add them to your distribution. cs_protocol The protocol that the viewer specified in the request: http, https, ws, or wss. cs_bytes The number of bytes of data that the viewer included in the request, including headers. For WebSocket connections, this is the total number of bytes sent from the client to the server on the connection. time_taken The number of seconds (to the thousandth of a second; for example, 0.002) between the time that a CloudFront edge server receives a viewer's request and the time that CloudFront writes the last byte of the response to the edge server's output queue as measured on the server. From the perspective of the viewer, the total time to get the full object will be longer than this value due to network latency and TCP buffering. x_forwarded_for If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip in field 5 is the IP address of the proxy or load balancer. In that case, this field is the IP address of the viewer that originated the request. This field contains IPv4 and IPv6 addresses as applicable. If the viewer did not use an HTTP proxy or a load balancer, the value of x_forwarded_for is a hyphen (-). ssl_protocol When cs_protocol in field 17 is https, this field contains the SSL/TLS protocol that the client and CloudFront negotiated for transmitting the request and response. Possible values include: SSLv3 TLSv1 TLSv1.1 TLSv1.2 When cs_protocol in field 17 is http, the value for this field is a hyphen (-). ssl_cipher When cs_protocol in field 17 is https, this field contains the SSL/TLS cipher that the client and CloudFront negotiated for encrypting the request and response. Possible values include: ECDHE-RSA-AES128-GCM-SHA256 ECDHE-RSA-AES128-SHA256 ECDHE-RSA-AES128-SHA ECDHE-RSA-AES256-GCM-SHA384 ECDHE-RSA-AES256-SHA384 ECDHE-RSA-AES256-SHA AES128-GCM-SHA256 AES256-GCM-SHA384 AES128-SHA256 AES256-SHA AES128-SHA DES-CBC3-SHA RC4-MD5 When cs_protocol in field 17 is http, the value for this field is a hyphen (-). x_edge_response_result_type How CloudFront classified the response just before returning the response to the viewer. Possible values include: Hit: CloudFront served the object to the viewer from the edge cache. RefreshHit: CloudFront found the object in the edge cache but it had expired, so CloudFront contacted the origin to verify that the cache has the latest version of the object. Miss: The request could not be satisfied by an object in the edge cache, so CloudFront forwarded the request to the origin server and returned the result to the viewer. LimitExceeded: The request was denied because a CloudFront limit was exceeded. CapacityExceeded: CloudFront returned a 503 error because the edge location didn't have enough capacity at the time of the request to serve the object. Error: Typically this means the request resulted in a client error (sc_status is 4xx) or a server error (sc_status is 5xx). If the value of x_edge_result_type is Error and the value of this field is not Error, the client disconnected before finishing the download. Redirect: CloudFront redirects from HTTP to HTTPS. If sc_status is 403 and you configured CloudFront to restrict the geographic distribution of your content, the request might have come from a restricted location. cs_protocol_version The HTTP version that the viewer specified in the request. Possible values include: HTTP/0.9 HTTP/1.0 HTTP/1.1 HTTP/2.0 fle_status When field-level encryption is configured for a distribution, this field contains a code that indicates whether the request body was successfully processed. If field-level encryption is not configured for the distribution, the value is a hyphen (-). fle-encrypted-fields The number of fields that CloudFront encrypted and forwarded to the origin. CloudFront streams the processed request to the origin as it encrypts data, so fle-encrypted-fields can have a value even if the value of fle-status is an error. If field-level encryption is not configured for the distribution, the value of fle-encrypted-fields is a hyphen (-). c_port The port number of the request from the viewer. time_to_first_byte The number of seconds between receiving the request and writing the first byte of the response, as measured on the server. x_edge_detailed_result_type When x-edge-result-type is not Error, this field contains the same value as x-edge-result-type. When x-edge-result-type is Error, this field contains the specific type of error. sc_content_type The value of the HTTP Content-Type header of the response. sc_content_len The value of the HTTP Content-Length header of the response. sc_range_start When the response contains the HTTP Content-Range header, this field contains the range start value. sc-range-end When the response contains the HTTP Content-Range header, this field contains the range end value. Elastic Load Balancer Source: logtype = 'elb' Grok: ^%{TIMESTAMP_ISO8601:time} %{NOTSPACE:elb} %{NOTSPACE:client_ip}:%{NOTSPACE:client_port} ((%{NOTSPACE:backend_ip}:%{NOTSPACE:backend_port})|-) %{NOTSPACE:request_processing_time} %{NOTSPACE:backend_processing_time} %{NOTSPACE:response_processing_time} %{NOTSPACE:elb_status_code} %{NOTSPACE:backend_status_code} %{NOTSPACE:received_bytes} %{NOTSPACE:sent_bytes} \"%{DATA:request}\" \"%{DATA:user_agent}\" %{NOTSPACE:ssl_cipher} %{NOTSPACE:ssl_protocol} Copy Results: Field Definition x_edge_location The edge location that served the request. Each edge location is identified by a three-letter code and an arbitrarily assigned number; for example, DFW3. The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.) sc_bytes The total number of bytes that CloudFront served to the viewer in response to the request, including headers; for example, 1045619. For WebSocket connections, this is the total number of bytes sent from the server to the client through the connection. c_ip The IP address of the viewer that made the request. If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip is the IP address of the proxy or load balancer. cs_method The HTTP request method: DELETE, GET, HEAD, OPTIONS, PATCH, POST, or PUT. cs_host The domain name of the CloudFront distribution; for example, d111111abcdef8.cloudfront.net. cs_uri_stem The portion of the URI that identifies the path and object; for example, /images/cat.jpg. Question marks (?) in URLs and query strings are not included in the log. sc_status An HTTP status code (for example, 200). Status code 000 indicates that the viewer closed the connection (for example, closed the browser tab) before CloudFront could respond to a request. If the viewer closes the connection after CloudFront starts to send the response, the log contains the applicable HTTP status code. cs_referer he name of the domain that originated the request. Common referrers include search engines, other websites that link directly to your objects, and your own website. cs_user_agent The value of the User-Agent header in the request. The User-Agent header identifies the source of the request, such as the type of device and browser that submitted the request and which search engine if applicable. cs_uri_query The query string portion of the URI, if any. When a URI doesn't contain a query string, this field's value is a hyphen (-). cs_cookie The cookie header in the request, including name-value pairs and the associated attributes. If you enable cookie logging, CloudFront logs the cookies in all requests, regardless of which cookies you choose to forward to the origin. If a request doesn't include a cookie header, this field's value is a hyphen (-). x_edge_result_type How CloudFront classifies the response after the last byte left the edge location. In some cases, the result type can change between the time that CloudFront is ready to send the response and the time that CloudFront has finished sending the response. x_edge_request_id An encrypted string that uniquely identifies a request. In the response header, this is x-amz-cf-id. x_host_header The value that the viewer included in the Host header for this request. This is the domain name in the request. If you're using the CloudFront domain name in your object URLs, this field contains that domain name. If you're using alternate domain names in your object URLs, such as [http://example.com/logo.png, this field contains the alternate domain name, such as example.com. To use alternate domain names, you must add them to your distribution. cs_protocol The protocol that the viewer specified in the request: http, https, ws, or wss. cs_bytes The number of bytes of data that the viewer included in the request, including headers. For WebSocket connections, this is the total number of bytes sent from the client to the server on the connection. time_taken The number of seconds (to the thousandth of a second; for example, 0.002) between the time that a CloudFront edge server receives a viewer's request and the time that CloudFront writes the last byte of the response to the edge server's output queue as measured on the server. From the perspective of the viewer, the total time to get the full object will be longer than this value due to network latency and TCP buffering. x_forwarded_for If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip in field 5 is the IP address of the proxy or load balancer. In that case, this field is the IP address of the viewer that originated the request. This field contains IPv4 and IPv6 addresses as applicable. If the viewer did not use an HTTP proxy or a load balancer, the value of x_forwarded_for is a hyphen (-). ssl_protocol When cs_protocol in field 17 is https, this field contains the SSL/TLS protocol that the client and CloudFront negotiated for transmitting the request and response. Possible values include: SSLv3 TLSv1 TLSv1.1 TLSv1.2 When cs_protocol in field 17 is http, the value for this field is a hyphen (-). ssl_cipher When cs_protocol in field 17 is https, this field contains the SSL/TLS cipher that the client and CloudFront negotiated for encrypting the request and response. Possible values include: ECDHE-RSA-AES128-GCM-SHA256 ECDHE-RSA-AES128-SHA256 ECDHE-RSA-AES128-SHA ECDHE-RSA-AES256-GCM-SHA384 ECDHE-RSA-AES256-SHA384 ECDHE-RSA-AES256-SHA AES128-GCM-SHA256 AES256-GCM-SHA384 AES128-SHA256 AES256-SHA AES128-SHA DES-CBC3-SHA RC4-MD5 When cs_protocol is http, the value for this field is a hyphen (-). x_edge_response_result_type How CloudFront classified the response just before returning the response to the viewer. Possible values include: Hit: CloudFront served the object to the viewer from the edge cache. RefreshHit: CloudFront found the object in the edge cache but it had expired, so CloudFront contacted the origin to verify that the cache has the latest version of the object. Miss: The request could not be satisfied by an object in the edge cache, so CloudFront forwarded the request to the origin server and returned the result to the viewer. LimitExceeded: The request was denied because a CloudFront limit was exceeded. CapacityExceeded: CloudFront returned a 503 error because the edge location didn't have enough capacity at the time of the request to serve the object. Error: Typically this means the request resulted in a client error (sc_status is 4xx) or a server error (sc_status is 5xx). If the value of x_edge_result_type is Error and the value of this field is not Error, the client disconnected before finishing the download. Redirect: CloudFront redirects from HTTP to HTTPS. If sc_status is 403 and you configured CloudFront to restrict the geographic distribution of your content, the request might have come from a restricted location. cs_protocol_version The HTTP version that the viewer specified in the request. Possible values include: HTTP/0.9 HTTP/1.0 HTTP/1.1 HTTP/2.0 fle_status When field-level encryption is configured for a distribution, this field contains a code that indicates whether the request body was successfully processed. If field-level encryption is not configured for the distribution, the value of this field is a hyphen (-). When CloudFront successfully processes the request body, encrypts values in the specified fields, and forwards the request to the origin, the value of this field is Processed. The value of x_edge_result_type can still indicate a client-side or server-side error in this case. If the request exceeds a field-level encryption limit, fle-status contains one of the following error codes, and CloudFront returns HTTP status code 400 to the viewer. fle-encrypted-fields The number of fields that CloudFront encrypted and forwarded to the origin. CloudFront streams the processed request to the origin as it encrypts data, so fle_encrypted_fields can have a value even if the value of fle_status is an error. If field-level encryption is not configured for the distribution, the value of fle_encrypted_fields is a hyphen (-). c_port The port number of the request from the viewer. time_to_first_byte The number of seconds between receiving the request and writing the first byte of the response, as measured on the server. x_edge_detailed_result_type When x_edge_result_type is not Error, this field contains the same value as x_edge_result_type. When x_edge_result_type is Error, this field contains the specific type of error. sc_content_type The value of the HTTP Content-Type header of the response. sc_content_len The value of the HTTP Content-Length header of the response. sc_range_start When the response contains the HTTP Content-Range header, this field contains the range start value. sc-range-end When the response contains the HTTP Content-Range header, this field contains the range end value. Microsoft IIS Source: logtype = 'iis_w3c' Grok: %{TIMESTAMP_ISO8601:log_timestamp} %{NOTSPACE:server_ip} %{WORD:method} %{NOTSPACE:uri} %{NOTSPACE:uri_query} %{NOTSPACE:server_port} %{NOTSPACE:username} %{NOTSPACE:client_ip} %{NOTSPACE:user_agent} %{NOTSPACE:referer} %{NOTSPACE:status} %{NOTSPACE:substatus} %{NOTSPACE:win32_status} %{NOTSPACE:time_taken} Copy Monit Source: logtype = 'monit' Grok: \\\\[%{NOTSPACE:tz} %{SYSLOGTIMESTAMP:nr_timestamp}\\\\] %{WORD:state}%{SPACE}: %{GREEDYDATA:message} Copy Results: state: The severity of the log line message: The message MySQL Error Source: logtype = 'mysql-error' Grok: \\\\[%{WORD:log_level}\\\\] Copy Results: log_level: The severity of the log line NGINX Source: logtype = 'nginx' Grok: %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \\[%{HTTPDATE:timestamp}\\] \"(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})\" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer} %{QS:agent} Copy Results: clientip: The IP address of the client verb: The HTTP verb ident: The user identity of the client making the request response: The HTTP status code of the response request: The URI and request being made httpversion: The HTTP version of the request rawrequest: The raw HTTP request if data is posted bytes: The number of bytes sent referrer: The HTTP referrer agent: The client's user agent NGINX Error Source: logtype = 'nginx-error' Grok: ^(?<timestamp>%{YEAR:year}[./-]%{MONTHNUM:month}[./-]%{MONTHDAY:day}[- ]%{TIME:time}) \\\\[%{LOGLEVEL:severity}\\\\] %{POSINT:pid}#%{NUMBER}: %{GREEDYDATA:errormessage}(?:, client: (?<client>%{IP:clientip}|%{HOSTNAME:hostname}))(?:, server: %{IPORHOSTORUNDERSCORE:server})(?:, request: %{QS:request})?(?:, upstream: \\\"%{URI:upstream}\\\")?(?:, host: %{QS:host})?(?:, referrer: \\\"%{URI:referrer}\\\")?$ Copy Results: severity: The severity of the log line pid: The server process ID errormessage: The error message clientip: The IP address of the calling client server: The server IP address request: The full request upstream: The upstream URI host: The server's hostname referrer: The HTTP referrer Route 53 Source: logtype = 'route-53' Grok: %{NUMBER:log_format_version} %{TIMESTAMP_ISO8601} %{WORD:zone_id} %{IPORHOST:query} %{WORD:query_type} %{WORD:response_code} %{WORD:protocol} %{WORD:edge_location} %{IP:resolver_ip} %{GREEDYDATA:edns_client_subnet} Copy Results: log_format_version: A versioned format for the log. zone_id: The ID of the hosted zone that is associated with all the DNS queries in this log. query: The domain or subdomain that was specified in the request. query_type: Either the DNS record type that was specified in the request, or ANY. response_code: The DNS response code that Route 53 returned in response to the DNS query. protocol: The protocol that was used to submit the query, either TCP or UDP. edge_location: The Route 53 edge location that responded to the query. Each edge location is identified by a three-letter code and an arbitrary number; for example, DFW3. The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.) resolver_ip: The IP address of the DNS resolver that submitted the request to Route 53. edns_client_subnet: A partial IP address for the client that the request originated from, if available from the DNS resolver. Syslog RFC-5424 Source: logtype = 'syslog-rfc5424' Grok: <%{NONNEGINT:pri}>%{NONNEGINT:version} +(?:%{TIMESTAMP_ISO8601:log.timestamp}|-) +(?:%{HOSTNAME:hostname}|-) +(?:\\\\-|%{NOTSPACE:app.name}) +(?:\\\\-|%{NOTSPACE:procid}) (?:\\\\-|%{NOTSPACE:msgid}) +(?:\\[%{DATA:structured.data}\\]|-|) +%{GREEDYDATA:message} Copy Results: pri: The priority represents both the message facility and severity. version: Syslog protocol version. log.timestamp: Original timestamp. hostname: The machine that originally sent the Syslog message. app.name: The device or application that originated the message. procid: The process name or process ID associated with a Syslog system. msgid: Identifies the type of message. structured.data: Structured data string value. sd.<var>sd-id</var>.<var>sd-param-name</var>: The structured.data content is also parsed into separate attributes following a predefined naming convention: sd.<var>sd-id</var>.<var>sd-param-name</var>. See the structured data parsing examples, which follow. message: Free-form message that provides information about the event. Structured data parsing examples: The structured data [example one=\"1\" two=\"2\"] would be parsed into two different attributes: sd.example.one: \"1\" sd.example.two: \"2\" Copy If the same structured data block contains duplicate param names, it also appends an index-based suffix on the attribute name. For example, the structured data [example number=\"1\" number=\"2\"] would be parsed as: sd.example.number.0: \"1\" sd.example.number.1: \"2\" Copy For structured data with enterprise numbers assigned, an extra attribute is also parsed. For example, the structured data [example@123 number=\"1\"] would be parsed as: sd.example.enterprise.number: 123 sd.example.number: \"1\" Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.797,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Built-in <em>log</em> parsing rules",
        "sections": "Built-in <em>log</em> parsing rules",
        "tags": "<em>Log</em> <em>management</em>",
        "body": " RFC-5424 Source: logtype = &#x27;syslog-rfc5424&#x27; Grok: &lt;%{NONNEGINT:pri}&gt;%{NONNEGINT:version} +(?:%{TIMESTAMP_ISO8601:<em>log</em>.timestamp}|-) +(?:%{HOSTNAME:hostname}|-) +(?:\\\\-|%{NOTSPACE:app.name}) +(?:\\\\-|%{NOTSPACE:procid}) (?:\\\\-|%{NOTSPACE:msgid}) +(?:\\[%{<em>DATA:structured.data</em>}\\]|-|) +%{GREEDYDATA:message"
      },
      "id": "603e7b9164441f1b2d4e8872"
    }
  ],
  "/docs/logs/ui-data/long-logs-blobs": [
    {
      "sections": [
        "Organize data with partitions",
        "Plan your partition",
        "Important",
        "Required roles and permissions",
        "Sizing and organizing a partition",
        "Choosing a namespace",
        "Create partition rules",
        "Search data partitions",
        "Manage data partitions programatically with NerdGraph"
      ],
      "title": "Organize data with partitions",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "620ba43370a8ca4900a02cd4ccc6fefa7f5cf8d7",
      "image": "https://docs.newrelic.com/static/7815845d8068377477aa26f8571d5907/c1b63/log-partitions-crop.png",
      "url": "https://docs.newrelic.com/docs/logs/ui-data/data-partitions/",
      "published_at": "2021-12-04T22:05:01Z",
      "updated_at": "2021-11-14T07:18:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Data partitions are a way to group or organize log data for faster and more efficient querying. When a query targets a single partition, New Relic's Logs UI: Scans less unrelated data. Returns results faster. Accounts can have multiple partitions, and multiple partitions can be queried at the same time. Data partitions also allow data to be mapped to an alternative, or “secondary” namespace with a fixed 30-day retention. This is useful for maintaining compliance with privacy-centric regulations and standards like the General Data Protection Regulation (GDPR). Plan your partition Before you start creating partitions, make sure you have the right permissions and a partition plan. Important Logs are routed to partitions during the ingestion process, before data is written to NRDB. Partition rules will not affect logs that were ingested before the rule was created. Required roles and permissions Users require an Admin role to create and modify partition rules. Sizing and organizing a partition You can gain significant performance improvements with proper use of data partitions. Organizing your data into discrete partitions enables you to query them separately or all together. The goals of partitioning your data should be: Create data partitions that align with concepts in your environment or organization that are static or change infrequently (for example, by business unit, team, environment, service, etc.). Ensure each partition remains below 1 TB of daily ingest for optimal performance. Having more partitions allows for more targeted searches, but creating too many partitions can make logs hard to find and increase administrative overhead. Finding the right balance is important. We support 100 partitions maximum per account, but the optimal number for most accounts is 10 to 15 partitions. Choosing a namespace A partition’s namespace determines its retention period. We offer two retention options: Standard: The account’s default retention determined by your New Relic subscription. This is the maximum retention period available in your account and is the namespace you'll select for most of your partitions. Secondary: 30-day retention. All logs sent to a partition that's a member of the Secondary namespace will be purged on a rolling basis 30 days after having been ingested. Secondary retention is not a cost control mechanism; data is billed on ingest. Create partition rules From the left nav in the Logs UI, select Data partitions, then create a Log_ partition name with the retention namespace, optional description, and matching criteria. To create a new partition rule: Go to one.newrelic.com > Logs. From Manage Data on the left nav of the Logs UI, click Data partitions, then click Create partition rule. Define a Partition name as an alphanumeric string that begins with Log_. Add an optional description. Select the retention namespace for the partition. Set your rule's Matching criteria: Select EQUALS to target logs that match your criteria exactly, or select LIKE to apply a fuzzy match. Click the Enable Rule slider, and click Create. To view a list of data partitions: From Manage Data on the left nav of the Logs UI, click Data partitions. Search data partitions The default partition for all Logs accounts is Log. Any log that is not affected by a partition rule will be stored in the Log partition by default. You can query multiple partitions simultaneously. For best performance, select the smallest number of partitions possible. To search data partitions: From Views and Attributes on the left nav of the Logs UI, click Select partitions. Click one or more partitions you want to query, or search for a partition name. Click Query logs to search your selected partitions. Manage data partitions programatically with NerdGraph If you want to manage your data partitions programatically, you can use NerdGraph, our GraphQL-format API. This tutorial shows how to query, create, and delete data partitions using our API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.79999,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Organize <em>data</em> with partitions",
        "sections": "<em>Manage</em> <em>data</em> partitions programatically with NerdGraph",
        "tags": "<em>Log</em> <em>management</em>",
        "body": "<em>Data</em> partitions are a way to group or organize <em>log</em> <em>data</em> for faster and more efficient querying. When a query targets a single partition, New Relic&#x27;s <em>Logs</em> <em>UI</em>: Scans less unrelated <em>data</em>. Returns results faster. Accounts can have multiple partitions, and multiple partitions can be queried at the same"
      },
      "id": "6087e311e7b9d2f90ba5c6a4"
    },
    {
      "sections": [
        "Built-in log parsing rules",
        "Apache",
        "Application Load Balancer",
        "Cloudfront",
        "Elastic Load Balancer",
        "Microsoft IIS",
        "Monit",
        "MySQL Error",
        "NGINX",
        "NGINX Error",
        "Route 53",
        "Syslog RFC-5424"
      ],
      "title": "Built-in log parsing rules",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "ae238defe10615c8767ea24f74b3c416190f4b49",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/ui-data/built-log-parsing-rules/",
      "published_at": "2021-12-04T22:06:50Z",
      "updated_at": "2021-11-14T07:16:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic can parse common log formats according to built-in rules, so that you don't have to create your own parsing rules. Here are the log parsing rules, their Grok patterns, and what fields are parsed. To enable built-in log parsing, see our documentation for adding the logtype attribute. To manage your parsing rules programmatically, use NerdGraph, our GraphQL-format API, at api.newrelic.com/graphiql. For more information, see the NerdGraph tutorial to create, query, and delete your parsing rules. Apache Source: logtype = 'apache' Grok: %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \\[%{HTTPDATE:timestamp}\\] \"(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})\" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer} %{QS:agent} Copy Results: clientip: The IP address of the client. verb: The HTTP verb ident: The user identity of the client making the request response: The HTTP status code of the response request: The URI and request being made httpversion: The HTTP version of the request rawrequest: The raw HTTP request if data is posted bytes: The number of bytes sent referrer: The HTTP referrer agent: The client's user agent Application Load Balancer Source: logtype = 'alb' Grok: ^%{NOTSPACE:type} %{TIMESTAMP_ISO8601:time} %{NOTSPACE:elb} %{NOTSPACE:client_ip}:%{NOTSPACE:client_port} ((%{NOTSPACE:target_ip}:%{NOTSPACE:target_port})|-) %{NOTSPACE:request_processing_time} %{NOTSPACE:target_processing_time} %{NOTSPACE:response_processing_time} %{NOTSPACE:elb_status_code} %{NOTSPACE:target_status_code} %{NOTSPACE:received_bytes} %{NOTSPACE:sent_bytes} \"%{DATA:request}\" \"%{DATA:user_agent}\" %{NOTSPACE:ssl_cipher} %{NOTSPACE:ssl_protocol} %{NOTSPACE:target_group_arn} \"%{DATA:trace_id}\" \"%{NOTSPACE:domain_name}\" \"%{NOTSPACE:chosen_cert_arn}\" %{NOTSPACE:matched_rule_priority} %{TIMESTAMP_ISO8601:request_creation_time} \"%{NOTSPACE:actions_executed}\" \"%{NOTSPACE:redirect_url}\" \"%{NOTSPACE:error_reason}\" (?:\"|)%{DATA:target_port_list}(?:\"|) (?:\"|)%{DATA:target_status_code_list}(?:\"|) \"%{NOTSPACE:classification}\" \"%{NOTSPACE:classification_reason}\" Copy Results: Field Definition type The type of request or connection. Possible values are: http: HTTP https: HTTP over SSL/TLS h2: HTTP/2 over SSL/TLS ws: WebSockets wss: WebSockets over SSL/TLS elb The resource ID of the load balancer. If you are parsing access log entries, note that resources IDs can contain forward slashes (/). client The IP address and port of the requesting client target The IP address and port of the target that processed this request. If the client didn't send a full request, the load balancer can't dispatch the request to a target, and this value is set to -. If the target is a Lambda function, this value is set to -. If the request is blocked by AWS WAF, this value is set to -, and the value of elb_status_code is set to 403. request_processing_time The total time elapsed (in seconds, with millisecond precision) from the time the load balancer received the request until the time it sent it to a target. This value is set to -1 if the load balancer can't dispatch the request to a target. This can happen if the target closes the connection before the idle timeout or if the client sends a malformed request. This value can also be set to -1 if the registered target does not respond before the idle timeout. target_processing_time The total time elapsed (in seconds, with millisecond precision) from the time the load balancer sent the request to a target until the target started to send the response headers. This value is set to -1 if the load balancer can't dispatch the request to a target. This can happen if the target closes the connection before the idle timeout or if the client sends a malformed request. This value can also be set to -1 if the registered target does not respond before the idle timeout. response_processing_time The total time elapsed (in seconds, with millisecond precision) from the time the load balancer received the response header from the target until it started to send the response to the client. This includes both the queuing time at the load balancer and the connection acquisition time from the load balancer to the client. This value is set to -1 if the load balancer can't send the request to a target. This can happen if the target closes the connection before the idle timeout or if the client sends a malformed request. elb_status_code The status code of the response from the load balancer target_status_code The status code of the response from the target. This value is recorded only if a connection was established to the target and the target sent a response. Otherwise, it is set to -. received_bytes The size of the request, in bytes, received from the client (requester). For HTTP requests, this includes the headers. For WebSockets, this is the total number of bytes received from the client on the connection. sent_bytes The size of the response, in bytes, sent to the client (requester). For HTTP requests, this includes the headers. For WebSockets, this is the total number of bytes sent to the client on the connection. method The HTTP verb of the request uri The URI the request was targeting http_version The HTTP version number of the request user_agent User-Agent string that identifies the client that originated the request, enclosed in double quotes. The string consists of one or more product identifiers, product/version. If the string is longer than 8 KB, it is truncated. ssl_cipher The SSL cipher. This value is set to - if the listener is not an HTTPS listener. ssl_protocol The SSL protocol. This value is set to - if the listener is not an HTTPS listener. target_group_arn The Amazon Resource Name (ARN) of the target group trace_id The contents of the X-Amzn-Trace-Id header, enclosed in double quotes domain_name The SNI domain provided by the client during the TLS handshake, enclosed in double quotes. This value is set to - if the client doesn't support SNI or the domain doesn't match a certificate and the default certificate is presented to the client. chosen_cert_arn The ARN of the certificate presented to the client, enclosed in double quotes. Set to session-reused if the session is reused. Set to - if the listener is not an HTTPS listener. matched_rule_priority The priority value of the rule that matched the request. If a rule matched, this is a value from 1 to 50000. If no rule matched and the default action was taken, this value is set to 0. If an error occurs during rules evaluation, it is set to -1. For any other error, it is set to -. request_creation_time The time when the load balancer received the request from the client, in ISO 8601 format. actions_executed The actions taken when processing the request, enclosed in double quotes. This value is a comma-separated list that can include the values described in actions_taken. If no action was taken, such as for a malformed request, this value is set to -. redirect_url The URL of the redirect target for the location header of the HTTP response, enclosed in double quotes. If no redirect actions were taken, this value is set to -. error_reason The error reason code, enclosed in double quotes. If the request failed, this is one of the error codes described in Error Reason Codes. If the actions taken do not include an authenticate action or the target is not a Lambda function, this value is set to -. Cloudfront Source: logtype = 'cloudfront-web' Grok: ^%{NOTSPACE:date}%{SPACE}%{NOTSPACE:time}%{SPACE}%{NOTSPACE:x_edge_location}%{SPACE}%{NOTSPACE:sc_bytes}%{SPACE}%{NOTSPACE:c_ip}%{SPACE}%{NOTSPACE:cs_method}%{SPACE}%{NOTSPACE:cs_host}%{SPACE}%{NOTSPACE:cs_uri_stem}%{SPACE}%{NOTSPACE:sc_status}%{SPACE}%{NOTSPACE:cs_referer}%{SPACE}%{NOTSPACE:cs_user_agent}%{SPACE}%{NOTSPACE:cs_uri_query}%{SPACE}%{NOTSPACE:cs_Cookie}%{SPACE}%{NOTSPACE:x_edge_result_type}%{SPACE}%{NOTSPACE:x_edge_request_id}%{SPACE}%{NOTSPACE:x_host_header}%{SPACE}%{NOTSPACE:cs_protocol}%{SPACE}%{NOTSPACE:cs_bytes}%{SPACE}%{NOTSPACE:time_taken}%{SPACE}%{NOTSPACE:x_forwarded_for}%{SPACE}%{NOTSPACE:ssl_protocol}%{SPACE}%{NOTSPACE:ssl_cipher}%{SPACE}%{NOTSPACE:x_edge_response_result_type}%{SPACE}%{NOTSPACE:cs_protocol_version}%{SPACE}%{NOTSPACE:fle_status}%{SPACE}%{NOTSPACE:fle_encrypted_fields}%{SPACE}%{NOTSPACE:c_port}%{SPACE}%{NOTSPACE:time_to_first_byte}%{SPACE}%{NOTSPACE:x_edge_detailed_result_type}%{SPACE}%{NOTSPACE:sc_content_type}%{SPACE}%{NOTSPACE:sc_content_len}%{SPACE}%{NOTSPACE:sc_range_start}%{SPACE}%{NOTSPACE:sc_range_end} Copy Results: Field Definition x_edge_location The edge location that served the request. Each edge location is identified by a three-letter code and an arbitrarily assigned number; for example, DFW3. The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.) sc_bytes The total number of bytes that CloudFront served to the viewer in response to the request, including headers; for example, 1045619. For WebSocket connections, this is the total number of bytes sent from the server to the client through the connection. c_ip The IP address of the viewer that made the request, either in IPv4 or IPv6 format. If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip is the IP address of the proxy or load balancer. See also X-Forwarded-For. cs_method The HTTP request method: DELETE, GET, HEAD, OPTIONS, PATCH, POST, or PUT. cs_host The domain name of the CloudFront distribution; for example, d111111abcdef8.cloudfront.net. cs_uri_stem The portion of the URI that identifies the path and object; for example, /images/cat.jpg. Question marks in URLs and query strings are not included. sc_status An HTTP status code; for example, 200. Status code 000 indicates the viewer closed the connection (for example, closed the browser tab) before CloudFront could respond to a request. If the viewer closes the connection after CloudFront starts to send the response, the log contains the applicable HTTP status code. cs_referer The name of the domain that originated the request. Common referrers include search engines, other websites that link directly to your objects, and your own website. cs_user_agent The value of the User-Agent header in the request. The User-Agent header identifies the source of the request, such as the type of device and browser that submitted the request, and which search engine if applicable. cs_uri_query The query string portion of the URI, if any. When a URI doesn't contain a query string, this field's value is a hyphen (-). cs_cookie The cookie header in the request, including name-value pairs and the associated attributes. If you enable cookie logging, CloudFront logs the cookies in all requests regardless of which cookies you choose to forward to the origin. If a request doesn't include a cookie header, this field's value is a hyphen (-). x_edge_result_type How CloudFront classifies the response after the last byte left the edge location. In some cases, the result type can change between the time that CloudFront is ready to send the response and the time that CloudFront has finished sending the response. x_edge_request_id An encrypted string that uniquely identifies a request. In the response header, this is x-amz-cf-id. x_host_header The value that the viewer included in the Host header for this request. This is the domain name in the request. If you're using the CloudFront domain name in your object URLs, this field contains that domain name. If you're using alternate domain names in your object URLs, such as http://example.com/logo.png, this field contains the alternate domain name, such as example.com. To use alternate domain names, you must add them to your distribution. cs_protocol The protocol that the viewer specified in the request: http, https, ws, or wss. cs_bytes The number of bytes of data that the viewer included in the request, including headers. For WebSocket connections, this is the total number of bytes sent from the client to the server on the connection. time_taken The number of seconds (to the thousandth of a second; for example, 0.002) between the time that a CloudFront edge server receives a viewer's request and the time that CloudFront writes the last byte of the response to the edge server's output queue as measured on the server. From the perspective of the viewer, the total time to get the full object will be longer than this value due to network latency and TCP buffering. x_forwarded_for If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip in field 5 is the IP address of the proxy or load balancer. In that case, this field is the IP address of the viewer that originated the request. This field contains IPv4 and IPv6 addresses as applicable. If the viewer did not use an HTTP proxy or a load balancer, the value of x_forwarded_for is a hyphen (-). ssl_protocol When cs_protocol in field 17 is https, this field contains the SSL/TLS protocol that the client and CloudFront negotiated for transmitting the request and response. Possible values include: SSLv3 TLSv1 TLSv1.1 TLSv1.2 When cs_protocol in field 17 is http, the value for this field is a hyphen (-). ssl_cipher When cs_protocol in field 17 is https, this field contains the SSL/TLS cipher that the client and CloudFront negotiated for encrypting the request and response. Possible values include: ECDHE-RSA-AES128-GCM-SHA256 ECDHE-RSA-AES128-SHA256 ECDHE-RSA-AES128-SHA ECDHE-RSA-AES256-GCM-SHA384 ECDHE-RSA-AES256-SHA384 ECDHE-RSA-AES256-SHA AES128-GCM-SHA256 AES256-GCM-SHA384 AES128-SHA256 AES256-SHA AES128-SHA DES-CBC3-SHA RC4-MD5 When cs_protocol in field 17 is http, the value for this field is a hyphen (-). x_edge_response_result_type How CloudFront classified the response just before returning the response to the viewer. Possible values include: Hit: CloudFront served the object to the viewer from the edge cache. RefreshHit: CloudFront found the object in the edge cache but it had expired, so CloudFront contacted the origin to verify that the cache has the latest version of the object. Miss: The request could not be satisfied by an object in the edge cache, so CloudFront forwarded the request to the origin server and returned the result to the viewer. LimitExceeded: The request was denied because a CloudFront limit was exceeded. CapacityExceeded: CloudFront returned a 503 error because the edge location didn't have enough capacity at the time of the request to serve the object. Error: Typically this means the request resulted in a client error (sc_status is 4xx) or a server error (sc_status is 5xx). If the value of x_edge_result_type is Error and the value of this field is not Error, the client disconnected before finishing the download. Redirect: CloudFront redirects from HTTP to HTTPS. If sc_status is 403 and you configured CloudFront to restrict the geographic distribution of your content, the request might have come from a restricted location. cs_protocol_version The HTTP version that the viewer specified in the request. Possible values include: HTTP/0.9 HTTP/1.0 HTTP/1.1 HTTP/2.0 fle_status When field-level encryption is configured for a distribution, this field contains a code that indicates whether the request body was successfully processed. If field-level encryption is not configured for the distribution, the value is a hyphen (-). fle-encrypted-fields The number of fields that CloudFront encrypted and forwarded to the origin. CloudFront streams the processed request to the origin as it encrypts data, so fle-encrypted-fields can have a value even if the value of fle-status is an error. If field-level encryption is not configured for the distribution, the value of fle-encrypted-fields is a hyphen (-). c_port The port number of the request from the viewer. time_to_first_byte The number of seconds between receiving the request and writing the first byte of the response, as measured on the server. x_edge_detailed_result_type When x-edge-result-type is not Error, this field contains the same value as x-edge-result-type. When x-edge-result-type is Error, this field contains the specific type of error. sc_content_type The value of the HTTP Content-Type header of the response. sc_content_len The value of the HTTP Content-Length header of the response. sc_range_start When the response contains the HTTP Content-Range header, this field contains the range start value. sc-range-end When the response contains the HTTP Content-Range header, this field contains the range end value. Elastic Load Balancer Source: logtype = 'elb' Grok: ^%{TIMESTAMP_ISO8601:time} %{NOTSPACE:elb} %{NOTSPACE:client_ip}:%{NOTSPACE:client_port} ((%{NOTSPACE:backend_ip}:%{NOTSPACE:backend_port})|-) %{NOTSPACE:request_processing_time} %{NOTSPACE:backend_processing_time} %{NOTSPACE:response_processing_time} %{NOTSPACE:elb_status_code} %{NOTSPACE:backend_status_code} %{NOTSPACE:received_bytes} %{NOTSPACE:sent_bytes} \"%{DATA:request}\" \"%{DATA:user_agent}\" %{NOTSPACE:ssl_cipher} %{NOTSPACE:ssl_protocol} Copy Results: Field Definition x_edge_location The edge location that served the request. Each edge location is identified by a three-letter code and an arbitrarily assigned number; for example, DFW3. The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.) sc_bytes The total number of bytes that CloudFront served to the viewer in response to the request, including headers; for example, 1045619. For WebSocket connections, this is the total number of bytes sent from the server to the client through the connection. c_ip The IP address of the viewer that made the request. If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip is the IP address of the proxy or load balancer. cs_method The HTTP request method: DELETE, GET, HEAD, OPTIONS, PATCH, POST, or PUT. cs_host The domain name of the CloudFront distribution; for example, d111111abcdef8.cloudfront.net. cs_uri_stem The portion of the URI that identifies the path and object; for example, /images/cat.jpg. Question marks (?) in URLs and query strings are not included in the log. sc_status An HTTP status code (for example, 200). Status code 000 indicates that the viewer closed the connection (for example, closed the browser tab) before CloudFront could respond to a request. If the viewer closes the connection after CloudFront starts to send the response, the log contains the applicable HTTP status code. cs_referer he name of the domain that originated the request. Common referrers include search engines, other websites that link directly to your objects, and your own website. cs_user_agent The value of the User-Agent header in the request. The User-Agent header identifies the source of the request, such as the type of device and browser that submitted the request and which search engine if applicable. cs_uri_query The query string portion of the URI, if any. When a URI doesn't contain a query string, this field's value is a hyphen (-). cs_cookie The cookie header in the request, including name-value pairs and the associated attributes. If you enable cookie logging, CloudFront logs the cookies in all requests, regardless of which cookies you choose to forward to the origin. If a request doesn't include a cookie header, this field's value is a hyphen (-). x_edge_result_type How CloudFront classifies the response after the last byte left the edge location. In some cases, the result type can change between the time that CloudFront is ready to send the response and the time that CloudFront has finished sending the response. x_edge_request_id An encrypted string that uniquely identifies a request. In the response header, this is x-amz-cf-id. x_host_header The value that the viewer included in the Host header for this request. This is the domain name in the request. If you're using the CloudFront domain name in your object URLs, this field contains that domain name. If you're using alternate domain names in your object URLs, such as [http://example.com/logo.png, this field contains the alternate domain name, such as example.com. To use alternate domain names, you must add them to your distribution. cs_protocol The protocol that the viewer specified in the request: http, https, ws, or wss. cs_bytes The number of bytes of data that the viewer included in the request, including headers. For WebSocket connections, this is the total number of bytes sent from the client to the server on the connection. time_taken The number of seconds (to the thousandth of a second; for example, 0.002) between the time that a CloudFront edge server receives a viewer's request and the time that CloudFront writes the last byte of the response to the edge server's output queue as measured on the server. From the perspective of the viewer, the total time to get the full object will be longer than this value due to network latency and TCP buffering. x_forwarded_for If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip in field 5 is the IP address of the proxy or load balancer. In that case, this field is the IP address of the viewer that originated the request. This field contains IPv4 and IPv6 addresses as applicable. If the viewer did not use an HTTP proxy or a load balancer, the value of x_forwarded_for is a hyphen (-). ssl_protocol When cs_protocol in field 17 is https, this field contains the SSL/TLS protocol that the client and CloudFront negotiated for transmitting the request and response. Possible values include: SSLv3 TLSv1 TLSv1.1 TLSv1.2 When cs_protocol in field 17 is http, the value for this field is a hyphen (-). ssl_cipher When cs_protocol in field 17 is https, this field contains the SSL/TLS cipher that the client and CloudFront negotiated for encrypting the request and response. Possible values include: ECDHE-RSA-AES128-GCM-SHA256 ECDHE-RSA-AES128-SHA256 ECDHE-RSA-AES128-SHA ECDHE-RSA-AES256-GCM-SHA384 ECDHE-RSA-AES256-SHA384 ECDHE-RSA-AES256-SHA AES128-GCM-SHA256 AES256-GCM-SHA384 AES128-SHA256 AES256-SHA AES128-SHA DES-CBC3-SHA RC4-MD5 When cs_protocol is http, the value for this field is a hyphen (-). x_edge_response_result_type How CloudFront classified the response just before returning the response to the viewer. Possible values include: Hit: CloudFront served the object to the viewer from the edge cache. RefreshHit: CloudFront found the object in the edge cache but it had expired, so CloudFront contacted the origin to verify that the cache has the latest version of the object. Miss: The request could not be satisfied by an object in the edge cache, so CloudFront forwarded the request to the origin server and returned the result to the viewer. LimitExceeded: The request was denied because a CloudFront limit was exceeded. CapacityExceeded: CloudFront returned a 503 error because the edge location didn't have enough capacity at the time of the request to serve the object. Error: Typically this means the request resulted in a client error (sc_status is 4xx) or a server error (sc_status is 5xx). If the value of x_edge_result_type is Error and the value of this field is not Error, the client disconnected before finishing the download. Redirect: CloudFront redirects from HTTP to HTTPS. If sc_status is 403 and you configured CloudFront to restrict the geographic distribution of your content, the request might have come from a restricted location. cs_protocol_version The HTTP version that the viewer specified in the request. Possible values include: HTTP/0.9 HTTP/1.0 HTTP/1.1 HTTP/2.0 fle_status When field-level encryption is configured for a distribution, this field contains a code that indicates whether the request body was successfully processed. If field-level encryption is not configured for the distribution, the value of this field is a hyphen (-). When CloudFront successfully processes the request body, encrypts values in the specified fields, and forwards the request to the origin, the value of this field is Processed. The value of x_edge_result_type can still indicate a client-side or server-side error in this case. If the request exceeds a field-level encryption limit, fle-status contains one of the following error codes, and CloudFront returns HTTP status code 400 to the viewer. fle-encrypted-fields The number of fields that CloudFront encrypted and forwarded to the origin. CloudFront streams the processed request to the origin as it encrypts data, so fle_encrypted_fields can have a value even if the value of fle_status is an error. If field-level encryption is not configured for the distribution, the value of fle_encrypted_fields is a hyphen (-). c_port The port number of the request from the viewer. time_to_first_byte The number of seconds between receiving the request and writing the first byte of the response, as measured on the server. x_edge_detailed_result_type When x_edge_result_type is not Error, this field contains the same value as x_edge_result_type. When x_edge_result_type is Error, this field contains the specific type of error. sc_content_type The value of the HTTP Content-Type header of the response. sc_content_len The value of the HTTP Content-Length header of the response. sc_range_start When the response contains the HTTP Content-Range header, this field contains the range start value. sc-range-end When the response contains the HTTP Content-Range header, this field contains the range end value. Microsoft IIS Source: logtype = 'iis_w3c' Grok: %{TIMESTAMP_ISO8601:log_timestamp} %{NOTSPACE:server_ip} %{WORD:method} %{NOTSPACE:uri} %{NOTSPACE:uri_query} %{NOTSPACE:server_port} %{NOTSPACE:username} %{NOTSPACE:client_ip} %{NOTSPACE:user_agent} %{NOTSPACE:referer} %{NOTSPACE:status} %{NOTSPACE:substatus} %{NOTSPACE:win32_status} %{NOTSPACE:time_taken} Copy Monit Source: logtype = 'monit' Grok: \\\\[%{NOTSPACE:tz} %{SYSLOGTIMESTAMP:nr_timestamp}\\\\] %{WORD:state}%{SPACE}: %{GREEDYDATA:message} Copy Results: state: The severity of the log line message: The message MySQL Error Source: logtype = 'mysql-error' Grok: \\\\[%{WORD:log_level}\\\\] Copy Results: log_level: The severity of the log line NGINX Source: logtype = 'nginx' Grok: %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \\[%{HTTPDATE:timestamp}\\] \"(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})\" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer} %{QS:agent} Copy Results: clientip: The IP address of the client verb: The HTTP verb ident: The user identity of the client making the request response: The HTTP status code of the response request: The URI and request being made httpversion: The HTTP version of the request rawrequest: The raw HTTP request if data is posted bytes: The number of bytes sent referrer: The HTTP referrer agent: The client's user agent NGINX Error Source: logtype = 'nginx-error' Grok: ^(?<timestamp>%{YEAR:year}[./-]%{MONTHNUM:month}[./-]%{MONTHDAY:day}[- ]%{TIME:time}) \\\\[%{LOGLEVEL:severity}\\\\] %{POSINT:pid}#%{NUMBER}: %{GREEDYDATA:errormessage}(?:, client: (?<client>%{IP:clientip}|%{HOSTNAME:hostname}))(?:, server: %{IPORHOSTORUNDERSCORE:server})(?:, request: %{QS:request})?(?:, upstream: \\\"%{URI:upstream}\\\")?(?:, host: %{QS:host})?(?:, referrer: \\\"%{URI:referrer}\\\")?$ Copy Results: severity: The severity of the log line pid: The server process ID errormessage: The error message clientip: The IP address of the calling client server: The server IP address request: The full request upstream: The upstream URI host: The server's hostname referrer: The HTTP referrer Route 53 Source: logtype = 'route-53' Grok: %{NUMBER:log_format_version} %{TIMESTAMP_ISO8601} %{WORD:zone_id} %{IPORHOST:query} %{WORD:query_type} %{WORD:response_code} %{WORD:protocol} %{WORD:edge_location} %{IP:resolver_ip} %{GREEDYDATA:edns_client_subnet} Copy Results: log_format_version: A versioned format for the log. zone_id: The ID of the hosted zone that is associated with all the DNS queries in this log. query: The domain or subdomain that was specified in the request. query_type: Either the DNS record type that was specified in the request, or ANY. response_code: The DNS response code that Route 53 returned in response to the DNS query. protocol: The protocol that was used to submit the query, either TCP or UDP. edge_location: The Route 53 edge location that responded to the query. Each edge location is identified by a three-letter code and an arbitrary number; for example, DFW3. The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.) resolver_ip: The IP address of the DNS resolver that submitted the request to Route 53. edns_client_subnet: A partial IP address for the client that the request originated from, if available from the DNS resolver. Syslog RFC-5424 Source: logtype = 'syslog-rfc5424' Grok: <%{NONNEGINT:pri}>%{NONNEGINT:version} +(?:%{TIMESTAMP_ISO8601:log.timestamp}|-) +(?:%{HOSTNAME:hostname}|-) +(?:\\\\-|%{NOTSPACE:app.name}) +(?:\\\\-|%{NOTSPACE:procid}) (?:\\\\-|%{NOTSPACE:msgid}) +(?:\\[%{DATA:structured.data}\\]|-|) +%{GREEDYDATA:message} Copy Results: pri: The priority represents both the message facility and severity. version: Syslog protocol version. log.timestamp: Original timestamp. hostname: The machine that originally sent the Syslog message. app.name: The device or application that originated the message. procid: The process name or process ID associated with a Syslog system. msgid: Identifies the type of message. structured.data: Structured data string value. sd.<var>sd-id</var>.<var>sd-param-name</var>: The structured.data content is also parsed into separate attributes following a predefined naming convention: sd.<var>sd-id</var>.<var>sd-param-name</var>. See the structured data parsing examples, which follow. message: Free-form message that provides information about the event. Structured data parsing examples: The structured data [example one=\"1\" two=\"2\"] would be parsed into two different attributes: sd.example.one: \"1\" sd.example.two: \"2\" Copy If the same structured data block contains duplicate param names, it also appends an index-based suffix on the attribute name. For example, the structured data [example number=\"1\" number=\"2\"] would be parsed as: sd.example.number.0: \"1\" sd.example.number.1: \"2\" Copy For structured data with enterprise numbers assigned, an extra attribute is also parsed. For example, the structured data [example@123 number=\"1\"] would be parsed as: sd.example.enterprise.number: 123 sd.example.number: \"1\" Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.79698,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Built-in <em>log</em> parsing rules",
        "sections": "Built-in <em>log</em> parsing rules",
        "tags": "<em>Log</em> <em>management</em>",
        "body": " RFC-5424 Source: logtype = &#x27;syslog-rfc5424&#x27; Grok: &lt;%{NONNEGINT:pri}&gt;%{NONNEGINT:version} +(?:%{TIMESTAMP_ISO8601:<em>log</em>.timestamp}|-) +(?:%{HOSTNAME:hostname}|-) +(?:\\\\-|%{NOTSPACE:app.name}) +(?:\\\\-|%{NOTSPACE:procid}) (?:\\\\-|%{NOTSPACE:msgid}) +(?:\\[%{<em>DATA:structured.data</em>}\\]|-|) +%{GREEDYDATA:message"
      },
      "id": "603e7b9164441f1b2d4e8872"
    },
    {
      "sections": [
        "Drop data with drop filter rules",
        "Savings, security, speed",
        "Caution",
        "How drop filter rules work",
        "Cautions when dropping data",
        "Create drop filter rules",
        "Manage drop filter rules via NerdGraph API",
        "Types of drop filter rules",
        "Drop log events",
        "Drop attributes",
        "Tip",
        "View or delete drop filter rules"
      ],
      "title": "Drop data with drop filter rules",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "41ef69e9d8d23b2ab732b489bb5e0cb47b8c16b6",
      "image": "https://docs.newrelic.com/static/db4b077fafd911b9f5019b022b3048ab/b04e4/ingest-pipeline.png",
      "url": "https://docs.newrelic.com/docs/logs/ui-data/drop-data-drop-filter-rules/",
      "published_at": "2021-12-04T22:05:01Z",
      "updated_at": "2021-11-14T07:15:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After log event data has been shipped to New Relic, it can either be stored in our NRDB database or dropped (discarded). We can drop both log events and event attributes via drop filter rules. You can manage drop filter rules using our Logs UI, as explained in this document. You can also use NerdGraph, our GraphQL-format API explorer. Savings, security, speed Drop filter rules help you accomplish several important goals: Lower costs by storing only logs relevant to your account. Protect privacy and security by removing personal identifiable information (PII). Reduce noise by removing irrelevant events and attributes. Caution Use caution when deciding to drop data. The data you drop is not recoverable. Before using this feature, review the responsibilities and considerations for dropping data. How drop filter rules work A drop filter rule matches data based on a query. When triggered, the drop filter rule removes the matching data from the ingestion pipeline before it is written to NRDB. This creates an explicit demarcation between the logs being forwarded from your domain and the data that New Relic collects. Since the data removed by the drop filter rule doesn't reach our backend, it cannot be queried: the data is gone and cannot be restored. During the ingestion process, customer log data can be parsed, transformed, or dropped before being stored in New Relic's database. Cautions when dropping data When creating drop rules, you are responsible for ensuring that the rules accurately identify and discard the data that meets the conditions that you have established. You are also responsible for monitoring the rule, as well as the data you disclose to New Relic. New Relic cannot guarantee that this functionality will completely resolve data disclosure concerns you may have. New Relic doesn't review or monitor how effective the rules you develop are. Creating rules about sensitive data can leak information about what kinds of data you maintain, including the format of your data or systems (for example, through referencing email addresses or specific credit card numbers). Any user with the relevant role-based access control permissions can view and edit all information in the rules you create. Create drop filter rules To create and edit drop filters, you must have admin permissions in New Relic, or you must be a member of a role with create and edit permissions for Insights > NRQL Drop Rules. Once a drop filter rule is active, it's applied to all log events ingested from that point onwards. Rules are not applied retroactively. Logs collected before creating a rule are not filtered by that rule. Filter or query the set of logs that contain the data you want to drop. Then, from Manage Data on the left nav of the Logs UI, click Create drop filter. To create a new drop filter rule, you can use new or existing log queries. Go to one.newrelic.com > Logs. Filter or query to the specific set of logs that contain the data to be dropped. Once the query is active, from Manage Data on the left nav of the Logs UI, click Create drop filter. Recommendation: Change the drop rule's default name to a meaningful name. Choose to either drop the entire log event that matches the query or just a specific subset of attributes in the matching events. Review the log partitions where this drop rule applies. Save the drop filter rule. Manage drop filter rules via NerdGraph API If you want to manage your drop filter rules programmatically, you can use NerdGraph, our graphQL-format API, at api.newrelic.com/graphiql. For more information, see the NerdGraph tutorial to create, query, and delete your drop filter rules. Types of drop filter rules The drop filters UI prompts you to select whether to drop logs based on the query or on specific attributes. Drop log events The default type of drop filter rule is to drop logs. This option drops the entire log events that match the filter or query. When creating a rule, try to provide a specific query that only matches log data that should be dropped. Our drop filters process won't let you create drop filter rules without values in the matching query. This prevents badly formed rules from dropping all log data. Drop attributes You can specify attributes to be dropped in a log event that matches your query. At least one or more attributes must be selected. Any attribute which is selected will be dropped; all remaining attributes will be kept and stored in NRDB. Tip We recommend this method for removing fields that could contain personal identifiable information (PII) or other sensitive attributes without losing valuable monitoring data. View or delete drop filter rules To view or delete a drop filter rule: Go to one.newrelic.com > Logs. From Manage Data on the left nav of the Logs UI, click Drop filters. Click the delete icon next to the drop filter rule you want to remove. Once deleted, rules no longer filter ingested log events.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.79593,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Drop <em>data</em> with drop filter rules",
        "sections": "Drop <em>data</em> with drop filter rules",
        "tags": "<em>Log</em> <em>management</em>",
        "body": "After <em>log</em> event <em>data</em> has been shipped to New Relic, it can either be stored in our NRDB database or dropped (discarded). We can drop both <em>log</em> events and event attributes via drop filter rules. You can manage drop filter rules using our <em>Logs</em> <em>UI</em>, as explained in this document. You can also use"
      },
      "id": "603e813f28ccbc08c1eba787"
    }
  ],
  "/docs/logs/ui-data/parsing": [
    {
      "sections": [
        "Find data in long logs (blobs)",
        "How blobs work",
        "Tip",
        "Query your data for blobs",
        "Data retention for long logs"
      ],
      "title": "Find data in long logs (blobs)",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "413651f55060d47b3b2c3a939d9f4f576467e405",
      "image": "https://docs.newrelic.com/static/25249afab9ba5695a0764e676d14dfb3/c1b63/log-blob-query.png",
      "url": "https://docs.newrelic.com/docs/logs/ui-data/long-logs-blobs/",
      "published_at": "2021-12-04T22:05:37Z",
      "updated_at": "2021-11-14T08:46:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Extensive log data can help you troubleshoot issues. But what if an attribute in your log contains thousands of characters? How much of this data can New Relic store? And how can you find useful information in all this data? How blobs work For lengthy string values that are longer than can be stored in NRDB (4,094 characters), we store the long string in three pieces: Long log sections Description First 4,094 characters The first 4,094 characters are stored in a Log event field with the same name. So a long message value would have its first 4,094 characters stored in a message field. Next 128,000 UTF-8 bytes The next 128,000 UTF-8 bytes of the string are stored in a blob field with the name with newrelic.ext. prepended. So a long message value would have characters past the first 4,094 characters stored in a newrelic.ext.message field as a blob. The actual number of characters stored depends on the UTF-8 representation of the characters. UTF-8 represents Unicode characters as one to four bytes, so we will store anywhere between 32,000 and 128,000 characters past the first 4,094 characters. Remaining characters Any characters past 4,094 characters plus 128,000 bytes are dropped and not stored. So the long message field would be stored as: message: <first 4,094 characters as a string> newrelic.ext.message: <next 128,000 bytes as a 'blob'> Copy Tip You can search the first 4,094 characters of a string attribute. You can also create alerts for the first 4,094 characters. However, since 'blob' storage is not searchable, text beyond the first 4,094 characters is not searchable or alertable. Query your data for blobs To query for any log data in New Relic, run the following query: SELECT * FROM Log Copy To expand the blob data, run the following query, using message or any other attribute. Be sure to enclose the blob's attribute with backticks. For example: SELECT message, another-attribute, blob(`newrelic.ext.message`), blob(`newrelic.ext.another-attribute) FROM Log Copy To query extended blob data in your logs, be sure to include backticks in your attribute's blob syntax. This expands the data in the blob so you can see (but not search) it. For example, New Relic returns: { \"message\": <first 4,094 characters> \"newrelic.ext.message\": <the next 128,000 bytes as Base64> \"another-attribute\": <first 4,094 characters> \"newrelic.ext.another-attribute\": <the next 128,000 bytes as Base64> } Copy The Logs UI automatically stitches the original value back together when looking at the Log Detail View. When querying using NRQL directly, you need to manually stitch the information together by: Decoding the Base64 of the newrelic.ext. attribute value Converting the resulting UTF-8 into a string Appending that string to the first 4,094 characters in the \"main\" attribute Data retention for long logs NRDB retains your blob records for a month. If you have existing long log messages stored as LogExtendedRecord, that data will also continue to be available for a month in NRDB. After a month passes, no more new LogExtendedRecord attributes will be created. They will all be stored in NRDB as blobs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.90709,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Find <em>data</em> in long <em>logs</em> (blobs)",
        "sections": "Find <em>data</em> in long <em>logs</em> (blobs)",
        "tags": "<em>Log</em> <em>management</em>",
        "body": " other attribute. Be sure to enclose the blob&#x27;s attribute with backticks. For example: SELECT message, another-attribute, blob(`newrelic.ext.message`), blob(`newrelic.ext.another-attribute) FROM <em>Log</em> Copy To query extended blob <em>data</em> in your <em>logs</em>, be sure to include backticks in your attribute&#x27;s blob"
      },
      "id": "6150569228ccbcf314f21423"
    },
    {
      "sections": [
        "Organize data with partitions",
        "Plan your partition",
        "Important",
        "Required roles and permissions",
        "Sizing and organizing a partition",
        "Choosing a namespace",
        "Create partition rules",
        "Search data partitions",
        "Manage data partitions programatically with NerdGraph"
      ],
      "title": "Organize data with partitions",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "620ba43370a8ca4900a02cd4ccc6fefa7f5cf8d7",
      "image": "https://docs.newrelic.com/static/7815845d8068377477aa26f8571d5907/c1b63/log-partitions-crop.png",
      "url": "https://docs.newrelic.com/docs/logs/ui-data/data-partitions/",
      "published_at": "2021-12-04T22:05:01Z",
      "updated_at": "2021-11-14T07:18:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Data partitions are a way to group or organize log data for faster and more efficient querying. When a query targets a single partition, New Relic's Logs UI: Scans less unrelated data. Returns results faster. Accounts can have multiple partitions, and multiple partitions can be queried at the same time. Data partitions also allow data to be mapped to an alternative, or “secondary” namespace with a fixed 30-day retention. This is useful for maintaining compliance with privacy-centric regulations and standards like the General Data Protection Regulation (GDPR). Plan your partition Before you start creating partitions, make sure you have the right permissions and a partition plan. Important Logs are routed to partitions during the ingestion process, before data is written to NRDB. Partition rules will not affect logs that were ingested before the rule was created. Required roles and permissions Users require an Admin role to create and modify partition rules. Sizing and organizing a partition You can gain significant performance improvements with proper use of data partitions. Organizing your data into discrete partitions enables you to query them separately or all together. The goals of partitioning your data should be: Create data partitions that align with concepts in your environment or organization that are static or change infrequently (for example, by business unit, team, environment, service, etc.). Ensure each partition remains below 1 TB of daily ingest for optimal performance. Having more partitions allows for more targeted searches, but creating too many partitions can make logs hard to find and increase administrative overhead. Finding the right balance is important. We support 100 partitions maximum per account, but the optimal number for most accounts is 10 to 15 partitions. Choosing a namespace A partition’s namespace determines its retention period. We offer two retention options: Standard: The account’s default retention determined by your New Relic subscription. This is the maximum retention period available in your account and is the namespace you'll select for most of your partitions. Secondary: 30-day retention. All logs sent to a partition that's a member of the Secondary namespace will be purged on a rolling basis 30 days after having been ingested. Secondary retention is not a cost control mechanism; data is billed on ingest. Create partition rules From the left nav in the Logs UI, select Data partitions, then create a Log_ partition name with the retention namespace, optional description, and matching criteria. To create a new partition rule: Go to one.newrelic.com > Logs. From Manage Data on the left nav of the Logs UI, click Data partitions, then click Create partition rule. Define a Partition name as an alphanumeric string that begins with Log_. Add an optional description. Select the retention namespace for the partition. Set your rule's Matching criteria: Select EQUALS to target logs that match your criteria exactly, or select LIKE to apply a fuzzy match. Click the Enable Rule slider, and click Create. To view a list of data partitions: From Manage Data on the left nav of the Logs UI, click Data partitions. Search data partitions The default partition for all Logs accounts is Log. Any log that is not affected by a partition rule will be stored in the Log partition by default. You can query multiple partitions simultaneously. For best performance, select the smallest number of partitions possible. To search data partitions: From Views and Attributes on the left nav of the Logs UI, click Select partitions. Click one or more partitions you want to query, or search for a partition name. Click Query logs to search your selected partitions. Manage data partitions programatically with NerdGraph If you want to manage your data partitions programatically, you can use NerdGraph, our GraphQL-format API. This tutorial shows how to query, create, and delete data partitions using our API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.79999,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Organize <em>data</em> with partitions",
        "sections": "<em>Manage</em> <em>data</em> partitions programatically with NerdGraph",
        "tags": "<em>Log</em> <em>management</em>",
        "body": "<em>Data</em> partitions are a way to group or organize <em>log</em> <em>data</em> for faster and more efficient querying. When a query targets a single partition, New Relic&#x27;s <em>Logs</em> <em>UI</em>: Scans less unrelated <em>data</em>. Returns results faster. Accounts can have multiple partitions, and multiple partitions can be queried at the same"
      },
      "id": "6087e311e7b9d2f90ba5c6a4"
    },
    {
      "sections": [
        "Built-in log parsing rules",
        "Apache",
        "Application Load Balancer",
        "Cloudfront",
        "Elastic Load Balancer",
        "Microsoft IIS",
        "Monit",
        "MySQL Error",
        "NGINX",
        "NGINX Error",
        "Route 53",
        "Syslog RFC-5424"
      ],
      "title": "Built-in log parsing rules",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "ae238defe10615c8767ea24f74b3c416190f4b49",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/ui-data/built-log-parsing-rules/",
      "published_at": "2021-12-04T22:06:50Z",
      "updated_at": "2021-11-14T07:16:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic can parse common log formats according to built-in rules, so that you don't have to create your own parsing rules. Here are the log parsing rules, their Grok patterns, and what fields are parsed. To enable built-in log parsing, see our documentation for adding the logtype attribute. To manage your parsing rules programmatically, use NerdGraph, our GraphQL-format API, at api.newrelic.com/graphiql. For more information, see the NerdGraph tutorial to create, query, and delete your parsing rules. Apache Source: logtype = 'apache' Grok: %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \\[%{HTTPDATE:timestamp}\\] \"(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})\" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer} %{QS:agent} Copy Results: clientip: The IP address of the client. verb: The HTTP verb ident: The user identity of the client making the request response: The HTTP status code of the response request: The URI and request being made httpversion: The HTTP version of the request rawrequest: The raw HTTP request if data is posted bytes: The number of bytes sent referrer: The HTTP referrer agent: The client's user agent Application Load Balancer Source: logtype = 'alb' Grok: ^%{NOTSPACE:type} %{TIMESTAMP_ISO8601:time} %{NOTSPACE:elb} %{NOTSPACE:client_ip}:%{NOTSPACE:client_port} ((%{NOTSPACE:target_ip}:%{NOTSPACE:target_port})|-) %{NOTSPACE:request_processing_time} %{NOTSPACE:target_processing_time} %{NOTSPACE:response_processing_time} %{NOTSPACE:elb_status_code} %{NOTSPACE:target_status_code} %{NOTSPACE:received_bytes} %{NOTSPACE:sent_bytes} \"%{DATA:request}\" \"%{DATA:user_agent}\" %{NOTSPACE:ssl_cipher} %{NOTSPACE:ssl_protocol} %{NOTSPACE:target_group_arn} \"%{DATA:trace_id}\" \"%{NOTSPACE:domain_name}\" \"%{NOTSPACE:chosen_cert_arn}\" %{NOTSPACE:matched_rule_priority} %{TIMESTAMP_ISO8601:request_creation_time} \"%{NOTSPACE:actions_executed}\" \"%{NOTSPACE:redirect_url}\" \"%{NOTSPACE:error_reason}\" (?:\"|)%{DATA:target_port_list}(?:\"|) (?:\"|)%{DATA:target_status_code_list}(?:\"|) \"%{NOTSPACE:classification}\" \"%{NOTSPACE:classification_reason}\" Copy Results: Field Definition type The type of request or connection. Possible values are: http: HTTP https: HTTP over SSL/TLS h2: HTTP/2 over SSL/TLS ws: WebSockets wss: WebSockets over SSL/TLS elb The resource ID of the load balancer. If you are parsing access log entries, note that resources IDs can contain forward slashes (/). client The IP address and port of the requesting client target The IP address and port of the target that processed this request. If the client didn't send a full request, the load balancer can't dispatch the request to a target, and this value is set to -. If the target is a Lambda function, this value is set to -. If the request is blocked by AWS WAF, this value is set to -, and the value of elb_status_code is set to 403. request_processing_time The total time elapsed (in seconds, with millisecond precision) from the time the load balancer received the request until the time it sent it to a target. This value is set to -1 if the load balancer can't dispatch the request to a target. This can happen if the target closes the connection before the idle timeout or if the client sends a malformed request. This value can also be set to -1 if the registered target does not respond before the idle timeout. target_processing_time The total time elapsed (in seconds, with millisecond precision) from the time the load balancer sent the request to a target until the target started to send the response headers. This value is set to -1 if the load balancer can't dispatch the request to a target. This can happen if the target closes the connection before the idle timeout or if the client sends a malformed request. This value can also be set to -1 if the registered target does not respond before the idle timeout. response_processing_time The total time elapsed (in seconds, with millisecond precision) from the time the load balancer received the response header from the target until it started to send the response to the client. This includes both the queuing time at the load balancer and the connection acquisition time from the load balancer to the client. This value is set to -1 if the load balancer can't send the request to a target. This can happen if the target closes the connection before the idle timeout or if the client sends a malformed request. elb_status_code The status code of the response from the load balancer target_status_code The status code of the response from the target. This value is recorded only if a connection was established to the target and the target sent a response. Otherwise, it is set to -. received_bytes The size of the request, in bytes, received from the client (requester). For HTTP requests, this includes the headers. For WebSockets, this is the total number of bytes received from the client on the connection. sent_bytes The size of the response, in bytes, sent to the client (requester). For HTTP requests, this includes the headers. For WebSockets, this is the total number of bytes sent to the client on the connection. method The HTTP verb of the request uri The URI the request was targeting http_version The HTTP version number of the request user_agent User-Agent string that identifies the client that originated the request, enclosed in double quotes. The string consists of one or more product identifiers, product/version. If the string is longer than 8 KB, it is truncated. ssl_cipher The SSL cipher. This value is set to - if the listener is not an HTTPS listener. ssl_protocol The SSL protocol. This value is set to - if the listener is not an HTTPS listener. target_group_arn The Amazon Resource Name (ARN) of the target group trace_id The contents of the X-Amzn-Trace-Id header, enclosed in double quotes domain_name The SNI domain provided by the client during the TLS handshake, enclosed in double quotes. This value is set to - if the client doesn't support SNI or the domain doesn't match a certificate and the default certificate is presented to the client. chosen_cert_arn The ARN of the certificate presented to the client, enclosed in double quotes. Set to session-reused if the session is reused. Set to - if the listener is not an HTTPS listener. matched_rule_priority The priority value of the rule that matched the request. If a rule matched, this is a value from 1 to 50000. If no rule matched and the default action was taken, this value is set to 0. If an error occurs during rules evaluation, it is set to -1. For any other error, it is set to -. request_creation_time The time when the load balancer received the request from the client, in ISO 8601 format. actions_executed The actions taken when processing the request, enclosed in double quotes. This value is a comma-separated list that can include the values described in actions_taken. If no action was taken, such as for a malformed request, this value is set to -. redirect_url The URL of the redirect target for the location header of the HTTP response, enclosed in double quotes. If no redirect actions were taken, this value is set to -. error_reason The error reason code, enclosed in double quotes. If the request failed, this is one of the error codes described in Error Reason Codes. If the actions taken do not include an authenticate action or the target is not a Lambda function, this value is set to -. Cloudfront Source: logtype = 'cloudfront-web' Grok: ^%{NOTSPACE:date}%{SPACE}%{NOTSPACE:time}%{SPACE}%{NOTSPACE:x_edge_location}%{SPACE}%{NOTSPACE:sc_bytes}%{SPACE}%{NOTSPACE:c_ip}%{SPACE}%{NOTSPACE:cs_method}%{SPACE}%{NOTSPACE:cs_host}%{SPACE}%{NOTSPACE:cs_uri_stem}%{SPACE}%{NOTSPACE:sc_status}%{SPACE}%{NOTSPACE:cs_referer}%{SPACE}%{NOTSPACE:cs_user_agent}%{SPACE}%{NOTSPACE:cs_uri_query}%{SPACE}%{NOTSPACE:cs_Cookie}%{SPACE}%{NOTSPACE:x_edge_result_type}%{SPACE}%{NOTSPACE:x_edge_request_id}%{SPACE}%{NOTSPACE:x_host_header}%{SPACE}%{NOTSPACE:cs_protocol}%{SPACE}%{NOTSPACE:cs_bytes}%{SPACE}%{NOTSPACE:time_taken}%{SPACE}%{NOTSPACE:x_forwarded_for}%{SPACE}%{NOTSPACE:ssl_protocol}%{SPACE}%{NOTSPACE:ssl_cipher}%{SPACE}%{NOTSPACE:x_edge_response_result_type}%{SPACE}%{NOTSPACE:cs_protocol_version}%{SPACE}%{NOTSPACE:fle_status}%{SPACE}%{NOTSPACE:fle_encrypted_fields}%{SPACE}%{NOTSPACE:c_port}%{SPACE}%{NOTSPACE:time_to_first_byte}%{SPACE}%{NOTSPACE:x_edge_detailed_result_type}%{SPACE}%{NOTSPACE:sc_content_type}%{SPACE}%{NOTSPACE:sc_content_len}%{SPACE}%{NOTSPACE:sc_range_start}%{SPACE}%{NOTSPACE:sc_range_end} Copy Results: Field Definition x_edge_location The edge location that served the request. Each edge location is identified by a three-letter code and an arbitrarily assigned number; for example, DFW3. The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.) sc_bytes The total number of bytes that CloudFront served to the viewer in response to the request, including headers; for example, 1045619. For WebSocket connections, this is the total number of bytes sent from the server to the client through the connection. c_ip The IP address of the viewer that made the request, either in IPv4 or IPv6 format. If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip is the IP address of the proxy or load balancer. See also X-Forwarded-For. cs_method The HTTP request method: DELETE, GET, HEAD, OPTIONS, PATCH, POST, or PUT. cs_host The domain name of the CloudFront distribution; for example, d111111abcdef8.cloudfront.net. cs_uri_stem The portion of the URI that identifies the path and object; for example, /images/cat.jpg. Question marks in URLs and query strings are not included. sc_status An HTTP status code; for example, 200. Status code 000 indicates the viewer closed the connection (for example, closed the browser tab) before CloudFront could respond to a request. If the viewer closes the connection after CloudFront starts to send the response, the log contains the applicable HTTP status code. cs_referer The name of the domain that originated the request. Common referrers include search engines, other websites that link directly to your objects, and your own website. cs_user_agent The value of the User-Agent header in the request. The User-Agent header identifies the source of the request, such as the type of device and browser that submitted the request, and which search engine if applicable. cs_uri_query The query string portion of the URI, if any. When a URI doesn't contain a query string, this field's value is a hyphen (-). cs_cookie The cookie header in the request, including name-value pairs and the associated attributes. If you enable cookie logging, CloudFront logs the cookies in all requests regardless of which cookies you choose to forward to the origin. If a request doesn't include a cookie header, this field's value is a hyphen (-). x_edge_result_type How CloudFront classifies the response after the last byte left the edge location. In some cases, the result type can change between the time that CloudFront is ready to send the response and the time that CloudFront has finished sending the response. x_edge_request_id An encrypted string that uniquely identifies a request. In the response header, this is x-amz-cf-id. x_host_header The value that the viewer included in the Host header for this request. This is the domain name in the request. If you're using the CloudFront domain name in your object URLs, this field contains that domain name. If you're using alternate domain names in your object URLs, such as http://example.com/logo.png, this field contains the alternate domain name, such as example.com. To use alternate domain names, you must add them to your distribution. cs_protocol The protocol that the viewer specified in the request: http, https, ws, or wss. cs_bytes The number of bytes of data that the viewer included in the request, including headers. For WebSocket connections, this is the total number of bytes sent from the client to the server on the connection. time_taken The number of seconds (to the thousandth of a second; for example, 0.002) between the time that a CloudFront edge server receives a viewer's request and the time that CloudFront writes the last byte of the response to the edge server's output queue as measured on the server. From the perspective of the viewer, the total time to get the full object will be longer than this value due to network latency and TCP buffering. x_forwarded_for If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip in field 5 is the IP address of the proxy or load balancer. In that case, this field is the IP address of the viewer that originated the request. This field contains IPv4 and IPv6 addresses as applicable. If the viewer did not use an HTTP proxy or a load balancer, the value of x_forwarded_for is a hyphen (-). ssl_protocol When cs_protocol in field 17 is https, this field contains the SSL/TLS protocol that the client and CloudFront negotiated for transmitting the request and response. Possible values include: SSLv3 TLSv1 TLSv1.1 TLSv1.2 When cs_protocol in field 17 is http, the value for this field is a hyphen (-). ssl_cipher When cs_protocol in field 17 is https, this field contains the SSL/TLS cipher that the client and CloudFront negotiated for encrypting the request and response. Possible values include: ECDHE-RSA-AES128-GCM-SHA256 ECDHE-RSA-AES128-SHA256 ECDHE-RSA-AES128-SHA ECDHE-RSA-AES256-GCM-SHA384 ECDHE-RSA-AES256-SHA384 ECDHE-RSA-AES256-SHA AES128-GCM-SHA256 AES256-GCM-SHA384 AES128-SHA256 AES256-SHA AES128-SHA DES-CBC3-SHA RC4-MD5 When cs_protocol in field 17 is http, the value for this field is a hyphen (-). x_edge_response_result_type How CloudFront classified the response just before returning the response to the viewer. Possible values include: Hit: CloudFront served the object to the viewer from the edge cache. RefreshHit: CloudFront found the object in the edge cache but it had expired, so CloudFront contacted the origin to verify that the cache has the latest version of the object. Miss: The request could not be satisfied by an object in the edge cache, so CloudFront forwarded the request to the origin server and returned the result to the viewer. LimitExceeded: The request was denied because a CloudFront limit was exceeded. CapacityExceeded: CloudFront returned a 503 error because the edge location didn't have enough capacity at the time of the request to serve the object. Error: Typically this means the request resulted in a client error (sc_status is 4xx) or a server error (sc_status is 5xx). If the value of x_edge_result_type is Error and the value of this field is not Error, the client disconnected before finishing the download. Redirect: CloudFront redirects from HTTP to HTTPS. If sc_status is 403 and you configured CloudFront to restrict the geographic distribution of your content, the request might have come from a restricted location. cs_protocol_version The HTTP version that the viewer specified in the request. Possible values include: HTTP/0.9 HTTP/1.0 HTTP/1.1 HTTP/2.0 fle_status When field-level encryption is configured for a distribution, this field contains a code that indicates whether the request body was successfully processed. If field-level encryption is not configured for the distribution, the value is a hyphen (-). fle-encrypted-fields The number of fields that CloudFront encrypted and forwarded to the origin. CloudFront streams the processed request to the origin as it encrypts data, so fle-encrypted-fields can have a value even if the value of fle-status is an error. If field-level encryption is not configured for the distribution, the value of fle-encrypted-fields is a hyphen (-). c_port The port number of the request from the viewer. time_to_first_byte The number of seconds between receiving the request and writing the first byte of the response, as measured on the server. x_edge_detailed_result_type When x-edge-result-type is not Error, this field contains the same value as x-edge-result-type. When x-edge-result-type is Error, this field contains the specific type of error. sc_content_type The value of the HTTP Content-Type header of the response. sc_content_len The value of the HTTP Content-Length header of the response. sc_range_start When the response contains the HTTP Content-Range header, this field contains the range start value. sc-range-end When the response contains the HTTP Content-Range header, this field contains the range end value. Elastic Load Balancer Source: logtype = 'elb' Grok: ^%{TIMESTAMP_ISO8601:time} %{NOTSPACE:elb} %{NOTSPACE:client_ip}:%{NOTSPACE:client_port} ((%{NOTSPACE:backend_ip}:%{NOTSPACE:backend_port})|-) %{NOTSPACE:request_processing_time} %{NOTSPACE:backend_processing_time} %{NOTSPACE:response_processing_time} %{NOTSPACE:elb_status_code} %{NOTSPACE:backend_status_code} %{NOTSPACE:received_bytes} %{NOTSPACE:sent_bytes} \"%{DATA:request}\" \"%{DATA:user_agent}\" %{NOTSPACE:ssl_cipher} %{NOTSPACE:ssl_protocol} Copy Results: Field Definition x_edge_location The edge location that served the request. Each edge location is identified by a three-letter code and an arbitrarily assigned number; for example, DFW3. The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.) sc_bytes The total number of bytes that CloudFront served to the viewer in response to the request, including headers; for example, 1045619. For WebSocket connections, this is the total number of bytes sent from the server to the client through the connection. c_ip The IP address of the viewer that made the request. If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip is the IP address of the proxy or load balancer. cs_method The HTTP request method: DELETE, GET, HEAD, OPTIONS, PATCH, POST, or PUT. cs_host The domain name of the CloudFront distribution; for example, d111111abcdef8.cloudfront.net. cs_uri_stem The portion of the URI that identifies the path and object; for example, /images/cat.jpg. Question marks (?) in URLs and query strings are not included in the log. sc_status An HTTP status code (for example, 200). Status code 000 indicates that the viewer closed the connection (for example, closed the browser tab) before CloudFront could respond to a request. If the viewer closes the connection after CloudFront starts to send the response, the log contains the applicable HTTP status code. cs_referer he name of the domain that originated the request. Common referrers include search engines, other websites that link directly to your objects, and your own website. cs_user_agent The value of the User-Agent header in the request. The User-Agent header identifies the source of the request, such as the type of device and browser that submitted the request and which search engine if applicable. cs_uri_query The query string portion of the URI, if any. When a URI doesn't contain a query string, this field's value is a hyphen (-). cs_cookie The cookie header in the request, including name-value pairs and the associated attributes. If you enable cookie logging, CloudFront logs the cookies in all requests, regardless of which cookies you choose to forward to the origin. If a request doesn't include a cookie header, this field's value is a hyphen (-). x_edge_result_type How CloudFront classifies the response after the last byte left the edge location. In some cases, the result type can change between the time that CloudFront is ready to send the response and the time that CloudFront has finished sending the response. x_edge_request_id An encrypted string that uniquely identifies a request. In the response header, this is x-amz-cf-id. x_host_header The value that the viewer included in the Host header for this request. This is the domain name in the request. If you're using the CloudFront domain name in your object URLs, this field contains that domain name. If you're using alternate domain names in your object URLs, such as [http://example.com/logo.png, this field contains the alternate domain name, such as example.com. To use alternate domain names, you must add them to your distribution. cs_protocol The protocol that the viewer specified in the request: http, https, ws, or wss. cs_bytes The number of bytes of data that the viewer included in the request, including headers. For WebSocket connections, this is the total number of bytes sent from the client to the server on the connection. time_taken The number of seconds (to the thousandth of a second; for example, 0.002) between the time that a CloudFront edge server receives a viewer's request and the time that CloudFront writes the last byte of the response to the edge server's output queue as measured on the server. From the perspective of the viewer, the total time to get the full object will be longer than this value due to network latency and TCP buffering. x_forwarded_for If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip in field 5 is the IP address of the proxy or load balancer. In that case, this field is the IP address of the viewer that originated the request. This field contains IPv4 and IPv6 addresses as applicable. If the viewer did not use an HTTP proxy or a load balancer, the value of x_forwarded_for is a hyphen (-). ssl_protocol When cs_protocol in field 17 is https, this field contains the SSL/TLS protocol that the client and CloudFront negotiated for transmitting the request and response. Possible values include: SSLv3 TLSv1 TLSv1.1 TLSv1.2 When cs_protocol in field 17 is http, the value for this field is a hyphen (-). ssl_cipher When cs_protocol in field 17 is https, this field contains the SSL/TLS cipher that the client and CloudFront negotiated for encrypting the request and response. Possible values include: ECDHE-RSA-AES128-GCM-SHA256 ECDHE-RSA-AES128-SHA256 ECDHE-RSA-AES128-SHA ECDHE-RSA-AES256-GCM-SHA384 ECDHE-RSA-AES256-SHA384 ECDHE-RSA-AES256-SHA AES128-GCM-SHA256 AES256-GCM-SHA384 AES128-SHA256 AES256-SHA AES128-SHA DES-CBC3-SHA RC4-MD5 When cs_protocol is http, the value for this field is a hyphen (-). x_edge_response_result_type How CloudFront classified the response just before returning the response to the viewer. Possible values include: Hit: CloudFront served the object to the viewer from the edge cache. RefreshHit: CloudFront found the object in the edge cache but it had expired, so CloudFront contacted the origin to verify that the cache has the latest version of the object. Miss: The request could not be satisfied by an object in the edge cache, so CloudFront forwarded the request to the origin server and returned the result to the viewer. LimitExceeded: The request was denied because a CloudFront limit was exceeded. CapacityExceeded: CloudFront returned a 503 error because the edge location didn't have enough capacity at the time of the request to serve the object. Error: Typically this means the request resulted in a client error (sc_status is 4xx) or a server error (sc_status is 5xx). If the value of x_edge_result_type is Error and the value of this field is not Error, the client disconnected before finishing the download. Redirect: CloudFront redirects from HTTP to HTTPS. If sc_status is 403 and you configured CloudFront to restrict the geographic distribution of your content, the request might have come from a restricted location. cs_protocol_version The HTTP version that the viewer specified in the request. Possible values include: HTTP/0.9 HTTP/1.0 HTTP/1.1 HTTP/2.0 fle_status When field-level encryption is configured for a distribution, this field contains a code that indicates whether the request body was successfully processed. If field-level encryption is not configured for the distribution, the value of this field is a hyphen (-). When CloudFront successfully processes the request body, encrypts values in the specified fields, and forwards the request to the origin, the value of this field is Processed. The value of x_edge_result_type can still indicate a client-side or server-side error in this case. If the request exceeds a field-level encryption limit, fle-status contains one of the following error codes, and CloudFront returns HTTP status code 400 to the viewer. fle-encrypted-fields The number of fields that CloudFront encrypted and forwarded to the origin. CloudFront streams the processed request to the origin as it encrypts data, so fle_encrypted_fields can have a value even if the value of fle_status is an error. If field-level encryption is not configured for the distribution, the value of fle_encrypted_fields is a hyphen (-). c_port The port number of the request from the viewer. time_to_first_byte The number of seconds between receiving the request and writing the first byte of the response, as measured on the server. x_edge_detailed_result_type When x_edge_result_type is not Error, this field contains the same value as x_edge_result_type. When x_edge_result_type is Error, this field contains the specific type of error. sc_content_type The value of the HTTP Content-Type header of the response. sc_content_len The value of the HTTP Content-Length header of the response. sc_range_start When the response contains the HTTP Content-Range header, this field contains the range start value. sc-range-end When the response contains the HTTP Content-Range header, this field contains the range end value. Microsoft IIS Source: logtype = 'iis_w3c' Grok: %{TIMESTAMP_ISO8601:log_timestamp} %{NOTSPACE:server_ip} %{WORD:method} %{NOTSPACE:uri} %{NOTSPACE:uri_query} %{NOTSPACE:server_port} %{NOTSPACE:username} %{NOTSPACE:client_ip} %{NOTSPACE:user_agent} %{NOTSPACE:referer} %{NOTSPACE:status} %{NOTSPACE:substatus} %{NOTSPACE:win32_status} %{NOTSPACE:time_taken} Copy Monit Source: logtype = 'monit' Grok: \\\\[%{NOTSPACE:tz} %{SYSLOGTIMESTAMP:nr_timestamp}\\\\] %{WORD:state}%{SPACE}: %{GREEDYDATA:message} Copy Results: state: The severity of the log line message: The message MySQL Error Source: logtype = 'mysql-error' Grok: \\\\[%{WORD:log_level}\\\\] Copy Results: log_level: The severity of the log line NGINX Source: logtype = 'nginx' Grok: %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \\[%{HTTPDATE:timestamp}\\] \"(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})\" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer} %{QS:agent} Copy Results: clientip: The IP address of the client verb: The HTTP verb ident: The user identity of the client making the request response: The HTTP status code of the response request: The URI and request being made httpversion: The HTTP version of the request rawrequest: The raw HTTP request if data is posted bytes: The number of bytes sent referrer: The HTTP referrer agent: The client's user agent NGINX Error Source: logtype = 'nginx-error' Grok: ^(?<timestamp>%{YEAR:year}[./-]%{MONTHNUM:month}[./-]%{MONTHDAY:day}[- ]%{TIME:time}) \\\\[%{LOGLEVEL:severity}\\\\] %{POSINT:pid}#%{NUMBER}: %{GREEDYDATA:errormessage}(?:, client: (?<client>%{IP:clientip}|%{HOSTNAME:hostname}))(?:, server: %{IPORHOSTORUNDERSCORE:server})(?:, request: %{QS:request})?(?:, upstream: \\\"%{URI:upstream}\\\")?(?:, host: %{QS:host})?(?:, referrer: \\\"%{URI:referrer}\\\")?$ Copy Results: severity: The severity of the log line pid: The server process ID errormessage: The error message clientip: The IP address of the calling client server: The server IP address request: The full request upstream: The upstream URI host: The server's hostname referrer: The HTTP referrer Route 53 Source: logtype = 'route-53' Grok: %{NUMBER:log_format_version} %{TIMESTAMP_ISO8601} %{WORD:zone_id} %{IPORHOST:query} %{WORD:query_type} %{WORD:response_code} %{WORD:protocol} %{WORD:edge_location} %{IP:resolver_ip} %{GREEDYDATA:edns_client_subnet} Copy Results: log_format_version: A versioned format for the log. zone_id: The ID of the hosted zone that is associated with all the DNS queries in this log. query: The domain or subdomain that was specified in the request. query_type: Either the DNS record type that was specified in the request, or ANY. response_code: The DNS response code that Route 53 returned in response to the DNS query. protocol: The protocol that was used to submit the query, either TCP or UDP. edge_location: The Route 53 edge location that responded to the query. Each edge location is identified by a three-letter code and an arbitrary number; for example, DFW3. The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.) resolver_ip: The IP address of the DNS resolver that submitted the request to Route 53. edns_client_subnet: A partial IP address for the client that the request originated from, if available from the DNS resolver. Syslog RFC-5424 Source: logtype = 'syslog-rfc5424' Grok: <%{NONNEGINT:pri}>%{NONNEGINT:version} +(?:%{TIMESTAMP_ISO8601:log.timestamp}|-) +(?:%{HOSTNAME:hostname}|-) +(?:\\\\-|%{NOTSPACE:app.name}) +(?:\\\\-|%{NOTSPACE:procid}) (?:\\\\-|%{NOTSPACE:msgid}) +(?:\\[%{DATA:structured.data}\\]|-|) +%{GREEDYDATA:message} Copy Results: pri: The priority represents both the message facility and severity. version: Syslog protocol version. log.timestamp: Original timestamp. hostname: The machine that originally sent the Syslog message. app.name: The device or application that originated the message. procid: The process name or process ID associated with a Syslog system. msgid: Identifies the type of message. structured.data: Structured data string value. sd.<var>sd-id</var>.<var>sd-param-name</var>: The structured.data content is also parsed into separate attributes following a predefined naming convention: sd.<var>sd-id</var>.<var>sd-param-name</var>. See the structured data parsing examples, which follow. message: Free-form message that provides information about the event. Structured data parsing examples: The structured data [example one=\"1\" two=\"2\"] would be parsed into two different attributes: sd.example.one: \"1\" sd.example.two: \"2\" Copy If the same structured data block contains duplicate param names, it also appends an index-based suffix on the attribute name. For example, the structured data [example number=\"1\" number=\"2\"] would be parsed as: sd.example.number.0: \"1\" sd.example.number.1: \"2\" Copy For structured data with enterprise numbers assigned, an extra attribute is also parsed. For example, the structured data [example@123 number=\"1\"] would be parsed as: sd.example.enterprise.number: 123 sd.example.number: \"1\" Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.79698,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Built-in <em>log</em> parsing rules",
        "sections": "Built-in <em>log</em> parsing rules",
        "tags": "<em>Log</em> <em>management</em>",
        "body": " RFC-5424 Source: logtype = &#x27;syslog-rfc5424&#x27; Grok: &lt;%{NONNEGINT:pri}&gt;%{NONNEGINT:version} +(?:%{TIMESTAMP_ISO8601:<em>log</em>.timestamp}|-) +(?:%{HOSTNAME:hostname}|-) +(?:\\\\-|%{NOTSPACE:app.name}) +(?:\\\\-|%{NOTSPACE:procid}) (?:\\\\-|%{NOTSPACE:msgid}) +(?:\\[%{<em>DATA:structured.data</em>}\\]|-|) +%{GREEDYDATA:message"
      },
      "id": "603e7b9164441f1b2d4e8872"
    }
  ],
  "/docs/logs/ui-data/query-syntax-logs": [
    {
      "sections": [
        "Find data in long logs (blobs)",
        "How blobs work",
        "Tip",
        "Query your data for blobs",
        "Data retention for long logs"
      ],
      "title": "Find data in long logs (blobs)",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "413651f55060d47b3b2c3a939d9f4f576467e405",
      "image": "https://docs.newrelic.com/static/25249afab9ba5695a0764e676d14dfb3/c1b63/log-blob-query.png",
      "url": "https://docs.newrelic.com/docs/logs/ui-data/long-logs-blobs/",
      "published_at": "2021-12-04T22:05:37Z",
      "updated_at": "2021-11-14T08:46:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Extensive log data can help you troubleshoot issues. But what if an attribute in your log contains thousands of characters? How much of this data can New Relic store? And how can you find useful information in all this data? How blobs work For lengthy string values that are longer than can be stored in NRDB (4,094 characters), we store the long string in three pieces: Long log sections Description First 4,094 characters The first 4,094 characters are stored in a Log event field with the same name. So a long message value would have its first 4,094 characters stored in a message field. Next 128,000 UTF-8 bytes The next 128,000 UTF-8 bytes of the string are stored in a blob field with the name with newrelic.ext. prepended. So a long message value would have characters past the first 4,094 characters stored in a newrelic.ext.message field as a blob. The actual number of characters stored depends on the UTF-8 representation of the characters. UTF-8 represents Unicode characters as one to four bytes, so we will store anywhere between 32,000 and 128,000 characters past the first 4,094 characters. Remaining characters Any characters past 4,094 characters plus 128,000 bytes are dropped and not stored. So the long message field would be stored as: message: <first 4,094 characters as a string> newrelic.ext.message: <next 128,000 bytes as a 'blob'> Copy Tip You can search the first 4,094 characters of a string attribute. You can also create alerts for the first 4,094 characters. However, since 'blob' storage is not searchable, text beyond the first 4,094 characters is not searchable or alertable. Query your data for blobs To query for any log data in New Relic, run the following query: SELECT * FROM Log Copy To expand the blob data, run the following query, using message or any other attribute. Be sure to enclose the blob's attribute with backticks. For example: SELECT message, another-attribute, blob(`newrelic.ext.message`), blob(`newrelic.ext.another-attribute) FROM Log Copy To query extended blob data in your logs, be sure to include backticks in your attribute's blob syntax. This expands the data in the blob so you can see (but not search) it. For example, New Relic returns: { \"message\": <first 4,094 characters> \"newrelic.ext.message\": <the next 128,000 bytes as Base64> \"another-attribute\": <first 4,094 characters> \"newrelic.ext.another-attribute\": <the next 128,000 bytes as Base64> } Copy The Logs UI automatically stitches the original value back together when looking at the Log Detail View. When querying using NRQL directly, you need to manually stitch the information together by: Decoding the Base64 of the newrelic.ext. attribute value Converting the resulting UTF-8 into a string Appending that string to the first 4,094 characters in the \"main\" attribute Data retention for long logs NRDB retains your blob records for a month. If you have existing long log messages stored as LogExtendedRecord, that data will also continue to be available for a month in NRDB. After a month passes, no more new LogExtendedRecord attributes will be created. They will all be stored in NRDB as blobs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.90706,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Find <em>data</em> in long <em>logs</em> (blobs)",
        "sections": "Find <em>data</em> in long <em>logs</em> (blobs)",
        "tags": "<em>Log</em> <em>management</em>",
        "body": " other attribute. Be sure to enclose the blob&#x27;s attribute with backticks. For example: SELECT message, another-attribute, blob(`newrelic.ext.message`), blob(`newrelic.ext.another-attribute) FROM <em>Log</em> Copy To query extended blob <em>data</em> in your <em>logs</em>, be sure to include backticks in your attribute&#x27;s blob"
      },
      "id": "6150569228ccbcf314f21423"
    },
    {
      "sections": [
        "Organize data with partitions",
        "Plan your partition",
        "Important",
        "Required roles and permissions",
        "Sizing and organizing a partition",
        "Choosing a namespace",
        "Create partition rules",
        "Search data partitions",
        "Manage data partitions programatically with NerdGraph"
      ],
      "title": "Organize data with partitions",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "620ba43370a8ca4900a02cd4ccc6fefa7f5cf8d7",
      "image": "https://docs.newrelic.com/static/7815845d8068377477aa26f8571d5907/c1b63/log-partitions-crop.png",
      "url": "https://docs.newrelic.com/docs/logs/ui-data/data-partitions/",
      "published_at": "2021-12-04T22:05:01Z",
      "updated_at": "2021-11-14T07:18:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Data partitions are a way to group or organize log data for faster and more efficient querying. When a query targets a single partition, New Relic's Logs UI: Scans less unrelated data. Returns results faster. Accounts can have multiple partitions, and multiple partitions can be queried at the same time. Data partitions also allow data to be mapped to an alternative, or “secondary” namespace with a fixed 30-day retention. This is useful for maintaining compliance with privacy-centric regulations and standards like the General Data Protection Regulation (GDPR). Plan your partition Before you start creating partitions, make sure you have the right permissions and a partition plan. Important Logs are routed to partitions during the ingestion process, before data is written to NRDB. Partition rules will not affect logs that were ingested before the rule was created. Required roles and permissions Users require an Admin role to create and modify partition rules. Sizing and organizing a partition You can gain significant performance improvements with proper use of data partitions. Organizing your data into discrete partitions enables you to query them separately or all together. The goals of partitioning your data should be: Create data partitions that align with concepts in your environment or organization that are static or change infrequently (for example, by business unit, team, environment, service, etc.). Ensure each partition remains below 1 TB of daily ingest for optimal performance. Having more partitions allows for more targeted searches, but creating too many partitions can make logs hard to find and increase administrative overhead. Finding the right balance is important. We support 100 partitions maximum per account, but the optimal number for most accounts is 10 to 15 partitions. Choosing a namespace A partition’s namespace determines its retention period. We offer two retention options: Standard: The account’s default retention determined by your New Relic subscription. This is the maximum retention period available in your account and is the namespace you'll select for most of your partitions. Secondary: 30-day retention. All logs sent to a partition that's a member of the Secondary namespace will be purged on a rolling basis 30 days after having been ingested. Secondary retention is not a cost control mechanism; data is billed on ingest. Create partition rules From the left nav in the Logs UI, select Data partitions, then create a Log_ partition name with the retention namespace, optional description, and matching criteria. To create a new partition rule: Go to one.newrelic.com > Logs. From Manage Data on the left nav of the Logs UI, click Data partitions, then click Create partition rule. Define a Partition name as an alphanumeric string that begins with Log_. Add an optional description. Select the retention namespace for the partition. Set your rule's Matching criteria: Select EQUALS to target logs that match your criteria exactly, or select LIKE to apply a fuzzy match. Click the Enable Rule slider, and click Create. To view a list of data partitions: From Manage Data on the left nav of the Logs UI, click Data partitions. Search data partitions The default partition for all Logs accounts is Log. Any log that is not affected by a partition rule will be stored in the Log partition by default. You can query multiple partitions simultaneously. For best performance, select the smallest number of partitions possible. To search data partitions: From Views and Attributes on the left nav of the Logs UI, click Select partitions. Click one or more partitions you want to query, or search for a partition name. Click Query logs to search your selected partitions. Manage data partitions programatically with NerdGraph If you want to manage your data partitions programatically, you can use NerdGraph, our GraphQL-format API. This tutorial shows how to query, create, and delete data partitions using our API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.79996,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Organize <em>data</em> with partitions",
        "sections": "<em>Manage</em> <em>data</em> partitions programatically with NerdGraph",
        "tags": "<em>Log</em> <em>management</em>",
        "body": "<em>Data</em> partitions are a way to group or organize <em>log</em> <em>data</em> for faster and more efficient querying. When a query targets a single partition, New Relic&#x27;s <em>Logs</em> <em>UI</em>: Scans less unrelated <em>data</em>. Returns results faster. Accounts can have multiple partitions, and multiple partitions can be queried at the same"
      },
      "id": "6087e311e7b9d2f90ba5c6a4"
    },
    {
      "sections": [
        "Built-in log parsing rules",
        "Apache",
        "Application Load Balancer",
        "Cloudfront",
        "Elastic Load Balancer",
        "Microsoft IIS",
        "Monit",
        "MySQL Error",
        "NGINX",
        "NGINX Error",
        "Route 53",
        "Syslog RFC-5424"
      ],
      "title": "Built-in log parsing rules",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "ae238defe10615c8767ea24f74b3c416190f4b49",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/ui-data/built-log-parsing-rules/",
      "published_at": "2021-12-04T22:06:50Z",
      "updated_at": "2021-11-14T07:16:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic can parse common log formats according to built-in rules, so that you don't have to create your own parsing rules. Here are the log parsing rules, their Grok patterns, and what fields are parsed. To enable built-in log parsing, see our documentation for adding the logtype attribute. To manage your parsing rules programmatically, use NerdGraph, our GraphQL-format API, at api.newrelic.com/graphiql. For more information, see the NerdGraph tutorial to create, query, and delete your parsing rules. Apache Source: logtype = 'apache' Grok: %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \\[%{HTTPDATE:timestamp}\\] \"(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})\" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer} %{QS:agent} Copy Results: clientip: The IP address of the client. verb: The HTTP verb ident: The user identity of the client making the request response: The HTTP status code of the response request: The URI and request being made httpversion: The HTTP version of the request rawrequest: The raw HTTP request if data is posted bytes: The number of bytes sent referrer: The HTTP referrer agent: The client's user agent Application Load Balancer Source: logtype = 'alb' Grok: ^%{NOTSPACE:type} %{TIMESTAMP_ISO8601:time} %{NOTSPACE:elb} %{NOTSPACE:client_ip}:%{NOTSPACE:client_port} ((%{NOTSPACE:target_ip}:%{NOTSPACE:target_port})|-) %{NOTSPACE:request_processing_time} %{NOTSPACE:target_processing_time} %{NOTSPACE:response_processing_time} %{NOTSPACE:elb_status_code} %{NOTSPACE:target_status_code} %{NOTSPACE:received_bytes} %{NOTSPACE:sent_bytes} \"%{DATA:request}\" \"%{DATA:user_agent}\" %{NOTSPACE:ssl_cipher} %{NOTSPACE:ssl_protocol} %{NOTSPACE:target_group_arn} \"%{DATA:trace_id}\" \"%{NOTSPACE:domain_name}\" \"%{NOTSPACE:chosen_cert_arn}\" %{NOTSPACE:matched_rule_priority} %{TIMESTAMP_ISO8601:request_creation_time} \"%{NOTSPACE:actions_executed}\" \"%{NOTSPACE:redirect_url}\" \"%{NOTSPACE:error_reason}\" (?:\"|)%{DATA:target_port_list}(?:\"|) (?:\"|)%{DATA:target_status_code_list}(?:\"|) \"%{NOTSPACE:classification}\" \"%{NOTSPACE:classification_reason}\" Copy Results: Field Definition type The type of request or connection. Possible values are: http: HTTP https: HTTP over SSL/TLS h2: HTTP/2 over SSL/TLS ws: WebSockets wss: WebSockets over SSL/TLS elb The resource ID of the load balancer. If you are parsing access log entries, note that resources IDs can contain forward slashes (/). client The IP address and port of the requesting client target The IP address and port of the target that processed this request. If the client didn't send a full request, the load balancer can't dispatch the request to a target, and this value is set to -. If the target is a Lambda function, this value is set to -. If the request is blocked by AWS WAF, this value is set to -, and the value of elb_status_code is set to 403. request_processing_time The total time elapsed (in seconds, with millisecond precision) from the time the load balancer received the request until the time it sent it to a target. This value is set to -1 if the load balancer can't dispatch the request to a target. This can happen if the target closes the connection before the idle timeout or if the client sends a malformed request. This value can also be set to -1 if the registered target does not respond before the idle timeout. target_processing_time The total time elapsed (in seconds, with millisecond precision) from the time the load balancer sent the request to a target until the target started to send the response headers. This value is set to -1 if the load balancer can't dispatch the request to a target. This can happen if the target closes the connection before the idle timeout or if the client sends a malformed request. This value can also be set to -1 if the registered target does not respond before the idle timeout. response_processing_time The total time elapsed (in seconds, with millisecond precision) from the time the load balancer received the response header from the target until it started to send the response to the client. This includes both the queuing time at the load balancer and the connection acquisition time from the load balancer to the client. This value is set to -1 if the load balancer can't send the request to a target. This can happen if the target closes the connection before the idle timeout or if the client sends a malformed request. elb_status_code The status code of the response from the load balancer target_status_code The status code of the response from the target. This value is recorded only if a connection was established to the target and the target sent a response. Otherwise, it is set to -. received_bytes The size of the request, in bytes, received from the client (requester). For HTTP requests, this includes the headers. For WebSockets, this is the total number of bytes received from the client on the connection. sent_bytes The size of the response, in bytes, sent to the client (requester). For HTTP requests, this includes the headers. For WebSockets, this is the total number of bytes sent to the client on the connection. method The HTTP verb of the request uri The URI the request was targeting http_version The HTTP version number of the request user_agent User-Agent string that identifies the client that originated the request, enclosed in double quotes. The string consists of one or more product identifiers, product/version. If the string is longer than 8 KB, it is truncated. ssl_cipher The SSL cipher. This value is set to - if the listener is not an HTTPS listener. ssl_protocol The SSL protocol. This value is set to - if the listener is not an HTTPS listener. target_group_arn The Amazon Resource Name (ARN) of the target group trace_id The contents of the X-Amzn-Trace-Id header, enclosed in double quotes domain_name The SNI domain provided by the client during the TLS handshake, enclosed in double quotes. This value is set to - if the client doesn't support SNI or the domain doesn't match a certificate and the default certificate is presented to the client. chosen_cert_arn The ARN of the certificate presented to the client, enclosed in double quotes. Set to session-reused if the session is reused. Set to - if the listener is not an HTTPS listener. matched_rule_priority The priority value of the rule that matched the request. If a rule matched, this is a value from 1 to 50000. If no rule matched and the default action was taken, this value is set to 0. If an error occurs during rules evaluation, it is set to -1. For any other error, it is set to -. request_creation_time The time when the load balancer received the request from the client, in ISO 8601 format. actions_executed The actions taken when processing the request, enclosed in double quotes. This value is a comma-separated list that can include the values described in actions_taken. If no action was taken, such as for a malformed request, this value is set to -. redirect_url The URL of the redirect target for the location header of the HTTP response, enclosed in double quotes. If no redirect actions were taken, this value is set to -. error_reason The error reason code, enclosed in double quotes. If the request failed, this is one of the error codes described in Error Reason Codes. If the actions taken do not include an authenticate action or the target is not a Lambda function, this value is set to -. Cloudfront Source: logtype = 'cloudfront-web' Grok: ^%{NOTSPACE:date}%{SPACE}%{NOTSPACE:time}%{SPACE}%{NOTSPACE:x_edge_location}%{SPACE}%{NOTSPACE:sc_bytes}%{SPACE}%{NOTSPACE:c_ip}%{SPACE}%{NOTSPACE:cs_method}%{SPACE}%{NOTSPACE:cs_host}%{SPACE}%{NOTSPACE:cs_uri_stem}%{SPACE}%{NOTSPACE:sc_status}%{SPACE}%{NOTSPACE:cs_referer}%{SPACE}%{NOTSPACE:cs_user_agent}%{SPACE}%{NOTSPACE:cs_uri_query}%{SPACE}%{NOTSPACE:cs_Cookie}%{SPACE}%{NOTSPACE:x_edge_result_type}%{SPACE}%{NOTSPACE:x_edge_request_id}%{SPACE}%{NOTSPACE:x_host_header}%{SPACE}%{NOTSPACE:cs_protocol}%{SPACE}%{NOTSPACE:cs_bytes}%{SPACE}%{NOTSPACE:time_taken}%{SPACE}%{NOTSPACE:x_forwarded_for}%{SPACE}%{NOTSPACE:ssl_protocol}%{SPACE}%{NOTSPACE:ssl_cipher}%{SPACE}%{NOTSPACE:x_edge_response_result_type}%{SPACE}%{NOTSPACE:cs_protocol_version}%{SPACE}%{NOTSPACE:fle_status}%{SPACE}%{NOTSPACE:fle_encrypted_fields}%{SPACE}%{NOTSPACE:c_port}%{SPACE}%{NOTSPACE:time_to_first_byte}%{SPACE}%{NOTSPACE:x_edge_detailed_result_type}%{SPACE}%{NOTSPACE:sc_content_type}%{SPACE}%{NOTSPACE:sc_content_len}%{SPACE}%{NOTSPACE:sc_range_start}%{SPACE}%{NOTSPACE:sc_range_end} Copy Results: Field Definition x_edge_location The edge location that served the request. Each edge location is identified by a three-letter code and an arbitrarily assigned number; for example, DFW3. The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.) sc_bytes The total number of bytes that CloudFront served to the viewer in response to the request, including headers; for example, 1045619. For WebSocket connections, this is the total number of bytes sent from the server to the client through the connection. c_ip The IP address of the viewer that made the request, either in IPv4 or IPv6 format. If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip is the IP address of the proxy or load balancer. See also X-Forwarded-For. cs_method The HTTP request method: DELETE, GET, HEAD, OPTIONS, PATCH, POST, or PUT. cs_host The domain name of the CloudFront distribution; for example, d111111abcdef8.cloudfront.net. cs_uri_stem The portion of the URI that identifies the path and object; for example, /images/cat.jpg. Question marks in URLs and query strings are not included. sc_status An HTTP status code; for example, 200. Status code 000 indicates the viewer closed the connection (for example, closed the browser tab) before CloudFront could respond to a request. If the viewer closes the connection after CloudFront starts to send the response, the log contains the applicable HTTP status code. cs_referer The name of the domain that originated the request. Common referrers include search engines, other websites that link directly to your objects, and your own website. cs_user_agent The value of the User-Agent header in the request. The User-Agent header identifies the source of the request, such as the type of device and browser that submitted the request, and which search engine if applicable. cs_uri_query The query string portion of the URI, if any. When a URI doesn't contain a query string, this field's value is a hyphen (-). cs_cookie The cookie header in the request, including name-value pairs and the associated attributes. If you enable cookie logging, CloudFront logs the cookies in all requests regardless of which cookies you choose to forward to the origin. If a request doesn't include a cookie header, this field's value is a hyphen (-). x_edge_result_type How CloudFront classifies the response after the last byte left the edge location. In some cases, the result type can change between the time that CloudFront is ready to send the response and the time that CloudFront has finished sending the response. x_edge_request_id An encrypted string that uniquely identifies a request. In the response header, this is x-amz-cf-id. x_host_header The value that the viewer included in the Host header for this request. This is the domain name in the request. If you're using the CloudFront domain name in your object URLs, this field contains that domain name. If you're using alternate domain names in your object URLs, such as http://example.com/logo.png, this field contains the alternate domain name, such as example.com. To use alternate domain names, you must add them to your distribution. cs_protocol The protocol that the viewer specified in the request: http, https, ws, or wss. cs_bytes The number of bytes of data that the viewer included in the request, including headers. For WebSocket connections, this is the total number of bytes sent from the client to the server on the connection. time_taken The number of seconds (to the thousandth of a second; for example, 0.002) between the time that a CloudFront edge server receives a viewer's request and the time that CloudFront writes the last byte of the response to the edge server's output queue as measured on the server. From the perspective of the viewer, the total time to get the full object will be longer than this value due to network latency and TCP buffering. x_forwarded_for If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip in field 5 is the IP address of the proxy or load balancer. In that case, this field is the IP address of the viewer that originated the request. This field contains IPv4 and IPv6 addresses as applicable. If the viewer did not use an HTTP proxy or a load balancer, the value of x_forwarded_for is a hyphen (-). ssl_protocol When cs_protocol in field 17 is https, this field contains the SSL/TLS protocol that the client and CloudFront negotiated for transmitting the request and response. Possible values include: SSLv3 TLSv1 TLSv1.1 TLSv1.2 When cs_protocol in field 17 is http, the value for this field is a hyphen (-). ssl_cipher When cs_protocol in field 17 is https, this field contains the SSL/TLS cipher that the client and CloudFront negotiated for encrypting the request and response. Possible values include: ECDHE-RSA-AES128-GCM-SHA256 ECDHE-RSA-AES128-SHA256 ECDHE-RSA-AES128-SHA ECDHE-RSA-AES256-GCM-SHA384 ECDHE-RSA-AES256-SHA384 ECDHE-RSA-AES256-SHA AES128-GCM-SHA256 AES256-GCM-SHA384 AES128-SHA256 AES256-SHA AES128-SHA DES-CBC3-SHA RC4-MD5 When cs_protocol in field 17 is http, the value for this field is a hyphen (-). x_edge_response_result_type How CloudFront classified the response just before returning the response to the viewer. Possible values include: Hit: CloudFront served the object to the viewer from the edge cache. RefreshHit: CloudFront found the object in the edge cache but it had expired, so CloudFront contacted the origin to verify that the cache has the latest version of the object. Miss: The request could not be satisfied by an object in the edge cache, so CloudFront forwarded the request to the origin server and returned the result to the viewer. LimitExceeded: The request was denied because a CloudFront limit was exceeded. CapacityExceeded: CloudFront returned a 503 error because the edge location didn't have enough capacity at the time of the request to serve the object. Error: Typically this means the request resulted in a client error (sc_status is 4xx) or a server error (sc_status is 5xx). If the value of x_edge_result_type is Error and the value of this field is not Error, the client disconnected before finishing the download. Redirect: CloudFront redirects from HTTP to HTTPS. If sc_status is 403 and you configured CloudFront to restrict the geographic distribution of your content, the request might have come from a restricted location. cs_protocol_version The HTTP version that the viewer specified in the request. Possible values include: HTTP/0.9 HTTP/1.0 HTTP/1.1 HTTP/2.0 fle_status When field-level encryption is configured for a distribution, this field contains a code that indicates whether the request body was successfully processed. If field-level encryption is not configured for the distribution, the value is a hyphen (-). fle-encrypted-fields The number of fields that CloudFront encrypted and forwarded to the origin. CloudFront streams the processed request to the origin as it encrypts data, so fle-encrypted-fields can have a value even if the value of fle-status is an error. If field-level encryption is not configured for the distribution, the value of fle-encrypted-fields is a hyphen (-). c_port The port number of the request from the viewer. time_to_first_byte The number of seconds between receiving the request and writing the first byte of the response, as measured on the server. x_edge_detailed_result_type When x-edge-result-type is not Error, this field contains the same value as x-edge-result-type. When x-edge-result-type is Error, this field contains the specific type of error. sc_content_type The value of the HTTP Content-Type header of the response. sc_content_len The value of the HTTP Content-Length header of the response. sc_range_start When the response contains the HTTP Content-Range header, this field contains the range start value. sc-range-end When the response contains the HTTP Content-Range header, this field contains the range end value. Elastic Load Balancer Source: logtype = 'elb' Grok: ^%{TIMESTAMP_ISO8601:time} %{NOTSPACE:elb} %{NOTSPACE:client_ip}:%{NOTSPACE:client_port} ((%{NOTSPACE:backend_ip}:%{NOTSPACE:backend_port})|-) %{NOTSPACE:request_processing_time} %{NOTSPACE:backend_processing_time} %{NOTSPACE:response_processing_time} %{NOTSPACE:elb_status_code} %{NOTSPACE:backend_status_code} %{NOTSPACE:received_bytes} %{NOTSPACE:sent_bytes} \"%{DATA:request}\" \"%{DATA:user_agent}\" %{NOTSPACE:ssl_cipher} %{NOTSPACE:ssl_protocol} Copy Results: Field Definition x_edge_location The edge location that served the request. Each edge location is identified by a three-letter code and an arbitrarily assigned number; for example, DFW3. The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.) sc_bytes The total number of bytes that CloudFront served to the viewer in response to the request, including headers; for example, 1045619. For WebSocket connections, this is the total number of bytes sent from the server to the client through the connection. c_ip The IP address of the viewer that made the request. If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip is the IP address of the proxy or load balancer. cs_method The HTTP request method: DELETE, GET, HEAD, OPTIONS, PATCH, POST, or PUT. cs_host The domain name of the CloudFront distribution; for example, d111111abcdef8.cloudfront.net. cs_uri_stem The portion of the URI that identifies the path and object; for example, /images/cat.jpg. Question marks (?) in URLs and query strings are not included in the log. sc_status An HTTP status code (for example, 200). Status code 000 indicates that the viewer closed the connection (for example, closed the browser tab) before CloudFront could respond to a request. If the viewer closes the connection after CloudFront starts to send the response, the log contains the applicable HTTP status code. cs_referer he name of the domain that originated the request. Common referrers include search engines, other websites that link directly to your objects, and your own website. cs_user_agent The value of the User-Agent header in the request. The User-Agent header identifies the source of the request, such as the type of device and browser that submitted the request and which search engine if applicable. cs_uri_query The query string portion of the URI, if any. When a URI doesn't contain a query string, this field's value is a hyphen (-). cs_cookie The cookie header in the request, including name-value pairs and the associated attributes. If you enable cookie logging, CloudFront logs the cookies in all requests, regardless of which cookies you choose to forward to the origin. If a request doesn't include a cookie header, this field's value is a hyphen (-). x_edge_result_type How CloudFront classifies the response after the last byte left the edge location. In some cases, the result type can change between the time that CloudFront is ready to send the response and the time that CloudFront has finished sending the response. x_edge_request_id An encrypted string that uniquely identifies a request. In the response header, this is x-amz-cf-id. x_host_header The value that the viewer included in the Host header for this request. This is the domain name in the request. If you're using the CloudFront domain name in your object URLs, this field contains that domain name. If you're using alternate domain names in your object URLs, such as [http://example.com/logo.png, this field contains the alternate domain name, such as example.com. To use alternate domain names, you must add them to your distribution. cs_protocol The protocol that the viewer specified in the request: http, https, ws, or wss. cs_bytes The number of bytes of data that the viewer included in the request, including headers. For WebSocket connections, this is the total number of bytes sent from the client to the server on the connection. time_taken The number of seconds (to the thousandth of a second; for example, 0.002) between the time that a CloudFront edge server receives a viewer's request and the time that CloudFront writes the last byte of the response to the edge server's output queue as measured on the server. From the perspective of the viewer, the total time to get the full object will be longer than this value due to network latency and TCP buffering. x_forwarded_for If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip in field 5 is the IP address of the proxy or load balancer. In that case, this field is the IP address of the viewer that originated the request. This field contains IPv4 and IPv6 addresses as applicable. If the viewer did not use an HTTP proxy or a load balancer, the value of x_forwarded_for is a hyphen (-). ssl_protocol When cs_protocol in field 17 is https, this field contains the SSL/TLS protocol that the client and CloudFront negotiated for transmitting the request and response. Possible values include: SSLv3 TLSv1 TLSv1.1 TLSv1.2 When cs_protocol in field 17 is http, the value for this field is a hyphen (-). ssl_cipher When cs_protocol in field 17 is https, this field contains the SSL/TLS cipher that the client and CloudFront negotiated for encrypting the request and response. Possible values include: ECDHE-RSA-AES128-GCM-SHA256 ECDHE-RSA-AES128-SHA256 ECDHE-RSA-AES128-SHA ECDHE-RSA-AES256-GCM-SHA384 ECDHE-RSA-AES256-SHA384 ECDHE-RSA-AES256-SHA AES128-GCM-SHA256 AES256-GCM-SHA384 AES128-SHA256 AES256-SHA AES128-SHA DES-CBC3-SHA RC4-MD5 When cs_protocol is http, the value for this field is a hyphen (-). x_edge_response_result_type How CloudFront classified the response just before returning the response to the viewer. Possible values include: Hit: CloudFront served the object to the viewer from the edge cache. RefreshHit: CloudFront found the object in the edge cache but it had expired, so CloudFront contacted the origin to verify that the cache has the latest version of the object. Miss: The request could not be satisfied by an object in the edge cache, so CloudFront forwarded the request to the origin server and returned the result to the viewer. LimitExceeded: The request was denied because a CloudFront limit was exceeded. CapacityExceeded: CloudFront returned a 503 error because the edge location didn't have enough capacity at the time of the request to serve the object. Error: Typically this means the request resulted in a client error (sc_status is 4xx) or a server error (sc_status is 5xx). If the value of x_edge_result_type is Error and the value of this field is not Error, the client disconnected before finishing the download. Redirect: CloudFront redirects from HTTP to HTTPS. If sc_status is 403 and you configured CloudFront to restrict the geographic distribution of your content, the request might have come from a restricted location. cs_protocol_version The HTTP version that the viewer specified in the request. Possible values include: HTTP/0.9 HTTP/1.0 HTTP/1.1 HTTP/2.0 fle_status When field-level encryption is configured for a distribution, this field contains a code that indicates whether the request body was successfully processed. If field-level encryption is not configured for the distribution, the value of this field is a hyphen (-). When CloudFront successfully processes the request body, encrypts values in the specified fields, and forwards the request to the origin, the value of this field is Processed. The value of x_edge_result_type can still indicate a client-side or server-side error in this case. If the request exceeds a field-level encryption limit, fle-status contains one of the following error codes, and CloudFront returns HTTP status code 400 to the viewer. fle-encrypted-fields The number of fields that CloudFront encrypted and forwarded to the origin. CloudFront streams the processed request to the origin as it encrypts data, so fle_encrypted_fields can have a value even if the value of fle_status is an error. If field-level encryption is not configured for the distribution, the value of fle_encrypted_fields is a hyphen (-). c_port The port number of the request from the viewer. time_to_first_byte The number of seconds between receiving the request and writing the first byte of the response, as measured on the server. x_edge_detailed_result_type When x_edge_result_type is not Error, this field contains the same value as x_edge_result_type. When x_edge_result_type is Error, this field contains the specific type of error. sc_content_type The value of the HTTP Content-Type header of the response. sc_content_len The value of the HTTP Content-Length header of the response. sc_range_start When the response contains the HTTP Content-Range header, this field contains the range start value. sc-range-end When the response contains the HTTP Content-Range header, this field contains the range end value. Microsoft IIS Source: logtype = 'iis_w3c' Grok: %{TIMESTAMP_ISO8601:log_timestamp} %{NOTSPACE:server_ip} %{WORD:method} %{NOTSPACE:uri} %{NOTSPACE:uri_query} %{NOTSPACE:server_port} %{NOTSPACE:username} %{NOTSPACE:client_ip} %{NOTSPACE:user_agent} %{NOTSPACE:referer} %{NOTSPACE:status} %{NOTSPACE:substatus} %{NOTSPACE:win32_status} %{NOTSPACE:time_taken} Copy Monit Source: logtype = 'monit' Grok: \\\\[%{NOTSPACE:tz} %{SYSLOGTIMESTAMP:nr_timestamp}\\\\] %{WORD:state}%{SPACE}: %{GREEDYDATA:message} Copy Results: state: The severity of the log line message: The message MySQL Error Source: logtype = 'mysql-error' Grok: \\\\[%{WORD:log_level}\\\\] Copy Results: log_level: The severity of the log line NGINX Source: logtype = 'nginx' Grok: %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \\[%{HTTPDATE:timestamp}\\] \"(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})\" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer} %{QS:agent} Copy Results: clientip: The IP address of the client verb: The HTTP verb ident: The user identity of the client making the request response: The HTTP status code of the response request: The URI and request being made httpversion: The HTTP version of the request rawrequest: The raw HTTP request if data is posted bytes: The number of bytes sent referrer: The HTTP referrer agent: The client's user agent NGINX Error Source: logtype = 'nginx-error' Grok: ^(?<timestamp>%{YEAR:year}[./-]%{MONTHNUM:month}[./-]%{MONTHDAY:day}[- ]%{TIME:time}) \\\\[%{LOGLEVEL:severity}\\\\] %{POSINT:pid}#%{NUMBER}: %{GREEDYDATA:errormessage}(?:, client: (?<client>%{IP:clientip}|%{HOSTNAME:hostname}))(?:, server: %{IPORHOSTORUNDERSCORE:server})(?:, request: %{QS:request})?(?:, upstream: \\\"%{URI:upstream}\\\")?(?:, host: %{QS:host})?(?:, referrer: \\\"%{URI:referrer}\\\")?$ Copy Results: severity: The severity of the log line pid: The server process ID errormessage: The error message clientip: The IP address of the calling client server: The server IP address request: The full request upstream: The upstream URI host: The server's hostname referrer: The HTTP referrer Route 53 Source: logtype = 'route-53' Grok: %{NUMBER:log_format_version} %{TIMESTAMP_ISO8601} %{WORD:zone_id} %{IPORHOST:query} %{WORD:query_type} %{WORD:response_code} %{WORD:protocol} %{WORD:edge_location} %{IP:resolver_ip} %{GREEDYDATA:edns_client_subnet} Copy Results: log_format_version: A versioned format for the log. zone_id: The ID of the hosted zone that is associated with all the DNS queries in this log. query: The domain or subdomain that was specified in the request. query_type: Either the DNS record type that was specified in the request, or ANY. response_code: The DNS response code that Route 53 returned in response to the DNS query. protocol: The protocol that was used to submit the query, either TCP or UDP. edge_location: The Route 53 edge location that responded to the query. Each edge location is identified by a three-letter code and an arbitrary number; for example, DFW3. The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.) resolver_ip: The IP address of the DNS resolver that submitted the request to Route 53. edns_client_subnet: A partial IP address for the client that the request originated from, if available from the DNS resolver. Syslog RFC-5424 Source: logtype = 'syslog-rfc5424' Grok: <%{NONNEGINT:pri}>%{NONNEGINT:version} +(?:%{TIMESTAMP_ISO8601:log.timestamp}|-) +(?:%{HOSTNAME:hostname}|-) +(?:\\\\-|%{NOTSPACE:app.name}) +(?:\\\\-|%{NOTSPACE:procid}) (?:\\\\-|%{NOTSPACE:msgid}) +(?:\\[%{DATA:structured.data}\\]|-|) +%{GREEDYDATA:message} Copy Results: pri: The priority represents both the message facility and severity. version: Syslog protocol version. log.timestamp: Original timestamp. hostname: The machine that originally sent the Syslog message. app.name: The device or application that originated the message. procid: The process name or process ID associated with a Syslog system. msgid: Identifies the type of message. structured.data: Structured data string value. sd.<var>sd-id</var>.<var>sd-param-name</var>: The structured.data content is also parsed into separate attributes following a predefined naming convention: sd.<var>sd-id</var>.<var>sd-param-name</var>. See the structured data parsing examples, which follow. message: Free-form message that provides information about the event. Structured data parsing examples: The structured data [example one=\"1\" two=\"2\"] would be parsed into two different attributes: sd.example.one: \"1\" sd.example.two: \"2\" Copy If the same structured data block contains duplicate param names, it also appends an index-based suffix on the attribute name. For example, the structured data [example number=\"1\" number=\"2\"] would be parsed as: sd.example.number.0: \"1\" sd.example.number.1: \"2\" Copy For structured data with enterprise numbers assigned, an extra attribute is also parsed. For example, the structured data [example@123 number=\"1\"] would be parsed as: sd.example.enterprise.number: 123 sd.example.number: \"1\" Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.79697,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Built-in <em>log</em> parsing rules",
        "sections": "Built-in <em>log</em> parsing rules",
        "tags": "<em>Log</em> <em>management</em>",
        "body": " RFC-5424 Source: logtype = &#x27;syslog-rfc5424&#x27; Grok: &lt;%{NONNEGINT:pri}&gt;%{NONNEGINT:version} +(?:%{TIMESTAMP_ISO8601:<em>log</em>.timestamp}|-) +(?:%{HOSTNAME:hostname}|-) +(?:\\\\-|%{NOTSPACE:app.name}) +(?:\\\\-|%{NOTSPACE:procid}) (?:\\\\-|%{NOTSPACE:msgid}) +(?:\\[%{<em>DATA:structured.data</em>}\\]|-|) +%{GREEDYDATA:message"
      },
      "id": "603e7b9164441f1b2d4e8872"
    }
  ],
  "/docs/logs/ui-data/use-logs-ui": [
    {
      "sections": [
        "Find data in long logs (blobs)",
        "How blobs work",
        "Tip",
        "Query your data for blobs",
        "Data retention for long logs"
      ],
      "title": "Find data in long logs (blobs)",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "413651f55060d47b3b2c3a939d9f4f576467e405",
      "image": "https://docs.newrelic.com/static/25249afab9ba5695a0764e676d14dfb3/c1b63/log-blob-query.png",
      "url": "https://docs.newrelic.com/docs/logs/ui-data/long-logs-blobs/",
      "published_at": "2021-12-04T22:05:37Z",
      "updated_at": "2021-11-14T08:46:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Extensive log data can help you troubleshoot issues. But what if an attribute in your log contains thousands of characters? How much of this data can New Relic store? And how can you find useful information in all this data? How blobs work For lengthy string values that are longer than can be stored in NRDB (4,094 characters), we store the long string in three pieces: Long log sections Description First 4,094 characters The first 4,094 characters are stored in a Log event field with the same name. So a long message value would have its first 4,094 characters stored in a message field. Next 128,000 UTF-8 bytes The next 128,000 UTF-8 bytes of the string are stored in a blob field with the name with newrelic.ext. prepended. So a long message value would have characters past the first 4,094 characters stored in a newrelic.ext.message field as a blob. The actual number of characters stored depends on the UTF-8 representation of the characters. UTF-8 represents Unicode characters as one to four bytes, so we will store anywhere between 32,000 and 128,000 characters past the first 4,094 characters. Remaining characters Any characters past 4,094 characters plus 128,000 bytes are dropped and not stored. So the long message field would be stored as: message: <first 4,094 characters as a string> newrelic.ext.message: <next 128,000 bytes as a 'blob'> Copy Tip You can search the first 4,094 characters of a string attribute. You can also create alerts for the first 4,094 characters. However, since 'blob' storage is not searchable, text beyond the first 4,094 characters is not searchable or alertable. Query your data for blobs To query for any log data in New Relic, run the following query: SELECT * FROM Log Copy To expand the blob data, run the following query, using message or any other attribute. Be sure to enclose the blob's attribute with backticks. For example: SELECT message, another-attribute, blob(`newrelic.ext.message`), blob(`newrelic.ext.another-attribute) FROM Log Copy To query extended blob data in your logs, be sure to include backticks in your attribute's blob syntax. This expands the data in the blob so you can see (but not search) it. For example, New Relic returns: { \"message\": <first 4,094 characters> \"newrelic.ext.message\": <the next 128,000 bytes as Base64> \"another-attribute\": <first 4,094 characters> \"newrelic.ext.another-attribute\": <the next 128,000 bytes as Base64> } Copy The Logs UI automatically stitches the original value back together when looking at the Log Detail View. When querying using NRQL directly, you need to manually stitch the information together by: Decoding the Base64 of the newrelic.ext. attribute value Converting the resulting UTF-8 into a string Appending that string to the first 4,094 characters in the \"main\" attribute Data retention for long logs NRDB retains your blob records for a month. If you have existing long log messages stored as LogExtendedRecord, that data will also continue to be available for a month in NRDB. After a month passes, no more new LogExtendedRecord attributes will be created. They will all be stored in NRDB as blobs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.90706,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Find <em>data</em> in long <em>logs</em> (blobs)",
        "sections": "Find <em>data</em> in long <em>logs</em> (blobs)",
        "tags": "<em>Log</em> <em>management</em>",
        "body": " other attribute. Be sure to enclose the blob&#x27;s attribute with backticks. For example: SELECT message, another-attribute, blob(`newrelic.ext.message`), blob(`newrelic.ext.another-attribute) FROM <em>Log</em> Copy To query extended blob <em>data</em> in your <em>logs</em>, be sure to include backticks in your attribute&#x27;s blob"
      },
      "id": "6150569228ccbcf314f21423"
    },
    {
      "sections": [
        "Organize data with partitions",
        "Plan your partition",
        "Important",
        "Required roles and permissions",
        "Sizing and organizing a partition",
        "Choosing a namespace",
        "Create partition rules",
        "Search data partitions",
        "Manage data partitions programatically with NerdGraph"
      ],
      "title": "Organize data with partitions",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "620ba43370a8ca4900a02cd4ccc6fefa7f5cf8d7",
      "image": "https://docs.newrelic.com/static/7815845d8068377477aa26f8571d5907/c1b63/log-partitions-crop.png",
      "url": "https://docs.newrelic.com/docs/logs/ui-data/data-partitions/",
      "published_at": "2021-12-04T22:05:01Z",
      "updated_at": "2021-11-14T07:18:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Data partitions are a way to group or organize log data for faster and more efficient querying. When a query targets a single partition, New Relic's Logs UI: Scans less unrelated data. Returns results faster. Accounts can have multiple partitions, and multiple partitions can be queried at the same time. Data partitions also allow data to be mapped to an alternative, or “secondary” namespace with a fixed 30-day retention. This is useful for maintaining compliance with privacy-centric regulations and standards like the General Data Protection Regulation (GDPR). Plan your partition Before you start creating partitions, make sure you have the right permissions and a partition plan. Important Logs are routed to partitions during the ingestion process, before data is written to NRDB. Partition rules will not affect logs that were ingested before the rule was created. Required roles and permissions Users require an Admin role to create and modify partition rules. Sizing and organizing a partition You can gain significant performance improvements with proper use of data partitions. Organizing your data into discrete partitions enables you to query them separately or all together. The goals of partitioning your data should be: Create data partitions that align with concepts in your environment or organization that are static or change infrequently (for example, by business unit, team, environment, service, etc.). Ensure each partition remains below 1 TB of daily ingest for optimal performance. Having more partitions allows for more targeted searches, but creating too many partitions can make logs hard to find and increase administrative overhead. Finding the right balance is important. We support 100 partitions maximum per account, but the optimal number for most accounts is 10 to 15 partitions. Choosing a namespace A partition’s namespace determines its retention period. We offer two retention options: Standard: The account’s default retention determined by your New Relic subscription. This is the maximum retention period available in your account and is the namespace you'll select for most of your partitions. Secondary: 30-day retention. All logs sent to a partition that's a member of the Secondary namespace will be purged on a rolling basis 30 days after having been ingested. Secondary retention is not a cost control mechanism; data is billed on ingest. Create partition rules From the left nav in the Logs UI, select Data partitions, then create a Log_ partition name with the retention namespace, optional description, and matching criteria. To create a new partition rule: Go to one.newrelic.com > Logs. From Manage Data on the left nav of the Logs UI, click Data partitions, then click Create partition rule. Define a Partition name as an alphanumeric string that begins with Log_. Add an optional description. Select the retention namespace for the partition. Set your rule's Matching criteria: Select EQUALS to target logs that match your criteria exactly, or select LIKE to apply a fuzzy match. Click the Enable Rule slider, and click Create. To view a list of data partitions: From Manage Data on the left nav of the Logs UI, click Data partitions. Search data partitions The default partition for all Logs accounts is Log. Any log that is not affected by a partition rule will be stored in the Log partition by default. You can query multiple partitions simultaneously. For best performance, select the smallest number of partitions possible. To search data partitions: From Views and Attributes on the left nav of the Logs UI, click Select partitions. Click one or more partitions you want to query, or search for a partition name. Click Query logs to search your selected partitions. Manage data partitions programatically with NerdGraph If you want to manage your data partitions programatically, you can use NerdGraph, our GraphQL-format API. This tutorial shows how to query, create, and delete data partitions using our API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.79996,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Organize <em>data</em> with partitions",
        "sections": "<em>Manage</em> <em>data</em> partitions programatically with NerdGraph",
        "tags": "<em>Log</em> <em>management</em>",
        "body": "<em>Data</em> partitions are a way to group or organize <em>log</em> <em>data</em> for faster and more efficient querying. When a query targets a single partition, New Relic&#x27;s <em>Logs</em> <em>UI</em>: Scans less unrelated <em>data</em>. Returns results faster. Accounts can have multiple partitions, and multiple partitions can be queried at the same"
      },
      "id": "6087e311e7b9d2f90ba5c6a4"
    },
    {
      "sections": [
        "Built-in log parsing rules",
        "Apache",
        "Application Load Balancer",
        "Cloudfront",
        "Elastic Load Balancer",
        "Microsoft IIS",
        "Monit",
        "MySQL Error",
        "NGINX",
        "NGINX Error",
        "Route 53",
        "Syslog RFC-5424"
      ],
      "title": "Built-in log parsing rules",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "ae238defe10615c8767ea24f74b3c416190f4b49",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/ui-data/built-log-parsing-rules/",
      "published_at": "2021-12-04T22:06:50Z",
      "updated_at": "2021-11-14T07:16:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic can parse common log formats according to built-in rules, so that you don't have to create your own parsing rules. Here are the log parsing rules, their Grok patterns, and what fields are parsed. To enable built-in log parsing, see our documentation for adding the logtype attribute. To manage your parsing rules programmatically, use NerdGraph, our GraphQL-format API, at api.newrelic.com/graphiql. For more information, see the NerdGraph tutorial to create, query, and delete your parsing rules. Apache Source: logtype = 'apache' Grok: %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \\[%{HTTPDATE:timestamp}\\] \"(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})\" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer} %{QS:agent} Copy Results: clientip: The IP address of the client. verb: The HTTP verb ident: The user identity of the client making the request response: The HTTP status code of the response request: The URI and request being made httpversion: The HTTP version of the request rawrequest: The raw HTTP request if data is posted bytes: The number of bytes sent referrer: The HTTP referrer agent: The client's user agent Application Load Balancer Source: logtype = 'alb' Grok: ^%{NOTSPACE:type} %{TIMESTAMP_ISO8601:time} %{NOTSPACE:elb} %{NOTSPACE:client_ip}:%{NOTSPACE:client_port} ((%{NOTSPACE:target_ip}:%{NOTSPACE:target_port})|-) %{NOTSPACE:request_processing_time} %{NOTSPACE:target_processing_time} %{NOTSPACE:response_processing_time} %{NOTSPACE:elb_status_code} %{NOTSPACE:target_status_code} %{NOTSPACE:received_bytes} %{NOTSPACE:sent_bytes} \"%{DATA:request}\" \"%{DATA:user_agent}\" %{NOTSPACE:ssl_cipher} %{NOTSPACE:ssl_protocol} %{NOTSPACE:target_group_arn} \"%{DATA:trace_id}\" \"%{NOTSPACE:domain_name}\" \"%{NOTSPACE:chosen_cert_arn}\" %{NOTSPACE:matched_rule_priority} %{TIMESTAMP_ISO8601:request_creation_time} \"%{NOTSPACE:actions_executed}\" \"%{NOTSPACE:redirect_url}\" \"%{NOTSPACE:error_reason}\" (?:\"|)%{DATA:target_port_list}(?:\"|) (?:\"|)%{DATA:target_status_code_list}(?:\"|) \"%{NOTSPACE:classification}\" \"%{NOTSPACE:classification_reason}\" Copy Results: Field Definition type The type of request or connection. Possible values are: http: HTTP https: HTTP over SSL/TLS h2: HTTP/2 over SSL/TLS ws: WebSockets wss: WebSockets over SSL/TLS elb The resource ID of the load balancer. If you are parsing access log entries, note that resources IDs can contain forward slashes (/). client The IP address and port of the requesting client target The IP address and port of the target that processed this request. If the client didn't send a full request, the load balancer can't dispatch the request to a target, and this value is set to -. If the target is a Lambda function, this value is set to -. If the request is blocked by AWS WAF, this value is set to -, and the value of elb_status_code is set to 403. request_processing_time The total time elapsed (in seconds, with millisecond precision) from the time the load balancer received the request until the time it sent it to a target. This value is set to -1 if the load balancer can't dispatch the request to a target. This can happen if the target closes the connection before the idle timeout or if the client sends a malformed request. This value can also be set to -1 if the registered target does not respond before the idle timeout. target_processing_time The total time elapsed (in seconds, with millisecond precision) from the time the load balancer sent the request to a target until the target started to send the response headers. This value is set to -1 if the load balancer can't dispatch the request to a target. This can happen if the target closes the connection before the idle timeout or if the client sends a malformed request. This value can also be set to -1 if the registered target does not respond before the idle timeout. response_processing_time The total time elapsed (in seconds, with millisecond precision) from the time the load balancer received the response header from the target until it started to send the response to the client. This includes both the queuing time at the load balancer and the connection acquisition time from the load balancer to the client. This value is set to -1 if the load balancer can't send the request to a target. This can happen if the target closes the connection before the idle timeout or if the client sends a malformed request. elb_status_code The status code of the response from the load balancer target_status_code The status code of the response from the target. This value is recorded only if a connection was established to the target and the target sent a response. Otherwise, it is set to -. received_bytes The size of the request, in bytes, received from the client (requester). For HTTP requests, this includes the headers. For WebSockets, this is the total number of bytes received from the client on the connection. sent_bytes The size of the response, in bytes, sent to the client (requester). For HTTP requests, this includes the headers. For WebSockets, this is the total number of bytes sent to the client on the connection. method The HTTP verb of the request uri The URI the request was targeting http_version The HTTP version number of the request user_agent User-Agent string that identifies the client that originated the request, enclosed in double quotes. The string consists of one or more product identifiers, product/version. If the string is longer than 8 KB, it is truncated. ssl_cipher The SSL cipher. This value is set to - if the listener is not an HTTPS listener. ssl_protocol The SSL protocol. This value is set to - if the listener is not an HTTPS listener. target_group_arn The Amazon Resource Name (ARN) of the target group trace_id The contents of the X-Amzn-Trace-Id header, enclosed in double quotes domain_name The SNI domain provided by the client during the TLS handshake, enclosed in double quotes. This value is set to - if the client doesn't support SNI or the domain doesn't match a certificate and the default certificate is presented to the client. chosen_cert_arn The ARN of the certificate presented to the client, enclosed in double quotes. Set to session-reused if the session is reused. Set to - if the listener is not an HTTPS listener. matched_rule_priority The priority value of the rule that matched the request. If a rule matched, this is a value from 1 to 50000. If no rule matched and the default action was taken, this value is set to 0. If an error occurs during rules evaluation, it is set to -1. For any other error, it is set to -. request_creation_time The time when the load balancer received the request from the client, in ISO 8601 format. actions_executed The actions taken when processing the request, enclosed in double quotes. This value is a comma-separated list that can include the values described in actions_taken. If no action was taken, such as for a malformed request, this value is set to -. redirect_url The URL of the redirect target for the location header of the HTTP response, enclosed in double quotes. If no redirect actions were taken, this value is set to -. error_reason The error reason code, enclosed in double quotes. If the request failed, this is one of the error codes described in Error Reason Codes. If the actions taken do not include an authenticate action or the target is not a Lambda function, this value is set to -. Cloudfront Source: logtype = 'cloudfront-web' Grok: ^%{NOTSPACE:date}%{SPACE}%{NOTSPACE:time}%{SPACE}%{NOTSPACE:x_edge_location}%{SPACE}%{NOTSPACE:sc_bytes}%{SPACE}%{NOTSPACE:c_ip}%{SPACE}%{NOTSPACE:cs_method}%{SPACE}%{NOTSPACE:cs_host}%{SPACE}%{NOTSPACE:cs_uri_stem}%{SPACE}%{NOTSPACE:sc_status}%{SPACE}%{NOTSPACE:cs_referer}%{SPACE}%{NOTSPACE:cs_user_agent}%{SPACE}%{NOTSPACE:cs_uri_query}%{SPACE}%{NOTSPACE:cs_Cookie}%{SPACE}%{NOTSPACE:x_edge_result_type}%{SPACE}%{NOTSPACE:x_edge_request_id}%{SPACE}%{NOTSPACE:x_host_header}%{SPACE}%{NOTSPACE:cs_protocol}%{SPACE}%{NOTSPACE:cs_bytes}%{SPACE}%{NOTSPACE:time_taken}%{SPACE}%{NOTSPACE:x_forwarded_for}%{SPACE}%{NOTSPACE:ssl_protocol}%{SPACE}%{NOTSPACE:ssl_cipher}%{SPACE}%{NOTSPACE:x_edge_response_result_type}%{SPACE}%{NOTSPACE:cs_protocol_version}%{SPACE}%{NOTSPACE:fle_status}%{SPACE}%{NOTSPACE:fle_encrypted_fields}%{SPACE}%{NOTSPACE:c_port}%{SPACE}%{NOTSPACE:time_to_first_byte}%{SPACE}%{NOTSPACE:x_edge_detailed_result_type}%{SPACE}%{NOTSPACE:sc_content_type}%{SPACE}%{NOTSPACE:sc_content_len}%{SPACE}%{NOTSPACE:sc_range_start}%{SPACE}%{NOTSPACE:sc_range_end} Copy Results: Field Definition x_edge_location The edge location that served the request. Each edge location is identified by a three-letter code and an arbitrarily assigned number; for example, DFW3. The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.) sc_bytes The total number of bytes that CloudFront served to the viewer in response to the request, including headers; for example, 1045619. For WebSocket connections, this is the total number of bytes sent from the server to the client through the connection. c_ip The IP address of the viewer that made the request, either in IPv4 or IPv6 format. If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip is the IP address of the proxy or load balancer. See also X-Forwarded-For. cs_method The HTTP request method: DELETE, GET, HEAD, OPTIONS, PATCH, POST, or PUT. cs_host The domain name of the CloudFront distribution; for example, d111111abcdef8.cloudfront.net. cs_uri_stem The portion of the URI that identifies the path and object; for example, /images/cat.jpg. Question marks in URLs and query strings are not included. sc_status An HTTP status code; for example, 200. Status code 000 indicates the viewer closed the connection (for example, closed the browser tab) before CloudFront could respond to a request. If the viewer closes the connection after CloudFront starts to send the response, the log contains the applicable HTTP status code. cs_referer The name of the domain that originated the request. Common referrers include search engines, other websites that link directly to your objects, and your own website. cs_user_agent The value of the User-Agent header in the request. The User-Agent header identifies the source of the request, such as the type of device and browser that submitted the request, and which search engine if applicable. cs_uri_query The query string portion of the URI, if any. When a URI doesn't contain a query string, this field's value is a hyphen (-). cs_cookie The cookie header in the request, including name-value pairs and the associated attributes. If you enable cookie logging, CloudFront logs the cookies in all requests regardless of which cookies you choose to forward to the origin. If a request doesn't include a cookie header, this field's value is a hyphen (-). x_edge_result_type How CloudFront classifies the response after the last byte left the edge location. In some cases, the result type can change between the time that CloudFront is ready to send the response and the time that CloudFront has finished sending the response. x_edge_request_id An encrypted string that uniquely identifies a request. In the response header, this is x-amz-cf-id. x_host_header The value that the viewer included in the Host header for this request. This is the domain name in the request. If you're using the CloudFront domain name in your object URLs, this field contains that domain name. If you're using alternate domain names in your object URLs, such as http://example.com/logo.png, this field contains the alternate domain name, such as example.com. To use alternate domain names, you must add them to your distribution. cs_protocol The protocol that the viewer specified in the request: http, https, ws, or wss. cs_bytes The number of bytes of data that the viewer included in the request, including headers. For WebSocket connections, this is the total number of bytes sent from the client to the server on the connection. time_taken The number of seconds (to the thousandth of a second; for example, 0.002) between the time that a CloudFront edge server receives a viewer's request and the time that CloudFront writes the last byte of the response to the edge server's output queue as measured on the server. From the perspective of the viewer, the total time to get the full object will be longer than this value due to network latency and TCP buffering. x_forwarded_for If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip in field 5 is the IP address of the proxy or load balancer. In that case, this field is the IP address of the viewer that originated the request. This field contains IPv4 and IPv6 addresses as applicable. If the viewer did not use an HTTP proxy or a load balancer, the value of x_forwarded_for is a hyphen (-). ssl_protocol When cs_protocol in field 17 is https, this field contains the SSL/TLS protocol that the client and CloudFront negotiated for transmitting the request and response. Possible values include: SSLv3 TLSv1 TLSv1.1 TLSv1.2 When cs_protocol in field 17 is http, the value for this field is a hyphen (-). ssl_cipher When cs_protocol in field 17 is https, this field contains the SSL/TLS cipher that the client and CloudFront negotiated for encrypting the request and response. Possible values include: ECDHE-RSA-AES128-GCM-SHA256 ECDHE-RSA-AES128-SHA256 ECDHE-RSA-AES128-SHA ECDHE-RSA-AES256-GCM-SHA384 ECDHE-RSA-AES256-SHA384 ECDHE-RSA-AES256-SHA AES128-GCM-SHA256 AES256-GCM-SHA384 AES128-SHA256 AES256-SHA AES128-SHA DES-CBC3-SHA RC4-MD5 When cs_protocol in field 17 is http, the value for this field is a hyphen (-). x_edge_response_result_type How CloudFront classified the response just before returning the response to the viewer. Possible values include: Hit: CloudFront served the object to the viewer from the edge cache. RefreshHit: CloudFront found the object in the edge cache but it had expired, so CloudFront contacted the origin to verify that the cache has the latest version of the object. Miss: The request could not be satisfied by an object in the edge cache, so CloudFront forwarded the request to the origin server and returned the result to the viewer. LimitExceeded: The request was denied because a CloudFront limit was exceeded. CapacityExceeded: CloudFront returned a 503 error because the edge location didn't have enough capacity at the time of the request to serve the object. Error: Typically this means the request resulted in a client error (sc_status is 4xx) or a server error (sc_status is 5xx). If the value of x_edge_result_type is Error and the value of this field is not Error, the client disconnected before finishing the download. Redirect: CloudFront redirects from HTTP to HTTPS. If sc_status is 403 and you configured CloudFront to restrict the geographic distribution of your content, the request might have come from a restricted location. cs_protocol_version The HTTP version that the viewer specified in the request. Possible values include: HTTP/0.9 HTTP/1.0 HTTP/1.1 HTTP/2.0 fle_status When field-level encryption is configured for a distribution, this field contains a code that indicates whether the request body was successfully processed. If field-level encryption is not configured for the distribution, the value is a hyphen (-). fle-encrypted-fields The number of fields that CloudFront encrypted and forwarded to the origin. CloudFront streams the processed request to the origin as it encrypts data, so fle-encrypted-fields can have a value even if the value of fle-status is an error. If field-level encryption is not configured for the distribution, the value of fle-encrypted-fields is a hyphen (-). c_port The port number of the request from the viewer. time_to_first_byte The number of seconds between receiving the request and writing the first byte of the response, as measured on the server. x_edge_detailed_result_type When x-edge-result-type is not Error, this field contains the same value as x-edge-result-type. When x-edge-result-type is Error, this field contains the specific type of error. sc_content_type The value of the HTTP Content-Type header of the response. sc_content_len The value of the HTTP Content-Length header of the response. sc_range_start When the response contains the HTTP Content-Range header, this field contains the range start value. sc-range-end When the response contains the HTTP Content-Range header, this field contains the range end value. Elastic Load Balancer Source: logtype = 'elb' Grok: ^%{TIMESTAMP_ISO8601:time} %{NOTSPACE:elb} %{NOTSPACE:client_ip}:%{NOTSPACE:client_port} ((%{NOTSPACE:backend_ip}:%{NOTSPACE:backend_port})|-) %{NOTSPACE:request_processing_time} %{NOTSPACE:backend_processing_time} %{NOTSPACE:response_processing_time} %{NOTSPACE:elb_status_code} %{NOTSPACE:backend_status_code} %{NOTSPACE:received_bytes} %{NOTSPACE:sent_bytes} \"%{DATA:request}\" \"%{DATA:user_agent}\" %{NOTSPACE:ssl_cipher} %{NOTSPACE:ssl_protocol} Copy Results: Field Definition x_edge_location The edge location that served the request. Each edge location is identified by a three-letter code and an arbitrarily assigned number; for example, DFW3. The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.) sc_bytes The total number of bytes that CloudFront served to the viewer in response to the request, including headers; for example, 1045619. For WebSocket connections, this is the total number of bytes sent from the server to the client through the connection. c_ip The IP address of the viewer that made the request. If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip is the IP address of the proxy or load balancer. cs_method The HTTP request method: DELETE, GET, HEAD, OPTIONS, PATCH, POST, or PUT. cs_host The domain name of the CloudFront distribution; for example, d111111abcdef8.cloudfront.net. cs_uri_stem The portion of the URI that identifies the path and object; for example, /images/cat.jpg. Question marks (?) in URLs and query strings are not included in the log. sc_status An HTTP status code (for example, 200). Status code 000 indicates that the viewer closed the connection (for example, closed the browser tab) before CloudFront could respond to a request. If the viewer closes the connection after CloudFront starts to send the response, the log contains the applicable HTTP status code. cs_referer he name of the domain that originated the request. Common referrers include search engines, other websites that link directly to your objects, and your own website. cs_user_agent The value of the User-Agent header in the request. The User-Agent header identifies the source of the request, such as the type of device and browser that submitted the request and which search engine if applicable. cs_uri_query The query string portion of the URI, if any. When a URI doesn't contain a query string, this field's value is a hyphen (-). cs_cookie The cookie header in the request, including name-value pairs and the associated attributes. If you enable cookie logging, CloudFront logs the cookies in all requests, regardless of which cookies you choose to forward to the origin. If a request doesn't include a cookie header, this field's value is a hyphen (-). x_edge_result_type How CloudFront classifies the response after the last byte left the edge location. In some cases, the result type can change between the time that CloudFront is ready to send the response and the time that CloudFront has finished sending the response. x_edge_request_id An encrypted string that uniquely identifies a request. In the response header, this is x-amz-cf-id. x_host_header The value that the viewer included in the Host header for this request. This is the domain name in the request. If you're using the CloudFront domain name in your object URLs, this field contains that domain name. If you're using alternate domain names in your object URLs, such as [http://example.com/logo.png, this field contains the alternate domain name, such as example.com. To use alternate domain names, you must add them to your distribution. cs_protocol The protocol that the viewer specified in the request: http, https, ws, or wss. cs_bytes The number of bytes of data that the viewer included in the request, including headers. For WebSocket connections, this is the total number of bytes sent from the client to the server on the connection. time_taken The number of seconds (to the thousandth of a second; for example, 0.002) between the time that a CloudFront edge server receives a viewer's request and the time that CloudFront writes the last byte of the response to the edge server's output queue as measured on the server. From the perspective of the viewer, the total time to get the full object will be longer than this value due to network latency and TCP buffering. x_forwarded_for If the viewer used an HTTP proxy or a load balancer to send the request, the value of c_ip in field 5 is the IP address of the proxy or load balancer. In that case, this field is the IP address of the viewer that originated the request. This field contains IPv4 and IPv6 addresses as applicable. If the viewer did not use an HTTP proxy or a load balancer, the value of x_forwarded_for is a hyphen (-). ssl_protocol When cs_protocol in field 17 is https, this field contains the SSL/TLS protocol that the client and CloudFront negotiated for transmitting the request and response. Possible values include: SSLv3 TLSv1 TLSv1.1 TLSv1.2 When cs_protocol in field 17 is http, the value for this field is a hyphen (-). ssl_cipher When cs_protocol in field 17 is https, this field contains the SSL/TLS cipher that the client and CloudFront negotiated for encrypting the request and response. Possible values include: ECDHE-RSA-AES128-GCM-SHA256 ECDHE-RSA-AES128-SHA256 ECDHE-RSA-AES128-SHA ECDHE-RSA-AES256-GCM-SHA384 ECDHE-RSA-AES256-SHA384 ECDHE-RSA-AES256-SHA AES128-GCM-SHA256 AES256-GCM-SHA384 AES128-SHA256 AES256-SHA AES128-SHA DES-CBC3-SHA RC4-MD5 When cs_protocol is http, the value for this field is a hyphen (-). x_edge_response_result_type How CloudFront classified the response just before returning the response to the viewer. Possible values include: Hit: CloudFront served the object to the viewer from the edge cache. RefreshHit: CloudFront found the object in the edge cache but it had expired, so CloudFront contacted the origin to verify that the cache has the latest version of the object. Miss: The request could not be satisfied by an object in the edge cache, so CloudFront forwarded the request to the origin server and returned the result to the viewer. LimitExceeded: The request was denied because a CloudFront limit was exceeded. CapacityExceeded: CloudFront returned a 503 error because the edge location didn't have enough capacity at the time of the request to serve the object. Error: Typically this means the request resulted in a client error (sc_status is 4xx) or a server error (sc_status is 5xx). If the value of x_edge_result_type is Error and the value of this field is not Error, the client disconnected before finishing the download. Redirect: CloudFront redirects from HTTP to HTTPS. If sc_status is 403 and you configured CloudFront to restrict the geographic distribution of your content, the request might have come from a restricted location. cs_protocol_version The HTTP version that the viewer specified in the request. Possible values include: HTTP/0.9 HTTP/1.0 HTTP/1.1 HTTP/2.0 fle_status When field-level encryption is configured for a distribution, this field contains a code that indicates whether the request body was successfully processed. If field-level encryption is not configured for the distribution, the value of this field is a hyphen (-). When CloudFront successfully processes the request body, encrypts values in the specified fields, and forwards the request to the origin, the value of this field is Processed. The value of x_edge_result_type can still indicate a client-side or server-side error in this case. If the request exceeds a field-level encryption limit, fle-status contains one of the following error codes, and CloudFront returns HTTP status code 400 to the viewer. fle-encrypted-fields The number of fields that CloudFront encrypted and forwarded to the origin. CloudFront streams the processed request to the origin as it encrypts data, so fle_encrypted_fields can have a value even if the value of fle_status is an error. If field-level encryption is not configured for the distribution, the value of fle_encrypted_fields is a hyphen (-). c_port The port number of the request from the viewer. time_to_first_byte The number of seconds between receiving the request and writing the first byte of the response, as measured on the server. x_edge_detailed_result_type When x_edge_result_type is not Error, this field contains the same value as x_edge_result_type. When x_edge_result_type is Error, this field contains the specific type of error. sc_content_type The value of the HTTP Content-Type header of the response. sc_content_len The value of the HTTP Content-Length header of the response. sc_range_start When the response contains the HTTP Content-Range header, this field contains the range start value. sc-range-end When the response contains the HTTP Content-Range header, this field contains the range end value. Microsoft IIS Source: logtype = 'iis_w3c' Grok: %{TIMESTAMP_ISO8601:log_timestamp} %{NOTSPACE:server_ip} %{WORD:method} %{NOTSPACE:uri} %{NOTSPACE:uri_query} %{NOTSPACE:server_port} %{NOTSPACE:username} %{NOTSPACE:client_ip} %{NOTSPACE:user_agent} %{NOTSPACE:referer} %{NOTSPACE:status} %{NOTSPACE:substatus} %{NOTSPACE:win32_status} %{NOTSPACE:time_taken} Copy Monit Source: logtype = 'monit' Grok: \\\\[%{NOTSPACE:tz} %{SYSLOGTIMESTAMP:nr_timestamp}\\\\] %{WORD:state}%{SPACE}: %{GREEDYDATA:message} Copy Results: state: The severity of the log line message: The message MySQL Error Source: logtype = 'mysql-error' Grok: \\\\[%{WORD:log_level}\\\\] Copy Results: log_level: The severity of the log line NGINX Source: logtype = 'nginx' Grok: %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \\[%{HTTPDATE:timestamp}\\] \"(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})\" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer} %{QS:agent} Copy Results: clientip: The IP address of the client verb: The HTTP verb ident: The user identity of the client making the request response: The HTTP status code of the response request: The URI and request being made httpversion: The HTTP version of the request rawrequest: The raw HTTP request if data is posted bytes: The number of bytes sent referrer: The HTTP referrer agent: The client's user agent NGINX Error Source: logtype = 'nginx-error' Grok: ^(?<timestamp>%{YEAR:year}[./-]%{MONTHNUM:month}[./-]%{MONTHDAY:day}[- ]%{TIME:time}) \\\\[%{LOGLEVEL:severity}\\\\] %{POSINT:pid}#%{NUMBER}: %{GREEDYDATA:errormessage}(?:, client: (?<client>%{IP:clientip}|%{HOSTNAME:hostname}))(?:, server: %{IPORHOSTORUNDERSCORE:server})(?:, request: %{QS:request})?(?:, upstream: \\\"%{URI:upstream}\\\")?(?:, host: %{QS:host})?(?:, referrer: \\\"%{URI:referrer}\\\")?$ Copy Results: severity: The severity of the log line pid: The server process ID errormessage: The error message clientip: The IP address of the calling client server: The server IP address request: The full request upstream: The upstream URI host: The server's hostname referrer: The HTTP referrer Route 53 Source: logtype = 'route-53' Grok: %{NUMBER:log_format_version} %{TIMESTAMP_ISO8601} %{WORD:zone_id} %{IPORHOST:query} %{WORD:query_type} %{WORD:response_code} %{WORD:protocol} %{WORD:edge_location} %{IP:resolver_ip} %{GREEDYDATA:edns_client_subnet} Copy Results: log_format_version: A versioned format for the log. zone_id: The ID of the hosted zone that is associated with all the DNS queries in this log. query: The domain or subdomain that was specified in the request. query_type: Either the DNS record type that was specified in the request, or ANY. response_code: The DNS response code that Route 53 returned in response to the DNS query. protocol: The protocol that was used to submit the query, either TCP or UDP. edge_location: The Route 53 edge location that responded to the query. Each edge location is identified by a three-letter code and an arbitrary number; for example, DFW3. The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.) resolver_ip: The IP address of the DNS resolver that submitted the request to Route 53. edns_client_subnet: A partial IP address for the client that the request originated from, if available from the DNS resolver. Syslog RFC-5424 Source: logtype = 'syslog-rfc5424' Grok: <%{NONNEGINT:pri}>%{NONNEGINT:version} +(?:%{TIMESTAMP_ISO8601:log.timestamp}|-) +(?:%{HOSTNAME:hostname}|-) +(?:\\\\-|%{NOTSPACE:app.name}) +(?:\\\\-|%{NOTSPACE:procid}) (?:\\\\-|%{NOTSPACE:msgid}) +(?:\\[%{DATA:structured.data}\\]|-|) +%{GREEDYDATA:message} Copy Results: pri: The priority represents both the message facility and severity. version: Syslog protocol version. log.timestamp: Original timestamp. hostname: The machine that originally sent the Syslog message. app.name: The device or application that originated the message. procid: The process name or process ID associated with a Syslog system. msgid: Identifies the type of message. structured.data: Structured data string value. sd.<var>sd-id</var>.<var>sd-param-name</var>: The structured.data content is also parsed into separate attributes following a predefined naming convention: sd.<var>sd-id</var>.<var>sd-param-name</var>. See the structured data parsing examples, which follow. message: Free-form message that provides information about the event. Structured data parsing examples: The structured data [example one=\"1\" two=\"2\"] would be parsed into two different attributes: sd.example.one: \"1\" sd.example.two: \"2\" Copy If the same structured data block contains duplicate param names, it also appends an index-based suffix on the attribute name. For example, the structured data [example number=\"1\" number=\"2\"] would be parsed as: sd.example.number.0: \"1\" sd.example.number.1: \"2\" Copy For structured data with enterprise numbers assigned, an extra attribute is also parsed. For example, the structured data [example@123 number=\"1\"] would be parsed as: sd.example.enterprise.number: 123 sd.example.number: \"1\" Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.79697,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Built-in <em>log</em> parsing rules",
        "sections": "Built-in <em>log</em> parsing rules",
        "tags": "<em>Log</em> <em>management</em>",
        "body": " RFC-5424 Source: logtype = &#x27;syslog-rfc5424&#x27; Grok: &lt;%{NONNEGINT:pri}&gt;%{NONNEGINT:version} +(?:%{TIMESTAMP_ISO8601:<em>log</em>.timestamp}|-) +(?:%{HOSTNAME:hostname}|-) +(?:\\\\-|%{NOTSPACE:app.name}) +(?:\\\\-|%{NOTSPACE:procid}) (?:\\\\-|%{NOTSPACE:msgid}) +(?:\\[%{<em>DATA:structured.data</em>}\\]|-|) +%{GREEDYDATA:message"
      },
      "id": "603e7b9164441f1b2d4e8872"
    }
  ],
  "/docs/mlops/bring-your-own/mlops-byo": [
    {
      "sections": [
        "Superwise MLOps integration",
        "What is MLOps?",
        "What is Superwise?",
        "Migrate Data from Superwise with New Relic",
        "View and explore your Superwise models in New Relic dashboards"
      ],
      "title": "Superwise MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "Superwise integrations"
      ],
      "external_id": "eea57de1a53ec53766ba067ed720283105bc741e",
      "image": "https://docs.newrelic.com/static/79201eea2484599d4f3ededa8819d458/c1b63/superwise2.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/superwise-mlops-integration/",
      "published_at": "2021-12-04T15:29:10Z",
      "updated_at": "2021-11-24T04:47:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. What is Superwise? Superwise now offers an integration with New Relic to help users add the state of their AI as monitored by Superwise to their centralized operational view on New Relic. Migrate Data from Superwise with New Relic Superwise’s KPI and incidents integration streamlines results of our out-of-the-box model KPIs, including drift, activity, incidents, and any custom KPI you configure, directly into New Relic One. You’ll get an immediate overview of which models are misbehaving that can be tailored to any use case, logic, segmentation, threshold, and sensitivity. In order to receive data from Superwise into New Relic, you’ll need to do the following: Login into your New Relic account: Log into one.newrelic.com and click on Explorer. On the upper hand corner, on the main navigation menu, click on + Add more data. Click on Superwise: In the search bar, type Superwise or scroll down to the MLOps Integration section, then click on the Superwise icon. Select an account ID: Select the account ID you want Superwise to integrate with. Create two access tokens: Once you select an Account ID, under Prediction data + Generate Dashboard, click Create a key. This is your new telemetry API key. In addition, under Model quality metric, click Create a Key. This is your Incident Insights key. Keep the New Relic page open for future steps. Log into the Superwise portal: Log into the Superwise portal and go to Notification channel settings. Select New Relic and create a channel name. Copy and paste the token in Superwise: Go back to the New Relic integration dashboard and copy the two tokens you created by clicking on the copy icon next to the API key and Insight key. On Superwise’s portal, on the New Relic channel, paste the API key under Incident Intelligence API, and the Insight key under Telemetry Key. Finish by clicking Save. Verify the Token: Click on the Test button in the Superwise channel portal, to verify both tokens are working properly. A green or red status box should appear to indicate the verification. View and explore your Superwise models in New Relic dashboards Once a user configures the New Relic integration in Superwise, standard model metrics are sent to New Relic and users get model observability dashboards within New Relic. Users can also configure any specific model metric and incident policy and send them to New Relic for model observability tailored to their business context. Go to the integration dashboard: Once you’ve tested your tokens and confirmed the integration is set up correctly, return to the New Relic integration dashboard and click on See your data. This will redirect you to an automatically generated dashboard powered by Superwise. Analyze Superwise’s dashboard. Superwise’s dashboard contains 3 charts: The Model activity chart displays the number of active models, their activity, and the total number of predictions during a filtered timeframe. The Model input drift detection chart displays which models are drifting and may require retraining using a model drift leveler, scaled between 0 and 100. The Incident Insights chart displays how many models have open incidents, how incidents are being distributed, and deeper details on the model incident itself. Customize metrics and incidents in Superwise: Teams can easily customize any model metric and incident type in the Superwise platform. They can then search for these metrics in the New Relic Browser tab under Metrics. To do this, follow the instructions in step 4 in the Superwise docs. Set up alert notifications: Once you've created some dashboards, you can get alerted on your data. To create a NRQL alerts condition from a chart, click the chart widget, then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Get notified: Once you've created an alerts condition, you can choose how you want to be notified. See our docs on how to set up notification channels. Correlate your incidents: In addition to notifications, you can use Incident Intelligence to correlate your incidents. See our docs on how to correlate incidents using decisions. You’ve now successfully integrated New Relic with Superwise. Newly created alerts will now be correlated with your New Relic alerts and you should be able to see data about newly reported predictions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.192245,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Superwise <em>MLOps</em> <em>integration</em>",
        "sections": "Superwise <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "617e42b364441fa664fbc5c7"
    },
    {
      "sections": [
        "TruEra MLOps integration",
        "What is MLOps?",
        "What is TruEra?",
        "Integrate TruEra with New Relic",
        "Add a Machine Learning Model to TruEra",
        "Stream data from TruEra to New Relic",
        "View out-of-the-box New Relic dashboards using TruEra"
      ],
      "title": "TruEra MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "TruEra integrations"
      ],
      "external_id": "6d0ba2649cebaddb8661e4cdbb8ee8b437c9bc1f",
      "image": "https://docs.newrelic.com/static/15c7d07492de3d07413a8d1c65135584/c1b63/truera_alerts.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/truera-mlops-integration/",
      "published_at": "2021-12-04T15:29:10Z",
      "updated_at": "2021-11-23T21:12:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. What is TruEra? TruEra fills a critical gap in your AI stack, explaining and testing model quality throughout the lifecycle. TruEra’s AI solutions explain, debug, and monitor machine learning models, leading to higher quality and trustworthiness, as well as faster deployment. The solution works across the model lifecycle, is independent of model development platforms, and embeds easily into your existing AI stack. TruEra now offers an integration with New Relic to help MLOps teams correlate signals throughout the ML lifecycle and go beyond standard accuracy, and monitor input and output drifting. Integrate TruEra with New Relic Add a Machine Learning Model to TruEra TruEra provides a command line interface (CLI) and Python client to ingest the machine learning model and other data. Steps to add a model using the CLI include creating a new project, data collection, adding training data, packaging and ingesting the model, and adding production data. These steps can be found on the TruEra technical documentation page. Stream data from TruEra to New Relic Whenever a new set of data is ingested into the Truera Monitoring system, it computes relevant metrics and stores it. These computed metrics can be periodically pushed to New Relic using the truera2newrelic data exporter. This exporter needs API keys generated by the Truera and New Relic consoles. The following instructions will show you how to create these keys: Login into your New Relic account: Log into one.newrelic.com and click on Explorer. On the upper hand corner, on the main navigation menu, click on + Add more data. Click on TruEra: In the search bar, type TruEra or scroll down to the MLOps Integration section, then click on the TruEra icon. Select an account ID: Select the account ID you want TruEra to integrate with. Select or create an API key: You need an Active dashboard key for dashboards management, and a Model metrics data key for metrics ingestion. Create a new key, or select an existing one under the two key sections. Create a key on TruEra: Log into the TruEra console, and go to the users page. Click on Generate Credentials to create an Auth token. Verify the data export run and set up the batch exporter: Now go to TruEra docs to find steps on how to verify the first data export run using commands in your terminal. Next, set up the batch data exporter on a virtual machine. View out-of-the-box New Relic dashboards using TruEra To visualize machine learning monitoring metrics, TruEra provides skeleton dashboards to monitor and drill down on issues using themes like model health, segment drilldown, feature values, data quality, fairness, and more. These dashboards can be set up using the truera2newrelic dashboard tool. To do so, follow these steps: Verify your model metrics: From one.newrelic.com, go to the navigation menu and click on the dashboard tab on the main navigation menu. You will see an automatically generated dashboard setup for the given ML model. Verify that recently exported model metrics are visible. Set up alert notifications: Once you've created some dashboards, you can get alerted on your data. To create a NRQL alerts condition from a chart, click the chart widget, then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Get notified: Once you've created an alerts condition, you can choose how you want to be notified. See our docs on how to set up notification channels. Correlate your incidents: In addition to notifications, you can use Incident Intelligence to correlate your incidents. See our docs on how to correlate incidents using decisions. You’ve now successfully integrated New Relic with TruEra. Newly created alerts are now correlated with your New Relic alerts, and you should be able to see data about newly reported predictions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 77.827324,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "TruEra <em>MLOps</em> <em>integration</em>",
        "sections": "TruEra <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "619d5931196a670e2fa07e7c"
    },
    {
      "sections": [
        "Datarobot MLOps integration",
        "What is MLOps?",
        "The Datarobot integration",
        "Integrate Datarobot with New Relic",
        "Connect your Datarobot data to New Relic",
        "Monitor your machine learning models [#monitor]"
      ],
      "title": "Datarobot MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "Datarobot integrations"
      ],
      "external_id": "50f76f931cf5783cb47c3b8feee7b9cddb0185c4",
      "image": "https://docs.newrelic.com/static/e5770f365474a584b077b7565f273a79/c1b63/algorithmia-flow.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/datarobot-mlops-integration/",
      "published_at": "2021-12-04T15:29:11Z",
      "updated_at": "2021-11-06T20:09:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. The Datarobot integration Datarobot provides tools for deploying your machine-learning models into production. By integrating, Datarobot's integration with New Relic, you'll be able to instrument, analyze, troubleshoot, and optimize your machine-learning performance across your entire system. By rigorously observing your capabilities, you'll be able to react quickly to changes in the model's input or output and the relationship between the two. Send your model performance metrics from Datarobot Insights to New Relic and you'll have real-time monitoring for your algorithms. You'll explore your metrics data with user-friendly charts and learn the state of your algorithms at a glance for faster and more efficient troubleshooting. Integrate Datarobot with New Relic First, Datarobot uses a Kafka topic to stream Insights from your machine-learning algorithm's performance metrics. Then, the New Relic connector (another algorithm) transforms the Kafka topic into a metrics data payload for a specific New Relic account. Datarobot uses Kafka and Event Flows to send data to New Relic. With Datarobot’s Event Flows, when a new message is set to your Kafka topic, your configured New Relic connector algorithm gets called. The connector transforms your metrics and sends them to your New Relic account. Connect your Datarobot data to New Relic By integrating Incident Intelligence with your Datarobot machine-learning models, you can monitor your machine learning model performance. Start monitoring your Datarobot event flows with New Relic. Get your API key: From one.newrelic.com the account menu, click API keys and then create a user key for your account with a meaningful name. Make note of this name for later. For more on API keys, see our docs. Create a dashboard: From one.newrelic.com go to Dashboards, then click the Import dashboards button. Copy and paste the JSON code into the Paste your JSON field code. Update the YOUR_ACCOUNT_ID values with your account ID. { \"name\": \"Datarobot Dashboard for Default Metrics\", \"description\": null, \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"Datarobot Dashboard for Default Metrics\", \"description\": null, \"widgets\": [ { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Runtime Duration by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT average(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Throughput by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT count(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } Copy Configure Datarobot Insights for New Relic: Use Datarobot's docs for how to configure Datarobot for New Relic. Create the New Relic connector algorithm: Use Python 3.8 to create a connector algorithm. If you're new to writing code to generate algorithms, see Datarobot's getting started guide. import Datarobot import json from datetime import datetime from newrelic_telemetry_sdk import GaugeMetric, MetricClient client = Datarobot.client() metric_client = MetricClient(os.environ[\"newrelic_api_key\"]) def convert_str_timestamp_to_epoch(str_time): obj_time = datetime.strptime(str_time, \"%Y-%m-%dT%H:%M:%S.%f\") return int(obj_time.timestamp() * 1000) def get_operational_metrics(payload): ALGORITHM_TAGS = { \"algorithm_version\", \"request_id\", \"time\", \"algorithm_name\", \"session_id\", \"algorithm_owner\" } inference_metrics = { key: payload[key] for key in payload.keys() ^ ALGORITHM_TAGS } return inference_metrics def send_to_newrelic(inference_metrics, insights_payload): newrelic_metrics = [] for key, value in inference_metrics.items(): name = \"algorithmia.\" + key epoch_time = convert_str_timestamp_to_epoch(insights_payload[\"time\"]) tags = { \"algorithm_name\": insights_payload[\"algorithm_name\"], \"algorithm_version\": insights_payload[\"algorithm_version\"], \"algorithm_owner\": insights_payload[\"algorithm_owner\"], \"request_id\": insights_payload[\"request_id\"], \"session_id\": insights_payload[\"session_id\"], } newrelic_metrics.append(GaugeMetric( name=name, value=value, tags=tags, end_time_ms=epoch_time )) response = metric_client.send_batch(newrelic_metrics) response.raise_for_status() def apply(input): insights_payload = input inference_metrics = get_operational_metrics(insights_payload) send_to_newrelic(inference_metrics, insights_payload) return None Copy Include these dependencies: algorithmia>=1.0.0,<2.0 newrelic_telemetry_sdk==0.4.2 Copy Once your algorithm build finishes, you can test it with this sample payload to make sure it runs successfully. Your output should look something like this. { \"risk_score\": 0.2, \"duration_milliseconds\": 8, \"algorithm_version\": \"1.0.6\", \"session_id\": \"rses-f28bb94a-5556-4aeb-a6d2-89493626bf4f\", \"time\": \"2021-02-20T00:21:54.867231\", \"algorithm_name\": \"credit_card_approval\", \"request_id\": \"req-9f5345b4-a1cd-431c-a43a-bd2a06f4a6f4\", \"algorithm_owner\": \"asli\" } Copy Configure with your API key: Add your New Relic API key to the Datarobot secret store. Set up Datarobot Event Flows with New Relic: See Datarobot's documentation on setting up your connector algorithm to send event-based machine learning flows to New Relic. Monitor your machine learning models [#monitor] Follow these steps to get the most of observing your machine-learning data in New Relic. Get your API key: From one.newrelic.com the account menu, click API keys and then create a user key for your account with a meaningful name. Make note of this name for later. For more on API keys, see our docs. Create a dashboard: From one.newrelic.com go to Dashboards, then click the Import dashboards button. Copy and paste the JSON code into the Paste your JSON field code. Update the YOUR_ACCOUNT_ID values with your account ID. { \"name\": \"Datarobot Dashboard for Default Metrics\", \"description\": null, \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"Datarobot Dashboard for Default Metrics\", \"description\": null, \"widgets\": [ { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Runtime Duration by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT average(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Throughput by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT count(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } Copy Set up alerts notifications: Once you've created some dashboards, you can get alerted on your data. To create a NRQL alerts condition from a chart, click the chart menu , then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Get notified: Once you've created an alerts condition, you can choose how you want to be notified. See our docs on how to set up notification channels. Correlate your incidents: In addition to notifications, you can use Incident Intelligence to correlate your incidents. See our docs on how to correlate incidents using decisions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 66.790215,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Datarobot <em>MLOps</em> <em>integration</em>",
        "sections": "Datarobot <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "6186e10a28ccbcd8d2cdfd59"
    }
  ],
  "/docs/mlops/get-started/intro-mlops": [
    {
      "sections": [
        "TruEra MLOps integration",
        "What is MLOps?",
        "What is TruEra?",
        "Integrate TruEra with New Relic",
        "Add a Machine Learning Model to TruEra",
        "Stream data from TruEra to New Relic",
        "View out-of-the-box New Relic dashboards using TruEra"
      ],
      "title": "TruEra MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "TruEra integrations"
      ],
      "external_id": "6d0ba2649cebaddb8661e4cdbb8ee8b437c9bc1f",
      "image": "https://docs.newrelic.com/static/15c7d07492de3d07413a8d1c65135584/c1b63/truera_alerts.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/truera-mlops-integration/",
      "published_at": "2021-12-04T15:29:10Z",
      "updated_at": "2021-11-23T21:12:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. What is TruEra? TruEra fills a critical gap in your AI stack, explaining and testing model quality throughout the lifecycle. TruEra’s AI solutions explain, debug, and monitor machine learning models, leading to higher quality and trustworthiness, as well as faster deployment. The solution works across the model lifecycle, is independent of model development platforms, and embeds easily into your existing AI stack. TruEra now offers an integration with New Relic to help MLOps teams correlate signals throughout the ML lifecycle and go beyond standard accuracy, and monitor input and output drifting. Integrate TruEra with New Relic Add a Machine Learning Model to TruEra TruEra provides a command line interface (CLI) and Python client to ingest the machine learning model and other data. Steps to add a model using the CLI include creating a new project, data collection, adding training data, packaging and ingesting the model, and adding production data. These steps can be found on the TruEra technical documentation page. Stream data from TruEra to New Relic Whenever a new set of data is ingested into the Truera Monitoring system, it computes relevant metrics and stores it. These computed metrics can be periodically pushed to New Relic using the truera2newrelic data exporter. This exporter needs API keys generated by the Truera and New Relic consoles. The following instructions will show you how to create these keys: Login into your New Relic account: Log into one.newrelic.com and click on Explorer. On the upper hand corner, on the main navigation menu, click on + Add more data. Click on TruEra: In the search bar, type TruEra or scroll down to the MLOps Integration section, then click on the TruEra icon. Select an account ID: Select the account ID you want TruEra to integrate with. Select or create an API key: You need an Active dashboard key for dashboards management, and a Model metrics data key for metrics ingestion. Create a new key, or select an existing one under the two key sections. Create a key on TruEra: Log into the TruEra console, and go to the users page. Click on Generate Credentials to create an Auth token. Verify the data export run and set up the batch exporter: Now go to TruEra docs to find steps on how to verify the first data export run using commands in your terminal. Next, set up the batch data exporter on a virtual machine. View out-of-the-box New Relic dashboards using TruEra To visualize machine learning monitoring metrics, TruEra provides skeleton dashboards to monitor and drill down on issues using themes like model health, segment drilldown, feature values, data quality, fairness, and more. These dashboards can be set up using the truera2newrelic dashboard tool. To do so, follow these steps: Verify your model metrics: From one.newrelic.com, go to the navigation menu and click on the dashboard tab on the main navigation menu. You will see an automatically generated dashboard setup for the given ML model. Verify that recently exported model metrics are visible. Set up alert notifications: Once you've created some dashboards, you can get alerted on your data. To create a NRQL alerts condition from a chart, click the chart widget, then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Get notified: Once you've created an alerts condition, you can choose how you want to be notified. See our docs on how to set up notification channels. Correlate your incidents: In addition to notifications, you can use Incident Intelligence to correlate your incidents. See our docs on how to correlate incidents using decisions. You’ve now successfully integrated New Relic with TruEra. Newly created alerts are now correlated with your New Relic alerts, and you should be able to see data about newly reported predictions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.62341,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "TruEra <em>MLOps</em> <em>integration</em>",
        "sections": "TruEra <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "619d5931196a670e2fa07e7c"
    },
    {
      "sections": [
        "Superwise MLOps integration",
        "What is MLOps?",
        "What is Superwise?",
        "Migrate Data from Superwise with New Relic",
        "View and explore your Superwise models in New Relic dashboards"
      ],
      "title": "Superwise MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "Superwise integrations"
      ],
      "external_id": "eea57de1a53ec53766ba067ed720283105bc741e",
      "image": "https://docs.newrelic.com/static/79201eea2484599d4f3ededa8819d458/c1b63/superwise2.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/superwise-mlops-integration/",
      "published_at": "2021-12-04T15:29:10Z",
      "updated_at": "2021-11-24T04:47:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. What is Superwise? Superwise now offers an integration with New Relic to help users add the state of their AI as monitored by Superwise to their centralized operational view on New Relic. Migrate Data from Superwise with New Relic Superwise’s KPI and incidents integration streamlines results of our out-of-the-box model KPIs, including drift, activity, incidents, and any custom KPI you configure, directly into New Relic One. You’ll get an immediate overview of which models are misbehaving that can be tailored to any use case, logic, segmentation, threshold, and sensitivity. In order to receive data from Superwise into New Relic, you’ll need to do the following: Login into your New Relic account: Log into one.newrelic.com and click on Explorer. On the upper hand corner, on the main navigation menu, click on + Add more data. Click on Superwise: In the search bar, type Superwise or scroll down to the MLOps Integration section, then click on the Superwise icon. Select an account ID: Select the account ID you want Superwise to integrate with. Create two access tokens: Once you select an Account ID, under Prediction data + Generate Dashboard, click Create a key. This is your new telemetry API key. In addition, under Model quality metric, click Create a Key. This is your Incident Insights key. Keep the New Relic page open for future steps. Log into the Superwise portal: Log into the Superwise portal and go to Notification channel settings. Select New Relic and create a channel name. Copy and paste the token in Superwise: Go back to the New Relic integration dashboard and copy the two tokens you created by clicking on the copy icon next to the API key and Insight key. On Superwise’s portal, on the New Relic channel, paste the API key under Incident Intelligence API, and the Insight key under Telemetry Key. Finish by clicking Save. Verify the Token: Click on the Test button in the Superwise channel portal, to verify both tokens are working properly. A green or red status box should appear to indicate the verification. View and explore your Superwise models in New Relic dashboards Once a user configures the New Relic integration in Superwise, standard model metrics are sent to New Relic and users get model observability dashboards within New Relic. Users can also configure any specific model metric and incident policy and send them to New Relic for model observability tailored to their business context. Go to the integration dashboard: Once you’ve tested your tokens and confirmed the integration is set up correctly, return to the New Relic integration dashboard and click on See your data. This will redirect you to an automatically generated dashboard powered by Superwise. Analyze Superwise’s dashboard. Superwise’s dashboard contains 3 charts: The Model activity chart displays the number of active models, their activity, and the total number of predictions during a filtered timeframe. The Model input drift detection chart displays which models are drifting and may require retraining using a model drift leveler, scaled between 0 and 100. The Incident Insights chart displays how many models have open incidents, how incidents are being distributed, and deeper details on the model incident itself. Customize metrics and incidents in Superwise: Teams can easily customize any model metric and incident type in the Superwise platform. They can then search for these metrics in the New Relic Browser tab under Metrics. To do this, follow the instructions in step 4 in the Superwise docs. Set up alert notifications: Once you've created some dashboards, you can get alerted on your data. To create a NRQL alerts condition from a chart, click the chart widget, then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Get notified: Once you've created an alerts condition, you can choose how you want to be notified. See our docs on how to set up notification channels. Correlate your incidents: In addition to notifications, you can use Incident Intelligence to correlate your incidents. See our docs on how to correlate incidents using decisions. You’ve now successfully integrated New Relic with Superwise. Newly created alerts will now be correlated with your New Relic alerts and you should be able to see data about newly reported predictions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.40373,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Superwise <em>MLOps</em> <em>integration</em>",
        "sections": "Superwise <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "617e42b364441fa664fbc5c7"
    },
    {
      "sections": [
        "Comet MLOps integration",
        "What is MLOps?",
        "The Comet integration",
        "Integrate Comet with New Relic"
      ],
      "title": "Comet MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "Comet integrations"
      ],
      "external_id": "5bd55e6c5d49d480acb50bd0c1830a08aa84ceaf",
      "image": "https://docs.newrelic.com/static/f75787c4d9fd008aad94f01908ee9995/c1b63/comet03.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/comet-mlops-integration/",
      "published_at": "2021-12-04T20:58:08Z",
      "updated_at": "2021-11-06T20:09:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. The Comet integration Comet is an MLOps platform that extends full stack observability to machine learning models, and allows you to establish production performance baselines based on model performance. The Comet integration allows you to integrate machine learning metrics with New Relic, so you can continuosly monitor your data across the full machine learning lifecycle. This helps ensure optimal model performance, and helps you achieve better business outcomes. Integrate Comet with New Relic Use New Relic's Comet integration to get data and insights that help you build better, more accurate machine-learning models, while also improving productivity, collaboration, and visibility across your team. To setup the integration, follow these steps: Log into your New Relic account: Log into one.newrelic.com and click on Explorer. At the upper hand corner, on the main navigation menu, click +Add more data. Click on Comet: Type Comet in the search bar, or scroll down to the MLOps Integration section and click on the Comet icon. Select the account ID you want Comet to integrate with. Select or create an Insight API Key: You need an Insight API Key to integrate with Comet. Create or select an existing API key under the Real time training metric section. Contact Comet: To set up the integration and view the Model Production Monitoring dashboard in Comet, you need to contact Comet. The Comet team will walk you through each step of the integration process and get you all set up. View your insights: Now that you’ve set up your integration, you can start tracking the performance of your machine learning models in a dedicated New Relic One dashboard, which is automatically generated by Comet’s team.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 197.42545,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Comet <em>MLOps</em> <em>integration</em>",
        "sections": "Comet <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "6186e10a28ccbcdc52cdf889"
    }
  ],
  "/docs/mlops/integrations/aporia-mlops-integration": [
    {
      "sections": [
        "Superwise MLOps integration",
        "What is MLOps?",
        "What is Superwise?",
        "Migrate Data from Superwise with New Relic",
        "View and explore your Superwise models in New Relic dashboards"
      ],
      "title": "Superwise MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "Superwise integrations"
      ],
      "external_id": "eea57de1a53ec53766ba067ed720283105bc741e",
      "image": "https://docs.newrelic.com/static/79201eea2484599d4f3ededa8819d458/c1b63/superwise2.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/superwise-mlops-integration/",
      "published_at": "2021-12-04T15:29:10Z",
      "updated_at": "2021-11-24T04:47:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. What is Superwise? Superwise now offers an integration with New Relic to help users add the state of their AI as monitored by Superwise to their centralized operational view on New Relic. Migrate Data from Superwise with New Relic Superwise’s KPI and incidents integration streamlines results of our out-of-the-box model KPIs, including drift, activity, incidents, and any custom KPI you configure, directly into New Relic One. You’ll get an immediate overview of which models are misbehaving that can be tailored to any use case, logic, segmentation, threshold, and sensitivity. In order to receive data from Superwise into New Relic, you’ll need to do the following: Login into your New Relic account: Log into one.newrelic.com and click on Explorer. On the upper hand corner, on the main navigation menu, click on + Add more data. Click on Superwise: In the search bar, type Superwise or scroll down to the MLOps Integration section, then click on the Superwise icon. Select an account ID: Select the account ID you want Superwise to integrate with. Create two access tokens: Once you select an Account ID, under Prediction data + Generate Dashboard, click Create a key. This is your new telemetry API key. In addition, under Model quality metric, click Create a Key. This is your Incident Insights key. Keep the New Relic page open for future steps. Log into the Superwise portal: Log into the Superwise portal and go to Notification channel settings. Select New Relic and create a channel name. Copy and paste the token in Superwise: Go back to the New Relic integration dashboard and copy the two tokens you created by clicking on the copy icon next to the API key and Insight key. On Superwise’s portal, on the New Relic channel, paste the API key under Incident Intelligence API, and the Insight key under Telemetry Key. Finish by clicking Save. Verify the Token: Click on the Test button in the Superwise channel portal, to verify both tokens are working properly. A green or red status box should appear to indicate the verification. View and explore your Superwise models in New Relic dashboards Once a user configures the New Relic integration in Superwise, standard model metrics are sent to New Relic and users get model observability dashboards within New Relic. Users can also configure any specific model metric and incident policy and send them to New Relic for model observability tailored to their business context. Go to the integration dashboard: Once you’ve tested your tokens and confirmed the integration is set up correctly, return to the New Relic integration dashboard and click on See your data. This will redirect you to an automatically generated dashboard powered by Superwise. Analyze Superwise’s dashboard. Superwise’s dashboard contains 3 charts: The Model activity chart displays the number of active models, their activity, and the total number of predictions during a filtered timeframe. The Model input drift detection chart displays which models are drifting and may require retraining using a model drift leveler, scaled between 0 and 100. The Incident Insights chart displays how many models have open incidents, how incidents are being distributed, and deeper details on the model incident itself. Customize metrics and incidents in Superwise: Teams can easily customize any model metric and incident type in the Superwise platform. They can then search for these metrics in the New Relic Browser tab under Metrics. To do this, follow the instructions in step 4 in the Superwise docs. Set up alert notifications: Once you've created some dashboards, you can get alerted on your data. To create a NRQL alerts condition from a chart, click the chart widget, then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Get notified: Once you've created an alerts condition, you can choose how you want to be notified. See our docs on how to set up notification channels. Correlate your incidents: In addition to notifications, you can use Incident Intelligence to correlate your incidents. See our docs on how to correlate incidents using decisions. You’ve now successfully integrated New Relic with Superwise. Newly created alerts will now be correlated with your New Relic alerts and you should be able to see data about newly reported predictions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.19857,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Superwise <em>MLOps</em> <em>integration</em>",
        "sections": "Superwise <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "617e42b364441fa664fbc5c7"
    },
    {
      "sections": [
        "TruEra MLOps integration",
        "What is MLOps?",
        "What is TruEra?",
        "Integrate TruEra with New Relic",
        "Add a Machine Learning Model to TruEra",
        "Stream data from TruEra to New Relic",
        "View out-of-the-box New Relic dashboards using TruEra"
      ],
      "title": "TruEra MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "TruEra integrations"
      ],
      "external_id": "6d0ba2649cebaddb8661e4cdbb8ee8b437c9bc1f",
      "image": "https://docs.newrelic.com/static/15c7d07492de3d07413a8d1c65135584/c1b63/truera_alerts.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/truera-mlops-integration/",
      "published_at": "2021-12-04T15:29:10Z",
      "updated_at": "2021-11-23T21:12:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. What is TruEra? TruEra fills a critical gap in your AI stack, explaining and testing model quality throughout the lifecycle. TruEra’s AI solutions explain, debug, and monitor machine learning models, leading to higher quality and trustworthiness, as well as faster deployment. The solution works across the model lifecycle, is independent of model development platforms, and embeds easily into your existing AI stack. TruEra now offers an integration with New Relic to help MLOps teams correlate signals throughout the ML lifecycle and go beyond standard accuracy, and monitor input and output drifting. Integrate TruEra with New Relic Add a Machine Learning Model to TruEra TruEra provides a command line interface (CLI) and Python client to ingest the machine learning model and other data. Steps to add a model using the CLI include creating a new project, data collection, adding training data, packaging and ingesting the model, and adding production data. These steps can be found on the TruEra technical documentation page. Stream data from TruEra to New Relic Whenever a new set of data is ingested into the Truera Monitoring system, it computes relevant metrics and stores it. These computed metrics can be periodically pushed to New Relic using the truera2newrelic data exporter. This exporter needs API keys generated by the Truera and New Relic consoles. The following instructions will show you how to create these keys: Login into your New Relic account: Log into one.newrelic.com and click on Explorer. On the upper hand corner, on the main navigation menu, click on + Add more data. Click on TruEra: In the search bar, type TruEra or scroll down to the MLOps Integration section, then click on the TruEra icon. Select an account ID: Select the account ID you want TruEra to integrate with. Select or create an API key: You need an Active dashboard key for dashboards management, and a Model metrics data key for metrics ingestion. Create a new key, or select an existing one under the two key sections. Create a key on TruEra: Log into the TruEra console, and go to the users page. Click on Generate Credentials to create an Auth token. Verify the data export run and set up the batch exporter: Now go to TruEra docs to find steps on how to verify the first data export run using commands in your terminal. Next, set up the batch data exporter on a virtual machine. View out-of-the-box New Relic dashboards using TruEra To visualize machine learning monitoring metrics, TruEra provides skeleton dashboards to monitor and drill down on issues using themes like model health, segment drilldown, feature values, data quality, fairness, and more. These dashboards can be set up using the truera2newrelic dashboard tool. To do so, follow these steps: Verify your model metrics: From one.newrelic.com, go to the navigation menu and click on the dashboard tab on the main navigation menu. You will see an automatically generated dashboard setup for the given ML model. Verify that recently exported model metrics are visible. Set up alert notifications: Once you've created some dashboards, you can get alerted on your data. To create a NRQL alerts condition from a chart, click the chart widget, then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Get notified: Once you've created an alerts condition, you can choose how you want to be notified. See our docs on how to set up notification channels. Correlate your incidents: In addition to notifications, you can use Incident Intelligence to correlate your incidents. See our docs on how to correlate incidents using decisions. You’ve now successfully integrated New Relic with TruEra. Newly created alerts are now correlated with your New Relic alerts, and you should be able to see data about newly reported predictions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.660934,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "TruEra <em>MLOps</em> <em>integration</em>",
        "sections": "TruEra <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "619d5931196a670e2fa07e7c"
    },
    {
      "sections": [
        "Datarobot MLOps integration",
        "What is MLOps?",
        "The Datarobot integration",
        "Integrate Datarobot with New Relic",
        "Connect your Datarobot data to New Relic",
        "Monitor your machine learning models [#monitor]"
      ],
      "title": "Datarobot MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "Datarobot integrations"
      ],
      "external_id": "50f76f931cf5783cb47c3b8feee7b9cddb0185c4",
      "image": "https://docs.newrelic.com/static/e5770f365474a584b077b7565f273a79/c1b63/algorithmia-flow.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/datarobot-mlops-integration/",
      "published_at": "2021-12-04T15:29:11Z",
      "updated_at": "2021-11-06T20:09:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. The Datarobot integration Datarobot provides tools for deploying your machine-learning models into production. By integrating, Datarobot's integration with New Relic, you'll be able to instrument, analyze, troubleshoot, and optimize your machine-learning performance across your entire system. By rigorously observing your capabilities, you'll be able to react quickly to changes in the model's input or output and the relationship between the two. Send your model performance metrics from Datarobot Insights to New Relic and you'll have real-time monitoring for your algorithms. You'll explore your metrics data with user-friendly charts and learn the state of your algorithms at a glance for faster and more efficient troubleshooting. Integrate Datarobot with New Relic First, Datarobot uses a Kafka topic to stream Insights from your machine-learning algorithm's performance metrics. Then, the New Relic connector (another algorithm) transforms the Kafka topic into a metrics data payload for a specific New Relic account. Datarobot uses Kafka and Event Flows to send data to New Relic. With Datarobot’s Event Flows, when a new message is set to your Kafka topic, your configured New Relic connector algorithm gets called. The connector transforms your metrics and sends them to your New Relic account. Connect your Datarobot data to New Relic By integrating Incident Intelligence with your Datarobot machine-learning models, you can monitor your machine learning model performance. Start monitoring your Datarobot event flows with New Relic. Get your API key: From one.newrelic.com the account menu, click API keys and then create a user key for your account with a meaningful name. Make note of this name for later. For more on API keys, see our docs. Create a dashboard: From one.newrelic.com go to Dashboards, then click the Import dashboards button. Copy and paste the JSON code into the Paste your JSON field code. Update the YOUR_ACCOUNT_ID values with your account ID. { \"name\": \"Datarobot Dashboard for Default Metrics\", \"description\": null, \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"Datarobot Dashboard for Default Metrics\", \"description\": null, \"widgets\": [ { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Runtime Duration by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT average(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Throughput by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT count(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } Copy Configure Datarobot Insights for New Relic: Use Datarobot's docs for how to configure Datarobot for New Relic. Create the New Relic connector algorithm: Use Python 3.8 to create a connector algorithm. If you're new to writing code to generate algorithms, see Datarobot's getting started guide. import Datarobot import json from datetime import datetime from newrelic_telemetry_sdk import GaugeMetric, MetricClient client = Datarobot.client() metric_client = MetricClient(os.environ[\"newrelic_api_key\"]) def convert_str_timestamp_to_epoch(str_time): obj_time = datetime.strptime(str_time, \"%Y-%m-%dT%H:%M:%S.%f\") return int(obj_time.timestamp() * 1000) def get_operational_metrics(payload): ALGORITHM_TAGS = { \"algorithm_version\", \"request_id\", \"time\", \"algorithm_name\", \"session_id\", \"algorithm_owner\" } inference_metrics = { key: payload[key] for key in payload.keys() ^ ALGORITHM_TAGS } return inference_metrics def send_to_newrelic(inference_metrics, insights_payload): newrelic_metrics = [] for key, value in inference_metrics.items(): name = \"algorithmia.\" + key epoch_time = convert_str_timestamp_to_epoch(insights_payload[\"time\"]) tags = { \"algorithm_name\": insights_payload[\"algorithm_name\"], \"algorithm_version\": insights_payload[\"algorithm_version\"], \"algorithm_owner\": insights_payload[\"algorithm_owner\"], \"request_id\": insights_payload[\"request_id\"], \"session_id\": insights_payload[\"session_id\"], } newrelic_metrics.append(GaugeMetric( name=name, value=value, tags=tags, end_time_ms=epoch_time )) response = metric_client.send_batch(newrelic_metrics) response.raise_for_status() def apply(input): insights_payload = input inference_metrics = get_operational_metrics(insights_payload) send_to_newrelic(inference_metrics, insights_payload) return None Copy Include these dependencies: algorithmia>=1.0.0,<2.0 newrelic_telemetry_sdk==0.4.2 Copy Once your algorithm build finishes, you can test it with this sample payload to make sure it runs successfully. Your output should look something like this. { \"risk_score\": 0.2, \"duration_milliseconds\": 8, \"algorithm_version\": \"1.0.6\", \"session_id\": \"rses-f28bb94a-5556-4aeb-a6d2-89493626bf4f\", \"time\": \"2021-02-20T00:21:54.867231\", \"algorithm_name\": \"credit_card_approval\", \"request_id\": \"req-9f5345b4-a1cd-431c-a43a-bd2a06f4a6f4\", \"algorithm_owner\": \"asli\" } Copy Configure with your API key: Add your New Relic API key to the Datarobot secret store. Set up Datarobot Event Flows with New Relic: See Datarobot's documentation on setting up your connector algorithm to send event-based machine learning flows to New Relic. Monitor your machine learning models [#monitor] Follow these steps to get the most of observing your machine-learning data in New Relic. Get your API key: From one.newrelic.com the account menu, click API keys and then create a user key for your account with a meaningful name. Make note of this name for later. For more on API keys, see our docs. Create a dashboard: From one.newrelic.com go to Dashboards, then click the Import dashboards button. Copy and paste the JSON code into the Paste your JSON field code. Update the YOUR_ACCOUNT_ID values with your account ID. { \"name\": \"Datarobot Dashboard for Default Metrics\", \"description\": null, \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"Datarobot Dashboard for Default Metrics\", \"description\": null, \"widgets\": [ { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Runtime Duration by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT average(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Throughput by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT count(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } Copy Set up alerts notifications: Once you've created some dashboards, you can get alerted on your data. To create a NRQL alerts condition from a chart, click the chart menu , then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Get notified: Once you've created an alerts condition, you can choose how you want to be notified. See our docs on how to set up notification channels. Correlate your incidents: In addition to notifications, you can use Incident Intelligence to correlate your incidents. See our docs on how to correlate incidents using decisions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.40027,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Datarobot <em>MLOps</em> <em>integration</em>",
        "sections": "Datarobot <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "6186e10a28ccbcd8d2cdfd59"
    }
  ],
  "/docs/mlops/integrations/aws-sagemaker-mlops-integration": [
    {
      "sections": [
        "TruEra MLOps integration",
        "What is MLOps?",
        "What is TruEra?",
        "Integrate TruEra with New Relic",
        "Add a Machine Learning Model to TruEra",
        "Stream data from TruEra to New Relic",
        "View out-of-the-box New Relic dashboards using TruEra"
      ],
      "title": "TruEra MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "TruEra integrations"
      ],
      "external_id": "6d0ba2649cebaddb8661e4cdbb8ee8b437c9bc1f",
      "image": "https://docs.newrelic.com/static/15c7d07492de3d07413a8d1c65135584/c1b63/truera_alerts.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/truera-mlops-integration/",
      "published_at": "2021-12-04T15:29:10Z",
      "updated_at": "2021-11-23T21:12:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. What is TruEra? TruEra fills a critical gap in your AI stack, explaining and testing model quality throughout the lifecycle. TruEra’s AI solutions explain, debug, and monitor machine learning models, leading to higher quality and trustworthiness, as well as faster deployment. The solution works across the model lifecycle, is independent of model development platforms, and embeds easily into your existing AI stack. TruEra now offers an integration with New Relic to help MLOps teams correlate signals throughout the ML lifecycle and go beyond standard accuracy, and monitor input and output drifting. Integrate TruEra with New Relic Add a Machine Learning Model to TruEra TruEra provides a command line interface (CLI) and Python client to ingest the machine learning model and other data. Steps to add a model using the CLI include creating a new project, data collection, adding training data, packaging and ingesting the model, and adding production data. These steps can be found on the TruEra technical documentation page. Stream data from TruEra to New Relic Whenever a new set of data is ingested into the Truera Monitoring system, it computes relevant metrics and stores it. These computed metrics can be periodically pushed to New Relic using the truera2newrelic data exporter. This exporter needs API keys generated by the Truera and New Relic consoles. The following instructions will show you how to create these keys: Login into your New Relic account: Log into one.newrelic.com and click on Explorer. On the upper hand corner, on the main navigation menu, click on + Add more data. Click on TruEra: In the search bar, type TruEra or scroll down to the MLOps Integration section, then click on the TruEra icon. Select an account ID: Select the account ID you want TruEra to integrate with. Select or create an API key: You need an Active dashboard key for dashboards management, and a Model metrics data key for metrics ingestion. Create a new key, or select an existing one under the two key sections. Create a key on TruEra: Log into the TruEra console, and go to the users page. Click on Generate Credentials to create an Auth token. Verify the data export run and set up the batch exporter: Now go to TruEra docs to find steps on how to verify the first data export run using commands in your terminal. Next, set up the batch data exporter on a virtual machine. View out-of-the-box New Relic dashboards using TruEra To visualize machine learning monitoring metrics, TruEra provides skeleton dashboards to monitor and drill down on issues using themes like model health, segment drilldown, feature values, data quality, fairness, and more. These dashboards can be set up using the truera2newrelic dashboard tool. To do so, follow these steps: Verify your model metrics: From one.newrelic.com, go to the navigation menu and click on the dashboard tab on the main navigation menu. You will see an automatically generated dashboard setup for the given ML model. Verify that recently exported model metrics are visible. Set up alert notifications: Once you've created some dashboards, you can get alerted on your data. To create a NRQL alerts condition from a chart, click the chart widget, then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Get notified: Once you've created an alerts condition, you can choose how you want to be notified. See our docs on how to set up notification channels. Correlate your incidents: In addition to notifications, you can use Incident Intelligence to correlate your incidents. See our docs on how to correlate incidents using decisions. You’ve now successfully integrated New Relic with TruEra. Newly created alerts are now correlated with your New Relic alerts, and you should be able to see data about newly reported predictions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.07367,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "TruEra <em>MLOps</em> <em>integration</em>",
        "sections": "TruEra <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "619d5931196a670e2fa07e7c"
    },
    {
      "sections": [
        "Superwise MLOps integration",
        "What is MLOps?",
        "What is Superwise?",
        "Migrate Data from Superwise with New Relic",
        "View and explore your Superwise models in New Relic dashboards"
      ],
      "title": "Superwise MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "Superwise integrations"
      ],
      "external_id": "eea57de1a53ec53766ba067ed720283105bc741e",
      "image": "https://docs.newrelic.com/static/79201eea2484599d4f3ededa8819d458/c1b63/superwise2.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/superwise-mlops-integration/",
      "published_at": "2021-12-04T15:29:10Z",
      "updated_at": "2021-11-24T04:47:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. What is Superwise? Superwise now offers an integration with New Relic to help users add the state of their AI as monitored by Superwise to their centralized operational view on New Relic. Migrate Data from Superwise with New Relic Superwise’s KPI and incidents integration streamlines results of our out-of-the-box model KPIs, including drift, activity, incidents, and any custom KPI you configure, directly into New Relic One. You’ll get an immediate overview of which models are misbehaving that can be tailored to any use case, logic, segmentation, threshold, and sensitivity. In order to receive data from Superwise into New Relic, you’ll need to do the following: Login into your New Relic account: Log into one.newrelic.com and click on Explorer. On the upper hand corner, on the main navigation menu, click on + Add more data. Click on Superwise: In the search bar, type Superwise or scroll down to the MLOps Integration section, then click on the Superwise icon. Select an account ID: Select the account ID you want Superwise to integrate with. Create two access tokens: Once you select an Account ID, under Prediction data + Generate Dashboard, click Create a key. This is your new telemetry API key. In addition, under Model quality metric, click Create a Key. This is your Incident Insights key. Keep the New Relic page open for future steps. Log into the Superwise portal: Log into the Superwise portal and go to Notification channel settings. Select New Relic and create a channel name. Copy and paste the token in Superwise: Go back to the New Relic integration dashboard and copy the two tokens you created by clicking on the copy icon next to the API key and Insight key. On Superwise’s portal, on the New Relic channel, paste the API key under Incident Intelligence API, and the Insight key under Telemetry Key. Finish by clicking Save. Verify the Token: Click on the Test button in the Superwise channel portal, to verify both tokens are working properly. A green or red status box should appear to indicate the verification. View and explore your Superwise models in New Relic dashboards Once a user configures the New Relic integration in Superwise, standard model metrics are sent to New Relic and users get model observability dashboards within New Relic. Users can also configure any specific model metric and incident policy and send them to New Relic for model observability tailored to their business context. Go to the integration dashboard: Once you’ve tested your tokens and confirmed the integration is set up correctly, return to the New Relic integration dashboard and click on See your data. This will redirect you to an automatically generated dashboard powered by Superwise. Analyze Superwise’s dashboard. Superwise’s dashboard contains 3 charts: The Model activity chart displays the number of active models, their activity, and the total number of predictions during a filtered timeframe. The Model input drift detection chart displays which models are drifting and may require retraining using a model drift leveler, scaled between 0 and 100. The Incident Insights chart displays how many models have open incidents, how incidents are being distributed, and deeper details on the model incident itself. Customize metrics and incidents in Superwise: Teams can easily customize any model metric and incident type in the Superwise platform. They can then search for these metrics in the New Relic Browser tab under Metrics. To do this, follow the instructions in step 4 in the Superwise docs. Set up alert notifications: Once you've created some dashboards, you can get alerted on your data. To create a NRQL alerts condition from a chart, click the chart widget, then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Get notified: Once you've created an alerts condition, you can choose how you want to be notified. See our docs on how to set up notification channels. Correlate your incidents: In addition to notifications, you can use Incident Intelligence to correlate your incidents. See our docs on how to correlate incidents using decisions. You’ve now successfully integrated New Relic with Superwise. Newly created alerts will now be correlated with your New Relic alerts and you should be able to see data about newly reported predictions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.46695,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Superwise <em>MLOps</em> <em>integration</em>",
        "sections": "Superwise <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "617e42b364441fa664fbc5c7"
    },
    {
      "sections": [
        "Comet MLOps integration",
        "What is MLOps?",
        "The Comet integration",
        "Integrate Comet with New Relic"
      ],
      "title": "Comet MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "Comet integrations"
      ],
      "external_id": "5bd55e6c5d49d480acb50bd0c1830a08aa84ceaf",
      "image": "https://docs.newrelic.com/static/f75787c4d9fd008aad94f01908ee9995/c1b63/comet03.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/comet-mlops-integration/",
      "published_at": "2021-12-04T20:58:08Z",
      "updated_at": "2021-11-06T20:09:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. The Comet integration Comet is an MLOps platform that extends full stack observability to machine learning models, and allows you to establish production performance baselines based on model performance. The Comet integration allows you to integrate machine learning metrics with New Relic, so you can continuosly monitor your data across the full machine learning lifecycle. This helps ensure optimal model performance, and helps you achieve better business outcomes. Integrate Comet with New Relic Use New Relic's Comet integration to get data and insights that help you build better, more accurate machine-learning models, while also improving productivity, collaboration, and visibility across your team. To setup the integration, follow these steps: Log into your New Relic account: Log into one.newrelic.com and click on Explorer. At the upper hand corner, on the main navigation menu, click +Add more data. Click on Comet: Type Comet in the search bar, or scroll down to the MLOps Integration section and click on the Comet icon. Select the account ID you want Comet to integrate with. Select or create an Insight API Key: You need an Insight API Key to integrate with Comet. Create or select an existing API key under the Real time training metric section. Contact Comet: To set up the integration and view the Model Production Monitoring dashboard in Comet, you need to contact Comet. The Comet team will walk you through each step of the integration process and get you all set up. View your insights: Now that you’ve set up your integration, you can start tracking the performance of your machine learning models in a dedicated New Relic One dashboard, which is automatically generated by Comet’s team.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.58255,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Comet <em>MLOps</em> <em>integration</em>",
        "sections": "Comet <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "6186e10a28ccbcdc52cdf889"
    }
  ],
  "/docs/mlops/integrations/comet-mlops-integration": [
    {
      "sections": [
        "Superwise MLOps integration",
        "What is MLOps?",
        "What is Superwise?",
        "Migrate Data from Superwise with New Relic",
        "View and explore your Superwise models in New Relic dashboards"
      ],
      "title": "Superwise MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "Superwise integrations"
      ],
      "external_id": "eea57de1a53ec53766ba067ed720283105bc741e",
      "image": "https://docs.newrelic.com/static/79201eea2484599d4f3ededa8819d458/c1b63/superwise2.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/superwise-mlops-integration/",
      "published_at": "2021-12-04T15:29:10Z",
      "updated_at": "2021-11-24T04:47:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. What is Superwise? Superwise now offers an integration with New Relic to help users add the state of their AI as monitored by Superwise to their centralized operational view on New Relic. Migrate Data from Superwise with New Relic Superwise’s KPI and incidents integration streamlines results of our out-of-the-box model KPIs, including drift, activity, incidents, and any custom KPI you configure, directly into New Relic One. You’ll get an immediate overview of which models are misbehaving that can be tailored to any use case, logic, segmentation, threshold, and sensitivity. In order to receive data from Superwise into New Relic, you’ll need to do the following: Login into your New Relic account: Log into one.newrelic.com and click on Explorer. On the upper hand corner, on the main navigation menu, click on + Add more data. Click on Superwise: In the search bar, type Superwise or scroll down to the MLOps Integration section, then click on the Superwise icon. Select an account ID: Select the account ID you want Superwise to integrate with. Create two access tokens: Once you select an Account ID, under Prediction data + Generate Dashboard, click Create a key. This is your new telemetry API key. In addition, under Model quality metric, click Create a Key. This is your Incident Insights key. Keep the New Relic page open for future steps. Log into the Superwise portal: Log into the Superwise portal and go to Notification channel settings. Select New Relic and create a channel name. Copy and paste the token in Superwise: Go back to the New Relic integration dashboard and copy the two tokens you created by clicking on the copy icon next to the API key and Insight key. On Superwise’s portal, on the New Relic channel, paste the API key under Incident Intelligence API, and the Insight key under Telemetry Key. Finish by clicking Save. Verify the Token: Click on the Test button in the Superwise channel portal, to verify both tokens are working properly. A green or red status box should appear to indicate the verification. View and explore your Superwise models in New Relic dashboards Once a user configures the New Relic integration in Superwise, standard model metrics are sent to New Relic and users get model observability dashboards within New Relic. Users can also configure any specific model metric and incident policy and send them to New Relic for model observability tailored to their business context. Go to the integration dashboard: Once you’ve tested your tokens and confirmed the integration is set up correctly, return to the New Relic integration dashboard and click on See your data. This will redirect you to an automatically generated dashboard powered by Superwise. Analyze Superwise’s dashboard. Superwise’s dashboard contains 3 charts: The Model activity chart displays the number of active models, their activity, and the total number of predictions during a filtered timeframe. The Model input drift detection chart displays which models are drifting and may require retraining using a model drift leveler, scaled between 0 and 100. The Incident Insights chart displays how many models have open incidents, how incidents are being distributed, and deeper details on the model incident itself. Customize metrics and incidents in Superwise: Teams can easily customize any model metric and incident type in the Superwise platform. They can then search for these metrics in the New Relic Browser tab under Metrics. To do this, follow the instructions in step 4 in the Superwise docs. Set up alert notifications: Once you've created some dashboards, you can get alerted on your data. To create a NRQL alerts condition from a chart, click the chart widget, then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Get notified: Once you've created an alerts condition, you can choose how you want to be notified. See our docs on how to set up notification channels. Correlate your incidents: In addition to notifications, you can use Incident Intelligence to correlate your incidents. See our docs on how to correlate incidents using decisions. You’ve now successfully integrated New Relic with Superwise. Newly created alerts will now be correlated with your New Relic alerts and you should be able to see data about newly reported predictions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.19855,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Superwise <em>MLOps</em> <em>integration</em>",
        "sections": "Superwise <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "617e42b364441fa664fbc5c7"
    },
    {
      "sections": [
        "TruEra MLOps integration",
        "What is MLOps?",
        "What is TruEra?",
        "Integrate TruEra with New Relic",
        "Add a Machine Learning Model to TruEra",
        "Stream data from TruEra to New Relic",
        "View out-of-the-box New Relic dashboards using TruEra"
      ],
      "title": "TruEra MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "TruEra integrations"
      ],
      "external_id": "6d0ba2649cebaddb8661e4cdbb8ee8b437c9bc1f",
      "image": "https://docs.newrelic.com/static/15c7d07492de3d07413a8d1c65135584/c1b63/truera_alerts.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/truera-mlops-integration/",
      "published_at": "2021-12-04T15:29:10Z",
      "updated_at": "2021-11-23T21:12:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. What is TruEra? TruEra fills a critical gap in your AI stack, explaining and testing model quality throughout the lifecycle. TruEra’s AI solutions explain, debug, and monitor machine learning models, leading to higher quality and trustworthiness, as well as faster deployment. The solution works across the model lifecycle, is independent of model development platforms, and embeds easily into your existing AI stack. TruEra now offers an integration with New Relic to help MLOps teams correlate signals throughout the ML lifecycle and go beyond standard accuracy, and monitor input and output drifting. Integrate TruEra with New Relic Add a Machine Learning Model to TruEra TruEra provides a command line interface (CLI) and Python client to ingest the machine learning model and other data. Steps to add a model using the CLI include creating a new project, data collection, adding training data, packaging and ingesting the model, and adding production data. These steps can be found on the TruEra technical documentation page. Stream data from TruEra to New Relic Whenever a new set of data is ingested into the Truera Monitoring system, it computes relevant metrics and stores it. These computed metrics can be periodically pushed to New Relic using the truera2newrelic data exporter. This exporter needs API keys generated by the Truera and New Relic consoles. The following instructions will show you how to create these keys: Login into your New Relic account: Log into one.newrelic.com and click on Explorer. On the upper hand corner, on the main navigation menu, click on + Add more data. Click on TruEra: In the search bar, type TruEra or scroll down to the MLOps Integration section, then click on the TruEra icon. Select an account ID: Select the account ID you want TruEra to integrate with. Select or create an API key: You need an Active dashboard key for dashboards management, and a Model metrics data key for metrics ingestion. Create a new key, or select an existing one under the two key sections. Create a key on TruEra: Log into the TruEra console, and go to the users page. Click on Generate Credentials to create an Auth token. Verify the data export run and set up the batch exporter: Now go to TruEra docs to find steps on how to verify the first data export run using commands in your terminal. Next, set up the batch data exporter on a virtual machine. View out-of-the-box New Relic dashboards using TruEra To visualize machine learning monitoring metrics, TruEra provides skeleton dashboards to monitor and drill down on issues using themes like model health, segment drilldown, feature values, data quality, fairness, and more. These dashboards can be set up using the truera2newrelic dashboard tool. To do so, follow these steps: Verify your model metrics: From one.newrelic.com, go to the navigation menu and click on the dashboard tab on the main navigation menu. You will see an automatically generated dashboard setup for the given ML model. Verify that recently exported model metrics are visible. Set up alert notifications: Once you've created some dashboards, you can get alerted on your data. To create a NRQL alerts condition from a chart, click the chart widget, then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Get notified: Once you've created an alerts condition, you can choose how you want to be notified. See our docs on how to set up notification channels. Correlate your incidents: In addition to notifications, you can use Incident Intelligence to correlate your incidents. See our docs on how to correlate incidents using decisions. You’ve now successfully integrated New Relic with TruEra. Newly created alerts are now correlated with your New Relic alerts, and you should be able to see data about newly reported predictions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.66092,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "TruEra <em>MLOps</em> <em>integration</em>",
        "sections": "TruEra <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "619d5931196a670e2fa07e7c"
    },
    {
      "sections": [
        "Datarobot MLOps integration",
        "What is MLOps?",
        "The Datarobot integration",
        "Integrate Datarobot with New Relic",
        "Connect your Datarobot data to New Relic",
        "Monitor your machine learning models [#monitor]"
      ],
      "title": "Datarobot MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "Datarobot integrations"
      ],
      "external_id": "50f76f931cf5783cb47c3b8feee7b9cddb0185c4",
      "image": "https://docs.newrelic.com/static/e5770f365474a584b077b7565f273a79/c1b63/algorithmia-flow.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/datarobot-mlops-integration/",
      "published_at": "2021-12-04T15:29:11Z",
      "updated_at": "2021-11-06T20:09:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. The Datarobot integration Datarobot provides tools for deploying your machine-learning models into production. By integrating, Datarobot's integration with New Relic, you'll be able to instrument, analyze, troubleshoot, and optimize your machine-learning performance across your entire system. By rigorously observing your capabilities, you'll be able to react quickly to changes in the model's input or output and the relationship between the two. Send your model performance metrics from Datarobot Insights to New Relic and you'll have real-time monitoring for your algorithms. You'll explore your metrics data with user-friendly charts and learn the state of your algorithms at a glance for faster and more efficient troubleshooting. Integrate Datarobot with New Relic First, Datarobot uses a Kafka topic to stream Insights from your machine-learning algorithm's performance metrics. Then, the New Relic connector (another algorithm) transforms the Kafka topic into a metrics data payload for a specific New Relic account. Datarobot uses Kafka and Event Flows to send data to New Relic. With Datarobot’s Event Flows, when a new message is set to your Kafka topic, your configured New Relic connector algorithm gets called. The connector transforms your metrics and sends them to your New Relic account. Connect your Datarobot data to New Relic By integrating Incident Intelligence with your Datarobot machine-learning models, you can monitor your machine learning model performance. Start monitoring your Datarobot event flows with New Relic. Get your API key: From one.newrelic.com the account menu, click API keys and then create a user key for your account with a meaningful name. Make note of this name for later. For more on API keys, see our docs. Create a dashboard: From one.newrelic.com go to Dashboards, then click the Import dashboards button. Copy and paste the JSON code into the Paste your JSON field code. Update the YOUR_ACCOUNT_ID values with your account ID. { \"name\": \"Datarobot Dashboard for Default Metrics\", \"description\": null, \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"Datarobot Dashboard for Default Metrics\", \"description\": null, \"widgets\": [ { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Runtime Duration by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT average(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Throughput by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT count(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } Copy Configure Datarobot Insights for New Relic: Use Datarobot's docs for how to configure Datarobot for New Relic. Create the New Relic connector algorithm: Use Python 3.8 to create a connector algorithm. If you're new to writing code to generate algorithms, see Datarobot's getting started guide. import Datarobot import json from datetime import datetime from newrelic_telemetry_sdk import GaugeMetric, MetricClient client = Datarobot.client() metric_client = MetricClient(os.environ[\"newrelic_api_key\"]) def convert_str_timestamp_to_epoch(str_time): obj_time = datetime.strptime(str_time, \"%Y-%m-%dT%H:%M:%S.%f\") return int(obj_time.timestamp() * 1000) def get_operational_metrics(payload): ALGORITHM_TAGS = { \"algorithm_version\", \"request_id\", \"time\", \"algorithm_name\", \"session_id\", \"algorithm_owner\" } inference_metrics = { key: payload[key] for key in payload.keys() ^ ALGORITHM_TAGS } return inference_metrics def send_to_newrelic(inference_metrics, insights_payload): newrelic_metrics = [] for key, value in inference_metrics.items(): name = \"algorithmia.\" + key epoch_time = convert_str_timestamp_to_epoch(insights_payload[\"time\"]) tags = { \"algorithm_name\": insights_payload[\"algorithm_name\"], \"algorithm_version\": insights_payload[\"algorithm_version\"], \"algorithm_owner\": insights_payload[\"algorithm_owner\"], \"request_id\": insights_payload[\"request_id\"], \"session_id\": insights_payload[\"session_id\"], } newrelic_metrics.append(GaugeMetric( name=name, value=value, tags=tags, end_time_ms=epoch_time )) response = metric_client.send_batch(newrelic_metrics) response.raise_for_status() def apply(input): insights_payload = input inference_metrics = get_operational_metrics(insights_payload) send_to_newrelic(inference_metrics, insights_payload) return None Copy Include these dependencies: algorithmia>=1.0.0,<2.0 newrelic_telemetry_sdk==0.4.2 Copy Once your algorithm build finishes, you can test it with this sample payload to make sure it runs successfully. Your output should look something like this. { \"risk_score\": 0.2, \"duration_milliseconds\": 8, \"algorithm_version\": \"1.0.6\", \"session_id\": \"rses-f28bb94a-5556-4aeb-a6d2-89493626bf4f\", \"time\": \"2021-02-20T00:21:54.867231\", \"algorithm_name\": \"credit_card_approval\", \"request_id\": \"req-9f5345b4-a1cd-431c-a43a-bd2a06f4a6f4\", \"algorithm_owner\": \"asli\" } Copy Configure with your API key: Add your New Relic API key to the Datarobot secret store. Set up Datarobot Event Flows with New Relic: See Datarobot's documentation on setting up your connector algorithm to send event-based machine learning flows to New Relic. Monitor your machine learning models [#monitor] Follow these steps to get the most of observing your machine-learning data in New Relic. Get your API key: From one.newrelic.com the account menu, click API keys and then create a user key for your account with a meaningful name. Make note of this name for later. For more on API keys, see our docs. Create a dashboard: From one.newrelic.com go to Dashboards, then click the Import dashboards button. Copy and paste the JSON code into the Paste your JSON field code. Update the YOUR_ACCOUNT_ID values with your account ID. { \"name\": \"Datarobot Dashboard for Default Metrics\", \"description\": null, \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"Datarobot Dashboard for Default Metrics\", \"description\": null, \"widgets\": [ { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Runtime Duration by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT average(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Throughput by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT count(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } Copy Set up alerts notifications: Once you've created some dashboards, you can get alerted on your data. To create a NRQL alerts condition from a chart, click the chart menu , then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Get notified: Once you've created an alerts condition, you can choose how you want to be notified. See our docs on how to set up notification channels. Correlate your incidents: In addition to notifications, you can use Incident Intelligence to correlate your incidents. See our docs on how to correlate incidents using decisions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.40026,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Datarobot <em>MLOps</em> <em>integration</em>",
        "sections": "Datarobot <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "6186e10a28ccbcd8d2cdfd59"
    }
  ],
  "/docs/mlops/integrations/dagshub-mlops-integration": [
    {
      "sections": [
        "Superwise MLOps integration",
        "What is MLOps?",
        "What is Superwise?",
        "Migrate Data from Superwise with New Relic",
        "View and explore your Superwise models in New Relic dashboards"
      ],
      "title": "Superwise MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "Superwise integrations"
      ],
      "external_id": "eea57de1a53ec53766ba067ed720283105bc741e",
      "image": "https://docs.newrelic.com/static/79201eea2484599d4f3ededa8819d458/c1b63/superwise2.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/superwise-mlops-integration/",
      "published_at": "2021-12-04T15:29:10Z",
      "updated_at": "2021-11-24T04:47:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. What is Superwise? Superwise now offers an integration with New Relic to help users add the state of their AI as monitored by Superwise to their centralized operational view on New Relic. Migrate Data from Superwise with New Relic Superwise’s KPI and incidents integration streamlines results of our out-of-the-box model KPIs, including drift, activity, incidents, and any custom KPI you configure, directly into New Relic One. You’ll get an immediate overview of which models are misbehaving that can be tailored to any use case, logic, segmentation, threshold, and sensitivity. In order to receive data from Superwise into New Relic, you’ll need to do the following: Login into your New Relic account: Log into one.newrelic.com and click on Explorer. On the upper hand corner, on the main navigation menu, click on + Add more data. Click on Superwise: In the search bar, type Superwise or scroll down to the MLOps Integration section, then click on the Superwise icon. Select an account ID: Select the account ID you want Superwise to integrate with. Create two access tokens: Once you select an Account ID, under Prediction data + Generate Dashboard, click Create a key. This is your new telemetry API key. In addition, under Model quality metric, click Create a Key. This is your Incident Insights key. Keep the New Relic page open for future steps. Log into the Superwise portal: Log into the Superwise portal and go to Notification channel settings. Select New Relic and create a channel name. Copy and paste the token in Superwise: Go back to the New Relic integration dashboard and copy the two tokens you created by clicking on the copy icon next to the API key and Insight key. On Superwise’s portal, on the New Relic channel, paste the API key under Incident Intelligence API, and the Insight key under Telemetry Key. Finish by clicking Save. Verify the Token: Click on the Test button in the Superwise channel portal, to verify both tokens are working properly. A green or red status box should appear to indicate the verification. View and explore your Superwise models in New Relic dashboards Once a user configures the New Relic integration in Superwise, standard model metrics are sent to New Relic and users get model observability dashboards within New Relic. Users can also configure any specific model metric and incident policy and send them to New Relic for model observability tailored to their business context. Go to the integration dashboard: Once you’ve tested your tokens and confirmed the integration is set up correctly, return to the New Relic integration dashboard and click on See your data. This will redirect you to an automatically generated dashboard powered by Superwise. Analyze Superwise’s dashboard. Superwise’s dashboard contains 3 charts: The Model activity chart displays the number of active models, their activity, and the total number of predictions during a filtered timeframe. The Model input drift detection chart displays which models are drifting and may require retraining using a model drift leveler, scaled between 0 and 100. The Incident Insights chart displays how many models have open incidents, how incidents are being distributed, and deeper details on the model incident itself. Customize metrics and incidents in Superwise: Teams can easily customize any model metric and incident type in the Superwise platform. They can then search for these metrics in the New Relic Browser tab under Metrics. To do this, follow the instructions in step 4 in the Superwise docs. Set up alert notifications: Once you've created some dashboards, you can get alerted on your data. To create a NRQL alerts condition from a chart, click the chart widget, then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Get notified: Once you've created an alerts condition, you can choose how you want to be notified. See our docs on how to set up notification channels. Correlate your incidents: In addition to notifications, you can use Incident Intelligence to correlate your incidents. See our docs on how to correlate incidents using decisions. You’ve now successfully integrated New Relic with Superwise. Newly created alerts will now be correlated with your New Relic alerts and you should be able to see data about newly reported predictions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.19855,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Superwise <em>MLOps</em> <em>integration</em>",
        "sections": "Superwise <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "617e42b364441fa664fbc5c7"
    },
    {
      "sections": [
        "TruEra MLOps integration",
        "What is MLOps?",
        "What is TruEra?",
        "Integrate TruEra with New Relic",
        "Add a Machine Learning Model to TruEra",
        "Stream data from TruEra to New Relic",
        "View out-of-the-box New Relic dashboards using TruEra"
      ],
      "title": "TruEra MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "TruEra integrations"
      ],
      "external_id": "6d0ba2649cebaddb8661e4cdbb8ee8b437c9bc1f",
      "image": "https://docs.newrelic.com/static/15c7d07492de3d07413a8d1c65135584/c1b63/truera_alerts.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/truera-mlops-integration/",
      "published_at": "2021-12-04T15:29:10Z",
      "updated_at": "2021-11-23T21:12:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. What is TruEra? TruEra fills a critical gap in your AI stack, explaining and testing model quality throughout the lifecycle. TruEra’s AI solutions explain, debug, and monitor machine learning models, leading to higher quality and trustworthiness, as well as faster deployment. The solution works across the model lifecycle, is independent of model development platforms, and embeds easily into your existing AI stack. TruEra now offers an integration with New Relic to help MLOps teams correlate signals throughout the ML lifecycle and go beyond standard accuracy, and monitor input and output drifting. Integrate TruEra with New Relic Add a Machine Learning Model to TruEra TruEra provides a command line interface (CLI) and Python client to ingest the machine learning model and other data. Steps to add a model using the CLI include creating a new project, data collection, adding training data, packaging and ingesting the model, and adding production data. These steps can be found on the TruEra technical documentation page. Stream data from TruEra to New Relic Whenever a new set of data is ingested into the Truera Monitoring system, it computes relevant metrics and stores it. These computed metrics can be periodically pushed to New Relic using the truera2newrelic data exporter. This exporter needs API keys generated by the Truera and New Relic consoles. The following instructions will show you how to create these keys: Login into your New Relic account: Log into one.newrelic.com and click on Explorer. On the upper hand corner, on the main navigation menu, click on + Add more data. Click on TruEra: In the search bar, type TruEra or scroll down to the MLOps Integration section, then click on the TruEra icon. Select an account ID: Select the account ID you want TruEra to integrate with. Select or create an API key: You need an Active dashboard key for dashboards management, and a Model metrics data key for metrics ingestion. Create a new key, or select an existing one under the two key sections. Create a key on TruEra: Log into the TruEra console, and go to the users page. Click on Generate Credentials to create an Auth token. Verify the data export run and set up the batch exporter: Now go to TruEra docs to find steps on how to verify the first data export run using commands in your terminal. Next, set up the batch data exporter on a virtual machine. View out-of-the-box New Relic dashboards using TruEra To visualize machine learning monitoring metrics, TruEra provides skeleton dashboards to monitor and drill down on issues using themes like model health, segment drilldown, feature values, data quality, fairness, and more. These dashboards can be set up using the truera2newrelic dashboard tool. To do so, follow these steps: Verify your model metrics: From one.newrelic.com, go to the navigation menu and click on the dashboard tab on the main navigation menu. You will see an automatically generated dashboard setup for the given ML model. Verify that recently exported model metrics are visible. Set up alert notifications: Once you've created some dashboards, you can get alerted on your data. To create a NRQL alerts condition from a chart, click the chart widget, then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Get notified: Once you've created an alerts condition, you can choose how you want to be notified. See our docs on how to set up notification channels. Correlate your incidents: In addition to notifications, you can use Incident Intelligence to correlate your incidents. See our docs on how to correlate incidents using decisions. You’ve now successfully integrated New Relic with TruEra. Newly created alerts are now correlated with your New Relic alerts, and you should be able to see data about newly reported predictions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.66092,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "TruEra <em>MLOps</em> <em>integration</em>",
        "sections": "TruEra <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "619d5931196a670e2fa07e7c"
    },
    {
      "sections": [
        "Datarobot MLOps integration",
        "What is MLOps?",
        "The Datarobot integration",
        "Integrate Datarobot with New Relic",
        "Connect your Datarobot data to New Relic",
        "Monitor your machine learning models [#monitor]"
      ],
      "title": "Datarobot MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "Datarobot integrations"
      ],
      "external_id": "50f76f931cf5783cb47c3b8feee7b9cddb0185c4",
      "image": "https://docs.newrelic.com/static/e5770f365474a584b077b7565f273a79/c1b63/algorithmia-flow.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/datarobot-mlops-integration/",
      "published_at": "2021-12-04T15:29:11Z",
      "updated_at": "2021-11-06T20:09:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. The Datarobot integration Datarobot provides tools for deploying your machine-learning models into production. By integrating, Datarobot's integration with New Relic, you'll be able to instrument, analyze, troubleshoot, and optimize your machine-learning performance across your entire system. By rigorously observing your capabilities, you'll be able to react quickly to changes in the model's input or output and the relationship between the two. Send your model performance metrics from Datarobot Insights to New Relic and you'll have real-time monitoring for your algorithms. You'll explore your metrics data with user-friendly charts and learn the state of your algorithms at a glance for faster and more efficient troubleshooting. Integrate Datarobot with New Relic First, Datarobot uses a Kafka topic to stream Insights from your machine-learning algorithm's performance metrics. Then, the New Relic connector (another algorithm) transforms the Kafka topic into a metrics data payload for a specific New Relic account. Datarobot uses Kafka and Event Flows to send data to New Relic. With Datarobot’s Event Flows, when a new message is set to your Kafka topic, your configured New Relic connector algorithm gets called. The connector transforms your metrics and sends them to your New Relic account. Connect your Datarobot data to New Relic By integrating Incident Intelligence with your Datarobot machine-learning models, you can monitor your machine learning model performance. Start monitoring your Datarobot event flows with New Relic. Get your API key: From one.newrelic.com the account menu, click API keys and then create a user key for your account with a meaningful name. Make note of this name for later. For more on API keys, see our docs. Create a dashboard: From one.newrelic.com go to Dashboards, then click the Import dashboards button. Copy and paste the JSON code into the Paste your JSON field code. Update the YOUR_ACCOUNT_ID values with your account ID. { \"name\": \"Datarobot Dashboard for Default Metrics\", \"description\": null, \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"Datarobot Dashboard for Default Metrics\", \"description\": null, \"widgets\": [ { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Runtime Duration by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT average(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Throughput by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT count(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } Copy Configure Datarobot Insights for New Relic: Use Datarobot's docs for how to configure Datarobot for New Relic. Create the New Relic connector algorithm: Use Python 3.8 to create a connector algorithm. If you're new to writing code to generate algorithms, see Datarobot's getting started guide. import Datarobot import json from datetime import datetime from newrelic_telemetry_sdk import GaugeMetric, MetricClient client = Datarobot.client() metric_client = MetricClient(os.environ[\"newrelic_api_key\"]) def convert_str_timestamp_to_epoch(str_time): obj_time = datetime.strptime(str_time, \"%Y-%m-%dT%H:%M:%S.%f\") return int(obj_time.timestamp() * 1000) def get_operational_metrics(payload): ALGORITHM_TAGS = { \"algorithm_version\", \"request_id\", \"time\", \"algorithm_name\", \"session_id\", \"algorithm_owner\" } inference_metrics = { key: payload[key] for key in payload.keys() ^ ALGORITHM_TAGS } return inference_metrics def send_to_newrelic(inference_metrics, insights_payload): newrelic_metrics = [] for key, value in inference_metrics.items(): name = \"algorithmia.\" + key epoch_time = convert_str_timestamp_to_epoch(insights_payload[\"time\"]) tags = { \"algorithm_name\": insights_payload[\"algorithm_name\"], \"algorithm_version\": insights_payload[\"algorithm_version\"], \"algorithm_owner\": insights_payload[\"algorithm_owner\"], \"request_id\": insights_payload[\"request_id\"], \"session_id\": insights_payload[\"session_id\"], } newrelic_metrics.append(GaugeMetric( name=name, value=value, tags=tags, end_time_ms=epoch_time )) response = metric_client.send_batch(newrelic_metrics) response.raise_for_status() def apply(input): insights_payload = input inference_metrics = get_operational_metrics(insights_payload) send_to_newrelic(inference_metrics, insights_payload) return None Copy Include these dependencies: algorithmia>=1.0.0,<2.0 newrelic_telemetry_sdk==0.4.2 Copy Once your algorithm build finishes, you can test it with this sample payload to make sure it runs successfully. Your output should look something like this. { \"risk_score\": 0.2, \"duration_milliseconds\": 8, \"algorithm_version\": \"1.0.6\", \"session_id\": \"rses-f28bb94a-5556-4aeb-a6d2-89493626bf4f\", \"time\": \"2021-02-20T00:21:54.867231\", \"algorithm_name\": \"credit_card_approval\", \"request_id\": \"req-9f5345b4-a1cd-431c-a43a-bd2a06f4a6f4\", \"algorithm_owner\": \"asli\" } Copy Configure with your API key: Add your New Relic API key to the Datarobot secret store. Set up Datarobot Event Flows with New Relic: See Datarobot's documentation on setting up your connector algorithm to send event-based machine learning flows to New Relic. Monitor your machine learning models [#monitor] Follow these steps to get the most of observing your machine-learning data in New Relic. Get your API key: From one.newrelic.com the account menu, click API keys and then create a user key for your account with a meaningful name. Make note of this name for later. For more on API keys, see our docs. Create a dashboard: From one.newrelic.com go to Dashboards, then click the Import dashboards button. Copy and paste the JSON code into the Paste your JSON field code. Update the YOUR_ACCOUNT_ID values with your account ID. { \"name\": \"Datarobot Dashboard for Default Metrics\", \"description\": null, \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"Datarobot Dashboard for Default Metrics\", \"description\": null, \"widgets\": [ { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Runtime Duration by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT average(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Throughput by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT count(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } Copy Set up alerts notifications: Once you've created some dashboards, you can get alerted on your data. To create a NRQL alerts condition from a chart, click the chart menu , then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Get notified: Once you've created an alerts condition, you can choose how you want to be notified. See our docs on how to set up notification channels. Correlate your incidents: In addition to notifications, you can use Incident Intelligence to correlate your incidents. See our docs on how to correlate incidents using decisions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.40026,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Datarobot <em>MLOps</em> <em>integration</em>",
        "sections": "Datarobot <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "6186e10a28ccbcd8d2cdfd59"
    }
  ],
  "/docs/mlops/integrations/datarobot-mlops-integration": [
    {
      "sections": [
        "Superwise MLOps integration",
        "What is MLOps?",
        "What is Superwise?",
        "Migrate Data from Superwise with New Relic",
        "View and explore your Superwise models in New Relic dashboards"
      ],
      "title": "Superwise MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "Superwise integrations"
      ],
      "external_id": "eea57de1a53ec53766ba067ed720283105bc741e",
      "image": "https://docs.newrelic.com/static/79201eea2484599d4f3ededa8819d458/c1b63/superwise2.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/superwise-mlops-integration/",
      "published_at": "2021-12-04T15:29:10Z",
      "updated_at": "2021-11-24T04:47:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. What is Superwise? Superwise now offers an integration with New Relic to help users add the state of their AI as monitored by Superwise to their centralized operational view on New Relic. Migrate Data from Superwise with New Relic Superwise’s KPI and incidents integration streamlines results of our out-of-the-box model KPIs, including drift, activity, incidents, and any custom KPI you configure, directly into New Relic One. You’ll get an immediate overview of which models are misbehaving that can be tailored to any use case, logic, segmentation, threshold, and sensitivity. In order to receive data from Superwise into New Relic, you’ll need to do the following: Login into your New Relic account: Log into one.newrelic.com and click on Explorer. On the upper hand corner, on the main navigation menu, click on + Add more data. Click on Superwise: In the search bar, type Superwise or scroll down to the MLOps Integration section, then click on the Superwise icon. Select an account ID: Select the account ID you want Superwise to integrate with. Create two access tokens: Once you select an Account ID, under Prediction data + Generate Dashboard, click Create a key. This is your new telemetry API key. In addition, under Model quality metric, click Create a Key. This is your Incident Insights key. Keep the New Relic page open for future steps. Log into the Superwise portal: Log into the Superwise portal and go to Notification channel settings. Select New Relic and create a channel name. Copy and paste the token in Superwise: Go back to the New Relic integration dashboard and copy the two tokens you created by clicking on the copy icon next to the API key and Insight key. On Superwise’s portal, on the New Relic channel, paste the API key under Incident Intelligence API, and the Insight key under Telemetry Key. Finish by clicking Save. Verify the Token: Click on the Test button in the Superwise channel portal, to verify both tokens are working properly. A green or red status box should appear to indicate the verification. View and explore your Superwise models in New Relic dashboards Once a user configures the New Relic integration in Superwise, standard model metrics are sent to New Relic and users get model observability dashboards within New Relic. Users can also configure any specific model metric and incident policy and send them to New Relic for model observability tailored to their business context. Go to the integration dashboard: Once you’ve tested your tokens and confirmed the integration is set up correctly, return to the New Relic integration dashboard and click on See your data. This will redirect you to an automatically generated dashboard powered by Superwise. Analyze Superwise’s dashboard. Superwise’s dashboard contains 3 charts: The Model activity chart displays the number of active models, their activity, and the total number of predictions during a filtered timeframe. The Model input drift detection chart displays which models are drifting and may require retraining using a model drift leveler, scaled between 0 and 100. The Incident Insights chart displays how many models have open incidents, how incidents are being distributed, and deeper details on the model incident itself. Customize metrics and incidents in Superwise: Teams can easily customize any model metric and incident type in the Superwise platform. They can then search for these metrics in the New Relic Browser tab under Metrics. To do this, follow the instructions in step 4 in the Superwise docs. Set up alert notifications: Once you've created some dashboards, you can get alerted on your data. To create a NRQL alerts condition from a chart, click the chart widget, then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Get notified: Once you've created an alerts condition, you can choose how you want to be notified. See our docs on how to set up notification channels. Correlate your incidents: In addition to notifications, you can use Incident Intelligence to correlate your incidents. See our docs on how to correlate incidents using decisions. You’ve now successfully integrated New Relic with Superwise. Newly created alerts will now be correlated with your New Relic alerts and you should be able to see data about newly reported predictions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.19853,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Superwise <em>MLOps</em> <em>integration</em>",
        "sections": "Superwise <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "617e42b364441fa664fbc5c7"
    },
    {
      "sections": [
        "TruEra MLOps integration",
        "What is MLOps?",
        "What is TruEra?",
        "Integrate TruEra with New Relic",
        "Add a Machine Learning Model to TruEra",
        "Stream data from TruEra to New Relic",
        "View out-of-the-box New Relic dashboards using TruEra"
      ],
      "title": "TruEra MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "TruEra integrations"
      ],
      "external_id": "6d0ba2649cebaddb8661e4cdbb8ee8b437c9bc1f",
      "image": "https://docs.newrelic.com/static/15c7d07492de3d07413a8d1c65135584/c1b63/truera_alerts.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/truera-mlops-integration/",
      "published_at": "2021-12-04T15:29:10Z",
      "updated_at": "2021-11-23T21:12:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. What is TruEra? TruEra fills a critical gap in your AI stack, explaining and testing model quality throughout the lifecycle. TruEra’s AI solutions explain, debug, and monitor machine learning models, leading to higher quality and trustworthiness, as well as faster deployment. The solution works across the model lifecycle, is independent of model development platforms, and embeds easily into your existing AI stack. TruEra now offers an integration with New Relic to help MLOps teams correlate signals throughout the ML lifecycle and go beyond standard accuracy, and monitor input and output drifting. Integrate TruEra with New Relic Add a Machine Learning Model to TruEra TruEra provides a command line interface (CLI) and Python client to ingest the machine learning model and other data. Steps to add a model using the CLI include creating a new project, data collection, adding training data, packaging and ingesting the model, and adding production data. These steps can be found on the TruEra technical documentation page. Stream data from TruEra to New Relic Whenever a new set of data is ingested into the Truera Monitoring system, it computes relevant metrics and stores it. These computed metrics can be periodically pushed to New Relic using the truera2newrelic data exporter. This exporter needs API keys generated by the Truera and New Relic consoles. The following instructions will show you how to create these keys: Login into your New Relic account: Log into one.newrelic.com and click on Explorer. On the upper hand corner, on the main navigation menu, click on + Add more data. Click on TruEra: In the search bar, type TruEra or scroll down to the MLOps Integration section, then click on the TruEra icon. Select an account ID: Select the account ID you want TruEra to integrate with. Select or create an API key: You need an Active dashboard key for dashboards management, and a Model metrics data key for metrics ingestion. Create a new key, or select an existing one under the two key sections. Create a key on TruEra: Log into the TruEra console, and go to the users page. Click on Generate Credentials to create an Auth token. Verify the data export run and set up the batch exporter: Now go to TruEra docs to find steps on how to verify the first data export run using commands in your terminal. Next, set up the batch data exporter on a virtual machine. View out-of-the-box New Relic dashboards using TruEra To visualize machine learning monitoring metrics, TruEra provides skeleton dashboards to monitor and drill down on issues using themes like model health, segment drilldown, feature values, data quality, fairness, and more. These dashboards can be set up using the truera2newrelic dashboard tool. To do so, follow these steps: Verify your model metrics: From one.newrelic.com, go to the navigation menu and click on the dashboard tab on the main navigation menu. You will see an automatically generated dashboard setup for the given ML model. Verify that recently exported model metrics are visible. Set up alert notifications: Once you've created some dashboards, you can get alerted on your data. To create a NRQL alerts condition from a chart, click the chart widget, then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Get notified: Once you've created an alerts condition, you can choose how you want to be notified. See our docs on how to set up notification channels. Correlate your incidents: In addition to notifications, you can use Incident Intelligence to correlate your incidents. See our docs on how to correlate incidents using decisions. You’ve now successfully integrated New Relic with TruEra. Newly created alerts are now correlated with your New Relic alerts, and you should be able to see data about newly reported predictions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.6609,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "TruEra <em>MLOps</em> <em>integration</em>",
        "sections": "TruEra <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "619d5931196a670e2fa07e7c"
    },
    {
      "sections": [
        "Comet MLOps integration",
        "What is MLOps?",
        "The Comet integration",
        "Integrate Comet with New Relic"
      ],
      "title": "Comet MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "Comet integrations"
      ],
      "external_id": "5bd55e6c5d49d480acb50bd0c1830a08aa84ceaf",
      "image": "https://docs.newrelic.com/static/f75787c4d9fd008aad94f01908ee9995/c1b63/comet03.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/comet-mlops-integration/",
      "published_at": "2021-12-04T20:58:08Z",
      "updated_at": "2021-11-06T20:09:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. The Comet integration Comet is an MLOps platform that extends full stack observability to machine learning models, and allows you to establish production performance baselines based on model performance. The Comet integration allows you to integrate machine learning metrics with New Relic, so you can continuosly monitor your data across the full machine learning lifecycle. This helps ensure optimal model performance, and helps you achieve better business outcomes. Integrate Comet with New Relic Use New Relic's Comet integration to get data and insights that help you build better, more accurate machine-learning models, while also improving productivity, collaboration, and visibility across your team. To setup the integration, follow these steps: Log into your New Relic account: Log into one.newrelic.com and click on Explorer. At the upper hand corner, on the main navigation menu, click +Add more data. Click on Comet: Type Comet in the search bar, or scroll down to the MLOps Integration section and click on the Comet icon. Select the account ID you want Comet to integrate with. Select or create an Insight API Key: You need an Insight API Key to integrate with Comet. Create or select an existing API key under the Real time training metric section. Contact Comet: To set up the integration and view the Model Production Monitoring dashboard in Comet, you need to contact Comet. The Comet team will walk you through each step of the integration process and get you all set up. View your insights: Now that you’ve set up your integration, you can start tracking the performance of your machine learning models in a dedicated New Relic One dashboard, which is automatically generated by Comet’s team.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.40025,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Comet <em>MLOps</em> <em>integration</em>",
        "sections": "Comet <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "6186e10a28ccbcdc52cdf889"
    }
  ],
  "/docs/mlops/integrations/mona-mlops-integration": [
    {
      "sections": [
        "Superwise MLOps integration",
        "What is MLOps?",
        "What is Superwise?",
        "Migrate Data from Superwise with New Relic",
        "View and explore your Superwise models in New Relic dashboards"
      ],
      "title": "Superwise MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "Superwise integrations"
      ],
      "external_id": "eea57de1a53ec53766ba067ed720283105bc741e",
      "image": "https://docs.newrelic.com/static/79201eea2484599d4f3ededa8819d458/c1b63/superwise2.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/superwise-mlops-integration/",
      "published_at": "2021-12-04T15:29:10Z",
      "updated_at": "2021-11-24T04:47:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. What is Superwise? Superwise now offers an integration with New Relic to help users add the state of their AI as monitored by Superwise to their centralized operational view on New Relic. Migrate Data from Superwise with New Relic Superwise’s KPI and incidents integration streamlines results of our out-of-the-box model KPIs, including drift, activity, incidents, and any custom KPI you configure, directly into New Relic One. You’ll get an immediate overview of which models are misbehaving that can be tailored to any use case, logic, segmentation, threshold, and sensitivity. In order to receive data from Superwise into New Relic, you’ll need to do the following: Login into your New Relic account: Log into one.newrelic.com and click on Explorer. On the upper hand corner, on the main navigation menu, click on + Add more data. Click on Superwise: In the search bar, type Superwise or scroll down to the MLOps Integration section, then click on the Superwise icon. Select an account ID: Select the account ID you want Superwise to integrate with. Create two access tokens: Once you select an Account ID, under Prediction data + Generate Dashboard, click Create a key. This is your new telemetry API key. In addition, under Model quality metric, click Create a Key. This is your Incident Insights key. Keep the New Relic page open for future steps. Log into the Superwise portal: Log into the Superwise portal and go to Notification channel settings. Select New Relic and create a channel name. Copy and paste the token in Superwise: Go back to the New Relic integration dashboard and copy the two tokens you created by clicking on the copy icon next to the API key and Insight key. On Superwise’s portal, on the New Relic channel, paste the API key under Incident Intelligence API, and the Insight key under Telemetry Key. Finish by clicking Save. Verify the Token: Click on the Test button in the Superwise channel portal, to verify both tokens are working properly. A green or red status box should appear to indicate the verification. View and explore your Superwise models in New Relic dashboards Once a user configures the New Relic integration in Superwise, standard model metrics are sent to New Relic and users get model observability dashboards within New Relic. Users can also configure any specific model metric and incident policy and send them to New Relic for model observability tailored to their business context. Go to the integration dashboard: Once you’ve tested your tokens and confirmed the integration is set up correctly, return to the New Relic integration dashboard and click on See your data. This will redirect you to an automatically generated dashboard powered by Superwise. Analyze Superwise’s dashboard. Superwise’s dashboard contains 3 charts: The Model activity chart displays the number of active models, their activity, and the total number of predictions during a filtered timeframe. The Model input drift detection chart displays which models are drifting and may require retraining using a model drift leveler, scaled between 0 and 100. The Incident Insights chart displays how many models have open incidents, how incidents are being distributed, and deeper details on the model incident itself. Customize metrics and incidents in Superwise: Teams can easily customize any model metric and incident type in the Superwise platform. They can then search for these metrics in the New Relic Browser tab under Metrics. To do this, follow the instructions in step 4 in the Superwise docs. Set up alert notifications: Once you've created some dashboards, you can get alerted on your data. To create a NRQL alerts condition from a chart, click the chart widget, then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Get notified: Once you've created an alerts condition, you can choose how you want to be notified. See our docs on how to set up notification channels. Correlate your incidents: In addition to notifications, you can use Incident Intelligence to correlate your incidents. See our docs on how to correlate incidents using decisions. You’ve now successfully integrated New Relic with Superwise. Newly created alerts will now be correlated with your New Relic alerts and you should be able to see data about newly reported predictions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.19853,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Superwise <em>MLOps</em> <em>integration</em>",
        "sections": "Superwise <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "617e42b364441fa664fbc5c7"
    },
    {
      "sections": [
        "TruEra MLOps integration",
        "What is MLOps?",
        "What is TruEra?",
        "Integrate TruEra with New Relic",
        "Add a Machine Learning Model to TruEra",
        "Stream data from TruEra to New Relic",
        "View out-of-the-box New Relic dashboards using TruEra"
      ],
      "title": "TruEra MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "TruEra integrations"
      ],
      "external_id": "6d0ba2649cebaddb8661e4cdbb8ee8b437c9bc1f",
      "image": "https://docs.newrelic.com/static/15c7d07492de3d07413a8d1c65135584/c1b63/truera_alerts.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/truera-mlops-integration/",
      "published_at": "2021-12-04T15:29:10Z",
      "updated_at": "2021-11-23T21:12:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. What is TruEra? TruEra fills a critical gap in your AI stack, explaining and testing model quality throughout the lifecycle. TruEra’s AI solutions explain, debug, and monitor machine learning models, leading to higher quality and trustworthiness, as well as faster deployment. The solution works across the model lifecycle, is independent of model development platforms, and embeds easily into your existing AI stack. TruEra now offers an integration with New Relic to help MLOps teams correlate signals throughout the ML lifecycle and go beyond standard accuracy, and monitor input and output drifting. Integrate TruEra with New Relic Add a Machine Learning Model to TruEra TruEra provides a command line interface (CLI) and Python client to ingest the machine learning model and other data. Steps to add a model using the CLI include creating a new project, data collection, adding training data, packaging and ingesting the model, and adding production data. These steps can be found on the TruEra technical documentation page. Stream data from TruEra to New Relic Whenever a new set of data is ingested into the Truera Monitoring system, it computes relevant metrics and stores it. These computed metrics can be periodically pushed to New Relic using the truera2newrelic data exporter. This exporter needs API keys generated by the Truera and New Relic consoles. The following instructions will show you how to create these keys: Login into your New Relic account: Log into one.newrelic.com and click on Explorer. On the upper hand corner, on the main navigation menu, click on + Add more data. Click on TruEra: In the search bar, type TruEra or scroll down to the MLOps Integration section, then click on the TruEra icon. Select an account ID: Select the account ID you want TruEra to integrate with. Select or create an API key: You need an Active dashboard key for dashboards management, and a Model metrics data key for metrics ingestion. Create a new key, or select an existing one under the two key sections. Create a key on TruEra: Log into the TruEra console, and go to the users page. Click on Generate Credentials to create an Auth token. Verify the data export run and set up the batch exporter: Now go to TruEra docs to find steps on how to verify the first data export run using commands in your terminal. Next, set up the batch data exporter on a virtual machine. View out-of-the-box New Relic dashboards using TruEra To visualize machine learning monitoring metrics, TruEra provides skeleton dashboards to monitor and drill down on issues using themes like model health, segment drilldown, feature values, data quality, fairness, and more. These dashboards can be set up using the truera2newrelic dashboard tool. To do so, follow these steps: Verify your model metrics: From one.newrelic.com, go to the navigation menu and click on the dashboard tab on the main navigation menu. You will see an automatically generated dashboard setup for the given ML model. Verify that recently exported model metrics are visible. Set up alert notifications: Once you've created some dashboards, you can get alerted on your data. To create a NRQL alerts condition from a chart, click the chart widget, then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Get notified: Once you've created an alerts condition, you can choose how you want to be notified. See our docs on how to set up notification channels. Correlate your incidents: In addition to notifications, you can use Incident Intelligence to correlate your incidents. See our docs on how to correlate incidents using decisions. You’ve now successfully integrated New Relic with TruEra. Newly created alerts are now correlated with your New Relic alerts, and you should be able to see data about newly reported predictions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.6609,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "TruEra <em>MLOps</em> <em>integration</em>",
        "sections": "TruEra <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "619d5931196a670e2fa07e7c"
    },
    {
      "sections": [
        "Datarobot MLOps integration",
        "What is MLOps?",
        "The Datarobot integration",
        "Integrate Datarobot with New Relic",
        "Connect your Datarobot data to New Relic",
        "Monitor your machine learning models [#monitor]"
      ],
      "title": "Datarobot MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "Datarobot integrations"
      ],
      "external_id": "50f76f931cf5783cb47c3b8feee7b9cddb0185c4",
      "image": "https://docs.newrelic.com/static/e5770f365474a584b077b7565f273a79/c1b63/algorithmia-flow.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/datarobot-mlops-integration/",
      "published_at": "2021-12-04T15:29:11Z",
      "updated_at": "2021-11-06T20:09:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. The Datarobot integration Datarobot provides tools for deploying your machine-learning models into production. By integrating, Datarobot's integration with New Relic, you'll be able to instrument, analyze, troubleshoot, and optimize your machine-learning performance across your entire system. By rigorously observing your capabilities, you'll be able to react quickly to changes in the model's input or output and the relationship between the two. Send your model performance metrics from Datarobot Insights to New Relic and you'll have real-time monitoring for your algorithms. You'll explore your metrics data with user-friendly charts and learn the state of your algorithms at a glance for faster and more efficient troubleshooting. Integrate Datarobot with New Relic First, Datarobot uses a Kafka topic to stream Insights from your machine-learning algorithm's performance metrics. Then, the New Relic connector (another algorithm) transforms the Kafka topic into a metrics data payload for a specific New Relic account. Datarobot uses Kafka and Event Flows to send data to New Relic. With Datarobot’s Event Flows, when a new message is set to your Kafka topic, your configured New Relic connector algorithm gets called. The connector transforms your metrics and sends them to your New Relic account. Connect your Datarobot data to New Relic By integrating Incident Intelligence with your Datarobot machine-learning models, you can monitor your machine learning model performance. Start monitoring your Datarobot event flows with New Relic. Get your API key: From one.newrelic.com the account menu, click API keys and then create a user key for your account with a meaningful name. Make note of this name for later. For more on API keys, see our docs. Create a dashboard: From one.newrelic.com go to Dashboards, then click the Import dashboards button. Copy and paste the JSON code into the Paste your JSON field code. Update the YOUR_ACCOUNT_ID values with your account ID. { \"name\": \"Datarobot Dashboard for Default Metrics\", \"description\": null, \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"Datarobot Dashboard for Default Metrics\", \"description\": null, \"widgets\": [ { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Runtime Duration by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT average(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Throughput by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT count(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } Copy Configure Datarobot Insights for New Relic: Use Datarobot's docs for how to configure Datarobot for New Relic. Create the New Relic connector algorithm: Use Python 3.8 to create a connector algorithm. If you're new to writing code to generate algorithms, see Datarobot's getting started guide. import Datarobot import json from datetime import datetime from newrelic_telemetry_sdk import GaugeMetric, MetricClient client = Datarobot.client() metric_client = MetricClient(os.environ[\"newrelic_api_key\"]) def convert_str_timestamp_to_epoch(str_time): obj_time = datetime.strptime(str_time, \"%Y-%m-%dT%H:%M:%S.%f\") return int(obj_time.timestamp() * 1000) def get_operational_metrics(payload): ALGORITHM_TAGS = { \"algorithm_version\", \"request_id\", \"time\", \"algorithm_name\", \"session_id\", \"algorithm_owner\" } inference_metrics = { key: payload[key] for key in payload.keys() ^ ALGORITHM_TAGS } return inference_metrics def send_to_newrelic(inference_metrics, insights_payload): newrelic_metrics = [] for key, value in inference_metrics.items(): name = \"algorithmia.\" + key epoch_time = convert_str_timestamp_to_epoch(insights_payload[\"time\"]) tags = { \"algorithm_name\": insights_payload[\"algorithm_name\"], \"algorithm_version\": insights_payload[\"algorithm_version\"], \"algorithm_owner\": insights_payload[\"algorithm_owner\"], \"request_id\": insights_payload[\"request_id\"], \"session_id\": insights_payload[\"session_id\"], } newrelic_metrics.append(GaugeMetric( name=name, value=value, tags=tags, end_time_ms=epoch_time )) response = metric_client.send_batch(newrelic_metrics) response.raise_for_status() def apply(input): insights_payload = input inference_metrics = get_operational_metrics(insights_payload) send_to_newrelic(inference_metrics, insights_payload) return None Copy Include these dependencies: algorithmia>=1.0.0,<2.0 newrelic_telemetry_sdk==0.4.2 Copy Once your algorithm build finishes, you can test it with this sample payload to make sure it runs successfully. Your output should look something like this. { \"risk_score\": 0.2, \"duration_milliseconds\": 8, \"algorithm_version\": \"1.0.6\", \"session_id\": \"rses-f28bb94a-5556-4aeb-a6d2-89493626bf4f\", \"time\": \"2021-02-20T00:21:54.867231\", \"algorithm_name\": \"credit_card_approval\", \"request_id\": \"req-9f5345b4-a1cd-431c-a43a-bd2a06f4a6f4\", \"algorithm_owner\": \"asli\" } Copy Configure with your API key: Add your New Relic API key to the Datarobot secret store. Set up Datarobot Event Flows with New Relic: See Datarobot's documentation on setting up your connector algorithm to send event-based machine learning flows to New Relic. Monitor your machine learning models [#monitor] Follow these steps to get the most of observing your machine-learning data in New Relic. Get your API key: From one.newrelic.com the account menu, click API keys and then create a user key for your account with a meaningful name. Make note of this name for later. For more on API keys, see our docs. Create a dashboard: From one.newrelic.com go to Dashboards, then click the Import dashboards button. Copy and paste the JSON code into the Paste your JSON field code. Update the YOUR_ACCOUNT_ID values with your account ID. { \"name\": \"Datarobot Dashboard for Default Metrics\", \"description\": null, \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"Datarobot Dashboard for Default Metrics\", \"description\": null, \"widgets\": [ { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Runtime Duration by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT average(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Throughput by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT count(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } Copy Set up alerts notifications: Once you've created some dashboards, you can get alerted on your data. To create a NRQL alerts condition from a chart, click the chart menu , then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Get notified: Once you've created an alerts condition, you can choose how you want to be notified. See our docs on how to set up notification channels. Correlate your incidents: In addition to notifications, you can use Incident Intelligence to correlate your incidents. See our docs on how to correlate incidents using decisions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.40025,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Datarobot <em>MLOps</em> <em>integration</em>",
        "sections": "Datarobot <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "6186e10a28ccbcd8d2cdfd59"
    }
  ],
  "/docs/mlops/integrations/superwise-mlops-integration": [
    {
      "sections": [
        "TruEra MLOps integration",
        "What is MLOps?",
        "What is TruEra?",
        "Integrate TruEra with New Relic",
        "Add a Machine Learning Model to TruEra",
        "Stream data from TruEra to New Relic",
        "View out-of-the-box New Relic dashboards using TruEra"
      ],
      "title": "TruEra MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "TruEra integrations"
      ],
      "external_id": "6d0ba2649cebaddb8661e4cdbb8ee8b437c9bc1f",
      "image": "https://docs.newrelic.com/static/15c7d07492de3d07413a8d1c65135584/c1b63/truera_alerts.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/truera-mlops-integration/",
      "published_at": "2021-12-04T15:29:10Z",
      "updated_at": "2021-11-23T21:12:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. What is TruEra? TruEra fills a critical gap in your AI stack, explaining and testing model quality throughout the lifecycle. TruEra’s AI solutions explain, debug, and monitor machine learning models, leading to higher quality and trustworthiness, as well as faster deployment. The solution works across the model lifecycle, is independent of model development platforms, and embeds easily into your existing AI stack. TruEra now offers an integration with New Relic to help MLOps teams correlate signals throughout the ML lifecycle and go beyond standard accuracy, and monitor input and output drifting. Integrate TruEra with New Relic Add a Machine Learning Model to TruEra TruEra provides a command line interface (CLI) and Python client to ingest the machine learning model and other data. Steps to add a model using the CLI include creating a new project, data collection, adding training data, packaging and ingesting the model, and adding production data. These steps can be found on the TruEra technical documentation page. Stream data from TruEra to New Relic Whenever a new set of data is ingested into the Truera Monitoring system, it computes relevant metrics and stores it. These computed metrics can be periodically pushed to New Relic using the truera2newrelic data exporter. This exporter needs API keys generated by the Truera and New Relic consoles. The following instructions will show you how to create these keys: Login into your New Relic account: Log into one.newrelic.com and click on Explorer. On the upper hand corner, on the main navigation menu, click on + Add more data. Click on TruEra: In the search bar, type TruEra or scroll down to the MLOps Integration section, then click on the TruEra icon. Select an account ID: Select the account ID you want TruEra to integrate with. Select or create an API key: You need an Active dashboard key for dashboards management, and a Model metrics data key for metrics ingestion. Create a new key, or select an existing one under the two key sections. Create a key on TruEra: Log into the TruEra console, and go to the users page. Click on Generate Credentials to create an Auth token. Verify the data export run and set up the batch exporter: Now go to TruEra docs to find steps on how to verify the first data export run using commands in your terminal. Next, set up the batch data exporter on a virtual machine. View out-of-the-box New Relic dashboards using TruEra To visualize machine learning monitoring metrics, TruEra provides skeleton dashboards to monitor and drill down on issues using themes like model health, segment drilldown, feature values, data quality, fairness, and more. These dashboards can be set up using the truera2newrelic dashboard tool. To do so, follow these steps: Verify your model metrics: From one.newrelic.com, go to the navigation menu and click on the dashboard tab on the main navigation menu. You will see an automatically generated dashboard setup for the given ML model. Verify that recently exported model metrics are visible. Set up alert notifications: Once you've created some dashboards, you can get alerted on your data. To create a NRQL alerts condition from a chart, click the chart widget, then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Get notified: Once you've created an alerts condition, you can choose how you want to be notified. See our docs on how to set up notification channels. Correlate your incidents: In addition to notifications, you can use Incident Intelligence to correlate your incidents. See our docs on how to correlate incidents using decisions. You’ve now successfully integrated New Relic with TruEra. Newly created alerts are now correlated with your New Relic alerts, and you should be able to see data about newly reported predictions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.77642,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "TruEra <em>MLOps</em> <em>integration</em>",
        "sections": "TruEra <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "619d5931196a670e2fa07e7c"
    },
    {
      "sections": [
        "Datarobot MLOps integration",
        "What is MLOps?",
        "The Datarobot integration",
        "Integrate Datarobot with New Relic",
        "Connect your Datarobot data to New Relic",
        "Monitor your machine learning models [#monitor]"
      ],
      "title": "Datarobot MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "Datarobot integrations"
      ],
      "external_id": "50f76f931cf5783cb47c3b8feee7b9cddb0185c4",
      "image": "https://docs.newrelic.com/static/e5770f365474a584b077b7565f273a79/c1b63/algorithmia-flow.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/datarobot-mlops-integration/",
      "published_at": "2021-12-04T15:29:11Z",
      "updated_at": "2021-11-06T20:09:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. The Datarobot integration Datarobot provides tools for deploying your machine-learning models into production. By integrating, Datarobot's integration with New Relic, you'll be able to instrument, analyze, troubleshoot, and optimize your machine-learning performance across your entire system. By rigorously observing your capabilities, you'll be able to react quickly to changes in the model's input or output and the relationship between the two. Send your model performance metrics from Datarobot Insights to New Relic and you'll have real-time monitoring for your algorithms. You'll explore your metrics data with user-friendly charts and learn the state of your algorithms at a glance for faster and more efficient troubleshooting. Integrate Datarobot with New Relic First, Datarobot uses a Kafka topic to stream Insights from your machine-learning algorithm's performance metrics. Then, the New Relic connector (another algorithm) transforms the Kafka topic into a metrics data payload for a specific New Relic account. Datarobot uses Kafka and Event Flows to send data to New Relic. With Datarobot’s Event Flows, when a new message is set to your Kafka topic, your configured New Relic connector algorithm gets called. The connector transforms your metrics and sends them to your New Relic account. Connect your Datarobot data to New Relic By integrating Incident Intelligence with your Datarobot machine-learning models, you can monitor your machine learning model performance. Start monitoring your Datarobot event flows with New Relic. Get your API key: From one.newrelic.com the account menu, click API keys and then create a user key for your account with a meaningful name. Make note of this name for later. For more on API keys, see our docs. Create a dashboard: From one.newrelic.com go to Dashboards, then click the Import dashboards button. Copy and paste the JSON code into the Paste your JSON field code. Update the YOUR_ACCOUNT_ID values with your account ID. { \"name\": \"Datarobot Dashboard for Default Metrics\", \"description\": null, \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"Datarobot Dashboard for Default Metrics\", \"description\": null, \"widgets\": [ { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Runtime Duration by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT average(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Throughput by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT count(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } Copy Configure Datarobot Insights for New Relic: Use Datarobot's docs for how to configure Datarobot for New Relic. Create the New Relic connector algorithm: Use Python 3.8 to create a connector algorithm. If you're new to writing code to generate algorithms, see Datarobot's getting started guide. import Datarobot import json from datetime import datetime from newrelic_telemetry_sdk import GaugeMetric, MetricClient client = Datarobot.client() metric_client = MetricClient(os.environ[\"newrelic_api_key\"]) def convert_str_timestamp_to_epoch(str_time): obj_time = datetime.strptime(str_time, \"%Y-%m-%dT%H:%M:%S.%f\") return int(obj_time.timestamp() * 1000) def get_operational_metrics(payload): ALGORITHM_TAGS = { \"algorithm_version\", \"request_id\", \"time\", \"algorithm_name\", \"session_id\", \"algorithm_owner\" } inference_metrics = { key: payload[key] for key in payload.keys() ^ ALGORITHM_TAGS } return inference_metrics def send_to_newrelic(inference_metrics, insights_payload): newrelic_metrics = [] for key, value in inference_metrics.items(): name = \"algorithmia.\" + key epoch_time = convert_str_timestamp_to_epoch(insights_payload[\"time\"]) tags = { \"algorithm_name\": insights_payload[\"algorithm_name\"], \"algorithm_version\": insights_payload[\"algorithm_version\"], \"algorithm_owner\": insights_payload[\"algorithm_owner\"], \"request_id\": insights_payload[\"request_id\"], \"session_id\": insights_payload[\"session_id\"], } newrelic_metrics.append(GaugeMetric( name=name, value=value, tags=tags, end_time_ms=epoch_time )) response = metric_client.send_batch(newrelic_metrics) response.raise_for_status() def apply(input): insights_payload = input inference_metrics = get_operational_metrics(insights_payload) send_to_newrelic(inference_metrics, insights_payload) return None Copy Include these dependencies: algorithmia>=1.0.0,<2.0 newrelic_telemetry_sdk==0.4.2 Copy Once your algorithm build finishes, you can test it with this sample payload to make sure it runs successfully. Your output should look something like this. { \"risk_score\": 0.2, \"duration_milliseconds\": 8, \"algorithm_version\": \"1.0.6\", \"session_id\": \"rses-f28bb94a-5556-4aeb-a6d2-89493626bf4f\", \"time\": \"2021-02-20T00:21:54.867231\", \"algorithm_name\": \"credit_card_approval\", \"request_id\": \"req-9f5345b4-a1cd-431c-a43a-bd2a06f4a6f4\", \"algorithm_owner\": \"asli\" } Copy Configure with your API key: Add your New Relic API key to the Datarobot secret store. Set up Datarobot Event Flows with New Relic: See Datarobot's documentation on setting up your connector algorithm to send event-based machine learning flows to New Relic. Monitor your machine learning models [#monitor] Follow these steps to get the most of observing your machine-learning data in New Relic. Get your API key: From one.newrelic.com the account menu, click API keys and then create a user key for your account with a meaningful name. Make note of this name for later. For more on API keys, see our docs. Create a dashboard: From one.newrelic.com go to Dashboards, then click the Import dashboards button. Copy and paste the JSON code into the Paste your JSON field code. Update the YOUR_ACCOUNT_ID values with your account ID. { \"name\": \"Datarobot Dashboard for Default Metrics\", \"description\": null, \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"Datarobot Dashboard for Default Metrics\", \"description\": null, \"widgets\": [ { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Runtime Duration by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT average(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Throughput by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT count(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } Copy Set up alerts notifications: Once you've created some dashboards, you can get alerted on your data. To create a NRQL alerts condition from a chart, click the chart menu , then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Get notified: Once you've created an alerts condition, you can choose how you want to be notified. See our docs on how to set up notification channels. Correlate your incidents: In addition to notifications, you can use Incident Intelligence to correlate your incidents. See our docs on how to correlate incidents using decisions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 105.36488,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Datarobot <em>MLOps</em> <em>integration</em>",
        "sections": "Datarobot <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "6186e10a28ccbcd8d2cdfd59"
    },
    {
      "sections": [
        "Comet MLOps integration",
        "What is MLOps?",
        "The Comet integration",
        "Integrate Comet with New Relic"
      ],
      "title": "Comet MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "Comet integrations"
      ],
      "external_id": "5bd55e6c5d49d480acb50bd0c1830a08aa84ceaf",
      "image": "https://docs.newrelic.com/static/f75787c4d9fd008aad94f01908ee9995/c1b63/comet03.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/comet-mlops-integration/",
      "published_at": "2021-12-04T20:58:08Z",
      "updated_at": "2021-11-06T20:09:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. The Comet integration Comet is an MLOps platform that extends full stack observability to machine learning models, and allows you to establish production performance baselines based on model performance. The Comet integration allows you to integrate machine learning metrics with New Relic, so you can continuosly monitor your data across the full machine learning lifecycle. This helps ensure optimal model performance, and helps you achieve better business outcomes. Integrate Comet with New Relic Use New Relic's Comet integration to get data and insights that help you build better, more accurate machine-learning models, while also improving productivity, collaboration, and visibility across your team. To setup the integration, follow these steps: Log into your New Relic account: Log into one.newrelic.com and click on Explorer. At the upper hand corner, on the main navigation menu, click +Add more data. Click on Comet: Type Comet in the search bar, or scroll down to the MLOps Integration section and click on the Comet icon. Select the account ID you want Comet to integrate with. Select or create an Insight API Key: You need an Insight API Key to integrate with Comet. Create or select an existing API key under the Real time training metric section. Contact Comet: To set up the integration and view the Model Production Monitoring dashboard in Comet, you need to contact Comet. The Comet team will walk you through each step of the integration process and get you all set up. View your insights: Now that you’ve set up your integration, you can start tracking the performance of your machine learning models in a dedicated New Relic One dashboard, which is automatically generated by Comet’s team.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 105.36488,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Comet <em>MLOps</em> <em>integration</em>",
        "sections": "Comet <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "6186e10a28ccbcdc52cdf889"
    }
  ],
  "/docs/mlops/integrations/truera-mlops-integration": [
    {
      "sections": [
        "Superwise MLOps integration",
        "What is MLOps?",
        "What is Superwise?",
        "Migrate Data from Superwise with New Relic",
        "View and explore your Superwise models in New Relic dashboards"
      ],
      "title": "Superwise MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "Superwise integrations"
      ],
      "external_id": "eea57de1a53ec53766ba067ed720283105bc741e",
      "image": "https://docs.newrelic.com/static/79201eea2484599d4f3ededa8819d458/c1b63/superwise2.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/superwise-mlops-integration/",
      "published_at": "2021-12-04T15:29:10Z",
      "updated_at": "2021-11-24T04:47:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. What is Superwise? Superwise now offers an integration with New Relic to help users add the state of their AI as monitored by Superwise to their centralized operational view on New Relic. Migrate Data from Superwise with New Relic Superwise’s KPI and incidents integration streamlines results of our out-of-the-box model KPIs, including drift, activity, incidents, and any custom KPI you configure, directly into New Relic One. You’ll get an immediate overview of which models are misbehaving that can be tailored to any use case, logic, segmentation, threshold, and sensitivity. In order to receive data from Superwise into New Relic, you’ll need to do the following: Login into your New Relic account: Log into one.newrelic.com and click on Explorer. On the upper hand corner, on the main navigation menu, click on + Add more data. Click on Superwise: In the search bar, type Superwise or scroll down to the MLOps Integration section, then click on the Superwise icon. Select an account ID: Select the account ID you want Superwise to integrate with. Create two access tokens: Once you select an Account ID, under Prediction data + Generate Dashboard, click Create a key. This is your new telemetry API key. In addition, under Model quality metric, click Create a Key. This is your Incident Insights key. Keep the New Relic page open for future steps. Log into the Superwise portal: Log into the Superwise portal and go to Notification channel settings. Select New Relic and create a channel name. Copy and paste the token in Superwise: Go back to the New Relic integration dashboard and copy the two tokens you created by clicking on the copy icon next to the API key and Insight key. On Superwise’s portal, on the New Relic channel, paste the API key under Incident Intelligence API, and the Insight key under Telemetry Key. Finish by clicking Save. Verify the Token: Click on the Test button in the Superwise channel portal, to verify both tokens are working properly. A green or red status box should appear to indicate the verification. View and explore your Superwise models in New Relic dashboards Once a user configures the New Relic integration in Superwise, standard model metrics are sent to New Relic and users get model observability dashboards within New Relic. Users can also configure any specific model metric and incident policy and send them to New Relic for model observability tailored to their business context. Go to the integration dashboard: Once you’ve tested your tokens and confirmed the integration is set up correctly, return to the New Relic integration dashboard and click on See your data. This will redirect you to an automatically generated dashboard powered by Superwise. Analyze Superwise’s dashboard. Superwise’s dashboard contains 3 charts: The Model activity chart displays the number of active models, their activity, and the total number of predictions during a filtered timeframe. The Model input drift detection chart displays which models are drifting and may require retraining using a model drift leveler, scaled between 0 and 100. The Incident Insights chart displays how many models have open incidents, how incidents are being distributed, and deeper details on the model incident itself. Customize metrics and incidents in Superwise: Teams can easily customize any model metric and incident type in the Superwise platform. They can then search for these metrics in the New Relic Browser tab under Metrics. To do this, follow the instructions in step 4 in the Superwise docs. Set up alert notifications: Once you've created some dashboards, you can get alerted on your data. To create a NRQL alerts condition from a chart, click the chart widget, then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Get notified: Once you've created an alerts condition, you can choose how you want to be notified. See our docs on how to set up notification channels. Correlate your incidents: In addition to notifications, you can use Incident Intelligence to correlate your incidents. See our docs on how to correlate incidents using decisions. You’ve now successfully integrated New Relic with Superwise. Newly created alerts will now be correlated with your New Relic alerts and you should be able to see data about newly reported predictions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.35211,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Superwise <em>MLOps</em> <em>integration</em>",
        "sections": "Superwise <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "617e42b364441fa664fbc5c7"
    },
    {
      "sections": [
        "Datarobot MLOps integration",
        "What is MLOps?",
        "The Datarobot integration",
        "Integrate Datarobot with New Relic",
        "Connect your Datarobot data to New Relic",
        "Monitor your machine learning models [#monitor]"
      ],
      "title": "Datarobot MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "Datarobot integrations"
      ],
      "external_id": "50f76f931cf5783cb47c3b8feee7b9cddb0185c4",
      "image": "https://docs.newrelic.com/static/e5770f365474a584b077b7565f273a79/c1b63/algorithmia-flow.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/datarobot-mlops-integration/",
      "published_at": "2021-12-04T15:29:11Z",
      "updated_at": "2021-11-06T20:09:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. The Datarobot integration Datarobot provides tools for deploying your machine-learning models into production. By integrating, Datarobot's integration with New Relic, you'll be able to instrument, analyze, troubleshoot, and optimize your machine-learning performance across your entire system. By rigorously observing your capabilities, you'll be able to react quickly to changes in the model's input or output and the relationship between the two. Send your model performance metrics from Datarobot Insights to New Relic and you'll have real-time monitoring for your algorithms. You'll explore your metrics data with user-friendly charts and learn the state of your algorithms at a glance for faster and more efficient troubleshooting. Integrate Datarobot with New Relic First, Datarobot uses a Kafka topic to stream Insights from your machine-learning algorithm's performance metrics. Then, the New Relic connector (another algorithm) transforms the Kafka topic into a metrics data payload for a specific New Relic account. Datarobot uses Kafka and Event Flows to send data to New Relic. With Datarobot’s Event Flows, when a new message is set to your Kafka topic, your configured New Relic connector algorithm gets called. The connector transforms your metrics and sends them to your New Relic account. Connect your Datarobot data to New Relic By integrating Incident Intelligence with your Datarobot machine-learning models, you can monitor your machine learning model performance. Start monitoring your Datarobot event flows with New Relic. Get your API key: From one.newrelic.com the account menu, click API keys and then create a user key for your account with a meaningful name. Make note of this name for later. For more on API keys, see our docs. Create a dashboard: From one.newrelic.com go to Dashboards, then click the Import dashboards button. Copy and paste the JSON code into the Paste your JSON field code. Update the YOUR_ACCOUNT_ID values with your account ID. { \"name\": \"Datarobot Dashboard for Default Metrics\", \"description\": null, \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"Datarobot Dashboard for Default Metrics\", \"description\": null, \"widgets\": [ { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Runtime Duration by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT average(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Throughput by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT count(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } Copy Configure Datarobot Insights for New Relic: Use Datarobot's docs for how to configure Datarobot for New Relic. Create the New Relic connector algorithm: Use Python 3.8 to create a connector algorithm. If you're new to writing code to generate algorithms, see Datarobot's getting started guide. import Datarobot import json from datetime import datetime from newrelic_telemetry_sdk import GaugeMetric, MetricClient client = Datarobot.client() metric_client = MetricClient(os.environ[\"newrelic_api_key\"]) def convert_str_timestamp_to_epoch(str_time): obj_time = datetime.strptime(str_time, \"%Y-%m-%dT%H:%M:%S.%f\") return int(obj_time.timestamp() * 1000) def get_operational_metrics(payload): ALGORITHM_TAGS = { \"algorithm_version\", \"request_id\", \"time\", \"algorithm_name\", \"session_id\", \"algorithm_owner\" } inference_metrics = { key: payload[key] for key in payload.keys() ^ ALGORITHM_TAGS } return inference_metrics def send_to_newrelic(inference_metrics, insights_payload): newrelic_metrics = [] for key, value in inference_metrics.items(): name = \"algorithmia.\" + key epoch_time = convert_str_timestamp_to_epoch(insights_payload[\"time\"]) tags = { \"algorithm_name\": insights_payload[\"algorithm_name\"], \"algorithm_version\": insights_payload[\"algorithm_version\"], \"algorithm_owner\": insights_payload[\"algorithm_owner\"], \"request_id\": insights_payload[\"request_id\"], \"session_id\": insights_payload[\"session_id\"], } newrelic_metrics.append(GaugeMetric( name=name, value=value, tags=tags, end_time_ms=epoch_time )) response = metric_client.send_batch(newrelic_metrics) response.raise_for_status() def apply(input): insights_payload = input inference_metrics = get_operational_metrics(insights_payload) send_to_newrelic(inference_metrics, insights_payload) return None Copy Include these dependencies: algorithmia>=1.0.0,<2.0 newrelic_telemetry_sdk==0.4.2 Copy Once your algorithm build finishes, you can test it with this sample payload to make sure it runs successfully. Your output should look something like this. { \"risk_score\": 0.2, \"duration_milliseconds\": 8, \"algorithm_version\": \"1.0.6\", \"session_id\": \"rses-f28bb94a-5556-4aeb-a6d2-89493626bf4f\", \"time\": \"2021-02-20T00:21:54.867231\", \"algorithm_name\": \"credit_card_approval\", \"request_id\": \"req-9f5345b4-a1cd-431c-a43a-bd2a06f4a6f4\", \"algorithm_owner\": \"asli\" } Copy Configure with your API key: Add your New Relic API key to the Datarobot secret store. Set up Datarobot Event Flows with New Relic: See Datarobot's documentation on setting up your connector algorithm to send event-based machine learning flows to New Relic. Monitor your machine learning models [#monitor] Follow these steps to get the most of observing your machine-learning data in New Relic. Get your API key: From one.newrelic.com the account menu, click API keys and then create a user key for your account with a meaningful name. Make note of this name for later. For more on API keys, see our docs. Create a dashboard: From one.newrelic.com go to Dashboards, then click the Import dashboards button. Copy and paste the JSON code into the Paste your JSON field code. Update the YOUR_ACCOUNT_ID values with your account ID. { \"name\": \"Datarobot Dashboard for Default Metrics\", \"description\": null, \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"Datarobot Dashboard for Default Metrics\", \"description\": null, \"widgets\": [ { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Runtime Duration by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT average(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Throughput by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT count(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } Copy Set up alerts notifications: Once you've created some dashboards, you can get alerted on your data. To create a NRQL alerts condition from a chart, click the chart menu , then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Get notified: Once you've created an alerts condition, you can choose how you want to be notified. See our docs on how to set up notification channels. Correlate your incidents: In addition to notifications, you can use Incident Intelligence to correlate your incidents. See our docs on how to correlate incidents using decisions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 105.36488,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Datarobot <em>MLOps</em> <em>integration</em>",
        "sections": "Datarobot <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "6186e10a28ccbcd8d2cdfd59"
    },
    {
      "sections": [
        "Comet MLOps integration",
        "What is MLOps?",
        "The Comet integration",
        "Integrate Comet with New Relic"
      ],
      "title": "Comet MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "Comet integrations"
      ],
      "external_id": "5bd55e6c5d49d480acb50bd0c1830a08aa84ceaf",
      "image": "https://docs.newrelic.com/static/f75787c4d9fd008aad94f01908ee9995/c1b63/comet03.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/comet-mlops-integration/",
      "published_at": "2021-12-04T20:58:08Z",
      "updated_at": "2021-11-06T20:09:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. The Comet integration Comet is an MLOps platform that extends full stack observability to machine learning models, and allows you to establish production performance baselines based on model performance. The Comet integration allows you to integrate machine learning metrics with New Relic, so you can continuosly monitor your data across the full machine learning lifecycle. This helps ensure optimal model performance, and helps you achieve better business outcomes. Integrate Comet with New Relic Use New Relic's Comet integration to get data and insights that help you build better, more accurate machine-learning models, while also improving productivity, collaboration, and visibility across your team. To setup the integration, follow these steps: Log into your New Relic account: Log into one.newrelic.com and click on Explorer. At the upper hand corner, on the main navigation menu, click +Add more data. Click on Comet: Type Comet in the search bar, or scroll down to the MLOps Integration section and click on the Comet icon. Select the account ID you want Comet to integrate with. Select or create an Insight API Key: You need an Insight API Key to integrate with Comet. Create or select an existing API key under the Real time training metric section. Contact Comet: To set up the integration and view the Model Production Monitoring dashboard in Comet, you need to contact Comet. The Comet team will walk you through each step of the integration process and get you all set up. View your insights: Now that you’ve set up your integration, you can start tracking the performance of your machine learning models in a dedicated New Relic One dashboard, which is automatically generated by Comet’s team.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 105.36488,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Comet <em>MLOps</em> <em>integration</em>",
        "sections": "Comet <em>MLOps</em> <em>integration</em>",
        "tags": "<em>MLOps</em> <em>integrations</em>",
        "body": "What is <em>MLOps</em>? <em>MLOps</em> stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there&#x27;s a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those"
      },
      "id": "6186e10a28ccbcdc52cdf889"
    }
  ],
  "/docs/mobile-apps/new-relic-mobile-apps/android-app/android-app-ui": [
    {
      "sections": [
        "Introduction to New Relic Android app",
        "Requirements",
        "Install New Relic's mobile app",
        "View New Relic data",
        "New Relic product details",
        "Synthetics data",
        "Alerts",
        "Mobile app monitoring",
        "Details on setting time range",
        "Data privacy"
      ],
      "title": "Introduction to New Relic Android app",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Android app"
      ],
      "external_id": "ff8415c00363a49eaa062f4b0b13c795b4717ea5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/android-app/introduction-new-relic-android-app/",
      "published_at": "2021-12-04T17:58:46Z",
      "updated_at": "2021-11-13T02:30:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The user interface for New Relic's Android app provides functionality similar to New Relic's standard user interface, with customized details for mobile users. Requirements Requirements include: Android 8.0 (Oreo) or higher Screen size of 7 inches or less Install New Relic's mobile app You can install the New Relic Android app from the Google Play Store or learn more from the New Relic website. Follow standard procedures to install any Android app, then sign in with your New Relic user name (account email) and password if applicable. Depending on your New Relic account, additional installation or user authentication steps may be required. View New Relic data To view details of your apps monitored by New Relic, select a product from the app's main menu. See below for details on how to use specific features of the app: New Relic product details The New Relic Android app includes data about these features: APM metrics, both real-time and historical data, including health maps. Select the transaction icon to see detailed transaction metrics, or an Overview chart to view summary charts of your top five transactions. Select the icon to filter by labels and categories. Browser monitoring metrics, including average page load time, Apdex, average throughput, and more. Infrastructure monitoring. Mobile monitoring, including crash reports, network errors, API calls, and active user count. Event notifications, including mobile alerts wherever you are, plus deployment notifications and notes. New Relic's Android app does not have the full feature set of the New Relic web interface. For more detailed analysis, sign in to your New Relic account with a web browser. Synthetics data You can use the Android app to view your synthetic monitoring data, including charts of your monitor's availability, load times, and load sizes. To view more detailed charts, select the caret icon. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you log in to your New Relic account from the Android app, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For Android alerts, notifications appear on your lock screen. To view them, tap the alert event. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile app monitoring If you have installed mobile monitoring, you can monitor its performance directly from your Android device. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. Details on setting time range When viewing an application or host, you can change the visible time frame with the time picker. To move back and forth across the timeline, scrub the New Relic charts. To change the duration of the visible time slice, select the clock icon. To specify an end time other than now, slide the toggle from Ending Now to Custom Date. To save your changes and refresh the chart data, select the clock icon again. Data privacy New Relic's mobile apps only record information needed to help authenticate and troubleshoot: User's email address associated with your New Relic account, including first and last name (for authentication purposes only) IP address Device ID For more information, see our Mobile data privacy and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 233.86176,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>Android</em> <em>app</em>",
        "sections": "Install <em>New</em> <em>Relic&#x27;s</em> <em>mobile</em> <em>app</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": "The user interface for <em>New</em> <em>Relic</em>&#x27;s <em>Android</em> <em>app</em> provides functionality similar to <em>New</em> <em>Relic</em>&#x27;s standard user interface, with customized details for <em>mobile</em> users. Requirements Requirements include: <em>Android</em> 8.0 (Oreo) or higher Screen size of 7 inches or less Install <em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>app</em> You can"
      },
      "id": "604415e0196a67ff23960f46"
    },
    {
      "sections": [
        "Introduction to iOS mobile app",
        "Features",
        "Time range",
        "Synthetic monitoring",
        "Alerts",
        "Mobile monitoring",
        "Data privacy"
      ],
      "title": "Introduction to iOS mobile app",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "iOS app"
      ],
      "external_id": "371077582a50dfd2a1e7c57cfbbf9eeaf8013e1c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/ios-app/introduction-ios-mobile-app/",
      "published_at": "2021-12-06T01:42:46Z",
      "updated_at": "2021-11-23T01:49:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The user interface for New Relic's iPhone and iPad app provides functionality similar to New Relic's standard user interface, with customized details for mobile users. Features New Relic's iOS app includes these New Relic products and features: New Relic's iOS app for iPhone and iPad includes these New Relic products and features: APM (iPhone and iPad). Includes real-time and historical data. Select the icon to see transaction details. Select Overview Charts to view summary charts of your top five transactions. Browser monitoring (iPhone and iPad). Provide overview dashboard, including average page load time, browser Apdex, average throughput, and more. Infrastructure monitoring (iPhone only). Alerts (iPhone and iPad). Get alert and deployment notifications. Synthetic monitoring (iPhone only). Mobile monitoring (iPhone and iPad). Includes crash reports, network errors, API calls, and active user count. New Relic's iOS app does not have all the features of the New Relic web application. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the clock icon in the top right of the page. This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth across the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). For iPads: to specify an end time other than now, slide the toggle from Ending Now to Custom Date. Synthetic monitoring You can use the iOS app to view your synthetic monitoring data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you connect the iOS app to your New Relic account, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For iOS alerts, notifications appear on your lock screen and can be viewed by swiping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile monitoring If you have a mobile application and have installed mobile monitoring, you can monitor its performance directly from your iPhone or iPad. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. Data privacy New Relic's mobile apps only record information needed to help authenticate and troubleshoot: User's email address associated with your New Relic account, including first and last name (for authentication purposes only) IP address Device ID For more information, see our Mobile data privacy and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.26428,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to iOS <em>mobile</em> <em>app</em>",
        "sections": "Introduction to iOS <em>mobile</em> <em>app</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": "The user interface for <em>New</em> <em>Relic</em>&#x27;s iPhone and iPad <em>app</em> provides functionality similar to <em>New</em> <em>Relic</em>&#x27;s standard user interface, with customized details for <em>mobile</em> users. Features <em>New</em> <em>Relic</em>&#x27;s iOS <em>app</em> includes these <em>New</em> <em>Relic</em> products and features: <em>New</em> <em>Relic</em>&#x27;s iOS <em>app</em> for iPhone and iPad includes"
      },
      "id": "6044161628ccbc96b62c6092"
    },
    {
      "sections": [
        "User settings and authentication",
        "User authentication",
        "User settings",
        "Sign in with additional username",
        "Switch between accounts",
        "Remove or re-add a user name"
      ],
      "title": "User settings and authentication",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Authentication and alerts"
      ],
      "external_id": "0b40ac4c2e769279d25d0ebb2ea77cebda8d8ea7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/authentication-alerts/user-settings-authentication/",
      "published_at": "2021-12-04T17:59:31Z",
      "updated_at": "2021-11-25T04:07:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This explains how to authenticate your New Relic mobile app account, and how to add users to or remove them from your mobile device. User authentication Depending on your New Relic account, additional installation or authentication steps may be required when you install the New Relic mobile app. New Relic account Additional requirements New users If you do not already have a New Relic account: From your desktop web browser, create a New Relic account. Install your application with the appropriate New Relic agent. As part of new account setup, you will receive an email with a password reset link. The password reset link expires after 20 minutes for mobile apps. Existing New Relic users No additional requirements; your applications, hosts, and key transactions automatically appear after you sign in. Users with New Relic partner accounts Depending on the partner, you may need to complete a different authentication process. Azure Store users: Due to the deep integration between Azure Storefront and New Relic, Azure Storefront users cannot access their accounts on the New Relic Android or iOS apps. Users with SAML-SSO enabled accounts When you sign in to the New Relic mobile app, your session automatically redirects to your web browser. From there you can sign in to your New Relic SAML-SSO account. If you see any errors when using SAML-SSO accounts on your mobile device, verify that you are able to sign in to one.newrelic.com with a desktop web browser. If no, contact your administrator. If yes, get support at support.newrelic.com. User settings After you sign in, all New Relic accounts and applications associated with the user appear automatically. Sign in with additional username Follow the procedure for your mobile device. Mobile device To sign in to the app with an additional user name: Android To switch users: Log out from the Android device: Main menu > (selected username) > Logout > Confirm. Log in with a new account. iPhone From the app menu, select your account name, then select the Users menu. From the Users menu, select the plus icon. Sign in with the additional username. iPad To access the Users menu: Select the user icon or slide right. From the Users menu, select the plus icon. Sign in with the additional username. Switch between accounts To switch between accounts associated with your username: From the Users menu, select the user name. Select the account name. Remove or re-add a user name To remove a specific username from this device: From the Users menu, select Logout. To remove a user from this device, select the user's red minus icon. Select the user's Log out icon. To add a user again, sign in with that username again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 179.45195,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": " a different authentication process. Azure Store users: Due to the deep integration between Azure Storefront and <em>New</em> <em>Relic</em>, Azure Storefront users cannot access their accounts on the <em>New</em> <em>Relic</em> <em>Android</em> or iOS <em>apps</em>. Users with SAML-SSO enabled accounts When you sign in to the <em>New</em> <em>Relic</em> <em>mobile</em> <em>app</em>, your"
      },
      "id": "604415a728ccbc8fb52c6068"
    }
  ],
  "/docs/mobile-apps/new-relic-mobile-apps/android-app/introduction-new-relic-android-app": [
    {
      "sections": [
        "Android app UI",
        "Pages",
        "Time range",
        "New Relic Synthetics",
        "Alerts",
        "Mobile apps"
      ],
      "title": "Android app UI",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Android app"
      ],
      "external_id": "8918a5a2454491a91421c55e26501a0e3f64cd3a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/android-app/android-app-ui/",
      "published_at": "2021-12-06T01:42:46Z",
      "updated_at": "2021-10-30T14:09:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The UI for the New Relic Android app provides functionality similar to the standard user interface, with customized details for mobile users. Pages The New Relic Android app includes: APM metrics, both real-time and historical data, including health maps. And, select the transaction icon for detailed transaction metrics, or an Overview Charts to view summary charts of your top five transactions. New Relic Infrastructure utilization. Mobile monitoring, including crash reports, network errors, API calls, and active user count. Select the filter icon to filter by labels and categories. Event notifications, including mobile alerts wherever you are, plus deployment notifications and notes. Note: New Relic's Android app does not have the full feature set of the New Relic web interface. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the time picker icon in the top right of the page (the 7D in the screenshot). This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth in the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). New Relic Synthetics You can use the Android app to view your New Relic Synthetics data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you log in to your New Relic account from the Android app, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For Android alerts, notifications appear on your lock screen and can be viewed by tapping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile apps If you have a mobile application and have installed mobile monitoring, you can monitor its performance directly from your Android device. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 218.63065,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>app</em> UI",
        "sections": "<em>Mobile</em> <em>apps</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": "The UI for the <em>New</em> <em>Relic</em> <em>Android</em> <em>app</em> provides functionality similar to the standard user interface, with customized details for <em>mobile</em> users. Pages The <em>New</em> <em>Relic</em> <em>Android</em> <em>app</em> includes: APM metrics, both real-time and historical data, including health maps. And, select the transaction icon"
      },
      "id": "6044181d28ccbc9a522c60a5"
    },
    {
      "sections": [
        "Introduction to iOS mobile app",
        "Features",
        "Time range",
        "Synthetic monitoring",
        "Alerts",
        "Mobile monitoring",
        "Data privacy"
      ],
      "title": "Introduction to iOS mobile app",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "iOS app"
      ],
      "external_id": "371077582a50dfd2a1e7c57cfbbf9eeaf8013e1c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/ios-app/introduction-ios-mobile-app/",
      "published_at": "2021-12-06T01:42:46Z",
      "updated_at": "2021-11-23T01:49:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The user interface for New Relic's iPhone and iPad app provides functionality similar to New Relic's standard user interface, with customized details for mobile users. Features New Relic's iOS app includes these New Relic products and features: New Relic's iOS app for iPhone and iPad includes these New Relic products and features: APM (iPhone and iPad). Includes real-time and historical data. Select the icon to see transaction details. Select Overview Charts to view summary charts of your top five transactions. Browser monitoring (iPhone and iPad). Provide overview dashboard, including average page load time, browser Apdex, average throughput, and more. Infrastructure monitoring (iPhone only). Alerts (iPhone and iPad). Get alert and deployment notifications. Synthetic monitoring (iPhone only). Mobile monitoring (iPhone and iPad). Includes crash reports, network errors, API calls, and active user count. New Relic's iOS app does not have all the features of the New Relic web application. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the clock icon in the top right of the page. This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth across the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). For iPads: to specify an end time other than now, slide the toggle from Ending Now to Custom Date. Synthetic monitoring You can use the iOS app to view your synthetic monitoring data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you connect the iOS app to your New Relic account, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For iOS alerts, notifications appear on your lock screen and can be viewed by swiping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile monitoring If you have a mobile application and have installed mobile monitoring, you can monitor its performance directly from your iPhone or iPad. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. Data privacy New Relic's mobile apps only record information needed to help authenticate and troubleshoot: User's email address associated with your New Relic account, including first and last name (for authentication purposes only) IP address Device ID For more information, see our Mobile data privacy and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.26428,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to iOS <em>mobile</em> <em>app</em>",
        "sections": "Introduction to iOS <em>mobile</em> <em>app</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": "The user interface for <em>New</em> <em>Relic</em>&#x27;s iPhone and iPad <em>app</em> provides functionality similar to <em>New</em> <em>Relic</em>&#x27;s standard user interface, with customized details for <em>mobile</em> users. Features <em>New</em> <em>Relic</em>&#x27;s iOS <em>app</em> includes these <em>New</em> <em>Relic</em> products and features: <em>New</em> <em>Relic</em>&#x27;s iOS <em>app</em> for iPhone and iPad includes"
      },
      "id": "6044161628ccbc96b62c6092"
    },
    {
      "sections": [
        "User settings and authentication",
        "User authentication",
        "User settings",
        "Sign in with additional username",
        "Switch between accounts",
        "Remove or re-add a user name"
      ],
      "title": "User settings and authentication",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Authentication and alerts"
      ],
      "external_id": "0b40ac4c2e769279d25d0ebb2ea77cebda8d8ea7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/authentication-alerts/user-settings-authentication/",
      "published_at": "2021-12-04T17:59:31Z",
      "updated_at": "2021-11-25T04:07:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This explains how to authenticate your New Relic mobile app account, and how to add users to or remove them from your mobile device. User authentication Depending on your New Relic account, additional installation or authentication steps may be required when you install the New Relic mobile app. New Relic account Additional requirements New users If you do not already have a New Relic account: From your desktop web browser, create a New Relic account. Install your application with the appropriate New Relic agent. As part of new account setup, you will receive an email with a password reset link. The password reset link expires after 20 minutes for mobile apps. Existing New Relic users No additional requirements; your applications, hosts, and key transactions automatically appear after you sign in. Users with New Relic partner accounts Depending on the partner, you may need to complete a different authentication process. Azure Store users: Due to the deep integration between Azure Storefront and New Relic, Azure Storefront users cannot access their accounts on the New Relic Android or iOS apps. Users with SAML-SSO enabled accounts When you sign in to the New Relic mobile app, your session automatically redirects to your web browser. From there you can sign in to your New Relic SAML-SSO account. If you see any errors when using SAML-SSO accounts on your mobile device, verify that you are able to sign in to one.newrelic.com with a desktop web browser. If no, contact your administrator. If yes, get support at support.newrelic.com. User settings After you sign in, all New Relic accounts and applications associated with the user appear automatically. Sign in with additional username Follow the procedure for your mobile device. Mobile device To sign in to the app with an additional user name: Android To switch users: Log out from the Android device: Main menu > (selected username) > Logout > Confirm. Log in with a new account. iPhone From the app menu, select your account name, then select the Users menu. From the Users menu, select the plus icon. Sign in with the additional username. iPad To access the Users menu: Select the user icon or slide right. From the Users menu, select the plus icon. Sign in with the additional username. Switch between accounts To switch between accounts associated with your username: From the Users menu, select the user name. Select the account name. Remove or re-add a user name To remove a specific username from this device: From the Users menu, select Logout. To remove a user from this device, select the user's red minus icon. Select the user's Log out icon. To add a user again, sign in with that username again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 179.45195,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": " a different authentication process. Azure Store users: Due to the deep integration between Azure Storefront and <em>New</em> <em>Relic</em>, Azure Storefront users cannot access their accounts on the <em>New</em> <em>Relic</em> <em>Android</em> or iOS <em>apps</em>. Users with SAML-SSO enabled accounts When you sign in to the <em>New</em> <em>Relic</em> <em>mobile</em> <em>app</em>, your"
      },
      "id": "604415a728ccbc8fb52c6068"
    }
  ],
  "/docs/mobile-apps/new-relic-mobile-apps/authentication-alerts/alerting-new-relic-mobile-apps": [
    {
      "sections": [
        "User settings and authentication",
        "User authentication",
        "User settings",
        "Sign in with additional username",
        "Switch between accounts",
        "Remove or re-add a user name"
      ],
      "title": "User settings and authentication",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Authentication and alerts"
      ],
      "external_id": "0b40ac4c2e769279d25d0ebb2ea77cebda8d8ea7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/authentication-alerts/user-settings-authentication/",
      "published_at": "2021-12-04T17:59:31Z",
      "updated_at": "2021-11-25T04:07:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This explains how to authenticate your New Relic mobile app account, and how to add users to or remove them from your mobile device. User authentication Depending on your New Relic account, additional installation or authentication steps may be required when you install the New Relic mobile app. New Relic account Additional requirements New users If you do not already have a New Relic account: From your desktop web browser, create a New Relic account. Install your application with the appropriate New Relic agent. As part of new account setup, you will receive an email with a password reset link. The password reset link expires after 20 minutes for mobile apps. Existing New Relic users No additional requirements; your applications, hosts, and key transactions automatically appear after you sign in. Users with New Relic partner accounts Depending on the partner, you may need to complete a different authentication process. Azure Store users: Due to the deep integration between Azure Storefront and New Relic, Azure Storefront users cannot access their accounts on the New Relic Android or iOS apps. Users with SAML-SSO enabled accounts When you sign in to the New Relic mobile app, your session automatically redirects to your web browser. From there you can sign in to your New Relic SAML-SSO account. If you see any errors when using SAML-SSO accounts on your mobile device, verify that you are able to sign in to one.newrelic.com with a desktop web browser. If no, contact your administrator. If yes, get support at support.newrelic.com. User settings After you sign in, all New Relic accounts and applications associated with the user appear automatically. Sign in with additional username Follow the procedure for your mobile device. Mobile device To sign in to the app with an additional user name: Android To switch users: Log out from the Android device: Main menu > (selected username) > Logout > Confirm. Log in with a new account. iPhone From the app menu, select your account name, then select the Users menu. From the Users menu, select the plus icon. Sign in with the additional username. iPad To access the Users menu: Select the user icon or slide right. From the Users menu, select the plus icon. Sign in with the additional username. Switch between accounts To switch between accounts associated with your username: From the Users menu, select the user name. Select the account name. Remove or re-add a user name To remove a specific username from this device: From the Users menu, select Logout. To remove a user from this device, select the user's red minus icon. Select the user's Log out icon. To add a user again, sign in with that username again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 291.32248,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User settings <em>and</em> <em>authentication</em>",
        "sections": "User settings <em>and</em> <em>authentication</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": " a different <em>authentication</em> process. Azure Store users: Due to the deep integration between Azure Storefront and <em>New</em> <em>Relic</em>, Azure Storefront users cannot access their accounts on the <em>New</em> <em>Relic</em> Android or iOS <em>apps</em>. Users with SAML-SSO enabled accounts When you sign in to the <em>New</em> <em>Relic</em> <em>mobile</em> <em>app</em>, your"
      },
      "id": "604415a728ccbc8fb52c6068"
    },
    {
      "sections": [
        "Troubleshoot SSO accounts using mobile devices",
        "No user name or password",
        "Errors after signing in",
        "Reauthentication problems"
      ],
      "title": "Troubleshoot SSO accounts using mobile devices",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Authentication and alerts"
      ],
      "external_id": "9ebb373182ce5fea83ba5a6baa03b2c7bccf0174",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/authentication-alerts/troubleshoot-sso-accounts-using-mobile-devices/",
      "published_at": "2021-12-04T17:59:22Z",
      "updated_at": "2021-05-16T06:23:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Typically when you sign in to the New Relic mobile app, your session redirects automatically to your web browser. From there you can sign in to your New Relic account. Here are troubleshooting tips if you have problems using the New Relic mobile app with your SAML-SSO enabled account. No user name or password You may not have a user name or password for New Relic because some SAML providers will overwrite your password, or because your administrator has not sent you this information. In these situations: From the mobile app's Log in, select the I don't have a password link. Use your mobile device to open your email account. From your email account, retrieve the New Relic authentication email within 20 minutes. Select the Authenticate button or the link below it in the email. Errors after signing in If you see any errors after successfully signing in to your SSO provider with your mobile device, verify that you are able to sign in to one.newrelic.com with a desktop web browser. If no, contact your administrator. If yes, get support at support.newrelic.com. Reauthentication problems If you are using reauthentication on a SAML-SSO account, you must log in to your default account. (All other accounts will be grayed out.) If you attempt to switch to a grayed-out account, an error message will appear, explaining this is currently not supported.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 201.59558,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshoot SSO accounts using <em>mobile</em> devices",
        "sections": "Troubleshoot SSO accounts using <em>mobile</em> devices",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": "Typically when you sign in to the <em>New</em> <em>Relic</em> <em>mobile</em> <em>app</em>, your session redirects automatically to your web browser. From there you can sign in to your <em>New</em> <em>Relic</em> account. Here are troubleshooting tips if you have problems using the <em>New</em> <em>Relic</em> <em>mobile</em> <em>app</em> with your SAML-SSO enabled account. No user name"
      },
      "id": "604415e0196a67fc3f960f42"
    },
    {
      "sections": [
        "Mobile app authentication for New Relic partners",
        "Important",
        "Confirm your email address",
        "Troubleshoot email problems"
      ],
      "title": "Mobile app authentication for New Relic partners",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Authentication and alerts"
      ],
      "external_id": "de6bdd35891dbbfea0ae914251a9d5c4487594a9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-apps/mobile-app-features/authentication-partner-saml-sso-accounts/",
      "published_at": "2021-12-04T16:40:04Z",
      "updated_at": "2021-03-13T03:57:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important This resource is for New Relic partners. For authentication of users in regular New Relic accounts, see Authentication. Partner account users typically use SAML-SSO to sign in through your New Relic partner site. You may not have separate passwords or authentication information for your New Relic account. If you use an email address associated with a New Relic partner account when you first sign in to the New Relic mobile app, New Relic will send you a confirmation email for authentication. Android app users will also see a notification message. Important The authentication email expires 20 minutes after it is sent. Confirm your email address To authenticate using a SAML-SSO account provided through a New Relic partner: From the New Relic mobile app, type your email address associated with the partner account. Select I don't have a password. Retrieve the authentication email from your mobile device within 20 minutes. Select the Authenticate button (Android users) or email link (Android or iOS users) in the email to log in to New Relic. You will be redirected to the New Relic mobile app and logged in to your partner account. Troubleshoot email problems Here are some troubleshooting tips: If you cannot find the authentication message from New Relic in your mobile device's email in-box, check your Spam folder. If you miss the 20-minute deadline, sign in to the New Relic mobile app again, then select the link to resend the authentication email.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 199.32742,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Mobile</em> <em>app</em> <em>authentication</em> for <em>New</em> <em>Relic</em> partners",
        "sections": "<em>Mobile</em> <em>app</em> <em>authentication</em> for <em>New</em> <em>Relic</em> partners",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": " <em>New</em> <em>Relic</em> account. If you use an email address associated with a <em>New</em> <em>Relic</em> partner account when you first sign in to the <em>New</em> <em>Relic</em> <em>mobile</em> <em>app</em>, <em>New</em> <em>Relic</em> will send you a confirmation email for <em>authentication</em>. Android <em>app</em> users will also see a notification message. Important The <em>authentication</em> email"
      },
      "id": "604418de28ccbc28932c6071"
    }
  ],
  "/docs/mobile-apps/new-relic-mobile-apps/authentication-alerts/troubleshoot-sso-accounts-using-mobile-devices": [
    {
      "sections": [
        "User settings and authentication",
        "User authentication",
        "User settings",
        "Sign in with additional username",
        "Switch between accounts",
        "Remove or re-add a user name"
      ],
      "title": "User settings and authentication",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Authentication and alerts"
      ],
      "external_id": "0b40ac4c2e769279d25d0ebb2ea77cebda8d8ea7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/authentication-alerts/user-settings-authentication/",
      "published_at": "2021-12-04T17:59:31Z",
      "updated_at": "2021-11-25T04:07:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This explains how to authenticate your New Relic mobile app account, and how to add users to or remove them from your mobile device. User authentication Depending on your New Relic account, additional installation or authentication steps may be required when you install the New Relic mobile app. New Relic account Additional requirements New users If you do not already have a New Relic account: From your desktop web browser, create a New Relic account. Install your application with the appropriate New Relic agent. As part of new account setup, you will receive an email with a password reset link. The password reset link expires after 20 minutes for mobile apps. Existing New Relic users No additional requirements; your applications, hosts, and key transactions automatically appear after you sign in. Users with New Relic partner accounts Depending on the partner, you may need to complete a different authentication process. Azure Store users: Due to the deep integration between Azure Storefront and New Relic, Azure Storefront users cannot access their accounts on the New Relic Android or iOS apps. Users with SAML-SSO enabled accounts When you sign in to the New Relic mobile app, your session automatically redirects to your web browser. From there you can sign in to your New Relic SAML-SSO account. If you see any errors when using SAML-SSO accounts on your mobile device, verify that you are able to sign in to one.newrelic.com with a desktop web browser. If no, contact your administrator. If yes, get support at support.newrelic.com. User settings After you sign in, all New Relic accounts and applications associated with the user appear automatically. Sign in with additional username Follow the procedure for your mobile device. Mobile device To sign in to the app with an additional user name: Android To switch users: Log out from the Android device: Main menu > (selected username) > Logout > Confirm. Log in with a new account. iPhone From the app menu, select your account name, then select the Users menu. From the Users menu, select the plus icon. Sign in with the additional username. iPad To access the Users menu: Select the user icon or slide right. From the Users menu, select the plus icon. Sign in with the additional username. Switch between accounts To switch between accounts associated with your username: From the Users menu, select the user name. Select the account name. Remove or re-add a user name To remove a specific username from this device: From the Users menu, select Logout. To remove a user from this device, select the user's red minus icon. Select the user's Log out icon. To add a user again, sign in with that username again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 291.32248,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User settings <em>and</em> <em>authentication</em>",
        "sections": "User settings <em>and</em> <em>authentication</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": " a different <em>authentication</em> process. Azure Store users: Due to the deep integration between Azure Storefront and <em>New</em> <em>Relic</em>, Azure Storefront users cannot access their accounts on the <em>New</em> <em>Relic</em> Android or iOS <em>apps</em>. Users with SAML-SSO enabled accounts When you sign in to the <em>New</em> <em>Relic</em> <em>mobile</em> <em>app</em>, your"
      },
      "id": "604415a728ccbc8fb52c6068"
    },
    {
      "sections": [
        "Alerting with New Relic mobile apps",
        "Requirements",
        "Turn notifications on or off",
        "View alert incident details",
        "Troubleshoot alert settings",
        "Check notification settings for your mobile device.",
        "Delete the Android or iOS device from your New Relic account.",
        "Uninstall the New Relic mobile app.",
        "Reinstall the New Relic mobile app."
      ],
      "title": "Alerting with New Relic mobile apps",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Authentication and alerts"
      ],
      "external_id": "d55850dc642cc8ade20310e1d4654db61af1e809",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/authentication-alerts/alerting-new-relic-mobile-apps/",
      "published_at": "2021-12-04T17:58:58Z",
      "updated_at": "2021-07-09T12:24:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Account administrators can set up configuration to receive push notifications on Android and iOS devices from New Relic Alerts. You can receive alerts from any policy by attaching a user channel to the policy. Requirements This feature is available only to users on the original user model, not to users on the New Relic One user model. As a workaround, you can use the email notification channel. Turn notifications on or off When you log in to your New Relic account from an Android or iOS app, your device is automatically associated with your user channel. Be sure to add the associated user channel to the alert policy. View alert incident details The notification automatically appears on your device's lock screen. To start the New Relic app: Android devices: Tap the notification from the notification drawer. OR iOS devices: Swipe the screen. From the New Relic app's Alerts menu, select any alert to view error details for the associated application. Optional: Select Acknowledge. Optional: To view additional details, select Overview, Violations, or Event log. The main menu's Alerts list shows alerts in the following order, sorted by time: Active incidents Resolved incidents from today Resolved incidents and events from the past week, organized by day Troubleshoot alert settings If alerts are not working on your mobile device: Verify that you meet the requirements. Verify that alerts are enabled. Check your mobile device's notification settings, to ensure New Relic is permitted to send alerts. If the notification settings for your mobile device are correct, but you still do not receive notifications, delete the device from your account, then uninstall and reinstall the New Relic application. Check notification settings for your mobile device. Follow the procedure for your mobile device. Device To check notification settings: Android From your Android device's Settings, select Sound and notification. Check the settings for sound volume. Optional: Enable Also vibrate for calls. Check the settings for Interruptions. Check the settings for Notification. Check the settings for App notifications: Select the New Relic app, then check the settings for Block and Priority. iOS Ensure Do Not Disturb is off: From the iOS Settings app, select Do Not Disturb, and check that the Manual switch is off. Ensure the New Relic app is allowed to send notifications: From the iOS Settings app, select Notifications, and locate the New Relic app from the app list. Ensure that the Allow Notifications switch is on. Ensure that the alert style is set to Banners or Alerts. Optional: To enable audio alerts, set Sounds to on. Delete the Android or iOS device from your New Relic account. To delete the mobile device from your New Relic account, use the public graphql api api.newrelic.com/graphiql in a web browser: Query current devices by selecting actor -> mobilePushNotification -> devices and selecting appVersion, deviceId, and deviceName. Run this query to get the list of devices. Mutate to remove a device by selecting mutation -> mobilePushNotificationRemoveDevice, and passing in the deviceId from the list above. Or you can remove the device from the in-app Settings option from the menu -> Settings Look under Push notification devices, and remove from there. On iOS, slide from right to left to Delete a device, on Android, tap Delete Continue with the steps to reinstall the New Relic app from your device. Uninstall the New Relic mobile app. Follow the procedure to uninstall the New Relic app from your device, then reinstall it. Device To uninstall the New Relic app: Android From your Android device's Settings, select Apps, then select the New Relic app. Select Uninstall. Continue with the steps to reinstall the New Relic app. iOS From your iOS home screen, tap and hold the New Relic icon until it shakes. To delete the app, select the X icon. Continue with the steps to reinstall the New Relic app. Reinstall the New Relic mobile app. To reinstall the New Relic mobile app: From your Android device, select Google Play Store. OR From your iOS device's home screen, select App Store. Search for New Relic. Download the app. When the download finishes, sign in to your New Relic mobile app with your New Relic account.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 204.93674,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerting</em> with <em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "sections": "<em>Alerting</em> with <em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": " channel to the <em>alert</em> policy. View <em>alert</em> incident details The notification automatically appears on your device&#x27;s lock screen. To start the <em>New</em> <em>Relic</em> <em>app</em>: Android devices: Tap the notification from the notification drawer. OR iOS devices: Swipe the screen. From the <em>New</em> <em>Relic</em> <em>app</em>&#x27;s <em>Alerts</em> menu, select"
      },
      "id": "603e9efd64441f19a14e88ab"
    },
    {
      "sections": [
        "Mobile app authentication for New Relic partners",
        "Important",
        "Confirm your email address",
        "Troubleshoot email problems"
      ],
      "title": "Mobile app authentication for New Relic partners",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Authentication and alerts"
      ],
      "external_id": "de6bdd35891dbbfea0ae914251a9d5c4487594a9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-apps/mobile-app-features/authentication-partner-saml-sso-accounts/",
      "published_at": "2021-12-04T16:40:04Z",
      "updated_at": "2021-03-13T03:57:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important This resource is for New Relic partners. For authentication of users in regular New Relic accounts, see Authentication. Partner account users typically use SAML-SSO to sign in through your New Relic partner site. You may not have separate passwords or authentication information for your New Relic account. If you use an email address associated with a New Relic partner account when you first sign in to the New Relic mobile app, New Relic will send you a confirmation email for authentication. Android app users will also see a notification message. Important The authentication email expires 20 minutes after it is sent. Confirm your email address To authenticate using a SAML-SSO account provided through a New Relic partner: From the New Relic mobile app, type your email address associated with the partner account. Select I don't have a password. Retrieve the authentication email from your mobile device within 20 minutes. Select the Authenticate button (Android users) or email link (Android or iOS users) in the email to log in to New Relic. You will be redirected to the New Relic mobile app and logged in to your partner account. Troubleshoot email problems Here are some troubleshooting tips: If you cannot find the authentication message from New Relic in your mobile device's email in-box, check your Spam folder. If you miss the 20-minute deadline, sign in to the New Relic mobile app again, then select the link to resend the authentication email.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 199.32742,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Mobile</em> <em>app</em> <em>authentication</em> for <em>New</em> <em>Relic</em> partners",
        "sections": "<em>Mobile</em> <em>app</em> <em>authentication</em> for <em>New</em> <em>Relic</em> partners",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": " <em>New</em> <em>Relic</em> account. If you use an email address associated with a <em>New</em> <em>Relic</em> partner account when you first sign in to the <em>New</em> <em>Relic</em> <em>mobile</em> <em>app</em>, <em>New</em> <em>Relic</em> will send you a confirmation email for <em>authentication</em>. Android <em>app</em> users will also see a notification message. Important The <em>authentication</em> email"
      },
      "id": "604418de28ccbc28932c6071"
    }
  ],
  "/docs/mobile-apps/new-relic-mobile-apps/authentication-alerts/user-settings-authentication": [
    {
      "sections": [
        "Alerting with New Relic mobile apps",
        "Requirements",
        "Turn notifications on or off",
        "View alert incident details",
        "Troubleshoot alert settings",
        "Check notification settings for your mobile device.",
        "Delete the Android or iOS device from your New Relic account.",
        "Uninstall the New Relic mobile app.",
        "Reinstall the New Relic mobile app."
      ],
      "title": "Alerting with New Relic mobile apps",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Authentication and alerts"
      ],
      "external_id": "d55850dc642cc8ade20310e1d4654db61af1e809",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/authentication-alerts/alerting-new-relic-mobile-apps/",
      "published_at": "2021-12-04T17:58:58Z",
      "updated_at": "2021-07-09T12:24:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Account administrators can set up configuration to receive push notifications on Android and iOS devices from New Relic Alerts. You can receive alerts from any policy by attaching a user channel to the policy. Requirements This feature is available only to users on the original user model, not to users on the New Relic One user model. As a workaround, you can use the email notification channel. Turn notifications on or off When you log in to your New Relic account from an Android or iOS app, your device is automatically associated with your user channel. Be sure to add the associated user channel to the alert policy. View alert incident details The notification automatically appears on your device's lock screen. To start the New Relic app: Android devices: Tap the notification from the notification drawer. OR iOS devices: Swipe the screen. From the New Relic app's Alerts menu, select any alert to view error details for the associated application. Optional: Select Acknowledge. Optional: To view additional details, select Overview, Violations, or Event log. The main menu's Alerts list shows alerts in the following order, sorted by time: Active incidents Resolved incidents from today Resolved incidents and events from the past week, organized by day Troubleshoot alert settings If alerts are not working on your mobile device: Verify that you meet the requirements. Verify that alerts are enabled. Check your mobile device's notification settings, to ensure New Relic is permitted to send alerts. If the notification settings for your mobile device are correct, but you still do not receive notifications, delete the device from your account, then uninstall and reinstall the New Relic application. Check notification settings for your mobile device. Follow the procedure for your mobile device. Device To check notification settings: Android From your Android device's Settings, select Sound and notification. Check the settings for sound volume. Optional: Enable Also vibrate for calls. Check the settings for Interruptions. Check the settings for Notification. Check the settings for App notifications: Select the New Relic app, then check the settings for Block and Priority. iOS Ensure Do Not Disturb is off: From the iOS Settings app, select Do Not Disturb, and check that the Manual switch is off. Ensure the New Relic app is allowed to send notifications: From the iOS Settings app, select Notifications, and locate the New Relic app from the app list. Ensure that the Allow Notifications switch is on. Ensure that the alert style is set to Banners or Alerts. Optional: To enable audio alerts, set Sounds to on. Delete the Android or iOS device from your New Relic account. To delete the mobile device from your New Relic account, use the public graphql api api.newrelic.com/graphiql in a web browser: Query current devices by selecting actor -> mobilePushNotification -> devices and selecting appVersion, deviceId, and deviceName. Run this query to get the list of devices. Mutate to remove a device by selecting mutation -> mobilePushNotificationRemoveDevice, and passing in the deviceId from the list above. Or you can remove the device from the in-app Settings option from the menu -> Settings Look under Push notification devices, and remove from there. On iOS, slide from right to left to Delete a device, on Android, tap Delete Continue with the steps to reinstall the New Relic app from your device. Uninstall the New Relic mobile app. Follow the procedure to uninstall the New Relic app from your device, then reinstall it. Device To uninstall the New Relic app: Android From your Android device's Settings, select Apps, then select the New Relic app. Select Uninstall. Continue with the steps to reinstall the New Relic app. iOS From your iOS home screen, tap and hold the New Relic icon until it shakes. To delete the app, select the X icon. Continue with the steps to reinstall the New Relic app. Reinstall the New Relic mobile app. To reinstall the New Relic mobile app: From your Android device, select Google Play Store. OR From your iOS device's home screen, select App Store. Search for New Relic. Download the app. When the download finishes, sign in to your New Relic mobile app with your New Relic account.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 204.93674,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerting</em> with <em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "sections": "<em>Alerting</em> with <em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": " channel to the <em>alert</em> policy. View <em>alert</em> incident details The notification automatically appears on your device&#x27;s lock screen. To start the <em>New</em> <em>Relic</em> <em>app</em>: Android devices: Tap the notification from the notification drawer. OR iOS devices: Swipe the screen. From the <em>New</em> <em>Relic</em> <em>app</em>&#x27;s <em>Alerts</em> menu, select"
      },
      "id": "603e9efd64441f19a14e88ab"
    },
    {
      "sections": [
        "Troubleshoot SSO accounts using mobile devices",
        "No user name or password",
        "Errors after signing in",
        "Reauthentication problems"
      ],
      "title": "Troubleshoot SSO accounts using mobile devices",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Authentication and alerts"
      ],
      "external_id": "9ebb373182ce5fea83ba5a6baa03b2c7bccf0174",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/authentication-alerts/troubleshoot-sso-accounts-using-mobile-devices/",
      "published_at": "2021-12-04T17:59:22Z",
      "updated_at": "2021-05-16T06:23:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Typically when you sign in to the New Relic mobile app, your session redirects automatically to your web browser. From there you can sign in to your New Relic account. Here are troubleshooting tips if you have problems using the New Relic mobile app with your SAML-SSO enabled account. No user name or password You may not have a user name or password for New Relic because some SAML providers will overwrite your password, or because your administrator has not sent you this information. In these situations: From the mobile app's Log in, select the I don't have a password link. Use your mobile device to open your email account. From your email account, retrieve the New Relic authentication email within 20 minutes. Select the Authenticate button or the link below it in the email. Errors after signing in If you see any errors after successfully signing in to your SSO provider with your mobile device, verify that you are able to sign in to one.newrelic.com with a desktop web browser. If no, contact your administrator. If yes, get support at support.newrelic.com. Reauthentication problems If you are using reauthentication on a SAML-SSO account, you must log in to your default account. (All other accounts will be grayed out.) If you attempt to switch to a grayed-out account, an error message will appear, explaining this is currently not supported.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 201.59558,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshoot SSO accounts using <em>mobile</em> devices",
        "sections": "Troubleshoot SSO accounts using <em>mobile</em> devices",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": "Typically when you sign in to the <em>New</em> <em>Relic</em> <em>mobile</em> <em>app</em>, your session redirects automatically to your web browser. From there you can sign in to your <em>New</em> <em>Relic</em> account. Here are troubleshooting tips if you have problems using the <em>New</em> <em>Relic</em> <em>mobile</em> <em>app</em> with your SAML-SSO enabled account. No user name"
      },
      "id": "604415e0196a67fc3f960f42"
    },
    {
      "sections": [
        "Mobile app authentication for New Relic partners",
        "Important",
        "Confirm your email address",
        "Troubleshoot email problems"
      ],
      "title": "Mobile app authentication for New Relic partners",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Authentication and alerts"
      ],
      "external_id": "de6bdd35891dbbfea0ae914251a9d5c4487594a9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-apps/mobile-app-features/authentication-partner-saml-sso-accounts/",
      "published_at": "2021-12-04T16:40:04Z",
      "updated_at": "2021-03-13T03:57:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important This resource is for New Relic partners. For authentication of users in regular New Relic accounts, see Authentication. Partner account users typically use SAML-SSO to sign in through your New Relic partner site. You may not have separate passwords or authentication information for your New Relic account. If you use an email address associated with a New Relic partner account when you first sign in to the New Relic mobile app, New Relic will send you a confirmation email for authentication. Android app users will also see a notification message. Important The authentication email expires 20 minutes after it is sent. Confirm your email address To authenticate using a SAML-SSO account provided through a New Relic partner: From the New Relic mobile app, type your email address associated with the partner account. Select I don't have a password. Retrieve the authentication email from your mobile device within 20 minutes. Select the Authenticate button (Android users) or email link (Android or iOS users) in the email to log in to New Relic. You will be redirected to the New Relic mobile app and logged in to your partner account. Troubleshoot email problems Here are some troubleshooting tips: If you cannot find the authentication message from New Relic in your mobile device's email in-box, check your Spam folder. If you miss the 20-minute deadline, sign in to the New Relic mobile app again, then select the link to resend the authentication email.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 199.32742,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Mobile</em> <em>app</em> <em>authentication</em> for <em>New</em> <em>Relic</em> partners",
        "sections": "<em>Mobile</em> <em>app</em> <em>authentication</em> for <em>New</em> <em>Relic</em> partners",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": " <em>New</em> <em>Relic</em> account. If you use an email address associated with a <em>New</em> <em>Relic</em> partner account when you first sign in to the <em>New</em> <em>Relic</em> <em>mobile</em> <em>app</em>, <em>New</em> <em>Relic</em> will send you a confirmation email for <em>authentication</em>. Android <em>app</em> users will also see a notification message. Important The <em>authentication</em> email"
      },
      "id": "604418de28ccbc28932c6071"
    }
  ],
  "/docs/mobile-apps/new-relic-mobile-apps/ios-app/install-new-relic-ios-mobile-app": [
    {
      "sections": [
        "Introduction to iOS mobile app",
        "Features",
        "Time range",
        "Synthetic monitoring",
        "Alerts",
        "Mobile monitoring",
        "Data privacy"
      ],
      "title": "Introduction to iOS mobile app",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "iOS app"
      ],
      "external_id": "371077582a50dfd2a1e7c57cfbbf9eeaf8013e1c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/ios-app/introduction-ios-mobile-app/",
      "published_at": "2021-12-06T01:42:46Z",
      "updated_at": "2021-11-23T01:49:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The user interface for New Relic's iPhone and iPad app provides functionality similar to New Relic's standard user interface, with customized details for mobile users. Features New Relic's iOS app includes these New Relic products and features: New Relic's iOS app for iPhone and iPad includes these New Relic products and features: APM (iPhone and iPad). Includes real-time and historical data. Select the icon to see transaction details. Select Overview Charts to view summary charts of your top five transactions. Browser monitoring (iPhone and iPad). Provide overview dashboard, including average page load time, browser Apdex, average throughput, and more. Infrastructure monitoring (iPhone only). Alerts (iPhone and iPad). Get alert and deployment notifications. Synthetic monitoring (iPhone only). Mobile monitoring (iPhone and iPad). Includes crash reports, network errors, API calls, and active user count. New Relic's iOS app does not have all the features of the New Relic web application. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the clock icon in the top right of the page. This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth across the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). For iPads: to specify an end time other than now, slide the toggle from Ending Now to Custom Date. Synthetic monitoring You can use the iOS app to view your synthetic monitoring data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you connect the iOS app to your New Relic account, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For iOS alerts, notifications appear on your lock screen and can be viewed by swiping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile monitoring If you have a mobile application and have installed mobile monitoring, you can monitor its performance directly from your iPhone or iPad. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. Data privacy New Relic's mobile apps only record information needed to help authenticate and troubleshoot: User's email address associated with your New Relic account, including first and last name (for authentication purposes only) IP address Device ID For more information, see our Mobile data privacy and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 329.53992,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>mobile</em> <em>app</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>mobile</em> <em>app</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": "The user interface for <em>New</em> <em>Relic</em>&#x27;s <em>i</em>Phone and <em>i</em>Pad <em>app</em> provides functionality similar to <em>New</em> <em>Relic</em>&#x27;s standard user interface, with customized details for <em>mobile</em> users. Features <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>app</em> includes these <em>New</em> <em>Relic</em> products and features: <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>app</em> for <em>i</em>Phone and <em>i</em>Pad includes"
      },
      "id": "6044161628ccbc96b62c6092"
    },
    {
      "sections": [
        "Alerting with New Relic mobile apps",
        "Requirements",
        "Turn notifications on or off",
        "View alert incident details",
        "Troubleshoot alert settings",
        "Check notification settings for your mobile device.",
        "Delete the Android or iOS device from your New Relic account.",
        "Uninstall the New Relic mobile app.",
        "Reinstall the New Relic mobile app."
      ],
      "title": "Alerting with New Relic mobile apps",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Authentication and alerts"
      ],
      "external_id": "d55850dc642cc8ade20310e1d4654db61af1e809",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/authentication-alerts/alerting-new-relic-mobile-apps/",
      "published_at": "2021-12-04T17:58:58Z",
      "updated_at": "2021-07-09T12:24:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Account administrators can set up configuration to receive push notifications on Android and iOS devices from New Relic Alerts. You can receive alerts from any policy by attaching a user channel to the policy. Requirements This feature is available only to users on the original user model, not to users on the New Relic One user model. As a workaround, you can use the email notification channel. Turn notifications on or off When you log in to your New Relic account from an Android or iOS app, your device is automatically associated with your user channel. Be sure to add the associated user channel to the alert policy. View alert incident details The notification automatically appears on your device's lock screen. To start the New Relic app: Android devices: Tap the notification from the notification drawer. OR iOS devices: Swipe the screen. From the New Relic app's Alerts menu, select any alert to view error details for the associated application. Optional: Select Acknowledge. Optional: To view additional details, select Overview, Violations, or Event log. The main menu's Alerts list shows alerts in the following order, sorted by time: Active incidents Resolved incidents from today Resolved incidents and events from the past week, organized by day Troubleshoot alert settings If alerts are not working on your mobile device: Verify that you meet the requirements. Verify that alerts are enabled. Check your mobile device's notification settings, to ensure New Relic is permitted to send alerts. If the notification settings for your mobile device are correct, but you still do not receive notifications, delete the device from your account, then uninstall and reinstall the New Relic application. Check notification settings for your mobile device. Follow the procedure for your mobile device. Device To check notification settings: Android From your Android device's Settings, select Sound and notification. Check the settings for sound volume. Optional: Enable Also vibrate for calls. Check the settings for Interruptions. Check the settings for Notification. Check the settings for App notifications: Select the New Relic app, then check the settings for Block and Priority. iOS Ensure Do Not Disturb is off: From the iOS Settings app, select Do Not Disturb, and check that the Manual switch is off. Ensure the New Relic app is allowed to send notifications: From the iOS Settings app, select Notifications, and locate the New Relic app from the app list. Ensure that the Allow Notifications switch is on. Ensure that the alert style is set to Banners or Alerts. Optional: To enable audio alerts, set Sounds to on. Delete the Android or iOS device from your New Relic account. To delete the mobile device from your New Relic account, use the public graphql api api.newrelic.com/graphiql in a web browser: Query current devices by selecting actor -> mobilePushNotification -> devices and selecting appVersion, deviceId, and deviceName. Run this query to get the list of devices. Mutate to remove a device by selecting mutation -> mobilePushNotificationRemoveDevice, and passing in the deviceId from the list above. Or you can remove the device from the in-app Settings option from the menu -> Settings Look under Push notification devices, and remove from there. On iOS, slide from right to left to Delete a device, on Android, tap Delete Continue with the steps to reinstall the New Relic app from your device. Uninstall the New Relic mobile app. Follow the procedure to uninstall the New Relic app from your device, then reinstall it. Device To uninstall the New Relic app: Android From your Android device's Settings, select Apps, then select the New Relic app. Select Uninstall. Continue with the steps to reinstall the New Relic app. iOS From your iOS home screen, tap and hold the New Relic icon until it shakes. To delete the app, select the X icon. Continue with the steps to reinstall the New Relic app. Reinstall the New Relic mobile app. To reinstall the New Relic mobile app: From your Android device, select Google Play Store. OR From your iOS device's home screen, select App Store. Search for New Relic. Download the app. When the download finishes, sign in to your New Relic mobile app with your New Relic account.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.14854,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Alerting with <em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "sections": "Alerting with <em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": ": Android From your Android device&#x27;s Settings, select <em>Apps</em>, then select the <em>New</em> <em>Relic</em> <em>app</em>. Select Uninstall. Continue with the steps to reinstall the <em>New</em> <em>Relic</em> <em>app</em>. <em>iOS</em> From your <em>iOS</em> home screen, tap and hold the <em>New</em> <em>Relic</em> icon until it shakes. To delete the <em>app</em>, select the X icon. Continue"
      },
      "id": "603e9efd64441f19a14e88ab"
    },
    {
      "sections": [
        "User settings and authentication",
        "User authentication",
        "User settings",
        "Sign in with additional username",
        "Switch between accounts",
        "Remove or re-add a user name"
      ],
      "title": "User settings and authentication",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Authentication and alerts"
      ],
      "external_id": "0b40ac4c2e769279d25d0ebb2ea77cebda8d8ea7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/authentication-alerts/user-settings-authentication/",
      "published_at": "2021-12-04T17:59:31Z",
      "updated_at": "2021-11-25T04:07:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This explains how to authenticate your New Relic mobile app account, and how to add users to or remove them from your mobile device. User authentication Depending on your New Relic account, additional installation or authentication steps may be required when you install the New Relic mobile app. New Relic account Additional requirements New users If you do not already have a New Relic account: From your desktop web browser, create a New Relic account. Install your application with the appropriate New Relic agent. As part of new account setup, you will receive an email with a password reset link. The password reset link expires after 20 minutes for mobile apps. Existing New Relic users No additional requirements; your applications, hosts, and key transactions automatically appear after you sign in. Users with New Relic partner accounts Depending on the partner, you may need to complete a different authentication process. Azure Store users: Due to the deep integration between Azure Storefront and New Relic, Azure Storefront users cannot access their accounts on the New Relic Android or iOS apps. Users with SAML-SSO enabled accounts When you sign in to the New Relic mobile app, your session automatically redirects to your web browser. From there you can sign in to your New Relic SAML-SSO account. If you see any errors when using SAML-SSO accounts on your mobile device, verify that you are able to sign in to one.newrelic.com with a desktop web browser. If no, contact your administrator. If yes, get support at support.newrelic.com. User settings After you sign in, all New Relic accounts and applications associated with the user appear automatically. Sign in with additional username Follow the procedure for your mobile device. Mobile device To sign in to the app with an additional user name: Android To switch users: Log out from the Android device: Main menu > (selected username) > Logout > Confirm. Log in with a new account. iPhone From the app menu, select your account name, then select the Users menu. From the Users menu, select the plus icon. Sign in with the additional username. iPad To access the Users menu: Select the user icon or slide right. From the Users menu, select the plus icon. Sign in with the additional username. Switch between accounts To switch between accounts associated with your username: From the Users menu, select the user name. Select the account name. Remove or re-add a user name To remove a specific username from this device: From the Users menu, select Logout. To remove a user from this device, select the user's red minus icon. Select the user's Log out icon. To add a user again, sign in with that username again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 188.26033,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Sign <em>in</em> with additional username",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": " a different authentication process. Azure Store users: Due to the deep integration between Azure Storefront and <em>New</em> <em>Relic</em>, Azure Storefront users cannot access their accounts on the <em>New</em> <em>Relic</em> Android or <em>iOS</em> <em>apps</em>. Users with SAML-SSO enabled accounts When you sign in to the <em>New</em> <em>Relic</em> <em>mobile</em> <em>app</em>, your"
      },
      "id": "604415a728ccbc8fb52c6068"
    }
  ],
  "/docs/mobile-apps/new-relic-mobile-apps/ios-app/introduction-ios-mobile-app": [
    {
      "sections": [
        "Install the New Relic iOS mobile app",
        "Compatibility and requirements",
        "Installation"
      ],
      "title": "Install the New Relic iOS mobile app",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "iOS app"
      ],
      "external_id": "a33650792e7ba24040db9a65d8d7fbb25c341d18",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/ios-app/install-new-relic-ios-mobile-app/",
      "published_at": "2021-12-04T17:59:31Z",
      "updated_at": "2021-11-13T18:56:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This section provides information about compatibility and requirements, basic instructions on how to install and configure the New Relic iPhone and iPad apps, and links to more detailed information. Compatibility and requirements The New Relic iOS app allows you to view your New Relic applications, infrastructure data, key transactions, synthetic monitors, and alerts from an iPhone or iPad. Product requirements include: iOS 13 or higher iPhone users: iPhone SE or higher iPad users: iPad Air 2 or higher You can also use an iPod touch, although resolution may be different. Installation You can install the New Relic app from the App Store or learn more from the New Relic website. Follow standard procedures to install any iOS app, and then sign in with your New Relic user name (account email) and password if applicable. Depending on your New Relic account, additional installation or authentication steps may be required. For more information, see User settings and authentication.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 296.69855,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the <em>New</em> <em>Relic</em> <em>iOS</em> <em>mobile</em> <em>app</em>",
        "sections": "<em>Install</em> the <em>New</em> <em>Relic</em> <em>iOS</em> <em>mobile</em> <em>app</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": "This section provides information about compatibility and requirements, basic instructions on how to install and configure the <em>New</em> <em>Relic</em> <em>i</em>Phone and <em>i</em>Pad <em>apps</em>, and links to more detailed information. Compatibility and requirements The <em>New</em> <em>Relic</em> <em>iOS</em> <em>app</em> allows you to view your <em>New</em> <em>Relic</em> applications"
      },
      "id": "60441616196a67b070960f2b"
    },
    {
      "sections": [
        "Alerting with New Relic mobile apps",
        "Requirements",
        "Turn notifications on or off",
        "View alert incident details",
        "Troubleshoot alert settings",
        "Check notification settings for your mobile device.",
        "Delete the Android or iOS device from your New Relic account.",
        "Uninstall the New Relic mobile app.",
        "Reinstall the New Relic mobile app."
      ],
      "title": "Alerting with New Relic mobile apps",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Authentication and alerts"
      ],
      "external_id": "d55850dc642cc8ade20310e1d4654db61af1e809",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/authentication-alerts/alerting-new-relic-mobile-apps/",
      "published_at": "2021-12-04T17:58:58Z",
      "updated_at": "2021-07-09T12:24:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Account administrators can set up configuration to receive push notifications on Android and iOS devices from New Relic Alerts. You can receive alerts from any policy by attaching a user channel to the policy. Requirements This feature is available only to users on the original user model, not to users on the New Relic One user model. As a workaround, you can use the email notification channel. Turn notifications on or off When you log in to your New Relic account from an Android or iOS app, your device is automatically associated with your user channel. Be sure to add the associated user channel to the alert policy. View alert incident details The notification automatically appears on your device's lock screen. To start the New Relic app: Android devices: Tap the notification from the notification drawer. OR iOS devices: Swipe the screen. From the New Relic app's Alerts menu, select any alert to view error details for the associated application. Optional: Select Acknowledge. Optional: To view additional details, select Overview, Violations, or Event log. The main menu's Alerts list shows alerts in the following order, sorted by time: Active incidents Resolved incidents from today Resolved incidents and events from the past week, organized by day Troubleshoot alert settings If alerts are not working on your mobile device: Verify that you meet the requirements. Verify that alerts are enabled. Check your mobile device's notification settings, to ensure New Relic is permitted to send alerts. If the notification settings for your mobile device are correct, but you still do not receive notifications, delete the device from your account, then uninstall and reinstall the New Relic application. Check notification settings for your mobile device. Follow the procedure for your mobile device. Device To check notification settings: Android From your Android device's Settings, select Sound and notification. Check the settings for sound volume. Optional: Enable Also vibrate for calls. Check the settings for Interruptions. Check the settings for Notification. Check the settings for App notifications: Select the New Relic app, then check the settings for Block and Priority. iOS Ensure Do Not Disturb is off: From the iOS Settings app, select Do Not Disturb, and check that the Manual switch is off. Ensure the New Relic app is allowed to send notifications: From the iOS Settings app, select Notifications, and locate the New Relic app from the app list. Ensure that the Allow Notifications switch is on. Ensure that the alert style is set to Banners or Alerts. Optional: To enable audio alerts, set Sounds to on. Delete the Android or iOS device from your New Relic account. To delete the mobile device from your New Relic account, use the public graphql api api.newrelic.com/graphiql in a web browser: Query current devices by selecting actor -> mobilePushNotification -> devices and selecting appVersion, deviceId, and deviceName. Run this query to get the list of devices. Mutate to remove a device by selecting mutation -> mobilePushNotificationRemoveDevice, and passing in the deviceId from the list above. Or you can remove the device from the in-app Settings option from the menu -> Settings Look under Push notification devices, and remove from there. On iOS, slide from right to left to Delete a device, on Android, tap Delete Continue with the steps to reinstall the New Relic app from your device. Uninstall the New Relic mobile app. Follow the procedure to uninstall the New Relic app from your device, then reinstall it. Device To uninstall the New Relic app: Android From your Android device's Settings, select Apps, then select the New Relic app. Select Uninstall. Continue with the steps to reinstall the New Relic app. iOS From your iOS home screen, tap and hold the New Relic icon until it shakes. To delete the app, select the X icon. Continue with the steps to reinstall the New Relic app. Reinstall the New Relic mobile app. To reinstall the New Relic mobile app: From your Android device, select Google Play Store. OR From your iOS device's home screen, select App Store. Search for New Relic. Download the app. When the download finishes, sign in to your New Relic mobile app with your New Relic account.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.14854,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Alerting with <em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "sections": "Alerting with <em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": ": Android From your Android device&#x27;s Settings, select <em>Apps</em>, then select the <em>New</em> <em>Relic</em> <em>app</em>. Select Uninstall. Continue with the steps to reinstall the <em>New</em> <em>Relic</em> <em>app</em>. <em>iOS</em> From your <em>iOS</em> home screen, tap and hold the <em>New</em> <em>Relic</em> icon until it shakes. To delete the <em>app</em>, select the X icon. Continue"
      },
      "id": "603e9efd64441f19a14e88ab"
    },
    {
      "sections": [
        "User settings and authentication",
        "User authentication",
        "User settings",
        "Sign in with additional username",
        "Switch between accounts",
        "Remove or re-add a user name"
      ],
      "title": "User settings and authentication",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Authentication and alerts"
      ],
      "external_id": "0b40ac4c2e769279d25d0ebb2ea77cebda8d8ea7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/authentication-alerts/user-settings-authentication/",
      "published_at": "2021-12-04T17:59:31Z",
      "updated_at": "2021-11-25T04:07:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This explains how to authenticate your New Relic mobile app account, and how to add users to or remove them from your mobile device. User authentication Depending on your New Relic account, additional installation or authentication steps may be required when you install the New Relic mobile app. New Relic account Additional requirements New users If you do not already have a New Relic account: From your desktop web browser, create a New Relic account. Install your application with the appropriate New Relic agent. As part of new account setup, you will receive an email with a password reset link. The password reset link expires after 20 minutes for mobile apps. Existing New Relic users No additional requirements; your applications, hosts, and key transactions automatically appear after you sign in. Users with New Relic partner accounts Depending on the partner, you may need to complete a different authentication process. Azure Store users: Due to the deep integration between Azure Storefront and New Relic, Azure Storefront users cannot access their accounts on the New Relic Android or iOS apps. Users with SAML-SSO enabled accounts When you sign in to the New Relic mobile app, your session automatically redirects to your web browser. From there you can sign in to your New Relic SAML-SSO account. If you see any errors when using SAML-SSO accounts on your mobile device, verify that you are able to sign in to one.newrelic.com with a desktop web browser. If no, contact your administrator. If yes, get support at support.newrelic.com. User settings After you sign in, all New Relic accounts and applications associated with the user appear automatically. Sign in with additional username Follow the procedure for your mobile device. Mobile device To sign in to the app with an additional user name: Android To switch users: Log out from the Android device: Main menu > (selected username) > Logout > Confirm. Log in with a new account. iPhone From the app menu, select your account name, then select the Users menu. From the Users menu, select the plus icon. Sign in with the additional username. iPad To access the Users menu: Select the user icon or slide right. From the Users menu, select the plus icon. Sign in with the additional username. Switch between accounts To switch between accounts associated with your username: From the Users menu, select the user name. Select the account name. Remove or re-add a user name To remove a specific username from this device: From the Users menu, select Logout. To remove a user from this device, select the user's red minus icon. Select the user's Log out icon. To add a user again, sign in with that username again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 188.26033,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Sign <em>in</em> with additional username",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": " a different authentication process. Azure Store users: Due to the deep integration between Azure Storefront and <em>New</em> <em>Relic</em>, Azure Storefront users cannot access their accounts on the <em>New</em> <em>Relic</em> Android or <em>iOS</em> <em>apps</em>. Users with SAML-SSO enabled accounts When you sign in to the <em>New</em> <em>Relic</em> <em>mobile</em> <em>app</em>, your"
      },
      "id": "604415a728ccbc8fb52c6068"
    }
  ],
  "/docs/mobile-apps/new-relic-mobile-apps/tvos-app/introduction-apple-tv-app": [
    {
      "sections": [
        "Introduction to iOS mobile app",
        "Features",
        "Time range",
        "Synthetic monitoring",
        "Alerts",
        "Mobile monitoring",
        "Data privacy"
      ],
      "title": "Introduction to iOS mobile app",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "iOS app"
      ],
      "external_id": "371077582a50dfd2a1e7c57cfbbf9eeaf8013e1c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/ios-app/introduction-ios-mobile-app/",
      "published_at": "2021-12-06T01:42:46Z",
      "updated_at": "2021-11-23T01:49:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The user interface for New Relic's iPhone and iPad app provides functionality similar to New Relic's standard user interface, with customized details for mobile users. Features New Relic's iOS app includes these New Relic products and features: New Relic's iOS app for iPhone and iPad includes these New Relic products and features: APM (iPhone and iPad). Includes real-time and historical data. Select the icon to see transaction details. Select Overview Charts to view summary charts of your top five transactions. Browser monitoring (iPhone and iPad). Provide overview dashboard, including average page load time, browser Apdex, average throughput, and more. Infrastructure monitoring (iPhone only). Alerts (iPhone and iPad). Get alert and deployment notifications. Synthetic monitoring (iPhone only). Mobile monitoring (iPhone and iPad). Includes crash reports, network errors, API calls, and active user count. New Relic's iOS app does not have all the features of the New Relic web application. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the clock icon in the top right of the page. This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth across the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). For iPads: to specify an end time other than now, slide the toggle from Ending Now to Custom Date. Synthetic monitoring You can use the iOS app to view your synthetic monitoring data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you connect the iOS app to your New Relic account, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For iOS alerts, notifications appear on your lock screen and can be viewed by swiping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile monitoring If you have a mobile application and have installed mobile monitoring, you can monitor its performance directly from your iPhone or iPad. Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. Data privacy New Relic's mobile apps only record information needed to help authenticate and troubleshoot: User's email address associated with your New Relic account, including first and last name (for authentication purposes only) IP address Device ID For more information, see our Mobile data privacy and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.26419,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to iOS <em>mobile</em> <em>app</em>",
        "sections": "Introduction to iOS <em>mobile</em> <em>app</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": "The user interface for <em>New</em> <em>Relic</em>&#x27;s iPhone and iPad <em>app</em> provides functionality similar to <em>New</em> <em>Relic</em>&#x27;s standard user interface, with customized details for <em>mobile</em> users. Features <em>New</em> <em>Relic</em>&#x27;s iOS <em>app</em> includes these <em>New</em> <em>Relic</em> products and features: <em>New</em> <em>Relic</em>&#x27;s iOS <em>app</em> for iPhone and iPad includes"
      },
      "id": "6044161628ccbc96b62c6092"
    },
    {
      "sections": [
        "User settings and authentication",
        "User authentication",
        "User settings",
        "Sign in with additional username",
        "Switch between accounts",
        "Remove or re-add a user name"
      ],
      "title": "User settings and authentication",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Authentication and alerts"
      ],
      "external_id": "0b40ac4c2e769279d25d0ebb2ea77cebda8d8ea7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/authentication-alerts/user-settings-authentication/",
      "published_at": "2021-12-04T17:59:31Z",
      "updated_at": "2021-11-25T04:07:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This explains how to authenticate your New Relic mobile app account, and how to add users to or remove them from your mobile device. User authentication Depending on your New Relic account, additional installation or authentication steps may be required when you install the New Relic mobile app. New Relic account Additional requirements New users If you do not already have a New Relic account: From your desktop web browser, create a New Relic account. Install your application with the appropriate New Relic agent. As part of new account setup, you will receive an email with a password reset link. The password reset link expires after 20 minutes for mobile apps. Existing New Relic users No additional requirements; your applications, hosts, and key transactions automatically appear after you sign in. Users with New Relic partner accounts Depending on the partner, you may need to complete a different authentication process. Azure Store users: Due to the deep integration between Azure Storefront and New Relic, Azure Storefront users cannot access their accounts on the New Relic Android or iOS apps. Users with SAML-SSO enabled accounts When you sign in to the New Relic mobile app, your session automatically redirects to your web browser. From there you can sign in to your New Relic SAML-SSO account. If you see any errors when using SAML-SSO accounts on your mobile device, verify that you are able to sign in to one.newrelic.com with a desktop web browser. If no, contact your administrator. If yes, get support at support.newrelic.com. User settings After you sign in, all New Relic accounts and applications associated with the user appear automatically. Sign in with additional username Follow the procedure for your mobile device. Mobile device To sign in to the app with an additional user name: Android To switch users: Log out from the Android device: Main menu > (selected username) > Logout > Confirm. Log in with a new account. iPhone From the app menu, select your account name, then select the Users menu. From the Users menu, select the plus icon. Sign in with the additional username. iPad To access the Users menu: Select the user icon or slide right. From the Users menu, select the plus icon. Sign in with the additional username. Switch between accounts To switch between accounts associated with your username: From the Users menu, select the user name. Select the account name. Remove or re-add a user name To remove a specific username from this device: From the Users menu, select Logout. To remove a user from this device, select the user's red minus icon. Select the user's Log out icon. To add a user again, sign in with that username again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 179.45184,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": " a different authentication process. Azure Store users: Due to the deep integration between Azure Storefront and <em>New</em> <em>Relic</em>, Azure Storefront users cannot access their accounts on the <em>New</em> <em>Relic</em> Android or iOS <em>apps</em>. Users with SAML-SSO enabled accounts When you sign in to the <em>New</em> <em>Relic</em> <em>mobile</em> <em>app</em>, your"
      },
      "id": "604415a728ccbc8fb52c6068"
    },
    {
      "sections": [
        "Install the New Relic iOS mobile app",
        "Compatibility and requirements",
        "Installation"
      ],
      "title": "Install the New Relic iOS mobile app",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "iOS app"
      ],
      "external_id": "a33650792e7ba24040db9a65d8d7fbb25c341d18",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/ios-app/install-new-relic-ios-mobile-app/",
      "published_at": "2021-12-04T17:59:31Z",
      "updated_at": "2021-11-13T18:56:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This section provides information about compatibility and requirements, basic instructions on how to install and configure the New Relic iPhone and iPad apps, and links to more detailed information. Compatibility and requirements The New Relic iOS app allows you to view your New Relic applications, infrastructure data, key transactions, synthetic monitors, and alerts from an iPhone or iPad. Product requirements include: iOS 13 or higher iPhone users: iPhone SE or higher iPad users: iPad Air 2 or higher You can also use an iPod touch, although resolution may be different. Installation You can install the New Relic app from the App Store or learn more from the New Relic website. Follow standard procedures to install any iOS app, and then sign in with your New Relic user name (account email) and password if applicable. Depending on your New Relic account, additional installation or authentication steps may be required. For more information, see User settings and authentication.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.93474,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>New</em> <em>Relic</em> iOS <em>mobile</em> <em>app</em>",
        "sections": "Install the <em>New</em> <em>Relic</em> iOS <em>mobile</em> <em>app</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": "This section provides information about compatibility and requirements, basic instructions on how to install and configure the <em>New</em> <em>Relic</em> iPhone and iPad <em>apps</em>, and links to more detailed information. Compatibility and requirements The <em>New</em> <em>Relic</em> iOS <em>app</em> allows you to view your <em>New</em> <em>Relic</em> applications"
      },
      "id": "60441616196a67b070960f2b"
    }
  ],
  "/docs/mobile-crash-rest-api-v1": [
    {
      "sections": [
        "Working with the New Relic REST API (v1) (deprecated)",
        "Important"
      ],
      "title": "Working with the New Relic REST API (v1) (deprecated)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v1 deprecated",
        "New Relic REST API v1"
      ],
      "external_id": "9cb0f38eb95a8757624ddb63298ff9a32e1176e7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v1-deprecated/new-relic-rest-api-v1/working-new-relic-rest-api-v1-deprecated/",
      "published_at": "2021-12-04T21:03:25Z",
      "updated_at": "2021-03-13T02:32:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Currently New Relic supports two versions of the REST API. Version 1 is deprecated and has been replaced with the newer v2. No termination date has been announced. However, no further development or modifications are being made to v1. Important Start new projects by referring to Getting started with API v2 and the New Relic REST API v2 examples. Also, begin migrating your v1 scripts to their v2 equivalent. To use the REST API v1 in any way, your API key is required. Then, from the command line, you can use: curl -gH \"x-api-key:REPLACE_WITH_YOUR_API_KEY\" 'ENDPOINT_URL' Copy OR wget -qO- --header \"x-api-key:REPLACE_WITH_YOUR_API_KEY\" 'ENDPOINT_URL' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 352.55417,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Working with the New Relic <em>REST</em> <em>API</em> (<em>v1</em>) (deprecated)",
        "sections": "Working with the New Relic <em>REST</em> <em>API</em> (<em>v1</em>) (deprecated)",
        "tags": "<em>REST</em> <em>API</em> <em>v1</em> deprecated",
        "body": "Currently New Relic supports two versions of the <em>REST</em> <em>API</em>. Version <em>1</em> is deprecated and has been replaced with the newer <em>v</em>2. No termination date has been announced. However, no further development or modifications are being made to <em>v1</em>. Important Start new projects by referring to Getting started"
      },
      "id": "6043ff97e7b9d20358579a0d"
    },
    {
      "sections": [
        "FedRAMP-compliant endpoints",
        "Customer FedRAMP obligations",
        "Overview of data sources",
        "Agents",
        "APM agents",
        "Mobile monitoring agents",
        "Infrastructure monitoring",
        "Important",
        "Infrastructure agent versions below 1.15.0",
        "Browser agent",
        "Data-ingest APIs",
        "OTLP API",
        "Metric API",
        "Telemetry integrations",
        "Telemetry SDKs",
        "Event API",
        "Log API",
        "Log forwarders",
        "Trace API"
      ],
      "title": "FedRAMP-compliant endpoints",
      "type": "docs",
      "tags": [
        "Security",
        "Security and Privacy",
        "Compliance"
      ],
      "external_id": "ffce8ad6f802717392aca80e0965c9f3fe77ffdf",
      "image": "",
      "url": "https://docs.newrelic.com/docs/security/security-privacy/compliance/fedramp-compliant-endpoints/",
      "published_at": "2021-12-05T05:16:53Z",
      "updated_at": "2021-11-07T09:07:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides information on FedRAMP-compliant endpoints in New Relic. For more information about our security accreditation for the Federal Risk and Authorization Management Program (FedRAMP), see our data encryption documentation. For further information on New Relic networks, domains, and ports see our networking documentation. Customer FedRAMP obligations New Relic customers must meet all of the following requirements for New Relic’s FedRAMP environment: New Relic-approved customers: New Relic’s FedRAMP-Moderate authorized environment is only available to New Relic-approved customers. For more information, contact your New Relic account representative. Order form: Customer’s order form with New Relic must include customer’s eligibility for FedRAMP. Subscription level: Customer must have a current and valid subscription to our Enterprise edition or a New Relic-approved subscription. Authorized New Relic endpoints: Customer must send its data only to New Relic’s FedRAMP-designated endpoints. Authorized services and features: Customer must use only FedRAMP audited and authorized New Relic services and features (see below). Overview of data sources There are multiple ways to get data into New Relic. This doc has two sections: Agent settings: for our APM agents, infrastructure agent, browser agent, and mobile agent. Data-ingest APIs: for our Metric API, Event API, Trace API, and Log API, and the integrations that use those APIs. Agents New Relic has several agents for reporting data, like our APM agents, infrastructure agents, mobile agents, and browser agent. Setting these agents to send FedRAMP-compliant data involves setting a configuration setting to use the relevant FedRAMP endpoint. APM agents To ensure FedRAMP compliance, all APM agent configurations must report to gov-collector.newrelic.com rather than the default. Depending on the agent, you can either use code-based configuration or an environment variable. Here are details on enabling this: Language Code or environment variable C SDK In code: strcpy(_newrelic_app_config_t->redirect_collector, \"gov-collector.newrelic.com\"); Copy Environment variable: none Go In code: app, err = newrelic.NewApplication( newrelic.ConfigAppName(\"App Name\"), newrelic.ConfigLicense(os.Getenv(\"NEW_RELIC_LICENSE_KEY\")), func(cfg *newrelic.Config) { cfg.Host = \"gov-collector.newrelic.com\" }, ) Copy Environment variable: NEW_RELIC_HOST Java In newrelic.yml: common: &default_settings host: gov-collector.newrelic.com Copy Or set a system property of: newrelic.config.host Copy Environment variable: NEW_RELIC_HOST .NET In your XML config next to the license key: <service licenseKey=\"YOUR_LICENSE_KEY\" host=\"gov-collector.newrelic.com\"/> Copy Environment variable: NEW_RELIC_HOST Node.js In newrelic.js: host: 'gov-collector.newrelic.com' Copy Environment variable: NEW_RELIC_HOST PHP In newrelic.ini: newrelic.daemon.collector_host = gov-collector.newrelic.com Copy Environment variable: none Python In newrelic.ini: [newrelic] host = gov-collector.newrelic.com Copy Environment variable: NEW_RELIC_HOST Ruby In newrelic.yml: common: &default_settings host: gov-collector.newrelic.com Copy Environment variable: NEW_RELIC_HOST Elixir (open source agent) In config.exs: config :new_relic_agent, host: \"gov-collector.newrelic.com\" Copy Environment variable: NEW_RELIC_HOST For more on configuring APM agents, see APM configuration. Mobile monitoring agents To ensure FedRAMP compliance when using our mobile monitoring agents, all agent configurations must report to gov-mobile-collector.newrelic.com rather than the default. You must use code-based configuration. Environment variables are not available. Framework-specific configurations: Agent Code or environment variable Android In code: NewRelic.withApplicationToken({APP_TOKEN}) .usingCollectorAddress(\"gov-mobile-collector.newrelic.com\") .usingCrashCollectorAddress(\"gov-mobile-crash.newrelic.com\") .start(this.getApplication()); Copy Environment variable: none iOS In code: [NewRelic startWithApplicationToken:@\"{APP_TOKEN}\" andCollectorAddress:@\"gov-mobile-collector.newrelic.com\" andCrashCollectorAddress:@\"gov-mobile-crash.newrelic.com\"]; Copy Environment variable: none Infrastructure monitoring If you have infrastructure agent version 1.15.0 or higher, simply enable the FedRAMP configuration option. This enables FedRAMP compliancy for data reported by the infrastructure agent, and for any on-host integrations that work with the infrastructure agent to report data. Important The AWS CloudWatch Metric Streams integration is not currently FedRAMP compliant. If you have an older agent version, use the following values to edit your YAML configuration: Infrastructure agent versions below 1.15.0 If you have an infrastructure agent version below 1.15.0, you must change three of the endpoints used for reporting. To set these endpoints, you can change your YAML configuration or use environment variables. YAML config field Endpoint URL collector_url https://gov-infra-api.newrelic.com Copy identity_url https://gov-identity-api.newrelic.com Copy command_channel_url https://gov-infrastructure-command-api.newrelic.com Copy To edit environment variables, use these values: Environment variable Endpoint URL NRIA_COLLECTOR_URL https://gov-infra-api.newrelic.com Copy NRIA_IDENTITY_URL https://gov-identity-api.newrelic.com Copy NRIA_COMMAND_CHANNEL_URL https://gov-infrastructure-command-api.newrelic.com Copy Browser agent Browser agents will automatically update your account information to use the correct endpoints. Data-ingest APIs Below are details about the FedRAMP endpoint for our ingest APIs: Metric API, the Event API, the Log API, and the Trace API. OTLP API To ensure FedRAMP compliance when using the OTLP API, instead of sending to the US OTLP API endpoint of https://otlp.nr-data.net:4317, send data to https://gov-otlp.nr-data.net:4317. Metric API To ensure FedRAMP compliance when using the Metric API, instead of sending metric data to the default Metric API endpoint of https://metric-api.newrelic.com/metric/v1, it must be sent to https://gov-metric-api.newrelic.com/metric/v1. The Metric API can be used directly but it's mainly used by various New Relic tools. Below are instructions showing where to edit the configuration for setting the FedRAMP endpoint. Telemetry integrations Here are instructions for our open source telemetry integrations that report metric data: Dropwizard: use the overrideUri configuration. Kamon: use the metric-ingest-url configuration. See Override endpoints. Micrometer: override the public String uri() method on your NewRelicRegistryConfig to return the new endpoint. See an example. Prometheus: Prometheus OpenMetrics: if you are using our nri-prometheus helm chart, you can change the endpoint in your values.yml file, like in this example. If you're using the nri-bundle chart, you need to nest this value under the nri-prometheus key to propagate it to the sub-chart. Remote write integration: not available. Telemetry SDKs Here are instructions for our Telemetry SDKs that report metric data: Go: use the MetricsURLOverride configuration. Java: in the MetricBatchSender section, configure the endpoint. See an example. .NET: use the MetricUrlOverride configuration. Node.js: edit the METRIC_HOST = 'metric-api.newrelic.com' configuration. Python: edit the HOST = \"metric-api.newrelic.com\" configuration. Event API To ensure FedRAMP compliance for the Event API, all traffic reporting to insights-collector.newrelic.com must instead report to gov-insights-collector.newrelic.com. The Event API endpoint is configurable for the following Telemetry SDKs. The Telemetry SDKs are used by our open-source telemetry integrations. Language Solution Java Telemetry SDK In code: SenderConfiguration configuration = SenderConfiguration .builder( \"gov-insights-collector.newrelic.com\", EventBatchSender.EVENTS_PATH) .build(); EventBatchSender eventBatchSender = EventBatchSender.create(configuration); Copy Python Telemetry SDK In code: event_client = EventClient(host=\"gov-insights-collector.newrelic.com\") Copy For more information, see our Telemetry API documentation in GitHub. Log API To ensure FedRAMP compliance for data sent via the Log API, the solution for almost all our logging tools is to replace the https://log-api.newrelic.com/log/v1 endpoint with https://gov-log-api.newrelic.com/log/v1. Here are details for various tools: Log forwarders Here are details on changing the endpoint for our log forwarders: AWS Firelens: Add the endpoint property to the options field of the logConfiguration, similar to to the EU account endpoint change shown in these Firelens endpoint configuration instructions. Fluentbit: Use our Fluentbit endpoint configuration. Fluentd: Use our Fluentd endpoint instructions. Infrastructure agent: See FedRAMP for infrastructure. Kubernetes: Our Kubernetes integration logs are based on fluentbit’s output plugin. Use these endpoint instructions. Logstash: Use our Logstash endpoint configuration. Syslog: For configuring syslog clients, see TCP endpoint configuration. S3: Not available. Vector: Not available. To use the Log API directly, you'd edit the Log API endpoint configuration. Trace API To ensure FedRAMP compliance for data sent via the Trace API (including telemetry integrations that use this API), replace the https://trace-api.newrelic.com/trace/v1 endpoint with https://gov-trace-api.newrelic.com/trace/v1. Notes about FedRAMP compliance for other trace data: Trace data is reported by some of our agents, like our APM agents, browser agent, and mobile agent. To enable FedRAMP compliance for that data, you would enable FedRAMP for the applicable agent. To enable FedRAMP compliance for Infinite Tracing, you would create a new FedRAMP compliant trace observer from the New Relic Edge app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 219.02509,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Mobile</em> monitoring agents",
        "body": " data to the default Metric <em>API</em> endpoint of https:&#x2F;&#x2F;metric-<em>api</em>.newrelic.com&#x2F;metric&#x2F;<em>v1</em>, it must be sent to https:&#x2F;&#x2F;gov-metric-<em>api</em>.newrelic.com&#x2F;metric&#x2F;<em>v1</em>. The Metric <em>API</em> can be used directly but it&#x27;s mainly used by various New Relic tools. Below are instructions showing where to edit the configuration"
      },
      "id": "603e945164441f64384e8872"
    },
    {
      "sections": [
        "Synthetics REST API version 1 (deprecated)",
        "Caution",
        "Managing simple and scripted monitors",
        "Get all monitors",
        "Get a specific monitor",
        "Create a monitor",
        "Update an existing monitor",
        "Delete an existing monitor",
        "Get list of valid locations",
        "Managing scripted monitors",
        "Get monitor script",
        "Add scripted monitor",
        "Update monitor script",
        "Scripted browser example",
        "Scripted browser API example",
        "Bash script example",
        "Synthetics attributes",
        "Specific monitor endpoint"
      ],
      "title": "Synthetics REST API version 1 (deprecated)",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Monitor examples"
      ],
      "external_id": "38f3b7d441889cea39fa8a10d1593473bffa8cf7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/synthetics-api/synthetics-rest-api-version-1/",
      "published_at": "2021-12-05T05:20:51Z",
      "updated_at": "2021-10-31T10:08:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Currently New Relic supports two versions of the Synthetics API: v1 and v3. Version 3 was released October 2016. Version 1 is deprecated and will eventually no longer be available. No termination date has been announced. However, no further development or modifications will be made to v1. Caution Recommendation: Create new monitors using the v3 Synthetics API and migrate v1 scripts to their v3 equivalent. To use the REST API for New Relic's synthetic monitoring, you must activate API access and generate your Admin User's API key from your account settings. Then you can make standard API calls via the command line. Managing simple and scripted monitors You must use your Admin User's API key to make Synthetics REST API calls. The account's REST API key will not work. Caution The Synthetics REST API limits an account's rate of requests to three requests per second. Requests made in excess of this threshold will return a 429 response code. These examples show curl commands: Get all monitors To view a list of all monitors in New Relic for your account, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/monitors. For example: curl -v \\ -H 'X-Api-Key:{Admin_User_Key}' https://synthetics.newrelic.com/synthetics/api/v1/monitors Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"count\": integer, \"monitors\": [ { \"id\": UUID, \"name\": string, \"type\": string, \"frequency\": integer, \"uri\": string, \"locations\": array of strings, \"status\": string, \"slaThreshold\": double, \"userId\": integer, \"apiVersion\": string } ] } Copy Get a specific monitor To view a single existing monitor in New Relic, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}. Replace the { id} in the following example with the specific monitor ID. curl -v \\ -H 'X-Api-Key:{Admin_User_Key}' https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id} Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"id\": UUID, \"name\": string, \"type\": string, \"frequency\": integer, \"uri\": string, \"locations\": array of strings, \"status\": string, \"slaThreshold\": double, \"userId\": integer, \"apiVersion\": string } Copy An invalid monitor ID will return the error 404 Not Found: The specified monitor doesn't exist. Create a monitor To add a new monitor to your account in New Relic, send a POST request to https://synthetics.newrelic.com/synthetics/api/v1/monitors with a JSON payload that describes the monitor: { \"name\": string [required], \"type\": string (SIMPLE, BROWSER, SCRIPT_API, SCRIPT_BROWSER) [required], \"frequency\": integer (minutes) [required, must be one of 1, 5, 10, 15, 30, 60, 360, 720, or 1440], \"uri\": string [required for SIMPLE and BROWSER type], \"locations\": array of strings (send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/locations to get a list of valid locations) [at least one required], \"status\": string (ENABLED, MUTED, DISABLED) [required], \"slaThreshold\": double, } Copy In addition, to add a scripted monitor via the REST API, call an additional API endpoint to send the script for the monitor just created. Replace the Synthetics REST API attributes in the following example with your specific values. curl -v \\ -X POST -H 'X-Api-Key:{Admin_User_Key}' \\ -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/monitors \\ -d '{ \"name\" : \"monitor1\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"type\" : \"browser\"}' Copy A successful request will return a 201 Created response, with the URI of the newly-created monitor specified in the location header. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds or one or more of the specified locations is invalid (See the error message in the body of the response.) 402 Payment Required: Creating the monitor will increase your scheduled checks past your account's purchased check limit. Update an existing monitor To update an existing monitor in New Relic, send a PUT request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}. In addition, for scripted monitors, follow the procedures to update the BASE64 encoded script. Replace the { id} in the following example with the specific monitor ID, and replace the Synthetics REST API attributes with your specific values. curl -v \\ -X PUT -H 'X-Api-Key:{Admin_User_Key}' \\ -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id} \\ -d '{ \"name\" : \"updated monitor name\", \"type\" : \"simple\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com/\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"status\" : \"enabled\", \"slaThreshold\": \"7.0\" }' Copy PUT requests are intended to replace target entities, so all attributes required in the JSON payload when creating a new monitor are also required when updating an existing monitor. A successful request will return a 204 No Content response, with an empty body. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds or one or more of the specified locations is invalid (See the error message in the body of the response.) 404 Not Found: The specified monitor does not exist. Delete an existing monitor To delete an existing monitor in New Relic, send a DELETE request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}. Replace the { id} in the following example with the specific monitor ID. curl -v \\ -H 'X-Api-Key:{Admin_User_Key}' \\ -X DELETE https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id} Copy A successful request will return a 204 No Content response, with an empty body. An unsuccessful request will return the response, 404 Not Found: The specified monitor does not exist. Get list of valid locations To retrieve the list of valid locations in New Relic, use the following command. curl -v \\ -X GET -H 'X-Api-Key:{Admin_User_Key}' https://synthetics.newrelic.com/synthetics/api/v1/locations Copy Managing scripted monitors In addition to the general API, there are several API methods for the scripted browser (SCRIPT_BROWSER) and api test (SCRIPT_API) monitor types. These examples show curl commands. Get monitor script To view the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic for your account, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}/script. Replace the { id} with the specific monitor ID. For example: curl -v -H 'X-Api-Key: {Admin_User_Key}' https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}/script Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"scriptText\": BASE64 encoded string } Copy Possible error codes include: 403 Forbidden: The specified monitor is not of type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor doesn't exist or the script associated with the monitor doesn't exist. Add scripted monitor To add a new scripted monitor to New Relic with the REST API: Follow standard API procedures to add a new monitor, and identify the type as a SCRIPT_BROWSER or SCRIPT_API. Update the new monitor with a BASE64 encoded version of the script to the ${MONITOR_UUID}/script endpoint. For more information, refer to the example. Update monitor script To update the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic for your account, send a PUT request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}/script with a JSON payload that contains the scriptText (required). The scriptLocations data is required only for private locations with Verified Script Execution turned on. The password used to generate the HMAC string must match the password set for the private location. When generating the HMAC string, use the SHA256 algorithm. { \"scriptText\": BASE64 encoded String, \"scriptLocations\": [ { \"name\": Location name, \"hmac\" BASE64 encoded String of SHA256 HMAC for location } ] } Copy Replace the { id} with the specific monitor ID. Here is an example for the script: var assert = require('assert'); assert.equal('1', '1'); Copy This example uses password as the password for the scriptLocation. curl -v -H 'X-Api-Key: '{Admin_User_Key}' -H 'content-type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}/script -d '{ \"scriptText\": \"dmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpOw0KYXNzZXJ0LmVxdWFsKCcxJywgJzEnKTs=\",\"scriptLocations\": [ { \"name\": \"my_vse_enabled_location\", \"hmac\": \"MjhiNGE4MjVlMDE1N2M4NDQ4MjNjNDFkZDEyYTRjMmUzZDE3NGJlNjU0MWFmOTJlMzNiODExOGU2ZjhkZTY4\"} ]}' Copy A successful request will return a 204 No Content response with an empty body. Possible error codes include: 400 Bad Request: Invalid BASE64 encoded string for scriptText or hmac. 403 Forbidden: The specified monitor is not of the type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor does not exist. Scripted browser example Here is an example of using New Relic's REST API and the bash script to create a scripted browser monitor. Scripted browser API example The following example shows curl commands to create a scripted browser monitor. At the top of the script, replace the variables with your specific values. For the scriptfile variable, identify the filename for the script to be created. Here is a sample script that can be saved as sample_synth_script.js to use in the example: var assert = require(\"assert\"); $browser.get(\"http://example.com\").then(function(){ // Check the H1 title matches \"Example Domain\" return $browser.findElement($driver.By.css(\"h1\")).then(function(element){ return element.getText().then(function(text){ assert.equal(\"Example Domain\", text, \"Page H1 title did not match\"); }); }); }).then(function(){ // Check that the external link matches \"http://www.iana.org/domains/example\" return $browser.findElement($driver.By.css(\"div > p > a\")).then(function(element){ return element.getAttribute(\"href\").then(function(link){ assert.equal(\"http://www.iana.org/domains/example\", link, \"More information link did not match\"); }); }); }); Copy Bash script example This example show the bash script that will create the SCRIPTED_BROWSER monitor. #!/bin/bash # Admin API key from your account settings adminAPIKey='' # Other attributes found at https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/attributes-synthetics-rest-api#api-attributes monitorName='Test API Script' monitorType='SCRIPT_BROWSER' frequency=1440 locations='\"AWS_US_WEST_1\", \"AWS_US_EAST_1\"' slaThreshold=7.0 # Location of the file with your script scriptfile=sample_synth_script.js # Test that the script file exists (does not validate content) if [ -e \"$scriptfile\" ] then script=$(cat \"$scriptfile\") payload=\"{ \\\"name\\\" : \\\"$monitorName\\\", \\\"frequency\\\" : $frequency, \\\"locations\\\" : [ $locations ], \\\"status\\\" : \\\"ENABLED\\\", \\\"type\\\" : \\\"$monitorType\\\", \\\"slaThreshold\\\" : $slaThreshold, \\\"uri\\\":\\\"\\\"}\" echo \"Creating monitor\" # Make cURL call to API and parse response headers to get monitor UUID shopt -s extglob # Required to trim whitespace; see below while IFS=':' read key value; do # trim whitespace in \"value\" value=${value##+([[:space:]])}; value=${value%%+([[:space:]])} case \"$key\" in location) LOCATION=\"$value\" ;; HTTP*) read PROTO STATUS MSG <<< \"$key{$value:+:$value}\" ;; esac done < <(curl -sS -i -X POST -H \"X-Api-Key:$adminAPIKey\" -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/monitors -d \"$payload\") # Validate monitor creation & add script unless it failed if [ $STATUS = 201 ]; then echo \"Monitor created, $LOCATION \" echo \"Uploading script\" # base64 encode script encoded=`echo \"$script\" | base64` scriptPayload='{\"scriptText\":\"'$encoded'\"}' curl -s -X PUT -H \"X-Api-Key:$adminAPIKey\" -H 'Content-Type: application/json' \"$LOCATION/script\" -d $scriptPayload echo \"Script uploaded\" else echo \"Monitor creation failed\" fi else echo \"script file not found, not creating monitor\" fi Copy Synthetics attributes Here are the attributes used with Synthetics REST API calls, listed in alphabetical order. Synthetics API attribute Definition apiVersion String: The version number. emails Array of strings: Email addresses for alert notifications with New Relic. frequency Integer: Number of minutes between checks. Valid values include 1, 5, 15, 30, 60, 360, 720, and 1440. id The UUID for the specific Synthetics monitor. locations Array of strings: Array of locations by full label. name String: The monitor's name. scriptLocations String: The name and hmac values for private locations using Verified Script Execution. scriptText String: The BASE64 encoded text for scripted monitors. slaThreshold Double: Value for the Synthetics SLA report, in seconds. status String: Valid values include ENABLED, MUTED, and DISABLED. type String: Type of monitor. Valid values include: SIMPLE (Ping) BROWSER SCRIPT_BROWSER SCRIPT_API uri String: The URI for SIMPLE and BROWSER monitor types; for example, http://my-site.com. Optional for SCRIPT_BROWSER and SCRIPT_API. userID Integer: The specific user ID. Specific monitor endpoint When making REST API calls for a specific monitor, include the monitor_uuid as part of the endpoint. The monitor_uuid is the GUID which is part of the URL. For example, a selected Synthetics monitor has this URL: https://synthetics.newrelic.com/accounts/nnnn/monitors/ab123-c456d-e78-90123-f45g Copy The monitor_uuid is the value that follows /monitors/.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 211.64717,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Synthetics <em>REST</em> <em>API</em> <em>version</em> <em>1</em> (deprecated)",
        "sections": "Synthetics <em>REST</em> <em>API</em> <em>version</em> <em>1</em> (deprecated)",
        "tags": "Synthetics <em>REST</em> <em>API</em>",
        "body": " Recommendation: Create new monitors using the <em>v</em>3 Synthetics <em>API</em> and migrate <em>v1</em> scripts to their <em>v</em>3 equivalent. To use the <em>REST</em> <em>API</em> for New Relic&#x27;s synthetic monitoring, you must activate <em>API</em> access and generate your Admin User&#x27;s <em>API</em> key from your account settings. Then you can make standard <em>API</em> calls"
      },
      "id": "60452541e7b9d27829579a0a"
    }
  ],
  "/docs/mobile-monitoring/index": [
    {
      "sections": [
        "HTTP errors: Network failure analysis",
        "Find and use the HTTP errors page",
        "Group, sort, and filter errors and failures",
        "HTTP error profiles",
        "View more details about a specific error",
        "View and share error data with query builder",
        "View legacy HTTP errors UI page",
        "View the Errors page",
        "Error trace details",
        "View error data in query builder",
        "Unknown errors or URL errors"
      ],
      "title": "HTTP errors: Network failure analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "04631e122b061663c6fd261b605202654aadcf96",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-errors-network-failure-analysis/",
      "published_at": "2021-12-04T15:48:48Z",
      "updated_at": "2021-12-04T15:48:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring's HTTP errors page helps you to better understand HTTP errors and network failures associated with your mobile app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager See a list of errors and failures so you can coordinate mobile app teams with backend teams and share the data they need to fix issues. QA engineer Make sure that a new version of your app does not cause a spike in errors compared to a previous version. DevOps engineer See a list of domains and URLs associated with HTTP errors and network failures, so you can focus on the ones that are causing errors and filter out status codes that are too noisy for your alerts. Mobile developer Find out if there are frontend or backend problems affecting your mobile app (even without an error alert going off) so that you can address them in a new version. Support engineer View the errors and session attributes (geography, connection type, device, app version) associated with an error so that you can help customers with their issues. Find and use the HTTP errors page There are two ways to get to the HTTP errors page: Go to one.newrelic.com > Mobile > (select an app) > Network > Network errors. From a mobile app's Overview page in mobile monitoring, select the HTTP errors/network failures chart title link. From the HTTP errors page, investigate HTTP request and network failures: Use any standard page functions to look for trends in Errors and failures charts. Target specific types of errors and failures by grouping, sorting, and filtering the data. Find anomalies in your request errors with HTTP error profiles. Select an error or failure to view details for it. You can also define NRQL alerts that are focused on error types for your critical services or query your app data. Group, sort, and filter errors and failures If you want to do this... Do this... Change how the page groups and sorts errors and network failures Make selections from the Group by and Sort by dropdowns. By default, the Network errors page is grouped by request domain and sorted by errors and failures. Filter for specific errors and network failures Select an error or failure from the Errors and failures list and/or select multiple filters from the Filter dropdown. See which filters you applied or remove filters The filters you select display next to the filter dropdown. To clear filters, select the X next to the filter you want to clear. Change the time window Select a new time period from the Time picker dropdown. View information for one specific app version Select the version that you want to see charts and lists for in the Versions dropdown. HTTP error profiles Error profiles provide visual details about significant differences in the frequency of different values for HTTP error events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of other errors This helps you take more of the guesswork out of resolving your mobile application's HTTP errors. You can more easily determine if you safely ignore the error, or if you should attempt to resolve the error with a new deployment, code change, customer communication or other actions. View more details about a specific error To view details about an error or failure, select the Request URL link to be directed to the Error summary page. From the Error summary page, you can view the version information, request attributes, and Response body, as well as get a breakdown of error types for the request URL. View and share error data with query builder To explore the data behind any of the charts or lists on the HTTP errors/requests page: Select for any chart. Select View query and then View in Insights. This will open the query builder. From the query builder, you can add the error data to a dashboard and share it via a permalink. To dig deeper into the error data, query your data for the following events and attributes: MobileRequestError events and attributes MobileRequest events and attributes View legacy HTTP errors UI page Accounts that do not have an Enterprise-level subscription see a different HTTP Errors UI page: The Errors page includes details about HTTP errors (403, 404, 422, 500, 502, etc.) and network failures for your hosts; for example: Secure connection failed Timed out Cannot find host Not connected to Internet Cannot connect to host View the Errors page To view HTTP errors or network failures for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Network > Errors. To change the view to errors or failures, select the Sort by option. To hide low-usage hosts, select the Hide < 1% throughput option. To limit information to a specific version of your app, or to change the time period, select your choice from the Versions menu or the time picker below the menu bar. To view details for a specific host, HTTP status error, or network failure, select its name. Use any of our standard user interface functions to drill down into detailed information. Error trace details Mobile monitoring will capture the response details from HTTP requests that return a 400 or 500 level status code. In addition, error messages generated from Android apps will include a stack trace. To view details about an error trace on the Errors page, select its request URL link. From here you can: View the response body. Share the error details with others by email. Delete or hide the error. The errors chart also appears on the selected mobile app's Overview page. If the chart shows errors, you can select its HTTP errors/network failures title or select anywhere on the Overview page's chart to go directly to this Errors page. View error data in query builder To dig deeper into your request data, use the query builder to query and chart the MobileRequest events and attributes. Unknown errors or URL errors The mobile agents maintain a list of exception types. In some cases, custom exceptions thrown by applications fall outside of this list. When this happens, Unknown may appear in the mobile Errors page. If you find Unknown in your list of errors and need assistance in researching which exception types are being missed, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 641.1166,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": "<em>Mobile</em> <em>monitoring</em>&#x27;s HTTP errors page helps you to better understand HTTP errors and network failures associated with your <em>mobile</em> app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager"
      },
      "id": "603e8eb428ccbcd174eba791"
    },
    {
      "sections": [
        "Find Build UUIDs for unsymbolicated crashes",
        "View the Build UUID",
        "Binary images example",
        "Find and resymbolicate the dSYM"
      ],
      "title": "Find Build UUIDs for unsymbolicated crashes",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Crashes"
      ],
      "external_id": "e8b926653583d66810c0f68eb6b0111ab3bfc477",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/crashes/find-build-uuids-unsymbolicated-crashes/",
      "published_at": "2021-12-04T18:00:46Z",
      "updated_at": "2021-10-30T20:52:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If the dSYM is not uploaded to New Relic, mobile crash reports cannot be symbolicated. You can upload dSYMs manually or directly through the New Relic UI. However, every build of an application will create a new dSYM, and it can be difficult managing which dSYM is attributed to which app build. In this situation, you can use the Build UUID identifier to: Identify a unique build of an application. Find which dSYM can be used to symbolicate a crash. View the Build UUID An application may have more than one Build UUID, one attributed for each CPU architecture the application is built. The Build UUID is also stored within the associated dSYM and can be extracted to identify the dSYM. New Relic crash reports also contain the Build UUID of the crashing application. To view the Build UUID: Go to one.newrelic.com and click Mobile in the top nav. Then find your app and click Crashes > Crash Analysis. From the Crash list table, select any row. From the selected crash report's Crash Details page, look for the App Image Uuid on the attribute list. If the App Image Uuid is not on the selected crash report's attributes list: Export the crash details. Look for the Build UUID in the Binary images section of the exported crash report. Use the Build UUID extracted from the crash details to find the missing dSYM. Binary images example Here is an example of the Binary images section from an exported crash report. This section lists the Build UUID for every dynamically-linked library included in the application, as well as the Build UUID for the main application. In this example, the main application is New Relic. Its Build UUID is 117667e7b8d230cb8a908906c64e0227. This is the identifier you can use to find the associated dSYM. Binary Images: 0xb1000 - 0x30d000 New Relic armv7 < 117667e7b8d230cb8a908906c64e0227 > /var/containers/Bundle/Application/New Relic.app/New Relic 0x22290000 - 0x22292000 libSystem.B.dylib armv7 <39d6d6f7c2ac3de8bb29c40a1b66368a> /usr/lib/libSystem.B.dylib 0x22292000 - 0x222de000 libc++.1.dylib armv7 <017dba6c16b63f9ebecb9ddd0d0a4520> /usr/lib/libc++.1.dylib 0x222de000 - 0x222f9000 libc++abi.dylib armv7 <d32373f6c2153a509f6603750d213ffb> /usr/lib/libc++abi.dylib 0x222fc000 - 0x22667000 libobjc.A.dylib armv7 <94f6d325c1843f45b3a439b86fc9de15> /usr/lib/libobjc.A.dylib 0x22667000 - 0x2266c000 libcache.dylib armv7 <8009f99fb892331dbcb61cd740ff0f43> /usr/lib/system/libcache.dylib 0x2266c000 - 0x22676000 libcommonCrypto.dylib armv7 <f6db318471d732d39918ef36bde65cb7> /usr/lib/system/libcommonCrypto.dylib 0x22676000 - 0x2267c000 libcompiler_rt.dylib armv7 <cfa3ca12d6c2383abcaf3c8541e9b86c> /usr/lib/system/libcompiler_rt.dylib 0x2267c000 - 0x22683000 libcopyfile.dylib armv7 <d2b06020c3693c7b9d179434f8115ba0> /usr/lib/system/libcopyfile.dylib 0x22683000 - 0x226d3000 libcorecrypto.dylib armv7 <181437f8d9e53277ace439de8b3fd1ad> /usr/lib/system/libcorecrypto.dylib 0x226d3000 - 0x2271d000 libdispatch.dylib armv7 <bbb4bba2176039ab95a59d7a56f6eff8> /usr/lib/system/libdispatch.dylib Copy Find and resymbolicate the dSYM To find a dSYM's Build UUID of a dSYM: use dwarfdump with the following terminal command: dwarfdump --uuid <path-to-dSYM> Copy In the following example, the New Relic dSYM returns two Build UUIDs, one each for ARMv7 and ARM64. The ARMv7 Build UUID matches the Build UUID of the missing crash example: > dwarfdump --uuid ./New\\ Relic.app.dSYM/Contents/Resources/DWARF/New\\ Relic UUID: 117667E7-B8D2-30CB-8A90-8906C64E0227 (armv7) ./New Relic.app.dSYM/Contents/Resources/DWARF/New Relic UUID: B1A8C6EE-02B9-3C55-AEE7-308521873107 (arm64) ./New Relic.app.dSYM/Contents/Resources/DWARF/New Relic Copy To symbolicate the unsymbolicated crashes, follow the instructions to manually upload the dSYM.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 408.36893,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": "If the dSYM is not uploaded to New Relic, <em>mobile</em> crash reports cannot be symbolicated. You can upload dSYMs manually or directly through the New Relic UI. However, every build of an application will create a new dSYM, and it can be difficult managing which dSYM is attributed to which app build"
      },
      "id": "603e9fbae7b9d21cef2a07dd"
    },
    {
      "sections": [
        "Introduction to mobile monitoring",
        "How we use mobile monitoring",
        "1. Alert notification shows new version crashes",
        "2. Crash analysis pinpoints exception, location, and more",
        "3. Problem solved, focus on improving app performance",
        "Improve frontend and backend performance",
        "Get started with mobile monitoring"
      ],
      "title": "Introduction to mobile monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile",
        "Get started"
      ],
      "external_id": "4e60f9568c1ffaf583f47bebfe1cecf5bde82a5b",
      "image": "https://docs.newrelic.com/static/3a1763e0e671b37ba517401ae6c5fb62/8c557/mobile-nrOne-summary072820.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile/get-started/introduction-mobile-monitoring/",
      "published_at": "2021-12-08T01:49:33Z",
      "updated_at": "2021-11-24T20:15:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring capabilities help you gain deeper visibility into how to analyze your Android and iOS application performance and troubleshoot crashes. You can also examine HTTP and other network performance for unexpected lag, which will in turn help you collaborate more efficiently with your backend teams. You'll be able to configure mobile monitoring to suit your environnment after you create a New Relic account (it's free, forever!) and install mobile monitoring for your Android, iOS, or Cordova environment. How we use mobile monitoring At New Relic, we have our own mobile developers who create iOS and Android apps so our customers can use New Relic from their mobile devices. During a feature deploy, we encountered a small bug that caused an edge case crash with our Android app. This happened after we had created, tested, and deployed the new feature. Because we work at New Relic, we also use New Relic One to analyze and troubleshoot our mobile apps. To give you an idea of how to explore the power of mobile monitoring, here's an example of how our own mobile engineers used it to track this small bug. A workflow to identify and resolve mobile app crashes using New Relic. 1. Alert notification shows new version crashes The night after a new release, our on-call developer received an alert notification on his mobile phone. The Alerts page indicated that some customers were seeing crashes on the new version of our Android app. Moving to his desktop browser, he checked the Summary page. The overview showed an increase in crashes for the newest version. By filtering for the latest version and setting the time picker to the past 24 hours, he could proceed with crash analysis. An example of using the mobile Summary page to filter to an Android version with crashes. 2. Crash analysis pinpoints exception, location, and more By clicking the Crashes chart title on the mobile Summary page, the Crash analysis page opened with the same 24-hour time frame and filter to this Android version. Here our developer could see a significant number of crashes for the selected version. This reinforced his suspicion there was bad code somewhere in the recent deployment. The developer clicked the link for the crash type to examine the exception, location, and error message. He also examined the stack trace, interaction trail, and event trail to quickly understand where users were impacted. An example of using the Crash analysis page to track down the cause for crashes for a new release by examining the exception, location, and error message. From here the developer saw the error. The new feature had a specific line of bad code that was crashing the app for customers who only used New Relic to monitor one app rather than multiple apps. The team released a hot fix in less than an hour, and the crash rate quickly de-escalated to 0.2%. 3. Problem solved, focus on improving app performance The problem was solved, but the team continues to use New Relic to make sure the most important workflows are running correctly and quickly. We also share HTTP and other network performance trends with our backend API developer teams. Improve frontend and backend performance More than a tool for crash analysis, our mobile monitoring capabilities can help you identify opportunities to speed app performance. For example, you can: Create dashboards to query, visualize, and share performance data. Identify handled exceptions to streamline workflows. See trends with sessions, devices, geographical locations, operating systems, carriers, requests and responses, etc. with crash profiles and HTTP profiles. Set up alert notifications for execution time, errors, etc. Define custom attributes and events to obtain additional, specific details about the mobile data that matters the most to your organization. And more! In addition to crash analysis, do more to fine-tune mobile app performance. Great mobile apps increasingly rely on backend systems to power their functionality, such as requesting product information, authenticating users, or streaming media content. But some backend issues can lead to upstream mobile app crashes, freezes, and broken functionality that impacts end users, including: Changed or non-versioned API endpoints Bad payloads API timeouts Slow or deprecated API endpoints You can use the network pages in our mobile monitoring UI to identify problems that surface through HTTP requests, errors, and other network issues. You can also query your data. Then create dashboards and share this information with backend API developer teams and others in your organization to help improve the overall end user experience with your mobile app. You can also improve your customers' overall digital experience: Get rapid visibility into how your end users experience your mobile apps and web browsers. Analyze actual or simulated end-user behavior to hone in on metrics like load time, availability, and errors, while staying grounded in the backend services that enable these digital experiences. Get started with mobile monitoring Before you install and configure New Relic's functionality for your mobile applications, follow these guidelines for compatibility and other requirements: Android compatibility and requirements iOS compatibility and requirements Then continue with the installation and configuration procedures for your Android, iOS, tvOS, or Cordova application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 383.2865,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>mobile</em> <em>monitoring</em>",
        "sections": "Introduction to <em>mobile</em> <em>monitoring</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": "New Relic&#x27;s <em>mobile</em> <em>monitoring</em> capabilities help you gain deeper visibility into how to analyze your Android and iOS application performance and troubleshoot crashes. You can also examine HTTP and other network performance for unexpected lag, which will in turn help you collaborate more efficiently"
      },
      "id": "603eb1c4e7b9d217802a07a7"
    }
  ],
  "/docs/mobile-monitoring/mobile-monitoring-ui/crashes/crash-analysis-group-filter-your-crashes": [
    {
      "sections": [
        "HTTP errors: Network failure analysis",
        "Find and use the HTTP errors page",
        "Group, sort, and filter errors and failures",
        "HTTP error profiles",
        "View more details about a specific error",
        "View and share error data with query builder",
        "View legacy HTTP errors UI page",
        "View the Errors page",
        "Error trace details",
        "View error data in query builder",
        "Unknown errors or URL errors"
      ],
      "title": "HTTP errors: Network failure analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "04631e122b061663c6fd261b605202654aadcf96",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-errors-network-failure-analysis/",
      "published_at": "2021-12-04T15:48:48Z",
      "updated_at": "2021-12-04T15:48:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring's HTTP errors page helps you to better understand HTTP errors and network failures associated with your mobile app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager See a list of errors and failures so you can coordinate mobile app teams with backend teams and share the data they need to fix issues. QA engineer Make sure that a new version of your app does not cause a spike in errors compared to a previous version. DevOps engineer See a list of domains and URLs associated with HTTP errors and network failures, so you can focus on the ones that are causing errors and filter out status codes that are too noisy for your alerts. Mobile developer Find out if there are frontend or backend problems affecting your mobile app (even without an error alert going off) so that you can address them in a new version. Support engineer View the errors and session attributes (geography, connection type, device, app version) associated with an error so that you can help customers with their issues. Find and use the HTTP errors page There are two ways to get to the HTTP errors page: Go to one.newrelic.com > Mobile > (select an app) > Network > Network errors. From a mobile app's Overview page in mobile monitoring, select the HTTP errors/network failures chart title link. From the HTTP errors page, investigate HTTP request and network failures: Use any standard page functions to look for trends in Errors and failures charts. Target specific types of errors and failures by grouping, sorting, and filtering the data. Find anomalies in your request errors with HTTP error profiles. Select an error or failure to view details for it. You can also define NRQL alerts that are focused on error types for your critical services or query your app data. Group, sort, and filter errors and failures If you want to do this... Do this... Change how the page groups and sorts errors and network failures Make selections from the Group by and Sort by dropdowns. By default, the Network errors page is grouped by request domain and sorted by errors and failures. Filter for specific errors and network failures Select an error or failure from the Errors and failures list and/or select multiple filters from the Filter dropdown. See which filters you applied or remove filters The filters you select display next to the filter dropdown. To clear filters, select the X next to the filter you want to clear. Change the time window Select a new time period from the Time picker dropdown. View information for one specific app version Select the version that you want to see charts and lists for in the Versions dropdown. HTTP error profiles Error profiles provide visual details about significant differences in the frequency of different values for HTTP error events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of other errors This helps you take more of the guesswork out of resolving your mobile application's HTTP errors. You can more easily determine if you safely ignore the error, or if you should attempt to resolve the error with a new deployment, code change, customer communication or other actions. View more details about a specific error To view details about an error or failure, select the Request URL link to be directed to the Error summary page. From the Error summary page, you can view the version information, request attributes, and Response body, as well as get a breakdown of error types for the request URL. View and share error data with query builder To explore the data behind any of the charts or lists on the HTTP errors/requests page: Select for any chart. Select View query and then View in Insights. This will open the query builder. From the query builder, you can add the error data to a dashboard and share it via a permalink. To dig deeper into the error data, query your data for the following events and attributes: MobileRequestError events and attributes MobileRequest events and attributes View legacy HTTP errors UI page Accounts that do not have an Enterprise-level subscription see a different HTTP Errors UI page: The Errors page includes details about HTTP errors (403, 404, 422, 500, 502, etc.) and network failures for your hosts; for example: Secure connection failed Timed out Cannot find host Not connected to Internet Cannot connect to host View the Errors page To view HTTP errors or network failures for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Network > Errors. To change the view to errors or failures, select the Sort by option. To hide low-usage hosts, select the Hide < 1% throughput option. To limit information to a specific version of your app, or to change the time period, select your choice from the Versions menu or the time picker below the menu bar. To view details for a specific host, HTTP status error, or network failure, select its name. Use any of our standard user interface functions to drill down into detailed information. Error trace details Mobile monitoring will capture the response details from HTTP requests that return a 400 or 500 level status code. In addition, error messages generated from Android apps will include a stack trace. To view details about an error trace on the Errors page, select its request URL link. From here you can: View the response body. Share the error details with others by email. Delete or hide the error. The errors chart also appears on the selected mobile app's Overview page. If the chart shows errors, you can select its HTTP errors/network failures title or select anywhere on the Overview page's chart to go directly to this Errors page. View error data in query builder To dig deeper into your request data, use the query builder to query and chart the MobileRequest events and attributes. Unknown errors or URL errors The mobile agents maintain a list of exception types. In some cases, custom exceptions thrown by applications fall outside of this list. When this happens, Unknown may appear in the mobile Errors page. If you find Unknown in your list of errors and need assistance in researching which exception types are being missed, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.4689,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View legacy HTTP errors <em>UI</em> page",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em>&#x27;s HTTP errors page helps you to better understand HTTP errors and network failures associated with your <em>mobile</em> app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager"
      },
      "id": "603e8eb428ccbcd174eba791"
    },
    {
      "sections": [
        "Find Build UUIDs for unsymbolicated crashes",
        "View the Build UUID",
        "Binary images example",
        "Find and resymbolicate the dSYM"
      ],
      "title": "Find Build UUIDs for unsymbolicated crashes",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Crashes"
      ],
      "external_id": "e8b926653583d66810c0f68eb6b0111ab3bfc477",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/crashes/find-build-uuids-unsymbolicated-crashes/",
      "published_at": "2021-12-04T18:00:46Z",
      "updated_at": "2021-10-30T20:52:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If the dSYM is not uploaded to New Relic, mobile crash reports cannot be symbolicated. You can upload dSYMs manually or directly through the New Relic UI. However, every build of an application will create a new dSYM, and it can be difficult managing which dSYM is attributed to which app build. In this situation, you can use the Build UUID identifier to: Identify a unique build of an application. Find which dSYM can be used to symbolicate a crash. View the Build UUID An application may have more than one Build UUID, one attributed for each CPU architecture the application is built. The Build UUID is also stored within the associated dSYM and can be extracted to identify the dSYM. New Relic crash reports also contain the Build UUID of the crashing application. To view the Build UUID: Go to one.newrelic.com and click Mobile in the top nav. Then find your app and click Crashes > Crash Analysis. From the Crash list table, select any row. From the selected crash report's Crash Details page, look for the App Image Uuid on the attribute list. If the App Image Uuid is not on the selected crash report's attributes list: Export the crash details. Look for the Build UUID in the Binary images section of the exported crash report. Use the Build UUID extracted from the crash details to find the missing dSYM. Binary images example Here is an example of the Binary images section from an exported crash report. This section lists the Build UUID for every dynamically-linked library included in the application, as well as the Build UUID for the main application. In this example, the main application is New Relic. Its Build UUID is 117667e7b8d230cb8a908906c64e0227. This is the identifier you can use to find the associated dSYM. Binary Images: 0xb1000 - 0x30d000 New Relic armv7 < 117667e7b8d230cb8a908906c64e0227 > /var/containers/Bundle/Application/New Relic.app/New Relic 0x22290000 - 0x22292000 libSystem.B.dylib armv7 <39d6d6f7c2ac3de8bb29c40a1b66368a> /usr/lib/libSystem.B.dylib 0x22292000 - 0x222de000 libc++.1.dylib armv7 <017dba6c16b63f9ebecb9ddd0d0a4520> /usr/lib/libc++.1.dylib 0x222de000 - 0x222f9000 libc++abi.dylib armv7 <d32373f6c2153a509f6603750d213ffb> /usr/lib/libc++abi.dylib 0x222fc000 - 0x22667000 libobjc.A.dylib armv7 <94f6d325c1843f45b3a439b86fc9de15> /usr/lib/libobjc.A.dylib 0x22667000 - 0x2266c000 libcache.dylib armv7 <8009f99fb892331dbcb61cd740ff0f43> /usr/lib/system/libcache.dylib 0x2266c000 - 0x22676000 libcommonCrypto.dylib armv7 <f6db318471d732d39918ef36bde65cb7> /usr/lib/system/libcommonCrypto.dylib 0x22676000 - 0x2267c000 libcompiler_rt.dylib armv7 <cfa3ca12d6c2383abcaf3c8541e9b86c> /usr/lib/system/libcompiler_rt.dylib 0x2267c000 - 0x22683000 libcopyfile.dylib armv7 <d2b06020c3693c7b9d179434f8115ba0> /usr/lib/system/libcopyfile.dylib 0x22683000 - 0x226d3000 libcorecrypto.dylib armv7 <181437f8d9e53277ace439de8b3fd1ad> /usr/lib/system/libcorecrypto.dylib 0x226d3000 - 0x2271d000 libdispatch.dylib armv7 <bbb4bba2176039ab95a59d7a56f6eff8> /usr/lib/system/libdispatch.dylib Copy Find and resymbolicate the dSYM To find a dSYM's Build UUID of a dSYM: use dwarfdump with the following terminal command: dwarfdump --uuid <path-to-dSYM> Copy In the following example, the New Relic dSYM returns two Build UUIDs, one each for ARMv7 and ARM64. The ARMv7 Build UUID matches the Build UUID of the missing crash example: > dwarfdump --uuid ./New\\ Relic.app.dSYM/Contents/Resources/DWARF/New\\ Relic UUID: 117667E7-B8D2-30CB-8A90-8906C64E0227 (armv7) ./New Relic.app.dSYM/Contents/Resources/DWARF/New Relic UUID: B1A8C6EE-02B9-3C55-AEE7-308521873107 (arm64) ./New Relic.app.dSYM/Contents/Resources/DWARF/New Relic Copy To symbolicate the unsymbolicated crashes, follow the instructions to manually upload the dSYM.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.59131,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Find Build UUIDs for unsymbolicated <em>crashes</em>",
        "sections": "Find Build UUIDs for unsymbolicated <em>crashes</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "If the dSYM is not uploaded to New Relic, <em>mobile</em> <em>crash</em> reports cannot be symbolicated. You can upload dSYMs manually or directly through the New Relic <em>UI</em>. However, every build of an application will create a new dSYM, and it can be difficult managing which dSYM is attributed to which app build"
      },
      "id": "603e9fbae7b9d21cef2a07dd"
    },
    {
      "sections": [
        "Introduction to mobile monitoring",
        "How we use mobile monitoring",
        "1. Alert notification shows new version crashes",
        "2. Crash analysis pinpoints exception, location, and more",
        "3. Problem solved, focus on improving app performance",
        "Improve frontend and backend performance",
        "Get started with mobile monitoring"
      ],
      "title": "Introduction to mobile monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile",
        "Get started"
      ],
      "external_id": "4e60f9568c1ffaf583f47bebfe1cecf5bde82a5b",
      "image": "https://docs.newrelic.com/static/3a1763e0e671b37ba517401ae6c5fb62/8c557/mobile-nrOne-summary072820.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile/get-started/introduction-mobile-monitoring/",
      "published_at": "2021-12-08T01:49:33Z",
      "updated_at": "2021-11-24T20:15:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring capabilities help you gain deeper visibility into how to analyze your Android and iOS application performance and troubleshoot crashes. You can also examine HTTP and other network performance for unexpected lag, which will in turn help you collaborate more efficiently with your backend teams. You'll be able to configure mobile monitoring to suit your environnment after you create a New Relic account (it's free, forever!) and install mobile monitoring for your Android, iOS, or Cordova environment. How we use mobile monitoring At New Relic, we have our own mobile developers who create iOS and Android apps so our customers can use New Relic from their mobile devices. During a feature deploy, we encountered a small bug that caused an edge case crash with our Android app. This happened after we had created, tested, and deployed the new feature. Because we work at New Relic, we also use New Relic One to analyze and troubleshoot our mobile apps. To give you an idea of how to explore the power of mobile monitoring, here's an example of how our own mobile engineers used it to track this small bug. A workflow to identify and resolve mobile app crashes using New Relic. 1. Alert notification shows new version crashes The night after a new release, our on-call developer received an alert notification on his mobile phone. The Alerts page indicated that some customers were seeing crashes on the new version of our Android app. Moving to his desktop browser, he checked the Summary page. The overview showed an increase in crashes for the newest version. By filtering for the latest version and setting the time picker to the past 24 hours, he could proceed with crash analysis. An example of using the mobile Summary page to filter to an Android version with crashes. 2. Crash analysis pinpoints exception, location, and more By clicking the Crashes chart title on the mobile Summary page, the Crash analysis page opened with the same 24-hour time frame and filter to this Android version. Here our developer could see a significant number of crashes for the selected version. This reinforced his suspicion there was bad code somewhere in the recent deployment. The developer clicked the link for the crash type to examine the exception, location, and error message. He also examined the stack trace, interaction trail, and event trail to quickly understand where users were impacted. An example of using the Crash analysis page to track down the cause for crashes for a new release by examining the exception, location, and error message. From here the developer saw the error. The new feature had a specific line of bad code that was crashing the app for customers who only used New Relic to monitor one app rather than multiple apps. The team released a hot fix in less than an hour, and the crash rate quickly de-escalated to 0.2%. 3. Problem solved, focus on improving app performance The problem was solved, but the team continues to use New Relic to make sure the most important workflows are running correctly and quickly. We also share HTTP and other network performance trends with our backend API developer teams. Improve frontend and backend performance More than a tool for crash analysis, our mobile monitoring capabilities can help you identify opportunities to speed app performance. For example, you can: Create dashboards to query, visualize, and share performance data. Identify handled exceptions to streamline workflows. See trends with sessions, devices, geographical locations, operating systems, carriers, requests and responses, etc. with crash profiles and HTTP profiles. Set up alert notifications for execution time, errors, etc. Define custom attributes and events to obtain additional, specific details about the mobile data that matters the most to your organization. And more! In addition to crash analysis, do more to fine-tune mobile app performance. Great mobile apps increasingly rely on backend systems to power their functionality, such as requesting product information, authenticating users, or streaming media content. But some backend issues can lead to upstream mobile app crashes, freezes, and broken functionality that impacts end users, including: Changed or non-versioned API endpoints Bad payloads API timeouts Slow or deprecated API endpoints You can use the network pages in our mobile monitoring UI to identify problems that surface through HTTP requests, errors, and other network issues. You can also query your data. Then create dashboards and share this information with backend API developer teams and others in your organization to help improve the overall end user experience with your mobile app. You can also improve your customers' overall digital experience: Get rapid visibility into how your end users experience your mobile apps and web browsers. Analyze actual or simulated end-user behavior to hone in on metrics like load time, availability, and errors, while staying grounded in the backend services that enable these digital experiences. Get started with mobile monitoring Before you install and configure New Relic's functionality for your mobile applications, follow these guidelines for compatibility and other requirements: Android compatibility and requirements iOS compatibility and requirements Then continue with the installation and configuration procedures for your Android, iOS, tvOS, or Cordova application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 162.72777,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>mobile</em> <em>monitoring</em>",
        "sections": "Introduction to <em>mobile</em> <em>monitoring</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": "New Relic&#x27;s <em>mobile</em> <em>monitoring</em> capabilities help you gain deeper visibility into how to analyze your Android and iOS application performance and troubleshoot <em>crashes</em>. You can also examine HTTP and other network performance for unexpected lag, which will in turn help you collaborate more efficiently"
      },
      "id": "603eb1c4e7b9d217802a07a7"
    }
  ],
  "/docs/mobile-monitoring/mobile-monitoring-ui/crashes/find-build-uuids-unsymbolicated-crashes": [
    {
      "sections": [
        "HTTP errors: Network failure analysis",
        "Find and use the HTTP errors page",
        "Group, sort, and filter errors and failures",
        "HTTP error profiles",
        "View more details about a specific error",
        "View and share error data with query builder",
        "View legacy HTTP errors UI page",
        "View the Errors page",
        "Error trace details",
        "View error data in query builder",
        "Unknown errors or URL errors"
      ],
      "title": "HTTP errors: Network failure analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "04631e122b061663c6fd261b605202654aadcf96",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-errors-network-failure-analysis/",
      "published_at": "2021-12-04T15:48:48Z",
      "updated_at": "2021-12-04T15:48:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring's HTTP errors page helps you to better understand HTTP errors and network failures associated with your mobile app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager See a list of errors and failures so you can coordinate mobile app teams with backend teams and share the data they need to fix issues. QA engineer Make sure that a new version of your app does not cause a spike in errors compared to a previous version. DevOps engineer See a list of domains and URLs associated with HTTP errors and network failures, so you can focus on the ones that are causing errors and filter out status codes that are too noisy for your alerts. Mobile developer Find out if there are frontend or backend problems affecting your mobile app (even without an error alert going off) so that you can address them in a new version. Support engineer View the errors and session attributes (geography, connection type, device, app version) associated with an error so that you can help customers with their issues. Find and use the HTTP errors page There are two ways to get to the HTTP errors page: Go to one.newrelic.com > Mobile > (select an app) > Network > Network errors. From a mobile app's Overview page in mobile monitoring, select the HTTP errors/network failures chart title link. From the HTTP errors page, investigate HTTP request and network failures: Use any standard page functions to look for trends in Errors and failures charts. Target specific types of errors and failures by grouping, sorting, and filtering the data. Find anomalies in your request errors with HTTP error profiles. Select an error or failure to view details for it. You can also define NRQL alerts that are focused on error types for your critical services or query your app data. Group, sort, and filter errors and failures If you want to do this... Do this... Change how the page groups and sorts errors and network failures Make selections from the Group by and Sort by dropdowns. By default, the Network errors page is grouped by request domain and sorted by errors and failures. Filter for specific errors and network failures Select an error or failure from the Errors and failures list and/or select multiple filters from the Filter dropdown. See which filters you applied or remove filters The filters you select display next to the filter dropdown. To clear filters, select the X next to the filter you want to clear. Change the time window Select a new time period from the Time picker dropdown. View information for one specific app version Select the version that you want to see charts and lists for in the Versions dropdown. HTTP error profiles Error profiles provide visual details about significant differences in the frequency of different values for HTTP error events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of other errors This helps you take more of the guesswork out of resolving your mobile application's HTTP errors. You can more easily determine if you safely ignore the error, or if you should attempt to resolve the error with a new deployment, code change, customer communication or other actions. View more details about a specific error To view details about an error or failure, select the Request URL link to be directed to the Error summary page. From the Error summary page, you can view the version information, request attributes, and Response body, as well as get a breakdown of error types for the request URL. View and share error data with query builder To explore the data behind any of the charts or lists on the HTTP errors/requests page: Select for any chart. Select View query and then View in Insights. This will open the query builder. From the query builder, you can add the error data to a dashboard and share it via a permalink. To dig deeper into the error data, query your data for the following events and attributes: MobileRequestError events and attributes MobileRequest events and attributes View legacy HTTP errors UI page Accounts that do not have an Enterprise-level subscription see a different HTTP Errors UI page: The Errors page includes details about HTTP errors (403, 404, 422, 500, 502, etc.) and network failures for your hosts; for example: Secure connection failed Timed out Cannot find host Not connected to Internet Cannot connect to host View the Errors page To view HTTP errors or network failures for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Network > Errors. To change the view to errors or failures, select the Sort by option. To hide low-usage hosts, select the Hide < 1% throughput option. To limit information to a specific version of your app, or to change the time period, select your choice from the Versions menu or the time picker below the menu bar. To view details for a specific host, HTTP status error, or network failure, select its name. Use any of our standard user interface functions to drill down into detailed information. Error trace details Mobile monitoring will capture the response details from HTTP requests that return a 400 or 500 level status code. In addition, error messages generated from Android apps will include a stack trace. To view details about an error trace on the Errors page, select its request URL link. From here you can: View the response body. Share the error details with others by email. Delete or hide the error. The errors chart also appears on the selected mobile app's Overview page. If the chart shows errors, you can select its HTTP errors/network failures title or select anywhere on the Overview page's chart to go directly to this Errors page. View error data in query builder To dig deeper into your request data, use the query builder to query and chart the MobileRequest events and attributes. Unknown errors or URL errors The mobile agents maintain a list of exception types. In some cases, custom exceptions thrown by applications fall outside of this list. When this happens, Unknown may appear in the mobile Errors page. If you find Unknown in your list of errors and need assistance in researching which exception types are being missed, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.4689,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View legacy HTTP errors <em>UI</em> page",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em>&#x27;s HTTP errors page helps you to better understand HTTP errors and network failures associated with your <em>mobile</em> app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager"
      },
      "id": "603e8eb428ccbcd174eba791"
    },
    {
      "sections": [
        "Introduction to mobile monitoring",
        "How we use mobile monitoring",
        "1. Alert notification shows new version crashes",
        "2. Crash analysis pinpoints exception, location, and more",
        "3. Problem solved, focus on improving app performance",
        "Improve frontend and backend performance",
        "Get started with mobile monitoring"
      ],
      "title": "Introduction to mobile monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile",
        "Get started"
      ],
      "external_id": "4e60f9568c1ffaf583f47bebfe1cecf5bde82a5b",
      "image": "https://docs.newrelic.com/static/3a1763e0e671b37ba517401ae6c5fb62/8c557/mobile-nrOne-summary072820.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile/get-started/introduction-mobile-monitoring/",
      "published_at": "2021-12-08T01:49:33Z",
      "updated_at": "2021-11-24T20:15:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring capabilities help you gain deeper visibility into how to analyze your Android and iOS application performance and troubleshoot crashes. You can also examine HTTP and other network performance for unexpected lag, which will in turn help you collaborate more efficiently with your backend teams. You'll be able to configure mobile monitoring to suit your environnment after you create a New Relic account (it's free, forever!) and install mobile monitoring for your Android, iOS, or Cordova environment. How we use mobile monitoring At New Relic, we have our own mobile developers who create iOS and Android apps so our customers can use New Relic from their mobile devices. During a feature deploy, we encountered a small bug that caused an edge case crash with our Android app. This happened after we had created, tested, and deployed the new feature. Because we work at New Relic, we also use New Relic One to analyze and troubleshoot our mobile apps. To give you an idea of how to explore the power of mobile monitoring, here's an example of how our own mobile engineers used it to track this small bug. A workflow to identify and resolve mobile app crashes using New Relic. 1. Alert notification shows new version crashes The night after a new release, our on-call developer received an alert notification on his mobile phone. The Alerts page indicated that some customers were seeing crashes on the new version of our Android app. Moving to his desktop browser, he checked the Summary page. The overview showed an increase in crashes for the newest version. By filtering for the latest version and setting the time picker to the past 24 hours, he could proceed with crash analysis. An example of using the mobile Summary page to filter to an Android version with crashes. 2. Crash analysis pinpoints exception, location, and more By clicking the Crashes chart title on the mobile Summary page, the Crash analysis page opened with the same 24-hour time frame and filter to this Android version. Here our developer could see a significant number of crashes for the selected version. This reinforced his suspicion there was bad code somewhere in the recent deployment. The developer clicked the link for the crash type to examine the exception, location, and error message. He also examined the stack trace, interaction trail, and event trail to quickly understand where users were impacted. An example of using the Crash analysis page to track down the cause for crashes for a new release by examining the exception, location, and error message. From here the developer saw the error. The new feature had a specific line of bad code that was crashing the app for customers who only used New Relic to monitor one app rather than multiple apps. The team released a hot fix in less than an hour, and the crash rate quickly de-escalated to 0.2%. 3. Problem solved, focus on improving app performance The problem was solved, but the team continues to use New Relic to make sure the most important workflows are running correctly and quickly. We also share HTTP and other network performance trends with our backend API developer teams. Improve frontend and backend performance More than a tool for crash analysis, our mobile monitoring capabilities can help you identify opportunities to speed app performance. For example, you can: Create dashboards to query, visualize, and share performance data. Identify handled exceptions to streamline workflows. See trends with sessions, devices, geographical locations, operating systems, carriers, requests and responses, etc. with crash profiles and HTTP profiles. Set up alert notifications for execution time, errors, etc. Define custom attributes and events to obtain additional, specific details about the mobile data that matters the most to your organization. And more! In addition to crash analysis, do more to fine-tune mobile app performance. Great mobile apps increasingly rely on backend systems to power their functionality, such as requesting product information, authenticating users, or streaming media content. But some backend issues can lead to upstream mobile app crashes, freezes, and broken functionality that impacts end users, including: Changed or non-versioned API endpoints Bad payloads API timeouts Slow or deprecated API endpoints You can use the network pages in our mobile monitoring UI to identify problems that surface through HTTP requests, errors, and other network issues. You can also query your data. Then create dashboards and share this information with backend API developer teams and others in your organization to help improve the overall end user experience with your mobile app. You can also improve your customers' overall digital experience: Get rapid visibility into how your end users experience your mobile apps and web browsers. Analyze actual or simulated end-user behavior to hone in on metrics like load time, availability, and errors, while staying grounded in the backend services that enable these digital experiences. Get started with mobile monitoring Before you install and configure New Relic's functionality for your mobile applications, follow these guidelines for compatibility and other requirements: Android compatibility and requirements iOS compatibility and requirements Then continue with the installation and configuration procedures for your Android, iOS, tvOS, or Cordova application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 162.72777,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>mobile</em> <em>monitoring</em>",
        "sections": "Introduction to <em>mobile</em> <em>monitoring</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": "New Relic&#x27;s <em>mobile</em> <em>monitoring</em> capabilities help you gain deeper visibility into how to analyze your Android and iOS application performance and troubleshoot <em>crashes</em>. You can also examine HTTP and other network performance for unexpected lag, which will in turn help you collaborate more efficiently"
      },
      "id": "603eb1c4e7b9d217802a07a7"
    },
    {
      "sections": [
        "Mobile crash event trail",
        "Tip",
        "View events before mobile app crashes",
        "Use the event trail",
        "Difference between event trail and interaction trail"
      ],
      "title": "Mobile crash event trail",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Crashes"
      ],
      "external_id": "58795d499c8db6d8cc95bd6d2c645e970ea10d83",
      "image": "https://docs.newrelic.com/static/3731efca2d88ed92cc150d5f6c06830a/0d6fe/New-Relic-Mobile-crash-event-trail.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/crashes/mobile-crash-event-trail/",
      "published_at": "2021-12-04T18:02:07Z",
      "updated_at": "2021-07-22T01:05:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The mobile monitoring crash event trail shows you the events leading up to a crash of a mobile app, based on your subscription level's data retention policy. These can be events New Relic monitors by default, or custom events. This document explains what the crash event trail is and how to use it. Tip Access to this feature depends on your subscription level. View events before mobile app crashes When a mobile app crashes and you don't know why, you can study what happened right before the crash. The crash event trail shows you these events so that you can follow the \"breadcrumbs\" leading up to the crash and diagnose the cause of the failure. one.newrelic.com > Mobile > (select a mobile app) > Crash analysis > (selected crash type) > Event trail: The crash event trail shows the activity leading up to a mobile app crash. The crash event trail shows all mobile event types leading up to a crash. You can use the iOS SDK or Android SDK to create custom MobileBreadcrumb events that track whatever app activity you think would help you diagnose a crash. You can also use MobileHandledException events in the crash event trail to aid in debugging. Use the iOS and Android recordHandledException APIs for iOS or Android to annotate where exceptions are handled in your application. These events will automatically appear in the crash event trail. For more about annotating crash event trails with custom data, see Add custom data to mobile monitoring. Use the event trail To use the crash event trail: Go to one.newrelic.com > Mobile > (select a mobile app) > Crash analysis. On the lower right side of the Crash analysis page, select a crash type. On the Crash details page, beside the stack trace, select Event trail. Study the events leading up to a crash type for clues to the reasons for the crash. To expand details about an event's attributes, select it. To view the event trail results in New Relic, select Open session in Insights. To scroll through occurrences of the same crash type, use the event trail's left and right arrows. To make the most out of our crash analysis tools, use: The Android SDK API or iOS SDK API to create custom MobileBreadcrumb or MobileHandledException events Enable MobileRequest events Crash analysis page Interaction trail Difference between event trail and interaction trail The crash event trail is different from the interaction trail. The crash event trail shows all mobile event types leading up to a crash, whereas the interaction trail only shows interaction event types (Mobile events with the category interaction). The interaction trail has additional features, including stack traces and links to the associated interaction charts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.42378,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Mobile</em> <em>crash</em> event trail",
        "sections": "View events before <em>mobile</em> app <em>crashes</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "The <em>mobile</em> <em>monitoring</em> <em>crash</em> event trail shows you the events leading up to a <em>crash</em> of a <em>mobile</em> app, based on your subscription level&#x27;s data retention policy. These can be events New Relic monitors by default, or custom events. This document explains what the <em>crash</em> event trail is and how to use"
      },
      "id": "604503b1e7b9d201e75799bb"
    }
  ],
  "/docs/mobile-monitoring/mobile-monitoring-ui/crashes/handled-exceptions-analyze-trends-prevent-crashes": [
    {
      "sections": [
        "HTTP errors: Network failure analysis",
        "Find and use the HTTP errors page",
        "Group, sort, and filter errors and failures",
        "HTTP error profiles",
        "View more details about a specific error",
        "View and share error data with query builder",
        "View legacy HTTP errors UI page",
        "View the Errors page",
        "Error trace details",
        "View error data in query builder",
        "Unknown errors or URL errors"
      ],
      "title": "HTTP errors: Network failure analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "04631e122b061663c6fd261b605202654aadcf96",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-errors-network-failure-analysis/",
      "published_at": "2021-12-04T15:48:48Z",
      "updated_at": "2021-12-04T15:48:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring's HTTP errors page helps you to better understand HTTP errors and network failures associated with your mobile app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager See a list of errors and failures so you can coordinate mobile app teams with backend teams and share the data they need to fix issues. QA engineer Make sure that a new version of your app does not cause a spike in errors compared to a previous version. DevOps engineer See a list of domains and URLs associated with HTTP errors and network failures, so you can focus on the ones that are causing errors and filter out status codes that are too noisy for your alerts. Mobile developer Find out if there are frontend or backend problems affecting your mobile app (even without an error alert going off) so that you can address them in a new version. Support engineer View the errors and session attributes (geography, connection type, device, app version) associated with an error so that you can help customers with their issues. Find and use the HTTP errors page There are two ways to get to the HTTP errors page: Go to one.newrelic.com > Mobile > (select an app) > Network > Network errors. From a mobile app's Overview page in mobile monitoring, select the HTTP errors/network failures chart title link. From the HTTP errors page, investigate HTTP request and network failures: Use any standard page functions to look for trends in Errors and failures charts. Target specific types of errors and failures by grouping, sorting, and filtering the data. Find anomalies in your request errors with HTTP error profiles. Select an error or failure to view details for it. You can also define NRQL alerts that are focused on error types for your critical services or query your app data. Group, sort, and filter errors and failures If you want to do this... Do this... Change how the page groups and sorts errors and network failures Make selections from the Group by and Sort by dropdowns. By default, the Network errors page is grouped by request domain and sorted by errors and failures. Filter for specific errors and network failures Select an error or failure from the Errors and failures list and/or select multiple filters from the Filter dropdown. See which filters you applied or remove filters The filters you select display next to the filter dropdown. To clear filters, select the X next to the filter you want to clear. Change the time window Select a new time period from the Time picker dropdown. View information for one specific app version Select the version that you want to see charts and lists for in the Versions dropdown. HTTP error profiles Error profiles provide visual details about significant differences in the frequency of different values for HTTP error events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of other errors This helps you take more of the guesswork out of resolving your mobile application's HTTP errors. You can more easily determine if you safely ignore the error, or if you should attempt to resolve the error with a new deployment, code change, customer communication or other actions. View more details about a specific error To view details about an error or failure, select the Request URL link to be directed to the Error summary page. From the Error summary page, you can view the version information, request attributes, and Response body, as well as get a breakdown of error types for the request URL. View and share error data with query builder To explore the data behind any of the charts or lists on the HTTP errors/requests page: Select for any chart. Select View query and then View in Insights. This will open the query builder. From the query builder, you can add the error data to a dashboard and share it via a permalink. To dig deeper into the error data, query your data for the following events and attributes: MobileRequestError events and attributes MobileRequest events and attributes View legacy HTTP errors UI page Accounts that do not have an Enterprise-level subscription see a different HTTP Errors UI page: The Errors page includes details about HTTP errors (403, 404, 422, 500, 502, etc.) and network failures for your hosts; for example: Secure connection failed Timed out Cannot find host Not connected to Internet Cannot connect to host View the Errors page To view HTTP errors or network failures for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Network > Errors. To change the view to errors or failures, select the Sort by option. To hide low-usage hosts, select the Hide < 1% throughput option. To limit information to a specific version of your app, or to change the time period, select your choice from the Versions menu or the time picker below the menu bar. To view details for a specific host, HTTP status error, or network failure, select its name. Use any of our standard user interface functions to drill down into detailed information. Error trace details Mobile monitoring will capture the response details from HTTP requests that return a 400 or 500 level status code. In addition, error messages generated from Android apps will include a stack trace. To view details about an error trace on the Errors page, select its request URL link. From here you can: View the response body. Share the error details with others by email. Delete or hide the error. The errors chart also appears on the selected mobile app's Overview page. If the chart shows errors, you can select its HTTP errors/network failures title or select anywhere on the Overview page's chart to go directly to this Errors page. View error data in query builder To dig deeper into your request data, use the query builder to query and chart the MobileRequest events and attributes. Unknown errors or URL errors The mobile agents maintain a list of exception types. In some cases, custom exceptions thrown by applications fall outside of this list. When this happens, Unknown may appear in the mobile Errors page. If you find Unknown in your list of errors and need assistance in researching which exception types are being missed, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.46881,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View legacy HTTP errors <em>UI</em> page",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em>&#x27;s HTTP errors page helps you to better understand HTTP errors and network failures associated with your <em>mobile</em> app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager"
      },
      "id": "603e8eb428ccbcd174eba791"
    },
    {
      "sections": [
        "Find Build UUIDs for unsymbolicated crashes",
        "View the Build UUID",
        "Binary images example",
        "Find and resymbolicate the dSYM"
      ],
      "title": "Find Build UUIDs for unsymbolicated crashes",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Crashes"
      ],
      "external_id": "e8b926653583d66810c0f68eb6b0111ab3bfc477",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/crashes/find-build-uuids-unsymbolicated-crashes/",
      "published_at": "2021-12-04T18:00:46Z",
      "updated_at": "2021-10-30T20:52:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If the dSYM is not uploaded to New Relic, mobile crash reports cannot be symbolicated. You can upload dSYMs manually or directly through the New Relic UI. However, every build of an application will create a new dSYM, and it can be difficult managing which dSYM is attributed to which app build. In this situation, you can use the Build UUID identifier to: Identify a unique build of an application. Find which dSYM can be used to symbolicate a crash. View the Build UUID An application may have more than one Build UUID, one attributed for each CPU architecture the application is built. The Build UUID is also stored within the associated dSYM and can be extracted to identify the dSYM. New Relic crash reports also contain the Build UUID of the crashing application. To view the Build UUID: Go to one.newrelic.com and click Mobile in the top nav. Then find your app and click Crashes > Crash Analysis. From the Crash list table, select any row. From the selected crash report's Crash Details page, look for the App Image Uuid on the attribute list. If the App Image Uuid is not on the selected crash report's attributes list: Export the crash details. Look for the Build UUID in the Binary images section of the exported crash report. Use the Build UUID extracted from the crash details to find the missing dSYM. Binary images example Here is an example of the Binary images section from an exported crash report. This section lists the Build UUID for every dynamically-linked library included in the application, as well as the Build UUID for the main application. In this example, the main application is New Relic. Its Build UUID is 117667e7b8d230cb8a908906c64e0227. This is the identifier you can use to find the associated dSYM. Binary Images: 0xb1000 - 0x30d000 New Relic armv7 < 117667e7b8d230cb8a908906c64e0227 > /var/containers/Bundle/Application/New Relic.app/New Relic 0x22290000 - 0x22292000 libSystem.B.dylib armv7 <39d6d6f7c2ac3de8bb29c40a1b66368a> /usr/lib/libSystem.B.dylib 0x22292000 - 0x222de000 libc++.1.dylib armv7 <017dba6c16b63f9ebecb9ddd0d0a4520> /usr/lib/libc++.1.dylib 0x222de000 - 0x222f9000 libc++abi.dylib armv7 <d32373f6c2153a509f6603750d213ffb> /usr/lib/libc++abi.dylib 0x222fc000 - 0x22667000 libobjc.A.dylib armv7 <94f6d325c1843f45b3a439b86fc9de15> /usr/lib/libobjc.A.dylib 0x22667000 - 0x2266c000 libcache.dylib armv7 <8009f99fb892331dbcb61cd740ff0f43> /usr/lib/system/libcache.dylib 0x2266c000 - 0x22676000 libcommonCrypto.dylib armv7 <f6db318471d732d39918ef36bde65cb7> /usr/lib/system/libcommonCrypto.dylib 0x22676000 - 0x2267c000 libcompiler_rt.dylib armv7 <cfa3ca12d6c2383abcaf3c8541e9b86c> /usr/lib/system/libcompiler_rt.dylib 0x2267c000 - 0x22683000 libcopyfile.dylib armv7 <d2b06020c3693c7b9d179434f8115ba0> /usr/lib/system/libcopyfile.dylib 0x22683000 - 0x226d3000 libcorecrypto.dylib armv7 <181437f8d9e53277ace439de8b3fd1ad> /usr/lib/system/libcorecrypto.dylib 0x226d3000 - 0x2271d000 libdispatch.dylib armv7 <bbb4bba2176039ab95a59d7a56f6eff8> /usr/lib/system/libdispatch.dylib Copy Find and resymbolicate the dSYM To find a dSYM's Build UUID of a dSYM: use dwarfdump with the following terminal command: dwarfdump --uuid <path-to-dSYM> Copy In the following example, the New Relic dSYM returns two Build UUIDs, one each for ARMv7 and ARM64. The ARMv7 Build UUID matches the Build UUID of the missing crash example: > dwarfdump --uuid ./New\\ Relic.app.dSYM/Contents/Resources/DWARF/New\\ Relic UUID: 117667E7-B8D2-30CB-8A90-8906C64E0227 (armv7) ./New Relic.app.dSYM/Contents/Resources/DWARF/New Relic UUID: B1A8C6EE-02B9-3C55-AEE7-308521873107 (arm64) ./New Relic.app.dSYM/Contents/Resources/DWARF/New Relic Copy To symbolicate the unsymbolicated crashes, follow the instructions to manually upload the dSYM.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.59131,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Find Build UUIDs for unsymbolicated <em>crashes</em>",
        "sections": "Find Build UUIDs for unsymbolicated <em>crashes</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "If the dSYM is not uploaded to New Relic, <em>mobile</em> <em>crash</em> reports cannot be symbolicated. You can upload dSYMs manually or directly through the New Relic <em>UI</em>. However, every build of an application will create a new dSYM, and it can be difficult managing which dSYM is attributed to which app build"
      },
      "id": "603e9fbae7b9d21cef2a07dd"
    },
    {
      "sections": [
        "Introduction to mobile monitoring",
        "How we use mobile monitoring",
        "1. Alert notification shows new version crashes",
        "2. Crash analysis pinpoints exception, location, and more",
        "3. Problem solved, focus on improving app performance",
        "Improve frontend and backend performance",
        "Get started with mobile monitoring"
      ],
      "title": "Introduction to mobile monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile",
        "Get started"
      ],
      "external_id": "4e60f9568c1ffaf583f47bebfe1cecf5bde82a5b",
      "image": "https://docs.newrelic.com/static/3a1763e0e671b37ba517401ae6c5fb62/8c557/mobile-nrOne-summary072820.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile/get-started/introduction-mobile-monitoring/",
      "published_at": "2021-12-08T01:49:33Z",
      "updated_at": "2021-11-24T20:15:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring capabilities help you gain deeper visibility into how to analyze your Android and iOS application performance and troubleshoot crashes. You can also examine HTTP and other network performance for unexpected lag, which will in turn help you collaborate more efficiently with your backend teams. You'll be able to configure mobile monitoring to suit your environnment after you create a New Relic account (it's free, forever!) and install mobile monitoring for your Android, iOS, or Cordova environment. How we use mobile monitoring At New Relic, we have our own mobile developers who create iOS and Android apps so our customers can use New Relic from their mobile devices. During a feature deploy, we encountered a small bug that caused an edge case crash with our Android app. This happened after we had created, tested, and deployed the new feature. Because we work at New Relic, we also use New Relic One to analyze and troubleshoot our mobile apps. To give you an idea of how to explore the power of mobile monitoring, here's an example of how our own mobile engineers used it to track this small bug. A workflow to identify and resolve mobile app crashes using New Relic. 1. Alert notification shows new version crashes The night after a new release, our on-call developer received an alert notification on his mobile phone. The Alerts page indicated that some customers were seeing crashes on the new version of our Android app. Moving to his desktop browser, he checked the Summary page. The overview showed an increase in crashes for the newest version. By filtering for the latest version and setting the time picker to the past 24 hours, he could proceed with crash analysis. An example of using the mobile Summary page to filter to an Android version with crashes. 2. Crash analysis pinpoints exception, location, and more By clicking the Crashes chart title on the mobile Summary page, the Crash analysis page opened with the same 24-hour time frame and filter to this Android version. Here our developer could see a significant number of crashes for the selected version. This reinforced his suspicion there was bad code somewhere in the recent deployment. The developer clicked the link for the crash type to examine the exception, location, and error message. He also examined the stack trace, interaction trail, and event trail to quickly understand where users were impacted. An example of using the Crash analysis page to track down the cause for crashes for a new release by examining the exception, location, and error message. From here the developer saw the error. The new feature had a specific line of bad code that was crashing the app for customers who only used New Relic to monitor one app rather than multiple apps. The team released a hot fix in less than an hour, and the crash rate quickly de-escalated to 0.2%. 3. Problem solved, focus on improving app performance The problem was solved, but the team continues to use New Relic to make sure the most important workflows are running correctly and quickly. We also share HTTP and other network performance trends with our backend API developer teams. Improve frontend and backend performance More than a tool for crash analysis, our mobile monitoring capabilities can help you identify opportunities to speed app performance. For example, you can: Create dashboards to query, visualize, and share performance data. Identify handled exceptions to streamline workflows. See trends with sessions, devices, geographical locations, operating systems, carriers, requests and responses, etc. with crash profiles and HTTP profiles. Set up alert notifications for execution time, errors, etc. Define custom attributes and events to obtain additional, specific details about the mobile data that matters the most to your organization. And more! In addition to crash analysis, do more to fine-tune mobile app performance. Great mobile apps increasingly rely on backend systems to power their functionality, such as requesting product information, authenticating users, or streaming media content. But some backend issues can lead to upstream mobile app crashes, freezes, and broken functionality that impacts end users, including: Changed or non-versioned API endpoints Bad payloads API timeouts Slow or deprecated API endpoints You can use the network pages in our mobile monitoring UI to identify problems that surface through HTTP requests, errors, and other network issues. You can also query your data. Then create dashboards and share this information with backend API developer teams and others in your organization to help improve the overall end user experience with your mobile app. You can also improve your customers' overall digital experience: Get rapid visibility into how your end users experience your mobile apps and web browsers. Analyze actual or simulated end-user behavior to hone in on metrics like load time, availability, and errors, while staying grounded in the backend services that enable these digital experiences. Get started with mobile monitoring Before you install and configure New Relic's functionality for your mobile applications, follow these guidelines for compatibility and other requirements: Android compatibility and requirements iOS compatibility and requirements Then continue with the installation and configuration procedures for your Android, iOS, tvOS, or Cordova application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 162.72774,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>mobile</em> <em>monitoring</em>",
        "sections": "Introduction to <em>mobile</em> <em>monitoring</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": "New Relic&#x27;s <em>mobile</em> <em>monitoring</em> capabilities help you gain deeper visibility into how to analyze your Android and iOS application performance and troubleshoot <em>crashes</em>. You can also examine HTTP and other network performance for unexpected lag, which will in turn help you collaborate more efficiently"
      },
      "id": "603eb1c4e7b9d217802a07a7"
    }
  ],
  "/docs/mobile-monitoring/mobile-monitoring-ui/crashes/handled-exceptions-occurrences": [
    {
      "sections": [
        "HTTP errors: Network failure analysis",
        "Find and use the HTTP errors page",
        "Group, sort, and filter errors and failures",
        "HTTP error profiles",
        "View more details about a specific error",
        "View and share error data with query builder",
        "View legacy HTTP errors UI page",
        "View the Errors page",
        "Error trace details",
        "View error data in query builder",
        "Unknown errors or URL errors"
      ],
      "title": "HTTP errors: Network failure analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "04631e122b061663c6fd261b605202654aadcf96",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-errors-network-failure-analysis/",
      "published_at": "2021-12-04T15:48:48Z",
      "updated_at": "2021-12-04T15:48:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring's HTTP errors page helps you to better understand HTTP errors and network failures associated with your mobile app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager See a list of errors and failures so you can coordinate mobile app teams with backend teams and share the data they need to fix issues. QA engineer Make sure that a new version of your app does not cause a spike in errors compared to a previous version. DevOps engineer See a list of domains and URLs associated with HTTP errors and network failures, so you can focus on the ones that are causing errors and filter out status codes that are too noisy for your alerts. Mobile developer Find out if there are frontend or backend problems affecting your mobile app (even without an error alert going off) so that you can address them in a new version. Support engineer View the errors and session attributes (geography, connection type, device, app version) associated with an error so that you can help customers with their issues. Find and use the HTTP errors page There are two ways to get to the HTTP errors page: Go to one.newrelic.com > Mobile > (select an app) > Network > Network errors. From a mobile app's Overview page in mobile monitoring, select the HTTP errors/network failures chart title link. From the HTTP errors page, investigate HTTP request and network failures: Use any standard page functions to look for trends in Errors and failures charts. Target specific types of errors and failures by grouping, sorting, and filtering the data. Find anomalies in your request errors with HTTP error profiles. Select an error or failure to view details for it. You can also define NRQL alerts that are focused on error types for your critical services or query your app data. Group, sort, and filter errors and failures If you want to do this... Do this... Change how the page groups and sorts errors and network failures Make selections from the Group by and Sort by dropdowns. By default, the Network errors page is grouped by request domain and sorted by errors and failures. Filter for specific errors and network failures Select an error or failure from the Errors and failures list and/or select multiple filters from the Filter dropdown. See which filters you applied or remove filters The filters you select display next to the filter dropdown. To clear filters, select the X next to the filter you want to clear. Change the time window Select a new time period from the Time picker dropdown. View information for one specific app version Select the version that you want to see charts and lists for in the Versions dropdown. HTTP error profiles Error profiles provide visual details about significant differences in the frequency of different values for HTTP error events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of other errors This helps you take more of the guesswork out of resolving your mobile application's HTTP errors. You can more easily determine if you safely ignore the error, or if you should attempt to resolve the error with a new deployment, code change, customer communication or other actions. View more details about a specific error To view details about an error or failure, select the Request URL link to be directed to the Error summary page. From the Error summary page, you can view the version information, request attributes, and Response body, as well as get a breakdown of error types for the request URL. View and share error data with query builder To explore the data behind any of the charts or lists on the HTTP errors/requests page: Select for any chart. Select View query and then View in Insights. This will open the query builder. From the query builder, you can add the error data to a dashboard and share it via a permalink. To dig deeper into the error data, query your data for the following events and attributes: MobileRequestError events and attributes MobileRequest events and attributes View legacy HTTP errors UI page Accounts that do not have an Enterprise-level subscription see a different HTTP Errors UI page: The Errors page includes details about HTTP errors (403, 404, 422, 500, 502, etc.) and network failures for your hosts; for example: Secure connection failed Timed out Cannot find host Not connected to Internet Cannot connect to host View the Errors page To view HTTP errors or network failures for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Network > Errors. To change the view to errors or failures, select the Sort by option. To hide low-usage hosts, select the Hide < 1% throughput option. To limit information to a specific version of your app, or to change the time period, select your choice from the Versions menu or the time picker below the menu bar. To view details for a specific host, HTTP status error, or network failure, select its name. Use any of our standard user interface functions to drill down into detailed information. Error trace details Mobile monitoring will capture the response details from HTTP requests that return a 400 or 500 level status code. In addition, error messages generated from Android apps will include a stack trace. To view details about an error trace on the Errors page, select its request URL link. From here you can: View the response body. Share the error details with others by email. Delete or hide the error. The errors chart also appears on the selected mobile app's Overview page. If the chart shows errors, you can select its HTTP errors/network failures title or select anywhere on the Overview page's chart to go directly to this Errors page. View error data in query builder To dig deeper into your request data, use the query builder to query and chart the MobileRequest events and attributes. Unknown errors or URL errors The mobile agents maintain a list of exception types. In some cases, custom exceptions thrown by applications fall outside of this list. When this happens, Unknown may appear in the mobile Errors page. If you find Unknown in your list of errors and need assistance in researching which exception types are being missed, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.46881,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View legacy HTTP errors <em>UI</em> page",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em>&#x27;s HTTP errors page helps you to better understand HTTP errors and network failures associated with your <em>mobile</em> app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager"
      },
      "id": "603e8eb428ccbcd174eba791"
    },
    {
      "sections": [
        "Find Build UUIDs for unsymbolicated crashes",
        "View the Build UUID",
        "Binary images example",
        "Find and resymbolicate the dSYM"
      ],
      "title": "Find Build UUIDs for unsymbolicated crashes",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Crashes"
      ],
      "external_id": "e8b926653583d66810c0f68eb6b0111ab3bfc477",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/crashes/find-build-uuids-unsymbolicated-crashes/",
      "published_at": "2021-12-04T18:00:46Z",
      "updated_at": "2021-10-30T20:52:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If the dSYM is not uploaded to New Relic, mobile crash reports cannot be symbolicated. You can upload dSYMs manually or directly through the New Relic UI. However, every build of an application will create a new dSYM, and it can be difficult managing which dSYM is attributed to which app build. In this situation, you can use the Build UUID identifier to: Identify a unique build of an application. Find which dSYM can be used to symbolicate a crash. View the Build UUID An application may have more than one Build UUID, one attributed for each CPU architecture the application is built. The Build UUID is also stored within the associated dSYM and can be extracted to identify the dSYM. New Relic crash reports also contain the Build UUID of the crashing application. To view the Build UUID: Go to one.newrelic.com and click Mobile in the top nav. Then find your app and click Crashes > Crash Analysis. From the Crash list table, select any row. From the selected crash report's Crash Details page, look for the App Image Uuid on the attribute list. If the App Image Uuid is not on the selected crash report's attributes list: Export the crash details. Look for the Build UUID in the Binary images section of the exported crash report. Use the Build UUID extracted from the crash details to find the missing dSYM. Binary images example Here is an example of the Binary images section from an exported crash report. This section lists the Build UUID for every dynamically-linked library included in the application, as well as the Build UUID for the main application. In this example, the main application is New Relic. Its Build UUID is 117667e7b8d230cb8a908906c64e0227. This is the identifier you can use to find the associated dSYM. Binary Images: 0xb1000 - 0x30d000 New Relic armv7 < 117667e7b8d230cb8a908906c64e0227 > /var/containers/Bundle/Application/New Relic.app/New Relic 0x22290000 - 0x22292000 libSystem.B.dylib armv7 <39d6d6f7c2ac3de8bb29c40a1b66368a> /usr/lib/libSystem.B.dylib 0x22292000 - 0x222de000 libc++.1.dylib armv7 <017dba6c16b63f9ebecb9ddd0d0a4520> /usr/lib/libc++.1.dylib 0x222de000 - 0x222f9000 libc++abi.dylib armv7 <d32373f6c2153a509f6603750d213ffb> /usr/lib/libc++abi.dylib 0x222fc000 - 0x22667000 libobjc.A.dylib armv7 <94f6d325c1843f45b3a439b86fc9de15> /usr/lib/libobjc.A.dylib 0x22667000 - 0x2266c000 libcache.dylib armv7 <8009f99fb892331dbcb61cd740ff0f43> /usr/lib/system/libcache.dylib 0x2266c000 - 0x22676000 libcommonCrypto.dylib armv7 <f6db318471d732d39918ef36bde65cb7> /usr/lib/system/libcommonCrypto.dylib 0x22676000 - 0x2267c000 libcompiler_rt.dylib armv7 <cfa3ca12d6c2383abcaf3c8541e9b86c> /usr/lib/system/libcompiler_rt.dylib 0x2267c000 - 0x22683000 libcopyfile.dylib armv7 <d2b06020c3693c7b9d179434f8115ba0> /usr/lib/system/libcopyfile.dylib 0x22683000 - 0x226d3000 libcorecrypto.dylib armv7 <181437f8d9e53277ace439de8b3fd1ad> /usr/lib/system/libcorecrypto.dylib 0x226d3000 - 0x2271d000 libdispatch.dylib armv7 <bbb4bba2176039ab95a59d7a56f6eff8> /usr/lib/system/libdispatch.dylib Copy Find and resymbolicate the dSYM To find a dSYM's Build UUID of a dSYM: use dwarfdump with the following terminal command: dwarfdump --uuid <path-to-dSYM> Copy In the following example, the New Relic dSYM returns two Build UUIDs, one each for ARMv7 and ARM64. The ARMv7 Build UUID matches the Build UUID of the missing crash example: > dwarfdump --uuid ./New\\ Relic.app.dSYM/Contents/Resources/DWARF/New\\ Relic UUID: 117667E7-B8D2-30CB-8A90-8906C64E0227 (armv7) ./New Relic.app.dSYM/Contents/Resources/DWARF/New Relic UUID: B1A8C6EE-02B9-3C55-AEE7-308521873107 (arm64) ./New Relic.app.dSYM/Contents/Resources/DWARF/New Relic Copy To symbolicate the unsymbolicated crashes, follow the instructions to manually upload the dSYM.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.59131,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Find Build UUIDs for unsymbolicated <em>crashes</em>",
        "sections": "Find Build UUIDs for unsymbolicated <em>crashes</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "If the dSYM is not uploaded to New Relic, <em>mobile</em> <em>crash</em> reports cannot be symbolicated. You can upload dSYMs manually or directly through the New Relic <em>UI</em>. However, every build of an application will create a new dSYM, and it can be difficult managing which dSYM is attributed to which app build"
      },
      "id": "603e9fbae7b9d21cef2a07dd"
    },
    {
      "sections": [
        "Introduction to mobile monitoring",
        "How we use mobile monitoring",
        "1. Alert notification shows new version crashes",
        "2. Crash analysis pinpoints exception, location, and more",
        "3. Problem solved, focus on improving app performance",
        "Improve frontend and backend performance",
        "Get started with mobile monitoring"
      ],
      "title": "Introduction to mobile monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile",
        "Get started"
      ],
      "external_id": "4e60f9568c1ffaf583f47bebfe1cecf5bde82a5b",
      "image": "https://docs.newrelic.com/static/3a1763e0e671b37ba517401ae6c5fb62/8c557/mobile-nrOne-summary072820.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile/get-started/introduction-mobile-monitoring/",
      "published_at": "2021-12-08T01:49:33Z",
      "updated_at": "2021-11-24T20:15:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring capabilities help you gain deeper visibility into how to analyze your Android and iOS application performance and troubleshoot crashes. You can also examine HTTP and other network performance for unexpected lag, which will in turn help you collaborate more efficiently with your backend teams. You'll be able to configure mobile monitoring to suit your environnment after you create a New Relic account (it's free, forever!) and install mobile monitoring for your Android, iOS, or Cordova environment. How we use mobile monitoring At New Relic, we have our own mobile developers who create iOS and Android apps so our customers can use New Relic from their mobile devices. During a feature deploy, we encountered a small bug that caused an edge case crash with our Android app. This happened after we had created, tested, and deployed the new feature. Because we work at New Relic, we also use New Relic One to analyze and troubleshoot our mobile apps. To give you an idea of how to explore the power of mobile monitoring, here's an example of how our own mobile engineers used it to track this small bug. A workflow to identify and resolve mobile app crashes using New Relic. 1. Alert notification shows new version crashes The night after a new release, our on-call developer received an alert notification on his mobile phone. The Alerts page indicated that some customers were seeing crashes on the new version of our Android app. Moving to his desktop browser, he checked the Summary page. The overview showed an increase in crashes for the newest version. By filtering for the latest version and setting the time picker to the past 24 hours, he could proceed with crash analysis. An example of using the mobile Summary page to filter to an Android version with crashes. 2. Crash analysis pinpoints exception, location, and more By clicking the Crashes chart title on the mobile Summary page, the Crash analysis page opened with the same 24-hour time frame and filter to this Android version. Here our developer could see a significant number of crashes for the selected version. This reinforced his suspicion there was bad code somewhere in the recent deployment. The developer clicked the link for the crash type to examine the exception, location, and error message. He also examined the stack trace, interaction trail, and event trail to quickly understand where users were impacted. An example of using the Crash analysis page to track down the cause for crashes for a new release by examining the exception, location, and error message. From here the developer saw the error. The new feature had a specific line of bad code that was crashing the app for customers who only used New Relic to monitor one app rather than multiple apps. The team released a hot fix in less than an hour, and the crash rate quickly de-escalated to 0.2%. 3. Problem solved, focus on improving app performance The problem was solved, but the team continues to use New Relic to make sure the most important workflows are running correctly and quickly. We also share HTTP and other network performance trends with our backend API developer teams. Improve frontend and backend performance More than a tool for crash analysis, our mobile monitoring capabilities can help you identify opportunities to speed app performance. For example, you can: Create dashboards to query, visualize, and share performance data. Identify handled exceptions to streamline workflows. See trends with sessions, devices, geographical locations, operating systems, carriers, requests and responses, etc. with crash profiles and HTTP profiles. Set up alert notifications for execution time, errors, etc. Define custom attributes and events to obtain additional, specific details about the mobile data that matters the most to your organization. And more! In addition to crash analysis, do more to fine-tune mobile app performance. Great mobile apps increasingly rely on backend systems to power their functionality, such as requesting product information, authenticating users, or streaming media content. But some backend issues can lead to upstream mobile app crashes, freezes, and broken functionality that impacts end users, including: Changed or non-versioned API endpoints Bad payloads API timeouts Slow or deprecated API endpoints You can use the network pages in our mobile monitoring UI to identify problems that surface through HTTP requests, errors, and other network issues. You can also query your data. Then create dashboards and share this information with backend API developer teams and others in your organization to help improve the overall end user experience with your mobile app. You can also improve your customers' overall digital experience: Get rapid visibility into how your end users experience your mobile apps and web browsers. Analyze actual or simulated end-user behavior to hone in on metrics like load time, availability, and errors, while staying grounded in the backend services that enable these digital experiences. Get started with mobile monitoring Before you install and configure New Relic's functionality for your mobile applications, follow these guidelines for compatibility and other requirements: Android compatibility and requirements iOS compatibility and requirements Then continue with the installation and configuration procedures for your Android, iOS, tvOS, or Cordova application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 162.72774,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>mobile</em> <em>monitoring</em>",
        "sections": "Introduction to <em>mobile</em> <em>monitoring</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": "New Relic&#x27;s <em>mobile</em> <em>monitoring</em> capabilities help you gain deeper visibility into how to analyze your Android and iOS application performance and troubleshoot <em>crashes</em>. You can also examine HTTP and other network performance for unexpected lag, which will in turn help you collaborate more efficiently"
      },
      "id": "603eb1c4e7b9d217802a07a7"
    }
  ],
  "/docs/mobile-monitoring/mobile-monitoring-ui/crashes/introduction-mobile-handled-exceptions": [
    {
      "sections": [
        "HTTP errors: Network failure analysis",
        "Find and use the HTTP errors page",
        "Group, sort, and filter errors and failures",
        "HTTP error profiles",
        "View more details about a specific error",
        "View and share error data with query builder",
        "View legacy HTTP errors UI page",
        "View the Errors page",
        "Error trace details",
        "View error data in query builder",
        "Unknown errors or URL errors"
      ],
      "title": "HTTP errors: Network failure analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "04631e122b061663c6fd261b605202654aadcf96",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-errors-network-failure-analysis/",
      "published_at": "2021-12-04T15:48:48Z",
      "updated_at": "2021-12-04T15:48:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring's HTTP errors page helps you to better understand HTTP errors and network failures associated with your mobile app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager See a list of errors and failures so you can coordinate mobile app teams with backend teams and share the data they need to fix issues. QA engineer Make sure that a new version of your app does not cause a spike in errors compared to a previous version. DevOps engineer See a list of domains and URLs associated with HTTP errors and network failures, so you can focus on the ones that are causing errors and filter out status codes that are too noisy for your alerts. Mobile developer Find out if there are frontend or backend problems affecting your mobile app (even without an error alert going off) so that you can address them in a new version. Support engineer View the errors and session attributes (geography, connection type, device, app version) associated with an error so that you can help customers with their issues. Find and use the HTTP errors page There are two ways to get to the HTTP errors page: Go to one.newrelic.com > Mobile > (select an app) > Network > Network errors. From a mobile app's Overview page in mobile monitoring, select the HTTP errors/network failures chart title link. From the HTTP errors page, investigate HTTP request and network failures: Use any standard page functions to look for trends in Errors and failures charts. Target specific types of errors and failures by grouping, sorting, and filtering the data. Find anomalies in your request errors with HTTP error profiles. Select an error or failure to view details for it. You can also define NRQL alerts that are focused on error types for your critical services or query your app data. Group, sort, and filter errors and failures If you want to do this... Do this... Change how the page groups and sorts errors and network failures Make selections from the Group by and Sort by dropdowns. By default, the Network errors page is grouped by request domain and sorted by errors and failures. Filter for specific errors and network failures Select an error or failure from the Errors and failures list and/or select multiple filters from the Filter dropdown. See which filters you applied or remove filters The filters you select display next to the filter dropdown. To clear filters, select the X next to the filter you want to clear. Change the time window Select a new time period from the Time picker dropdown. View information for one specific app version Select the version that you want to see charts and lists for in the Versions dropdown. HTTP error profiles Error profiles provide visual details about significant differences in the frequency of different values for HTTP error events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of other errors This helps you take more of the guesswork out of resolving your mobile application's HTTP errors. You can more easily determine if you safely ignore the error, or if you should attempt to resolve the error with a new deployment, code change, customer communication or other actions. View more details about a specific error To view details about an error or failure, select the Request URL link to be directed to the Error summary page. From the Error summary page, you can view the version information, request attributes, and Response body, as well as get a breakdown of error types for the request URL. View and share error data with query builder To explore the data behind any of the charts or lists on the HTTP errors/requests page: Select for any chart. Select View query and then View in Insights. This will open the query builder. From the query builder, you can add the error data to a dashboard and share it via a permalink. To dig deeper into the error data, query your data for the following events and attributes: MobileRequestError events and attributes MobileRequest events and attributes View legacy HTTP errors UI page Accounts that do not have an Enterprise-level subscription see a different HTTP Errors UI page: The Errors page includes details about HTTP errors (403, 404, 422, 500, 502, etc.) and network failures for your hosts; for example: Secure connection failed Timed out Cannot find host Not connected to Internet Cannot connect to host View the Errors page To view HTTP errors or network failures for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Network > Errors. To change the view to errors or failures, select the Sort by option. To hide low-usage hosts, select the Hide < 1% throughput option. To limit information to a specific version of your app, or to change the time period, select your choice from the Versions menu or the time picker below the menu bar. To view details for a specific host, HTTP status error, or network failure, select its name. Use any of our standard user interface functions to drill down into detailed information. Error trace details Mobile monitoring will capture the response details from HTTP requests that return a 400 or 500 level status code. In addition, error messages generated from Android apps will include a stack trace. To view details about an error trace on the Errors page, select its request URL link. From here you can: View the response body. Share the error details with others by email. Delete or hide the error. The errors chart also appears on the selected mobile app's Overview page. If the chart shows errors, you can select its HTTP errors/network failures title or select anywhere on the Overview page's chart to go directly to this Errors page. View error data in query builder To dig deeper into your request data, use the query builder to query and chart the MobileRequest events and attributes. Unknown errors or URL errors The mobile agents maintain a list of exception types. In some cases, custom exceptions thrown by applications fall outside of this list. When this happens, Unknown may appear in the mobile Errors page. If you find Unknown in your list of errors and need assistance in researching which exception types are being missed, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.4687,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View legacy HTTP errors <em>UI</em> page",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em>&#x27;s HTTP errors page helps you to better understand HTTP errors and network failures associated with your <em>mobile</em> app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager"
      },
      "id": "603e8eb428ccbcd174eba791"
    },
    {
      "sections": [
        "Find Build UUIDs for unsymbolicated crashes",
        "View the Build UUID",
        "Binary images example",
        "Find and resymbolicate the dSYM"
      ],
      "title": "Find Build UUIDs for unsymbolicated crashes",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Crashes"
      ],
      "external_id": "e8b926653583d66810c0f68eb6b0111ab3bfc477",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/crashes/find-build-uuids-unsymbolicated-crashes/",
      "published_at": "2021-12-04T18:00:46Z",
      "updated_at": "2021-10-30T20:52:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If the dSYM is not uploaded to New Relic, mobile crash reports cannot be symbolicated. You can upload dSYMs manually or directly through the New Relic UI. However, every build of an application will create a new dSYM, and it can be difficult managing which dSYM is attributed to which app build. In this situation, you can use the Build UUID identifier to: Identify a unique build of an application. Find which dSYM can be used to symbolicate a crash. View the Build UUID An application may have more than one Build UUID, one attributed for each CPU architecture the application is built. The Build UUID is also stored within the associated dSYM and can be extracted to identify the dSYM. New Relic crash reports also contain the Build UUID of the crashing application. To view the Build UUID: Go to one.newrelic.com and click Mobile in the top nav. Then find your app and click Crashes > Crash Analysis. From the Crash list table, select any row. From the selected crash report's Crash Details page, look for the App Image Uuid on the attribute list. If the App Image Uuid is not on the selected crash report's attributes list: Export the crash details. Look for the Build UUID in the Binary images section of the exported crash report. Use the Build UUID extracted from the crash details to find the missing dSYM. Binary images example Here is an example of the Binary images section from an exported crash report. This section lists the Build UUID for every dynamically-linked library included in the application, as well as the Build UUID for the main application. In this example, the main application is New Relic. Its Build UUID is 117667e7b8d230cb8a908906c64e0227. This is the identifier you can use to find the associated dSYM. Binary Images: 0xb1000 - 0x30d000 New Relic armv7 < 117667e7b8d230cb8a908906c64e0227 > /var/containers/Bundle/Application/New Relic.app/New Relic 0x22290000 - 0x22292000 libSystem.B.dylib armv7 <39d6d6f7c2ac3de8bb29c40a1b66368a> /usr/lib/libSystem.B.dylib 0x22292000 - 0x222de000 libc++.1.dylib armv7 <017dba6c16b63f9ebecb9ddd0d0a4520> /usr/lib/libc++.1.dylib 0x222de000 - 0x222f9000 libc++abi.dylib armv7 <d32373f6c2153a509f6603750d213ffb> /usr/lib/libc++abi.dylib 0x222fc000 - 0x22667000 libobjc.A.dylib armv7 <94f6d325c1843f45b3a439b86fc9de15> /usr/lib/libobjc.A.dylib 0x22667000 - 0x2266c000 libcache.dylib armv7 <8009f99fb892331dbcb61cd740ff0f43> /usr/lib/system/libcache.dylib 0x2266c000 - 0x22676000 libcommonCrypto.dylib armv7 <f6db318471d732d39918ef36bde65cb7> /usr/lib/system/libcommonCrypto.dylib 0x22676000 - 0x2267c000 libcompiler_rt.dylib armv7 <cfa3ca12d6c2383abcaf3c8541e9b86c> /usr/lib/system/libcompiler_rt.dylib 0x2267c000 - 0x22683000 libcopyfile.dylib armv7 <d2b06020c3693c7b9d179434f8115ba0> /usr/lib/system/libcopyfile.dylib 0x22683000 - 0x226d3000 libcorecrypto.dylib armv7 <181437f8d9e53277ace439de8b3fd1ad> /usr/lib/system/libcorecrypto.dylib 0x226d3000 - 0x2271d000 libdispatch.dylib armv7 <bbb4bba2176039ab95a59d7a56f6eff8> /usr/lib/system/libdispatch.dylib Copy Find and resymbolicate the dSYM To find a dSYM's Build UUID of a dSYM: use dwarfdump with the following terminal command: dwarfdump --uuid <path-to-dSYM> Copy In the following example, the New Relic dSYM returns two Build UUIDs, one each for ARMv7 and ARM64. The ARMv7 Build UUID matches the Build UUID of the missing crash example: > dwarfdump --uuid ./New\\ Relic.app.dSYM/Contents/Resources/DWARF/New\\ Relic UUID: 117667E7-B8D2-30CB-8A90-8906C64E0227 (armv7) ./New Relic.app.dSYM/Contents/Resources/DWARF/New Relic UUID: B1A8C6EE-02B9-3C55-AEE7-308521873107 (arm64) ./New Relic.app.dSYM/Contents/Resources/DWARF/New Relic Copy To symbolicate the unsymbolicated crashes, follow the instructions to manually upload the dSYM.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.5913,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Find Build UUIDs for unsymbolicated <em>crashes</em>",
        "sections": "Find Build UUIDs for unsymbolicated <em>crashes</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "If the dSYM is not uploaded to New Relic, <em>mobile</em> <em>crash</em> reports cannot be symbolicated. You can upload dSYMs manually or directly through the New Relic <em>UI</em>. However, every build of an application will create a new dSYM, and it can be difficult managing which dSYM is attributed to which app build"
      },
      "id": "603e9fbae7b9d21cef2a07dd"
    },
    {
      "sections": [
        "Introduction to mobile monitoring",
        "How we use mobile monitoring",
        "1. Alert notification shows new version crashes",
        "2. Crash analysis pinpoints exception, location, and more",
        "3. Problem solved, focus on improving app performance",
        "Improve frontend and backend performance",
        "Get started with mobile monitoring"
      ],
      "title": "Introduction to mobile monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile",
        "Get started"
      ],
      "external_id": "4e60f9568c1ffaf583f47bebfe1cecf5bde82a5b",
      "image": "https://docs.newrelic.com/static/3a1763e0e671b37ba517401ae6c5fb62/8c557/mobile-nrOne-summary072820.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile/get-started/introduction-mobile-monitoring/",
      "published_at": "2021-12-08T01:49:33Z",
      "updated_at": "2021-11-24T20:15:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring capabilities help you gain deeper visibility into how to analyze your Android and iOS application performance and troubleshoot crashes. You can also examine HTTP and other network performance for unexpected lag, which will in turn help you collaborate more efficiently with your backend teams. You'll be able to configure mobile monitoring to suit your environnment after you create a New Relic account (it's free, forever!) and install mobile monitoring for your Android, iOS, or Cordova environment. How we use mobile monitoring At New Relic, we have our own mobile developers who create iOS and Android apps so our customers can use New Relic from their mobile devices. During a feature deploy, we encountered a small bug that caused an edge case crash with our Android app. This happened after we had created, tested, and deployed the new feature. Because we work at New Relic, we also use New Relic One to analyze and troubleshoot our mobile apps. To give you an idea of how to explore the power of mobile monitoring, here's an example of how our own mobile engineers used it to track this small bug. A workflow to identify and resolve mobile app crashes using New Relic. 1. Alert notification shows new version crashes The night after a new release, our on-call developer received an alert notification on his mobile phone. The Alerts page indicated that some customers were seeing crashes on the new version of our Android app. Moving to his desktop browser, he checked the Summary page. The overview showed an increase in crashes for the newest version. By filtering for the latest version and setting the time picker to the past 24 hours, he could proceed with crash analysis. An example of using the mobile Summary page to filter to an Android version with crashes. 2. Crash analysis pinpoints exception, location, and more By clicking the Crashes chart title on the mobile Summary page, the Crash analysis page opened with the same 24-hour time frame and filter to this Android version. Here our developer could see a significant number of crashes for the selected version. This reinforced his suspicion there was bad code somewhere in the recent deployment. The developer clicked the link for the crash type to examine the exception, location, and error message. He also examined the stack trace, interaction trail, and event trail to quickly understand where users were impacted. An example of using the Crash analysis page to track down the cause for crashes for a new release by examining the exception, location, and error message. From here the developer saw the error. The new feature had a specific line of bad code that was crashing the app for customers who only used New Relic to monitor one app rather than multiple apps. The team released a hot fix in less than an hour, and the crash rate quickly de-escalated to 0.2%. 3. Problem solved, focus on improving app performance The problem was solved, but the team continues to use New Relic to make sure the most important workflows are running correctly and quickly. We also share HTTP and other network performance trends with our backend API developer teams. Improve frontend and backend performance More than a tool for crash analysis, our mobile monitoring capabilities can help you identify opportunities to speed app performance. For example, you can: Create dashboards to query, visualize, and share performance data. Identify handled exceptions to streamline workflows. See trends with sessions, devices, geographical locations, operating systems, carriers, requests and responses, etc. with crash profiles and HTTP profiles. Set up alert notifications for execution time, errors, etc. Define custom attributes and events to obtain additional, specific details about the mobile data that matters the most to your organization. And more! In addition to crash analysis, do more to fine-tune mobile app performance. Great mobile apps increasingly rely on backend systems to power their functionality, such as requesting product information, authenticating users, or streaming media content. But some backend issues can lead to upstream mobile app crashes, freezes, and broken functionality that impacts end users, including: Changed or non-versioned API endpoints Bad payloads API timeouts Slow or deprecated API endpoints You can use the network pages in our mobile monitoring UI to identify problems that surface through HTTP requests, errors, and other network issues. You can also query your data. Then create dashboards and share this information with backend API developer teams and others in your organization to help improve the overall end user experience with your mobile app. You can also improve your customers' overall digital experience: Get rapid visibility into how your end users experience your mobile apps and web browsers. Analyze actual or simulated end-user behavior to hone in on metrics like load time, availability, and errors, while staying grounded in the backend services that enable these digital experiences. Get started with mobile monitoring Before you install and configure New Relic's functionality for your mobile applications, follow these guidelines for compatibility and other requirements: Android compatibility and requirements iOS compatibility and requirements Then continue with the installation and configuration procedures for your Android, iOS, tvOS, or Cordova application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 162.7277,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>mobile</em> <em>monitoring</em>",
        "sections": "Introduction to <em>mobile</em> <em>monitoring</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": "New Relic&#x27;s <em>mobile</em> <em>monitoring</em> capabilities help you gain deeper visibility into how to analyze your Android and iOS application performance and troubleshoot <em>crashes</em>. You can also examine HTTP and other network performance for unexpected lag, which will in turn help you collaborate more efficiently"
      },
      "id": "603eb1c4e7b9d217802a07a7"
    }
  ],
  "/docs/mobile-monitoring/mobile-monitoring-ui/crashes/investigate-mobile-app-crash-report": [
    {
      "sections": [
        "HTTP errors: Network failure analysis",
        "Find and use the HTTP errors page",
        "Group, sort, and filter errors and failures",
        "HTTP error profiles",
        "View more details about a specific error",
        "View and share error data with query builder",
        "View legacy HTTP errors UI page",
        "View the Errors page",
        "Error trace details",
        "View error data in query builder",
        "Unknown errors or URL errors"
      ],
      "title": "HTTP errors: Network failure analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "04631e122b061663c6fd261b605202654aadcf96",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-errors-network-failure-analysis/",
      "published_at": "2021-12-04T15:48:48Z",
      "updated_at": "2021-12-04T15:48:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring's HTTP errors page helps you to better understand HTTP errors and network failures associated with your mobile app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager See a list of errors and failures so you can coordinate mobile app teams with backend teams and share the data they need to fix issues. QA engineer Make sure that a new version of your app does not cause a spike in errors compared to a previous version. DevOps engineer See a list of domains and URLs associated with HTTP errors and network failures, so you can focus on the ones that are causing errors and filter out status codes that are too noisy for your alerts. Mobile developer Find out if there are frontend or backend problems affecting your mobile app (even without an error alert going off) so that you can address them in a new version. Support engineer View the errors and session attributes (geography, connection type, device, app version) associated with an error so that you can help customers with their issues. Find and use the HTTP errors page There are two ways to get to the HTTP errors page: Go to one.newrelic.com > Mobile > (select an app) > Network > Network errors. From a mobile app's Overview page in mobile monitoring, select the HTTP errors/network failures chart title link. From the HTTP errors page, investigate HTTP request and network failures: Use any standard page functions to look for trends in Errors and failures charts. Target specific types of errors and failures by grouping, sorting, and filtering the data. Find anomalies in your request errors with HTTP error profiles. Select an error or failure to view details for it. You can also define NRQL alerts that are focused on error types for your critical services or query your app data. Group, sort, and filter errors and failures If you want to do this... Do this... Change how the page groups and sorts errors and network failures Make selections from the Group by and Sort by dropdowns. By default, the Network errors page is grouped by request domain and sorted by errors and failures. Filter for specific errors and network failures Select an error or failure from the Errors and failures list and/or select multiple filters from the Filter dropdown. See which filters you applied or remove filters The filters you select display next to the filter dropdown. To clear filters, select the X next to the filter you want to clear. Change the time window Select a new time period from the Time picker dropdown. View information for one specific app version Select the version that you want to see charts and lists for in the Versions dropdown. HTTP error profiles Error profiles provide visual details about significant differences in the frequency of different values for HTTP error events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of other errors This helps you take more of the guesswork out of resolving your mobile application's HTTP errors. You can more easily determine if you safely ignore the error, or if you should attempt to resolve the error with a new deployment, code change, customer communication or other actions. View more details about a specific error To view details about an error or failure, select the Request URL link to be directed to the Error summary page. From the Error summary page, you can view the version information, request attributes, and Response body, as well as get a breakdown of error types for the request URL. View and share error data with query builder To explore the data behind any of the charts or lists on the HTTP errors/requests page: Select for any chart. Select View query and then View in Insights. This will open the query builder. From the query builder, you can add the error data to a dashboard and share it via a permalink. To dig deeper into the error data, query your data for the following events and attributes: MobileRequestError events and attributes MobileRequest events and attributes View legacy HTTP errors UI page Accounts that do not have an Enterprise-level subscription see a different HTTP Errors UI page: The Errors page includes details about HTTP errors (403, 404, 422, 500, 502, etc.) and network failures for your hosts; for example: Secure connection failed Timed out Cannot find host Not connected to Internet Cannot connect to host View the Errors page To view HTTP errors or network failures for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Network > Errors. To change the view to errors or failures, select the Sort by option. To hide low-usage hosts, select the Hide < 1% throughput option. To limit information to a specific version of your app, or to change the time period, select your choice from the Versions menu or the time picker below the menu bar. To view details for a specific host, HTTP status error, or network failure, select its name. Use any of our standard user interface functions to drill down into detailed information. Error trace details Mobile monitoring will capture the response details from HTTP requests that return a 400 or 500 level status code. In addition, error messages generated from Android apps will include a stack trace. To view details about an error trace on the Errors page, select its request URL link. From here you can: View the response body. Share the error details with others by email. Delete or hide the error. The errors chart also appears on the selected mobile app's Overview page. If the chart shows errors, you can select its HTTP errors/network failures title or select anywhere on the Overview page's chart to go directly to this Errors page. View error data in query builder To dig deeper into your request data, use the query builder to query and chart the MobileRequest events and attributes. Unknown errors or URL errors The mobile agents maintain a list of exception types. In some cases, custom exceptions thrown by applications fall outside of this list. When this happens, Unknown may appear in the mobile Errors page. If you find Unknown in your list of errors and need assistance in researching which exception types are being missed, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.4687,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View legacy HTTP errors <em>UI</em> page",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em>&#x27;s HTTP errors page helps you to better understand HTTP errors and network failures associated with your <em>mobile</em> app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager"
      },
      "id": "603e8eb428ccbcd174eba791"
    },
    {
      "sections": [
        "Find Build UUIDs for unsymbolicated crashes",
        "View the Build UUID",
        "Binary images example",
        "Find and resymbolicate the dSYM"
      ],
      "title": "Find Build UUIDs for unsymbolicated crashes",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Crashes"
      ],
      "external_id": "e8b926653583d66810c0f68eb6b0111ab3bfc477",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/crashes/find-build-uuids-unsymbolicated-crashes/",
      "published_at": "2021-12-04T18:00:46Z",
      "updated_at": "2021-10-30T20:52:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If the dSYM is not uploaded to New Relic, mobile crash reports cannot be symbolicated. You can upload dSYMs manually or directly through the New Relic UI. However, every build of an application will create a new dSYM, and it can be difficult managing which dSYM is attributed to which app build. In this situation, you can use the Build UUID identifier to: Identify a unique build of an application. Find which dSYM can be used to symbolicate a crash. View the Build UUID An application may have more than one Build UUID, one attributed for each CPU architecture the application is built. The Build UUID is also stored within the associated dSYM and can be extracted to identify the dSYM. New Relic crash reports also contain the Build UUID of the crashing application. To view the Build UUID: Go to one.newrelic.com and click Mobile in the top nav. Then find your app and click Crashes > Crash Analysis. From the Crash list table, select any row. From the selected crash report's Crash Details page, look for the App Image Uuid on the attribute list. If the App Image Uuid is not on the selected crash report's attributes list: Export the crash details. Look for the Build UUID in the Binary images section of the exported crash report. Use the Build UUID extracted from the crash details to find the missing dSYM. Binary images example Here is an example of the Binary images section from an exported crash report. This section lists the Build UUID for every dynamically-linked library included in the application, as well as the Build UUID for the main application. In this example, the main application is New Relic. Its Build UUID is 117667e7b8d230cb8a908906c64e0227. This is the identifier you can use to find the associated dSYM. Binary Images: 0xb1000 - 0x30d000 New Relic armv7 < 117667e7b8d230cb8a908906c64e0227 > /var/containers/Bundle/Application/New Relic.app/New Relic 0x22290000 - 0x22292000 libSystem.B.dylib armv7 <39d6d6f7c2ac3de8bb29c40a1b66368a> /usr/lib/libSystem.B.dylib 0x22292000 - 0x222de000 libc++.1.dylib armv7 <017dba6c16b63f9ebecb9ddd0d0a4520> /usr/lib/libc++.1.dylib 0x222de000 - 0x222f9000 libc++abi.dylib armv7 <d32373f6c2153a509f6603750d213ffb> /usr/lib/libc++abi.dylib 0x222fc000 - 0x22667000 libobjc.A.dylib armv7 <94f6d325c1843f45b3a439b86fc9de15> /usr/lib/libobjc.A.dylib 0x22667000 - 0x2266c000 libcache.dylib armv7 <8009f99fb892331dbcb61cd740ff0f43> /usr/lib/system/libcache.dylib 0x2266c000 - 0x22676000 libcommonCrypto.dylib armv7 <f6db318471d732d39918ef36bde65cb7> /usr/lib/system/libcommonCrypto.dylib 0x22676000 - 0x2267c000 libcompiler_rt.dylib armv7 <cfa3ca12d6c2383abcaf3c8541e9b86c> /usr/lib/system/libcompiler_rt.dylib 0x2267c000 - 0x22683000 libcopyfile.dylib armv7 <d2b06020c3693c7b9d179434f8115ba0> /usr/lib/system/libcopyfile.dylib 0x22683000 - 0x226d3000 libcorecrypto.dylib armv7 <181437f8d9e53277ace439de8b3fd1ad> /usr/lib/system/libcorecrypto.dylib 0x226d3000 - 0x2271d000 libdispatch.dylib armv7 <bbb4bba2176039ab95a59d7a56f6eff8> /usr/lib/system/libdispatch.dylib Copy Find and resymbolicate the dSYM To find a dSYM's Build UUID of a dSYM: use dwarfdump with the following terminal command: dwarfdump --uuid <path-to-dSYM> Copy In the following example, the New Relic dSYM returns two Build UUIDs, one each for ARMv7 and ARM64. The ARMv7 Build UUID matches the Build UUID of the missing crash example: > dwarfdump --uuid ./New\\ Relic.app.dSYM/Contents/Resources/DWARF/New\\ Relic UUID: 117667E7-B8D2-30CB-8A90-8906C64E0227 (armv7) ./New Relic.app.dSYM/Contents/Resources/DWARF/New Relic UUID: B1A8C6EE-02B9-3C55-AEE7-308521873107 (arm64) ./New Relic.app.dSYM/Contents/Resources/DWARF/New Relic Copy To symbolicate the unsymbolicated crashes, follow the instructions to manually upload the dSYM.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.5913,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Find Build UUIDs for unsymbolicated <em>crashes</em>",
        "sections": "Find Build UUIDs for unsymbolicated <em>crashes</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "If the dSYM is not uploaded to New Relic, <em>mobile</em> <em>crash</em> reports cannot be symbolicated. You can upload dSYMs manually or directly through the New Relic <em>UI</em>. However, every build of an application will create a new dSYM, and it can be difficult managing which dSYM is attributed to which app build"
      },
      "id": "603e9fbae7b9d21cef2a07dd"
    },
    {
      "sections": [
        "Introduction to mobile monitoring",
        "How we use mobile monitoring",
        "1. Alert notification shows new version crashes",
        "2. Crash analysis pinpoints exception, location, and more",
        "3. Problem solved, focus on improving app performance",
        "Improve frontend and backend performance",
        "Get started with mobile monitoring"
      ],
      "title": "Introduction to mobile monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile",
        "Get started"
      ],
      "external_id": "4e60f9568c1ffaf583f47bebfe1cecf5bde82a5b",
      "image": "https://docs.newrelic.com/static/3a1763e0e671b37ba517401ae6c5fb62/8c557/mobile-nrOne-summary072820.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile/get-started/introduction-mobile-monitoring/",
      "published_at": "2021-12-08T01:49:33Z",
      "updated_at": "2021-11-24T20:15:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring capabilities help you gain deeper visibility into how to analyze your Android and iOS application performance and troubleshoot crashes. You can also examine HTTP and other network performance for unexpected lag, which will in turn help you collaborate more efficiently with your backend teams. You'll be able to configure mobile monitoring to suit your environnment after you create a New Relic account (it's free, forever!) and install mobile monitoring for your Android, iOS, or Cordova environment. How we use mobile monitoring At New Relic, we have our own mobile developers who create iOS and Android apps so our customers can use New Relic from their mobile devices. During a feature deploy, we encountered a small bug that caused an edge case crash with our Android app. This happened after we had created, tested, and deployed the new feature. Because we work at New Relic, we also use New Relic One to analyze and troubleshoot our mobile apps. To give you an idea of how to explore the power of mobile monitoring, here's an example of how our own mobile engineers used it to track this small bug. A workflow to identify and resolve mobile app crashes using New Relic. 1. Alert notification shows new version crashes The night after a new release, our on-call developer received an alert notification on his mobile phone. The Alerts page indicated that some customers were seeing crashes on the new version of our Android app. Moving to his desktop browser, he checked the Summary page. The overview showed an increase in crashes for the newest version. By filtering for the latest version and setting the time picker to the past 24 hours, he could proceed with crash analysis. An example of using the mobile Summary page to filter to an Android version with crashes. 2. Crash analysis pinpoints exception, location, and more By clicking the Crashes chart title on the mobile Summary page, the Crash analysis page opened with the same 24-hour time frame and filter to this Android version. Here our developer could see a significant number of crashes for the selected version. This reinforced his suspicion there was bad code somewhere in the recent deployment. The developer clicked the link for the crash type to examine the exception, location, and error message. He also examined the stack trace, interaction trail, and event trail to quickly understand where users were impacted. An example of using the Crash analysis page to track down the cause for crashes for a new release by examining the exception, location, and error message. From here the developer saw the error. The new feature had a specific line of bad code that was crashing the app for customers who only used New Relic to monitor one app rather than multiple apps. The team released a hot fix in less than an hour, and the crash rate quickly de-escalated to 0.2%. 3. Problem solved, focus on improving app performance The problem was solved, but the team continues to use New Relic to make sure the most important workflows are running correctly and quickly. We also share HTTP and other network performance trends with our backend API developer teams. Improve frontend and backend performance More than a tool for crash analysis, our mobile monitoring capabilities can help you identify opportunities to speed app performance. For example, you can: Create dashboards to query, visualize, and share performance data. Identify handled exceptions to streamline workflows. See trends with sessions, devices, geographical locations, operating systems, carriers, requests and responses, etc. with crash profiles and HTTP profiles. Set up alert notifications for execution time, errors, etc. Define custom attributes and events to obtain additional, specific details about the mobile data that matters the most to your organization. And more! In addition to crash analysis, do more to fine-tune mobile app performance. Great mobile apps increasingly rely on backend systems to power their functionality, such as requesting product information, authenticating users, or streaming media content. But some backend issues can lead to upstream mobile app crashes, freezes, and broken functionality that impacts end users, including: Changed or non-versioned API endpoints Bad payloads API timeouts Slow or deprecated API endpoints You can use the network pages in our mobile monitoring UI to identify problems that surface through HTTP requests, errors, and other network issues. You can also query your data. Then create dashboards and share this information with backend API developer teams and others in your organization to help improve the overall end user experience with your mobile app. You can also improve your customers' overall digital experience: Get rapid visibility into how your end users experience your mobile apps and web browsers. Analyze actual or simulated end-user behavior to hone in on metrics like load time, availability, and errors, while staying grounded in the backend services that enable these digital experiences. Get started with mobile monitoring Before you install and configure New Relic's functionality for your mobile applications, follow these guidelines for compatibility and other requirements: Android compatibility and requirements iOS compatibility and requirements Then continue with the installation and configuration procedures for your Android, iOS, tvOS, or Cordova application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 162.7277,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>mobile</em> <em>monitoring</em>",
        "sections": "Introduction to <em>mobile</em> <em>monitoring</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": "New Relic&#x27;s <em>mobile</em> <em>monitoring</em> capabilities help you gain deeper visibility into how to analyze your Android and iOS application performance and troubleshoot <em>crashes</em>. You can also examine HTTP and other network performance for unexpected lag, which will in turn help you collaborate more efficiently"
      },
      "id": "603eb1c4e7b9d217802a07a7"
    }
  ],
  "/docs/mobile-monitoring/mobile-monitoring-ui/crashes/mobile-crash-event-trail": [
    {
      "sections": [
        "HTTP errors: Network failure analysis",
        "Find and use the HTTP errors page",
        "Group, sort, and filter errors and failures",
        "HTTP error profiles",
        "View more details about a specific error",
        "View and share error data with query builder",
        "View legacy HTTP errors UI page",
        "View the Errors page",
        "Error trace details",
        "View error data in query builder",
        "Unknown errors or URL errors"
      ],
      "title": "HTTP errors: Network failure analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "04631e122b061663c6fd261b605202654aadcf96",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-errors-network-failure-analysis/",
      "published_at": "2021-12-04T15:48:48Z",
      "updated_at": "2021-12-04T15:48:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring's HTTP errors page helps you to better understand HTTP errors and network failures associated with your mobile app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager See a list of errors and failures so you can coordinate mobile app teams with backend teams and share the data they need to fix issues. QA engineer Make sure that a new version of your app does not cause a spike in errors compared to a previous version. DevOps engineer See a list of domains and URLs associated with HTTP errors and network failures, so you can focus on the ones that are causing errors and filter out status codes that are too noisy for your alerts. Mobile developer Find out if there are frontend or backend problems affecting your mobile app (even without an error alert going off) so that you can address them in a new version. Support engineer View the errors and session attributes (geography, connection type, device, app version) associated with an error so that you can help customers with their issues. Find and use the HTTP errors page There are two ways to get to the HTTP errors page: Go to one.newrelic.com > Mobile > (select an app) > Network > Network errors. From a mobile app's Overview page in mobile monitoring, select the HTTP errors/network failures chart title link. From the HTTP errors page, investigate HTTP request and network failures: Use any standard page functions to look for trends in Errors and failures charts. Target specific types of errors and failures by grouping, sorting, and filtering the data. Find anomalies in your request errors with HTTP error profiles. Select an error or failure to view details for it. You can also define NRQL alerts that are focused on error types for your critical services or query your app data. Group, sort, and filter errors and failures If you want to do this... Do this... Change how the page groups and sorts errors and network failures Make selections from the Group by and Sort by dropdowns. By default, the Network errors page is grouped by request domain and sorted by errors and failures. Filter for specific errors and network failures Select an error or failure from the Errors and failures list and/or select multiple filters from the Filter dropdown. See which filters you applied or remove filters The filters you select display next to the filter dropdown. To clear filters, select the X next to the filter you want to clear. Change the time window Select a new time period from the Time picker dropdown. View information for one specific app version Select the version that you want to see charts and lists for in the Versions dropdown. HTTP error profiles Error profiles provide visual details about significant differences in the frequency of different values for HTTP error events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of other errors This helps you take more of the guesswork out of resolving your mobile application's HTTP errors. You can more easily determine if you safely ignore the error, or if you should attempt to resolve the error with a new deployment, code change, customer communication or other actions. View more details about a specific error To view details about an error or failure, select the Request URL link to be directed to the Error summary page. From the Error summary page, you can view the version information, request attributes, and Response body, as well as get a breakdown of error types for the request URL. View and share error data with query builder To explore the data behind any of the charts or lists on the HTTP errors/requests page: Select for any chart. Select View query and then View in Insights. This will open the query builder. From the query builder, you can add the error data to a dashboard and share it via a permalink. To dig deeper into the error data, query your data for the following events and attributes: MobileRequestError events and attributes MobileRequest events and attributes View legacy HTTP errors UI page Accounts that do not have an Enterprise-level subscription see a different HTTP Errors UI page: The Errors page includes details about HTTP errors (403, 404, 422, 500, 502, etc.) and network failures for your hosts; for example: Secure connection failed Timed out Cannot find host Not connected to Internet Cannot connect to host View the Errors page To view HTTP errors or network failures for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Network > Errors. To change the view to errors or failures, select the Sort by option. To hide low-usage hosts, select the Hide < 1% throughput option. To limit information to a specific version of your app, or to change the time period, select your choice from the Versions menu or the time picker below the menu bar. To view details for a specific host, HTTP status error, or network failure, select its name. Use any of our standard user interface functions to drill down into detailed information. Error trace details Mobile monitoring will capture the response details from HTTP requests that return a 400 or 500 level status code. In addition, error messages generated from Android apps will include a stack trace. To view details about an error trace on the Errors page, select its request URL link. From here you can: View the response body. Share the error details with others by email. Delete or hide the error. The errors chart also appears on the selected mobile app's Overview page. If the chart shows errors, you can select its HTTP errors/network failures title or select anywhere on the Overview page's chart to go directly to this Errors page. View error data in query builder To dig deeper into your request data, use the query builder to query and chart the MobileRequest events and attributes. Unknown errors or URL errors The mobile agents maintain a list of exception types. In some cases, custom exceptions thrown by applications fall outside of this list. When this happens, Unknown may appear in the mobile Errors page. If you find Unknown in your list of errors and need assistance in researching which exception types are being missed, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.4686,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View legacy HTTP errors <em>UI</em> page",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em>&#x27;s HTTP errors page helps you to better understand HTTP errors and network failures associated with your <em>mobile</em> app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager"
      },
      "id": "603e8eb428ccbcd174eba791"
    },
    {
      "sections": [
        "Find Build UUIDs for unsymbolicated crashes",
        "View the Build UUID",
        "Binary images example",
        "Find and resymbolicate the dSYM"
      ],
      "title": "Find Build UUIDs for unsymbolicated crashes",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Crashes"
      ],
      "external_id": "e8b926653583d66810c0f68eb6b0111ab3bfc477",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/crashes/find-build-uuids-unsymbolicated-crashes/",
      "published_at": "2021-12-04T18:00:46Z",
      "updated_at": "2021-10-30T20:52:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If the dSYM is not uploaded to New Relic, mobile crash reports cannot be symbolicated. You can upload dSYMs manually or directly through the New Relic UI. However, every build of an application will create a new dSYM, and it can be difficult managing which dSYM is attributed to which app build. In this situation, you can use the Build UUID identifier to: Identify a unique build of an application. Find which dSYM can be used to symbolicate a crash. View the Build UUID An application may have more than one Build UUID, one attributed for each CPU architecture the application is built. The Build UUID is also stored within the associated dSYM and can be extracted to identify the dSYM. New Relic crash reports also contain the Build UUID of the crashing application. To view the Build UUID: Go to one.newrelic.com and click Mobile in the top nav. Then find your app and click Crashes > Crash Analysis. From the Crash list table, select any row. From the selected crash report's Crash Details page, look for the App Image Uuid on the attribute list. If the App Image Uuid is not on the selected crash report's attributes list: Export the crash details. Look for the Build UUID in the Binary images section of the exported crash report. Use the Build UUID extracted from the crash details to find the missing dSYM. Binary images example Here is an example of the Binary images section from an exported crash report. This section lists the Build UUID for every dynamically-linked library included in the application, as well as the Build UUID for the main application. In this example, the main application is New Relic. Its Build UUID is 117667e7b8d230cb8a908906c64e0227. This is the identifier you can use to find the associated dSYM. Binary Images: 0xb1000 - 0x30d000 New Relic armv7 < 117667e7b8d230cb8a908906c64e0227 > /var/containers/Bundle/Application/New Relic.app/New Relic 0x22290000 - 0x22292000 libSystem.B.dylib armv7 <39d6d6f7c2ac3de8bb29c40a1b66368a> /usr/lib/libSystem.B.dylib 0x22292000 - 0x222de000 libc++.1.dylib armv7 <017dba6c16b63f9ebecb9ddd0d0a4520> /usr/lib/libc++.1.dylib 0x222de000 - 0x222f9000 libc++abi.dylib armv7 <d32373f6c2153a509f6603750d213ffb> /usr/lib/libc++abi.dylib 0x222fc000 - 0x22667000 libobjc.A.dylib armv7 <94f6d325c1843f45b3a439b86fc9de15> /usr/lib/libobjc.A.dylib 0x22667000 - 0x2266c000 libcache.dylib armv7 <8009f99fb892331dbcb61cd740ff0f43> /usr/lib/system/libcache.dylib 0x2266c000 - 0x22676000 libcommonCrypto.dylib armv7 <f6db318471d732d39918ef36bde65cb7> /usr/lib/system/libcommonCrypto.dylib 0x22676000 - 0x2267c000 libcompiler_rt.dylib armv7 <cfa3ca12d6c2383abcaf3c8541e9b86c> /usr/lib/system/libcompiler_rt.dylib 0x2267c000 - 0x22683000 libcopyfile.dylib armv7 <d2b06020c3693c7b9d179434f8115ba0> /usr/lib/system/libcopyfile.dylib 0x22683000 - 0x226d3000 libcorecrypto.dylib armv7 <181437f8d9e53277ace439de8b3fd1ad> /usr/lib/system/libcorecrypto.dylib 0x226d3000 - 0x2271d000 libdispatch.dylib armv7 <bbb4bba2176039ab95a59d7a56f6eff8> /usr/lib/system/libdispatch.dylib Copy Find and resymbolicate the dSYM To find a dSYM's Build UUID of a dSYM: use dwarfdump with the following terminal command: dwarfdump --uuid <path-to-dSYM> Copy In the following example, the New Relic dSYM returns two Build UUIDs, one each for ARMv7 and ARM64. The ARMv7 Build UUID matches the Build UUID of the missing crash example: > dwarfdump --uuid ./New\\ Relic.app.dSYM/Contents/Resources/DWARF/New\\ Relic UUID: 117667E7-B8D2-30CB-8A90-8906C64E0227 (armv7) ./New Relic.app.dSYM/Contents/Resources/DWARF/New Relic UUID: B1A8C6EE-02B9-3C55-AEE7-308521873107 (arm64) ./New Relic.app.dSYM/Contents/Resources/DWARF/New Relic Copy To symbolicate the unsymbolicated crashes, follow the instructions to manually upload the dSYM.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.5913,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Find Build UUIDs for unsymbolicated <em>crashes</em>",
        "sections": "Find Build UUIDs for unsymbolicated <em>crashes</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "If the dSYM is not uploaded to New Relic, <em>mobile</em> <em>crash</em> reports cannot be symbolicated. You can upload dSYMs manually or directly through the New Relic <em>UI</em>. However, every build of an application will create a new dSYM, and it can be difficult managing which dSYM is attributed to which app build"
      },
      "id": "603e9fbae7b9d21cef2a07dd"
    },
    {
      "sections": [
        "Introduction to mobile monitoring",
        "How we use mobile monitoring",
        "1. Alert notification shows new version crashes",
        "2. Crash analysis pinpoints exception, location, and more",
        "3. Problem solved, focus on improving app performance",
        "Improve frontend and backend performance",
        "Get started with mobile monitoring"
      ],
      "title": "Introduction to mobile monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile",
        "Get started"
      ],
      "external_id": "4e60f9568c1ffaf583f47bebfe1cecf5bde82a5b",
      "image": "https://docs.newrelic.com/static/3a1763e0e671b37ba517401ae6c5fb62/8c557/mobile-nrOne-summary072820.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile/get-started/introduction-mobile-monitoring/",
      "published_at": "2021-12-08T01:49:33Z",
      "updated_at": "2021-11-24T20:15:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring capabilities help you gain deeper visibility into how to analyze your Android and iOS application performance and troubleshoot crashes. You can also examine HTTP and other network performance for unexpected lag, which will in turn help you collaborate more efficiently with your backend teams. You'll be able to configure mobile monitoring to suit your environnment after you create a New Relic account (it's free, forever!) and install mobile monitoring for your Android, iOS, or Cordova environment. How we use mobile monitoring At New Relic, we have our own mobile developers who create iOS and Android apps so our customers can use New Relic from their mobile devices. During a feature deploy, we encountered a small bug that caused an edge case crash with our Android app. This happened after we had created, tested, and deployed the new feature. Because we work at New Relic, we also use New Relic One to analyze and troubleshoot our mobile apps. To give you an idea of how to explore the power of mobile monitoring, here's an example of how our own mobile engineers used it to track this small bug. A workflow to identify and resolve mobile app crashes using New Relic. 1. Alert notification shows new version crashes The night after a new release, our on-call developer received an alert notification on his mobile phone. The Alerts page indicated that some customers were seeing crashes on the new version of our Android app. Moving to his desktop browser, he checked the Summary page. The overview showed an increase in crashes for the newest version. By filtering for the latest version and setting the time picker to the past 24 hours, he could proceed with crash analysis. An example of using the mobile Summary page to filter to an Android version with crashes. 2. Crash analysis pinpoints exception, location, and more By clicking the Crashes chart title on the mobile Summary page, the Crash analysis page opened with the same 24-hour time frame and filter to this Android version. Here our developer could see a significant number of crashes for the selected version. This reinforced his suspicion there was bad code somewhere in the recent deployment. The developer clicked the link for the crash type to examine the exception, location, and error message. He also examined the stack trace, interaction trail, and event trail to quickly understand where users were impacted. An example of using the Crash analysis page to track down the cause for crashes for a new release by examining the exception, location, and error message. From here the developer saw the error. The new feature had a specific line of bad code that was crashing the app for customers who only used New Relic to monitor one app rather than multiple apps. The team released a hot fix in less than an hour, and the crash rate quickly de-escalated to 0.2%. 3. Problem solved, focus on improving app performance The problem was solved, but the team continues to use New Relic to make sure the most important workflows are running correctly and quickly. We also share HTTP and other network performance trends with our backend API developer teams. Improve frontend and backend performance More than a tool for crash analysis, our mobile monitoring capabilities can help you identify opportunities to speed app performance. For example, you can: Create dashboards to query, visualize, and share performance data. Identify handled exceptions to streamline workflows. See trends with sessions, devices, geographical locations, operating systems, carriers, requests and responses, etc. with crash profiles and HTTP profiles. Set up alert notifications for execution time, errors, etc. Define custom attributes and events to obtain additional, specific details about the mobile data that matters the most to your organization. And more! In addition to crash analysis, do more to fine-tune mobile app performance. Great mobile apps increasingly rely on backend systems to power their functionality, such as requesting product information, authenticating users, or streaming media content. But some backend issues can lead to upstream mobile app crashes, freezes, and broken functionality that impacts end users, including: Changed or non-versioned API endpoints Bad payloads API timeouts Slow or deprecated API endpoints You can use the network pages in our mobile monitoring UI to identify problems that surface through HTTP requests, errors, and other network issues. You can also query your data. Then create dashboards and share this information with backend API developer teams and others in your organization to help improve the overall end user experience with your mobile app. You can also improve your customers' overall digital experience: Get rapid visibility into how your end users experience your mobile apps and web browsers. Analyze actual or simulated end-user behavior to hone in on metrics like load time, availability, and errors, while staying grounded in the backend services that enable these digital experiences. Get started with mobile monitoring Before you install and configure New Relic's functionality for your mobile applications, follow these guidelines for compatibility and other requirements: Android compatibility and requirements iOS compatibility and requirements Then continue with the installation and configuration procedures for your Android, iOS, tvOS, or Cordova application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 162.72768,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>mobile</em> <em>monitoring</em>",
        "sections": "Introduction to <em>mobile</em> <em>monitoring</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": "New Relic&#x27;s <em>mobile</em> <em>monitoring</em> capabilities help you gain deeper visibility into how to analyze your Android and iOS application performance and troubleshoot <em>crashes</em>. You can also examine HTTP and other network performance for unexpected lag, which will in turn help you collaborate more efficiently"
      },
      "id": "603eb1c4e7b9d217802a07a7"
    }
  ],
  "/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/alerts-page-mobile-apps": [
    {
      "sections": [
        "HTTP errors: Network failure analysis",
        "Find and use the HTTP errors page",
        "Group, sort, and filter errors and failures",
        "HTTP error profiles",
        "View more details about a specific error",
        "View and share error data with query builder",
        "View legacy HTTP errors UI page",
        "View the Errors page",
        "Error trace details",
        "View error data in query builder",
        "Unknown errors or URL errors"
      ],
      "title": "HTTP errors: Network failure analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "04631e122b061663c6fd261b605202654aadcf96",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-errors-network-failure-analysis/",
      "published_at": "2021-12-04T15:48:48Z",
      "updated_at": "2021-12-04T15:48:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring's HTTP errors page helps you to better understand HTTP errors and network failures associated with your mobile app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager See a list of errors and failures so you can coordinate mobile app teams with backend teams and share the data they need to fix issues. QA engineer Make sure that a new version of your app does not cause a spike in errors compared to a previous version. DevOps engineer See a list of domains and URLs associated with HTTP errors and network failures, so you can focus on the ones that are causing errors and filter out status codes that are too noisy for your alerts. Mobile developer Find out if there are frontend or backend problems affecting your mobile app (even without an error alert going off) so that you can address them in a new version. Support engineer View the errors and session attributes (geography, connection type, device, app version) associated with an error so that you can help customers with their issues. Find and use the HTTP errors page There are two ways to get to the HTTP errors page: Go to one.newrelic.com > Mobile > (select an app) > Network > Network errors. From a mobile app's Overview page in mobile monitoring, select the HTTP errors/network failures chart title link. From the HTTP errors page, investigate HTTP request and network failures: Use any standard page functions to look for trends in Errors and failures charts. Target specific types of errors and failures by grouping, sorting, and filtering the data. Find anomalies in your request errors with HTTP error profiles. Select an error or failure to view details for it. You can also define NRQL alerts that are focused on error types for your critical services or query your app data. Group, sort, and filter errors and failures If you want to do this... Do this... Change how the page groups and sorts errors and network failures Make selections from the Group by and Sort by dropdowns. By default, the Network errors page is grouped by request domain and sorted by errors and failures. Filter for specific errors and network failures Select an error or failure from the Errors and failures list and/or select multiple filters from the Filter dropdown. See which filters you applied or remove filters The filters you select display next to the filter dropdown. To clear filters, select the X next to the filter you want to clear. Change the time window Select a new time period from the Time picker dropdown. View information for one specific app version Select the version that you want to see charts and lists for in the Versions dropdown. HTTP error profiles Error profiles provide visual details about significant differences in the frequency of different values for HTTP error events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of other errors This helps you take more of the guesswork out of resolving your mobile application's HTTP errors. You can more easily determine if you safely ignore the error, or if you should attempt to resolve the error with a new deployment, code change, customer communication or other actions. View more details about a specific error To view details about an error or failure, select the Request URL link to be directed to the Error summary page. From the Error summary page, you can view the version information, request attributes, and Response body, as well as get a breakdown of error types for the request URL. View and share error data with query builder To explore the data behind any of the charts or lists on the HTTP errors/requests page: Select for any chart. Select View query and then View in Insights. This will open the query builder. From the query builder, you can add the error data to a dashboard and share it via a permalink. To dig deeper into the error data, query your data for the following events and attributes: MobileRequestError events and attributes MobileRequest events and attributes View legacy HTTP errors UI page Accounts that do not have an Enterprise-level subscription see a different HTTP Errors UI page: The Errors page includes details about HTTP errors (403, 404, 422, 500, 502, etc.) and network failures for your hosts; for example: Secure connection failed Timed out Cannot find host Not connected to Internet Cannot connect to host View the Errors page To view HTTP errors or network failures for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Network > Errors. To change the view to errors or failures, select the Sort by option. To hide low-usage hosts, select the Hide < 1% throughput option. To limit information to a specific version of your app, or to change the time period, select your choice from the Versions menu or the time picker below the menu bar. To view details for a specific host, HTTP status error, or network failure, select its name. Use any of our standard user interface functions to drill down into detailed information. Error trace details Mobile monitoring will capture the response details from HTTP requests that return a 400 or 500 level status code. In addition, error messages generated from Android apps will include a stack trace. To view details about an error trace on the Errors page, select its request URL link. From here you can: View the response body. Share the error details with others by email. Delete or hide the error. The errors chart also appears on the selected mobile app's Overview page. If the chart shows errors, you can select its HTTP errors/network failures title or select anywhere on the Overview page's chart to go directly to this Errors page. View error data in query builder To dig deeper into your request data, use the query builder to query and chart the MobileRequest events and attributes. Unknown errors or URL errors The mobile agents maintain a list of exception types. In some cases, custom exceptions thrown by applications fall outside of this list. When this happens, Unknown may appear in the mobile Errors page. If you find Unknown in your list of errors and need assistance in researching which exception types are being missed, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.4686,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View legacy HTTP errors <em>UI</em> <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em>&#x27;s HTTP errors <em>page</em> helps you to better understand HTTP errors and network failures associated with your <em>mobile</em> <em>app</em>, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors <em>page</em> to... Manager"
      },
      "id": "603e8eb428ccbcd174eba791"
    },
    {
      "sections": [
        "Mobile apps index",
        "View your list of mobile apps",
        "Standard menu functions"
      ],
      "title": "Mobile apps index",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Mobile app pages"
      ],
      "external_id": "38ff00ca55b0ca25a0ad534b57e02b01f4040c97",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/mobile-apps-index/",
      "published_at": "2021-12-04T18:03:02Z",
      "updated_at": "2021-08-27T07:51:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring UI includes a mobile app index that shows a list of your monitored apps and important summary information about them. View your list of mobile apps To see the mobile apps index, go to [one.newrelic.com > Explorer > Mobile applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. Alternatively, go to one.newrelic.com > Mobile. The index of available mobile apps includes a colored health status indicating: Green = Normal Yellow = Warning Red = Critical Gray = Not reporting data Standard menu functions To view details for a specific app, select it from the index. Here are some other functions available from the index: If you want to... Do this... View the app's status Mouse over the mobile app's colored health status indicator. If the health status indicator is gray and no data is being reported, you likely need to finish installing mobile monitoring. Monitor another app Select Add more. See the app's metadata To see the app's metadata, including its app ID, entity GUID, and more, click the icon next to the application name. For more about UI functions, see Basic UI functions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.45697,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Mobile</em> <em>apps</em> index",
        "sections": "<em>Mobile</em> <em>apps</em> index",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": " status indicator is gray and no data is being reported, you likely need to finish installing <em>mobile</em> <em>monitoring</em>. <em>Monitor</em> another <em>app</em> Select Add more. See the <em>app</em>&#x27;s metadata To see the <em>app</em>&#x27;s metadata, including its <em>app</em> ID, entity GUID, and more, click the icon next to the application name. For more about <em>UI</em> functions, see Basic <em>UI</em> functions."
      },
      "id": "604537fc64441f7903378f35"
    },
    {
      "sections": [
        "Version trends: Compare user adoption metrics and performance",
        "Requirements",
        "View version trend data in UI",
        "View version trend details",
        "Performance across releases",
        "Critical user adoption metrics",
        "Key technical indicators",
        "Interpret version trend data (examples)",
        "Query version trend data"
      ],
      "title": "Version trends: Compare user adoption metrics and performance",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Mobile App pages"
      ],
      "external_id": "6fd958a0aa5eec172bddf32f30411f0caab44504",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/version-trends-compare-user-adoption-metrics-performance/",
      "published_at": "2021-12-04T18:03:54Z",
      "updated_at": "2021-08-02T12:36:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring provides a Version trends report with metrics to compare usage, adoption, and performance across the most recent versions of your mobile app. This helps mobile app development managers and their teams to compare up to five production versions from a single page and to analyze the impact of improvements, fixes, and degradations for each. You can view version trend data in the mobile monitoring UI. You can also enable email notifications. Requirements If you see this message in the Version trends UI: \"No adoption data is available for this version because it is running an older agent,\" this indicates the mobile app wasn't using the New Relic mobile agent version that collects install/upgrade count data. To collect version trend information for your mobile app, make sure your agent version is: New Relic mobile agent for Android version 5.3.3 or higher New Relic mobile agent for iOS version 5.3.4 or higher View version trend data in UI To view the Version trends report: Go to one.newrelic.com > Mobile > (select an app) > App > Version trends. Select the Launch time period to compare versions by day (default), week, or month, or view all available data. Review the version trend details to analyze performance, user adoption, and key technical indicators. For additional suggestions about how to interpret the data, review the examples. Optional: To configure email settings, see Email reports. View version trend details Each version includes several metrics to analyze performance, user adoption, and key technical indicators. Performance across releases An important feature is comparison of app performance across releases, based on data collected when each version was at its peak of popularity. You can select four different views of data for when each version was in production, including: Launch day (default) Launch week Launch month All available data for the version This quickly helps you see whether the adoption and performance characteristics of an app's version are better or worse than others. Summary mobile app information for each release includes: Versions: Versions of your app release, sorted by date of highest popularity Sessions: Count of mobile app sessions showing usage of each release Critical user adoption metrics You can compare different versions to see how successfully they have been adopted by users. Total users: Count of unique users (devices) active Upgrades: Count of unique users (devices) active that were upgrades from a previous app version New installs: Count of unique users (devices) active who performed a new install of this app Upgrades and new installs combine to reveal adoption in the form of total unique installs. Key technical indicators Key technical performance indicators include stability, network health, other app or server problems, and memory usage: To track stability, the UI shows the Crash rate as the percentage of all app sessions that crashed. To understand whether networking problems are originating from the app, network, or server, the UI shows the percentage of server responses that returned an HTTP error code (HTTP errors) and the percentage of network calls that failed to receive a response (Network failure). To identify other problems from the app or server, the UI shows the average number of network requests made per app session (Requests per session) and the average server Response time as seen from the app’s perspective. To compare improvements or problems with Memory usage, the first four versions include metrics indicating better (green) or worse (red) performance than the previous version's. Interpret version trend data (examples) Here are some examples of how to interpret some of the data that appears. Example Comments Improvements A new release with faster response time than previous releases may indicate that development efforts were successful. Problems A new release with a spike in crashes, as compared to the previous releases, may indicate that a change introduced in the library or framework is not handling the new scenario or code path properly. User adoption A new release with low numbers of upgrades or new installs may indicate slow adoption of the newest version. This in turn may help justify a new or changed focus in marketing the new release. Release maintenance An older release with continued higher numbers of total users also may indicate slow adoption of the newest version. This in turn may result in unanticipated costs for continued support, or delays in deprecating the old version and its back-end APIs. Query version trend data When querying with NRQL, we provide two attributes to help analyze version trend information: To track when a session includes a new install or a new upgrade, use install. This attribute records true for new installations. To track the last version of the mobile app when an upgrade is detected, use upgradeFrom. To use these attributes, make sure your version of our Android agent or iOS agent supports them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 181.4228,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View version trend data in <em>UI</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em> provides a Version trends report with metrics to compare usage, adoption, and performance across the most recent versions of your <em>mobile</em> <em>app</em>. This helps <em>mobile</em> <em>app</em> development managers and their teams to compare up to five production versions from a single <em>page</em> and to analyze"
      },
      "id": "6044165a196a677c89960f30"
    }
  ],
  "/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/devices-page": [
    {
      "sections": [
        "HTTP errors: Network failure analysis",
        "Find and use the HTTP errors page",
        "Group, sort, and filter errors and failures",
        "HTTP error profiles",
        "View more details about a specific error",
        "View and share error data with query builder",
        "View legacy HTTP errors UI page",
        "View the Errors page",
        "Error trace details",
        "View error data in query builder",
        "Unknown errors or URL errors"
      ],
      "title": "HTTP errors: Network failure analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "04631e122b061663c6fd261b605202654aadcf96",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-errors-network-failure-analysis/",
      "published_at": "2021-12-04T15:48:48Z",
      "updated_at": "2021-12-04T15:48:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring's HTTP errors page helps you to better understand HTTP errors and network failures associated with your mobile app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager See a list of errors and failures so you can coordinate mobile app teams with backend teams and share the data they need to fix issues. QA engineer Make sure that a new version of your app does not cause a spike in errors compared to a previous version. DevOps engineer See a list of domains and URLs associated with HTTP errors and network failures, so you can focus on the ones that are causing errors and filter out status codes that are too noisy for your alerts. Mobile developer Find out if there are frontend or backend problems affecting your mobile app (even without an error alert going off) so that you can address them in a new version. Support engineer View the errors and session attributes (geography, connection type, device, app version) associated with an error so that you can help customers with their issues. Find and use the HTTP errors page There are two ways to get to the HTTP errors page: Go to one.newrelic.com > Mobile > (select an app) > Network > Network errors. From a mobile app's Overview page in mobile monitoring, select the HTTP errors/network failures chart title link. From the HTTP errors page, investigate HTTP request and network failures: Use any standard page functions to look for trends in Errors and failures charts. Target specific types of errors and failures by grouping, sorting, and filtering the data. Find anomalies in your request errors with HTTP error profiles. Select an error or failure to view details for it. You can also define NRQL alerts that are focused on error types for your critical services or query your app data. Group, sort, and filter errors and failures If you want to do this... Do this... Change how the page groups and sorts errors and network failures Make selections from the Group by and Sort by dropdowns. By default, the Network errors page is grouped by request domain and sorted by errors and failures. Filter for specific errors and network failures Select an error or failure from the Errors and failures list and/or select multiple filters from the Filter dropdown. See which filters you applied or remove filters The filters you select display next to the filter dropdown. To clear filters, select the X next to the filter you want to clear. Change the time window Select a new time period from the Time picker dropdown. View information for one specific app version Select the version that you want to see charts and lists for in the Versions dropdown. HTTP error profiles Error profiles provide visual details about significant differences in the frequency of different values for HTTP error events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of other errors This helps you take more of the guesswork out of resolving your mobile application's HTTP errors. You can more easily determine if you safely ignore the error, or if you should attempt to resolve the error with a new deployment, code change, customer communication or other actions. View more details about a specific error To view details about an error or failure, select the Request URL link to be directed to the Error summary page. From the Error summary page, you can view the version information, request attributes, and Response body, as well as get a breakdown of error types for the request URL. View and share error data with query builder To explore the data behind any of the charts or lists on the HTTP errors/requests page: Select for any chart. Select View query and then View in Insights. This will open the query builder. From the query builder, you can add the error data to a dashboard and share it via a permalink. To dig deeper into the error data, query your data for the following events and attributes: MobileRequestError events and attributes MobileRequest events and attributes View legacy HTTP errors UI page Accounts that do not have an Enterprise-level subscription see a different HTTP Errors UI page: The Errors page includes details about HTTP errors (403, 404, 422, 500, 502, etc.) and network failures for your hosts; for example: Secure connection failed Timed out Cannot find host Not connected to Internet Cannot connect to host View the Errors page To view HTTP errors or network failures for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Network > Errors. To change the view to errors or failures, select the Sort by option. To hide low-usage hosts, select the Hide < 1% throughput option. To limit information to a specific version of your app, or to change the time period, select your choice from the Versions menu or the time picker below the menu bar. To view details for a specific host, HTTP status error, or network failure, select its name. Use any of our standard user interface functions to drill down into detailed information. Error trace details Mobile monitoring will capture the response details from HTTP requests that return a 400 or 500 level status code. In addition, error messages generated from Android apps will include a stack trace. To view details about an error trace on the Errors page, select its request URL link. From here you can: View the response body. Share the error details with others by email. Delete or hide the error. The errors chart also appears on the selected mobile app's Overview page. If the chart shows errors, you can select its HTTP errors/network failures title or select anywhere on the Overview page's chart to go directly to this Errors page. View error data in query builder To dig deeper into your request data, use the query builder to query and chart the MobileRequest events and attributes. Unknown errors or URL errors The mobile agents maintain a list of exception types. In some cases, custom exceptions thrown by applications fall outside of this list. When this happens, Unknown may appear in the mobile Errors page. If you find Unknown in your list of errors and need assistance in researching which exception types are being missed, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.4686,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View legacy HTTP errors <em>UI</em> <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em>&#x27;s HTTP errors <em>page</em> helps you to better understand HTTP errors and network failures associated with your <em>mobile</em> <em>app</em>, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors <em>page</em> to... Manager"
      },
      "id": "603e8eb428ccbcd174eba791"
    },
    {
      "sections": [
        "Mobile apps index",
        "View your list of mobile apps",
        "Standard menu functions"
      ],
      "title": "Mobile apps index",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Mobile app pages"
      ],
      "external_id": "38ff00ca55b0ca25a0ad534b57e02b01f4040c97",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/mobile-apps-index/",
      "published_at": "2021-12-04T18:03:02Z",
      "updated_at": "2021-08-27T07:51:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring UI includes a mobile app index that shows a list of your monitored apps and important summary information about them. View your list of mobile apps To see the mobile apps index, go to [one.newrelic.com > Explorer > Mobile applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. Alternatively, go to one.newrelic.com > Mobile. The index of available mobile apps includes a colored health status indicating: Green = Normal Yellow = Warning Red = Critical Gray = Not reporting data Standard menu functions To view details for a specific app, select it from the index. Here are some other functions available from the index: If you want to... Do this... View the app's status Mouse over the mobile app's colored health status indicator. If the health status indicator is gray and no data is being reported, you likely need to finish installing mobile monitoring. Monitor another app Select Add more. See the app's metadata To see the app's metadata, including its app ID, entity GUID, and more, click the icon next to the application name. For more about UI functions, see Basic UI functions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.45697,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Mobile</em> <em>apps</em> index",
        "sections": "<em>Mobile</em> <em>apps</em> index",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": " status indicator is gray and no data is being reported, you likely need to finish installing <em>mobile</em> <em>monitoring</em>. <em>Monitor</em> another <em>app</em> Select Add more. See the <em>app</em>&#x27;s metadata To see the <em>app</em>&#x27;s metadata, including its <em>app</em> ID, entity GUID, and more, click the icon next to the application name. For more about <em>UI</em> functions, see Basic <em>UI</em> functions."
      },
      "id": "604537fc64441f7903378f35"
    },
    {
      "sections": [
        "Version trends: Compare user adoption metrics and performance",
        "Requirements",
        "View version trend data in UI",
        "View version trend details",
        "Performance across releases",
        "Critical user adoption metrics",
        "Key technical indicators",
        "Interpret version trend data (examples)",
        "Query version trend data"
      ],
      "title": "Version trends: Compare user adoption metrics and performance",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Mobile App pages"
      ],
      "external_id": "6fd958a0aa5eec172bddf32f30411f0caab44504",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/version-trends-compare-user-adoption-metrics-performance/",
      "published_at": "2021-12-04T18:03:54Z",
      "updated_at": "2021-08-02T12:36:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring provides a Version trends report with metrics to compare usage, adoption, and performance across the most recent versions of your mobile app. This helps mobile app development managers and their teams to compare up to five production versions from a single page and to analyze the impact of improvements, fixes, and degradations for each. You can view version trend data in the mobile monitoring UI. You can also enable email notifications. Requirements If you see this message in the Version trends UI: \"No adoption data is available for this version because it is running an older agent,\" this indicates the mobile app wasn't using the New Relic mobile agent version that collects install/upgrade count data. To collect version trend information for your mobile app, make sure your agent version is: New Relic mobile agent for Android version 5.3.3 or higher New Relic mobile agent for iOS version 5.3.4 or higher View version trend data in UI To view the Version trends report: Go to one.newrelic.com > Mobile > (select an app) > App > Version trends. Select the Launch time period to compare versions by day (default), week, or month, or view all available data. Review the version trend details to analyze performance, user adoption, and key technical indicators. For additional suggestions about how to interpret the data, review the examples. Optional: To configure email settings, see Email reports. View version trend details Each version includes several metrics to analyze performance, user adoption, and key technical indicators. Performance across releases An important feature is comparison of app performance across releases, based on data collected when each version was at its peak of popularity. You can select four different views of data for when each version was in production, including: Launch day (default) Launch week Launch month All available data for the version This quickly helps you see whether the adoption and performance characteristics of an app's version are better or worse than others. Summary mobile app information for each release includes: Versions: Versions of your app release, sorted by date of highest popularity Sessions: Count of mobile app sessions showing usage of each release Critical user adoption metrics You can compare different versions to see how successfully they have been adopted by users. Total users: Count of unique users (devices) active Upgrades: Count of unique users (devices) active that were upgrades from a previous app version New installs: Count of unique users (devices) active who performed a new install of this app Upgrades and new installs combine to reveal adoption in the form of total unique installs. Key technical indicators Key technical performance indicators include stability, network health, other app or server problems, and memory usage: To track stability, the UI shows the Crash rate as the percentage of all app sessions that crashed. To understand whether networking problems are originating from the app, network, or server, the UI shows the percentage of server responses that returned an HTTP error code (HTTP errors) and the percentage of network calls that failed to receive a response (Network failure). To identify other problems from the app or server, the UI shows the average number of network requests made per app session (Requests per session) and the average server Response time as seen from the app’s perspective. To compare improvements or problems with Memory usage, the first four versions include metrics indicating better (green) or worse (red) performance than the previous version's. Interpret version trend data (examples) Here are some examples of how to interpret some of the data that appears. Example Comments Improvements A new release with faster response time than previous releases may indicate that development efforts were successful. Problems A new release with a spike in crashes, as compared to the previous releases, may indicate that a change introduced in the library or framework is not handling the new scenario or code path properly. User adoption A new release with low numbers of upgrades or new installs may indicate slow adoption of the newest version. This in turn may help justify a new or changed focus in marketing the new release. Release maintenance An older release with continued higher numbers of total users also may indicate slow adoption of the newest version. This in turn may result in unanticipated costs for continued support, or delays in deprecating the old version and its back-end APIs. Query version trend data When querying with NRQL, we provide two attributes to help analyze version trend information: To track when a session includes a new install or a new upgrade, use install. This attribute records true for new installations. To track the last version of the mobile app when an upgrade is detected, use upgradeFrom. To use these attributes, make sure your version of our Android agent or iOS agent supports them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 181.4228,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View version trend data in <em>UI</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em> provides a Version trends report with metrics to compare usage, adoption, and performance across the most recent versions of your <em>mobile</em> <em>app</em>. This helps <em>mobile</em> <em>app</em> development managers and their teams to compare up to five production versions from a single <em>page</em> and to analyze"
      },
      "id": "6044165a196a677c89960f30"
    }
  ],
  "/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/interactions-page": [
    {
      "sections": [
        "HTTP errors: Network failure analysis",
        "Find and use the HTTP errors page",
        "Group, sort, and filter errors and failures",
        "HTTP error profiles",
        "View more details about a specific error",
        "View and share error data with query builder",
        "View legacy HTTP errors UI page",
        "View the Errors page",
        "Error trace details",
        "View error data in query builder",
        "Unknown errors or URL errors"
      ],
      "title": "HTTP errors: Network failure analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "04631e122b061663c6fd261b605202654aadcf96",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-errors-network-failure-analysis/",
      "published_at": "2021-12-04T15:48:48Z",
      "updated_at": "2021-12-04T15:48:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring's HTTP errors page helps you to better understand HTTP errors and network failures associated with your mobile app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager See a list of errors and failures so you can coordinate mobile app teams with backend teams and share the data they need to fix issues. QA engineer Make sure that a new version of your app does not cause a spike in errors compared to a previous version. DevOps engineer See a list of domains and URLs associated with HTTP errors and network failures, so you can focus on the ones that are causing errors and filter out status codes that are too noisy for your alerts. Mobile developer Find out if there are frontend or backend problems affecting your mobile app (even without an error alert going off) so that you can address them in a new version. Support engineer View the errors and session attributes (geography, connection type, device, app version) associated with an error so that you can help customers with their issues. Find and use the HTTP errors page There are two ways to get to the HTTP errors page: Go to one.newrelic.com > Mobile > (select an app) > Network > Network errors. From a mobile app's Overview page in mobile monitoring, select the HTTP errors/network failures chart title link. From the HTTP errors page, investigate HTTP request and network failures: Use any standard page functions to look for trends in Errors and failures charts. Target specific types of errors and failures by grouping, sorting, and filtering the data. Find anomalies in your request errors with HTTP error profiles. Select an error or failure to view details for it. You can also define NRQL alerts that are focused on error types for your critical services or query your app data. Group, sort, and filter errors and failures If you want to do this... Do this... Change how the page groups and sorts errors and network failures Make selections from the Group by and Sort by dropdowns. By default, the Network errors page is grouped by request domain and sorted by errors and failures. Filter for specific errors and network failures Select an error or failure from the Errors and failures list and/or select multiple filters from the Filter dropdown. See which filters you applied or remove filters The filters you select display next to the filter dropdown. To clear filters, select the X next to the filter you want to clear. Change the time window Select a new time period from the Time picker dropdown. View information for one specific app version Select the version that you want to see charts and lists for in the Versions dropdown. HTTP error profiles Error profiles provide visual details about significant differences in the frequency of different values for HTTP error events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of other errors This helps you take more of the guesswork out of resolving your mobile application's HTTP errors. You can more easily determine if you safely ignore the error, or if you should attempt to resolve the error with a new deployment, code change, customer communication or other actions. View more details about a specific error To view details about an error or failure, select the Request URL link to be directed to the Error summary page. From the Error summary page, you can view the version information, request attributes, and Response body, as well as get a breakdown of error types for the request URL. View and share error data with query builder To explore the data behind any of the charts or lists on the HTTP errors/requests page: Select for any chart. Select View query and then View in Insights. This will open the query builder. From the query builder, you can add the error data to a dashboard and share it via a permalink. To dig deeper into the error data, query your data for the following events and attributes: MobileRequestError events and attributes MobileRequest events and attributes View legacy HTTP errors UI page Accounts that do not have an Enterprise-level subscription see a different HTTP Errors UI page: The Errors page includes details about HTTP errors (403, 404, 422, 500, 502, etc.) and network failures for your hosts; for example: Secure connection failed Timed out Cannot find host Not connected to Internet Cannot connect to host View the Errors page To view HTTP errors or network failures for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Network > Errors. To change the view to errors or failures, select the Sort by option. To hide low-usage hosts, select the Hide < 1% throughput option. To limit information to a specific version of your app, or to change the time period, select your choice from the Versions menu or the time picker below the menu bar. To view details for a specific host, HTTP status error, or network failure, select its name. Use any of our standard user interface functions to drill down into detailed information. Error trace details Mobile monitoring will capture the response details from HTTP requests that return a 400 or 500 level status code. In addition, error messages generated from Android apps will include a stack trace. To view details about an error trace on the Errors page, select its request URL link. From here you can: View the response body. Share the error details with others by email. Delete or hide the error. The errors chart also appears on the selected mobile app's Overview page. If the chart shows errors, you can select its HTTP errors/network failures title or select anywhere on the Overview page's chart to go directly to this Errors page. View error data in query builder To dig deeper into your request data, use the query builder to query and chart the MobileRequest events and attributes. Unknown errors or URL errors The mobile agents maintain a list of exception types. In some cases, custom exceptions thrown by applications fall outside of this list. When this happens, Unknown may appear in the mobile Errors page. If you find Unknown in your list of errors and need assistance in researching which exception types are being missed, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.4685,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View legacy HTTP errors <em>UI</em> <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em>&#x27;s HTTP errors <em>page</em> helps you to better understand HTTP errors and network failures associated with your <em>mobile</em> <em>app</em>, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors <em>page</em> to... Manager"
      },
      "id": "603e8eb428ccbcd174eba791"
    },
    {
      "sections": [
        "Mobile apps index",
        "View your list of mobile apps",
        "Standard menu functions"
      ],
      "title": "Mobile apps index",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Mobile app pages"
      ],
      "external_id": "38ff00ca55b0ca25a0ad534b57e02b01f4040c97",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/mobile-apps-index/",
      "published_at": "2021-12-04T18:03:02Z",
      "updated_at": "2021-08-27T07:51:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring UI includes a mobile app index that shows a list of your monitored apps and important summary information about them. View your list of mobile apps To see the mobile apps index, go to [one.newrelic.com > Explorer > Mobile applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. Alternatively, go to one.newrelic.com > Mobile. The index of available mobile apps includes a colored health status indicating: Green = Normal Yellow = Warning Red = Critical Gray = Not reporting data Standard menu functions To view details for a specific app, select it from the index. Here are some other functions available from the index: If you want to... Do this... View the app's status Mouse over the mobile app's colored health status indicator. If the health status indicator is gray and no data is being reported, you likely need to finish installing mobile monitoring. Monitor another app Select Add more. See the app's metadata To see the app's metadata, including its app ID, entity GUID, and more, click the icon next to the application name. For more about UI functions, see Basic UI functions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.45697,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Mobile</em> <em>apps</em> index",
        "sections": "<em>Mobile</em> <em>apps</em> index",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": " status indicator is gray and no data is being reported, you likely need to finish installing <em>mobile</em> <em>monitoring</em>. <em>Monitor</em> another <em>app</em> Select Add more. See the <em>app</em>&#x27;s metadata To see the <em>app</em>&#x27;s metadata, including its <em>app</em> ID, entity GUID, and more, click the icon next to the application name. For more about <em>UI</em> functions, see Basic <em>UI</em> functions."
      },
      "id": "604537fc64441f7903378f35"
    },
    {
      "sections": [
        "Version trends: Compare user adoption metrics and performance",
        "Requirements",
        "View version trend data in UI",
        "View version trend details",
        "Performance across releases",
        "Critical user adoption metrics",
        "Key technical indicators",
        "Interpret version trend data (examples)",
        "Query version trend data"
      ],
      "title": "Version trends: Compare user adoption metrics and performance",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Mobile App pages"
      ],
      "external_id": "6fd958a0aa5eec172bddf32f30411f0caab44504",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/version-trends-compare-user-adoption-metrics-performance/",
      "published_at": "2021-12-04T18:03:54Z",
      "updated_at": "2021-08-02T12:36:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring provides a Version trends report with metrics to compare usage, adoption, and performance across the most recent versions of your mobile app. This helps mobile app development managers and their teams to compare up to five production versions from a single page and to analyze the impact of improvements, fixes, and degradations for each. You can view version trend data in the mobile monitoring UI. You can also enable email notifications. Requirements If you see this message in the Version trends UI: \"No adoption data is available for this version because it is running an older agent,\" this indicates the mobile app wasn't using the New Relic mobile agent version that collects install/upgrade count data. To collect version trend information for your mobile app, make sure your agent version is: New Relic mobile agent for Android version 5.3.3 or higher New Relic mobile agent for iOS version 5.3.4 or higher View version trend data in UI To view the Version trends report: Go to one.newrelic.com > Mobile > (select an app) > App > Version trends. Select the Launch time period to compare versions by day (default), week, or month, or view all available data. Review the version trend details to analyze performance, user adoption, and key technical indicators. For additional suggestions about how to interpret the data, review the examples. Optional: To configure email settings, see Email reports. View version trend details Each version includes several metrics to analyze performance, user adoption, and key technical indicators. Performance across releases An important feature is comparison of app performance across releases, based on data collected when each version was at its peak of popularity. You can select four different views of data for when each version was in production, including: Launch day (default) Launch week Launch month All available data for the version This quickly helps you see whether the adoption and performance characteristics of an app's version are better or worse than others. Summary mobile app information for each release includes: Versions: Versions of your app release, sorted by date of highest popularity Sessions: Count of mobile app sessions showing usage of each release Critical user adoption metrics You can compare different versions to see how successfully they have been adopted by users. Total users: Count of unique users (devices) active Upgrades: Count of unique users (devices) active that were upgrades from a previous app version New installs: Count of unique users (devices) active who performed a new install of this app Upgrades and new installs combine to reveal adoption in the form of total unique installs. Key technical indicators Key technical performance indicators include stability, network health, other app or server problems, and memory usage: To track stability, the UI shows the Crash rate as the percentage of all app sessions that crashed. To understand whether networking problems are originating from the app, network, or server, the UI shows the percentage of server responses that returned an HTTP error code (HTTP errors) and the percentage of network calls that failed to receive a response (Network failure). To identify other problems from the app or server, the UI shows the average number of network requests made per app session (Requests per session) and the average server Response time as seen from the app’s perspective. To compare improvements or problems with Memory usage, the first four versions include metrics indicating better (green) or worse (red) performance than the previous version's. Interpret version trend data (examples) Here are some examples of how to interpret some of the data that appears. Example Comments Improvements A new release with faster response time than previous releases may indicate that development efforts were successful. Problems A new release with a spike in crashes, as compared to the previous releases, may indicate that a change introduced in the library or framework is not handling the new scenario or code path properly. User adoption A new release with low numbers of upgrades or new installs may indicate slow adoption of the newest version. This in turn may help justify a new or changed focus in marketing the new release. Release maintenance An older release with continued higher numbers of total users also may indicate slow adoption of the newest version. This in turn may result in unanticipated costs for continued support, or delays in deprecating the old version and its back-end APIs. Query version trend data When querying with NRQL, we provide two attributes to help analyze version trend information: To track when a session includes a new install or a new upgrade, use install. This attribute records true for new installations. To track the last version of the mobile app when an upgrade is detected, use upgradeFrom. To use these attributes, make sure your version of our Android agent or iOS agent supports them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 181.4228,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View version trend data in <em>UI</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em> provides a Version trends report with metrics to compare usage, adoption, and performance across the most recent versions of your <em>mobile</em> <em>app</em>. This helps <em>mobile</em> <em>app</em> development managers and their teams to compare up to five production versions from a single <em>page</em> and to analyze"
      },
      "id": "6044165a196a677c89960f30"
    }
  ],
  "/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/mobile-apps-index": [
    {
      "sections": [
        "HTTP errors: Network failure analysis",
        "Find and use the HTTP errors page",
        "Group, sort, and filter errors and failures",
        "HTTP error profiles",
        "View more details about a specific error",
        "View and share error data with query builder",
        "View legacy HTTP errors UI page",
        "View the Errors page",
        "Error trace details",
        "View error data in query builder",
        "Unknown errors or URL errors"
      ],
      "title": "HTTP errors: Network failure analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "04631e122b061663c6fd261b605202654aadcf96",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-errors-network-failure-analysis/",
      "published_at": "2021-12-04T15:48:48Z",
      "updated_at": "2021-12-04T15:48:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring's HTTP errors page helps you to better understand HTTP errors and network failures associated with your mobile app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager See a list of errors and failures so you can coordinate mobile app teams with backend teams and share the data they need to fix issues. QA engineer Make sure that a new version of your app does not cause a spike in errors compared to a previous version. DevOps engineer See a list of domains and URLs associated with HTTP errors and network failures, so you can focus on the ones that are causing errors and filter out status codes that are too noisy for your alerts. Mobile developer Find out if there are frontend or backend problems affecting your mobile app (even without an error alert going off) so that you can address them in a new version. Support engineer View the errors and session attributes (geography, connection type, device, app version) associated with an error so that you can help customers with their issues. Find and use the HTTP errors page There are two ways to get to the HTTP errors page: Go to one.newrelic.com > Mobile > (select an app) > Network > Network errors. From a mobile app's Overview page in mobile monitoring, select the HTTP errors/network failures chart title link. From the HTTP errors page, investigate HTTP request and network failures: Use any standard page functions to look for trends in Errors and failures charts. Target specific types of errors and failures by grouping, sorting, and filtering the data. Find anomalies in your request errors with HTTP error profiles. Select an error or failure to view details for it. You can also define NRQL alerts that are focused on error types for your critical services or query your app data. Group, sort, and filter errors and failures If you want to do this... Do this... Change how the page groups and sorts errors and network failures Make selections from the Group by and Sort by dropdowns. By default, the Network errors page is grouped by request domain and sorted by errors and failures. Filter for specific errors and network failures Select an error or failure from the Errors and failures list and/or select multiple filters from the Filter dropdown. See which filters you applied or remove filters The filters you select display next to the filter dropdown. To clear filters, select the X next to the filter you want to clear. Change the time window Select a new time period from the Time picker dropdown. View information for one specific app version Select the version that you want to see charts and lists for in the Versions dropdown. HTTP error profiles Error profiles provide visual details about significant differences in the frequency of different values for HTTP error events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of other errors This helps you take more of the guesswork out of resolving your mobile application's HTTP errors. You can more easily determine if you safely ignore the error, or if you should attempt to resolve the error with a new deployment, code change, customer communication or other actions. View more details about a specific error To view details about an error or failure, select the Request URL link to be directed to the Error summary page. From the Error summary page, you can view the version information, request attributes, and Response body, as well as get a breakdown of error types for the request URL. View and share error data with query builder To explore the data behind any of the charts or lists on the HTTP errors/requests page: Select for any chart. Select View query and then View in Insights. This will open the query builder. From the query builder, you can add the error data to a dashboard and share it via a permalink. To dig deeper into the error data, query your data for the following events and attributes: MobileRequestError events and attributes MobileRequest events and attributes View legacy HTTP errors UI page Accounts that do not have an Enterprise-level subscription see a different HTTP Errors UI page: The Errors page includes details about HTTP errors (403, 404, 422, 500, 502, etc.) and network failures for your hosts; for example: Secure connection failed Timed out Cannot find host Not connected to Internet Cannot connect to host View the Errors page To view HTTP errors or network failures for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Network > Errors. To change the view to errors or failures, select the Sort by option. To hide low-usage hosts, select the Hide < 1% throughput option. To limit information to a specific version of your app, or to change the time period, select your choice from the Versions menu or the time picker below the menu bar. To view details for a specific host, HTTP status error, or network failure, select its name. Use any of our standard user interface functions to drill down into detailed information. Error trace details Mobile monitoring will capture the response details from HTTP requests that return a 400 or 500 level status code. In addition, error messages generated from Android apps will include a stack trace. To view details about an error trace on the Errors page, select its request URL link. From here you can: View the response body. Share the error details with others by email. Delete or hide the error. The errors chart also appears on the selected mobile app's Overview page. If the chart shows errors, you can select its HTTP errors/network failures title or select anywhere on the Overview page's chart to go directly to this Errors page. View error data in query builder To dig deeper into your request data, use the query builder to query and chart the MobileRequest events and attributes. Unknown errors or URL errors The mobile agents maintain a list of exception types. In some cases, custom exceptions thrown by applications fall outside of this list. When this happens, Unknown may appear in the mobile Errors page. If you find Unknown in your list of errors and need assistance in researching which exception types are being missed, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.4685,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View legacy HTTP errors <em>UI</em> <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em>&#x27;s HTTP errors <em>page</em> helps you to better understand HTTP errors and network failures associated with your <em>mobile</em> <em>app</em>, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors <em>page</em> to... Manager"
      },
      "id": "603e8eb428ccbcd174eba791"
    },
    {
      "sections": [
        "Version trends: Compare user adoption metrics and performance",
        "Requirements",
        "View version trend data in UI",
        "View version trend details",
        "Performance across releases",
        "Critical user adoption metrics",
        "Key technical indicators",
        "Interpret version trend data (examples)",
        "Query version trend data"
      ],
      "title": "Version trends: Compare user adoption metrics and performance",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Mobile App pages"
      ],
      "external_id": "6fd958a0aa5eec172bddf32f30411f0caab44504",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/version-trends-compare-user-adoption-metrics-performance/",
      "published_at": "2021-12-04T18:03:54Z",
      "updated_at": "2021-08-02T12:36:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring provides a Version trends report with metrics to compare usage, adoption, and performance across the most recent versions of your mobile app. This helps mobile app development managers and their teams to compare up to five production versions from a single page and to analyze the impact of improvements, fixes, and degradations for each. You can view version trend data in the mobile monitoring UI. You can also enable email notifications. Requirements If you see this message in the Version trends UI: \"No adoption data is available for this version because it is running an older agent,\" this indicates the mobile app wasn't using the New Relic mobile agent version that collects install/upgrade count data. To collect version trend information for your mobile app, make sure your agent version is: New Relic mobile agent for Android version 5.3.3 or higher New Relic mobile agent for iOS version 5.3.4 or higher View version trend data in UI To view the Version trends report: Go to one.newrelic.com > Mobile > (select an app) > App > Version trends. Select the Launch time period to compare versions by day (default), week, or month, or view all available data. Review the version trend details to analyze performance, user adoption, and key technical indicators. For additional suggestions about how to interpret the data, review the examples. Optional: To configure email settings, see Email reports. View version trend details Each version includes several metrics to analyze performance, user adoption, and key technical indicators. Performance across releases An important feature is comparison of app performance across releases, based on data collected when each version was at its peak of popularity. You can select four different views of data for when each version was in production, including: Launch day (default) Launch week Launch month All available data for the version This quickly helps you see whether the adoption and performance characteristics of an app's version are better or worse than others. Summary mobile app information for each release includes: Versions: Versions of your app release, sorted by date of highest popularity Sessions: Count of mobile app sessions showing usage of each release Critical user adoption metrics You can compare different versions to see how successfully they have been adopted by users. Total users: Count of unique users (devices) active Upgrades: Count of unique users (devices) active that were upgrades from a previous app version New installs: Count of unique users (devices) active who performed a new install of this app Upgrades and new installs combine to reveal adoption in the form of total unique installs. Key technical indicators Key technical performance indicators include stability, network health, other app or server problems, and memory usage: To track stability, the UI shows the Crash rate as the percentage of all app sessions that crashed. To understand whether networking problems are originating from the app, network, or server, the UI shows the percentage of server responses that returned an HTTP error code (HTTP errors) and the percentage of network calls that failed to receive a response (Network failure). To identify other problems from the app or server, the UI shows the average number of network requests made per app session (Requests per session) and the average server Response time as seen from the app’s perspective. To compare improvements or problems with Memory usage, the first four versions include metrics indicating better (green) or worse (red) performance than the previous version's. Interpret version trend data (examples) Here are some examples of how to interpret some of the data that appears. Example Comments Improvements A new release with faster response time than previous releases may indicate that development efforts were successful. Problems A new release with a spike in crashes, as compared to the previous releases, may indicate that a change introduced in the library or framework is not handling the new scenario or code path properly. User adoption A new release with low numbers of upgrades or new installs may indicate slow adoption of the newest version. This in turn may help justify a new or changed focus in marketing the new release. Release maintenance An older release with continued higher numbers of total users also may indicate slow adoption of the newest version. This in turn may result in unanticipated costs for continued support, or delays in deprecating the old version and its back-end APIs. Query version trend data When querying with NRQL, we provide two attributes to help analyze version trend information: To track when a session includes a new install or a new upgrade, use install. This attribute records true for new installations. To track the last version of the mobile app when an upgrade is detected, use upgradeFrom. To use these attributes, make sure your version of our Android agent or iOS agent supports them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 181.4228,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View version trend data in <em>UI</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em> provides a Version trends report with metrics to compare usage, adoption, and performance across the most recent versions of your <em>mobile</em> <em>app</em>. This helps <em>mobile</em> <em>app</em> development managers and their teams to compare up to five production versions from a single <em>page</em> and to analyze"
      },
      "id": "6044165a196a677c89960f30"
    },
    {
      "sections": [
        "OS versions page",
        "Viewing the OS versions page",
        "Viewing drill-down details"
      ],
      "title": "OS versions page",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Mobile app pages"
      ],
      "external_id": "370b6f1584d001a17f414066097692b9189e1a50",
      "image": "https://docs.newrelic.com/static/8d84abf966c2f4b75ca298b362995c0e/c1b63/os-version-pic_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/os-versions-page/",
      "published_at": "2021-12-04T18:03:34Z",
      "updated_at": "2021-07-09T11:46:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The OS versions page for mobile monitoring provides performance details about the top operating system versions hosting your mobile application, such as iOS and Android. Charts compare the OS versions by: HTTP request time Network failures Requests per minute Active devices From here you can drill down into details by a major or minor OS version (for example, iOS 8, iOS 7.1.1, Android 4.2.2). Viewing the OS versions page one.newrelic.com > Mobile > (select an app) > App > OS versions: Use this page to view, sort, or drill down into detailed information about the top five types of operation system versions using your mobile app. To view performance details about the operating system versions for your mobile app users: Go to one.newrelic.com > Mobile > (select an app) > App > OS versions. To select the mobile app versions or time period, use the Versions menu and time picker below the UI menu bar. Optional: Select the Sort by and Hide < 1% throughput options. To expand or collapse the list of operating systems to include versions, select the operating system's name (for example, iOS 7). Viewing drill-down details To drill down into detailed information, use any of our standard user interface functions and page functions to drill down into detailed information. In addition: To view details for the minor and point releases of a major OS version (including interaction time, HTTP request times, network failures, active devices, and slowest traces or all subversions), select a major OS version from the list. To view details for a specific OS version, select its name from the expanded OS list. To view trace details a slow transaction (if available), select its link. For more information, see Interactions page. To return to the main OS versions page, select the Close (X) button.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 179.38084,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "OS versions <em>page</em>",
        "sections": "OS versions <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "The OS versions <em>page</em> for <em>mobile</em> <em>monitoring</em> provides performance details about the top operating system versions hosting your <em>mobile</em> application, such as iOS and Android. Charts compare the OS versions by: HTTP request time Network failures Requests per minute Active devices From here you can drill"
      },
      "id": "603eaee9e7b9d260112a0809"
    }
  ],
  "/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/mobile-apps-overview-page": [
    {
      "sections": [
        "HTTP errors: Network failure analysis",
        "Find and use the HTTP errors page",
        "Group, sort, and filter errors and failures",
        "HTTP error profiles",
        "View more details about a specific error",
        "View and share error data with query builder",
        "View legacy HTTP errors UI page",
        "View the Errors page",
        "Error trace details",
        "View error data in query builder",
        "Unknown errors or URL errors"
      ],
      "title": "HTTP errors: Network failure analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "04631e122b061663c6fd261b605202654aadcf96",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-errors-network-failure-analysis/",
      "published_at": "2021-12-04T15:48:48Z",
      "updated_at": "2021-12-04T15:48:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring's HTTP errors page helps you to better understand HTTP errors and network failures associated with your mobile app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager See a list of errors and failures so you can coordinate mobile app teams with backend teams and share the data they need to fix issues. QA engineer Make sure that a new version of your app does not cause a spike in errors compared to a previous version. DevOps engineer See a list of domains and URLs associated with HTTP errors and network failures, so you can focus on the ones that are causing errors and filter out status codes that are too noisy for your alerts. Mobile developer Find out if there are frontend or backend problems affecting your mobile app (even without an error alert going off) so that you can address them in a new version. Support engineer View the errors and session attributes (geography, connection type, device, app version) associated with an error so that you can help customers with their issues. Find and use the HTTP errors page There are two ways to get to the HTTP errors page: Go to one.newrelic.com > Mobile > (select an app) > Network > Network errors. From a mobile app's Overview page in mobile monitoring, select the HTTP errors/network failures chart title link. From the HTTP errors page, investigate HTTP request and network failures: Use any standard page functions to look for trends in Errors and failures charts. Target specific types of errors and failures by grouping, sorting, and filtering the data. Find anomalies in your request errors with HTTP error profiles. Select an error or failure to view details for it. You can also define NRQL alerts that are focused on error types for your critical services or query your app data. Group, sort, and filter errors and failures If you want to do this... Do this... Change how the page groups and sorts errors and network failures Make selections from the Group by and Sort by dropdowns. By default, the Network errors page is grouped by request domain and sorted by errors and failures. Filter for specific errors and network failures Select an error or failure from the Errors and failures list and/or select multiple filters from the Filter dropdown. See which filters you applied or remove filters The filters you select display next to the filter dropdown. To clear filters, select the X next to the filter you want to clear. Change the time window Select a new time period from the Time picker dropdown. View information for one specific app version Select the version that you want to see charts and lists for in the Versions dropdown. HTTP error profiles Error profiles provide visual details about significant differences in the frequency of different values for HTTP error events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of other errors This helps you take more of the guesswork out of resolving your mobile application's HTTP errors. You can more easily determine if you safely ignore the error, or if you should attempt to resolve the error with a new deployment, code change, customer communication or other actions. View more details about a specific error To view details about an error or failure, select the Request URL link to be directed to the Error summary page. From the Error summary page, you can view the version information, request attributes, and Response body, as well as get a breakdown of error types for the request URL. View and share error data with query builder To explore the data behind any of the charts or lists on the HTTP errors/requests page: Select for any chart. Select View query and then View in Insights. This will open the query builder. From the query builder, you can add the error data to a dashboard and share it via a permalink. To dig deeper into the error data, query your data for the following events and attributes: MobileRequestError events and attributes MobileRequest events and attributes View legacy HTTP errors UI page Accounts that do not have an Enterprise-level subscription see a different HTTP Errors UI page: The Errors page includes details about HTTP errors (403, 404, 422, 500, 502, etc.) and network failures for your hosts; for example: Secure connection failed Timed out Cannot find host Not connected to Internet Cannot connect to host View the Errors page To view HTTP errors or network failures for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Network > Errors. To change the view to errors or failures, select the Sort by option. To hide low-usage hosts, select the Hide < 1% throughput option. To limit information to a specific version of your app, or to change the time period, select your choice from the Versions menu or the time picker below the menu bar. To view details for a specific host, HTTP status error, or network failure, select its name. Use any of our standard user interface functions to drill down into detailed information. Error trace details Mobile monitoring will capture the response details from HTTP requests that return a 400 or 500 level status code. In addition, error messages generated from Android apps will include a stack trace. To view details about an error trace on the Errors page, select its request URL link. From here you can: View the response body. Share the error details with others by email. Delete or hide the error. The errors chart also appears on the selected mobile app's Overview page. If the chart shows errors, you can select its HTTP errors/network failures title or select anywhere on the Overview page's chart to go directly to this Errors page. View error data in query builder To dig deeper into your request data, use the query builder to query and chart the MobileRequest events and attributes. Unknown errors or URL errors The mobile agents maintain a list of exception types. In some cases, custom exceptions thrown by applications fall outside of this list. When this happens, Unknown may appear in the mobile Errors page. If you find Unknown in your list of errors and need assistance in researching which exception types are being missed, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.46841,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View legacy HTTP errors <em>UI</em> <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em>&#x27;s HTTP errors <em>page</em> helps you to better understand HTTP errors and network failures associated with your <em>mobile</em> <em>app</em>, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors <em>page</em> to... Manager"
      },
      "id": "603e8eb428ccbcd174eba791"
    },
    {
      "sections": [
        "Mobile apps index",
        "View your list of mobile apps",
        "Standard menu functions"
      ],
      "title": "Mobile apps index",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Mobile app pages"
      ],
      "external_id": "38ff00ca55b0ca25a0ad534b57e02b01f4040c97",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/mobile-apps-index/",
      "published_at": "2021-12-04T18:03:02Z",
      "updated_at": "2021-08-27T07:51:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring UI includes a mobile app index that shows a list of your monitored apps and important summary information about them. View your list of mobile apps To see the mobile apps index, go to [one.newrelic.com > Explorer > Mobile applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. Alternatively, go to one.newrelic.com > Mobile. The index of available mobile apps includes a colored health status indicating: Green = Normal Yellow = Warning Red = Critical Gray = Not reporting data Standard menu functions To view details for a specific app, select it from the index. Here are some other functions available from the index: If you want to... Do this... View the app's status Mouse over the mobile app's colored health status indicator. If the health status indicator is gray and no data is being reported, you likely need to finish installing mobile monitoring. Monitor another app Select Add more. See the app's metadata To see the app's metadata, including its app ID, entity GUID, and more, click the icon next to the application name. For more about UI functions, see Basic UI functions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.45697,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Mobile</em> <em>apps</em> index",
        "sections": "<em>Mobile</em> <em>apps</em> index",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": " status indicator is gray and no data is being reported, you likely need to finish installing <em>mobile</em> <em>monitoring</em>. <em>Monitor</em> another <em>app</em> Select Add more. See the <em>app</em>&#x27;s metadata To see the <em>app</em>&#x27;s metadata, including its <em>app</em> ID, entity GUID, and more, click the icon next to the application name. For more about <em>UI</em> functions, see Basic <em>UI</em> functions."
      },
      "id": "604537fc64441f7903378f35"
    },
    {
      "sections": [
        "Version trends: Compare user adoption metrics and performance",
        "Requirements",
        "View version trend data in UI",
        "View version trend details",
        "Performance across releases",
        "Critical user adoption metrics",
        "Key technical indicators",
        "Interpret version trend data (examples)",
        "Query version trend data"
      ],
      "title": "Version trends: Compare user adoption metrics and performance",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Mobile App pages"
      ],
      "external_id": "6fd958a0aa5eec172bddf32f30411f0caab44504",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/version-trends-compare-user-adoption-metrics-performance/",
      "published_at": "2021-12-04T18:03:54Z",
      "updated_at": "2021-08-02T12:36:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring provides a Version trends report with metrics to compare usage, adoption, and performance across the most recent versions of your mobile app. This helps mobile app development managers and their teams to compare up to five production versions from a single page and to analyze the impact of improvements, fixes, and degradations for each. You can view version trend data in the mobile monitoring UI. You can also enable email notifications. Requirements If you see this message in the Version trends UI: \"No adoption data is available for this version because it is running an older agent,\" this indicates the mobile app wasn't using the New Relic mobile agent version that collects install/upgrade count data. To collect version trend information for your mobile app, make sure your agent version is: New Relic mobile agent for Android version 5.3.3 or higher New Relic mobile agent for iOS version 5.3.4 or higher View version trend data in UI To view the Version trends report: Go to one.newrelic.com > Mobile > (select an app) > App > Version trends. Select the Launch time period to compare versions by day (default), week, or month, or view all available data. Review the version trend details to analyze performance, user adoption, and key technical indicators. For additional suggestions about how to interpret the data, review the examples. Optional: To configure email settings, see Email reports. View version trend details Each version includes several metrics to analyze performance, user adoption, and key technical indicators. Performance across releases An important feature is comparison of app performance across releases, based on data collected when each version was at its peak of popularity. You can select four different views of data for when each version was in production, including: Launch day (default) Launch week Launch month All available data for the version This quickly helps you see whether the adoption and performance characteristics of an app's version are better or worse than others. Summary mobile app information for each release includes: Versions: Versions of your app release, sorted by date of highest popularity Sessions: Count of mobile app sessions showing usage of each release Critical user adoption metrics You can compare different versions to see how successfully they have been adopted by users. Total users: Count of unique users (devices) active Upgrades: Count of unique users (devices) active that were upgrades from a previous app version New installs: Count of unique users (devices) active who performed a new install of this app Upgrades and new installs combine to reveal adoption in the form of total unique installs. Key technical indicators Key technical performance indicators include stability, network health, other app or server problems, and memory usage: To track stability, the UI shows the Crash rate as the percentage of all app sessions that crashed. To understand whether networking problems are originating from the app, network, or server, the UI shows the percentage of server responses that returned an HTTP error code (HTTP errors) and the percentage of network calls that failed to receive a response (Network failure). To identify other problems from the app or server, the UI shows the average number of network requests made per app session (Requests per session) and the average server Response time as seen from the app’s perspective. To compare improvements or problems with Memory usage, the first four versions include metrics indicating better (green) or worse (red) performance than the previous version's. Interpret version trend data (examples) Here are some examples of how to interpret some of the data that appears. Example Comments Improvements A new release with faster response time than previous releases may indicate that development efforts were successful. Problems A new release with a spike in crashes, as compared to the previous releases, may indicate that a change introduced in the library or framework is not handling the new scenario or code path properly. User adoption A new release with low numbers of upgrades or new installs may indicate slow adoption of the newest version. This in turn may help justify a new or changed focus in marketing the new release. Release maintenance An older release with continued higher numbers of total users also may indicate slow adoption of the newest version. This in turn may result in unanticipated costs for continued support, or delays in deprecating the old version and its back-end APIs. Query version trend data When querying with NRQL, we provide two attributes to help analyze version trend information: To track when a session includes a new install or a new upgrade, use install. This attribute records true for new installations. To track the last version of the mobile app when an upgrade is detected, use upgradeFrom. To use these attributes, make sure your version of our Android agent or iOS agent supports them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 181.4228,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View version trend data in <em>UI</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em> provides a Version trends report with metrics to compare usage, adoption, and performance across the most recent versions of your <em>mobile</em> <em>app</em>. This helps <em>mobile</em> <em>app</em> development managers and their teams to compare up to five production versions from a single <em>page</em> and to analyze"
      },
      "id": "6044165a196a677c89960f30"
    }
  ],
  "/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/mobile-monitoring-email-notifications": [
    {
      "sections": [
        "HTTP errors: Network failure analysis",
        "Find and use the HTTP errors page",
        "Group, sort, and filter errors and failures",
        "HTTP error profiles",
        "View more details about a specific error",
        "View and share error data with query builder",
        "View legacy HTTP errors UI page",
        "View the Errors page",
        "Error trace details",
        "View error data in query builder",
        "Unknown errors or URL errors"
      ],
      "title": "HTTP errors: Network failure analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "04631e122b061663c6fd261b605202654aadcf96",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-errors-network-failure-analysis/",
      "published_at": "2021-12-04T15:48:48Z",
      "updated_at": "2021-12-04T15:48:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring's HTTP errors page helps you to better understand HTTP errors and network failures associated with your mobile app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager See a list of errors and failures so you can coordinate mobile app teams with backend teams and share the data they need to fix issues. QA engineer Make sure that a new version of your app does not cause a spike in errors compared to a previous version. DevOps engineer See a list of domains and URLs associated with HTTP errors and network failures, so you can focus on the ones that are causing errors and filter out status codes that are too noisy for your alerts. Mobile developer Find out if there are frontend or backend problems affecting your mobile app (even without an error alert going off) so that you can address them in a new version. Support engineer View the errors and session attributes (geography, connection type, device, app version) associated with an error so that you can help customers with their issues. Find and use the HTTP errors page There are two ways to get to the HTTP errors page: Go to one.newrelic.com > Mobile > (select an app) > Network > Network errors. From a mobile app's Overview page in mobile monitoring, select the HTTP errors/network failures chart title link. From the HTTP errors page, investigate HTTP request and network failures: Use any standard page functions to look for trends in Errors and failures charts. Target specific types of errors and failures by grouping, sorting, and filtering the data. Find anomalies in your request errors with HTTP error profiles. Select an error or failure to view details for it. You can also define NRQL alerts that are focused on error types for your critical services or query your app data. Group, sort, and filter errors and failures If you want to do this... Do this... Change how the page groups and sorts errors and network failures Make selections from the Group by and Sort by dropdowns. By default, the Network errors page is grouped by request domain and sorted by errors and failures. Filter for specific errors and network failures Select an error or failure from the Errors and failures list and/or select multiple filters from the Filter dropdown. See which filters you applied or remove filters The filters you select display next to the filter dropdown. To clear filters, select the X next to the filter you want to clear. Change the time window Select a new time period from the Time picker dropdown. View information for one specific app version Select the version that you want to see charts and lists for in the Versions dropdown. HTTP error profiles Error profiles provide visual details about significant differences in the frequency of different values for HTTP error events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of other errors This helps you take more of the guesswork out of resolving your mobile application's HTTP errors. You can more easily determine if you safely ignore the error, or if you should attempt to resolve the error with a new deployment, code change, customer communication or other actions. View more details about a specific error To view details about an error or failure, select the Request URL link to be directed to the Error summary page. From the Error summary page, you can view the version information, request attributes, and Response body, as well as get a breakdown of error types for the request URL. View and share error data with query builder To explore the data behind any of the charts or lists on the HTTP errors/requests page: Select for any chart. Select View query and then View in Insights. This will open the query builder. From the query builder, you can add the error data to a dashboard and share it via a permalink. To dig deeper into the error data, query your data for the following events and attributes: MobileRequestError events and attributes MobileRequest events and attributes View legacy HTTP errors UI page Accounts that do not have an Enterprise-level subscription see a different HTTP Errors UI page: The Errors page includes details about HTTP errors (403, 404, 422, 500, 502, etc.) and network failures for your hosts; for example: Secure connection failed Timed out Cannot find host Not connected to Internet Cannot connect to host View the Errors page To view HTTP errors or network failures for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Network > Errors. To change the view to errors or failures, select the Sort by option. To hide low-usage hosts, select the Hide < 1% throughput option. To limit information to a specific version of your app, or to change the time period, select your choice from the Versions menu or the time picker below the menu bar. To view details for a specific host, HTTP status error, or network failure, select its name. Use any of our standard user interface functions to drill down into detailed information. Error trace details Mobile monitoring will capture the response details from HTTP requests that return a 400 or 500 level status code. In addition, error messages generated from Android apps will include a stack trace. To view details about an error trace on the Errors page, select its request URL link. From here you can: View the response body. Share the error details with others by email. Delete or hide the error. The errors chart also appears on the selected mobile app's Overview page. If the chart shows errors, you can select its HTTP errors/network failures title or select anywhere on the Overview page's chart to go directly to this Errors page. View error data in query builder To dig deeper into your request data, use the query builder to query and chart the MobileRequest events and attributes. Unknown errors or URL errors The mobile agents maintain a list of exception types. In some cases, custom exceptions thrown by applications fall outside of this list. When this happens, Unknown may appear in the mobile Errors page. If you find Unknown in your list of errors and need assistance in researching which exception types are being missed, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.46841,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View legacy HTTP errors <em>UI</em> <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em>&#x27;s HTTP errors <em>page</em> helps you to better understand HTTP errors and network failures associated with your <em>mobile</em> <em>app</em>, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors <em>page</em> to... Manager"
      },
      "id": "603e8eb428ccbcd174eba791"
    },
    {
      "sections": [
        "Mobile apps index",
        "View your list of mobile apps",
        "Standard menu functions"
      ],
      "title": "Mobile apps index",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Mobile app pages"
      ],
      "external_id": "38ff00ca55b0ca25a0ad534b57e02b01f4040c97",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/mobile-apps-index/",
      "published_at": "2021-12-04T18:03:02Z",
      "updated_at": "2021-08-27T07:51:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring UI includes a mobile app index that shows a list of your monitored apps and important summary information about them. View your list of mobile apps To see the mobile apps index, go to [one.newrelic.com > Explorer > Mobile applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. Alternatively, go to one.newrelic.com > Mobile. The index of available mobile apps includes a colored health status indicating: Green = Normal Yellow = Warning Red = Critical Gray = Not reporting data Standard menu functions To view details for a specific app, select it from the index. Here are some other functions available from the index: If you want to... Do this... View the app's status Mouse over the mobile app's colored health status indicator. If the health status indicator is gray and no data is being reported, you likely need to finish installing mobile monitoring. Monitor another app Select Add more. See the app's metadata To see the app's metadata, including its app ID, entity GUID, and more, click the icon next to the application name. For more about UI functions, see Basic UI functions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.45697,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Mobile</em> <em>apps</em> index",
        "sections": "<em>Mobile</em> <em>apps</em> index",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": " status indicator is gray and no data is being reported, you likely need to finish installing <em>mobile</em> <em>monitoring</em>. <em>Monitor</em> another <em>app</em> Select Add more. See the <em>app</em>&#x27;s metadata To see the <em>app</em>&#x27;s metadata, including its <em>app</em> ID, entity GUID, and more, click the icon next to the application name. For more about <em>UI</em> functions, see Basic <em>UI</em> functions."
      },
      "id": "604537fc64441f7903378f35"
    },
    {
      "sections": [
        "Version trends: Compare user adoption metrics and performance",
        "Requirements",
        "View version trend data in UI",
        "View version trend details",
        "Performance across releases",
        "Critical user adoption metrics",
        "Key technical indicators",
        "Interpret version trend data (examples)",
        "Query version trend data"
      ],
      "title": "Version trends: Compare user adoption metrics and performance",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Mobile App pages"
      ],
      "external_id": "6fd958a0aa5eec172bddf32f30411f0caab44504",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/version-trends-compare-user-adoption-metrics-performance/",
      "published_at": "2021-12-04T18:03:54Z",
      "updated_at": "2021-08-02T12:36:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring provides a Version trends report with metrics to compare usage, adoption, and performance across the most recent versions of your mobile app. This helps mobile app development managers and their teams to compare up to five production versions from a single page and to analyze the impact of improvements, fixes, and degradations for each. You can view version trend data in the mobile monitoring UI. You can also enable email notifications. Requirements If you see this message in the Version trends UI: \"No adoption data is available for this version because it is running an older agent,\" this indicates the mobile app wasn't using the New Relic mobile agent version that collects install/upgrade count data. To collect version trend information for your mobile app, make sure your agent version is: New Relic mobile agent for Android version 5.3.3 or higher New Relic mobile agent for iOS version 5.3.4 or higher View version trend data in UI To view the Version trends report: Go to one.newrelic.com > Mobile > (select an app) > App > Version trends. Select the Launch time period to compare versions by day (default), week, or month, or view all available data. Review the version trend details to analyze performance, user adoption, and key technical indicators. For additional suggestions about how to interpret the data, review the examples. Optional: To configure email settings, see Email reports. View version trend details Each version includes several metrics to analyze performance, user adoption, and key technical indicators. Performance across releases An important feature is comparison of app performance across releases, based on data collected when each version was at its peak of popularity. You can select four different views of data for when each version was in production, including: Launch day (default) Launch week Launch month All available data for the version This quickly helps you see whether the adoption and performance characteristics of an app's version are better or worse than others. Summary mobile app information for each release includes: Versions: Versions of your app release, sorted by date of highest popularity Sessions: Count of mobile app sessions showing usage of each release Critical user adoption metrics You can compare different versions to see how successfully they have been adopted by users. Total users: Count of unique users (devices) active Upgrades: Count of unique users (devices) active that were upgrades from a previous app version New installs: Count of unique users (devices) active who performed a new install of this app Upgrades and new installs combine to reveal adoption in the form of total unique installs. Key technical indicators Key technical performance indicators include stability, network health, other app or server problems, and memory usage: To track stability, the UI shows the Crash rate as the percentage of all app sessions that crashed. To understand whether networking problems are originating from the app, network, or server, the UI shows the percentage of server responses that returned an HTTP error code (HTTP errors) and the percentage of network calls that failed to receive a response (Network failure). To identify other problems from the app or server, the UI shows the average number of network requests made per app session (Requests per session) and the average server Response time as seen from the app’s perspective. To compare improvements or problems with Memory usage, the first four versions include metrics indicating better (green) or worse (red) performance than the previous version's. Interpret version trend data (examples) Here are some examples of how to interpret some of the data that appears. Example Comments Improvements A new release with faster response time than previous releases may indicate that development efforts were successful. Problems A new release with a spike in crashes, as compared to the previous releases, may indicate that a change introduced in the library or framework is not handling the new scenario or code path properly. User adoption A new release with low numbers of upgrades or new installs may indicate slow adoption of the newest version. This in turn may help justify a new or changed focus in marketing the new release. Release maintenance An older release with continued higher numbers of total users also may indicate slow adoption of the newest version. This in turn may result in unanticipated costs for continued support, or delays in deprecating the old version and its back-end APIs. Query version trend data When querying with NRQL, we provide two attributes to help analyze version trend information: To track when a session includes a new install or a new upgrade, use install. This attribute records true for new installations. To track the last version of the mobile app when an upgrade is detected, use upgradeFrom. To use these attributes, make sure your version of our Android agent or iOS agent supports them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 181.4228,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View version trend data in <em>UI</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em> provides a Version trends report with metrics to compare usage, adoption, and performance across the most recent versions of your <em>mobile</em> <em>app</em>. This helps <em>mobile</em> <em>app</em> development managers and their teams to compare up to five production versions from a single <em>page</em> and to analyze"
      },
      "id": "6044165a196a677c89960f30"
    }
  ],
  "/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/os-versions-page": [
    {
      "sections": [
        "HTTP errors: Network failure analysis",
        "Find and use the HTTP errors page",
        "Group, sort, and filter errors and failures",
        "HTTP error profiles",
        "View more details about a specific error",
        "View and share error data with query builder",
        "View legacy HTTP errors UI page",
        "View the Errors page",
        "Error trace details",
        "View error data in query builder",
        "Unknown errors or URL errors"
      ],
      "title": "HTTP errors: Network failure analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "04631e122b061663c6fd261b605202654aadcf96",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-errors-network-failure-analysis/",
      "published_at": "2021-12-04T15:48:48Z",
      "updated_at": "2021-12-04T15:48:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring's HTTP errors page helps you to better understand HTTP errors and network failures associated with your mobile app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager See a list of errors and failures so you can coordinate mobile app teams with backend teams and share the data they need to fix issues. QA engineer Make sure that a new version of your app does not cause a spike in errors compared to a previous version. DevOps engineer See a list of domains and URLs associated with HTTP errors and network failures, so you can focus on the ones that are causing errors and filter out status codes that are too noisy for your alerts. Mobile developer Find out if there are frontend or backend problems affecting your mobile app (even without an error alert going off) so that you can address them in a new version. Support engineer View the errors and session attributes (geography, connection type, device, app version) associated with an error so that you can help customers with their issues. Find and use the HTTP errors page There are two ways to get to the HTTP errors page: Go to one.newrelic.com > Mobile > (select an app) > Network > Network errors. From a mobile app's Overview page in mobile monitoring, select the HTTP errors/network failures chart title link. From the HTTP errors page, investigate HTTP request and network failures: Use any standard page functions to look for trends in Errors and failures charts. Target specific types of errors and failures by grouping, sorting, and filtering the data. Find anomalies in your request errors with HTTP error profiles. Select an error or failure to view details for it. You can also define NRQL alerts that are focused on error types for your critical services or query your app data. Group, sort, and filter errors and failures If you want to do this... Do this... Change how the page groups and sorts errors and network failures Make selections from the Group by and Sort by dropdowns. By default, the Network errors page is grouped by request domain and sorted by errors and failures. Filter for specific errors and network failures Select an error or failure from the Errors and failures list and/or select multiple filters from the Filter dropdown. See which filters you applied or remove filters The filters you select display next to the filter dropdown. To clear filters, select the X next to the filter you want to clear. Change the time window Select a new time period from the Time picker dropdown. View information for one specific app version Select the version that you want to see charts and lists for in the Versions dropdown. HTTP error profiles Error profiles provide visual details about significant differences in the frequency of different values for HTTP error events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of other errors This helps you take more of the guesswork out of resolving your mobile application's HTTP errors. You can more easily determine if you safely ignore the error, or if you should attempt to resolve the error with a new deployment, code change, customer communication or other actions. View more details about a specific error To view details about an error or failure, select the Request URL link to be directed to the Error summary page. From the Error summary page, you can view the version information, request attributes, and Response body, as well as get a breakdown of error types for the request URL. View and share error data with query builder To explore the data behind any of the charts or lists on the HTTP errors/requests page: Select for any chart. Select View query and then View in Insights. This will open the query builder. From the query builder, you can add the error data to a dashboard and share it via a permalink. To dig deeper into the error data, query your data for the following events and attributes: MobileRequestError events and attributes MobileRequest events and attributes View legacy HTTP errors UI page Accounts that do not have an Enterprise-level subscription see a different HTTP Errors UI page: The Errors page includes details about HTTP errors (403, 404, 422, 500, 502, etc.) and network failures for your hosts; for example: Secure connection failed Timed out Cannot find host Not connected to Internet Cannot connect to host View the Errors page To view HTTP errors or network failures for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Network > Errors. To change the view to errors or failures, select the Sort by option. To hide low-usage hosts, select the Hide < 1% throughput option. To limit information to a specific version of your app, or to change the time period, select your choice from the Versions menu or the time picker below the menu bar. To view details for a specific host, HTTP status error, or network failure, select its name. Use any of our standard user interface functions to drill down into detailed information. Error trace details Mobile monitoring will capture the response details from HTTP requests that return a 400 or 500 level status code. In addition, error messages generated from Android apps will include a stack trace. To view details about an error trace on the Errors page, select its request URL link. From here you can: View the response body. Share the error details with others by email. Delete or hide the error. The errors chart also appears on the selected mobile app's Overview page. If the chart shows errors, you can select its HTTP errors/network failures title or select anywhere on the Overview page's chart to go directly to this Errors page. View error data in query builder To dig deeper into your request data, use the query builder to query and chart the MobileRequest events and attributes. Unknown errors or URL errors The mobile agents maintain a list of exception types. In some cases, custom exceptions thrown by applications fall outside of this list. When this happens, Unknown may appear in the mobile Errors page. If you find Unknown in your list of errors and need assistance in researching which exception types are being missed, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.46832,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View legacy HTTP errors <em>UI</em> <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em>&#x27;s HTTP errors <em>page</em> helps you to better understand HTTP errors and network failures associated with your <em>mobile</em> <em>app</em>, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors <em>page</em> to... Manager"
      },
      "id": "603e8eb428ccbcd174eba791"
    },
    {
      "sections": [
        "Mobile apps index",
        "View your list of mobile apps",
        "Standard menu functions"
      ],
      "title": "Mobile apps index",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Mobile app pages"
      ],
      "external_id": "38ff00ca55b0ca25a0ad534b57e02b01f4040c97",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/mobile-apps-index/",
      "published_at": "2021-12-04T18:03:02Z",
      "updated_at": "2021-08-27T07:51:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring UI includes a mobile app index that shows a list of your monitored apps and important summary information about them. View your list of mobile apps To see the mobile apps index, go to [one.newrelic.com > Explorer > Mobile applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. Alternatively, go to one.newrelic.com > Mobile. The index of available mobile apps includes a colored health status indicating: Green = Normal Yellow = Warning Red = Critical Gray = Not reporting data Standard menu functions To view details for a specific app, select it from the index. Here are some other functions available from the index: If you want to... Do this... View the app's status Mouse over the mobile app's colored health status indicator. If the health status indicator is gray and no data is being reported, you likely need to finish installing mobile monitoring. Monitor another app Select Add more. See the app's metadata To see the app's metadata, including its app ID, entity GUID, and more, click the icon next to the application name. For more about UI functions, see Basic UI functions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.45697,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Mobile</em> <em>apps</em> index",
        "sections": "<em>Mobile</em> <em>apps</em> index",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": " status indicator is gray and no data is being reported, you likely need to finish installing <em>mobile</em> <em>monitoring</em>. <em>Monitor</em> another <em>app</em> Select Add more. See the <em>app</em>&#x27;s metadata To see the <em>app</em>&#x27;s metadata, including its <em>app</em> ID, entity GUID, and more, click the icon next to the application name. For more about <em>UI</em> functions, see Basic <em>UI</em> functions."
      },
      "id": "604537fc64441f7903378f35"
    },
    {
      "sections": [
        "Version trends: Compare user adoption metrics and performance",
        "Requirements",
        "View version trend data in UI",
        "View version trend details",
        "Performance across releases",
        "Critical user adoption metrics",
        "Key technical indicators",
        "Interpret version trend data (examples)",
        "Query version trend data"
      ],
      "title": "Version trends: Compare user adoption metrics and performance",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Mobile App pages"
      ],
      "external_id": "6fd958a0aa5eec172bddf32f30411f0caab44504",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/version-trends-compare-user-adoption-metrics-performance/",
      "published_at": "2021-12-04T18:03:54Z",
      "updated_at": "2021-08-02T12:36:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring provides a Version trends report with metrics to compare usage, adoption, and performance across the most recent versions of your mobile app. This helps mobile app development managers and their teams to compare up to five production versions from a single page and to analyze the impact of improvements, fixes, and degradations for each. You can view version trend data in the mobile monitoring UI. You can also enable email notifications. Requirements If you see this message in the Version trends UI: \"No adoption data is available for this version because it is running an older agent,\" this indicates the mobile app wasn't using the New Relic mobile agent version that collects install/upgrade count data. To collect version trend information for your mobile app, make sure your agent version is: New Relic mobile agent for Android version 5.3.3 or higher New Relic mobile agent for iOS version 5.3.4 or higher View version trend data in UI To view the Version trends report: Go to one.newrelic.com > Mobile > (select an app) > App > Version trends. Select the Launch time period to compare versions by day (default), week, or month, or view all available data. Review the version trend details to analyze performance, user adoption, and key technical indicators. For additional suggestions about how to interpret the data, review the examples. Optional: To configure email settings, see Email reports. View version trend details Each version includes several metrics to analyze performance, user adoption, and key technical indicators. Performance across releases An important feature is comparison of app performance across releases, based on data collected when each version was at its peak of popularity. You can select four different views of data for when each version was in production, including: Launch day (default) Launch week Launch month All available data for the version This quickly helps you see whether the adoption and performance characteristics of an app's version are better or worse than others. Summary mobile app information for each release includes: Versions: Versions of your app release, sorted by date of highest popularity Sessions: Count of mobile app sessions showing usage of each release Critical user adoption metrics You can compare different versions to see how successfully they have been adopted by users. Total users: Count of unique users (devices) active Upgrades: Count of unique users (devices) active that were upgrades from a previous app version New installs: Count of unique users (devices) active who performed a new install of this app Upgrades and new installs combine to reveal adoption in the form of total unique installs. Key technical indicators Key technical performance indicators include stability, network health, other app or server problems, and memory usage: To track stability, the UI shows the Crash rate as the percentage of all app sessions that crashed. To understand whether networking problems are originating from the app, network, or server, the UI shows the percentage of server responses that returned an HTTP error code (HTTP errors) and the percentage of network calls that failed to receive a response (Network failure). To identify other problems from the app or server, the UI shows the average number of network requests made per app session (Requests per session) and the average server Response time as seen from the app’s perspective. To compare improvements or problems with Memory usage, the first four versions include metrics indicating better (green) or worse (red) performance than the previous version's. Interpret version trend data (examples) Here are some examples of how to interpret some of the data that appears. Example Comments Improvements A new release with faster response time than previous releases may indicate that development efforts were successful. Problems A new release with a spike in crashes, as compared to the previous releases, may indicate that a change introduced in the library or framework is not handling the new scenario or code path properly. User adoption A new release with low numbers of upgrades or new installs may indicate slow adoption of the newest version. This in turn may help justify a new or changed focus in marketing the new release. Release maintenance An older release with continued higher numbers of total users also may indicate slow adoption of the newest version. This in turn may result in unanticipated costs for continued support, or delays in deprecating the old version and its back-end APIs. Query version trend data When querying with NRQL, we provide two attributes to help analyze version trend information: To track when a session includes a new install or a new upgrade, use install. This attribute records true for new installations. To track the last version of the mobile app when an upgrade is detected, use upgradeFrom. To use these attributes, make sure your version of our Android agent or iOS agent supports them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 181.4228,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View version trend data in <em>UI</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em> provides a Version trends report with metrics to compare usage, adoption, and performance across the most recent versions of your <em>mobile</em> <em>app</em>. This helps <em>mobile</em> <em>app</em> development managers and their teams to compare up to five production versions from a single <em>page</em> and to analyze"
      },
      "id": "6044165a196a677c89960f30"
    }
  ],
  "/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/version-trends-compare-user-adoption-metrics-performance": [
    {
      "sections": [
        "HTTP errors: Network failure analysis",
        "Find and use the HTTP errors page",
        "Group, sort, and filter errors and failures",
        "HTTP error profiles",
        "View more details about a specific error",
        "View and share error data with query builder",
        "View legacy HTTP errors UI page",
        "View the Errors page",
        "Error trace details",
        "View error data in query builder",
        "Unknown errors or URL errors"
      ],
      "title": "HTTP errors: Network failure analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "04631e122b061663c6fd261b605202654aadcf96",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-errors-network-failure-analysis/",
      "published_at": "2021-12-04T15:48:48Z",
      "updated_at": "2021-12-04T15:48:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring's HTTP errors page helps you to better understand HTTP errors and network failures associated with your mobile app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager See a list of errors and failures so you can coordinate mobile app teams with backend teams and share the data they need to fix issues. QA engineer Make sure that a new version of your app does not cause a spike in errors compared to a previous version. DevOps engineer See a list of domains and URLs associated with HTTP errors and network failures, so you can focus on the ones that are causing errors and filter out status codes that are too noisy for your alerts. Mobile developer Find out if there are frontend or backend problems affecting your mobile app (even without an error alert going off) so that you can address them in a new version. Support engineer View the errors and session attributes (geography, connection type, device, app version) associated with an error so that you can help customers with their issues. Find and use the HTTP errors page There are two ways to get to the HTTP errors page: Go to one.newrelic.com > Mobile > (select an app) > Network > Network errors. From a mobile app's Overview page in mobile monitoring, select the HTTP errors/network failures chart title link. From the HTTP errors page, investigate HTTP request and network failures: Use any standard page functions to look for trends in Errors and failures charts. Target specific types of errors and failures by grouping, sorting, and filtering the data. Find anomalies in your request errors with HTTP error profiles. Select an error or failure to view details for it. You can also define NRQL alerts that are focused on error types for your critical services or query your app data. Group, sort, and filter errors and failures If you want to do this... Do this... Change how the page groups and sorts errors and network failures Make selections from the Group by and Sort by dropdowns. By default, the Network errors page is grouped by request domain and sorted by errors and failures. Filter for specific errors and network failures Select an error or failure from the Errors and failures list and/or select multiple filters from the Filter dropdown. See which filters you applied or remove filters The filters you select display next to the filter dropdown. To clear filters, select the X next to the filter you want to clear. Change the time window Select a new time period from the Time picker dropdown. View information for one specific app version Select the version that you want to see charts and lists for in the Versions dropdown. HTTP error profiles Error profiles provide visual details about significant differences in the frequency of different values for HTTP error events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of other errors This helps you take more of the guesswork out of resolving your mobile application's HTTP errors. You can more easily determine if you safely ignore the error, or if you should attempt to resolve the error with a new deployment, code change, customer communication or other actions. View more details about a specific error To view details about an error or failure, select the Request URL link to be directed to the Error summary page. From the Error summary page, you can view the version information, request attributes, and Response body, as well as get a breakdown of error types for the request URL. View and share error data with query builder To explore the data behind any of the charts or lists on the HTTP errors/requests page: Select for any chart. Select View query and then View in Insights. This will open the query builder. From the query builder, you can add the error data to a dashboard and share it via a permalink. To dig deeper into the error data, query your data for the following events and attributes: MobileRequestError events and attributes MobileRequest events and attributes View legacy HTTP errors UI page Accounts that do not have an Enterprise-level subscription see a different HTTP Errors UI page: The Errors page includes details about HTTP errors (403, 404, 422, 500, 502, etc.) and network failures for your hosts; for example: Secure connection failed Timed out Cannot find host Not connected to Internet Cannot connect to host View the Errors page To view HTTP errors or network failures for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Network > Errors. To change the view to errors or failures, select the Sort by option. To hide low-usage hosts, select the Hide < 1% throughput option. To limit information to a specific version of your app, or to change the time period, select your choice from the Versions menu or the time picker below the menu bar. To view details for a specific host, HTTP status error, or network failure, select its name. Use any of our standard user interface functions to drill down into detailed information. Error trace details Mobile monitoring will capture the response details from HTTP requests that return a 400 or 500 level status code. In addition, error messages generated from Android apps will include a stack trace. To view details about an error trace on the Errors page, select its request URL link. From here you can: View the response body. Share the error details with others by email. Delete or hide the error. The errors chart also appears on the selected mobile app's Overview page. If the chart shows errors, you can select its HTTP errors/network failures title or select anywhere on the Overview page's chart to go directly to this Errors page. View error data in query builder To dig deeper into your request data, use the query builder to query and chart the MobileRequest events and attributes. Unknown errors or URL errors The mobile agents maintain a list of exception types. In some cases, custom exceptions thrown by applications fall outside of this list. When this happens, Unknown may appear in the mobile Errors page. If you find Unknown in your list of errors and need assistance in researching which exception types are being missed, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.46832,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View legacy HTTP errors <em>UI</em> <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em>&#x27;s HTTP errors <em>page</em> helps you to better understand HTTP errors and network failures associated with your <em>mobile</em> <em>app</em>, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors <em>page</em> to... Manager"
      },
      "id": "603e8eb428ccbcd174eba791"
    },
    {
      "sections": [
        "Mobile apps index",
        "View your list of mobile apps",
        "Standard menu functions"
      ],
      "title": "Mobile apps index",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Mobile app pages"
      ],
      "external_id": "38ff00ca55b0ca25a0ad534b57e02b01f4040c97",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/mobile-apps-index/",
      "published_at": "2021-12-04T18:03:02Z",
      "updated_at": "2021-08-27T07:51:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring UI includes a mobile app index that shows a list of your monitored apps and important summary information about them. View your list of mobile apps To see the mobile apps index, go to [one.newrelic.com > Explorer > Mobile applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. Alternatively, go to one.newrelic.com > Mobile. The index of available mobile apps includes a colored health status indicating: Green = Normal Yellow = Warning Red = Critical Gray = Not reporting data Standard menu functions To view details for a specific app, select it from the index. Here are some other functions available from the index: If you want to... Do this... View the app's status Mouse over the mobile app's colored health status indicator. If the health status indicator is gray and no data is being reported, you likely need to finish installing mobile monitoring. Monitor another app Select Add more. See the app's metadata To see the app's metadata, including its app ID, entity GUID, and more, click the icon next to the application name. For more about UI functions, see Basic UI functions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.45697,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Mobile</em> <em>apps</em> index",
        "sections": "<em>Mobile</em> <em>apps</em> index",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": " status indicator is gray and no data is being reported, you likely need to finish installing <em>mobile</em> <em>monitoring</em>. <em>Monitor</em> another <em>app</em> Select Add more. See the <em>app</em>&#x27;s metadata To see the <em>app</em>&#x27;s metadata, including its <em>app</em> ID, entity GUID, and more, click the icon next to the application name. For more about <em>UI</em> functions, see Basic <em>UI</em> functions."
      },
      "id": "604537fc64441f7903378f35"
    },
    {
      "sections": [
        "OS versions page",
        "Viewing the OS versions page",
        "Viewing drill-down details"
      ],
      "title": "OS versions page",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Mobile app pages"
      ],
      "external_id": "370b6f1584d001a17f414066097692b9189e1a50",
      "image": "https://docs.newrelic.com/static/8d84abf966c2f4b75ca298b362995c0e/c1b63/os-version-pic_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/os-versions-page/",
      "published_at": "2021-12-04T18:03:34Z",
      "updated_at": "2021-07-09T11:46:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The OS versions page for mobile monitoring provides performance details about the top operating system versions hosting your mobile application, such as iOS and Android. Charts compare the OS versions by: HTTP request time Network failures Requests per minute Active devices From here you can drill down into details by a major or minor OS version (for example, iOS 8, iOS 7.1.1, Android 4.2.2). Viewing the OS versions page one.newrelic.com > Mobile > (select an app) > App > OS versions: Use this page to view, sort, or drill down into detailed information about the top five types of operation system versions using your mobile app. To view performance details about the operating system versions for your mobile app users: Go to one.newrelic.com > Mobile > (select an app) > App > OS versions. To select the mobile app versions or time period, use the Versions menu and time picker below the UI menu bar. Optional: Select the Sort by and Hide < 1% throughput options. To expand or collapse the list of operating systems to include versions, select the operating system's name (for example, iOS 7). Viewing drill-down details To drill down into detailed information, use any of our standard user interface functions and page functions to drill down into detailed information. In addition: To view details for the minor and point releases of a major OS version (including interaction time, HTTP request times, network failures, active devices, and slowest traces or all subversions), select a major OS version from the list. To view details for a specific OS version, select its name from the expanded OS list. To view trace details a slow transaction (if available), select its link. For more information, see Interactions page. To return to the main OS versions page, select the Close (X) button.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 179.38084,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "OS versions <em>page</em>",
        "sections": "OS versions <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "The OS versions <em>page</em> for <em>mobile</em> <em>monitoring</em> provides performance details about the top operating system versions hosting your <em>mobile</em> application, such as iOS and Android. Charts compare the OS versions by: HTTP request time Network failures Requests per minute Active devices From here you can drill"
      },
      "id": "603eaee9e7b9d260112a0809"
    }
  ],
  "/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/analyze-network-requests-using-mobilerequest-event-data": [
    {
      "sections": [
        "HTTP errors: Network failure analysis",
        "Find and use the HTTP errors page",
        "Group, sort, and filter errors and failures",
        "HTTP error profiles",
        "View more details about a specific error",
        "View and share error data with query builder",
        "View legacy HTTP errors UI page",
        "View the Errors page",
        "Error trace details",
        "View error data in query builder",
        "Unknown errors or URL errors"
      ],
      "title": "HTTP errors: Network failure analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "04631e122b061663c6fd261b605202654aadcf96",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-errors-network-failure-analysis/",
      "published_at": "2021-12-04T15:48:48Z",
      "updated_at": "2021-12-04T15:48:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring's HTTP errors page helps you to better understand HTTP errors and network failures associated with your mobile app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager See a list of errors and failures so you can coordinate mobile app teams with backend teams and share the data they need to fix issues. QA engineer Make sure that a new version of your app does not cause a spike in errors compared to a previous version. DevOps engineer See a list of domains and URLs associated with HTTP errors and network failures, so you can focus on the ones that are causing errors and filter out status codes that are too noisy for your alerts. Mobile developer Find out if there are frontend or backend problems affecting your mobile app (even without an error alert going off) so that you can address them in a new version. Support engineer View the errors and session attributes (geography, connection type, device, app version) associated with an error so that you can help customers with their issues. Find and use the HTTP errors page There are two ways to get to the HTTP errors page: Go to one.newrelic.com > Mobile > (select an app) > Network > Network errors. From a mobile app's Overview page in mobile monitoring, select the HTTP errors/network failures chart title link. From the HTTP errors page, investigate HTTP request and network failures: Use any standard page functions to look for trends in Errors and failures charts. Target specific types of errors and failures by grouping, sorting, and filtering the data. Find anomalies in your request errors with HTTP error profiles. Select an error or failure to view details for it. You can also define NRQL alerts that are focused on error types for your critical services or query your app data. Group, sort, and filter errors and failures If you want to do this... Do this... Change how the page groups and sorts errors and network failures Make selections from the Group by and Sort by dropdowns. By default, the Network errors page is grouped by request domain and sorted by errors and failures. Filter for specific errors and network failures Select an error or failure from the Errors and failures list and/or select multiple filters from the Filter dropdown. See which filters you applied or remove filters The filters you select display next to the filter dropdown. To clear filters, select the X next to the filter you want to clear. Change the time window Select a new time period from the Time picker dropdown. View information for one specific app version Select the version that you want to see charts and lists for in the Versions dropdown. HTTP error profiles Error profiles provide visual details about significant differences in the frequency of different values for HTTP error events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of other errors This helps you take more of the guesswork out of resolving your mobile application's HTTP errors. You can more easily determine if you safely ignore the error, or if you should attempt to resolve the error with a new deployment, code change, customer communication or other actions. View more details about a specific error To view details about an error or failure, select the Request URL link to be directed to the Error summary page. From the Error summary page, you can view the version information, request attributes, and Response body, as well as get a breakdown of error types for the request URL. View and share error data with query builder To explore the data behind any of the charts or lists on the HTTP errors/requests page: Select for any chart. Select View query and then View in Insights. This will open the query builder. From the query builder, you can add the error data to a dashboard and share it via a permalink. To dig deeper into the error data, query your data for the following events and attributes: MobileRequestError events and attributes MobileRequest events and attributes View legacy HTTP errors UI page Accounts that do not have an Enterprise-level subscription see a different HTTP Errors UI page: The Errors page includes details about HTTP errors (403, 404, 422, 500, 502, etc.) and network failures for your hosts; for example: Secure connection failed Timed out Cannot find host Not connected to Internet Cannot connect to host View the Errors page To view HTTP errors or network failures for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Network > Errors. To change the view to errors or failures, select the Sort by option. To hide low-usage hosts, select the Hide < 1% throughput option. To limit information to a specific version of your app, or to change the time period, select your choice from the Versions menu or the time picker below the menu bar. To view details for a specific host, HTTP status error, or network failure, select its name. Use any of our standard user interface functions to drill down into detailed information. Error trace details Mobile monitoring will capture the response details from HTTP requests that return a 400 or 500 level status code. In addition, error messages generated from Android apps will include a stack trace. To view details about an error trace on the Errors page, select its request URL link. From here you can: View the response body. Share the error details with others by email. Delete or hide the error. The errors chart also appears on the selected mobile app's Overview page. If the chart shows errors, you can select its HTTP errors/network failures title or select anywhere on the Overview page's chart to go directly to this Errors page. View error data in query builder To dig deeper into your request data, use the query builder to query and chart the MobileRequest events and attributes. Unknown errors or URL errors The mobile agents maintain a list of exception types. In some cases, custom exceptions thrown by applications fall outside of this list. When this happens, Unknown may appear in the mobile Errors page. If you find Unknown in your list of errors and need assistance in researching which exception types are being missed, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.20322,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "HTTP errors: <em>Network</em> failure analysis",
        "sections": "View legacy HTTP errors <em>UI</em> <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em>&#x27;s HTTP errors <em>page</em> helps you to better understand HTTP errors and <em>network</em> failures associated with your <em>mobile</em> app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors <em>page</em> to... Manager"
      },
      "id": "603e8eb428ccbcd174eba791"
    },
    {
      "sections": [
        "HTTP requests page",
        "Find and use HTTP requests page",
        "Understand HTTP request data",
        "Response time chart",
        "HTTP errors and network failures chart",
        "Total requests",
        "Group, sort, and filter HTTP requests",
        "View and share HTTP request data",
        "View legacy HTTP requests UI page",
        "View legacy HTTP requests UI",
        "View legacy drill-down details",
        "View legacy request data"
      ],
      "title": "HTTP requests page",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "56c27e3a1cad7439b752d38b4d00a60ab98f0e10",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-requests-page/",
      "published_at": "2021-12-04T16:35:47Z",
      "updated_at": "2021-10-07T20:06:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring has an HTTP requests UI page that helps you better understand HTTP requests associated with your mobile app and how those network calls are affecting performance. This document describes the Enterprise-level HTTP requests page. Non-Enterprise accounts will see the legacy HTTP requests page. Find and use HTTP requests page To view mobile monitoring's HTTP requests page: Go to one.newrelic.com > Mobile > (select an app) > Network > HTTP requests. Use our standard page functions to look for trends in the HTTP analysis charts. Target specific request and response attributes by grouping, sorting, and filtering the data. Understand HTTP request data Here are some places to find the most important HTTP request information: Response time chart The response time chart shows how your app's network calls are performing across percentiles. Use it to compare the average response time to the 1st, 50th, and 99th percentile. Percentiles let you filter out outliers that may be making your average response time higher than expected. HTTP errors and network failures chart This chart shows the unsuccessful network calls your app is experiencing. Select the chart title to go to the HTTP errors page for more detail on the errors and failures. Total requests Sort by Total requests to identify which network requests are being used most frequently. The reason this can be helpful is because your slowest network calls may be only infrequently used, while more frequently used requests might be more worthy of optimization even if they are not the slowest. For a description of the non-Enterprise HTTP requests UI page, see Legacy HTTP requests. Group, sort, and filter HTTP requests If you want to... Do this... Group and sort HTTP requests in different ways Make selections from the Group by and Sort by dropdowns. By default, the HTTP requests page is grouped by request domain and sorted by average response time. Filter for specific HTTP requests Select an HTTP request from the Errors and failures list and/or select multiple filters from the Filter dropdown. See or remove applied filters The filters you select are displayed next to the filter dropdown. To clear filters, select the X icon on the filter you want to clear. Change the time window Select a new time period from the time picker dropdown. View information for a specific app version Using the Versions dropdown, select the version for which you want to see charts and lists. View and share HTTP request data To view any HTTP requests chart in Insights: Select for any chart. Select View query > View in Insights. Optional: Add the data to a dashboard, or share it by using a permalink. To delve deeper into your request data, query MobileRequest events and attributes. View legacy HTTP requests UI page Accounts that do not have an Enterprise-level subscription see a different HTTP requests UI page: View legacy HTTP requests UI To view your top five domains or drill down into details about specific HTTP requests: Go to one.newrelic.com > (select an app) > Network > HTTP requests. Optional: Select the Sort by and Hide < 1% throughput options. To view or hide all requests made by your app, select Expand all or Collapse all. To view details for a specific host or HTTP request (including request time, average throughput, and data transfer), select its name. View legacy drill-down details Use any of New Relic's standard page functions to drill down into detailed information. In addition, from the HTTP requests page, you can drill down into detailed information about specific requests, including: Top five HTTP request times Average throughput Average data transfer To view legacy details: one.newrelic.com > Mobile > (select an app) > Network > HTTP requests > (select a request): > Switch to legacy requests. If you want to... Do this View information to a specific version of your app Select Versions from the side bar (if applicable). Change the time period Use the time picker below the New Relic menu bar. View legacy request data You can dig deeper into your request data by querying and charting the MobileRequest event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 188.6442,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "HTTP requests <em>page</em>",
        "sections": "View legacy HTTP requests <em>UI</em> <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em> has an HTTP requests <em>UI</em> <em>page</em> that helps you better understand HTTP requests associated with your <em>mobile</em> app and how those <em>network</em> calls are affecting performance. This document describes the Enterprise-level HTTP requests <em>page</em>. Non-Enterprise accounts will see the legacy HTTP"
      },
      "id": "60450de028ccbc42662c6083"
    },
    {
      "sections": [
        "Map page for mobile apps (deprecated)",
        "Important",
        "View a map of your mobile app services"
      ],
      "title": "Map page for mobile apps (deprecated)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "a082467948ce481c9ecb544d26a802e8d5f3894b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/map-page-mobile-apps-deprecated/",
      "published_at": "2021-12-04T16:36:31Z",
      "updated_at": "2021-09-14T20:45:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important The mobile Maps UI is deprecated since December 22, 2020. Service maps are available in New Relic One's left navigation for each mobile entity, and they are a better way to visualize and customize representations of your architecture. For more information, see our Explorers Hub post. Maps help you find performance problems for a mobile app or its services. This gives you a clear picture of your app's relationships to other services and the influence of each service on the others. If one service fails, you can see at a glance which other services are affected. View a map of your mobile app services To view your mobile app and its related services as an architectural map, go to one.newrelic.com > Mobile > (select a mobile app) > Monitor > Service map. For more information, see the service maps documentation. If you need to use the deprecated mobile Map page, follow these steps: Go to one.newrelic.com > Mobile > (select an app) > Network > Map. To view HTTP request details for a service, select its name. To view details for an app monitored by APM that is related to the service, select the service's name below the associated hostname. To view throughput details as a chart, select the icon or the cpm bar below the service's name. To view detailed metrics for a service, mouse over the throughput chart. The Map page for mobile monitoring gives an architectural view of your mobile app and the services it uses,",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.24562,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Map <em>page</em> for <em>mobile</em> apps (deprecated)",
        "sections": "Map <em>page</em> for <em>mobile</em> apps (deprecated)",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": " <em>mobile</em> app services To view your <em>mobile</em> app and its related services as an architectural map, go to one.newrelic.com &gt; <em>Mobile</em> &gt; (select a <em>mobile</em> app) &gt; <em>Monitor</em> &gt; Service map. For more information, see the service maps documentation. If you need to use the deprecated <em>mobile</em> Map <em>page</em>, follow these steps"
      },
      "id": "6044141828ccbc0f862c60ae"
    }
  ],
  "/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/carriers-page": [
    {
      "sections": [
        "HTTP errors: Network failure analysis",
        "Find and use the HTTP errors page",
        "Group, sort, and filter errors and failures",
        "HTTP error profiles",
        "View more details about a specific error",
        "View and share error data with query builder",
        "View legacy HTTP errors UI page",
        "View the Errors page",
        "Error trace details",
        "View error data in query builder",
        "Unknown errors or URL errors"
      ],
      "title": "HTTP errors: Network failure analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "04631e122b061663c6fd261b605202654aadcf96",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-errors-network-failure-analysis/",
      "published_at": "2021-12-04T15:48:48Z",
      "updated_at": "2021-12-04T15:48:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring's HTTP errors page helps you to better understand HTTP errors and network failures associated with your mobile app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager See a list of errors and failures so you can coordinate mobile app teams with backend teams and share the data they need to fix issues. QA engineer Make sure that a new version of your app does not cause a spike in errors compared to a previous version. DevOps engineer See a list of domains and URLs associated with HTTP errors and network failures, so you can focus on the ones that are causing errors and filter out status codes that are too noisy for your alerts. Mobile developer Find out if there are frontend or backend problems affecting your mobile app (even without an error alert going off) so that you can address them in a new version. Support engineer View the errors and session attributes (geography, connection type, device, app version) associated with an error so that you can help customers with their issues. Find and use the HTTP errors page There are two ways to get to the HTTP errors page: Go to one.newrelic.com > Mobile > (select an app) > Network > Network errors. From a mobile app's Overview page in mobile monitoring, select the HTTP errors/network failures chart title link. From the HTTP errors page, investigate HTTP request and network failures: Use any standard page functions to look for trends in Errors and failures charts. Target specific types of errors and failures by grouping, sorting, and filtering the data. Find anomalies in your request errors with HTTP error profiles. Select an error or failure to view details for it. You can also define NRQL alerts that are focused on error types for your critical services or query your app data. Group, sort, and filter errors and failures If you want to do this... Do this... Change how the page groups and sorts errors and network failures Make selections from the Group by and Sort by dropdowns. By default, the Network errors page is grouped by request domain and sorted by errors and failures. Filter for specific errors and network failures Select an error or failure from the Errors and failures list and/or select multiple filters from the Filter dropdown. See which filters you applied or remove filters The filters you select display next to the filter dropdown. To clear filters, select the X next to the filter you want to clear. Change the time window Select a new time period from the Time picker dropdown. View information for one specific app version Select the version that you want to see charts and lists for in the Versions dropdown. HTTP error profiles Error profiles provide visual details about significant differences in the frequency of different values for HTTP error events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of other errors This helps you take more of the guesswork out of resolving your mobile application's HTTP errors. You can more easily determine if you safely ignore the error, or if you should attempt to resolve the error with a new deployment, code change, customer communication or other actions. View more details about a specific error To view details about an error or failure, select the Request URL link to be directed to the Error summary page. From the Error summary page, you can view the version information, request attributes, and Response body, as well as get a breakdown of error types for the request URL. View and share error data with query builder To explore the data behind any of the charts or lists on the HTTP errors/requests page: Select for any chart. Select View query and then View in Insights. This will open the query builder. From the query builder, you can add the error data to a dashboard and share it via a permalink. To dig deeper into the error data, query your data for the following events and attributes: MobileRequestError events and attributes MobileRequest events and attributes View legacy HTTP errors UI page Accounts that do not have an Enterprise-level subscription see a different HTTP Errors UI page: The Errors page includes details about HTTP errors (403, 404, 422, 500, 502, etc.) and network failures for your hosts; for example: Secure connection failed Timed out Cannot find host Not connected to Internet Cannot connect to host View the Errors page To view HTTP errors or network failures for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Network > Errors. To change the view to errors or failures, select the Sort by option. To hide low-usage hosts, select the Hide < 1% throughput option. To limit information to a specific version of your app, or to change the time period, select your choice from the Versions menu or the time picker below the menu bar. To view details for a specific host, HTTP status error, or network failure, select its name. Use any of our standard user interface functions to drill down into detailed information. Error trace details Mobile monitoring will capture the response details from HTTP requests that return a 400 or 500 level status code. In addition, error messages generated from Android apps will include a stack trace. To view details about an error trace on the Errors page, select its request URL link. From here you can: View the response body. Share the error details with others by email. Delete or hide the error. The errors chart also appears on the selected mobile app's Overview page. If the chart shows errors, you can select its HTTP errors/network failures title or select anywhere on the Overview page's chart to go directly to this Errors page. View error data in query builder To dig deeper into your request data, use the query builder to query and chart the MobileRequest events and attributes. Unknown errors or URL errors The mobile agents maintain a list of exception types. In some cases, custom exceptions thrown by applications fall outside of this list. When this happens, Unknown may appear in the mobile Errors page. If you find Unknown in your list of errors and need assistance in researching which exception types are being missed, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.20306,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "HTTP errors: <em>Network</em> failure analysis",
        "sections": "View legacy HTTP errors <em>UI</em> <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em>&#x27;s HTTP errors <em>page</em> helps you to better understand HTTP errors and <em>network</em> failures associated with your <em>mobile</em> app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors <em>page</em> to... Manager"
      },
      "id": "603e8eb428ccbcd174eba791"
    },
    {
      "sections": [
        "HTTP requests page",
        "Find and use HTTP requests page",
        "Understand HTTP request data",
        "Response time chart",
        "HTTP errors and network failures chart",
        "Total requests",
        "Group, sort, and filter HTTP requests",
        "View and share HTTP request data",
        "View legacy HTTP requests UI page",
        "View legacy HTTP requests UI",
        "View legacy drill-down details",
        "View legacy request data"
      ],
      "title": "HTTP requests page",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "56c27e3a1cad7439b752d38b4d00a60ab98f0e10",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-requests-page/",
      "published_at": "2021-12-04T16:35:47Z",
      "updated_at": "2021-10-07T20:06:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring has an HTTP requests UI page that helps you better understand HTTP requests associated with your mobile app and how those network calls are affecting performance. This document describes the Enterprise-level HTTP requests page. Non-Enterprise accounts will see the legacy HTTP requests page. Find and use HTTP requests page To view mobile monitoring's HTTP requests page: Go to one.newrelic.com > Mobile > (select an app) > Network > HTTP requests. Use our standard page functions to look for trends in the HTTP analysis charts. Target specific request and response attributes by grouping, sorting, and filtering the data. Understand HTTP request data Here are some places to find the most important HTTP request information: Response time chart The response time chart shows how your app's network calls are performing across percentiles. Use it to compare the average response time to the 1st, 50th, and 99th percentile. Percentiles let you filter out outliers that may be making your average response time higher than expected. HTTP errors and network failures chart This chart shows the unsuccessful network calls your app is experiencing. Select the chart title to go to the HTTP errors page for more detail on the errors and failures. Total requests Sort by Total requests to identify which network requests are being used most frequently. The reason this can be helpful is because your slowest network calls may be only infrequently used, while more frequently used requests might be more worthy of optimization even if they are not the slowest. For a description of the non-Enterprise HTTP requests UI page, see Legacy HTTP requests. Group, sort, and filter HTTP requests If you want to... Do this... Group and sort HTTP requests in different ways Make selections from the Group by and Sort by dropdowns. By default, the HTTP requests page is grouped by request domain and sorted by average response time. Filter for specific HTTP requests Select an HTTP request from the Errors and failures list and/or select multiple filters from the Filter dropdown. See or remove applied filters The filters you select are displayed next to the filter dropdown. To clear filters, select the X icon on the filter you want to clear. Change the time window Select a new time period from the time picker dropdown. View information for a specific app version Using the Versions dropdown, select the version for which you want to see charts and lists. View and share HTTP request data To view any HTTP requests chart in Insights: Select for any chart. Select View query > View in Insights. Optional: Add the data to a dashboard, or share it by using a permalink. To delve deeper into your request data, query MobileRequest events and attributes. View legacy HTTP requests UI page Accounts that do not have an Enterprise-level subscription see a different HTTP requests UI page: View legacy HTTP requests UI To view your top five domains or drill down into details about specific HTTP requests: Go to one.newrelic.com > (select an app) > Network > HTTP requests. Optional: Select the Sort by and Hide < 1% throughput options. To view or hide all requests made by your app, select Expand all or Collapse all. To view details for a specific host or HTTP request (including request time, average throughput, and data transfer), select its name. View legacy drill-down details Use any of New Relic's standard page functions to drill down into detailed information. In addition, from the HTTP requests page, you can drill down into detailed information about specific requests, including: Top five HTTP request times Average throughput Average data transfer To view legacy details: one.newrelic.com > Mobile > (select an app) > Network > HTTP requests > (select a request): > Switch to legacy requests. If you want to... Do this View information to a specific version of your app Select Versions from the side bar (if applicable). Change the time period Use the time picker below the New Relic menu bar. View legacy request data You can dig deeper into your request data by querying and charting the MobileRequest event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 188.6442,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "HTTP requests <em>page</em>",
        "sections": "View legacy HTTP requests <em>UI</em> <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em> has an HTTP requests <em>UI</em> <em>page</em> that helps you better understand HTTP requests associated with your <em>mobile</em> app and how those <em>network</em> calls are affecting performance. This document describes the Enterprise-level HTTP requests <em>page</em>. Non-Enterprise accounts will see the legacy HTTP"
      },
      "id": "60450de028ccbc42662c6083"
    },
    {
      "sections": [
        "Map page for mobile apps (deprecated)",
        "Important",
        "View a map of your mobile app services"
      ],
      "title": "Map page for mobile apps (deprecated)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "a082467948ce481c9ecb544d26a802e8d5f3894b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/map-page-mobile-apps-deprecated/",
      "published_at": "2021-12-04T16:36:31Z",
      "updated_at": "2021-09-14T20:45:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important The mobile Maps UI is deprecated since December 22, 2020. Service maps are available in New Relic One's left navigation for each mobile entity, and they are a better way to visualize and customize representations of your architecture. For more information, see our Explorers Hub post. Maps help you find performance problems for a mobile app or its services. This gives you a clear picture of your app's relationships to other services and the influence of each service on the others. If one service fails, you can see at a glance which other services are affected. View a map of your mobile app services To view your mobile app and its related services as an architectural map, go to one.newrelic.com > Mobile > (select a mobile app) > Monitor > Service map. For more information, see the service maps documentation. If you need to use the deprecated mobile Map page, follow these steps: Go to one.newrelic.com > Mobile > (select an app) > Network > Map. To view HTTP request details for a service, select its name. To view details for an app monitored by APM that is related to the service, select the service's name below the associated hostname. To view throughput details as a chart, select the icon or the cpm bar below the service's name. To view detailed metrics for a service, mouse over the throughput chart. The Map page for mobile monitoring gives an architectural view of your mobile app and the services it uses,",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.24562,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Map <em>page</em> for <em>mobile</em> apps (deprecated)",
        "sections": "Map <em>page</em> for <em>mobile</em> apps (deprecated)",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": " <em>mobile</em> app services To view your <em>mobile</em> app and its related services as an architectural map, go to one.newrelic.com &gt; <em>Mobile</em> &gt; (select a <em>mobile</em> app) &gt; <em>Monitor</em> &gt; Service map. For more information, see the service maps documentation. If you need to use the deprecated <em>mobile</em> Map <em>page</em>, follow these steps"
      },
      "id": "6044141828ccbc0f862c60ae"
    }
  ],
  "/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/connection-types-page": [
    {
      "sections": [
        "HTTP errors: Network failure analysis",
        "Find and use the HTTP errors page",
        "Group, sort, and filter errors and failures",
        "HTTP error profiles",
        "View more details about a specific error",
        "View and share error data with query builder",
        "View legacy HTTP errors UI page",
        "View the Errors page",
        "Error trace details",
        "View error data in query builder",
        "Unknown errors or URL errors"
      ],
      "title": "HTTP errors: Network failure analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "04631e122b061663c6fd261b605202654aadcf96",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-errors-network-failure-analysis/",
      "published_at": "2021-12-04T15:48:48Z",
      "updated_at": "2021-12-04T15:48:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring's HTTP errors page helps you to better understand HTTP errors and network failures associated with your mobile app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager See a list of errors and failures so you can coordinate mobile app teams with backend teams and share the data they need to fix issues. QA engineer Make sure that a new version of your app does not cause a spike in errors compared to a previous version. DevOps engineer See a list of domains and URLs associated with HTTP errors and network failures, so you can focus on the ones that are causing errors and filter out status codes that are too noisy for your alerts. Mobile developer Find out if there are frontend or backend problems affecting your mobile app (even without an error alert going off) so that you can address them in a new version. Support engineer View the errors and session attributes (geography, connection type, device, app version) associated with an error so that you can help customers with their issues. Find and use the HTTP errors page There are two ways to get to the HTTP errors page: Go to one.newrelic.com > Mobile > (select an app) > Network > Network errors. From a mobile app's Overview page in mobile monitoring, select the HTTP errors/network failures chart title link. From the HTTP errors page, investigate HTTP request and network failures: Use any standard page functions to look for trends in Errors and failures charts. Target specific types of errors and failures by grouping, sorting, and filtering the data. Find anomalies in your request errors with HTTP error profiles. Select an error or failure to view details for it. You can also define NRQL alerts that are focused on error types for your critical services or query your app data. Group, sort, and filter errors and failures If you want to do this... Do this... Change how the page groups and sorts errors and network failures Make selections from the Group by and Sort by dropdowns. By default, the Network errors page is grouped by request domain and sorted by errors and failures. Filter for specific errors and network failures Select an error or failure from the Errors and failures list and/or select multiple filters from the Filter dropdown. See which filters you applied or remove filters The filters you select display next to the filter dropdown. To clear filters, select the X next to the filter you want to clear. Change the time window Select a new time period from the Time picker dropdown. View information for one specific app version Select the version that you want to see charts and lists for in the Versions dropdown. HTTP error profiles Error profiles provide visual details about significant differences in the frequency of different values for HTTP error events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of other errors This helps you take more of the guesswork out of resolving your mobile application's HTTP errors. You can more easily determine if you safely ignore the error, or if you should attempt to resolve the error with a new deployment, code change, customer communication or other actions. View more details about a specific error To view details about an error or failure, select the Request URL link to be directed to the Error summary page. From the Error summary page, you can view the version information, request attributes, and Response body, as well as get a breakdown of error types for the request URL. View and share error data with query builder To explore the data behind any of the charts or lists on the HTTP errors/requests page: Select for any chart. Select View query and then View in Insights. This will open the query builder. From the query builder, you can add the error data to a dashboard and share it via a permalink. To dig deeper into the error data, query your data for the following events and attributes: MobileRequestError events and attributes MobileRequest events and attributes View legacy HTTP errors UI page Accounts that do not have an Enterprise-level subscription see a different HTTP Errors UI page: The Errors page includes details about HTTP errors (403, 404, 422, 500, 502, etc.) and network failures for your hosts; for example: Secure connection failed Timed out Cannot find host Not connected to Internet Cannot connect to host View the Errors page To view HTTP errors or network failures for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Network > Errors. To change the view to errors or failures, select the Sort by option. To hide low-usage hosts, select the Hide < 1% throughput option. To limit information to a specific version of your app, or to change the time period, select your choice from the Versions menu or the time picker below the menu bar. To view details for a specific host, HTTP status error, or network failure, select its name. Use any of our standard user interface functions to drill down into detailed information. Error trace details Mobile monitoring will capture the response details from HTTP requests that return a 400 or 500 level status code. In addition, error messages generated from Android apps will include a stack trace. To view details about an error trace on the Errors page, select its request URL link. From here you can: View the response body. Share the error details with others by email. Delete or hide the error. The errors chart also appears on the selected mobile app's Overview page. If the chart shows errors, you can select its HTTP errors/network failures title or select anywhere on the Overview page's chart to go directly to this Errors page. View error data in query builder To dig deeper into your request data, use the query builder to query and chart the MobileRequest events and attributes. Unknown errors or URL errors The mobile agents maintain a list of exception types. In some cases, custom exceptions thrown by applications fall outside of this list. When this happens, Unknown may appear in the mobile Errors page. If you find Unknown in your list of errors and need assistance in researching which exception types are being missed, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.20306,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "HTTP errors: <em>Network</em> failure analysis",
        "sections": "View legacy HTTP errors <em>UI</em> <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em>&#x27;s HTTP errors <em>page</em> helps you to better understand HTTP errors and <em>network</em> failures associated with your <em>mobile</em> app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors <em>page</em> to... Manager"
      },
      "id": "603e8eb428ccbcd174eba791"
    },
    {
      "sections": [
        "HTTP requests page",
        "Find and use HTTP requests page",
        "Understand HTTP request data",
        "Response time chart",
        "HTTP errors and network failures chart",
        "Total requests",
        "Group, sort, and filter HTTP requests",
        "View and share HTTP request data",
        "View legacy HTTP requests UI page",
        "View legacy HTTP requests UI",
        "View legacy drill-down details",
        "View legacy request data"
      ],
      "title": "HTTP requests page",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "56c27e3a1cad7439b752d38b4d00a60ab98f0e10",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-requests-page/",
      "published_at": "2021-12-04T16:35:47Z",
      "updated_at": "2021-10-07T20:06:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring has an HTTP requests UI page that helps you better understand HTTP requests associated with your mobile app and how those network calls are affecting performance. This document describes the Enterprise-level HTTP requests page. Non-Enterprise accounts will see the legacy HTTP requests page. Find and use HTTP requests page To view mobile monitoring's HTTP requests page: Go to one.newrelic.com > Mobile > (select an app) > Network > HTTP requests. Use our standard page functions to look for trends in the HTTP analysis charts. Target specific request and response attributes by grouping, sorting, and filtering the data. Understand HTTP request data Here are some places to find the most important HTTP request information: Response time chart The response time chart shows how your app's network calls are performing across percentiles. Use it to compare the average response time to the 1st, 50th, and 99th percentile. Percentiles let you filter out outliers that may be making your average response time higher than expected. HTTP errors and network failures chart This chart shows the unsuccessful network calls your app is experiencing. Select the chart title to go to the HTTP errors page for more detail on the errors and failures. Total requests Sort by Total requests to identify which network requests are being used most frequently. The reason this can be helpful is because your slowest network calls may be only infrequently used, while more frequently used requests might be more worthy of optimization even if they are not the slowest. For a description of the non-Enterprise HTTP requests UI page, see Legacy HTTP requests. Group, sort, and filter HTTP requests If you want to... Do this... Group and sort HTTP requests in different ways Make selections from the Group by and Sort by dropdowns. By default, the HTTP requests page is grouped by request domain and sorted by average response time. Filter for specific HTTP requests Select an HTTP request from the Errors and failures list and/or select multiple filters from the Filter dropdown. See or remove applied filters The filters you select are displayed next to the filter dropdown. To clear filters, select the X icon on the filter you want to clear. Change the time window Select a new time period from the time picker dropdown. View information for a specific app version Using the Versions dropdown, select the version for which you want to see charts and lists. View and share HTTP request data To view any HTTP requests chart in Insights: Select for any chart. Select View query > View in Insights. Optional: Add the data to a dashboard, or share it by using a permalink. To delve deeper into your request data, query MobileRequest events and attributes. View legacy HTTP requests UI page Accounts that do not have an Enterprise-level subscription see a different HTTP requests UI page: View legacy HTTP requests UI To view your top five domains or drill down into details about specific HTTP requests: Go to one.newrelic.com > (select an app) > Network > HTTP requests. Optional: Select the Sort by and Hide < 1% throughput options. To view or hide all requests made by your app, select Expand all or Collapse all. To view details for a specific host or HTTP request (including request time, average throughput, and data transfer), select its name. View legacy drill-down details Use any of New Relic's standard page functions to drill down into detailed information. In addition, from the HTTP requests page, you can drill down into detailed information about specific requests, including: Top five HTTP request times Average throughput Average data transfer To view legacy details: one.newrelic.com > Mobile > (select an app) > Network > HTTP requests > (select a request): > Switch to legacy requests. If you want to... Do this View information to a specific version of your app Select Versions from the side bar (if applicable). Change the time period Use the time picker below the New Relic menu bar. View legacy request data You can dig deeper into your request data by querying and charting the MobileRequest event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 188.6442,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "HTTP requests <em>page</em>",
        "sections": "View legacy HTTP requests <em>UI</em> <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em> has an HTTP requests <em>UI</em> <em>page</em> that helps you better understand HTTP requests associated with your <em>mobile</em> app and how those <em>network</em> calls are affecting performance. This document describes the Enterprise-level HTTP requests <em>page</em>. Non-Enterprise accounts will see the legacy HTTP"
      },
      "id": "60450de028ccbc42662c6083"
    },
    {
      "sections": [
        "Map page for mobile apps (deprecated)",
        "Important",
        "View a map of your mobile app services"
      ],
      "title": "Map page for mobile apps (deprecated)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "a082467948ce481c9ecb544d26a802e8d5f3894b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/map-page-mobile-apps-deprecated/",
      "published_at": "2021-12-04T16:36:31Z",
      "updated_at": "2021-09-14T20:45:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important The mobile Maps UI is deprecated since December 22, 2020. Service maps are available in New Relic One's left navigation for each mobile entity, and they are a better way to visualize and customize representations of your architecture. For more information, see our Explorers Hub post. Maps help you find performance problems for a mobile app or its services. This gives you a clear picture of your app's relationships to other services and the influence of each service on the others. If one service fails, you can see at a glance which other services are affected. View a map of your mobile app services To view your mobile app and its related services as an architectural map, go to one.newrelic.com > Mobile > (select a mobile app) > Monitor > Service map. For more information, see the service maps documentation. If you need to use the deprecated mobile Map page, follow these steps: Go to one.newrelic.com > Mobile > (select an app) > Network > Map. To view HTTP request details for a service, select its name. To view details for an app monitored by APM that is related to the service, select the service's name below the associated hostname. To view throughput details as a chart, select the icon or the cpm bar below the service's name. To view detailed metrics for a service, mouse over the throughput chart. The Map page for mobile monitoring gives an architectural view of your mobile app and the services it uses,",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.24562,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Map <em>page</em> for <em>mobile</em> apps (deprecated)",
        "sections": "Map <em>page</em> for <em>mobile</em> apps (deprecated)",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": " <em>mobile</em> app services To view your <em>mobile</em> app and its related services as an architectural map, go to one.newrelic.com &gt; <em>Mobile</em> &gt; (select a <em>mobile</em> app) &gt; <em>Monitor</em> &gt; Service map. For more information, see the service maps documentation. If you need to use the deprecated <em>mobile</em> Map <em>page</em>, follow these steps"
      },
      "id": "6044141828ccbc0f862c60ae"
    }
  ],
  "/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/geography-page-mobile-apps": [
    {
      "sections": [
        "HTTP errors: Network failure analysis",
        "Find and use the HTTP errors page",
        "Group, sort, and filter errors and failures",
        "HTTP error profiles",
        "View more details about a specific error",
        "View and share error data with query builder",
        "View legacy HTTP errors UI page",
        "View the Errors page",
        "Error trace details",
        "View error data in query builder",
        "Unknown errors or URL errors"
      ],
      "title": "HTTP errors: Network failure analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "04631e122b061663c6fd261b605202654aadcf96",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-errors-network-failure-analysis/",
      "published_at": "2021-12-04T15:48:48Z",
      "updated_at": "2021-12-04T15:48:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring's HTTP errors page helps you to better understand HTTP errors and network failures associated with your mobile app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager See a list of errors and failures so you can coordinate mobile app teams with backend teams and share the data they need to fix issues. QA engineer Make sure that a new version of your app does not cause a spike in errors compared to a previous version. DevOps engineer See a list of domains and URLs associated with HTTP errors and network failures, so you can focus on the ones that are causing errors and filter out status codes that are too noisy for your alerts. Mobile developer Find out if there are frontend or backend problems affecting your mobile app (even without an error alert going off) so that you can address them in a new version. Support engineer View the errors and session attributes (geography, connection type, device, app version) associated with an error so that you can help customers with their issues. Find and use the HTTP errors page There are two ways to get to the HTTP errors page: Go to one.newrelic.com > Mobile > (select an app) > Network > Network errors. From a mobile app's Overview page in mobile monitoring, select the HTTP errors/network failures chart title link. From the HTTP errors page, investigate HTTP request and network failures: Use any standard page functions to look for trends in Errors and failures charts. Target specific types of errors and failures by grouping, sorting, and filtering the data. Find anomalies in your request errors with HTTP error profiles. Select an error or failure to view details for it. You can also define NRQL alerts that are focused on error types for your critical services or query your app data. Group, sort, and filter errors and failures If you want to do this... Do this... Change how the page groups and sorts errors and network failures Make selections from the Group by and Sort by dropdowns. By default, the Network errors page is grouped by request domain and sorted by errors and failures. Filter for specific errors and network failures Select an error or failure from the Errors and failures list and/or select multiple filters from the Filter dropdown. See which filters you applied or remove filters The filters you select display next to the filter dropdown. To clear filters, select the X next to the filter you want to clear. Change the time window Select a new time period from the Time picker dropdown. View information for one specific app version Select the version that you want to see charts and lists for in the Versions dropdown. HTTP error profiles Error profiles provide visual details about significant differences in the frequency of different values for HTTP error events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of other errors This helps you take more of the guesswork out of resolving your mobile application's HTTP errors. You can more easily determine if you safely ignore the error, or if you should attempt to resolve the error with a new deployment, code change, customer communication or other actions. View more details about a specific error To view details about an error or failure, select the Request URL link to be directed to the Error summary page. From the Error summary page, you can view the version information, request attributes, and Response body, as well as get a breakdown of error types for the request URL. View and share error data with query builder To explore the data behind any of the charts or lists on the HTTP errors/requests page: Select for any chart. Select View query and then View in Insights. This will open the query builder. From the query builder, you can add the error data to a dashboard and share it via a permalink. To dig deeper into the error data, query your data for the following events and attributes: MobileRequestError events and attributes MobileRequest events and attributes View legacy HTTP errors UI page Accounts that do not have an Enterprise-level subscription see a different HTTP Errors UI page: The Errors page includes details about HTTP errors (403, 404, 422, 500, 502, etc.) and network failures for your hosts; for example: Secure connection failed Timed out Cannot find host Not connected to Internet Cannot connect to host View the Errors page To view HTTP errors or network failures for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Network > Errors. To change the view to errors or failures, select the Sort by option. To hide low-usage hosts, select the Hide < 1% throughput option. To limit information to a specific version of your app, or to change the time period, select your choice from the Versions menu or the time picker below the menu bar. To view details for a specific host, HTTP status error, or network failure, select its name. Use any of our standard user interface functions to drill down into detailed information. Error trace details Mobile monitoring will capture the response details from HTTP requests that return a 400 or 500 level status code. In addition, error messages generated from Android apps will include a stack trace. To view details about an error trace on the Errors page, select its request URL link. From here you can: View the response body. Share the error details with others by email. Delete or hide the error. The errors chart also appears on the selected mobile app's Overview page. If the chart shows errors, you can select its HTTP errors/network failures title or select anywhere on the Overview page's chart to go directly to this Errors page. View error data in query builder To dig deeper into your request data, use the query builder to query and chart the MobileRequest events and attributes. Unknown errors or URL errors The mobile agents maintain a list of exception types. In some cases, custom exceptions thrown by applications fall outside of this list. When this happens, Unknown may appear in the mobile Errors page. If you find Unknown in your list of errors and need assistance in researching which exception types are being missed, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.2029,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "HTTP errors: <em>Network</em> failure analysis",
        "sections": "View legacy HTTP errors <em>UI</em> <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em>&#x27;s HTTP errors <em>page</em> helps you to better understand HTTP errors and <em>network</em> failures associated with your <em>mobile</em> app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors <em>page</em> to... Manager"
      },
      "id": "603e8eb428ccbcd174eba791"
    },
    {
      "sections": [
        "HTTP requests page",
        "Find and use HTTP requests page",
        "Understand HTTP request data",
        "Response time chart",
        "HTTP errors and network failures chart",
        "Total requests",
        "Group, sort, and filter HTTP requests",
        "View and share HTTP request data",
        "View legacy HTTP requests UI page",
        "View legacy HTTP requests UI",
        "View legacy drill-down details",
        "View legacy request data"
      ],
      "title": "HTTP requests page",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "56c27e3a1cad7439b752d38b4d00a60ab98f0e10",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-requests-page/",
      "published_at": "2021-12-04T16:35:47Z",
      "updated_at": "2021-10-07T20:06:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring has an HTTP requests UI page that helps you better understand HTTP requests associated with your mobile app and how those network calls are affecting performance. This document describes the Enterprise-level HTTP requests page. Non-Enterprise accounts will see the legacy HTTP requests page. Find and use HTTP requests page To view mobile monitoring's HTTP requests page: Go to one.newrelic.com > Mobile > (select an app) > Network > HTTP requests. Use our standard page functions to look for trends in the HTTP analysis charts. Target specific request and response attributes by grouping, sorting, and filtering the data. Understand HTTP request data Here are some places to find the most important HTTP request information: Response time chart The response time chart shows how your app's network calls are performing across percentiles. Use it to compare the average response time to the 1st, 50th, and 99th percentile. Percentiles let you filter out outliers that may be making your average response time higher than expected. HTTP errors and network failures chart This chart shows the unsuccessful network calls your app is experiencing. Select the chart title to go to the HTTP errors page for more detail on the errors and failures. Total requests Sort by Total requests to identify which network requests are being used most frequently. The reason this can be helpful is because your slowest network calls may be only infrequently used, while more frequently used requests might be more worthy of optimization even if they are not the slowest. For a description of the non-Enterprise HTTP requests UI page, see Legacy HTTP requests. Group, sort, and filter HTTP requests If you want to... Do this... Group and sort HTTP requests in different ways Make selections from the Group by and Sort by dropdowns. By default, the HTTP requests page is grouped by request domain and sorted by average response time. Filter for specific HTTP requests Select an HTTP request from the Errors and failures list and/or select multiple filters from the Filter dropdown. See or remove applied filters The filters you select are displayed next to the filter dropdown. To clear filters, select the X icon on the filter you want to clear. Change the time window Select a new time period from the time picker dropdown. View information for a specific app version Using the Versions dropdown, select the version for which you want to see charts and lists. View and share HTTP request data To view any HTTP requests chart in Insights: Select for any chart. Select View query > View in Insights. Optional: Add the data to a dashboard, or share it by using a permalink. To delve deeper into your request data, query MobileRequest events and attributes. View legacy HTTP requests UI page Accounts that do not have an Enterprise-level subscription see a different HTTP requests UI page: View legacy HTTP requests UI To view your top five domains or drill down into details about specific HTTP requests: Go to one.newrelic.com > (select an app) > Network > HTTP requests. Optional: Select the Sort by and Hide < 1% throughput options. To view or hide all requests made by your app, select Expand all or Collapse all. To view details for a specific host or HTTP request (including request time, average throughput, and data transfer), select its name. View legacy drill-down details Use any of New Relic's standard page functions to drill down into detailed information. In addition, from the HTTP requests page, you can drill down into detailed information about specific requests, including: Top five HTTP request times Average throughput Average data transfer To view legacy details: one.newrelic.com > Mobile > (select an app) > Network > HTTP requests > (select a request): > Switch to legacy requests. If you want to... Do this View information to a specific version of your app Select Versions from the side bar (if applicable). Change the time period Use the time picker below the New Relic menu bar. View legacy request data You can dig deeper into your request data by querying and charting the MobileRequest event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 188.6442,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "HTTP requests <em>page</em>",
        "sections": "View legacy HTTP requests <em>UI</em> <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em> has an HTTP requests <em>UI</em> <em>page</em> that helps you better understand HTTP requests associated with your <em>mobile</em> app and how those <em>network</em> calls are affecting performance. This document describes the Enterprise-level HTTP requests <em>page</em>. Non-Enterprise accounts will see the legacy HTTP"
      },
      "id": "60450de028ccbc42662c6083"
    },
    {
      "sections": [
        "Map page for mobile apps (deprecated)",
        "Important",
        "View a map of your mobile app services"
      ],
      "title": "Map page for mobile apps (deprecated)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "a082467948ce481c9ecb544d26a802e8d5f3894b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/map-page-mobile-apps-deprecated/",
      "published_at": "2021-12-04T16:36:31Z",
      "updated_at": "2021-09-14T20:45:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important The mobile Maps UI is deprecated since December 22, 2020. Service maps are available in New Relic One's left navigation for each mobile entity, and they are a better way to visualize and customize representations of your architecture. For more information, see our Explorers Hub post. Maps help you find performance problems for a mobile app or its services. This gives you a clear picture of your app's relationships to other services and the influence of each service on the others. If one service fails, you can see at a glance which other services are affected. View a map of your mobile app services To view your mobile app and its related services as an architectural map, go to one.newrelic.com > Mobile > (select a mobile app) > Monitor > Service map. For more information, see the service maps documentation. If you need to use the deprecated mobile Map page, follow these steps: Go to one.newrelic.com > Mobile > (select an app) > Network > Map. To view HTTP request details for a service, select its name. To view details for an app monitored by APM that is related to the service, select the service's name below the associated hostname. To view throughput details as a chart, select the icon or the cpm bar below the service's name. To view detailed metrics for a service, mouse over the throughput chart. The Map page for mobile monitoring gives an architectural view of your mobile app and the services it uses,",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.24562,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Map <em>page</em> for <em>mobile</em> apps (deprecated)",
        "sections": "Map <em>page</em> for <em>mobile</em> apps (deprecated)",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": " <em>mobile</em> app services To view your <em>mobile</em> app and its related services as an architectural map, go to one.newrelic.com &gt; <em>Mobile</em> &gt; (select a <em>mobile</em> app) &gt; <em>Monitor</em> &gt; Service map. For more information, see the service maps documentation. If you need to use the deprecated <em>mobile</em> Map <em>page</em>, follow these steps"
      },
      "id": "6044141828ccbc0f862c60ae"
    }
  ],
  "/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-errors-network-failure-analysis": [
    {
      "sections": [
        "HTTP requests page",
        "Find and use HTTP requests page",
        "Understand HTTP request data",
        "Response time chart",
        "HTTP errors and network failures chart",
        "Total requests",
        "Group, sort, and filter HTTP requests",
        "View and share HTTP request data",
        "View legacy HTTP requests UI page",
        "View legacy HTTP requests UI",
        "View legacy drill-down details",
        "View legacy request data"
      ],
      "title": "HTTP requests page",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "56c27e3a1cad7439b752d38b4d00a60ab98f0e10",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-requests-page/",
      "published_at": "2021-12-04T16:35:47Z",
      "updated_at": "2021-10-07T20:06:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring has an HTTP requests UI page that helps you better understand HTTP requests associated with your mobile app and how those network calls are affecting performance. This document describes the Enterprise-level HTTP requests page. Non-Enterprise accounts will see the legacy HTTP requests page. Find and use HTTP requests page To view mobile monitoring's HTTP requests page: Go to one.newrelic.com > Mobile > (select an app) > Network > HTTP requests. Use our standard page functions to look for trends in the HTTP analysis charts. Target specific request and response attributes by grouping, sorting, and filtering the data. Understand HTTP request data Here are some places to find the most important HTTP request information: Response time chart The response time chart shows how your app's network calls are performing across percentiles. Use it to compare the average response time to the 1st, 50th, and 99th percentile. Percentiles let you filter out outliers that may be making your average response time higher than expected. HTTP errors and network failures chart This chart shows the unsuccessful network calls your app is experiencing. Select the chart title to go to the HTTP errors page for more detail on the errors and failures. Total requests Sort by Total requests to identify which network requests are being used most frequently. The reason this can be helpful is because your slowest network calls may be only infrequently used, while more frequently used requests might be more worthy of optimization even if they are not the slowest. For a description of the non-Enterprise HTTP requests UI page, see Legacy HTTP requests. Group, sort, and filter HTTP requests If you want to... Do this... Group and sort HTTP requests in different ways Make selections from the Group by and Sort by dropdowns. By default, the HTTP requests page is grouped by request domain and sorted by average response time. Filter for specific HTTP requests Select an HTTP request from the Errors and failures list and/or select multiple filters from the Filter dropdown. See or remove applied filters The filters you select are displayed next to the filter dropdown. To clear filters, select the X icon on the filter you want to clear. Change the time window Select a new time period from the time picker dropdown. View information for a specific app version Using the Versions dropdown, select the version for which you want to see charts and lists. View and share HTTP request data To view any HTTP requests chart in Insights: Select for any chart. Select View query > View in Insights. Optional: Add the data to a dashboard, or share it by using a permalink. To delve deeper into your request data, query MobileRequest events and attributes. View legacy HTTP requests UI page Accounts that do not have an Enterprise-level subscription see a different HTTP requests UI page: View legacy HTTP requests UI To view your top five domains or drill down into details about specific HTTP requests: Go to one.newrelic.com > (select an app) > Network > HTTP requests. Optional: Select the Sort by and Hide < 1% throughput options. To view or hide all requests made by your app, select Expand all or Collapse all. To view details for a specific host or HTTP request (including request time, average throughput, and data transfer), select its name. View legacy drill-down details Use any of New Relic's standard page functions to drill down into detailed information. In addition, from the HTTP requests page, you can drill down into detailed information about specific requests, including: Top five HTTP request times Average throughput Average data transfer To view legacy details: one.newrelic.com > Mobile > (select an app) > Network > HTTP requests > (select a request): > Switch to legacy requests. If you want to... Do this View information to a specific version of your app Select Versions from the side bar (if applicable). Change the time period Use the time picker below the New Relic menu bar. View legacy request data You can dig deeper into your request data by querying and charting the MobileRequest event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 188.6442,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "HTTP requests <em>page</em>",
        "sections": "View legacy HTTP requests <em>UI</em> <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em> has an HTTP requests <em>UI</em> <em>page</em> that helps you better understand HTTP requests associated with your <em>mobile</em> app and how those <em>network</em> calls are affecting performance. This document describes the Enterprise-level HTTP requests <em>page</em>. Non-Enterprise accounts will see the legacy HTTP"
      },
      "id": "60450de028ccbc42662c6083"
    },
    {
      "sections": [
        "Map page for mobile apps (deprecated)",
        "Important",
        "View a map of your mobile app services"
      ],
      "title": "Map page for mobile apps (deprecated)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "a082467948ce481c9ecb544d26a802e8d5f3894b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/map-page-mobile-apps-deprecated/",
      "published_at": "2021-12-04T16:36:31Z",
      "updated_at": "2021-09-14T20:45:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important The mobile Maps UI is deprecated since December 22, 2020. Service maps are available in New Relic One's left navigation for each mobile entity, and they are a better way to visualize and customize representations of your architecture. For more information, see our Explorers Hub post. Maps help you find performance problems for a mobile app or its services. This gives you a clear picture of your app's relationships to other services and the influence of each service on the others. If one service fails, you can see at a glance which other services are affected. View a map of your mobile app services To view your mobile app and its related services as an architectural map, go to one.newrelic.com > Mobile > (select a mobile app) > Monitor > Service map. For more information, see the service maps documentation. If you need to use the deprecated mobile Map page, follow these steps: Go to one.newrelic.com > Mobile > (select an app) > Network > Map. To view HTTP request details for a service, select its name. To view details for an app monitored by APM that is related to the service, select the service's name below the associated hostname. To view throughput details as a chart, select the icon or the cpm bar below the service's name. To view detailed metrics for a service, mouse over the throughput chart. The Map page for mobile monitoring gives an architectural view of your mobile app and the services it uses,",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.24562,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Map <em>page</em> for <em>mobile</em> apps (deprecated)",
        "sections": "Map <em>page</em> for <em>mobile</em> apps (deprecated)",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": " <em>mobile</em> app services To view your <em>mobile</em> app and its related services as an architectural map, go to one.newrelic.com &gt; <em>Mobile</em> &gt; (select a <em>mobile</em> app) &gt; <em>Monitor</em> &gt; Service map. For more information, see the service maps documentation. If you need to use the deprecated <em>mobile</em> Map <em>page</em>, follow these steps"
      },
      "id": "6044141828ccbc0f862c60ae"
    },
    {
      "sections": [
        "Geography page for mobile apps",
        "Tip",
        "Viewing the Geography page",
        "Viewing drill-down details"
      ],
      "title": "Geography page for mobile apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "ec64765f7b48034c3c6e666cd8f553b28be7ca06",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/geography-page-mobile-apps/",
      "published_at": "2021-12-04T15:48:48Z",
      "updated_at": "2021-07-09T12:27:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Geography page shows your mobile users' experience as a world view, including: Color-coded response times Network requests (calls per minute) Data transfer size Active devices Network failure rates You can also drill down to detailed information about each country. Tip The Geography feature is not the same as the Map feature. The Map page shows an architectural view of the relationship between a mobile app and its related services. Viewing the Geography page To view or sort the mobile response time by country: Go to one.newrelic.com > Mobile > (select an app) > Network > Geography. To change the information that appears (including response time, requests per minute, total transfer size, active devices, or network failure rate), select your choice from the Sort by menu. To adjust the amount of information that appears, select Hide < 1% throughput. To view summary information about a location, mouse over any area in color on the map, or mouse over the country's name on the list. Use any of our standard user interface functions and page functions to drill down into detailed information. Viewing drill-down details To view detailed information about a specific location (including average response time, calls per minute, active devices, and network failure by type), select its location on the Geography page's map, or select its name on the list.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.0889,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Geography <em>page</em> for <em>mobile</em> apps",
        "sections": "Geography <em>page</em> for <em>mobile</em> apps",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "The Geography <em>page</em> shows your <em>mobile</em> users&#x27; experience as a world view, including: Color-coded response times <em>Network</em> requests (calls per minute) Data transfer size Active devices <em>Network</em> failure rates You can also drill down to detailed information about each country. Tip The Geography feature"
      },
      "id": "6044165a196a67660d960f44"
    }
  ],
  "/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-requests-page": [
    {
      "sections": [
        "HTTP errors: Network failure analysis",
        "Find and use the HTTP errors page",
        "Group, sort, and filter errors and failures",
        "HTTP error profiles",
        "View more details about a specific error",
        "View and share error data with query builder",
        "View legacy HTTP errors UI page",
        "View the Errors page",
        "Error trace details",
        "View error data in query builder",
        "Unknown errors or URL errors"
      ],
      "title": "HTTP errors: Network failure analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "04631e122b061663c6fd261b605202654aadcf96",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-errors-network-failure-analysis/",
      "published_at": "2021-12-04T15:48:48Z",
      "updated_at": "2021-12-04T15:48:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring's HTTP errors page helps you to better understand HTTP errors and network failures associated with your mobile app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager See a list of errors and failures so you can coordinate mobile app teams with backend teams and share the data they need to fix issues. QA engineer Make sure that a new version of your app does not cause a spike in errors compared to a previous version. DevOps engineer See a list of domains and URLs associated with HTTP errors and network failures, so you can focus on the ones that are causing errors and filter out status codes that are too noisy for your alerts. Mobile developer Find out if there are frontend or backend problems affecting your mobile app (even without an error alert going off) so that you can address them in a new version. Support engineer View the errors and session attributes (geography, connection type, device, app version) associated with an error so that you can help customers with their issues. Find and use the HTTP errors page There are two ways to get to the HTTP errors page: Go to one.newrelic.com > Mobile > (select an app) > Network > Network errors. From a mobile app's Overview page in mobile monitoring, select the HTTP errors/network failures chart title link. From the HTTP errors page, investigate HTTP request and network failures: Use any standard page functions to look for trends in Errors and failures charts. Target specific types of errors and failures by grouping, sorting, and filtering the data. Find anomalies in your request errors with HTTP error profiles. Select an error or failure to view details for it. You can also define NRQL alerts that are focused on error types for your critical services or query your app data. Group, sort, and filter errors and failures If you want to do this... Do this... Change how the page groups and sorts errors and network failures Make selections from the Group by and Sort by dropdowns. By default, the Network errors page is grouped by request domain and sorted by errors and failures. Filter for specific errors and network failures Select an error or failure from the Errors and failures list and/or select multiple filters from the Filter dropdown. See which filters you applied or remove filters The filters you select display next to the filter dropdown. To clear filters, select the X next to the filter you want to clear. Change the time window Select a new time period from the Time picker dropdown. View information for one specific app version Select the version that you want to see charts and lists for in the Versions dropdown. HTTP error profiles Error profiles provide visual details about significant differences in the frequency of different values for HTTP error events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of other errors This helps you take more of the guesswork out of resolving your mobile application's HTTP errors. You can more easily determine if you safely ignore the error, or if you should attempt to resolve the error with a new deployment, code change, customer communication or other actions. View more details about a specific error To view details about an error or failure, select the Request URL link to be directed to the Error summary page. From the Error summary page, you can view the version information, request attributes, and Response body, as well as get a breakdown of error types for the request URL. View and share error data with query builder To explore the data behind any of the charts or lists on the HTTP errors/requests page: Select for any chart. Select View query and then View in Insights. This will open the query builder. From the query builder, you can add the error data to a dashboard and share it via a permalink. To dig deeper into the error data, query your data for the following events and attributes: MobileRequestError events and attributes MobileRequest events and attributes View legacy HTTP errors UI page Accounts that do not have an Enterprise-level subscription see a different HTTP Errors UI page: The Errors page includes details about HTTP errors (403, 404, 422, 500, 502, etc.) and network failures for your hosts; for example: Secure connection failed Timed out Cannot find host Not connected to Internet Cannot connect to host View the Errors page To view HTTP errors or network failures for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Network > Errors. To change the view to errors or failures, select the Sort by option. To hide low-usage hosts, select the Hide < 1% throughput option. To limit information to a specific version of your app, or to change the time period, select your choice from the Versions menu or the time picker below the menu bar. To view details for a specific host, HTTP status error, or network failure, select its name. Use any of our standard user interface functions to drill down into detailed information. Error trace details Mobile monitoring will capture the response details from HTTP requests that return a 400 or 500 level status code. In addition, error messages generated from Android apps will include a stack trace. To view details about an error trace on the Errors page, select its request URL link. From here you can: View the response body. Share the error details with others by email. Delete or hide the error. The errors chart also appears on the selected mobile app's Overview page. If the chart shows errors, you can select its HTTP errors/network failures title or select anywhere on the Overview page's chart to go directly to this Errors page. View error data in query builder To dig deeper into your request data, use the query builder to query and chart the MobileRequest events and attributes. Unknown errors or URL errors The mobile agents maintain a list of exception types. In some cases, custom exceptions thrown by applications fall outside of this list. When this happens, Unknown may appear in the mobile Errors page. If you find Unknown in your list of errors and need assistance in researching which exception types are being missed, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.20276,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "HTTP errors: <em>Network</em> failure analysis",
        "sections": "View legacy HTTP errors <em>UI</em> <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em>&#x27;s HTTP errors <em>page</em> helps you to better understand HTTP errors and <em>network</em> failures associated with your <em>mobile</em> app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors <em>page</em> to... Manager"
      },
      "id": "603e8eb428ccbcd174eba791"
    },
    {
      "sections": [
        "Map page for mobile apps (deprecated)",
        "Important",
        "View a map of your mobile app services"
      ],
      "title": "Map page for mobile apps (deprecated)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "a082467948ce481c9ecb544d26a802e8d5f3894b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/map-page-mobile-apps-deprecated/",
      "published_at": "2021-12-04T16:36:31Z",
      "updated_at": "2021-09-14T20:45:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important The mobile Maps UI is deprecated since December 22, 2020. Service maps are available in New Relic One's left navigation for each mobile entity, and they are a better way to visualize and customize representations of your architecture. For more information, see our Explorers Hub post. Maps help you find performance problems for a mobile app or its services. This gives you a clear picture of your app's relationships to other services and the influence of each service on the others. If one service fails, you can see at a glance which other services are affected. View a map of your mobile app services To view your mobile app and its related services as an architectural map, go to one.newrelic.com > Mobile > (select a mobile app) > Monitor > Service map. For more information, see the service maps documentation. If you need to use the deprecated mobile Map page, follow these steps: Go to one.newrelic.com > Mobile > (select an app) > Network > Map. To view HTTP request details for a service, select its name. To view details for an app monitored by APM that is related to the service, select the service's name below the associated hostname. To view throughput details as a chart, select the icon or the cpm bar below the service's name. To view detailed metrics for a service, mouse over the throughput chart. The Map page for mobile monitoring gives an architectural view of your mobile app and the services it uses,",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.2456,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Map <em>page</em> for <em>mobile</em> apps (deprecated)",
        "sections": "Map <em>page</em> for <em>mobile</em> apps (deprecated)",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": " <em>mobile</em> app services To view your <em>mobile</em> app and its related services as an architectural map, go to one.newrelic.com &gt; <em>Mobile</em> &gt; (select a <em>mobile</em> app) &gt; <em>Monitor</em> &gt; Service map. For more information, see the service maps documentation. If you need to use the deprecated <em>mobile</em> Map <em>page</em>, follow these steps"
      },
      "id": "6044141828ccbc0f862c60ae"
    },
    {
      "sections": [
        "Geography page for mobile apps",
        "Tip",
        "Viewing the Geography page",
        "Viewing drill-down details"
      ],
      "title": "Geography page for mobile apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "ec64765f7b48034c3c6e666cd8f553b28be7ca06",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/geography-page-mobile-apps/",
      "published_at": "2021-12-04T15:48:48Z",
      "updated_at": "2021-07-09T12:27:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Geography page shows your mobile users' experience as a world view, including: Color-coded response times Network requests (calls per minute) Data transfer size Active devices Network failure rates You can also drill down to detailed information about each country. Tip The Geography feature is not the same as the Map feature. The Map page shows an architectural view of the relationship between a mobile app and its related services. Viewing the Geography page To view or sort the mobile response time by country: Go to one.newrelic.com > Mobile > (select an app) > Network > Geography. To change the information that appears (including response time, requests per minute, total transfer size, active devices, or network failure rate), select your choice from the Sort by menu. To adjust the amount of information that appears, select Hide < 1% throughput. To view summary information about a location, mouse over any area in color on the map, or mouse over the country's name on the list. Use any of our standard user interface functions and page functions to drill down into detailed information. Viewing drill-down details To view detailed information about a specific location (including average response time, calls per minute, active devices, and network failure by type), select its location on the Geography page's map, or select its name on the list.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.0889,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Geography <em>page</em> for <em>mobile</em> apps",
        "sections": "Geography <em>page</em> for <em>mobile</em> apps",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "The Geography <em>page</em> shows your <em>mobile</em> users&#x27; experience as a world view, including: Color-coded response times <em>Network</em> requests (calls per minute) Data transfer size Active devices <em>Network</em> failure rates You can also drill down to detailed information about each country. Tip The Geography feature"
      },
      "id": "6044165a196a67660d960f44"
    }
  ],
  "/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/map-page-mobile-apps-deprecated": [
    {
      "sections": [
        "HTTP errors: Network failure analysis",
        "Find and use the HTTP errors page",
        "Group, sort, and filter errors and failures",
        "HTTP error profiles",
        "View more details about a specific error",
        "View and share error data with query builder",
        "View legacy HTTP errors UI page",
        "View the Errors page",
        "Error trace details",
        "View error data in query builder",
        "Unknown errors or URL errors"
      ],
      "title": "HTTP errors: Network failure analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "04631e122b061663c6fd261b605202654aadcf96",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-errors-network-failure-analysis/",
      "published_at": "2021-12-04T15:48:48Z",
      "updated_at": "2021-12-04T15:48:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring's HTTP errors page helps you to better understand HTTP errors and network failures associated with your mobile app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager See a list of errors and failures so you can coordinate mobile app teams with backend teams and share the data they need to fix issues. QA engineer Make sure that a new version of your app does not cause a spike in errors compared to a previous version. DevOps engineer See a list of domains and URLs associated with HTTP errors and network failures, so you can focus on the ones that are causing errors and filter out status codes that are too noisy for your alerts. Mobile developer Find out if there are frontend or backend problems affecting your mobile app (even without an error alert going off) so that you can address them in a new version. Support engineer View the errors and session attributes (geography, connection type, device, app version) associated with an error so that you can help customers with their issues. Find and use the HTTP errors page There are two ways to get to the HTTP errors page: Go to one.newrelic.com > Mobile > (select an app) > Network > Network errors. From a mobile app's Overview page in mobile monitoring, select the HTTP errors/network failures chart title link. From the HTTP errors page, investigate HTTP request and network failures: Use any standard page functions to look for trends in Errors and failures charts. Target specific types of errors and failures by grouping, sorting, and filtering the data. Find anomalies in your request errors with HTTP error profiles. Select an error or failure to view details for it. You can also define NRQL alerts that are focused on error types for your critical services or query your app data. Group, sort, and filter errors and failures If you want to do this... Do this... Change how the page groups and sorts errors and network failures Make selections from the Group by and Sort by dropdowns. By default, the Network errors page is grouped by request domain and sorted by errors and failures. Filter for specific errors and network failures Select an error or failure from the Errors and failures list and/or select multiple filters from the Filter dropdown. See which filters you applied or remove filters The filters you select display next to the filter dropdown. To clear filters, select the X next to the filter you want to clear. Change the time window Select a new time period from the Time picker dropdown. View information for one specific app version Select the version that you want to see charts and lists for in the Versions dropdown. HTTP error profiles Error profiles provide visual details about significant differences in the frequency of different values for HTTP error events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of other errors This helps you take more of the guesswork out of resolving your mobile application's HTTP errors. You can more easily determine if you safely ignore the error, or if you should attempt to resolve the error with a new deployment, code change, customer communication or other actions. View more details about a specific error To view details about an error or failure, select the Request URL link to be directed to the Error summary page. From the Error summary page, you can view the version information, request attributes, and Response body, as well as get a breakdown of error types for the request URL. View and share error data with query builder To explore the data behind any of the charts or lists on the HTTP errors/requests page: Select for any chart. Select View query and then View in Insights. This will open the query builder. From the query builder, you can add the error data to a dashboard and share it via a permalink. To dig deeper into the error data, query your data for the following events and attributes: MobileRequestError events and attributes MobileRequest events and attributes View legacy HTTP errors UI page Accounts that do not have an Enterprise-level subscription see a different HTTP Errors UI page: The Errors page includes details about HTTP errors (403, 404, 422, 500, 502, etc.) and network failures for your hosts; for example: Secure connection failed Timed out Cannot find host Not connected to Internet Cannot connect to host View the Errors page To view HTTP errors or network failures for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Network > Errors. To change the view to errors or failures, select the Sort by option. To hide low-usage hosts, select the Hide < 1% throughput option. To limit information to a specific version of your app, or to change the time period, select your choice from the Versions menu or the time picker below the menu bar. To view details for a specific host, HTTP status error, or network failure, select its name. Use any of our standard user interface functions to drill down into detailed information. Error trace details Mobile monitoring will capture the response details from HTTP requests that return a 400 or 500 level status code. In addition, error messages generated from Android apps will include a stack trace. To view details about an error trace on the Errors page, select its request URL link. From here you can: View the response body. Share the error details with others by email. Delete or hide the error. The errors chart also appears on the selected mobile app's Overview page. If the chart shows errors, you can select its HTTP errors/network failures title or select anywhere on the Overview page's chart to go directly to this Errors page. View error data in query builder To dig deeper into your request data, use the query builder to query and chart the MobileRequest events and attributes. Unknown errors or URL errors The mobile agents maintain a list of exception types. In some cases, custom exceptions thrown by applications fall outside of this list. When this happens, Unknown may appear in the mobile Errors page. If you find Unknown in your list of errors and need assistance in researching which exception types are being missed, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.20276,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "HTTP errors: <em>Network</em> failure analysis",
        "sections": "View legacy HTTP errors <em>UI</em> <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em>&#x27;s HTTP errors <em>page</em> helps you to better understand HTTP errors and <em>network</em> failures associated with your <em>mobile</em> app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors <em>page</em> to... Manager"
      },
      "id": "603e8eb428ccbcd174eba791"
    },
    {
      "sections": [
        "HTTP requests page",
        "Find and use HTTP requests page",
        "Understand HTTP request data",
        "Response time chart",
        "HTTP errors and network failures chart",
        "Total requests",
        "Group, sort, and filter HTTP requests",
        "View and share HTTP request data",
        "View legacy HTTP requests UI page",
        "View legacy HTTP requests UI",
        "View legacy drill-down details",
        "View legacy request data"
      ],
      "title": "HTTP requests page",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "56c27e3a1cad7439b752d38b4d00a60ab98f0e10",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-requests-page/",
      "published_at": "2021-12-04T16:35:47Z",
      "updated_at": "2021-10-07T20:06:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring has an HTTP requests UI page that helps you better understand HTTP requests associated with your mobile app and how those network calls are affecting performance. This document describes the Enterprise-level HTTP requests page. Non-Enterprise accounts will see the legacy HTTP requests page. Find and use HTTP requests page To view mobile monitoring's HTTP requests page: Go to one.newrelic.com > Mobile > (select an app) > Network > HTTP requests. Use our standard page functions to look for trends in the HTTP analysis charts. Target specific request and response attributes by grouping, sorting, and filtering the data. Understand HTTP request data Here are some places to find the most important HTTP request information: Response time chart The response time chart shows how your app's network calls are performing across percentiles. Use it to compare the average response time to the 1st, 50th, and 99th percentile. Percentiles let you filter out outliers that may be making your average response time higher than expected. HTTP errors and network failures chart This chart shows the unsuccessful network calls your app is experiencing. Select the chart title to go to the HTTP errors page for more detail on the errors and failures. Total requests Sort by Total requests to identify which network requests are being used most frequently. The reason this can be helpful is because your slowest network calls may be only infrequently used, while more frequently used requests might be more worthy of optimization even if they are not the slowest. For a description of the non-Enterprise HTTP requests UI page, see Legacy HTTP requests. Group, sort, and filter HTTP requests If you want to... Do this... Group and sort HTTP requests in different ways Make selections from the Group by and Sort by dropdowns. By default, the HTTP requests page is grouped by request domain and sorted by average response time. Filter for specific HTTP requests Select an HTTP request from the Errors and failures list and/or select multiple filters from the Filter dropdown. See or remove applied filters The filters you select are displayed next to the filter dropdown. To clear filters, select the X icon on the filter you want to clear. Change the time window Select a new time period from the time picker dropdown. View information for a specific app version Using the Versions dropdown, select the version for which you want to see charts and lists. View and share HTTP request data To view any HTTP requests chart in Insights: Select for any chart. Select View query > View in Insights. Optional: Add the data to a dashboard, or share it by using a permalink. To delve deeper into your request data, query MobileRequest events and attributes. View legacy HTTP requests UI page Accounts that do not have an Enterprise-level subscription see a different HTTP requests UI page: View legacy HTTP requests UI To view your top five domains or drill down into details about specific HTTP requests: Go to one.newrelic.com > (select an app) > Network > HTTP requests. Optional: Select the Sort by and Hide < 1% throughput options. To view or hide all requests made by your app, select Expand all or Collapse all. To view details for a specific host or HTTP request (including request time, average throughput, and data transfer), select its name. View legacy drill-down details Use any of New Relic's standard page functions to drill down into detailed information. In addition, from the HTTP requests page, you can drill down into detailed information about specific requests, including: Top five HTTP request times Average throughput Average data transfer To view legacy details: one.newrelic.com > Mobile > (select an app) > Network > HTTP requests > (select a request): > Switch to legacy requests. If you want to... Do this View information to a specific version of your app Select Versions from the side bar (if applicable). Change the time period Use the time picker below the New Relic menu bar. View legacy request data You can dig deeper into your request data by querying and charting the MobileRequest event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 188.64418,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "HTTP requests <em>page</em>",
        "sections": "View legacy HTTP requests <em>UI</em> <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em> has an HTTP requests <em>UI</em> <em>page</em> that helps you better understand HTTP requests associated with your <em>mobile</em> app and how those <em>network</em> calls are affecting performance. This document describes the Enterprise-level HTTP requests <em>page</em>. Non-Enterprise accounts will see the legacy HTTP"
      },
      "id": "60450de028ccbc42662c6083"
    },
    {
      "sections": [
        "Geography page for mobile apps",
        "Tip",
        "Viewing the Geography page",
        "Viewing drill-down details"
      ],
      "title": "Geography page for mobile apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "ec64765f7b48034c3c6e666cd8f553b28be7ca06",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/geography-page-mobile-apps/",
      "published_at": "2021-12-04T15:48:48Z",
      "updated_at": "2021-07-09T12:27:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Geography page shows your mobile users' experience as a world view, including: Color-coded response times Network requests (calls per minute) Data transfer size Active devices Network failure rates You can also drill down to detailed information about each country. Tip The Geography feature is not the same as the Map feature. The Map page shows an architectural view of the relationship between a mobile app and its related services. Viewing the Geography page To view or sort the mobile response time by country: Go to one.newrelic.com > Mobile > (select an app) > Network > Geography. To change the information that appears (including response time, requests per minute, total transfer size, active devices, or network failure rate), select your choice from the Sort by menu. To adjust the amount of information that appears, select Hide < 1% throughput. To view summary information about a location, mouse over any area in color on the map, or mouse over the country's name on the list. Use any of our standard user interface functions and page functions to drill down into detailed information. Viewing drill-down details To view detailed information about a specific location (including average response time, calls per minute, active devices, and network failure by type), select its location on the Geography page's map, or select its name on the list.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.0889,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Geography <em>page</em> for <em>mobile</em> apps",
        "sections": "Geography <em>page</em> for <em>mobile</em> apps",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "The Geography <em>page</em> shows your <em>mobile</em> users&#x27; experience as a world view, including: Color-coded response times <em>Network</em> requests (calls per minute) Data transfer size Active devices <em>Network</em> failure rates You can also drill down to detailed information about each country. Tip The Geography feature"
      },
      "id": "6044165a196a67660d960f44"
    }
  ],
  "/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/mobile-http-error-profiles-find-error-causes": [
    {
      "sections": [
        "HTTP errors: Network failure analysis",
        "Find and use the HTTP errors page",
        "Group, sort, and filter errors and failures",
        "HTTP error profiles",
        "View more details about a specific error",
        "View and share error data with query builder",
        "View legacy HTTP errors UI page",
        "View the Errors page",
        "Error trace details",
        "View error data in query builder",
        "Unknown errors or URL errors"
      ],
      "title": "HTTP errors: Network failure analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "04631e122b061663c6fd261b605202654aadcf96",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-errors-network-failure-analysis/",
      "published_at": "2021-12-04T15:48:48Z",
      "updated_at": "2021-12-04T15:48:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring's HTTP errors page helps you to better understand HTTP errors and network failures associated with your mobile app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager See a list of errors and failures so you can coordinate mobile app teams with backend teams and share the data they need to fix issues. QA engineer Make sure that a new version of your app does not cause a spike in errors compared to a previous version. DevOps engineer See a list of domains and URLs associated with HTTP errors and network failures, so you can focus on the ones that are causing errors and filter out status codes that are too noisy for your alerts. Mobile developer Find out if there are frontend or backend problems affecting your mobile app (even without an error alert going off) so that you can address them in a new version. Support engineer View the errors and session attributes (geography, connection type, device, app version) associated with an error so that you can help customers with their issues. Find and use the HTTP errors page There are two ways to get to the HTTP errors page: Go to one.newrelic.com > Mobile > (select an app) > Network > Network errors. From a mobile app's Overview page in mobile monitoring, select the HTTP errors/network failures chart title link. From the HTTP errors page, investigate HTTP request and network failures: Use any standard page functions to look for trends in Errors and failures charts. Target specific types of errors and failures by grouping, sorting, and filtering the data. Find anomalies in your request errors with HTTP error profiles. Select an error or failure to view details for it. You can also define NRQL alerts that are focused on error types for your critical services or query your app data. Group, sort, and filter errors and failures If you want to do this... Do this... Change how the page groups and sorts errors and network failures Make selections from the Group by and Sort by dropdowns. By default, the Network errors page is grouped by request domain and sorted by errors and failures. Filter for specific errors and network failures Select an error or failure from the Errors and failures list and/or select multiple filters from the Filter dropdown. See which filters you applied or remove filters The filters you select display next to the filter dropdown. To clear filters, select the X next to the filter you want to clear. Change the time window Select a new time period from the Time picker dropdown. View information for one specific app version Select the version that you want to see charts and lists for in the Versions dropdown. HTTP error profiles Error profiles provide visual details about significant differences in the frequency of different values for HTTP error events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of other errors This helps you take more of the guesswork out of resolving your mobile application's HTTP errors. You can more easily determine if you safely ignore the error, or if you should attempt to resolve the error with a new deployment, code change, customer communication or other actions. View more details about a specific error To view details about an error or failure, select the Request URL link to be directed to the Error summary page. From the Error summary page, you can view the version information, request attributes, and Response body, as well as get a breakdown of error types for the request URL. View and share error data with query builder To explore the data behind any of the charts or lists on the HTTP errors/requests page: Select for any chart. Select View query and then View in Insights. This will open the query builder. From the query builder, you can add the error data to a dashboard and share it via a permalink. To dig deeper into the error data, query your data for the following events and attributes: MobileRequestError events and attributes MobileRequest events and attributes View legacy HTTP errors UI page Accounts that do not have an Enterprise-level subscription see a different HTTP Errors UI page: The Errors page includes details about HTTP errors (403, 404, 422, 500, 502, etc.) and network failures for your hosts; for example: Secure connection failed Timed out Cannot find host Not connected to Internet Cannot connect to host View the Errors page To view HTTP errors or network failures for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Network > Errors. To change the view to errors or failures, select the Sort by option. To hide low-usage hosts, select the Hide < 1% throughput option. To limit information to a specific version of your app, or to change the time period, select your choice from the Versions menu or the time picker below the menu bar. To view details for a specific host, HTTP status error, or network failure, select its name. Use any of our standard user interface functions to drill down into detailed information. Error trace details Mobile monitoring will capture the response details from HTTP requests that return a 400 or 500 level status code. In addition, error messages generated from Android apps will include a stack trace. To view details about an error trace on the Errors page, select its request URL link. From here you can: View the response body. Share the error details with others by email. Delete or hide the error. The errors chart also appears on the selected mobile app's Overview page. If the chart shows errors, you can select its HTTP errors/network failures title or select anywhere on the Overview page's chart to go directly to this Errors page. View error data in query builder To dig deeper into your request data, use the query builder to query and chart the MobileRequest events and attributes. Unknown errors or URL errors The mobile agents maintain a list of exception types. In some cases, custom exceptions thrown by applications fall outside of this list. When this happens, Unknown may appear in the mobile Errors page. If you find Unknown in your list of errors and need assistance in researching which exception types are being missed, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.2026,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "HTTP errors: <em>Network</em> failure analysis",
        "sections": "View legacy HTTP errors <em>UI</em> <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em>&#x27;s HTTP errors <em>page</em> helps you to better understand HTTP errors and <em>network</em> failures associated with your <em>mobile</em> app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors <em>page</em> to... Manager"
      },
      "id": "603e8eb428ccbcd174eba791"
    },
    {
      "sections": [
        "HTTP requests page",
        "Find and use HTTP requests page",
        "Understand HTTP request data",
        "Response time chart",
        "HTTP errors and network failures chart",
        "Total requests",
        "Group, sort, and filter HTTP requests",
        "View and share HTTP request data",
        "View legacy HTTP requests UI page",
        "View legacy HTTP requests UI",
        "View legacy drill-down details",
        "View legacy request data"
      ],
      "title": "HTTP requests page",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "56c27e3a1cad7439b752d38b4d00a60ab98f0e10",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-requests-page/",
      "published_at": "2021-12-04T16:35:47Z",
      "updated_at": "2021-10-07T20:06:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring has an HTTP requests UI page that helps you better understand HTTP requests associated with your mobile app and how those network calls are affecting performance. This document describes the Enterprise-level HTTP requests page. Non-Enterprise accounts will see the legacy HTTP requests page. Find and use HTTP requests page To view mobile monitoring's HTTP requests page: Go to one.newrelic.com > Mobile > (select an app) > Network > HTTP requests. Use our standard page functions to look for trends in the HTTP analysis charts. Target specific request and response attributes by grouping, sorting, and filtering the data. Understand HTTP request data Here are some places to find the most important HTTP request information: Response time chart The response time chart shows how your app's network calls are performing across percentiles. Use it to compare the average response time to the 1st, 50th, and 99th percentile. Percentiles let you filter out outliers that may be making your average response time higher than expected. HTTP errors and network failures chart This chart shows the unsuccessful network calls your app is experiencing. Select the chart title to go to the HTTP errors page for more detail on the errors and failures. Total requests Sort by Total requests to identify which network requests are being used most frequently. The reason this can be helpful is because your slowest network calls may be only infrequently used, while more frequently used requests might be more worthy of optimization even if they are not the slowest. For a description of the non-Enterprise HTTP requests UI page, see Legacy HTTP requests. Group, sort, and filter HTTP requests If you want to... Do this... Group and sort HTTP requests in different ways Make selections from the Group by and Sort by dropdowns. By default, the HTTP requests page is grouped by request domain and sorted by average response time. Filter for specific HTTP requests Select an HTTP request from the Errors and failures list and/or select multiple filters from the Filter dropdown. See or remove applied filters The filters you select are displayed next to the filter dropdown. To clear filters, select the X icon on the filter you want to clear. Change the time window Select a new time period from the time picker dropdown. View information for a specific app version Using the Versions dropdown, select the version for which you want to see charts and lists. View and share HTTP request data To view any HTTP requests chart in Insights: Select for any chart. Select View query > View in Insights. Optional: Add the data to a dashboard, or share it by using a permalink. To delve deeper into your request data, query MobileRequest events and attributes. View legacy HTTP requests UI page Accounts that do not have an Enterprise-level subscription see a different HTTP requests UI page: View legacy HTTP requests UI To view your top five domains or drill down into details about specific HTTP requests: Go to one.newrelic.com > (select an app) > Network > HTTP requests. Optional: Select the Sort by and Hide < 1% throughput options. To view or hide all requests made by your app, select Expand all or Collapse all. To view details for a specific host or HTTP request (including request time, average throughput, and data transfer), select its name. View legacy drill-down details Use any of New Relic's standard page functions to drill down into detailed information. In addition, from the HTTP requests page, you can drill down into detailed information about specific requests, including: Top five HTTP request times Average throughput Average data transfer To view legacy details: one.newrelic.com > Mobile > (select an app) > Network > HTTP requests > (select a request): > Switch to legacy requests. If you want to... Do this View information to a specific version of your app Select Versions from the side bar (if applicable). Change the time period Use the time picker below the New Relic menu bar. View legacy request data You can dig deeper into your request data by querying and charting the MobileRequest event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 188.64418,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "HTTP requests <em>page</em>",
        "sections": "View legacy HTTP requests <em>UI</em> <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em> has an HTTP requests <em>UI</em> <em>page</em> that helps you better understand HTTP requests associated with your <em>mobile</em> app and how those <em>network</em> calls are affecting performance. This document describes the Enterprise-level HTTP requests <em>page</em>. Non-Enterprise accounts will see the legacy HTTP"
      },
      "id": "60450de028ccbc42662c6083"
    },
    {
      "sections": [
        "Map page for mobile apps (deprecated)",
        "Important",
        "View a map of your mobile app services"
      ],
      "title": "Map page for mobile apps (deprecated)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "a082467948ce481c9ecb544d26a802e8d5f3894b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/map-page-mobile-apps-deprecated/",
      "published_at": "2021-12-04T16:36:31Z",
      "updated_at": "2021-09-14T20:45:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important The mobile Maps UI is deprecated since December 22, 2020. Service maps are available in New Relic One's left navigation for each mobile entity, and they are a better way to visualize and customize representations of your architecture. For more information, see our Explorers Hub post. Maps help you find performance problems for a mobile app or its services. This gives you a clear picture of your app's relationships to other services and the influence of each service on the others. If one service fails, you can see at a glance which other services are affected. View a map of your mobile app services To view your mobile app and its related services as an architectural map, go to one.newrelic.com > Mobile > (select a mobile app) > Monitor > Service map. For more information, see the service maps documentation. If you need to use the deprecated mobile Map page, follow these steps: Go to one.newrelic.com > Mobile > (select an app) > Network > Map. To view HTTP request details for a service, select its name. To view details for an app monitored by APM that is related to the service, select the service's name below the associated hostname. To view throughput details as a chart, select the icon or the cpm bar below the service's name. To view detailed metrics for a service, mouse over the throughput chart. The Map page for mobile monitoring gives an architectural view of your mobile app and the services it uses,",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.2456,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Map <em>page</em> for <em>mobile</em> apps (deprecated)",
        "sections": "Map <em>page</em> for <em>mobile</em> apps (deprecated)",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": " <em>mobile</em> app services To view your <em>mobile</em> app and its related services as an architectural map, go to one.newrelic.com &gt; <em>Mobile</em> &gt; (select a <em>mobile</em> app) &gt; <em>Monitor</em> &gt; Service map. For more information, see the service maps documentation. If you need to use the deprecated <em>mobile</em> Map <em>page</em>, follow these steps"
      },
      "id": "6044141828ccbc0f862c60ae"
    }
  ],
  "/docs/mobile-monitoring/mobile-monitoring-ui/usage-pages/monthly-uniques-report": [
    {
      "sections": [
        "HTTP errors: Network failure analysis",
        "Find and use the HTTP errors page",
        "Group, sort, and filter errors and failures",
        "HTTP error profiles",
        "View more details about a specific error",
        "View and share error data with query builder",
        "View legacy HTTP errors UI page",
        "View the Errors page",
        "Error trace details",
        "View error data in query builder",
        "Unknown errors or URL errors"
      ],
      "title": "HTTP errors: Network failure analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "04631e122b061663c6fd261b605202654aadcf96",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-errors-network-failure-analysis/",
      "published_at": "2021-12-04T15:48:48Z",
      "updated_at": "2021-12-04T15:48:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring's HTTP errors page helps you to better understand HTTP errors and network failures associated with your mobile app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager See a list of errors and failures so you can coordinate mobile app teams with backend teams and share the data they need to fix issues. QA engineer Make sure that a new version of your app does not cause a spike in errors compared to a previous version. DevOps engineer See a list of domains and URLs associated with HTTP errors and network failures, so you can focus on the ones that are causing errors and filter out status codes that are too noisy for your alerts. Mobile developer Find out if there are frontend or backend problems affecting your mobile app (even without an error alert going off) so that you can address them in a new version. Support engineer View the errors and session attributes (geography, connection type, device, app version) associated with an error so that you can help customers with their issues. Find and use the HTTP errors page There are two ways to get to the HTTP errors page: Go to one.newrelic.com > Mobile > (select an app) > Network > Network errors. From a mobile app's Overview page in mobile monitoring, select the HTTP errors/network failures chart title link. From the HTTP errors page, investigate HTTP request and network failures: Use any standard page functions to look for trends in Errors and failures charts. Target specific types of errors and failures by grouping, sorting, and filtering the data. Find anomalies in your request errors with HTTP error profiles. Select an error or failure to view details for it. You can also define NRQL alerts that are focused on error types for your critical services or query your app data. Group, sort, and filter errors and failures If you want to do this... Do this... Change how the page groups and sorts errors and network failures Make selections from the Group by and Sort by dropdowns. By default, the Network errors page is grouped by request domain and sorted by errors and failures. Filter for specific errors and network failures Select an error or failure from the Errors and failures list and/or select multiple filters from the Filter dropdown. See which filters you applied or remove filters The filters you select display next to the filter dropdown. To clear filters, select the X next to the filter you want to clear. Change the time window Select a new time period from the Time picker dropdown. View information for one specific app version Select the version that you want to see charts and lists for in the Versions dropdown. HTTP error profiles Error profiles provide visual details about significant differences in the frequency of different values for HTTP error events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of other errors This helps you take more of the guesswork out of resolving your mobile application's HTTP errors. You can more easily determine if you safely ignore the error, or if you should attempt to resolve the error with a new deployment, code change, customer communication or other actions. View more details about a specific error To view details about an error or failure, select the Request URL link to be directed to the Error summary page. From the Error summary page, you can view the version information, request attributes, and Response body, as well as get a breakdown of error types for the request URL. View and share error data with query builder To explore the data behind any of the charts or lists on the HTTP errors/requests page: Select for any chart. Select View query and then View in Insights. This will open the query builder. From the query builder, you can add the error data to a dashboard and share it via a permalink. To dig deeper into the error data, query your data for the following events and attributes: MobileRequestError events and attributes MobileRequest events and attributes View legacy HTTP errors UI page Accounts that do not have an Enterprise-level subscription see a different HTTP Errors UI page: The Errors page includes details about HTTP errors (403, 404, 422, 500, 502, etc.) and network failures for your hosts; for example: Secure connection failed Timed out Cannot find host Not connected to Internet Cannot connect to host View the Errors page To view HTTP errors or network failures for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Network > Errors. To change the view to errors or failures, select the Sort by option. To hide low-usage hosts, select the Hide < 1% throughput option. To limit information to a specific version of your app, or to change the time period, select your choice from the Versions menu or the time picker below the menu bar. To view details for a specific host, HTTP status error, or network failure, select its name. Use any of our standard user interface functions to drill down into detailed information. Error trace details Mobile monitoring will capture the response details from HTTP requests that return a 400 or 500 level status code. In addition, error messages generated from Android apps will include a stack trace. To view details about an error trace on the Errors page, select its request URL link. From here you can: View the response body. Share the error details with others by email. Delete or hide the error. The errors chart also appears on the selected mobile app's Overview page. If the chart shows errors, you can select its HTTP errors/network failures title or select anywhere on the Overview page's chart to go directly to this Errors page. View error data in query builder To dig deeper into your request data, use the query builder to query and chart the MobileRequest events and attributes. Unknown errors or URL errors The mobile agents maintain a list of exception types. In some cases, custom exceptions thrown by applications fall outside of this list. When this happens, Unknown may appear in the mobile Errors page. If you find Unknown in your list of errors and need assistance in researching which exception types are being missed, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.25122,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View legacy HTTP errors <em>UI</em> <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em>&#x27;s HTTP errors <em>page</em> helps you to better understand HTTP errors and network failures associated with your <em>mobile</em> app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors <em>page</em> to... Manager"
      },
      "id": "603e8eb428ccbcd174eba791"
    },
    {
      "sections": [
        "Versions analysis",
        "Versions analysis details",
        "Viewing drill-down details",
        "How version numbers are obtained",
        "Android",
        "iOS"
      ],
      "title": "Versions analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Usage pages"
      ],
      "external_id": "3906aba3231864c2adb43694636f085ae5332d0e",
      "image": "https://docs.newrelic.com/static/f359bb98f6fbf2a5c90dd604778a5dcd/c1b63/screen-versions_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/usage-pages/versions-analysis/",
      "published_at": "2021-12-04T16:09:02Z",
      "updated_at": "2021-07-09T12:29:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring includes a comparative analysis of adoption and performance between versions of your application, including top versions by: Interaction time Active sessions Error rate The Versions page also includes a table comparing each version by date created, average memory, average CPU, average sessions per minute, and average requests per minute (RPM) per active app. You can also drill down into additional details about a specific version. Versions analysis details one.newrelic.com > Mobile > (select an app) > Usage > Versions: The Versions analysis includes color-coded charts of mobile app usage, plus a table that summarizes mobile app versions and their averages for memory, CPU, active users, and network RPM (requests per minute). The Versions page provides a list of all versions of your app that have been detected, plus overview information on all versions active in the last seven days. To view the comparative analysis: Go to one.newrelic.com > Mobile > (select an app) > Usage > Versions. To select the time period, use the time picker below the New Relic menu bar. Optional: Select the Sort by options. To view details only for a specific version, select its name. The Versions page provides a list of all versions of your app that have been active in the selected time window. Use any of New Relic's standard user interface functions and page functions to drill down into detailed information. Viewing drill-down details one.newrelic.com > Mobile > (select an app) > Usage > Versions > (selected version): Here is an example of details for a selected version. The details page provides further insight into how the selected version compares to a reference version (a recent or popular version), and the average of other versions of your app. Time series show the comparison across error rate, response time, active sessions, and memory usage. To exit the details page, select the Close (X) button. How version numbers are obtained The way that mobile monitoring obtains the version number varies by platform: Android The Android agent obtains the version information from the android:versionName property in the manifest. iOS The iOS agent uses both CFBundleShortVersionString and CFBundleVersion properties to obtain the app version. The agent accesses those properties through iOS APIs. It does not obtain them by reading the info.plist file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.26144,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": " the comparison across error rate, response time, active sessions, and memory <em>usage</em>. To exit the details <em>page</em>, select the Close (X) button. How version numbers are obtained The way that <em>mobile</em> <em>monitoring</em> obtains the version number varies by platform: Android The Android agent obtains the version information"
      },
      "id": "603eaeeae7b9d262be2a080c"
    },
    {
      "sections": [
        "Find Build UUIDs for unsymbolicated crashes",
        "View the Build UUID",
        "Binary images example",
        "Find and resymbolicate the dSYM"
      ],
      "title": "Find Build UUIDs for unsymbolicated crashes",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Crashes"
      ],
      "external_id": "e8b926653583d66810c0f68eb6b0111ab3bfc477",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/crashes/find-build-uuids-unsymbolicated-crashes/",
      "published_at": "2021-12-04T18:00:46Z",
      "updated_at": "2021-10-30T20:52:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If the dSYM is not uploaded to New Relic, mobile crash reports cannot be symbolicated. You can upload dSYMs manually or directly through the New Relic UI. However, every build of an application will create a new dSYM, and it can be difficult managing which dSYM is attributed to which app build. In this situation, you can use the Build UUID identifier to: Identify a unique build of an application. Find which dSYM can be used to symbolicate a crash. View the Build UUID An application may have more than one Build UUID, one attributed for each CPU architecture the application is built. The Build UUID is also stored within the associated dSYM and can be extracted to identify the dSYM. New Relic crash reports also contain the Build UUID of the crashing application. To view the Build UUID: Go to one.newrelic.com and click Mobile in the top nav. Then find your app and click Crashes > Crash Analysis. From the Crash list table, select any row. From the selected crash report's Crash Details page, look for the App Image Uuid on the attribute list. If the App Image Uuid is not on the selected crash report's attributes list: Export the crash details. Look for the Build UUID in the Binary images section of the exported crash report. Use the Build UUID extracted from the crash details to find the missing dSYM. Binary images example Here is an example of the Binary images section from an exported crash report. This section lists the Build UUID for every dynamically-linked library included in the application, as well as the Build UUID for the main application. In this example, the main application is New Relic. Its Build UUID is 117667e7b8d230cb8a908906c64e0227. This is the identifier you can use to find the associated dSYM. Binary Images: 0xb1000 - 0x30d000 New Relic armv7 < 117667e7b8d230cb8a908906c64e0227 > /var/containers/Bundle/Application/New Relic.app/New Relic 0x22290000 - 0x22292000 libSystem.B.dylib armv7 <39d6d6f7c2ac3de8bb29c40a1b66368a> /usr/lib/libSystem.B.dylib 0x22292000 - 0x222de000 libc++.1.dylib armv7 <017dba6c16b63f9ebecb9ddd0d0a4520> /usr/lib/libc++.1.dylib 0x222de000 - 0x222f9000 libc++abi.dylib armv7 <d32373f6c2153a509f6603750d213ffb> /usr/lib/libc++abi.dylib 0x222fc000 - 0x22667000 libobjc.A.dylib armv7 <94f6d325c1843f45b3a439b86fc9de15> /usr/lib/libobjc.A.dylib 0x22667000 - 0x2266c000 libcache.dylib armv7 <8009f99fb892331dbcb61cd740ff0f43> /usr/lib/system/libcache.dylib 0x2266c000 - 0x22676000 libcommonCrypto.dylib armv7 <f6db318471d732d39918ef36bde65cb7> /usr/lib/system/libcommonCrypto.dylib 0x22676000 - 0x2267c000 libcompiler_rt.dylib armv7 <cfa3ca12d6c2383abcaf3c8541e9b86c> /usr/lib/system/libcompiler_rt.dylib 0x2267c000 - 0x22683000 libcopyfile.dylib armv7 <d2b06020c3693c7b9d179434f8115ba0> /usr/lib/system/libcopyfile.dylib 0x22683000 - 0x226d3000 libcorecrypto.dylib armv7 <181437f8d9e53277ace439de8b3fd1ad> /usr/lib/system/libcorecrypto.dylib 0x226d3000 - 0x2271d000 libdispatch.dylib armv7 <bbb4bba2176039ab95a59d7a56f6eff8> /usr/lib/system/libdispatch.dylib Copy Find and resymbolicate the dSYM To find a dSYM's Build UUID of a dSYM: use dwarfdump with the following terminal command: dwarfdump --uuid <path-to-dSYM> Copy In the following example, the New Relic dSYM returns two Build UUIDs, one each for ARMv7 and ARM64. The ARMv7 Build UUID matches the Build UUID of the missing crash example: > dwarfdump --uuid ./New\\ Relic.app.dSYM/Contents/Resources/DWARF/New\\ Relic UUID: 117667E7-B8D2-30CB-8A90-8906C64E0227 (armv7) ./New Relic.app.dSYM/Contents/Resources/DWARF/New Relic UUID: B1A8C6EE-02B9-3C55-AEE7-308521873107 (arm64) ./New Relic.app.dSYM/Contents/Resources/DWARF/New Relic Copy To symbolicate the unsymbolicated crashes, follow the instructions to manually upload the dSYM.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.10812,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "If the dSYM is not uploaded to New Relic, <em>mobile</em> crash reports cannot be symbolicated. You can upload dSYMs manually or directly through the New Relic <em>UI</em>. However, every build of an application will create a new dSYM, and it can be difficult managing which dSYM is attributed to which app build"
      },
      "id": "603e9fbae7b9d21cef2a07dd"
    }
  ],
  "/docs/mobile-monitoring/mobile-monitoring-ui/usage-pages/versions-analysis": [
    {
      "sections": [
        "HTTP errors: Network failure analysis",
        "Find and use the HTTP errors page",
        "Group, sort, and filter errors and failures",
        "HTTP error profiles",
        "View more details about a specific error",
        "View and share error data with query builder",
        "View legacy HTTP errors UI page",
        "View the Errors page",
        "Error trace details",
        "View error data in query builder",
        "Unknown errors or URL errors"
      ],
      "title": "HTTP errors: Network failure analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "04631e122b061663c6fd261b605202654aadcf96",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-errors-network-failure-analysis/",
      "published_at": "2021-12-04T15:48:48Z",
      "updated_at": "2021-12-04T15:48:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring's HTTP errors page helps you to better understand HTTP errors and network failures associated with your mobile app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors page to... Manager See a list of errors and failures so you can coordinate mobile app teams with backend teams and share the data they need to fix issues. QA engineer Make sure that a new version of your app does not cause a spike in errors compared to a previous version. DevOps engineer See a list of domains and URLs associated with HTTP errors and network failures, so you can focus on the ones that are causing errors and filter out status codes that are too noisy for your alerts. Mobile developer Find out if there are frontend or backend problems affecting your mobile app (even without an error alert going off) so that you can address them in a new version. Support engineer View the errors and session attributes (geography, connection type, device, app version) associated with an error so that you can help customers with their issues. Find and use the HTTP errors page There are two ways to get to the HTTP errors page: Go to one.newrelic.com > Mobile > (select an app) > Network > Network errors. From a mobile app's Overview page in mobile monitoring, select the HTTP errors/network failures chart title link. From the HTTP errors page, investigate HTTP request and network failures: Use any standard page functions to look for trends in Errors and failures charts. Target specific types of errors and failures by grouping, sorting, and filtering the data. Find anomalies in your request errors with HTTP error profiles. Select an error or failure to view details for it. You can also define NRQL alerts that are focused on error types for your critical services or query your app data. Group, sort, and filter errors and failures If you want to do this... Do this... Change how the page groups and sorts errors and network failures Make selections from the Group by and Sort by dropdowns. By default, the Network errors page is grouped by request domain and sorted by errors and failures. Filter for specific errors and network failures Select an error or failure from the Errors and failures list and/or select multiple filters from the Filter dropdown. See which filters you applied or remove filters The filters you select display next to the filter dropdown. To clear filters, select the X next to the filter you want to clear. Change the time window Select a new time period from the Time picker dropdown. View information for one specific app version Select the version that you want to see charts and lists for in the Versions dropdown. HTTP error profiles Error profiles provide visual details about significant differences in the frequency of different values for HTTP error events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of other errors This helps you take more of the guesswork out of resolving your mobile application's HTTP errors. You can more easily determine if you safely ignore the error, or if you should attempt to resolve the error with a new deployment, code change, customer communication or other actions. View more details about a specific error To view details about an error or failure, select the Request URL link to be directed to the Error summary page. From the Error summary page, you can view the version information, request attributes, and Response body, as well as get a breakdown of error types for the request URL. View and share error data with query builder To explore the data behind any of the charts or lists on the HTTP errors/requests page: Select for any chart. Select View query and then View in Insights. This will open the query builder. From the query builder, you can add the error data to a dashboard and share it via a permalink. To dig deeper into the error data, query your data for the following events and attributes: MobileRequestError events and attributes MobileRequest events and attributes View legacy HTTP errors UI page Accounts that do not have an Enterprise-level subscription see a different HTTP Errors UI page: The Errors page includes details about HTTP errors (403, 404, 422, 500, 502, etc.) and network failures for your hosts; for example: Secure connection failed Timed out Cannot find host Not connected to Internet Cannot connect to host View the Errors page To view HTTP errors or network failures for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Network > Errors. To change the view to errors or failures, select the Sort by option. To hide low-usage hosts, select the Hide < 1% throughput option. To limit information to a specific version of your app, or to change the time period, select your choice from the Versions menu or the time picker below the menu bar. To view details for a specific host, HTTP status error, or network failure, select its name. Use any of our standard user interface functions to drill down into detailed information. Error trace details Mobile monitoring will capture the response details from HTTP requests that return a 400 or 500 level status code. In addition, error messages generated from Android apps will include a stack trace. To view details about an error trace on the Errors page, select its request URL link. From here you can: View the response body. Share the error details with others by email. Delete or hide the error. The errors chart also appears on the selected mobile app's Overview page. If the chart shows errors, you can select its HTTP errors/network failures title or select anywhere on the Overview page's chart to go directly to this Errors page. View error data in query builder To dig deeper into your request data, use the query builder to query and chart the MobileRequest events and attributes. Unknown errors or URL errors The mobile agents maintain a list of exception types. In some cases, custom exceptions thrown by applications fall outside of this list. When this happens, Unknown may appear in the mobile Errors page. If you find Unknown in your list of errors and need assistance in researching which exception types are being missed, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.25113,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View legacy HTTP errors <em>UI</em> <em>page</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em>&#x27;s HTTP errors <em>page</em> helps you to better understand HTTP errors and network failures associated with your <em>mobile</em> app, to connect errors to services that are causing issues, and to share actionable data with your team: Team member View the data on the HTTP errors <em>page</em> to... Manager"
      },
      "id": "603e8eb428ccbcd174eba791"
    },
    {
      "sections": [
        "Monthly uniques report",
        "Monthly uniques report details",
        "Device tracking"
      ],
      "title": "Monthly uniques report",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Usage pages"
      ],
      "external_id": "8865375eef0e6bab4c0b40fa9edde33da93a752c",
      "image": "https://docs.newrelic.com/static/14ffff087d1c8f0d7c26b59739057f07/c1b63/screen-mobile-monthly-uniques.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/usage-pages/monthly-uniques-report/",
      "published_at": "2021-12-04T18:06:16Z",
      "updated_at": "2021-07-09T12:29:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring includes a monthly report with a bar chart tracking the number of devices running your app for each month over the last year. To view the report: Go to one.newrelic.com > Mobile > (select an app) > Usage > Monthly uniques. Monthly uniques report details To see the total number of unique devices for any month, mouse over the month's bar in the chart. The current month's device count is a month-to-date value and does not indicate the full month's usage. one.newrelic.com > Mobile > (select an app) > Usage > Monthly uniques: This report provides a bar chart tracking the number of devices running your app for each month over the last year. Use any of New Relic's standard user interface functions and page functions to drill down into detailed information. Unique users are used to calculate your monthly usage, which is used to calculate your subscription level. Device tracking Mobile monitoring does not use hardware identifiers for unique install tracking. On iOS we use the IdentifierForVendor property. (Versions 5.3.4 and lower used the SecureUDID library.) On Android we generate a unique GUID when the application is installed.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.26144,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "<em>Mobile</em> <em>monitoring</em> includes a monthly report with a bar chart tracking the number of devices running your app for each month over the last year. To view the report: Go to one.newrelic.com &gt; <em>Mobile</em> &gt; (select an app) &gt; <em>Usage</em> &gt; Monthly uniques. Monthly uniques report details To see the total number"
      },
      "id": "6044141964441f5cb1378f32"
    },
    {
      "sections": [
        "Find Build UUIDs for unsymbolicated crashes",
        "View the Build UUID",
        "Binary images example",
        "Find and resymbolicate the dSYM"
      ],
      "title": "Find Build UUIDs for unsymbolicated crashes",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Crashes"
      ],
      "external_id": "e8b926653583d66810c0f68eb6b0111ab3bfc477",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/crashes/find-build-uuids-unsymbolicated-crashes/",
      "published_at": "2021-12-04T18:00:46Z",
      "updated_at": "2021-10-30T20:52:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If the dSYM is not uploaded to New Relic, mobile crash reports cannot be symbolicated. You can upload dSYMs manually or directly through the New Relic UI. However, every build of an application will create a new dSYM, and it can be difficult managing which dSYM is attributed to which app build. In this situation, you can use the Build UUID identifier to: Identify a unique build of an application. Find which dSYM can be used to symbolicate a crash. View the Build UUID An application may have more than one Build UUID, one attributed for each CPU architecture the application is built. The Build UUID is also stored within the associated dSYM and can be extracted to identify the dSYM. New Relic crash reports also contain the Build UUID of the crashing application. To view the Build UUID: Go to one.newrelic.com and click Mobile in the top nav. Then find your app and click Crashes > Crash Analysis. From the Crash list table, select any row. From the selected crash report's Crash Details page, look for the App Image Uuid on the attribute list. If the App Image Uuid is not on the selected crash report's attributes list: Export the crash details. Look for the Build UUID in the Binary images section of the exported crash report. Use the Build UUID extracted from the crash details to find the missing dSYM. Binary images example Here is an example of the Binary images section from an exported crash report. This section lists the Build UUID for every dynamically-linked library included in the application, as well as the Build UUID for the main application. In this example, the main application is New Relic. Its Build UUID is 117667e7b8d230cb8a908906c64e0227. This is the identifier you can use to find the associated dSYM. Binary Images: 0xb1000 - 0x30d000 New Relic armv7 < 117667e7b8d230cb8a908906c64e0227 > /var/containers/Bundle/Application/New Relic.app/New Relic 0x22290000 - 0x22292000 libSystem.B.dylib armv7 <39d6d6f7c2ac3de8bb29c40a1b66368a> /usr/lib/libSystem.B.dylib 0x22292000 - 0x222de000 libc++.1.dylib armv7 <017dba6c16b63f9ebecb9ddd0d0a4520> /usr/lib/libc++.1.dylib 0x222de000 - 0x222f9000 libc++abi.dylib armv7 <d32373f6c2153a509f6603750d213ffb> /usr/lib/libc++abi.dylib 0x222fc000 - 0x22667000 libobjc.A.dylib armv7 <94f6d325c1843f45b3a439b86fc9de15> /usr/lib/libobjc.A.dylib 0x22667000 - 0x2266c000 libcache.dylib armv7 <8009f99fb892331dbcb61cd740ff0f43> /usr/lib/system/libcache.dylib 0x2266c000 - 0x22676000 libcommonCrypto.dylib armv7 <f6db318471d732d39918ef36bde65cb7> /usr/lib/system/libcommonCrypto.dylib 0x22676000 - 0x2267c000 libcompiler_rt.dylib armv7 <cfa3ca12d6c2383abcaf3c8541e9b86c> /usr/lib/system/libcompiler_rt.dylib 0x2267c000 - 0x22683000 libcopyfile.dylib armv7 <d2b06020c3693c7b9d179434f8115ba0> /usr/lib/system/libcopyfile.dylib 0x22683000 - 0x226d3000 libcorecrypto.dylib armv7 <181437f8d9e53277ace439de8b3fd1ad> /usr/lib/system/libcorecrypto.dylib 0x226d3000 - 0x2271d000 libdispatch.dylib armv7 <bbb4bba2176039ab95a59d7a56f6eff8> /usr/lib/system/libdispatch.dylib Copy Find and resymbolicate the dSYM To find a dSYM's Build UUID of a dSYM: use dwarfdump with the following terminal command: dwarfdump --uuid <path-to-dSYM> Copy In the following example, the New Relic dSYM returns two Build UUIDs, one each for ARMv7 and ARM64. The ARMv7 Build UUID matches the Build UUID of the missing crash example: > dwarfdump --uuid ./New\\ Relic.app.dSYM/Contents/Resources/DWARF/New\\ Relic UUID: 117667E7-B8D2-30CB-8A90-8906C64E0227 (armv7) ./New Relic.app.dSYM/Contents/Resources/DWARF/New Relic UUID: B1A8C6EE-02B9-3C55-AEE7-308521873107 (arm64) ./New Relic.app.dSYM/Contents/Resources/DWARF/New Relic Copy To symbolicate the unsymbolicated crashes, follow the instructions to manually upload the dSYM.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.10812,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Mobile</em> <em>monitoring</em> <em>UI</em>",
        "body": "If the dSYM is not uploaded to New Relic, <em>mobile</em> crash reports cannot be symbolicated. You can upload dSYMs manually or directly through the New Relic <em>UI</em>. However, every build of an application will create a new dSYM, and it can be difficult managing which dSYM is attributed to which app build"
      },
      "id": "603e9fbae7b9d21cef2a07dd"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile/get-started/introduction-mobile-monitoring": [
    {
      "sections": [
        "Android agent compatibility and requirements",
        "Foreground monitoring",
        "Android compatibility",
        "Important",
        "Agent and Gradle compatibility",
        "Kotlin and Kotlin DSL",
        "Kotlin DSL support by Android agent version",
        "Kotlin DSL support by AGP version",
        "Unit testing not supported"
      ],
      "title": "Android agent compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "fdae9b0d2971ed33098e8c7cf6152654e45cca69",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/new-relic-android-compatibility-requirements/",
      "published_at": "2021-12-04T16:38:37Z",
      "updated_at": "2021-11-13T03:49:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring is compliant with standard application stores, including Google Play Store, Amazon Appstore, and others. Before you install and configure the mobile agent with your Android applications, follow these guidelines for compatibility and other requirements. Foreground monitoring The Android agent only monitors your app while it is in the foreground. The agent does not monitor background services while the app is closed. For more information, see our Mobile data privacy and security documentation. Android compatibility Make sure your Android app meets these requirements: Component Application requirements Operating system Android 5.0 or higher Version 6.0.0 and higher: Build must be compiled with Android SDK Tools version 21 or higher. Version 5.0.0 and higher: Build must be compiled with Android SDK Tools version 14 or higher. API/SDK HttpURLConnection, OkHttp2 (except versions 2.0 and 2.4), OkHttp (versions 2.8, 3.5+, 4.0+), OkIO (version 1.11), AndroidHttpClient, Volley (version 1.0.0), and Apache HTTP Client networking APIs Build with Android SDK Tools version 21 or higher and the following as appropriate: Android Studio Gradle 3.3 Gradle plugin 3.4 Proguard 5.0 DexGuard 7.2.04 through 8.x Important As of January 2021, our Android agent discontinued support for Android Gradle Plugin version 2. For more information, see our Explorers Hub post. Upgrade to the most recent version before installing the Android agent. Languages Java 1.7 through Java 9. JDK 11 is supported in version 6.2.0 and higher. Devices Any Android compatible device (smartphones, tablets, etc.) File sizes The agent adds less than 500KB to your release APK. Architectures ARM, Intel Atom Signature validation The agent cannot instrument JARs that use signature validation during signing. JARs with manifests containing SHA1-Digest or SHA-256-Digest attributes will not be modified. Agent and Gradle compatibility The following are compatible versions of the New Relic Android agent, Gradle, and the Android Gradle plugin. Important As of March 2021, our Android agent discontinued support for Android Gradle Plugin version 2. For more information, see our Explorers Hub post. Android Gradle plugin New Relic Android agent compatibility 2.3 No longer supported in versions 6.0 and higher. 5.25 - 5.26 are not supported 3.0 - 3.3 No longer supported in versions 6.0 and higher. 3.4 5.25 and higher 4.+ 5.26 and higher Kotlin and Kotlin DSL You can also use Kotlin projects with Gradle and New Relic's Android agent. Kotlin DSL support by Android agent version With the exception of incompatibilities noted with Android Gradle, New Relic's Android agent is compatible with versions 1.3 - 1.4 of the Kotlin Gradle Plugin. Kotlin DSL version New Relic Android agent compatibility 1.2 Unsupported 1.3 5.24 and lower: Requires Kotlin Gradle Plugin version 1.3.10 or higher 5.25: Requires Kotlin Gradle Plugin version 1.3.10 or higher 5.26: Unsupported in Android agent versions 5.26.0 through 5.28.0 1.4 5.24 and lower: Requires Kotlin Gradle Plugin version 1.3.10 or higher 5.25: Supported 5.26: Unsupported in Android agent versions 5.26.0 through 5.28.0 Kotlin DSL support by AGP version Kotlin DSL support was officially added to Android Gradle Plugin in version 4.1, but many developers are already using it in place of Groovy. Kotlin DSL version Android Gradle Plugin and Android Gradle compatibility 1.3 3.2 (AGP), 4.6 (Gradle) : Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.3 (AGP), (5.1.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.4 (AGP), 5.1.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.5 (AGP), 5.4.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.6 (AGP), 5.6.4 Gradle): Requires Kotlin Gradle Plugin version 1.3.40 or higher 4.0 (AGP), 6.1.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.40 or higher 4.1 (AGP), 6.5 Gradle): Requires Kotlin Gradle Plugin version 1.3.40 or higher 1.4 3.2 (AGP), 4.6 (Gradle) : Requires Gradle 5.3 3.3 (AGP), (5.1.1 Gradle): Requires Gradle 5.3 3.4 (AGP), 5.1.1 Gradle): Supported 3.5 (AGP), 5.4.1 Gradle): Supported 3.6 (AGP), 5.6.4 Gradle): Supported 4.0 (AGP), 6.1.1 Gradle): Supported 4.1 (AGP), 6.5 Gradle): Supported Unit testing not supported Our New Relic mobile agents are designed and tested to work in a normal app lifecycle. We do not support running any testing environment on applications with the agent. Testing can cause conflicts and unpredictable behavior.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.732704,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Foreground <em>monitoring</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": "), 6.1.1 Gradle): Supported 4.1 (AGP), 6.5 Gradle): Supported Unit testing not supported Our <em>New</em> <em>Relic</em> <em>mobile</em> agents are designed and tested to work in a normal app lifecycle. We do not support running any testing environment on applications with the agent. Testing can cause conflicts and unpredictable behavior."
      },
      "id": "604418abe7b9d2d1015799cc"
    },
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-04T16:38:01Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.61989,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to Android <em>monitoring</em>",
        "sections": "Introduction to Android <em>monitoring</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": " on information in <em>New</em> <em>Relic</em> Insights. To access: In <em>mobile</em> <em>monitoring</em>: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Security for mobile apps",
        "Data collection",
        "Secure data endpoints",
        "Unique identifiers",
        "No remote updates",
        "Data storage",
        "Instrumentation added to your code",
        "User's IP address"
      ],
      "title": "Security for mobile apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile",
        "Get started"
      ],
      "external_id": "c1f31e708e4710eb4823467a43ab30af1f29243c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile/get-started/security-mobile-apps/",
      "published_at": "2021-12-04T18:06:55Z",
      "updated_at": "2021-05-05T05:08:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To protect your mobile application's security and your users' data privacy, New Relic only records performance data, as described in this document. We do not collect any data used or stored by the monitored app. For more information about New Relic's security measures, see our security and data privacy documentation, or visit the New Relic security website. Data collection When you install New Relic, our mobile monitoring capabilities become part of your iOS or Android app. These capabilities live within your application's \"sandbox,\" so they cannot access anything other than performance data from your mobile app. We do not collect performance data about the device itself, such as battery level. Our mobile SDK agent collects and sends specific data to the New Relic collector, including: Mobile data collected Comments Devices Length of application session Wireless carrier's name The device's model name and manufacturer, and its operating system version Certain package, class, method, and thread names A unique instance identifier Requests and responses URLs of HTTP requests, along with HTTP status code, response time, and size of the request and response body Operating system error code for network failures (HTTP requests that fail to complete) The first 2KB of the response body when the HTTP request receives a 4xx or 5xx response status code Android only: A stack trace when the HTTP request receives a 4xx or 5xx response status code The agent sends all data using HTTPS encryption and validates the collector's SSL certificate. This prevents common data sniffing and server spoofing attacks. The agent also removes the query string, fragment identifier, username, and password from each URL before sending the data. Secure data endpoints Our mobile SDK agent sends harvested data to the collectors for processing. You can redirect those data posts to proxy or delegate servers for secure data handling. Android: You can use APIs to specify the URI authority of harvest and crash collector data endpoints. For more information, see the Android agent configuration and feature flags documentation. iOS: For more information, see the iOS agent configuration and feature flags documentation. Unique identifiers Our mobile SDK agent assigns a unique identifier to each installed app instance in order to track discrete installs, identify recurring sessions, and correlate performance over time. Mobile agent Identifiers Android Our Android agent generates a cryptographically strong UUID and stores it in the app's SharedPreferences. For more information, see our Android compatibility and requirements documentation. iOS The security measures used for iOS depend on the agent version. In versions 5.3.5 or higher, the iOS agent uses the IdentifierForVendor property to provide a unique device ID. In versions 5.3.4 or lower, the iOS agent used the SecureUDID open source library. SecureUDID is used by many third party libraries and is an accepted industry standard that does not violate Apple App store guidelines. SecureUDID does not use device hardware identifiers such as IMEI. Note that our mobile SDK does not collect IDFA (Identity For Advertisers). For more information, see our iOS compatibility and requirements documentation. No remote updates New Relic does not have the ability to update mobile agents remotely. Using the agent will not introduce any code into your mobile app without your knowledge. Data storage Our mobile SDK agent stores configuration information using your app's normal preferences or settings API on the mobile device. This configuration includes your: Application token Application version number Android or iOS SDK agent version number Settings such as the maximum number of HTTP requests to track per minute Performance data is buffered in memory. It is never written to the device's storage. Server-side data storage for mobile apps is handled in the same way as all other applications monitored by New Relic. For more information, see our security documentation about hosting and data storage. In general, we retain performance data according to the more generous time period of either your web or your mobile subscription. We also retain aggregate records of the number of active instances of your application. Instrumentation added to your code Our mobile SDK agent injects code into certain method calls within your application in order to collect performance data. This can have the effect of adding stack frames to your application's call graph where our code executes. This allows us to time and monitor the inputs and outputs of various APIs. This added code has been reviewed and tested for security-related flaws, and it incorporates best practices related to secure coding. Because our code runs within your application's process, it is subject to the same rights and restrictions as your own code. In addition, our iOS agent registers an NSURLProtocol handler to track NSURLConnection-based networking activity. This instrumentation is compatible with other custom NSURLProtocol handlers your application may register. The handler is registered within a single application process, so it is unable to monitor networking requests originating from other applications or the underlying operating system. User's IP address Our mobile SDK agent captures the user's IP address to enrich data for additional user information. The IP address is used as a lookup value that maps to additional details and allows our customers to diagnose performance issues. IP address lookup values include: App name Country code Region Postal code Latitude Longitude Area code For more information about events and attributes for mobile monitoring, see our data dictionary. New Relic does not retain the user's IP address after the attributes have been mapped. The IP address value is cached in memory for up to six hours before being discarded. If you have questions or concerns about this use of IP addresses with regards to your own regulatory obligations for notice and consent, please contact your privacy or legal teams.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.77739,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Security for <em>mobile</em> apps",
        "sections": "Security for <em>mobile</em> apps",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": " privacy documentation, or visit the <em>New</em> <em>Relic</em> security website. Data collection When you install <em>New</em> <em>Relic</em>, our <em>mobile</em> <em>monitoring</em> capabilities become part of your iOS or Android app. These capabilities live within your application&#x27;s &quot;sandbox,&quot; so they cannot access anything other than performance data"
      },
      "id": "603eb1c564441fa7e44e88a5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile/get-started/mobile-monitoring-alert-information": [
    {
      "sections": [
        "Introduction to mobile monitoring",
        "How we use mobile monitoring",
        "1. Alert notification shows new version crashes",
        "2. Crash analysis pinpoints exception, location, and more",
        "3. Problem solved, focus on improving app performance",
        "Improve frontend and backend performance",
        "Get started with mobile monitoring"
      ],
      "title": "Introduction to mobile monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile",
        "Get started"
      ],
      "external_id": "4e60f9568c1ffaf583f47bebfe1cecf5bde82a5b",
      "image": "https://docs.newrelic.com/static/3a1763e0e671b37ba517401ae6c5fb62/8c557/mobile-nrOne-summary072820.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile/get-started/introduction-mobile-monitoring/",
      "published_at": "2021-12-08T01:49:33Z",
      "updated_at": "2021-11-24T20:15:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring capabilities help you gain deeper visibility into how to analyze your Android and iOS application performance and troubleshoot crashes. You can also examine HTTP and other network performance for unexpected lag, which will in turn help you collaborate more efficiently with your backend teams. You'll be able to configure mobile monitoring to suit your environnment after you create a New Relic account (it's free, forever!) and install mobile monitoring for your Android, iOS, or Cordova environment. How we use mobile monitoring At New Relic, we have our own mobile developers who create iOS and Android apps so our customers can use New Relic from their mobile devices. During a feature deploy, we encountered a small bug that caused an edge case crash with our Android app. This happened after we had created, tested, and deployed the new feature. Because we work at New Relic, we also use New Relic One to analyze and troubleshoot our mobile apps. To give you an idea of how to explore the power of mobile monitoring, here's an example of how our own mobile engineers used it to track this small bug. A workflow to identify and resolve mobile app crashes using New Relic. 1. Alert notification shows new version crashes The night after a new release, our on-call developer received an alert notification on his mobile phone. The Alerts page indicated that some customers were seeing crashes on the new version of our Android app. Moving to his desktop browser, he checked the Summary page. The overview showed an increase in crashes for the newest version. By filtering for the latest version and setting the time picker to the past 24 hours, he could proceed with crash analysis. An example of using the mobile Summary page to filter to an Android version with crashes. 2. Crash analysis pinpoints exception, location, and more By clicking the Crashes chart title on the mobile Summary page, the Crash analysis page opened with the same 24-hour time frame and filter to this Android version. Here our developer could see a significant number of crashes for the selected version. This reinforced his suspicion there was bad code somewhere in the recent deployment. The developer clicked the link for the crash type to examine the exception, location, and error message. He also examined the stack trace, interaction trail, and event trail to quickly understand where users were impacted. An example of using the Crash analysis page to track down the cause for crashes for a new release by examining the exception, location, and error message. From here the developer saw the error. The new feature had a specific line of bad code that was crashing the app for customers who only used New Relic to monitor one app rather than multiple apps. The team released a hot fix in less than an hour, and the crash rate quickly de-escalated to 0.2%. 3. Problem solved, focus on improving app performance The problem was solved, but the team continues to use New Relic to make sure the most important workflows are running correctly and quickly. We also share HTTP and other network performance trends with our backend API developer teams. Improve frontend and backend performance More than a tool for crash analysis, our mobile monitoring capabilities can help you identify opportunities to speed app performance. For example, you can: Create dashboards to query, visualize, and share performance data. Identify handled exceptions to streamline workflows. See trends with sessions, devices, geographical locations, operating systems, carriers, requests and responses, etc. with crash profiles and HTTP profiles. Set up alert notifications for execution time, errors, etc. Define custom attributes and events to obtain additional, specific details about the mobile data that matters the most to your organization. And more! In addition to crash analysis, do more to fine-tune mobile app performance. Great mobile apps increasingly rely on backend systems to power their functionality, such as requesting product information, authenticating users, or streaming media content. But some backend issues can lead to upstream mobile app crashes, freezes, and broken functionality that impacts end users, including: Changed or non-versioned API endpoints Bad payloads API timeouts Slow or deprecated API endpoints You can use the network pages in our mobile monitoring UI to identify problems that surface through HTTP requests, errors, and other network issues. You can also query your data. Then create dashboards and share this information with backend API developer teams and others in your organization to help improve the overall end user experience with your mobile app. You can also improve your customers' overall digital experience: Get rapid visibility into how your end users experience your mobile apps and web browsers. Analyze actual or simulated end-user behavior to hone in on metrics like load time, availability, and errors, while staying grounded in the backend services that enable these digital experiences. Get started with mobile monitoring Before you install and configure New Relic's functionality for your mobile applications, follow these guidelines for compatibility and other requirements: Android compatibility and requirements iOS compatibility and requirements Then continue with the installation and configuration procedures for your Android, iOS, tvOS, or Cordova application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 175.84177,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>mobile</em> <em>monitoring</em>",
        "sections": "<em>Get</em> <em>started</em> with <em>mobile</em> <em>monitoring</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> capabilities help you gain deeper visibility into how to analyze your Android and iOS application performance and troubleshoot crashes. You can also examine HTTP and other network performance for unexpected lag, which will in turn help you collaborate more efficiently"
      },
      "id": "603eb1c4e7b9d217802a07a7"
    },
    {
      "sections": [
        "Android agent compatibility and requirements",
        "Foreground monitoring",
        "Android compatibility",
        "Important",
        "Agent and Gradle compatibility",
        "Kotlin and Kotlin DSL",
        "Kotlin DSL support by Android agent version",
        "Kotlin DSL support by AGP version",
        "Unit testing not supported"
      ],
      "title": "Android agent compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "fdae9b0d2971ed33098e8c7cf6152654e45cca69",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/new-relic-android-compatibility-requirements/",
      "published_at": "2021-12-04T16:38:37Z",
      "updated_at": "2021-11-13T03:49:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring is compliant with standard application stores, including Google Play Store, Amazon Appstore, and others. Before you install and configure the mobile agent with your Android applications, follow these guidelines for compatibility and other requirements. Foreground monitoring The Android agent only monitors your app while it is in the foreground. The agent does not monitor background services while the app is closed. For more information, see our Mobile data privacy and security documentation. Android compatibility Make sure your Android app meets these requirements: Component Application requirements Operating system Android 5.0 or higher Version 6.0.0 and higher: Build must be compiled with Android SDK Tools version 21 or higher. Version 5.0.0 and higher: Build must be compiled with Android SDK Tools version 14 or higher. API/SDK HttpURLConnection, OkHttp2 (except versions 2.0 and 2.4), OkHttp (versions 2.8, 3.5+, 4.0+), OkIO (version 1.11), AndroidHttpClient, Volley (version 1.0.0), and Apache HTTP Client networking APIs Build with Android SDK Tools version 21 or higher and the following as appropriate: Android Studio Gradle 3.3 Gradle plugin 3.4 Proguard 5.0 DexGuard 7.2.04 through 8.x Important As of January 2021, our Android agent discontinued support for Android Gradle Plugin version 2. For more information, see our Explorers Hub post. Upgrade to the most recent version before installing the Android agent. Languages Java 1.7 through Java 9. JDK 11 is supported in version 6.2.0 and higher. Devices Any Android compatible device (smartphones, tablets, etc.) File sizes The agent adds less than 500KB to your release APK. Architectures ARM, Intel Atom Signature validation The agent cannot instrument JARs that use signature validation during signing. JARs with manifests containing SHA1-Digest or SHA-256-Digest attributes will not be modified. Agent and Gradle compatibility The following are compatible versions of the New Relic Android agent, Gradle, and the Android Gradle plugin. Important As of March 2021, our Android agent discontinued support for Android Gradle Plugin version 2. For more information, see our Explorers Hub post. Android Gradle plugin New Relic Android agent compatibility 2.3 No longer supported in versions 6.0 and higher. 5.25 - 5.26 are not supported 3.0 - 3.3 No longer supported in versions 6.0 and higher. 3.4 5.25 and higher 4.+ 5.26 and higher Kotlin and Kotlin DSL You can also use Kotlin projects with Gradle and New Relic's Android agent. Kotlin DSL support by Android agent version With the exception of incompatibilities noted with Android Gradle, New Relic's Android agent is compatible with versions 1.3 - 1.4 of the Kotlin Gradle Plugin. Kotlin DSL version New Relic Android agent compatibility 1.2 Unsupported 1.3 5.24 and lower: Requires Kotlin Gradle Plugin version 1.3.10 or higher 5.25: Requires Kotlin Gradle Plugin version 1.3.10 or higher 5.26: Unsupported in Android agent versions 5.26.0 through 5.28.0 1.4 5.24 and lower: Requires Kotlin Gradle Plugin version 1.3.10 or higher 5.25: Supported 5.26: Unsupported in Android agent versions 5.26.0 through 5.28.0 Kotlin DSL support by AGP version Kotlin DSL support was officially added to Android Gradle Plugin in version 4.1, but many developers are already using it in place of Groovy. Kotlin DSL version Android Gradle Plugin and Android Gradle compatibility 1.3 3.2 (AGP), 4.6 (Gradle) : Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.3 (AGP), (5.1.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.4 (AGP), 5.1.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.5 (AGP), 5.4.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.6 (AGP), 5.6.4 Gradle): Requires Kotlin Gradle Plugin version 1.3.40 or higher 4.0 (AGP), 6.1.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.40 or higher 4.1 (AGP), 6.5 Gradle): Requires Kotlin Gradle Plugin version 1.3.40 or higher 1.4 3.2 (AGP), 4.6 (Gradle) : Requires Gradle 5.3 3.3 (AGP), (5.1.1 Gradle): Requires Gradle 5.3 3.4 (AGP), 5.1.1 Gradle): Supported 3.5 (AGP), 5.4.1 Gradle): Supported 3.6 (AGP), 5.6.4 Gradle): Supported 4.0 (AGP), 6.1.1 Gradle): Supported 4.1 (AGP), 6.5 Gradle): Supported Unit testing not supported Our New Relic mobile agents are designed and tested to work in a normal app lifecycle. We do not support running any testing environment on applications with the agent. Testing can cause conflicts and unpredictable behavior.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.732704,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Foreground <em>monitoring</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": "), 6.1.1 Gradle): Supported 4.1 (AGP), 6.5 Gradle): Supported Unit testing not supported Our <em>New</em> <em>Relic</em> <em>mobile</em> agents are designed and tested to work in a normal app lifecycle. We do not support running any testing environment on applications with the agent. Testing can cause conflicts and unpredictable behavior."
      },
      "id": "604418abe7b9d2d1015799cc"
    },
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-04T16:38:01Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.61989,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to Android <em>monitoring</em>",
        "sections": "Introduction to Android <em>monitoring</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": " on information in <em>New</em> <em>Relic</em> Insights. To access: In <em>mobile</em> <em>monitoring</em>: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network"
      },
      "id": "6043a48f196a6784e6960f6d"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile/get-started/security-mobile-apps": [
    {
      "sections": [
        "Introduction to mobile monitoring",
        "How we use mobile monitoring",
        "1. Alert notification shows new version crashes",
        "2. Crash analysis pinpoints exception, location, and more",
        "3. Problem solved, focus on improving app performance",
        "Improve frontend and backend performance",
        "Get started with mobile monitoring"
      ],
      "title": "Introduction to mobile monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile",
        "Get started"
      ],
      "external_id": "4e60f9568c1ffaf583f47bebfe1cecf5bde82a5b",
      "image": "https://docs.newrelic.com/static/3a1763e0e671b37ba517401ae6c5fb62/8c557/mobile-nrOne-summary072820.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile/get-started/introduction-mobile-monitoring/",
      "published_at": "2021-12-08T01:49:33Z",
      "updated_at": "2021-11-24T20:15:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring capabilities help you gain deeper visibility into how to analyze your Android and iOS application performance and troubleshoot crashes. You can also examine HTTP and other network performance for unexpected lag, which will in turn help you collaborate more efficiently with your backend teams. You'll be able to configure mobile monitoring to suit your environnment after you create a New Relic account (it's free, forever!) and install mobile monitoring for your Android, iOS, or Cordova environment. How we use mobile monitoring At New Relic, we have our own mobile developers who create iOS and Android apps so our customers can use New Relic from their mobile devices. During a feature deploy, we encountered a small bug that caused an edge case crash with our Android app. This happened after we had created, tested, and deployed the new feature. Because we work at New Relic, we also use New Relic One to analyze and troubleshoot our mobile apps. To give you an idea of how to explore the power of mobile monitoring, here's an example of how our own mobile engineers used it to track this small bug. A workflow to identify and resolve mobile app crashes using New Relic. 1. Alert notification shows new version crashes The night after a new release, our on-call developer received an alert notification on his mobile phone. The Alerts page indicated that some customers were seeing crashes on the new version of our Android app. Moving to his desktop browser, he checked the Summary page. The overview showed an increase in crashes for the newest version. By filtering for the latest version and setting the time picker to the past 24 hours, he could proceed with crash analysis. An example of using the mobile Summary page to filter to an Android version with crashes. 2. Crash analysis pinpoints exception, location, and more By clicking the Crashes chart title on the mobile Summary page, the Crash analysis page opened with the same 24-hour time frame and filter to this Android version. Here our developer could see a significant number of crashes for the selected version. This reinforced his suspicion there was bad code somewhere in the recent deployment. The developer clicked the link for the crash type to examine the exception, location, and error message. He also examined the stack trace, interaction trail, and event trail to quickly understand where users were impacted. An example of using the Crash analysis page to track down the cause for crashes for a new release by examining the exception, location, and error message. From here the developer saw the error. The new feature had a specific line of bad code that was crashing the app for customers who only used New Relic to monitor one app rather than multiple apps. The team released a hot fix in less than an hour, and the crash rate quickly de-escalated to 0.2%. 3. Problem solved, focus on improving app performance The problem was solved, but the team continues to use New Relic to make sure the most important workflows are running correctly and quickly. We also share HTTP and other network performance trends with our backend API developer teams. Improve frontend and backend performance More than a tool for crash analysis, our mobile monitoring capabilities can help you identify opportunities to speed app performance. For example, you can: Create dashboards to query, visualize, and share performance data. Identify handled exceptions to streamline workflows. See trends with sessions, devices, geographical locations, operating systems, carriers, requests and responses, etc. with crash profiles and HTTP profiles. Set up alert notifications for execution time, errors, etc. Define custom attributes and events to obtain additional, specific details about the mobile data that matters the most to your organization. And more! In addition to crash analysis, do more to fine-tune mobile app performance. Great mobile apps increasingly rely on backend systems to power their functionality, such as requesting product information, authenticating users, or streaming media content. But some backend issues can lead to upstream mobile app crashes, freezes, and broken functionality that impacts end users, including: Changed or non-versioned API endpoints Bad payloads API timeouts Slow or deprecated API endpoints You can use the network pages in our mobile monitoring UI to identify problems that surface through HTTP requests, errors, and other network issues. You can also query your data. Then create dashboards and share this information with backend API developer teams and others in your organization to help improve the overall end user experience with your mobile app. You can also improve your customers' overall digital experience: Get rapid visibility into how your end users experience your mobile apps and web browsers. Analyze actual or simulated end-user behavior to hone in on metrics like load time, availability, and errors, while staying grounded in the backend services that enable these digital experiences. Get started with mobile monitoring Before you install and configure New Relic's functionality for your mobile applications, follow these guidelines for compatibility and other requirements: Android compatibility and requirements iOS compatibility and requirements Then continue with the installation and configuration procedures for your Android, iOS, tvOS, or Cordova application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 175.84172,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>mobile</em> <em>monitoring</em>",
        "sections": "<em>Get</em> <em>started</em> with <em>mobile</em> <em>monitoring</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> capabilities help you gain deeper visibility into how to analyze your Android and iOS application performance and troubleshoot crashes. You can also examine HTTP and other network performance for unexpected lag, which will in turn help you collaborate more efficiently"
      },
      "id": "603eb1c4e7b9d217802a07a7"
    },
    {
      "sections": [
        "Android agent compatibility and requirements",
        "Foreground monitoring",
        "Android compatibility",
        "Important",
        "Agent and Gradle compatibility",
        "Kotlin and Kotlin DSL",
        "Kotlin DSL support by Android agent version",
        "Kotlin DSL support by AGP version",
        "Unit testing not supported"
      ],
      "title": "Android agent compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "fdae9b0d2971ed33098e8c7cf6152654e45cca69",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/new-relic-android-compatibility-requirements/",
      "published_at": "2021-12-04T16:38:37Z",
      "updated_at": "2021-11-13T03:49:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring is compliant with standard application stores, including Google Play Store, Amazon Appstore, and others. Before you install and configure the mobile agent with your Android applications, follow these guidelines for compatibility and other requirements. Foreground monitoring The Android agent only monitors your app while it is in the foreground. The agent does not monitor background services while the app is closed. For more information, see our Mobile data privacy and security documentation. Android compatibility Make sure your Android app meets these requirements: Component Application requirements Operating system Android 5.0 or higher Version 6.0.0 and higher: Build must be compiled with Android SDK Tools version 21 or higher. Version 5.0.0 and higher: Build must be compiled with Android SDK Tools version 14 or higher. API/SDK HttpURLConnection, OkHttp2 (except versions 2.0 and 2.4), OkHttp (versions 2.8, 3.5+, 4.0+), OkIO (version 1.11), AndroidHttpClient, Volley (version 1.0.0), and Apache HTTP Client networking APIs Build with Android SDK Tools version 21 or higher and the following as appropriate: Android Studio Gradle 3.3 Gradle plugin 3.4 Proguard 5.0 DexGuard 7.2.04 through 8.x Important As of January 2021, our Android agent discontinued support for Android Gradle Plugin version 2. For more information, see our Explorers Hub post. Upgrade to the most recent version before installing the Android agent. Languages Java 1.7 through Java 9. JDK 11 is supported in version 6.2.0 and higher. Devices Any Android compatible device (smartphones, tablets, etc.) File sizes The agent adds less than 500KB to your release APK. Architectures ARM, Intel Atom Signature validation The agent cannot instrument JARs that use signature validation during signing. JARs with manifests containing SHA1-Digest or SHA-256-Digest attributes will not be modified. Agent and Gradle compatibility The following are compatible versions of the New Relic Android agent, Gradle, and the Android Gradle plugin. Important As of March 2021, our Android agent discontinued support for Android Gradle Plugin version 2. For more information, see our Explorers Hub post. Android Gradle plugin New Relic Android agent compatibility 2.3 No longer supported in versions 6.0 and higher. 5.25 - 5.26 are not supported 3.0 - 3.3 No longer supported in versions 6.0 and higher. 3.4 5.25 and higher 4.+ 5.26 and higher Kotlin and Kotlin DSL You can also use Kotlin projects with Gradle and New Relic's Android agent. Kotlin DSL support by Android agent version With the exception of incompatibilities noted with Android Gradle, New Relic's Android agent is compatible with versions 1.3 - 1.4 of the Kotlin Gradle Plugin. Kotlin DSL version New Relic Android agent compatibility 1.2 Unsupported 1.3 5.24 and lower: Requires Kotlin Gradle Plugin version 1.3.10 or higher 5.25: Requires Kotlin Gradle Plugin version 1.3.10 or higher 5.26: Unsupported in Android agent versions 5.26.0 through 5.28.0 1.4 5.24 and lower: Requires Kotlin Gradle Plugin version 1.3.10 or higher 5.25: Supported 5.26: Unsupported in Android agent versions 5.26.0 through 5.28.0 Kotlin DSL support by AGP version Kotlin DSL support was officially added to Android Gradle Plugin in version 4.1, but many developers are already using it in place of Groovy. Kotlin DSL version Android Gradle Plugin and Android Gradle compatibility 1.3 3.2 (AGP), 4.6 (Gradle) : Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.3 (AGP), (5.1.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.4 (AGP), 5.1.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.5 (AGP), 5.4.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.6 (AGP), 5.6.4 Gradle): Requires Kotlin Gradle Plugin version 1.3.40 or higher 4.0 (AGP), 6.1.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.40 or higher 4.1 (AGP), 6.5 Gradle): Requires Kotlin Gradle Plugin version 1.3.40 or higher 1.4 3.2 (AGP), 4.6 (Gradle) : Requires Gradle 5.3 3.3 (AGP), (5.1.1 Gradle): Requires Gradle 5.3 3.4 (AGP), 5.1.1 Gradle): Supported 3.5 (AGP), 5.4.1 Gradle): Supported 3.6 (AGP), 5.6.4 Gradle): Supported 4.0 (AGP), 6.1.1 Gradle): Supported 4.1 (AGP), 6.5 Gradle): Supported Unit testing not supported Our New Relic mobile agents are designed and tested to work in a normal app lifecycle. We do not support running any testing environment on applications with the agent. Testing can cause conflicts and unpredictable behavior.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.73269,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Foreground <em>monitoring</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": "), 6.1.1 Gradle): Supported 4.1 (AGP), 6.5 Gradle): Supported Unit testing not supported Our <em>New</em> <em>Relic</em> <em>mobile</em> agents are designed and tested to work in a normal app lifecycle. We do not support running any testing environment on applications with the agent. Testing can cause conflicts and unpredictable behavior."
      },
      "id": "604418abe7b9d2d1015799cc"
    },
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-04T16:38:01Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.61988,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to Android <em>monitoring</em>",
        "sections": "Introduction to Android <em>monitoring</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": " on information in <em>New</em> <em>Relic</em> Insights. To access: In <em>mobile</em> <em>monitoring</em>: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network"
      },
      "id": "6043a48f196a6784e6960f6d"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile/maintenance/add-custom-data-new-relic-mobile": [
    {
      "sections": [
        "Customize mobile app settings",
        "Important",
        "Change name of monitored app",
        "Caution",
        "Agent configuration"
      ],
      "title": "Customize mobile app settings",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile",
        "Maintenance"
      ],
      "external_id": "8719a1897be60f1d77831f1df82c464884cafadc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile/maintenance/customizing-your-mobile-app-settings/",
      "published_at": "2021-12-04T18:07:09Z",
      "updated_at": "2021-03-16T09:42:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the New Relic mobile monitoring UI, under Settings, there are options for changing your New Relic-monitored mobile app, editing alert conditions, and editing other settings. To get to mobile monitoring settings: Go to one.newrelic.com, click Mobile, and select a monitored app. Look at the UI pages under the Settings heading. Important Access to this feature depends on user permissions. Available settings include: If you want to... Select this Change your mobile app's name Application Change the Caution and Critical alert conditions for HTTP status code error rates, network failure error rates, or response time Alert conditions Turn on or turn off alert notifications for your mobile app Alert conditions Install our mobile monitoring Installation Upgrade our Mobile SDK in your mobile app Upgrade View your mobile app's authentication token Application or Installation Change another mobile app's settings Select your choice from the dropdown next to the currently selected mobile app's name Change name of monitored app You can change your app's name in the UI anytime, and our mobile monitoring will continue to collect, aggregate, and report data to your app based on the underlying application token used when configuring your mobile app. This means you don't need to change any code in your application. Caution Data reported from your mobile app is tied to a named app based on the application token. All apps with a single application token will report into the same app in our mobile monitoring UI, regardless of the app's name when installed on a mobile device. To rename your mobile app: Go to one.newrelic.com, click Mobile, and select a monitored app. Select Application. Type a new name and select Save settings. Agent configuration You can also configure the agent via API calls: Add custom data to mobile monitoring Android configuration and feature flags iOS configuration and feature flags",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.82669,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Customize <em>mobile</em> app settings",
        "sections": "Customize <em>mobile</em> app settings",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": "In the <em>New</em> <em>Relic</em> <em>mobile</em> <em>monitoring</em> UI, under Settings, there are options for changing your <em>New</em> <em>Relic</em>-monitored <em>mobile</em> app, editing alert conditions, and editing other settings. To get to <em>mobile</em> <em>monitoring</em> settings: Go to one.newrelic.com, click <em>Mobile</em>, and select a monitored app. Look at the UI"
      },
      "id": "603ebe82196a67b7eca83d94"
    },
    {
      "sections": [
        "Application token for New Relic mobile monitoring",
        "Tip"
      ],
      "title": "Application token for New Relic mobile monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile",
        "Maintenance"
      ],
      "external_id": "4321d8be4040736dd9ca00e165cf6e0df8d2db5c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile/maintenance/viewing-your-application-token/",
      "published_at": "2021-12-04T18:07:30Z",
      "updated_at": "2021-03-16T09:42:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring automatically assigns a unique, 40-character hexadecimal string to each mobile app you monitor, for both the US and EU datacenter. This application token is similar to a New Relic license key and is required to authenticate your app's data. To view your application token: Go to one.newrelic.com, click Mobile, and select a monitored app. Select Application or Installation. Tip Data reported from your mobile app is tied to a named app based on the application token. All apps with a single application token will report to the same place in our mobile monitoring UI, regardless of the app's name when installed on a mobile device. We recommend using a different application token for each platform to separate iOS and Android versions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.94656,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Application token for <em>New</em> <em>Relic</em> <em>mobile</em> <em>monitoring</em>",
        "sections": "Application token for <em>New</em> <em>Relic</em> <em>mobile</em> <em>monitoring</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> automatically assigns a unique, 40-character hexadecimal string to each <em>mobile</em> app you <em>monitor</em>, for both the US and EU datacenter. This application token is similar to a <em>New</em> <em>Relic</em> license key and is required to authenticate your app&#x27;s data. To view your application"
      },
      "id": "603ebe1964441fd8864e88aa"
    },
    {
      "sections": [
        "Introduction to mobile monitoring",
        "How we use mobile monitoring",
        "1. Alert notification shows new version crashes",
        "2. Crash analysis pinpoints exception, location, and more",
        "3. Problem solved, focus on improving app performance",
        "Improve frontend and backend performance",
        "Get started with mobile monitoring"
      ],
      "title": "Introduction to mobile monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile",
        "Get started"
      ],
      "external_id": "4e60f9568c1ffaf583f47bebfe1cecf5bde82a5b",
      "image": "https://docs.newrelic.com/static/3a1763e0e671b37ba517401ae6c5fb62/8c557/mobile-nrOne-summary072820.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile/get-started/introduction-mobile-monitoring/",
      "published_at": "2021-12-08T01:49:33Z",
      "updated_at": "2021-11-24T20:15:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring capabilities help you gain deeper visibility into how to analyze your Android and iOS application performance and troubleshoot crashes. You can also examine HTTP and other network performance for unexpected lag, which will in turn help you collaborate more efficiently with your backend teams. You'll be able to configure mobile monitoring to suit your environnment after you create a New Relic account (it's free, forever!) and install mobile monitoring for your Android, iOS, or Cordova environment. How we use mobile monitoring At New Relic, we have our own mobile developers who create iOS and Android apps so our customers can use New Relic from their mobile devices. During a feature deploy, we encountered a small bug that caused an edge case crash with our Android app. This happened after we had created, tested, and deployed the new feature. Because we work at New Relic, we also use New Relic One to analyze and troubleshoot our mobile apps. To give you an idea of how to explore the power of mobile monitoring, here's an example of how our own mobile engineers used it to track this small bug. A workflow to identify and resolve mobile app crashes using New Relic. 1. Alert notification shows new version crashes The night after a new release, our on-call developer received an alert notification on his mobile phone. The Alerts page indicated that some customers were seeing crashes on the new version of our Android app. Moving to his desktop browser, he checked the Summary page. The overview showed an increase in crashes for the newest version. By filtering for the latest version and setting the time picker to the past 24 hours, he could proceed with crash analysis. An example of using the mobile Summary page to filter to an Android version with crashes. 2. Crash analysis pinpoints exception, location, and more By clicking the Crashes chart title on the mobile Summary page, the Crash analysis page opened with the same 24-hour time frame and filter to this Android version. Here our developer could see a significant number of crashes for the selected version. This reinforced his suspicion there was bad code somewhere in the recent deployment. The developer clicked the link for the crash type to examine the exception, location, and error message. He also examined the stack trace, interaction trail, and event trail to quickly understand where users were impacted. An example of using the Crash analysis page to track down the cause for crashes for a new release by examining the exception, location, and error message. From here the developer saw the error. The new feature had a specific line of bad code that was crashing the app for customers who only used New Relic to monitor one app rather than multiple apps. The team released a hot fix in less than an hour, and the crash rate quickly de-escalated to 0.2%. 3. Problem solved, focus on improving app performance The problem was solved, but the team continues to use New Relic to make sure the most important workflows are running correctly and quickly. We also share HTTP and other network performance trends with our backend API developer teams. Improve frontend and backend performance More than a tool for crash analysis, our mobile monitoring capabilities can help you identify opportunities to speed app performance. For example, you can: Create dashboards to query, visualize, and share performance data. Identify handled exceptions to streamline workflows. See trends with sessions, devices, geographical locations, operating systems, carriers, requests and responses, etc. with crash profiles and HTTP profiles. Set up alert notifications for execution time, errors, etc. Define custom attributes and events to obtain additional, specific details about the mobile data that matters the most to your organization. And more! In addition to crash analysis, do more to fine-tune mobile app performance. Great mobile apps increasingly rely on backend systems to power their functionality, such as requesting product information, authenticating users, or streaming media content. But some backend issues can lead to upstream mobile app crashes, freezes, and broken functionality that impacts end users, including: Changed or non-versioned API endpoints Bad payloads API timeouts Slow or deprecated API endpoints You can use the network pages in our mobile monitoring UI to identify problems that surface through HTTP requests, errors, and other network issues. You can also query your data. Then create dashboards and share this information with backend API developer teams and others in your organization to help improve the overall end user experience with your mobile app. You can also improve your customers' overall digital experience: Get rapid visibility into how your end users experience your mobile apps and web browsers. Analyze actual or simulated end-user behavior to hone in on metrics like load time, availability, and errors, while staying grounded in the backend services that enable these digital experiences. Get started with mobile monitoring Before you install and configure New Relic's functionality for your mobile applications, follow these guidelines for compatibility and other requirements: Android compatibility and requirements iOS compatibility and requirements Then continue with the installation and configuration procedures for your Android, iOS, tvOS, or Cordova application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.75164,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>mobile</em> <em>monitoring</em>",
        "sections": "Introduction to <em>mobile</em> <em>monitoring</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> capabilities help you gain deeper visibility into how to analyze your Android and iOS application performance and troubleshoot crashes. You can also examine HTTP and other network performance for unexpected lag, which will in turn help you collaborate more efficiently"
      },
      "id": "603eb1c4e7b9d217802a07a7"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile/maintenance/customizing-your-mobile-app-settings": [
    {
      "sections": [
        "Application token for New Relic mobile monitoring",
        "Tip"
      ],
      "title": "Application token for New Relic mobile monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile",
        "Maintenance"
      ],
      "external_id": "4321d8be4040736dd9ca00e165cf6e0df8d2db5c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile/maintenance/viewing-your-application-token/",
      "published_at": "2021-12-04T18:07:30Z",
      "updated_at": "2021-03-16T09:42:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring automatically assigns a unique, 40-character hexadecimal string to each mobile app you monitor, for both the US and EU datacenter. This application token is similar to a New Relic license key and is required to authenticate your app's data. To view your application token: Go to one.newrelic.com, click Mobile, and select a monitored app. Select Application or Installation. Tip Data reported from your mobile app is tied to a named app based on the application token. All apps with a single application token will report to the same place in our mobile monitoring UI, regardless of the app's name when installed on a mobile device. We recommend using a different application token for each platform to separate iOS and Android versions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.94656,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Application token for <em>New</em> <em>Relic</em> <em>mobile</em> <em>monitoring</em>",
        "sections": "Application token for <em>New</em> <em>Relic</em> <em>mobile</em> <em>monitoring</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> automatically assigns a unique, 40-character hexadecimal string to each <em>mobile</em> app you <em>monitor</em>, for both the US and EU datacenter. This application token is similar to a <em>New</em> <em>Relic</em> license key and is required to authenticate your app&#x27;s data. To view your application"
      },
      "id": "603ebe1964441fd8864e88aa"
    },
    {
      "sections": [
        "Add custom data to mobile monitoring",
        "Choose a custom data type",
        "Add session-level custom attributes",
        "Record breadcrumbs",
        "Create custom interactions",
        "Record custom events"
      ],
      "title": "Add custom data to mobile monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile",
        "Maintenance"
      ],
      "external_id": "81d73d6610c6cc08cc21a5dbbb1ee1e507f6db16",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile/maintenance/add-custom-data-new-relic-mobile/",
      "published_at": "2021-12-04T18:06:54Z",
      "updated_at": "2021-03-11T11:17:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic mobile monitoring includes a number of ways to customize and extend the data your mobile app reports. We refer to this type of implementation as \"custom instrumentation.\" This document explains how to get additional data into New Relic, and how to view that new data in the UI. Choose a custom data type You can use these options to create your own data types for custom instrumentation for your mobile apps. Using these four options, you can get a wide range of data based on your needs for your apps. Custom data options Description Session-level custom attributes In creating your own attributes, consisting of a key-value pair, you can add custom data for use in tracking session data. Custom breadcrumbs Useful for troubleshooting crash causes, custom breadcrumb events track the user's code-level path through the app by seeing which breadcrumb API calls were reached and reporting app status details from those moments. Custom interactions Custom interactions give you tracing power so you can debug method timings and improve network call efficiency. A common use of interactions is to understand the underlying activity associated with loading a particular app screen. Custom events You can instrument custom events to collect data about user activity as a user navigates through your app. That user activity will in turn trigger other data collection: a collection of breadcrumbs, auto-instrumented HTTP requests and errors, auto-instrumented interactions, and custom interactions. Add session-level custom attributes Custom attributes annotate (or \"tag\") your mobile monitoring data. A custom attribute consists of a key-value pair. For example, you might create the key userEmail with values such as alice@bigcorp.test and bob@example.com. The agent automatically attaches custom attributes to default mobile monitoring data, and to any breadcrumbs or custom events you create. You can use custom attributes to capture usage data that's relevant to your business. Common examples include account names or IDs, user emails, and subscription levels. You can then filter and facet in the Crash analysis page and via NRQL query. Setting custom attributes will add the key-value pair information at the session level. All default mobile monitoring events inherit these session-level custom attributes. As a best practice, use custom attributes to track a single value for a key that can be true across a session (for example, a user's subscription level, or whether SAML was used to log in). To track the change of a value over the course of a session, like a change in connection type, you would instead record a breadcrumb and its own custom attributes. To track a series of discrete user actions that occur across the course of a session, use custom events. To add custom attributes, see: Android: Use setAttribute() and incrementAttribute(). iOS: Use setAttribute() and incrementAttribute(). Record breadcrumbs Breadcrumbs track the state of your app as it runs, then report a snapshot of that state if your app crashes. This allows you to debug your mobile app crashes more easily. Custom interactions only inherit custom attributes created at the session level. Breadcrumbs will inherit those same session-level custom attributes, but optionally you can also report additional custom attributes specific to each recordBreadcrumb() API call. You can use breadcrumbs in several ways: You could record a breadcrumb event when your app receives an HTTP response, and also record the values in that response as custom attributes (for example, the response might tell the app what screen to display next or recording unique timestamps for each change in the course of a session). If the app crashes or throws errors, you will be able to see invalid data from the HTTP response. You could track the success of each step of your user login process, with perhaps a status attribute recording a success or failure key for each step. This would let you debug which step is causing issues. Once you have released a version of your app that creates MobileBreadcrumb custom events, you can see them in the crash event trail whenever they appear in the app's code path as part of a crashed session. You can also query them using NRQL and query either all breadcrumbs or just breadcrumbs from crashed sessions. This lets you see the frequency of app paths that include that particular breadcrumb. To add custom breadcrumbs, see: Android: Use recordBreadcrumb(). iOS: Use recordBreadcrumb(). Create custom interactions Our mobile monitoring agent begins instrumenting an interaction when it detects a screen load or partial screen load (such as fragments for Android or view controllers for iOS). New Relic automatically traces slow interactions, providing a complete, in-depth picture of a single slow interaction, including the methods that were called, what network requests were made, and the CPU and memory usage once that interaction started. Our mobile monitoring automatically selects data-rich traces. The specific criteria the agent looks for are interactions whose instrumented methods account for at least 30% of the overall interaction time. In addition to the auto-instrumentation, you can start a custom interaction to force the agent to start recording a trace beginning at that point in your app code and continuing across the subsequent methods and network calls. Custom interaction traces provide deep information. However, they increase the overhead of the agent compared to other custom data collection methods because of the large amount of data collected for the entire duration of an interaction. When associated with a crash, custom interactions show up in the crash event trail. You can also query them with NRQL for flexible analysis. Interactions are powerful for tracing but are less flexible in other ways than other custom data types: While custom breadcrumbs and custom events let you optimize your custom attributes to specific events, interactions can only inherit session-level attributes. You can also manually end a custom interaction. However, ensure that the interaction includes enough method activity to be recorded. If the agent does not detect any traced activity for 0.5 seconds, the agent stops the interaction tracing because it is assumed no interesting data remains. In addition, the agent can only trace one interaction at a time, so if a new interaction is triggered the current trace will automatically be stopped in preference for the new trace. To add custom interaction traces, see: Android: Use startInteraction() and endInteraction(). iOS: Create and complete interactions. You can also configure interaction tracing globally: Android: Disable entirely with withInteractionTracing(), or disable only auto-instrumented traces with withDefaultInteractions(). iOS: Disable entirely with NRFeatureFlag_InteractionTracing(), or disable only auto-instrumented traces with NRFeatureFlag_DefaultInteractions(). Record custom events Custom events are a powerful tool for reporting arbitrary user activity to New Relic. When associated with a crash, custom events show up in the crash event trail. You can also query them with NRQL for flexible analysis. Unlike custom interactions, custom events allow you to add custom attributes to a particular event within the user session. For example, you could record a custom event each time a user taps a button or accesses a certain feature, and then use NRQL to track how often that feature was used. Beyond a simple count, you can FACET on default mobile app attributes such as location, device, or carrier to analyze usage. Adding session-level custom attributes would let you further examine usage based on the criteria important to you, such as user subscription level or other user characteristics. Adding additional attributes for that custom event would allow you to track user behavior more closely: What data did they enter or what option did they select, for example. To add custom events, see: Android: Use recordCustomEvent(). iOS: Use recordCustomEvent().",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.8558,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add custom data to <em>mobile</em> <em>monitoring</em>",
        "sections": "Add custom data to <em>mobile</em> <em>monitoring</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>monitoring</em> includes a number of ways to customize and extend the data your <em>mobile</em> app reports. We refer to this type of implementation as &quot;custom instrumentation.&quot; This document explains how to get additional data into <em>New</em> <em>Relic</em>, and how to view that <em>new</em> data in the UI. Choose"
      },
      "id": "60450e5028ccbc3cfd2c60d2"
    },
    {
      "sections": [
        "Introduction to mobile monitoring",
        "How we use mobile monitoring",
        "1. Alert notification shows new version crashes",
        "2. Crash analysis pinpoints exception, location, and more",
        "3. Problem solved, focus on improving app performance",
        "Improve frontend and backend performance",
        "Get started with mobile monitoring"
      ],
      "title": "Introduction to mobile monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile",
        "Get started"
      ],
      "external_id": "4e60f9568c1ffaf583f47bebfe1cecf5bde82a5b",
      "image": "https://docs.newrelic.com/static/3a1763e0e671b37ba517401ae6c5fb62/8c557/mobile-nrOne-summary072820.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile/get-started/introduction-mobile-monitoring/",
      "published_at": "2021-12-08T01:49:33Z",
      "updated_at": "2021-11-24T20:15:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring capabilities help you gain deeper visibility into how to analyze your Android and iOS application performance and troubleshoot crashes. You can also examine HTTP and other network performance for unexpected lag, which will in turn help you collaborate more efficiently with your backend teams. You'll be able to configure mobile monitoring to suit your environnment after you create a New Relic account (it's free, forever!) and install mobile monitoring for your Android, iOS, or Cordova environment. How we use mobile monitoring At New Relic, we have our own mobile developers who create iOS and Android apps so our customers can use New Relic from their mobile devices. During a feature deploy, we encountered a small bug that caused an edge case crash with our Android app. This happened after we had created, tested, and deployed the new feature. Because we work at New Relic, we also use New Relic One to analyze and troubleshoot our mobile apps. To give you an idea of how to explore the power of mobile monitoring, here's an example of how our own mobile engineers used it to track this small bug. A workflow to identify and resolve mobile app crashes using New Relic. 1. Alert notification shows new version crashes The night after a new release, our on-call developer received an alert notification on his mobile phone. The Alerts page indicated that some customers were seeing crashes on the new version of our Android app. Moving to his desktop browser, he checked the Summary page. The overview showed an increase in crashes for the newest version. By filtering for the latest version and setting the time picker to the past 24 hours, he could proceed with crash analysis. An example of using the mobile Summary page to filter to an Android version with crashes. 2. Crash analysis pinpoints exception, location, and more By clicking the Crashes chart title on the mobile Summary page, the Crash analysis page opened with the same 24-hour time frame and filter to this Android version. Here our developer could see a significant number of crashes for the selected version. This reinforced his suspicion there was bad code somewhere in the recent deployment. The developer clicked the link for the crash type to examine the exception, location, and error message. He also examined the stack trace, interaction trail, and event trail to quickly understand where users were impacted. An example of using the Crash analysis page to track down the cause for crashes for a new release by examining the exception, location, and error message. From here the developer saw the error. The new feature had a specific line of bad code that was crashing the app for customers who only used New Relic to monitor one app rather than multiple apps. The team released a hot fix in less than an hour, and the crash rate quickly de-escalated to 0.2%. 3. Problem solved, focus on improving app performance The problem was solved, but the team continues to use New Relic to make sure the most important workflows are running correctly and quickly. We also share HTTP and other network performance trends with our backend API developer teams. Improve frontend and backend performance More than a tool for crash analysis, our mobile monitoring capabilities can help you identify opportunities to speed app performance. For example, you can: Create dashboards to query, visualize, and share performance data. Identify handled exceptions to streamline workflows. See trends with sessions, devices, geographical locations, operating systems, carriers, requests and responses, etc. with crash profiles and HTTP profiles. Set up alert notifications for execution time, errors, etc. Define custom attributes and events to obtain additional, specific details about the mobile data that matters the most to your organization. And more! In addition to crash analysis, do more to fine-tune mobile app performance. Great mobile apps increasingly rely on backend systems to power their functionality, such as requesting product information, authenticating users, or streaming media content. But some backend issues can lead to upstream mobile app crashes, freezes, and broken functionality that impacts end users, including: Changed or non-versioned API endpoints Bad payloads API timeouts Slow or deprecated API endpoints You can use the network pages in our mobile monitoring UI to identify problems that surface through HTTP requests, errors, and other network issues. You can also query your data. Then create dashboards and share this information with backend API developer teams and others in your organization to help improve the overall end user experience with your mobile app. You can also improve your customers' overall digital experience: Get rapid visibility into how your end users experience your mobile apps and web browsers. Analyze actual or simulated end-user behavior to hone in on metrics like load time, availability, and errors, while staying grounded in the backend services that enable these digital experiences. Get started with mobile monitoring Before you install and configure New Relic's functionality for your mobile applications, follow these guidelines for compatibility and other requirements: Android compatibility and requirements iOS compatibility and requirements Then continue with the installation and configuration procedures for your Android, iOS, tvOS, or Cordova application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.75162,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>mobile</em> <em>monitoring</em>",
        "sections": "Introduction to <em>mobile</em> <em>monitoring</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> capabilities help you gain deeper visibility into how to analyze your Android and iOS application performance and troubleshoot crashes. You can also examine HTTP and other network performance for unexpected lag, which will in turn help you collaborate more efficiently"
      },
      "id": "603eb1c4e7b9d217802a07a7"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile/maintenance/viewing-your-application-token": [
    {
      "sections": [
        "Customize mobile app settings",
        "Important",
        "Change name of monitored app",
        "Caution",
        "Agent configuration"
      ],
      "title": "Customize mobile app settings",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile",
        "Maintenance"
      ],
      "external_id": "8719a1897be60f1d77831f1df82c464884cafadc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile/maintenance/customizing-your-mobile-app-settings/",
      "published_at": "2021-12-04T18:07:09Z",
      "updated_at": "2021-03-16T09:42:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the New Relic mobile monitoring UI, under Settings, there are options for changing your New Relic-monitored mobile app, editing alert conditions, and editing other settings. To get to mobile monitoring settings: Go to one.newrelic.com, click Mobile, and select a monitored app. Look at the UI pages under the Settings heading. Important Access to this feature depends on user permissions. Available settings include: If you want to... Select this Change your mobile app's name Application Change the Caution and Critical alert conditions for HTTP status code error rates, network failure error rates, or response time Alert conditions Turn on or turn off alert notifications for your mobile app Alert conditions Install our mobile monitoring Installation Upgrade our Mobile SDK in your mobile app Upgrade View your mobile app's authentication token Application or Installation Change another mobile app's settings Select your choice from the dropdown next to the currently selected mobile app's name Change name of monitored app You can change your app's name in the UI anytime, and our mobile monitoring will continue to collect, aggregate, and report data to your app based on the underlying application token used when configuring your mobile app. This means you don't need to change any code in your application. Caution Data reported from your mobile app is tied to a named app based on the application token. All apps with a single application token will report into the same app in our mobile monitoring UI, regardless of the app's name when installed on a mobile device. To rename your mobile app: Go to one.newrelic.com, click Mobile, and select a monitored app. Select Application. Type a new name and select Save settings. Agent configuration You can also configure the agent via API calls: Add custom data to mobile monitoring Android configuration and feature flags iOS configuration and feature flags",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.82669,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Customize <em>mobile</em> app settings",
        "sections": "Customize <em>mobile</em> app settings",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": "In the <em>New</em> <em>Relic</em> <em>mobile</em> <em>monitoring</em> UI, under Settings, there are options for changing your <em>New</em> <em>Relic</em>-monitored <em>mobile</em> app, editing alert conditions, and editing other settings. To get to <em>mobile</em> <em>monitoring</em> settings: Go to one.newrelic.com, click <em>Mobile</em>, and select a monitored app. Look at the UI"
      },
      "id": "603ebe82196a67b7eca83d94"
    },
    {
      "sections": [
        "Add custom data to mobile monitoring",
        "Choose a custom data type",
        "Add session-level custom attributes",
        "Record breadcrumbs",
        "Create custom interactions",
        "Record custom events"
      ],
      "title": "Add custom data to mobile monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile",
        "Maintenance"
      ],
      "external_id": "81d73d6610c6cc08cc21a5dbbb1ee1e507f6db16",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile/maintenance/add-custom-data-new-relic-mobile/",
      "published_at": "2021-12-04T18:06:54Z",
      "updated_at": "2021-03-11T11:17:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic mobile monitoring includes a number of ways to customize and extend the data your mobile app reports. We refer to this type of implementation as \"custom instrumentation.\" This document explains how to get additional data into New Relic, and how to view that new data in the UI. Choose a custom data type You can use these options to create your own data types for custom instrumentation for your mobile apps. Using these four options, you can get a wide range of data based on your needs for your apps. Custom data options Description Session-level custom attributes In creating your own attributes, consisting of a key-value pair, you can add custom data for use in tracking session data. Custom breadcrumbs Useful for troubleshooting crash causes, custom breadcrumb events track the user's code-level path through the app by seeing which breadcrumb API calls were reached and reporting app status details from those moments. Custom interactions Custom interactions give you tracing power so you can debug method timings and improve network call efficiency. A common use of interactions is to understand the underlying activity associated with loading a particular app screen. Custom events You can instrument custom events to collect data about user activity as a user navigates through your app. That user activity will in turn trigger other data collection: a collection of breadcrumbs, auto-instrumented HTTP requests and errors, auto-instrumented interactions, and custom interactions. Add session-level custom attributes Custom attributes annotate (or \"tag\") your mobile monitoring data. A custom attribute consists of a key-value pair. For example, you might create the key userEmail with values such as alice@bigcorp.test and bob@example.com. The agent automatically attaches custom attributes to default mobile monitoring data, and to any breadcrumbs or custom events you create. You can use custom attributes to capture usage data that's relevant to your business. Common examples include account names or IDs, user emails, and subscription levels. You can then filter and facet in the Crash analysis page and via NRQL query. Setting custom attributes will add the key-value pair information at the session level. All default mobile monitoring events inherit these session-level custom attributes. As a best practice, use custom attributes to track a single value for a key that can be true across a session (for example, a user's subscription level, or whether SAML was used to log in). To track the change of a value over the course of a session, like a change in connection type, you would instead record a breadcrumb and its own custom attributes. To track a series of discrete user actions that occur across the course of a session, use custom events. To add custom attributes, see: Android: Use setAttribute() and incrementAttribute(). iOS: Use setAttribute() and incrementAttribute(). Record breadcrumbs Breadcrumbs track the state of your app as it runs, then report a snapshot of that state if your app crashes. This allows you to debug your mobile app crashes more easily. Custom interactions only inherit custom attributes created at the session level. Breadcrumbs will inherit those same session-level custom attributes, but optionally you can also report additional custom attributes specific to each recordBreadcrumb() API call. You can use breadcrumbs in several ways: You could record a breadcrumb event when your app receives an HTTP response, and also record the values in that response as custom attributes (for example, the response might tell the app what screen to display next or recording unique timestamps for each change in the course of a session). If the app crashes or throws errors, you will be able to see invalid data from the HTTP response. You could track the success of each step of your user login process, with perhaps a status attribute recording a success or failure key for each step. This would let you debug which step is causing issues. Once you have released a version of your app that creates MobileBreadcrumb custom events, you can see them in the crash event trail whenever they appear in the app's code path as part of a crashed session. You can also query them using NRQL and query either all breadcrumbs or just breadcrumbs from crashed sessions. This lets you see the frequency of app paths that include that particular breadcrumb. To add custom breadcrumbs, see: Android: Use recordBreadcrumb(). iOS: Use recordBreadcrumb(). Create custom interactions Our mobile monitoring agent begins instrumenting an interaction when it detects a screen load or partial screen load (such as fragments for Android or view controllers for iOS). New Relic automatically traces slow interactions, providing a complete, in-depth picture of a single slow interaction, including the methods that were called, what network requests were made, and the CPU and memory usage once that interaction started. Our mobile monitoring automatically selects data-rich traces. The specific criteria the agent looks for are interactions whose instrumented methods account for at least 30% of the overall interaction time. In addition to the auto-instrumentation, you can start a custom interaction to force the agent to start recording a trace beginning at that point in your app code and continuing across the subsequent methods and network calls. Custom interaction traces provide deep information. However, they increase the overhead of the agent compared to other custom data collection methods because of the large amount of data collected for the entire duration of an interaction. When associated with a crash, custom interactions show up in the crash event trail. You can also query them with NRQL for flexible analysis. Interactions are powerful for tracing but are less flexible in other ways than other custom data types: While custom breadcrumbs and custom events let you optimize your custom attributes to specific events, interactions can only inherit session-level attributes. You can also manually end a custom interaction. However, ensure that the interaction includes enough method activity to be recorded. If the agent does not detect any traced activity for 0.5 seconds, the agent stops the interaction tracing because it is assumed no interesting data remains. In addition, the agent can only trace one interaction at a time, so if a new interaction is triggered the current trace will automatically be stopped in preference for the new trace. To add custom interaction traces, see: Android: Use startInteraction() and endInteraction(). iOS: Create and complete interactions. You can also configure interaction tracing globally: Android: Disable entirely with withInteractionTracing(), or disable only auto-instrumented traces with withDefaultInteractions(). iOS: Disable entirely with NRFeatureFlag_InteractionTracing(), or disable only auto-instrumented traces with NRFeatureFlag_DefaultInteractions(). Record custom events Custom events are a powerful tool for reporting arbitrary user activity to New Relic. When associated with a crash, custom events show up in the crash event trail. You can also query them with NRQL for flexible analysis. Unlike custom interactions, custom events allow you to add custom attributes to a particular event within the user session. For example, you could record a custom event each time a user taps a button or accesses a certain feature, and then use NRQL to track how often that feature was used. Beyond a simple count, you can FACET on default mobile app attributes such as location, device, or carrier to analyze usage. Adding session-level custom attributes would let you further examine usage based on the criteria important to you, such as user subscription level or other user characteristics. Adding additional attributes for that custom event would allow you to track user behavior more closely: What data did they enter or what option did they select, for example. To add custom events, see: Android: Use recordCustomEvent(). iOS: Use recordCustomEvent().",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.8558,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add custom data to <em>mobile</em> <em>monitoring</em>",
        "sections": "Add custom data to <em>mobile</em> <em>monitoring</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>monitoring</em> includes a number of ways to customize and extend the data your <em>mobile</em> app reports. We refer to this type of implementation as &quot;custom instrumentation.&quot; This document explains how to get additional data into <em>New</em> <em>Relic</em>, and how to view that <em>new</em> data in the UI. Choose"
      },
      "id": "60450e5028ccbc3cfd2c60d2"
    },
    {
      "sections": [
        "Introduction to mobile monitoring",
        "How we use mobile monitoring",
        "1. Alert notification shows new version crashes",
        "2. Crash analysis pinpoints exception, location, and more",
        "3. Problem solved, focus on improving app performance",
        "Improve frontend and backend performance",
        "Get started with mobile monitoring"
      ],
      "title": "Introduction to mobile monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile",
        "Get started"
      ],
      "external_id": "4e60f9568c1ffaf583f47bebfe1cecf5bde82a5b",
      "image": "https://docs.newrelic.com/static/3a1763e0e671b37ba517401ae6c5fb62/8c557/mobile-nrOne-summary072820.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile/get-started/introduction-mobile-monitoring/",
      "published_at": "2021-12-08T01:49:33Z",
      "updated_at": "2021-11-24T20:15:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring capabilities help you gain deeper visibility into how to analyze your Android and iOS application performance and troubleshoot crashes. You can also examine HTTP and other network performance for unexpected lag, which will in turn help you collaborate more efficiently with your backend teams. You'll be able to configure mobile monitoring to suit your environnment after you create a New Relic account (it's free, forever!) and install mobile monitoring for your Android, iOS, or Cordova environment. How we use mobile monitoring At New Relic, we have our own mobile developers who create iOS and Android apps so our customers can use New Relic from their mobile devices. During a feature deploy, we encountered a small bug that caused an edge case crash with our Android app. This happened after we had created, tested, and deployed the new feature. Because we work at New Relic, we also use New Relic One to analyze and troubleshoot our mobile apps. To give you an idea of how to explore the power of mobile monitoring, here's an example of how our own mobile engineers used it to track this small bug. A workflow to identify and resolve mobile app crashes using New Relic. 1. Alert notification shows new version crashes The night after a new release, our on-call developer received an alert notification on his mobile phone. The Alerts page indicated that some customers were seeing crashes on the new version of our Android app. Moving to his desktop browser, he checked the Summary page. The overview showed an increase in crashes for the newest version. By filtering for the latest version and setting the time picker to the past 24 hours, he could proceed with crash analysis. An example of using the mobile Summary page to filter to an Android version with crashes. 2. Crash analysis pinpoints exception, location, and more By clicking the Crashes chart title on the mobile Summary page, the Crash analysis page opened with the same 24-hour time frame and filter to this Android version. Here our developer could see a significant number of crashes for the selected version. This reinforced his suspicion there was bad code somewhere in the recent deployment. The developer clicked the link for the crash type to examine the exception, location, and error message. He also examined the stack trace, interaction trail, and event trail to quickly understand where users were impacted. An example of using the Crash analysis page to track down the cause for crashes for a new release by examining the exception, location, and error message. From here the developer saw the error. The new feature had a specific line of bad code that was crashing the app for customers who only used New Relic to monitor one app rather than multiple apps. The team released a hot fix in less than an hour, and the crash rate quickly de-escalated to 0.2%. 3. Problem solved, focus on improving app performance The problem was solved, but the team continues to use New Relic to make sure the most important workflows are running correctly and quickly. We also share HTTP and other network performance trends with our backend API developer teams. Improve frontend and backend performance More than a tool for crash analysis, our mobile monitoring capabilities can help you identify opportunities to speed app performance. For example, you can: Create dashboards to query, visualize, and share performance data. Identify handled exceptions to streamline workflows. See trends with sessions, devices, geographical locations, operating systems, carriers, requests and responses, etc. with crash profiles and HTTP profiles. Set up alert notifications for execution time, errors, etc. Define custom attributes and events to obtain additional, specific details about the mobile data that matters the most to your organization. And more! In addition to crash analysis, do more to fine-tune mobile app performance. Great mobile apps increasingly rely on backend systems to power their functionality, such as requesting product information, authenticating users, or streaming media content. But some backend issues can lead to upstream mobile app crashes, freezes, and broken functionality that impacts end users, including: Changed or non-versioned API endpoints Bad payloads API timeouts Slow or deprecated API endpoints You can use the network pages in our mobile monitoring UI to identify problems that surface through HTTP requests, errors, and other network issues. You can also query your data. Then create dashboards and share this information with backend API developer teams and others in your organization to help improve the overall end user experience with your mobile app. You can also improve your customers' overall digital experience: Get rapid visibility into how your end users experience your mobile apps and web browsers. Analyze actual or simulated end-user behavior to hone in on metrics like load time, availability, and errors, while staying grounded in the backend services that enable these digital experiences. Get started with mobile monitoring Before you install and configure New Relic's functionality for your mobile applications, follow these guidelines for compatibility and other requirements: Android compatibility and requirements iOS compatibility and requirements Then continue with the installation and configuration procedures for your Android, iOS, tvOS, or Cordova application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.75162,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>mobile</em> <em>monitoring</em>",
        "sections": "Introduction to <em>mobile</em> <em>monitoring</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> capabilities help you gain deeper visibility into how to analyze your Android and iOS application performance and troubleshoot crashes. You can also examine HTTP and other network performance for unexpected lag, which will in turn help you collaborate more efficiently"
      },
      "id": "603eb1c4e7b9d217802a07a7"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-agent-configuration-feature-flags": [
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-04T16:41:13Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.53694,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> SDK <em>API</em> <em>guide</em>",
        "sections": "<em>Android</em> SDK <em>API</em> <em>guide</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " instrumentation for <em>monitoring</em> your application. The <em>API</em> gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your <em>mobile</em> app. Record custom metrics. Send custom attributes and events to <em>New</em> <em>Relic</em> Insights. Track networking from libraries not supported"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "Android agent compatibility and requirements",
        "Foreground monitoring",
        "Android compatibility",
        "Important",
        "Agent and Gradle compatibility",
        "Kotlin and Kotlin DSL",
        "Kotlin DSL support by Android agent version",
        "Kotlin DSL support by AGP version",
        "Unit testing not supported"
      ],
      "title": "Android agent compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "fdae9b0d2971ed33098e8c7cf6152654e45cca69",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/new-relic-android-compatibility-requirements/",
      "published_at": "2021-12-04T16:38:37Z",
      "updated_at": "2021-11-13T03:49:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring is compliant with standard application stores, including Google Play Store, Amazon Appstore, and others. Before you install and configure the mobile agent with your Android applications, follow these guidelines for compatibility and other requirements. Foreground monitoring The Android agent only monitors your app while it is in the foreground. The agent does not monitor background services while the app is closed. For more information, see our Mobile data privacy and security documentation. Android compatibility Make sure your Android app meets these requirements: Component Application requirements Operating system Android 5.0 or higher Version 6.0.0 and higher: Build must be compiled with Android SDK Tools version 21 or higher. Version 5.0.0 and higher: Build must be compiled with Android SDK Tools version 14 or higher. API/SDK HttpURLConnection, OkHttp2 (except versions 2.0 and 2.4), OkHttp (versions 2.8, 3.5+, 4.0+), OkIO (version 1.11), AndroidHttpClient, Volley (version 1.0.0), and Apache HTTP Client networking APIs Build with Android SDK Tools version 21 or higher and the following as appropriate: Android Studio Gradle 3.3 Gradle plugin 3.4 Proguard 5.0 DexGuard 7.2.04 through 8.x Important As of January 2021, our Android agent discontinued support for Android Gradle Plugin version 2. For more information, see our Explorers Hub post. Upgrade to the most recent version before installing the Android agent. Languages Java 1.7 through Java 9. JDK 11 is supported in version 6.2.0 and higher. Devices Any Android compatible device (smartphones, tablets, etc.) File sizes The agent adds less than 500KB to your release APK. Architectures ARM, Intel Atom Signature validation The agent cannot instrument JARs that use signature validation during signing. JARs with manifests containing SHA1-Digest or SHA-256-Digest attributes will not be modified. Agent and Gradle compatibility The following are compatible versions of the New Relic Android agent, Gradle, and the Android Gradle plugin. Important As of March 2021, our Android agent discontinued support for Android Gradle Plugin version 2. For more information, see our Explorers Hub post. Android Gradle plugin New Relic Android agent compatibility 2.3 No longer supported in versions 6.0 and higher. 5.25 - 5.26 are not supported 3.0 - 3.3 No longer supported in versions 6.0 and higher. 3.4 5.25 and higher 4.+ 5.26 and higher Kotlin and Kotlin DSL You can also use Kotlin projects with Gradle and New Relic's Android agent. Kotlin DSL support by Android agent version With the exception of incompatibilities noted with Android Gradle, New Relic's Android agent is compatible with versions 1.3 - 1.4 of the Kotlin Gradle Plugin. Kotlin DSL version New Relic Android agent compatibility 1.2 Unsupported 1.3 5.24 and lower: Requires Kotlin Gradle Plugin version 1.3.10 or higher 5.25: Requires Kotlin Gradle Plugin version 1.3.10 or higher 5.26: Unsupported in Android agent versions 5.26.0 through 5.28.0 1.4 5.24 and lower: Requires Kotlin Gradle Plugin version 1.3.10 or higher 5.25: Supported 5.26: Unsupported in Android agent versions 5.26.0 through 5.28.0 Kotlin DSL support by AGP version Kotlin DSL support was officially added to Android Gradle Plugin in version 4.1, but many developers are already using it in place of Groovy. Kotlin DSL version Android Gradle Plugin and Android Gradle compatibility 1.3 3.2 (AGP), 4.6 (Gradle) : Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.3 (AGP), (5.1.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.4 (AGP), 5.1.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.5 (AGP), 5.4.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.6 (AGP), 5.6.4 Gradle): Requires Kotlin Gradle Plugin version 1.3.40 or higher 4.0 (AGP), 6.1.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.40 or higher 4.1 (AGP), 6.5 Gradle): Requires Kotlin Gradle Plugin version 1.3.40 or higher 1.4 3.2 (AGP), 4.6 (Gradle) : Requires Gradle 5.3 3.3 (AGP), (5.1.1 Gradle): Requires Gradle 5.3 3.4 (AGP), 5.1.1 Gradle): Supported 3.5 (AGP), 5.4.1 Gradle): Supported 3.6 (AGP), 5.6.4 Gradle): Supported 4.0 (AGP), 6.1.1 Gradle): Supported 4.1 (AGP), 6.5 Gradle): Supported Unit testing not supported Our New Relic mobile agents are designed and tested to work in a normal app lifecycle. We do not support running any testing environment on applications with the agent. Testing can cause conflicts and unpredictable behavior.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.673195,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> agent compatibility and requirements",
        "sections": "Foreground <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "<em>Mobile</em> <em>monitoring</em> is compliant with standard application stores, including Google Play Store, Amazon Appstore, and others. Before you install and configure the <em>mobile</em> agent with your <em>Android</em> applications, follow these guidelines for compatibility and other requirements. Foreground <em>monitoring</em>"
      },
      "id": "604418abe7b9d2d1015799cc"
    },
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-04T16:38:01Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.069275,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": ". As part of the installation process, <em>mobile</em> <em>monitoring</em> automatically generates an application token. This is a 40-character hexadecimal string for authenticating each <em>mobile</em> app that you <em>monitor</em>. Follow the <em>Android</em> installation and configuration procedures for your environment as applicable. If you have"
      },
      "id": "6043a48f196a6784e6960f6d"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide": [
    {
      "sections": [
        "Android agent configuration and feature flags",
        "Change configuration settings",
        "Analytics settings",
        "withAnalyticsEvents",
        "FeatureFlag.AnalyticsEvents",
        "Application settings",
        "withApplicationVersion",
        "withApplicationBuild",
        "Crash and error reporting settings",
        "withCrashReportingEnabledFeatureFlag.CrashReportingEnabled",
        "FeatureFlag.HandledExceptions",
        "Distributed tracing",
        "FeatureFlag.DistributedTracing",
        "Interaction settings",
        "withInteractionTracingFeatureFlag.InteractionTracing",
        "withDefaultInteractionsFeatureFlag.DefaultInteractions",
        "Networking settings",
        "FeatureFlag.NetworkRequests",
        "FeatureFlag.NetworkErrorRequests",
        "withHttpResponseBodyCaptureEnabledFeatureFlag.HttpResponseBodyCaptureEnabled",
        "Logging settings",
        "withLoggingEnabled",
        "withLogLevel",
        "Data endpoint settings",
        "usingCollectorAddress",
        "usingCrashCollectorAddress"
      ],
      "title": "Android agent configuration and feature flags",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "32b377c3872e22295228a679522632e66b58a53e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-agent-configuration-feature-flags/",
      "published_at": "2021-12-04T16:40:39Z",
      "updated_at": "2021-11-05T14:07:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Android agent provides configuration settings to change the default behavior of the agent. For an explanation of mobile custom data types, see Add custom data to mobile monitoring. Change configuration settings All settings, including the call to invoke the agent, are called in the onCreate method of the MainActivity class. To change settings, call the setting in one of two ways (if the setting supports it): Change the setting on its own line for each specific condition: NewRelic. disableFeature(FeatureFlag.DefaultInteractions) ; NewRelic. enableFeature(FeatureFlag.CrashReporting) ; NewRelic.withApplicationToken(<NEW_RELIC_TOKEN>).start(this.getApplication()); Copy OR Change the setting as part of the agent start call using the .with method: NewRelic.withApplicationToken(<NEW_RELIC_TOKEN>) .withDefaultInteractions(false) .withCrashReportingEnabled(true) .start(this.getApplication()); Copy Analytics settings withAnalyticsEvents Enable or disable collection of event data. These events are reported to Insights and used in the Crash analysis page. Type Boolean Default true FeatureFlag.AnalyticsEvents Enable or disable the reporting of event data. Event collection will still occur; the events will just not be sent to our collector. You might decide to use this instead of withAnalyticsEvents if you wanted to disable collection but still be able to see what the agent was collecting. Type Boolean Default true Application settings withApplicationVersion Set custom application version strings. Type String Default Defaults to version number set in AndroidManifest.xml withApplicationBuild Set custom application build strings. Type String Default Defaults to build ID set in AndroidManifest.xml Crash and error reporting settings withCrashReportingEnabled FeatureFlag.CrashReportingEnabled Enable or disable crash reporting. Type Boolean Default true FeatureFlag.HandledExceptions Enable or disable recording handled exceptions events, which appear on the Handled exception page. Type Boolean Default true Distributed tracing FeatureFlag.DistributedTracing Enable or disable the adding of distributed tracing headers to network requests. Refer to How New Relic distributed tracing works for more information on distributed tracing in mobile apps. Type Boolean Default true Interaction settings withInteractionTracing FeatureFlag.InteractionTracing Enable or disable interaction tracing. Trace instrumentation still occurs, but no traces are harvested. This will disable default and custom interactions. Available for Android agent version 5.4.0 or higher. Type Boolean Default true withDefaultInteractions FeatureFlag.DefaultInteractions Enable or disable default interactions. Trace instrumentation still occurs, but no traces are harvested. This will enable or disable default interactions only while custom interactions remain enabled. Type Boolean Default true Networking settings FeatureFlag.NetworkRequests Enable or disable reporting successful HTTP requests to the MobileRequest event type in Insights. Available for Android agent version 5.14.0 or higher. Type Boolean Default true Enabled by default as of agent version 5.15.2 FeatureFlag.NetworkErrorRequests Enable or disable reporting network and Http request errors to MobileRequestError event type in Insights. Available for Android agent version 5.11.0 or higher. Type Boolean Default true withHttpResponseBodyCaptureEnabled FeatureFlag.HttpResponseBodyCaptureEnabled Enable or disable capture of HTTP response bodies for HTTP error traces, and MobileRequestError events. Type Boolean Default true Logging settings withLoggingEnabled Enable or disable agent logging. Type Boolean Default true withLogLevel Specifies the log level. Options include: ERROR (least verbose) WARNING INFO (default) VERBOSE DEBUG AUDIT (most verbose) Type String Default AgentLog.INFO To increase your logging level in the app, add .withLogLevel to your NewRelic.withApplicationToken() method call. For example: NewRelic.withApplicationToken(\"YOUR_APP_TOKEN\") .withLogLevel(AgentLog.DEBUG) .start(this.getApplication()); Copy Data endpoint settings usingCollectorAddress Specifies the URI authority component of the harvest data upload endpoint. Type Boolean Default mobile-collector.newrelic.com To replace data endpoint the agent will use when reporting data harvests, add .usingCollectorAddress() to your NewRelic.withApplicationToken() method call. For example: NewRelic.withApplicationToken(\"YOUR_APP_TOKEN\") .usingCollectorAddress(\"harvest-upload-delegate.domain.com\") .start(this.getApplication()); Copy This endpoint is also used for handled exception uploads. usingCrashCollectorAddress Specifies the authority component of the crash data upload URI. Type String Default mobile-crash.newrelic.com To replace data endpoint the agent will use when reporting crashes, add .usingCrashCollectorAddress() to your NewRelic.withApplicationToken() method call. For example: NewRelic.withApplicationToken(\"YOUR_APP_TOKEN\") .usingCrashCollectorAddress(\"crash-upload-delegate.domain.com\") .start(this.getApplication()); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.53693,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> agent configuration and feature flags",
        "sections": "<em>Android</em> agent configuration and feature flags",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "The <em>Android</em> agent provides configuration settings to change the default behavior of the agent. For an explanation of <em>mobile</em> custom data types, see Add custom data to <em>mobile</em> <em>monitoring</em>. Change configuration settings All settings, including the call to invoke the agent, are called in the onCreate"
      },
      "id": "619f17fce7b9d2ef84fe5e31"
    },
    {
      "sections": [
        "Android agent compatibility and requirements",
        "Foreground monitoring",
        "Android compatibility",
        "Important",
        "Agent and Gradle compatibility",
        "Kotlin and Kotlin DSL",
        "Kotlin DSL support by Android agent version",
        "Kotlin DSL support by AGP version",
        "Unit testing not supported"
      ],
      "title": "Android agent compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "fdae9b0d2971ed33098e8c7cf6152654e45cca69",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/new-relic-android-compatibility-requirements/",
      "published_at": "2021-12-04T16:38:37Z",
      "updated_at": "2021-11-13T03:49:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring is compliant with standard application stores, including Google Play Store, Amazon Appstore, and others. Before you install and configure the mobile agent with your Android applications, follow these guidelines for compatibility and other requirements. Foreground monitoring The Android agent only monitors your app while it is in the foreground. The agent does not monitor background services while the app is closed. For more information, see our Mobile data privacy and security documentation. Android compatibility Make sure your Android app meets these requirements: Component Application requirements Operating system Android 5.0 or higher Version 6.0.0 and higher: Build must be compiled with Android SDK Tools version 21 or higher. Version 5.0.0 and higher: Build must be compiled with Android SDK Tools version 14 or higher. API/SDK HttpURLConnection, OkHttp2 (except versions 2.0 and 2.4), OkHttp (versions 2.8, 3.5+, 4.0+), OkIO (version 1.11), AndroidHttpClient, Volley (version 1.0.0), and Apache HTTP Client networking APIs Build with Android SDK Tools version 21 or higher and the following as appropriate: Android Studio Gradle 3.3 Gradle plugin 3.4 Proguard 5.0 DexGuard 7.2.04 through 8.x Important As of January 2021, our Android agent discontinued support for Android Gradle Plugin version 2. For more information, see our Explorers Hub post. Upgrade to the most recent version before installing the Android agent. Languages Java 1.7 through Java 9. JDK 11 is supported in version 6.2.0 and higher. Devices Any Android compatible device (smartphones, tablets, etc.) File sizes The agent adds less than 500KB to your release APK. Architectures ARM, Intel Atom Signature validation The agent cannot instrument JARs that use signature validation during signing. JARs with manifests containing SHA1-Digest or SHA-256-Digest attributes will not be modified. Agent and Gradle compatibility The following are compatible versions of the New Relic Android agent, Gradle, and the Android Gradle plugin. Important As of March 2021, our Android agent discontinued support for Android Gradle Plugin version 2. For more information, see our Explorers Hub post. Android Gradle plugin New Relic Android agent compatibility 2.3 No longer supported in versions 6.0 and higher. 5.25 - 5.26 are not supported 3.0 - 3.3 No longer supported in versions 6.0 and higher. 3.4 5.25 and higher 4.+ 5.26 and higher Kotlin and Kotlin DSL You can also use Kotlin projects with Gradle and New Relic's Android agent. Kotlin DSL support by Android agent version With the exception of incompatibilities noted with Android Gradle, New Relic's Android agent is compatible with versions 1.3 - 1.4 of the Kotlin Gradle Plugin. Kotlin DSL version New Relic Android agent compatibility 1.2 Unsupported 1.3 5.24 and lower: Requires Kotlin Gradle Plugin version 1.3.10 or higher 5.25: Requires Kotlin Gradle Plugin version 1.3.10 or higher 5.26: Unsupported in Android agent versions 5.26.0 through 5.28.0 1.4 5.24 and lower: Requires Kotlin Gradle Plugin version 1.3.10 or higher 5.25: Supported 5.26: Unsupported in Android agent versions 5.26.0 through 5.28.0 Kotlin DSL support by AGP version Kotlin DSL support was officially added to Android Gradle Plugin in version 4.1, but many developers are already using it in place of Groovy. Kotlin DSL version Android Gradle Plugin and Android Gradle compatibility 1.3 3.2 (AGP), 4.6 (Gradle) : Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.3 (AGP), (5.1.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.4 (AGP), 5.1.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.5 (AGP), 5.4.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.6 (AGP), 5.6.4 Gradle): Requires Kotlin Gradle Plugin version 1.3.40 or higher 4.0 (AGP), 6.1.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.40 or higher 4.1 (AGP), 6.5 Gradle): Requires Kotlin Gradle Plugin version 1.3.40 or higher 1.4 3.2 (AGP), 4.6 (Gradle) : Requires Gradle 5.3 3.3 (AGP), (5.1.1 Gradle): Requires Gradle 5.3 3.4 (AGP), 5.1.1 Gradle): Supported 3.5 (AGP), 5.4.1 Gradle): Supported 3.6 (AGP), 5.6.4 Gradle): Supported 4.0 (AGP), 6.1.1 Gradle): Supported 4.1 (AGP), 6.5 Gradle): Supported Unit testing not supported Our New Relic mobile agents are designed and tested to work in a normal app lifecycle. We do not support running any testing environment on applications with the agent. Testing can cause conflicts and unpredictable behavior.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.673195,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> agent compatibility and requirements",
        "sections": "Foreground <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "<em>Mobile</em> <em>monitoring</em> is compliant with standard application stores, including Google Play Store, Amazon Appstore, and others. Before you install and configure the <em>mobile</em> agent with your <em>Android</em> applications, follow these guidelines for compatibility and other requirements. Foreground <em>monitoring</em>"
      },
      "id": "604418abe7b9d2d1015799cc"
    },
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-04T16:38:01Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.069275,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": ". As part of the installation process, <em>mobile</em> <em>monitoring</em> automatically generates an application token. This is a 40-character hexadecimal string for authenticating each <em>mobile</em> app that you <em>monitor</em>. Follow the <em>Android</em> installation and configuration procedures for your environment as applicable. If you have"
      },
      "id": "6043a48f196a6784e6960f6d"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/crashnow-android-sdk-api": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-04T16:38:01Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 204.28284,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-04T16:41:13Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.44785,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Important Starting with version 5.9.0 of the <em>New</em> <em>Relic</em> <em>Android</em> agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the <em>NewRelic</em>.setUserId method. The <em>Android</em> agent provides an <em>SDK</em> <em>API</em> to set up custom"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-12-04T16:42:33Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.24748,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/currentsessionid-android-sdk-api": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-04T16:38:01Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 204.28282,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-04T16:41:13Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.44783,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Important Starting with version 5.9.0 of the <em>New</em> <em>Relic</em> <em>Android</em> agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the <em>NewRelic</em>.setUserId method. The <em>Android</em> agent provides an <em>SDK</em> <em>API</em> to set up custom"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-12-04T16:42:33Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.24748,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/end-interaction": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-04T16:38:01Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 204.28282,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-04T16:41:13Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.44783,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Important Starting with version 5.9.0 of the <em>New</em> <em>Relic</em> <em>Android</em> agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the <em>NewRelic</em>.setUserId method. The <em>Android</em> agent provides an <em>SDK</em> <em>API</em> to set up custom"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-12-04T16:42:33Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.24748,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/increment-attribute": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-04T16:38:01Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 204.2828,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-04T16:41:13Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.44781,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Important Starting with version 5.9.0 of the <em>New</em> <em>Relic</em> <em>Android</em> agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the <em>NewRelic</em>.setUserId method. The <em>Android</em> agent provides an <em>SDK</em> <em>API</em> to set up custom"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-12-04T16:42:33Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.24748,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-http-transaction": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-04T16:38:01Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 204.2828,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-04T16:41:13Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.44781,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Important Starting with version 5.9.0 of the <em>New</em> <em>Relic</em> <em>Android</em> agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the <em>NewRelic</em>.setUserId method. The <em>Android</em> agent provides an <em>SDK</em> <em>API</em> to set up custom"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-12-04T16:42:33Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.24748,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-04T16:38:01Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 204.2828,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-04T16:41:13Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.44781,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Important Starting with version 5.9.0 of the <em>New</em> <em>Relic</em> <em>Android</em> agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the <em>NewRelic</em>.setUserId method. The <em>Android</em> agent provides an <em>SDK</em> <em>API</em> to set up custom"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "noticeHttpTransaction (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record HTTP transaction"
      ],
      "title": "noticeHttpTransaction (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "3232e4a19b883d229a9611a2a5cc7b4a002c9f84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-http-transaction/",
      "published_at": "2021-12-04T16:42:00Z",
      "updated_at": "2021-07-09T15:31:23Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeHttpTransaction(string $url, string $httpMethod, int $statusCode, long $startTime, long $endTime, long $bytesSent, long $bytesReceived [, string $responseBody]) Copy Tracks networks requests. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests and network failures. You can use noticeHttpTransaction to record HTTP transactions, with an option to also send a response body. If a network request fails, you can record details about the failure with noticeNetworkFailure(). For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK. $startTime int Required. The start time of the request in milliseconds since the epoch. $endTime int Required. The end time of the request in milliseconds since the epoch. $bytesSent int Required. The number of bytes sent in the request. $bytesReceived int Required. The number of bytes received in the response. $responseBody string Optional. The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. Examples Record HTTP transaction An example of tracking an HTTP transaction: public class CustomHttpMetricsLogger implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); //collect request start time long t1 = System.nanoTime(); //get the size of the request body long requestSize = null == request.body() ? 0 : request.body().contentLength(); //proceed with the request Response response = chain.proceed(request); //capture the time when response returns long t2 = System.nanoTime(); long responseSize = null == response.body() ? 0 : response.body().contentLength(); //tell New Relic to notice this request NewRelic.noticeHttpTransaction(request.urlString(), request.method(), response.code(), t1, t2, requestSize, responseSize); //return response for processing return response; } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.43236,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeHttpTransaction (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " info on using the <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em>, see the usage guide. Parameters Parameter Description $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $statusCode int Required. The statusCode of the HTTP response, such as 200 for OK"
      },
      "id": "6044e8b6e7b9d26e235799e9"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/recordbreadcrumb": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-04T16:38:01Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 204.2828,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-04T16:41:13Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.44781,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Important Starting with version 5.9.0 of the <em>New</em> <em>Relic</em> <em>Android</em> agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the <em>NewRelic</em>.setUserId method. The <em>Android</em> agent provides an <em>SDK</em> <em>API</em> to set up custom"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-12-04T16:42:33Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.24748,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/recordcustomevent-android-sdk-api": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-04T16:38:01Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 204.2828,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-04T16:41:13Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.44781,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Important Starting with version 5.9.0 of the <em>New</em> <em>Relic</em> <em>Android</em> agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the <em>NewRelic</em>.setUserId method. The <em>Android</em> agent provides an <em>SDK</em> <em>API</em> to set up custom"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-12-04T16:42:33Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.24748,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/recordhandledexception-android-sdk-api": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-04T16:38:01Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 204.2828,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-04T16:41:13Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.4478,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Important Starting with version 5.9.0 of the <em>New</em> <em>Relic</em> <em>Android</em> agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the <em>NewRelic</em>.setUserId method. The <em>Android</em> agent provides an <em>SDK</em> <em>API</em> to set up custom"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-12-04T16:42:33Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.24748,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/recordmetric-android-sdk-api": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-04T16:38:01Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 204.2828,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-04T16:41:13Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.4478,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Important Starting with version 5.9.0 of the <em>New</em> <em>Relic</em> <em>Android</em> agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the <em>NewRelic</em>.setUserId method. The <em>Android</em> agent provides an <em>SDK</em> <em>API</em> to set up custom"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-12-04T16:42:33Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.24748,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/remove-all-attributes": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-04T16:38:01Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 204.28279,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-04T16:41:13Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.44778,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Important Starting with version 5.9.0 of the <em>New</em> <em>Relic</em> <em>Android</em> agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the <em>NewRelic</em>.setUserId method. The <em>Android</em> agent provides an <em>SDK</em> <em>API</em> to set up custom"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-12-04T16:42:33Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.24748,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/remove-attribute": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-04T16:38:01Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 204.28279,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-04T16:41:13Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.44778,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Important Starting with version 5.9.0 of the <em>New</em> <em>Relic</em> <em>Android</em> agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the <em>NewRelic</em>.setUserId method. The <em>Android</em> agent provides an <em>SDK</em> <em>API</em> to set up custom"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-12-04T16:42:33Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.24748,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/set-attribute": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-04T16:38:01Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 204.28279,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-04T16:41:13Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.44778,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Important Starting with version 5.9.0 of the <em>New</em> <em>Relic</em> <em>Android</em> agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the <em>NewRelic</em>.setUserId method. The <em>Android</em> agent provides an <em>SDK</em> <em>API</em> to set up custom"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-12-04T16:42:33Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.24748,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/set-interaction-name": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-04T16:38:01Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 204.28278,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-04T16:41:13Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.44778,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Important Starting with version 5.9.0 of the <em>New</em> <em>Relic</em> <em>Android</em> agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the <em>NewRelic</em>.setUserId method. The <em>Android</em> agent provides an <em>SDK</em> <em>API</em> to set up custom"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-12-04T16:42:33Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.24748,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/set-max-event-buffer-time": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-04T16:38:01Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 204.28278,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-04T16:41:13Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.44778,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Important Starting with version 5.9.0 of the <em>New</em> <em>Relic</em> <em>Android</em> agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the <em>NewRelic</em>.setUserId method. The <em>Android</em> agent provides an <em>SDK</em> <em>API</em> to set up custom"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-12-04T16:42:33Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.24748,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    }
  ]
}