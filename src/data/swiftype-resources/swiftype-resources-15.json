{
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/recordhandledexception-android-sdk-api": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-30T06:04:43Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.59901,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-30T06:12:18Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.92209,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Important Starting with version 5.9.0 of the <em>New</em> <em>Relic</em> <em>Android</em> agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the <em>NewRelic</em>.setUserId method. The <em>Android</em> agent provides an <em>SDK</em> <em>API</em> to set up custom"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-12-30T06:13:13Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.45522,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/recordmetric-android-sdk-api": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-30T06:04:43Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.59901,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-30T06:12:18Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.92209,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Important Starting with version 5.9.0 of the <em>New</em> <em>Relic</em> <em>Android</em> agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the <em>NewRelic</em>.setUserId method. The <em>Android</em> agent provides an <em>SDK</em> <em>API</em> to set up custom"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-12-30T06:13:13Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.45522,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/remove-all-attributes": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-30T06:04:43Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.59901,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-30T06:12:18Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.92207,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Important Starting with version 5.9.0 of the <em>New</em> <em>Relic</em> <em>Android</em> agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the <em>NewRelic</em>.setUserId method. The <em>Android</em> agent provides an <em>SDK</em> <em>API</em> to set up custom"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-12-30T06:13:13Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.45522,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/remove-attribute": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-30T06:04:43Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.59901,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-30T06:12:18Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.92207,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Important Starting with version 5.9.0 of the <em>New</em> <em>Relic</em> <em>Android</em> agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the <em>NewRelic</em>.setUserId method. The <em>Android</em> agent provides an <em>SDK</em> <em>API</em> to set up custom"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-12-30T06:13:13Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.45522,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/set-attribute": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-30T06:04:43Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.599,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-30T06:12:18Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.92207,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Important Starting with version 5.9.0 of the <em>New</em> <em>Relic</em> <em>Android</em> agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the <em>NewRelic</em>.setUserId method. The <em>Android</em> agent provides an <em>SDK</em> <em>API</em> to set up custom"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-12-30T06:13:13Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.45522,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/set-interaction-name": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-30T06:04:43Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.599,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-30T06:12:18Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.92207,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Important Starting with version 5.9.0 of the <em>New</em> <em>Relic</em> <em>Android</em> agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the <em>NewRelic</em>.setUserId method. The <em>Android</em> agent provides an <em>SDK</em> <em>API</em> to set up custom"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-12-30T06:13:13Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.45522,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/set-max-event-buffer-time": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-30T06:04:43Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.599,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-30T06:12:18Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.92207,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Important Starting with version 5.9.0 of the <em>New</em> <em>Relic</em> <em>Android</em> agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the <em>NewRelic</em>.setUserId method. The <em>Android</em> agent provides an <em>SDK</em> <em>API</em> to set up custom"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-12-30T06:13:13Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.45522,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/set-max-event-pool-size": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-30T06:04:43Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.599,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-30T06:12:18Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.92207,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Important Starting with version 5.9.0 of the <em>New</em> <em>Relic</em> <em>Android</em> agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the <em>NewRelic</em>.setUserId method. The <em>Android</em> agent provides an <em>SDK</em> <em>API</em> to set up custom"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-12-30T06:13:13Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.45522,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/set-user-id": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-30T06:04:43Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.599,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-30T06:12:18Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.92207,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Important Starting with version 5.9.0 of the <em>New</em> <em>Relic</em> <em>Android</em> agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the <em>NewRelic</em>.setUserId method. The <em>Android</em> agent provides an <em>SDK</em> <em>API</em> to set up custom"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-12-30T06:13:13Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.45522,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/start-interaction": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-30T06:04:43Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.599,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-30T06:12:18Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.92206,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Important Starting with version 5.9.0 of the <em>New</em> <em>Relic</em> <em>Android</em> agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the <em>NewRelic</em>.setUserId method. The <em>Android</em> agent provides an <em>SDK</em> <em>API</em> to set up custom"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-12-30T06:13:13Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.45522,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/with-application-build": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-30T06:04:43Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.599,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-30T06:12:18Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.92206,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Important Starting with version 5.9.0 of the <em>New</em> <em>Relic</em> <em>Android</em> agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the <em>NewRelic</em>.setUserId method. The <em>Android</em> agent provides an <em>SDK</em> <em>API</em> to set up custom"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-12-30T06:13:13Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.45522,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/with-application-version": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-30T06:04:43Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.599,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-30T06:12:18Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.92206,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Important Starting with version 5.9.0 of the <em>New</em> <em>Relic</em> <em>Android</em> agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the <em>NewRelic</em>.setUserId method. The <em>Android</em> agent provides an <em>SDK</em> <em>API</em> to set up custom"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-12-30T06:13:13Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.45522,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/with-interaction-tracing": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-30T06:04:43Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.599,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-30T06:12:18Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.92206,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>Android</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Important Starting with version 5.9.0 of the <em>New</em> <em>Relic</em> <em>Android</em> agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the <em>NewRelic</em>.setUserId method. The <em>Android</em> agent provides an <em>SDK</em> <em>API</em> to set up custom"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "noticeNetworkFailure (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record network failure"
      ],
      "title": "noticeNetworkFailure (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "eee872a3e0e4d6f512b27b29f3dd956aaad80d1a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/notice-network-failure/",
      "published_at": "2021-12-30T06:13:13Z",
      "updated_at": "2021-07-09T15:31:33Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The New Relic Android SDK API provides several methods to track network requests. If a network request fails, you can record details about the failure with noticeNetworkFailure. In most cases, place this call inside exception handlers, such as catch blocks. For general info on using the New Relic Android SDK API, see the usage guide. Parameters Parameter Description NewRelic.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR $networkFailure) Copy $url string Required. The URL of the request. $httpMethod string Required. The HTTP method used, such as GET or POST. $startTime long Required. The start time of the request in milliseconds since the epoch. $endTime long Required. The end time of the request in milliseconds since the epoch. $exception string Either this or $failure parameter is required. This is the exception that occurred. New Relic can automatically translate many common exceptions into network failure types. $failure enum Either this or $exception parameter is required. The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Examples Record network failure Here’s an example of an error listener that uses an error as part of the noticed network failure to New Relic: new Response.ErrorListener() { @Override public void onErrorResponse(Error error) { NewRelic.noticeNetworkFailure(badUrl, \"GET\", System.nanoTime(), System.nanoTime(), NetworkFailure.exceptionToNetworkFailure(error)); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.45522,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "noticeNetworkFailure (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.noticeNetworkFailure(string $url, string $httpMethod, long $startTime, long $endTime, exception $exception OR enum $networkFailure) Copy Records network failures. Requirements Compatible with all agent versions. Description The <em>New</em> <em>Relic</em> <em>Android</em> <em>SDK</em> <em>API</em> provides several methods"
      },
      "id": "6044e87d28ccbcb27a2c60d5"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android": [
    {
      "sections": [
        "Android agent compatibility and requirements",
        "Foreground monitoring",
        "Android compatibility",
        "Important",
        "Agent and Gradle compatibility",
        "Kotlin and Kotlin DSL",
        "Kotlin DSL support by Android agent version",
        "Kotlin DSL support by AGP version",
        "Unit testing not supported"
      ],
      "title": "Android agent compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "fdae9b0d2971ed33098e8c7cf6152654e45cca69",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/new-relic-android-compatibility-requirements/",
      "published_at": "2021-12-30T07:42:50Z",
      "updated_at": "2021-11-13T03:49:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring is compliant with standard application stores, including Google Play Store, Amazon Appstore, and others. Before you install and configure the mobile agent with your Android applications, follow these guidelines for compatibility and other requirements. Foreground monitoring The Android agent only monitors your app while it is in the foreground. The agent does not monitor background services while the app is closed. For more information, see our Mobile data privacy and security documentation. Android compatibility Make sure your Android app meets these requirements: Component Application requirements Operating system Android 5.0 or higher Version 6.0.0 and higher: Build must be compiled with Android SDK Tools version 21 or higher. Version 5.0.0 and higher: Build must be compiled with Android SDK Tools version 14 or higher. API/SDK HttpURLConnection, OkHttp2 (except versions 2.0 and 2.4), OkHttp (versions 2.8, 3.5+, 4.0+), OkIO (version 1.11), AndroidHttpClient, Volley (version 1.0.0), and Apache HTTP Client networking APIs Build with Android SDK Tools version 21 or higher and the following as appropriate: Android Studio Gradle 3.3 Gradle plugin 3.4 Proguard 5.0 DexGuard 7.2.04 through 8.x Important As of January 2021, our Android agent discontinued support for Android Gradle Plugin version 2. For more information, see our Explorers Hub post. Upgrade to the most recent version before installing the Android agent. Languages Java 1.7 through Java 9. JDK 11 is supported in version 6.2.0 and higher. Devices Any Android compatible device (smartphones, tablets, etc.) File sizes The agent adds less than 500KB to your release APK. Architectures ARM, Intel Atom Signature validation The agent cannot instrument JARs that use signature validation during signing. JARs with manifests containing SHA1-Digest or SHA-256-Digest attributes will not be modified. Agent and Gradle compatibility The following are compatible versions of the New Relic Android agent, Gradle, and the Android Gradle plugin. Important As of March 2021, our Android agent discontinued support for Android Gradle Plugin version 2. For more information, see our Explorers Hub post. Android Gradle plugin New Relic Android agent compatibility 2.3 No longer supported in versions 6.0 and higher. 5.25 - 5.26 are not supported 3.0 - 3.3 No longer supported in versions 6.0 and higher. 3.4 5.25 and higher 4.+ 5.26 and higher Kotlin and Kotlin DSL You can also use Kotlin projects with Gradle and New Relic's Android agent. Kotlin DSL support by Android agent version With the exception of incompatibilities noted with Android Gradle, New Relic's Android agent is compatible with versions 1.3 - 1.4 of the Kotlin Gradle Plugin. Kotlin DSL version New Relic Android agent compatibility 1.2 Unsupported 1.3 5.24 and lower: Requires Kotlin Gradle Plugin version 1.3.10 or higher 5.25: Requires Kotlin Gradle Plugin version 1.3.10 or higher 5.26: Unsupported in Android agent versions 5.26.0 through 5.28.0 1.4 5.24 and lower: Requires Kotlin Gradle Plugin version 1.3.10 or higher 5.25: Supported 5.26: Unsupported in Android agent versions 5.26.0 through 5.28.0 Kotlin DSL support by AGP version Kotlin DSL support was officially added to Android Gradle Plugin in version 4.1, but many developers are already using it in place of Groovy. Kotlin DSL version Android Gradle Plugin and Android Gradle compatibility 1.3 3.2 (AGP), 4.6 (Gradle) : Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.3 (AGP), (5.1.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.4 (AGP), 5.1.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.5 (AGP), 5.4.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.6 (AGP), 5.6.4 Gradle): Requires Kotlin Gradle Plugin version 1.3.40 or higher 4.0 (AGP), 6.1.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.40 or higher 4.1 (AGP), 6.5 Gradle): Requires Kotlin Gradle Plugin version 1.3.40 or higher 1.4 3.2 (AGP), 4.6 (Gradle) : Requires Gradle 5.3 3.3 (AGP), (5.1.1 Gradle): Requires Gradle 5.3 3.4 (AGP), 5.1.1 Gradle): Supported 3.5 (AGP), 5.4.1 Gradle): Supported 3.6 (AGP), 5.6.4 Gradle): Supported 4.0 (AGP), 6.1.1 Gradle): Supported 4.1 (AGP), 6.5 Gradle): Supported Unit testing not supported Our New Relic mobile agents are designed and tested to work in a normal app lifecycle. We do not support running any testing environment on applications with the agent. Testing can cause conflicts and unpredictable behavior.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.96236,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> agent compatibility and requirements",
        "sections": "Foreground <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "<em>Mobile</em> <em>monitoring</em> is compliant with standard application stores, including Google Play Store, Amazon Appstore, and others. Before you install and configure the <em>mobile</em> agent with your <em>Android</em> applications, follow these guidelines for compatibility and other requirements. Foreground <em>monitoring</em>"
      },
      "id": "604418abe7b9d2d1015799cc"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/new-relic-mobile-and-dt/",
      "sections": [
        "New Relic mobile monitoring with distributed tracing",
        "Requirements",
        "Tip",
        "How to set up distributed tracing",
        "Find data",
        "Troubleshooting"
      ],
      "published_at": "2021-12-30T09:14:17Z",
      "title": "New Relic mobile monitoring with distributed tracing",
      "updated_at": "2021-12-30T09:14:16Z",
      "type": "docs",
      "external_id": "c9846b0f2811bb718f79ce7321c4239032eb310e",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic mobile monitoring agents support distributed tracing. This lets you see how your mobile app activity connects to related services. Watch this short video (approx. 2:15 minutes) to learn how to: Find mobile distributed tracing data in New Relic. Filter by standard and custom attributes. Requirements Here's what you need to use distributed tracing with New Relic mobile: Android agent version 6.0.0 or higher XCFramework agent version 7.3.0 Tip Infinite Tracing is not yet available for mobile monitoring. How to set up distributed tracing For mobile agents that support this feature, it’s enabled by default. If you prefer to turn off distributed tracing, see the following: Android feature flag iOS feature flag Find data Mobile spans appear in any New Relic distributed tracing UI where those spans are part of a trace. Here are some tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting mobileApp.name to the browser app name. Query for traces containing at least one mobile app span with mobileApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both mobile and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.74225,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>monitoring</em> with distributed tracing",
        "sections": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>monitoring</em> with distributed tracing",
        "body": ". Requirements Here&#x27;s what you need to use distributed tracing with <em>New</em> <em>Relic</em> <em>mobile</em>: <em>Android</em> agent version 6.0.0 or higher XCFramework agent version 7.3.0 Tip Infinite Tracing is not yet available for <em>mobile</em> <em>monitoring</em>. How to set up distributed tracing For <em>mobile</em> agents that support this feature, it’s"
      },
      "id": "605858d464441f445f868bac"
    },
    {
      "sections": [
        "Install Android apps with Gradle and Android Studio",
        "Install your Android app",
        "Configure with Gradle and Android Studio",
        "Project level build.gradle file:",
        "App level build.gradle file:",
        "Important",
        "Update your Android installation",
        "Android 4.x: Multidex support",
        "New Relic Gradle Plugin configuration"
      ],
      "title": "Install Android apps with Gradle and Android Studio",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "51fab3eba87ddee949cd4729de8b5f64534de9c7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-android-apps-gradle-android-studio/",
      "published_at": "2021-12-30T06:16:04Z",
      "updated_at": "2021-07-27T17:09:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Gradle or Android Studio, follow these instructions to install New Relic's mobile monitoring for the first time. If you have previously installed the Android agent SDK for mobile monitoring, follow the steps before upgrading to the latest version with Gradle and Android Studio. Install your Android app As part of the installation process for mobile monitoring, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. Go to one.newrelic.com > Mobile. If applicable: From the Mobile apps index, select Add a new app. From the Get started page, select Android as the platform for mobile monitoring. Type a meaningful name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring with Gradle and Android Studio. OR: To complete the configuration process for a new mobile app later: Go to one.newrelic.com > Mobile, then select See instructions next to your mobile app name. To upgrade an existing Android installation: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Configure with Gradle and Android Studio These procedures to configure your Android app with Gradle and Android Studio also appear on the Get started page in New Relic. Merge New Relic's mobile monitoring code in the Gradle & Android Studio tab to your build.gradle file. Project level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. buildscript { repositories { mavenCentral() } dependencies { classpath \"com.newrelic.agent.android:agent-gradle-plugin:AGENT_VERSION\" } } Copy App level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. repositories { mavenCentral() } apply plugin: 'android' apply plugin: 'newrelic' dependencies { compile 'com.newrelic.agent.android:android-agent:AGENT_VERSION' } Copy ProGuard or DexGuard: In your project’s root directory (projectname/app), add a newrelic.properties file with the following line: com.newrelic.application_token=GENERATED_TOKEN Copy Follow the additional, required configuration steps for using ProGuard or DexGuard with New Relic. Set app permissions: Ensure that your Android app requests INTERNET and ACCESS_NETWORK_STATE permissions by adding these lines to your AndroidManifest.xml file: <uses-permission android:name=\"android.permission.INTERNET\" /> <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /> Copy To start New Relic's mobile monitoring agent: In your Default Activity (as defined in your Manifest), import the NewRelic class: import com.newrelic.agent.android.NewRelic; Copy Important We do not support starting the mobile monitoring agent in other classes, as that can cause unexpected or unstable behavior. To initialize mobile monitoring: In the onCreate() method, add this call: NewRelic.withApplicationToken(\"GENERATED_TOKEN\").start(this.getApplication()); Copy Optional: Change the logging level. To build and run your application: Clean your project, then run your app in an emulator or device to generate traffic. Wait a few minutes, then view data for your Android app from the Overview page: Go to one.newrelic.com > Mobile > (select an app). If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI, follow the troubleshooting procedures. Update your Android installation To keep your Android agent up to date, follow the procedures to upgrade the Android agent SDK for New Relic. To install the latest Android version for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Android 4.x: Multidex support New Relic's mobile monitoring for Android versions prior to Android 5.0 (API level 21) use the Dalvik runtime to execute app code. By default, Dalvik limits apps to a single classes.dex bytecode file per APK. In order to get around this limitation, you must enable multidex support. Then you can use the multidex support library, which becomes part of the primary DEX file of your app and then manages access to the additional DEX files and the code they contain. When building each DEX file for a multidex app, the build tools perform complex decision making to determine which classes are needed in the primary DEX file so that your app can start successfully. If any class required during startup is not provided in the primary DEX file, then your app crashes with the error java.lang.NoClassDefFoundError. If you see the java.lang.NoClassDefFoundError error, then you must manually specify these additional classes as required in the primary DEX file: Create a proguard.multidex.config file within the /app folder of your project. Update mypackage to reflect your package name. #################### # keep class names # #################### #Keep New Relic in the main dex -keep class com.newrelic.** { *; } -keep class com.mypackage.activities.** { *; } Copy Merge the following code into the app-level build.gradle file: android { defaultConfig{ … multiDexKeepProguard file(\"proguard.multidex.config\") } } Copy For more information, see the Android Developers documentation on declaring classes required in the primary DEX file. New Relic Gradle Plugin configuration For details on how to configure the behavior of the mobile monitoring agent plugin during Gradle builds, see the New Relic Gradle plugin extension guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.35041,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "sections": "<em>New</em> <em>Relic</em> Gradle Plugin configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " These procedures to configure your <em>Android</em> app with Gradle and <em>Android</em> Studio also appear on the <em>Get</em> <em>started</em> page in <em>New</em> <em>Relic</em>. Merge <em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> code in the Gradle &amp; <em>Android</em> Studio tab to your build.gradle file. Project level build.gradle file: In this example, AGENT_VERSION represents your"
      },
      "id": "603ea70128ccbc59c2eba74e"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/get-started/new-relic-android-compatibility-requirements": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-12-30T06:04:43Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.6204,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": ". As part of the installation process, <em>mobile</em> <em>monitoring</em> automatically generates an application token. This is a 40-character hexadecimal string for authenticating each <em>mobile</em> app that you <em>monitor</em>. Follow the <em>Android</em> installation and configuration procedures for your environment as applicable. If you have"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/new-relic-mobile-and-dt/",
      "sections": [
        "New Relic mobile monitoring with distributed tracing",
        "Requirements",
        "Tip",
        "How to set up distributed tracing",
        "Find data",
        "Troubleshooting"
      ],
      "published_at": "2021-12-30T09:14:17Z",
      "title": "New Relic mobile monitoring with distributed tracing",
      "updated_at": "2021-12-30T09:14:16Z",
      "type": "docs",
      "external_id": "c9846b0f2811bb718f79ce7321c4239032eb310e",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic mobile monitoring agents support distributed tracing. This lets you see how your mobile app activity connects to related services. Watch this short video (approx. 2:15 minutes) to learn how to: Find mobile distributed tracing data in New Relic. Filter by standard and custom attributes. Requirements Here's what you need to use distributed tracing with New Relic mobile: Android agent version 6.0.0 or higher XCFramework agent version 7.3.0 Tip Infinite Tracing is not yet available for mobile monitoring. How to set up distributed tracing For mobile agents that support this feature, it’s enabled by default. If you prefer to turn off distributed tracing, see the following: Android feature flag iOS feature flag Find data Mobile spans appear in any New Relic distributed tracing UI where those spans are part of a trace. Here are some tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting mobileApp.name to the browser app name. Query for traces containing at least one mobile app span with mobileApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both mobile and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.74225,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>monitoring</em> with distributed tracing",
        "sections": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>monitoring</em> with distributed tracing",
        "body": ". Requirements Here&#x27;s what you need to use distributed tracing with <em>New</em> <em>Relic</em> <em>mobile</em>: <em>Android</em> agent version 6.0.0 or higher XCFramework agent version 7.3.0 Tip Infinite Tracing is not yet available for <em>mobile</em> <em>monitoring</em>. How to set up distributed tracing For <em>mobile</em> agents that support this feature, it’s"
      },
      "id": "605858d464441f445f868bac"
    },
    {
      "sections": [
        "Install Android apps with Gradle and Android Studio",
        "Install your Android app",
        "Configure with Gradle and Android Studio",
        "Project level build.gradle file:",
        "App level build.gradle file:",
        "Important",
        "Update your Android installation",
        "Android 4.x: Multidex support",
        "New Relic Gradle Plugin configuration"
      ],
      "title": "Install Android apps with Gradle and Android Studio",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "51fab3eba87ddee949cd4729de8b5f64534de9c7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-android-apps-gradle-android-studio/",
      "published_at": "2021-12-30T06:16:04Z",
      "updated_at": "2021-07-27T17:09:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Gradle or Android Studio, follow these instructions to install New Relic's mobile monitoring for the first time. If you have previously installed the Android agent SDK for mobile monitoring, follow the steps before upgrading to the latest version with Gradle and Android Studio. Install your Android app As part of the installation process for mobile monitoring, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. Go to one.newrelic.com > Mobile. If applicable: From the Mobile apps index, select Add a new app. From the Get started page, select Android as the platform for mobile monitoring. Type a meaningful name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring with Gradle and Android Studio. OR: To complete the configuration process for a new mobile app later: Go to one.newrelic.com > Mobile, then select See instructions next to your mobile app name. To upgrade an existing Android installation: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Configure with Gradle and Android Studio These procedures to configure your Android app with Gradle and Android Studio also appear on the Get started page in New Relic. Merge New Relic's mobile monitoring code in the Gradle & Android Studio tab to your build.gradle file. Project level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. buildscript { repositories { mavenCentral() } dependencies { classpath \"com.newrelic.agent.android:agent-gradle-plugin:AGENT_VERSION\" } } Copy App level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. repositories { mavenCentral() } apply plugin: 'android' apply plugin: 'newrelic' dependencies { compile 'com.newrelic.agent.android:android-agent:AGENT_VERSION' } Copy ProGuard or DexGuard: In your project’s root directory (projectname/app), add a newrelic.properties file with the following line: com.newrelic.application_token=GENERATED_TOKEN Copy Follow the additional, required configuration steps for using ProGuard or DexGuard with New Relic. Set app permissions: Ensure that your Android app requests INTERNET and ACCESS_NETWORK_STATE permissions by adding these lines to your AndroidManifest.xml file: <uses-permission android:name=\"android.permission.INTERNET\" /> <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /> Copy To start New Relic's mobile monitoring agent: In your Default Activity (as defined in your Manifest), import the NewRelic class: import com.newrelic.agent.android.NewRelic; Copy Important We do not support starting the mobile monitoring agent in other classes, as that can cause unexpected or unstable behavior. To initialize mobile monitoring: In the onCreate() method, add this call: NewRelic.withApplicationToken(\"GENERATED_TOKEN\").start(this.getApplication()); Copy Optional: Change the logging level. To build and run your application: Clean your project, then run your app in an emulator or device to generate traffic. Wait a few minutes, then view data for your Android app from the Overview page: Go to one.newrelic.com > Mobile > (select an app). If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI, follow the troubleshooting procedures. Update your Android installation To keep your Android agent up to date, follow the procedures to upgrade the Android agent SDK for New Relic. To install the latest Android version for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Android 4.x: Multidex support New Relic's mobile monitoring for Android versions prior to Android 5.0 (API level 21) use the Dalvik runtime to execute app code. By default, Dalvik limits apps to a single classes.dex bytecode file per APK. In order to get around this limitation, you must enable multidex support. Then you can use the multidex support library, which becomes part of the primary DEX file of your app and then manages access to the additional DEX files and the code they contain. When building each DEX file for a multidex app, the build tools perform complex decision making to determine which classes are needed in the primary DEX file so that your app can start successfully. If any class required during startup is not provided in the primary DEX file, then your app crashes with the error java.lang.NoClassDefFoundError. If you see the java.lang.NoClassDefFoundError error, then you must manually specify these additional classes as required in the primary DEX file: Create a proguard.multidex.config file within the /app folder of your project. Update mypackage to reflect your package name. #################### # keep class names # #################### #Keep New Relic in the main dex -keep class com.newrelic.** { *; } -keep class com.mypackage.activities.** { *; } Copy Merge the following code into the app-level build.gradle file: android { defaultConfig{ … multiDexKeepProguard file(\"proguard.multidex.config\") } } Copy For more information, see the Android Developers documentation on declaring classes required in the primary DEX file. New Relic Gradle Plugin configuration For details on how to configure the behavior of the mobile monitoring agent plugin during Gradle builds, see the New Relic Gradle plugin extension guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.35041,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "sections": "<em>New</em> <em>Relic</em> Gradle Plugin configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " These procedures to configure your <em>Android</em> app with Gradle and <em>Android</em> Studio also appear on the <em>Get</em> <em>started</em> page in <em>New</em> <em>Relic</em>. Merge <em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> code in the Gradle &amp; <em>Android</em> Studio tab to your build.gradle file. Project level build.gradle file: In this example, AGENT_VERSION represents your"
      },
      "id": "603ea70128ccbc59c2eba74e"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/get-started/new-relic-mobile-and-dt": [
    {
      "sections": [
        "Introduction to Infinite Tracing",
        "What is Infinite Tracing?",
        "Requirements",
        "Enable Infinite Tracing",
        "Configure Infinite Tracing"
      ],
      "title": "Introduction to Infinite Tracing",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Distributed tracing",
        "Infinite Tracing"
      ],
      "external_id": "836125c2bb783114009b0b4748837b36fefb7a91",
      "image": "",
      "url": "https://docs.newrelic.com/docs/distributed-tracing/infinite-tracing/introduction-infinite-tracing/",
      "published_at": "2021-12-30T02:50:04Z",
      "updated_at": "2021-12-19T15:33:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Some of our tracing solutions support our Infinite Tracing feature. Infinite Tracing is a fully managed cloud-based solution that can analyze 100% of your trace data and choose the most actionable data, letting you investigate and solve issues quickly. This document only applies to our Infinite Tracing feature. For an overview of all distributed tracing options, see Enable distributed tracing. What is Infinite Tracing? Infinite Tracing allows you to send all your trace data to our cloud-based service and rely on Infinite Tracing to make sampling decisions. You can configure Infinite Tracing in various ways to ensure it's keeping the trace data you need to see. Unlike our standard distributed tracing options, Infinite Tracing can process more trace data. It uses superior tail-based sampling (sampling after data is collected), as opposed to the head-based sampling that our standard tracing feature uses. Resources for learning more about Infinite Tracing: Infinite Tracing product page Technical details about sampling and architecture Requirements Requirements differ depending on your pricing model: New Relic One pricing: requires Pro or Enterprise edition. Original pricing: requires New Relic help to enable it for your organization. For questions, contact your New Relic account representative. Enable Infinite Tracing When enabling Infinite Tracing, you should ideally enable it for all associated services. If you have a mix of Infinite Tracing and our standard tracing solutions enabled, traces will have configuration conflict issues. Instructions for setting up Infinite Tracing are in the specific docs for our solutions. To get started, see our quick start guide. Configure Infinite Tracing After enabling Infinite Tracing, there are various ways you can configure it to ensure it's keeping the data you want. See Configure.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.5675,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to Infinite <em>Tracing</em>",
        "sections": "Introduction to Infinite <em>Tracing</em>",
        "tags": "<em>Distributed</em> <em>tracing</em>",
        "body": " <em>Tracing</em> feature. For an overview of all <em>distributed</em> <em>tracing</em> options, see Enable <em>distributed</em> <em>tracing</em>. What is Infinite <em>Tracing</em>? Infinite <em>Tracing</em> allows you to send all your <em>trace</em> data to our cloud-based service and rely on Infinite <em>Tracing</em> to make sampling decisions. You can configure Infinite <em>Tracing</em>"
      },
      "id": "6072a6a4196a67faa964a788"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/attribute-dictionary/",
      "sections": [
        "New Relic data dictionary",
        "AjaxRequest",
        "AwsLambdaInvocation",
        "AwsLambdaInvocationError",
        "BrowserInteraction",
        "BrowserTiming",
        "ContainerSample",
        "DistributedTraceSummary",
        "InfrastructureEvent",
        "JavaScriptError",
        "Metric",
        "Mobile",
        "MobileCrash",
        "MobileHandledException",
        "MobileRequest",
        "MobileRequestError",
        "MobileSession",
        "NetworkSample",
        "NrAiIncident",
        "NrAuditEvent",
        "NrConsumption",
        "NrDailyUsage",
        "NrIntegrationError",
        "NrMTDConsumption",
        "NrUsage",
        "PageAction",
        "PageView",
        "PageViewTiming",
        "ProcessSample",
        "Span",
        "StorageSample",
        "SyntheticCheck",
        "SyntheticRequest",
        "SyntheticsPrivateLocationStatus",
        "SyntheticsPrivateMinion",
        "SystemSample",
        "Transaction",
        "TransactionError",
        "WorkloadStatus"
      ],
      "published_at": "2022-01-02T01:46:43Z",
      "title": "New Relic data dictionary",
      "updated_at": "2022-01-01T01:43:39Z",
      "type": "docs",
      "external_id": "cbca3a897621bcbb31159067d6d4ec27c5178fe4",
      "document_type": "views_page_content",
      "popularity": 1,
      "body": "AjaxRequest Data source : Browser agent An AjaxRequest event is created automatically when an Ajax request occurs during a BrowserInteraction event. The event attributes track geographic and browser info. Attribute name Definition Data types actionText The text of the HTML element that was clicked when a browser interaction started. Added to BrowserInteraction and any AjaxRequest, JavaScriptError and BrowserTiming events that occurred during that interaction. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError appId ID The ID of your application, as recorded by New Relic. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserInteractionName The name of the interaction. This is either the targetGroupedUrl or the custom name set via the API. AjaxRequest BrowserInteraction BrowserTiming city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView eventId ID A value that you can link to multiple BrowserInteraction events so you can view the interactions that occurred surrounding a specific event. For example, you can see the browser interactions that occurred prior to a JS error. AjaxRequest BrowserInteraction BrowserTiming groupedPageURL The grouped URL of the view that made the AJAX request. For example: myapp.com/acct/*/dash. AjaxRequest BrowserTiming groupedRequestUrl The grouped URL of the AJAX request. For example: myapp.com/acct/*/ajax. AjaxRequest Span hostname The fully qualified domain name (FQDN) of the request URL. AjaxRequest httpMethod enum The HTTP method of the AJAX request. Example: POST. AjaxRequest httpResponseCode enum The HTTP response code. Example: 200. AjaxRequest jsDuration seconds (s) The total duration, in seconds, spent on JavaScript execution. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. This attribute doesn't exist for initial page load events. AjaxRequest BrowserInteraction BrowserTiming pageUrl The URL of the page that was loaded for the PageView. For example: http://www.newrelic.com. This URL does not include query parameters. AjaxRequest BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError port enum The request port. AjaxRequest Span priority Likelihood this event will be saved. AjaxRequest regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming requestBodySize bytes (B) The payload size of the request body, in bytes. AjaxRequest requestUrl The URL of the AJAX request. For example: myapp.com/acct/1/ajax. AjaxRequest responseBodySize bytes (B) The payload size of the response body, in bytes. AjaxRequest session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span timeSinceBrowserInteractionStart seconds (s) The time in seconds between the start of the BrowserInteraction and the start of the request. AjaxRequest BrowserTiming timeToLastCallbackEnd seconds (s) The duration, in seconds, from the start of the request (timestamp) to the end of the last callback. This is not just an additive function; the callback time can overlap with the wait time. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserInteraction BrowserTiming timeToLoadEventStart seconds (s) The time, in seconds, from the start of the AJAX request to the start of its load event. This value represents the duration of the AJAX request with single page app (SPA) monitoring. For more information, see the Mozilla developer documentation about XMLHttpRequest load events. AjaxRequest timeToSettle seconds (s) The time, in seconds, from the start of the request to when all resulting callbacks (including callbacks of subsequent AJAX requests) are complete. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserTiming timestamp The time (date, hour, minute, second) at which the interaction occurred. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming Span userAgentName The browser’s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browser’s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browser’s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming AwsLambdaInvocation Data source : AWS Lambda This event is reported by New Relic monitoring for AWS Lambda. This event captures overall function timing and associated metadata. A single AwsLambdaInvocation event is generated for each invocation. Attribute name Definition Data types aws.lambda.arn The Amazon Resource Name (ARN) of the instrumented Lambda function. AwsLambdaInvocationError AwsLambdaInvocation aws.lambda.coldStart A Boolean indicating if the AWS Lambda invocation is a cold start. AwsLambdaInvocationError AwsLambdaInvocation aws.lambda.eventSource.arn The Amazon Resource Name (ARN) of the entity that invoked the instrumented Lambda function. AwsLambdaInvocationError AwsLambdaInvocation aws.requestId ID AWS identifier of the invocation. AwsLambdaInvocationError AwsLambdaInvocation databaseCallCount count The number of database calls made by this transaction. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError databaseDuration seconds (s) The database response time in seconds. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError duration seconds (s) The total invocation time for the transaction, in seconds. (Data source: AWS Lambda) AwsLambdaInvocationError AwsLambdaInvocation externalCallCount count The number of external calls made by this transaction. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError externalDuration seconds (s) The total response time of all external (out-of-process) services, in seconds. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError newRelic.ingestPoint Where the data point entered the platform (such as browser.spans, or api.traces). AwsLambdaInvocationError AwsLambdaInvocation Span parent.account ID If a distributed tracing payload is received, this is the account identifier for the transaction's upstream caller. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError parent.app ID If a distributed tracing payload is received, this is the application identifier. APM agents retrieve this value in the connect response under the key primary_application_id. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError parent.transportType When a distributed tracing payload is received, the method of transport for the payload. Example values: Unknown, HTTP, HTTPS, Kafka, JMS, IronMQ, AMQP, Queue, or Other. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError parent.type If a distributed trace payload was received, the parent's data source type. Example values: App, Browser, Mobile. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.accept The types as read from the HTTP Accept request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.contentLength bytes (B) Incoming request size in bytes as read from the Content-Length HTTP request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.contentType Incoming request content-type as read from the HTTP request header Content-Type. Example value: application/octet-stream. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.host The name from the HTTP host request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.referer The incoming request referer as read from the Referer request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.userAgent The contents of the User-Agent HTTP header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.method The HTTP request method used. Example values: POST, GET. AwsLambdaInvocationError AwsLambdaInvocation Span Transaction TransactionError response.headers.contentLength bytes (B) The outgoing response size in bytes as read from the Content-Length response header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError response.headers.contentType For an HTTP response, the data type of the returned response. Example values: text/html, application/json. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError response.status bytes (B) The response code for an HTTP request AwsLambdaInvocation totalTime seconds (s) The sum of all async components' duration, in seconds. An async component is a method or function where there is no instrumented encapsulating method or function. AwsLambdaInvocation Transaction traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocationError AwsLambdaInvocation MobileRequest MobileRequestError Span type The New Relic event type. Example values: Transaction, Span. AwsLambdaInvocationError AwsLambdaInvocation AwsLambdaInvocationError Data source : AWS Lambda This event is reported by New Relic monitoring for AWS Lambda. It's generated when an error occurs during a Lambda function invocation. Attribute name Definition Data types aws.lambda.arn The Amazon Resource Name (ARN) of the instrumented Lambda function. AwsLambdaInvocationError AwsLambdaInvocation aws.lambda.coldStart A Boolean indicating if the AWS Lambda invocation is a cold start. AwsLambdaInvocationError AwsLambdaInvocation aws.lambda.eventSource.arn The Amazon Resource Name (ARN) of the entity that invoked the instrumented Lambda function. AwsLambdaInvocationError AwsLambdaInvocation aws.requestId ID AWS identifier of the invocation. AwsLambdaInvocationError AwsLambdaInvocation databaseCallCount count The number of database calls made by this transaction. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError databaseDuration seconds (s) The database response time in seconds. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError duration seconds (s) The total invocation time for the transaction, in seconds. (Data source: AWS Lambda) AwsLambdaInvocationError AwsLambdaInvocation error.class The class name or type for the error. This will be server and platform specific. AwsLambdaInvocationError TransactionError error.message The error message for the transaction. This will be server and platform specific. AwsLambdaInvocationError TransactionError externalCallCount count The number of external calls made by this transaction. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError externalDuration seconds (s) The total response time of all external (out-of-process) services, in seconds. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError newRelic.ingestPoint Where the data point entered the platform (such as browser.spans, or api.traces). AwsLambdaInvocationError AwsLambdaInvocation Span parent.account ID If a distributed tracing payload is received, this is the account identifier for the transaction's upstream caller. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError parent.app ID If a distributed tracing payload is received, this is the application identifier. APM agents retrieve this value in the connect response under the key primary_application_id. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError parent.transportType When a distributed tracing payload is received, the method of transport for the payload. Example values: Unknown, HTTP, HTTPS, Kafka, JMS, IronMQ, AMQP, Queue, or Other. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError parent.type If a distributed trace payload was received, the parent's data source type. Example values: App, Browser, Mobile. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.accept The types as read from the HTTP Accept request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.contentLength bytes (B) Incoming request size in bytes as read from the Content-Length HTTP request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.contentType Incoming request content-type as read from the HTTP request header Content-Type. Example value: application/octet-stream. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.host The name from the HTTP host request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.referer The incoming request referer as read from the Referer request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.userAgent The contents of the User-Agent HTTP header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.method The HTTP request method used. Example values: POST, GET. AwsLambdaInvocationError AwsLambdaInvocation Span Transaction TransactionError response.headers.contentLength bytes (B) The outgoing response size in bytes as read from the Content-Length response header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError response.headers.contentType For an HTTP response, the data type of the returned response. Example values: text/html, application/json. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError stackTrace The error stack trace. The format will be different depending on the agent language. AwsLambdaInvocationError traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocationError AwsLambdaInvocation MobileRequest MobileRequestError Span transactionName Name of the transaction in which the error occurred. Example value: Controller/customers/show. Value may be 'Unknown' if an error occurs outside of a transaction. AwsLambdaInvocationError TransactionError type The New Relic event type. Example values: Transaction, Span. AwsLambdaInvocationError AwsLambdaInvocation BrowserInteraction Data source : Browser agent A BrowserInteraction represents a unit of work in a browser session, triggered by a user interacting with the webpage. It captures information about the session, AJAX calls and custom JavaScript timing that occurred as a result of the interaction. Initial load and route changes are captured as special types of browser interactions, and are used for SPA monitoring. Attribute name Definition Data types actionText The text of the HTML element that was clicked when a browser interaction started. Added to BrowserInteraction and any AjaxRequest, JavaScriptError and BrowserTiming events that occurred during that interaction. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError ajaxCount count A count of all XHRs included in the timing of a SPA interaction. BrowserInteraction appId ID The ID of your application, as recorded by New Relic. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming backendTransactionName The name of the backend transaction that served the initial page load. BrowserInteraction browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserInteractionName The name of the interaction. This is either the targetGroupedUrl or the custom name set via the API. AjaxRequest BrowserInteraction BrowserTiming category The type of interaction; either initial page load, route change, or custom. BrowserInteraction city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView domain The domain portion of the request URL. BrowserInteraction JavaScriptError PageView PageViewTiming duration seconds (s) The total time elapsed of the interaction event BrowserInteraction eventId ID A value that you can link to multiple BrowserInteraction events so you can view the interactions that occurred surrounding a specific event. For example, you can see the browser interactions that occurred prior to a JS error. AjaxRequest BrowserInteraction BrowserTiming firstContentfulPaint firstContentfulPaint is the point when the browser renders the first bit of content from the DOM, which may be text, an image, SVG, or a <canvas> element. Google's User-centric Performance Metrics contains detailed information about its Paint Timing API and firstContentfulPaint. See Compatibility and requirements for New Relic Browser for additional information about firstContentfulPaint browser compatibility. BrowserInteraction PageView firstPaint firstPaint marks the point when the browser renders anything that is visually different from what was on the screen prior to navigation. This includes non-default background paint and the enclosing box of an iframe. Google's User-centric Performance Metrics contains detailed information about its Paint Timing API and firstPaint. See Compatibility and requirements for New Relic Browser for additional information about firstPaint browser compatibility. BrowserInteraction PageView jsDuration seconds (s) The total duration, in seconds, spent on JavaScript execution. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. This attribute doesn't exist for initial page load events. AjaxRequest BrowserInteraction BrowserTiming monitorAccountId The Synthetics account from which you are running the monitor. BrowserInteraction JavaScriptError monitorId ID A unique number identifying a particular monitor. BrowserInteraction JavaScriptError SyntheticCheck monitorJobId ID The ID of a single Synthetics monitor run, which began at a specific time and originated from a specific location. BrowserInteraction JavaScriptError parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError previousGroupedUrl The grouped version of the URL in the browser at the start of the interaction. BrowserInteraction previousRouteName The route name of the page at the start of the interaction. This is the last value passed by setCurrentRouteName before the start of the interaction. BrowserInteraction previousURL The ungrouped URL in the browser at the start of the interaction. BrowserInteraction regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span targetGroupedUrl The grouped version of the URL in the browser at the end of the interaction. BrowserInteraction targetRouteName The route name for the page at the end of the interaction. The last value passed by setCurrentRouteName before the end of the interaction. BrowserInteraction targetUrl The ungrouped URL in the browser at the end of the interaction. BrowserInteraction timeToConnectEnd seconds (s) The time, in seconds, from the start of the interaction to the connectEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToConnectStart seconds (s) The time, in seconds, from the start of the interaction to the connectStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomComplete seconds (s) The time, in seconds, from the start of the interaction to the domComplete, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomContentLoadedEventEnd seconds (s) The time, in seconds, from the start of the interaction to the domContentLoadedEventEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomContentLoadedEventStart seconds (s) The time, in seconds, from the start of the interaction to the domContentLoadedEventStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomInteractive seconds (s) The time, in seconds, from the start of the interaction to the domInteractive, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomLoading seconds (s) The time, in seconds, from the start of the interaction to the domLoading, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomainLookupEnd seconds (s) The time, in seconds, from the start of the interaction to the domainLookupEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomainLookupStart seconds (s) The time, in seconds, from the start of the interaction to the domainLookupStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToFetchStart seconds (s) The time, in seconds, from the start of the interaction to the fetchStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToLastCallbackEnd seconds (s) The duration, in seconds, from the start of the request (timestamp) to the end of the last callback. This is not just an additive function; the callback time can overlap with the wait time. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserInteraction BrowserTiming timeToLoadEventEnd seconds (s) The time, in seconds, from the start of the interaction to the loadEventEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToLoadEventStart seconds (s) The time, in seconds, from the start of the interaction to the loadEventStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information, see our documentation about instrumentation for the Navigation Timing API. BrowserInteraction timeToRedirectEnd seconds (s) The time, in seconds, from the start of the interaction to the redirectEnd, as defined by the Navigation Timing API. This attribute exists only for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToRedirectStart seconds (s) The time, in seconds, from the start of the interaction to the redirectStart, as defined by the Navigation Timing API. This attribute exists only for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToRequestStart seconds (s) The time, in seconds, from the start of the interaction to the requestStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToResponseEnd seconds (s) The time, in seconds, from the start of the interaction to the responseEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToResponseStart seconds (s) The time, in seconds, from the start of the interaction to the responseStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToSecureConnectionStart seconds (s) The time, in seconds, from the start of the interaction to the secureConnectionStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToUnloadEventEnd seconds (s) The time, in seconds, from the start of the interaction to the unloadEventEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToUnloadEventStart seconds (s) The time, in seconds, from the start of the interaction to the unloadEventStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timestamp The time (date, hour, minute, second) at which the interaction occurred. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming Span trigger The cause of the route change or page load. The default values are click, submit, popstate, or initial page load. For a custom event created with the API, the default value for trigger will be api. This value can also be set via the API. BrowserInteraction userAgentName The browser’s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browser’s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browser’s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming BrowserTiming Data source : Browser agent BrowserTiming is a custom event that captures SPA timing data for browser interactions started using the custom createTracer SPA API method. BrowserTiming contains many of the same attributes used by other events, especially AjaxRequest. Attribute name Definition Data types actionText The text of the HTML element that was clicked when a browser interaction started. Added to BrowserInteraction and any AjaxRequest, JavaScriptError and BrowserTiming events that occurred during that interaction. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError appId ID The ID of your application, as recorded by New Relic. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserInteractionName The name of the interaction. This is either the targetGroupedUrl or the custom name set via the API. AjaxRequest BrowserInteraction BrowserTiming browserTimingName The name of the event. This is taken from the name argument of createTracer. BrowserTiming city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView eventId ID A value that you can link to multiple BrowserInteraction events so you can view the interactions that occurred surrounding a specific event. For example, you can see the browser interactions that occurred prior to a JS error. AjaxRequest BrowserInteraction BrowserTiming groupedPageURL The grouped URL of the view that made the AJAX request. For example: myapp.com/acct/*/dash. AjaxRequest BrowserTiming jsDuration seconds (s) The total duration, in seconds, spent on JavaScript execution. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. This attribute doesn't exist for initial page load events. AjaxRequest BrowserInteraction BrowserTiming pageUrl The URL of the page that was loaded for the PageView. For example: http://www.newrelic.com. This URL does not include query parameters. AjaxRequest BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span timeSinceBrowserInteractionStart seconds (s) The time in seconds between the start of the BrowserInteraction and the start of the request. AjaxRequest BrowserTiming timeToLastCallbackEnd seconds (s) The duration, in seconds, from the start of the request (timestamp) to the end of the last callback. This is not just an additive function; the callback time can overlap with the wait time. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserInteraction BrowserTiming timeToSettle seconds (s) The time, in seconds, from the start of the request to when all resulting callbacks (including callbacks of subsequent AJAX requests) are complete. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserTiming timeToTracedCallbackStart seconds (s) The time in seconds from the start of the custom tracer until the start of the traced callback. This attribute is unique to the BrowserTiming event. BrowserTiming timestamp The time (date, hour, minute, second) at which the interaction occurred. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming Span tracedCallbackDuration seconds (s) The duration in seconds of the traced callback. This attribute is unique to the BrowserTiming event. BrowserTiming userAgentName The browser’s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browser’s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browser’s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming ContainerSample Data source : Infrastructure This event is reported by the New Relic Infrastructure agent. It collects data from all the Docker containers on the host (which may or may not be running). It includes the container's ID, name, image, image name, and metrics about CPU, memory and networking. We take a snapshot of this data every 15 seconds for each container and package it into this event, which is then sent to New Relic. This data appears on the Containers UI page. Attribute name Definition Data types StorageDataAvailableBytes bytes (B) Data space available in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageDataTotalBytes bytes (B) Total Data space in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageDataUsagePercent percentage (%) Percent of Data space used in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageDataUsedBytes bytes (B) Data space used by the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataAvailableBytes bytes (B) Metadata space available in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataTotalBytes bytes (B) Total Metadata space in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataUsagePercent percentage (%) Percent of Metadata space used in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataUsedBytes bytes (B) Metadata space used by the Storage Driver. Only Device Mapper driver is supported. ContainerSample commandLine The command line used in the container. ContainerSample containerId ID The unique Docker container ID. ContainerSample cpuKernelPercent percentage (%) CPU time percentage used in kernel space. ContainerSample cpuLimitCores count Number of cores available for the container. ContainerSample cpuPercent percentage (%) CPU usage percentage used. ContainerSample cpuShares count Number of CPU shares assigned to the container. ContainerSample cpuThrottlePeriods count Total number of periods throttled. ContainerSample cpuThrottleTimeMs milliseconds (ms) Total throttling time in milliseconds. ContainerSample cpuUsedCores percentage (%) CPU usage per core. ContainerSample cpuUsedCoresPercent percentage (%) CPU usage percentage per core. ContainerSample cpuUserPercent percentage (%) CPU time percentage used in user space. ContainerSample criticalViolationCount count The number of times that alert conditions violated critical thresholds, causing critical violations and opening incidents. If this attribute does not exist on the sample, it has zero violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample image ID The Docker image ID for the image the container is based on. ContainerSample imageName The Docker image name for the container. ContainerSample label_KEY Docker labels associated with this container (where KEY represents a custom label's key value). ContainerSample memoryCacheBytes count The amount of memory used by the container that can be associated precisely with a block on a block device. ContainerSample memoryKernelUsageBytes bytes (B) The amount of current kernel memory allocation. ContainerSample memoryResidentSizeBytes bytes (B) The amount of memory that doesn't correspond to anything on disk: stacks, heaps, and anonymous memory maps. ContainerSample memorySizeLimitBytes bytes (B) The total amount of memory the container is allowed to use. ContainerSample memorySoftLimitBytes bytes (B) The soft limit of memory usage equivalent to the memory reservation of the container. ContainerSample memorySwapLimitBytes bytes (B) The total amount of memory the container is using, including swap. ContainerSample memorySwapLimitUsagePercent percentage (%) This metric is calculated as the percentage of memorySwapUsageBytes over memorySwapLimitBytes, if the limit exists. ContainerSample memorySwapOnlyUsageBytes bytes (B) The amount of swap memory the container is using. This memory doesn't include non-swap memory. ContainerSample memorySwapUsageBytes bytes (B) The amount of memory swap the container is using, including swap. ContainerSample memoryUsageBytes bytes (B) This metric doesn't account for swap usage. ContainerSample memoryUsageLimitPercent percentage (%) This metric is calculated as the memoryUsageBytes percentage over memorySizeLimitBytes, if the limit exists. ContainerSample name The Docker container name. ContainerSample networkRxBytes bytes (B) Total number of received bytes. ContainerSample networkRxBytesPerSecond rate Number of received bytes per second. ContainerSample networkRxDropped count Total number of received packets dropped. ContainerSample networkRxDroppedPerSecond rate Number of received packets dropped per second. ContainerSample networkRxError count Total number of received packets with error. ContainerSample networkRxErrorsPerSecond rate Number of received packets with error per second. ContainerSample networkRxPackets count Total number of received packets. ContainerSample networkRxPacketsPerSecond rate Number of received packets with error per second. ContainerSample networkTxBytesPerSecond rate Number of transmitted bytes per second. ContainerSample networkTxDropped count Total number of transmitted packets dropped. ContainerSample networkTxDroppedPerSecond rate Number of transmitted packets dropped per second. ContainerSample networkTxErrors count Total number of transmitted packets with error. ContainerSample networkTxErrorsPerSecond rate Number of transmitted packets with error per second. ContainerSample networkTxPackets count Total number of transmitted packets. ContainerSample networkTxPacketsPerSecond rate Number of transmitted packets per second. ContainerSample networksTxBytes count Total number of bytes transmitted. ContainerSample restartCount count The number of times the container was restarted. ContainerSample state It can be: created, restarting, running, removing, paused, exited, or dead. ContainerSample status Holds the current container state. ContainerSample warningViolationCount count The number of times that alert conditions violated warning thresholds, causing warning violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample DistributedTraceSummary Data source : Distributed Tracing This event contains summary data about a distributed trace and provides an aggregated view of distributed tracing data. DistributedTraceSummary events are generated by New Relic and are triggered by distributed tracing data from agents or the Trace API. Attribute name Definition Data types accountIds A comma delimited list of newrelic accountIds that took part in this trace. DistributedTraceSummary backend.duration.ms milliseconds (ms) The total elapsed time in milliseconds of all backend services in this trace. DistributedTraceSummary backend.timestamp milliseconds (ms) The timestamp of the first span in this trace from a backend entity. In distributed tracing, any events that are not from client-side applications contributed to the backend duration. DistributedTraceSummary duration.ms The duration of the entire distributed trace, including both backend and client-side entities. the earliest span to the latest. DistributedTraceSummary entityCount count The number of unique entities that took part in this trace. DistributedTraceSummary entityGuids A comma delimited list of entity GUIDs for entities that participated in this trace. These GUIDs are assigned by New Relic for the New Relic-monitored entity (host, application, etc.). Each GUID is stored as a Base64 encoded value. DistributedTraceSummary errorCount count The number of events in this distributed trace that were identified as errors. DistributedTraceSummary newRelic.traceFilter.type The name of the trace filter used by the Infinite Tracing trace observer to select this trace. DistributedTraceSummary Span root.entity.accountId The New Relic account ID that the root entity of this trace reports data to. DistributedTraceSummary root.entity.guid The entity GUID associated with the root entity of this trace. DistributedTraceSummary root.entity.name The name of the root entity of this trace. DistributedTraceSummary root.span.duration.ms milliseconds (ms) The elapsed time in milliseconds of the root span of this trace. The root of a distributed trace is the first span, and will have a null value for parent.id. DistributedTraceSummary root.span.id The unique identifier of the root span of this trace. The root of a distributed trace is the first span, and it has a null value for parent.id. DistributedTraceSummary root.span.name The name of the root span of this trace. DistributedTraceSummary root.span.timestamp milliseconds (ms) The timestamp of the root span of this trace. The root of a distributed trace is the first span, and will have a null value for parent.id. DistributedTraceSummary spanCount count The number of events in this distributed trace. Events in a distributed trace can have several event types, including Span, Transaction, and TransactionError. DistributedTraceSummary timestamp milliseconds (ms) The timestamp of the root span in this distributed trace. DistributedTraceSummary trace.id ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. DistributedTraceSummary MobileRequest MobileRequestError Span Transaction TransactionError InfrastructureEvent Data sources : InfrastructureCloudTrail InfrastructureEvent describes changes (deltas) that occur in a system's live state. When an inventory or system state is added, removed, or changed, Infrastructure will produce an InfrastructureEvent that logs that activity. Attribute name Definition Data types category A New Relic category used to organize events in the UI. For example: automation, notification, and service. InfrastructureEvent changeType A simple classification of the type of change made to the entity: added, modified, or removed. InfrastructureEvent changedPath The fully specified name of the item that changed. This is constructed by taking the source and adding one or more additional path elements that uniquely identify the item that changed. InfrastructureEvent deltaId Delta refers to a recorded change in the system. The deltaId is a number used by New Relic to organize incoming inventory change data. InfrastructureEvent eventId The unique ID of the event, generated by New Relic. InfrastructureEvent format The type of infrastructure event. Each format type includes attributes that may be used to render the event in the UI. InfrastructureEvent newStatus The new agent status: disconnected or connected. InfrastructureEvent newValue If a change is made to the entity, this attribute contains the new value of the inventory that was changed. This will have no value if no change has been made. The value will display approximately 4K bytes of data. InfrastructureEvent oldValue If a change is made to the entity, this attribute contains the old value of the inventory that was changed. This will be blank if no change has been made. InfrastructureEvent provider For integrations that use generic event types (like the DatastoreSample event), the provider value specifies the source of the data (the service, or a sub-category of data from that service). Some Insights events are generic and are used by several integrations. For example, the DatastoreSample event is used by several integrations, including the AWS DynamoDB integration and the AWS RDS integration. In these cases, the provider attribute value represents the source of that attribute. This will usually be the service that data comes from or, for integrations that use several provider values, a certain sub-category of data from that service. When a provider value is present for a generic event, that event will have additional integration-specific attributes attached to it. Here’s an example of an Insights NRQL query that returns the attributes present for a DatastoreSample event reported by the AWS RDS integration: SELECT * from DatastoreSample where provider = 'RdsDbCluster' InfrastructureEvent source The fully specified origin of this inventory item. This is typically in the form category/plugin, where plugin is the generic word used for the tool that gathered this data. InfrastructureEvent summary A summary of the change that happened. Uses a human-friendly string, such as Agent disconnected. InfrastructureEvent violationUpdateType The type of change to the violation: For example: open or closed. InfrastructureEvent JavaScriptError Data source : Browser agent As JavaScript errors are triggered, we capture details as events. The JavaScriptError event contains information to help you segment errors to understand how they impact performance. Attribute name Definition Data types actionText The text of the HTML element that was clicked when a browser interaction started. Added to BrowserInteraction and any AjaxRequest, JavaScriptError and BrowserTiming events that occurred during that interaction. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError appId ID The identification number for the reporting browser agent. JavaScriptError appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserStackHash ID An unique identifier generated for a stack trace. The browserStackHash for a stack trace is different across different browsers. An identical stack trace will generate the same identifier. JavaScriptError city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView domain The domain portion of the request URL. BrowserInteraction JavaScriptError PageView PageViewTiming entityGuid The unique identifier of the monitor referenced in New Relic One. JavaScriptError SyntheticCheck SyntheticRequest errorClass The error type of the JavaScript Error object. Examples: ReferenceError, SyntaxError, and UncaughtException. JavaScriptError errorMessage The error message that was delivered. JavaScriptError firstErrorInSession A value to indicate whether or not this was the first JS error in the session. Example: true. JavaScriptError monitorAccountId The Synthetics account from which you are running the monitor. BrowserInteraction JavaScriptError monitorId ID A unique number identifying a particular monitor. BrowserInteraction JavaScriptError SyntheticCheck monitorJobId ID The ID of a single Synthetics monitor run, which began at a specific time and originated from a specific location. BrowserInteraction JavaScriptError pageUrl The URL of the page that was loaded for the PageView. For example: http://www.newrelic.com. This URL does not include query parameters. AjaxRequest BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming releaseIds ID The releases in which the app was updated. Example: {\\\"jQuery\\\":\\\"v3.1.1\\\",\\\"multiverse\\\":\\\"96e9ac7\\\"}. JavaScriptError requestUri The URI of the requested resource. JavaScriptError session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span stackHash ID A unique identifier generated by the Browser agent for a stack trace. The stackHash for a stack trace is the same across different browsers. An identical stack trace will generate the same identifier. JavaScriptError stackTrace A collection of the active stack frames when the error occurred. JavaScriptError stackTraceGzip A compressed version of the stackTrace attribute. JavaScriptError timestamp The time that the error occurred, in Unix time. JavaScriptError transactionName The full metric name of the transaction in which the error occurred, or Unknown if the error occurs outside of a transaction. JavaScriptError userAgentName The browser’s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browser’s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browser’s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Metric Data source : Metrics Represents a metric data point (a measurement over a range of time, or a sample at a specific point in time) with multiple attributes attached, which allow for in-depth analysis and querying. This metric data comes from our Metric API, our Telemetry SDKs, network performance monitoring, and some of our open-source exporters/integrations. Attribute name Definition Data types endTimestamp milliseconds (ms) The end of the time range associated with the metric, in Unix time, in milliseconds. This is calculated by adding the metric interval to the timestamp of the metric (timestamp + interval.ms). Metric interval.ms milliseconds (ms) The length of the time window. Metric metricName Name of the metric. Metric newrelic.source The source of this data. For example: metricAPI. Metric timestamp milliseconds (ms) The start time for the metric, in Unix time. Metric Mobile Data source : Mobile A Mobile event is created when a crash occurs, when an interaction ends or has run for 1 second, or if a session completes after the app is closed, backgrounded, or has run for 10 minutes. Mobile events were once the only event type and were generated for every event, but now there are several specialized event types. Recommendation: Upgrade to the most recent mobile monitoring agent version to take full advantage of the new event types. Attribute name Definition Data types category The type of data, either session or interaction. Mobile MobileSession interactionDuration For interaction category events only. This is the total time for the interaction to render on the device. In addition to render time, this usually includes all external calls associated with the interaction. Currently, this attribute is measured in seconds for Android devices and in milliseconds for iOS devices. Mobile name For interaction category events only. This is the label of the interaction associated with the event. It is by default assigned by New Relic. For example: ApplicationsListFragment or Display iOS_Example.MasterViewController. Mobile reportedTimestampMs For interaction category events only. The UTC based timestamp for when the event was sent to New Relic. This is different from the attribute ‘timestamp’, which is when the event began. Mobile MobileCrash Data source : Mobile The MobileCrash event is created when an app crashes. MobileCrash includes attributes such as crash line number, class, and crash message. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appToken The mobile application license token. MobileCrash appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession architecture The processor architecture of the device. For example: armv7 or arm64. MobileCrash asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession bundleId ID The unique string used to identify the application. MobileCrash MobileSession carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession crashException The exception associated with the crash, if one is present. For example: java.lang.NullPointerException. MobileCrash crashFingerprint ID The New Relic-generated fingerprint used to uniquely identify the crash and other crashes identical to this one. MobileCrash crashLocationFile The file in which the crash occurred. MobileCrash crashMessage The message associated with the crash, if one is present. MobileCrash deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceName The device's name. MobileCrash deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession diskAvailable bytes (B) Space available on the device, in bytes. MobileCrash interactionHistory The client interactions with the application that led to the crash. MobileCrash isFirstOccurrence A boolean value indicating whether or not this was the first occurrence of the crash. MobileCrash lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession modelNumber The model of the device. This is the same as the session-level deviceModel attribute. MobileCrash networkStatus The type of network that the device was on at the time of crash, such as wifi or LTE. MobileCrash newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession occurrenceId ID The ID for this instance of the crash. MobileCrash orientation The orientation of the device, such as landscape or portrait. MobileCrash osBuild For Android only. The specific build of the Android OS. MobileCrash MobileHandledException osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession parentProcess The parent process that launched the crashing process. MobileCrash parentProcessId ID The parent identification number (PID) of the parent process. MobileCrash platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession processId ID The PID of the previously running process on the device. MobileCrash processName The name of the previously running process. MobileCrash processPath The path to the binary. MobileCrash reportedTimestampMs The UTC timestamp for when the event was received by New Relic. (This is different from timestamp, which is when the MobileSession event began that crashed.) MobileCrash runTime For Android only. The Android Runtime version where the exception/crash was generated. MobileCrash MobileHandledException sessionCrashed A boolean value indicating whether or not that session crashed. MobileCrash MobileSession sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession symbolicated A boolean value indicating whether or not the crash was properly symbolicated. MobileCrash timeSinceLastInteraction milliseconds (ms) The time, in milliseconds, since the interaction before a crash event. MobileCrash userImageUuids ID The array of build UUIDs for applications and libraries. MobileCrash uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession MobileHandledException Data source : Mobile MobileHandledException is sent when an exception is caught and is used for non-fatal exceptions reported to New Relic using the recordHandledException API for Android or iOS. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileRequestError MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileRequestError MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileRequestError MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession exceptionAppBuildUuid ID The build uuid of the application binary in which the exception was caught. MobileHandledException exceptionCause The unsymbolicated, platform-specific cause of the exception. MobileHandledException exceptionLocation New Relic defined location of an exception. Contains a combination of exception file name, class, line number, and method. MobileHandledException exceptionLocationClass The class that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionLocationFile The class that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionLocationLibraryOffset For XCFramework agent only. The library offset of the library that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionLocationLine Comes from the exception: The line number where the exception was generated. Only present if symbolication succeeded. MobileHandledException exceptionLocationMethod The method that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionMessage The unsymbolicated message from the exception. It can be user-generated or a generic system message. For Android, this is the Throwable message. MobileHandledException exceptionName The unsymbolicated exception type. MobileHandledException fingerprint ID The New Relic-generated identifier used to group like exceptions. MobileHandledException handledExceptionUuid ID The unique ID of the exception event. MobileHandledException lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession libraryName For XCFramework agent only. The library name where the exception was generated. MobileHandledException libraryStartAddr For XCFramework agent only. The library start address where the exception was generated. MobileHandledException memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession occurrenceTimestamp Agent-reported epoch timestamp of the handled exception. MobileHandledException osBuild For Android only. The specific build of the Android OS. MobileCrash MobileHandledException osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileRequestError MobileSession runTime For Android only. The Android Runtime version where the exception/crash was generated. MobileCrash MobileHandledException sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession timestamp Epoch timestamp of the handled exception. This exception timestamp represents the time New Relic created the event, if it's older than two days or some other unexpected time. MobileHandledException uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession MobileRequest Data source : Mobile A MobileRequest event is created when an HTTP request successfully completes, resulting in a response code below 400. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession bytesReceived bytes (B) Optional: If the application received a response from the requestUrl, the size of that response in bytes. MobileRequest MobileRequestError bytesSent bytes (B) Optional: If the application sent a request to the requestUrl, the size of that request in bytes. MobileRequest MobileRequestError carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession connectionType The type of connection which the device was using, such as 2G or 3G. MobileRequest MobileRequestError countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileRequestError MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileRequestError MobileSession deviceGroup The category of the device, such as iPhone or Tablet. MobileRequest MobileRequestError MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceSize The display size of the device: Small, normal, large, xlarge. MobileRequest MobileRequestError deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileRequestError MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession duration seconds (s) Optional: The time to complete the request, measured in fractional seconds. MobileRequest MobileRequestError guid ID The unique identifier for the segment. This is equivalent to spanID in OpenTracing semantics. MobileRequest MobileRequestError Span lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileRequestError MobileSession requestDomain The domain that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestFingerprint ID The New Relic-generated identifier used to group like request events. MobileRequest requestMethod The REST method (GET, PUT, POST, etc.) that the application attempted when the event occurred. MobileRequest MobileRequestError requestPath The path that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUrl The URL that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUuid ID A unique identifer for the request event. MobileRequest MobileRequestError responseTime seconds (s) The time between the request and the response in fractional seconds. MobileRequest MobileRequestError sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession statusCode Optional: The HTTP status code for the HTTP event. MobileRequest MobileRequestError timestamp The UTC epoch time at which an event began. MobileRequest MobileRequestError MobileSession trace.id ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. DistributedTraceSummary MobileRequest MobileRequestError Span Transaction TransactionError traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocationError AwsLambdaInvocation MobileRequest MobileRequestError Span uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession MobileRequestError Data source : Mobile A MobileRequestError is used for HTTP errors or network failures. HTTP errors are HTTP requests that have a status code greater than 400. A network failure is a HTTP request that results in no response. The event is sent when the HTTP request completes. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession bytesReceived bytes (B) Optional: If the application received a response from the requestUrl, the size of that response in bytes. MobileRequest MobileRequestError bytesSent bytes (B) Optional: If the application sent a request to the requestUrl, the size of that request in bytes. MobileRequest MobileRequestError carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession connectionType The type of connection which the device was using, such as 2G or 3G. MobileRequest MobileRequestError countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileRequestError MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileRequestError MobileSession deviceGroup The category of the device, such as iPhone or Tablet. MobileRequest MobileRequestError MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceSize The display size of the device: Small, normal, large, xlarge. MobileRequest MobileRequestError deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileRequestError MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession duration seconds (s) Optional: The time to complete the request, measured in fractional seconds. MobileRequest MobileRequestError errorType Either HTTPError or NetworkFailure, depending on whether the error is a result of a failed request to a host or a failure on the cellular network. MobileRequestError guid ID The unique identifier for the segment. This is equivalent to spanID in OpenTracing semantics. MobileRequest MobileRequestError Span lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession networkError The error message associated with the iOS NSURL Error code. See networkErrorCode for more information. MobileRequestError networkErrorCode If the error is a network error, this is the iOS network error code. For Android applications, this is the mapped value. MobileRequestError newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileRequestError MobileSession requestDomain The domain that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestErrorFingerprint ID The New Relic-generated identifier used to group like request error events. MobileRequestError requestMethod The REST method (GET, PUT, POST, etc.) that the application attempted when the event occurred. MobileRequest MobileRequestError requestPath The path that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUrl The URL that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUuid ID A unique identifer for the request event. MobileRequest MobileRequestError responseBody Optional: The response that is sent from the requestDomain for the HTTP error, up to 4096 bytes. MobileRequestError responseTime seconds (s) The time between the request and the response in fractional seconds. MobileRequest MobileRequestError sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession statusCode Optional: The HTTP status code for the HTTP event. MobileRequest MobileRequestError timestamp The UTC epoch time at which an event began. MobileRequest MobileRequestError MobileSession trace.id ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. DistributedTraceSummary MobileRequest MobileRequestError Span Transaction TransactionError traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocationError AwsLambdaInvocation MobileRequest MobileRequestError Span uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession MobileSession Data source : Mobile A MobileSession event is sent when an app is closed, backgrounded, or when 10 minutes of active use has elapsed. This is the source of the general session data used by the other mobile monitoring events. MobileSession captures attributes such as device type, device OS, and geographical information. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession bundleId ID The unique string used to identify the application. MobileCrash MobileSession carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession category The type of data, either session or interaction. Mobile MobileSession city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileRequestError MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileRequestError MobileSession deviceGroup The category of the device, such as iPhone or Tablet. MobileRequest MobileRequestError MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileRequestError MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession install Indicates true only if the current session is the first session after app install. MobileSession lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession newRelicAgent The New Relic agent running on the application. For example: the iOSAgent or the androidAgent. MobileSession newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileRequestError MobileSession sessionCrashed A boolean value indicating whether or not that session crashed. MobileCrash MobileSession sessionDuration seconds (s) The length of time for which the user used the application in seconds. If the session crashes, sessionDuration is not captured (although other events and attributes are still recorded). For sessions longer than 10 minutes, events in the Interaction and Custom event categories are sent to Insights while the session is ongoing, and therefore do not have sessionDuration attributes. Events recorded near the end of the session will include the duration, as will the Session event category. MobileSession sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession timeSinceLoad seconds (s) The time, in seconds, from the beginning of the mobile session to the time the event occurred. MobileSession timestamp The UTC epoch time at which an event began. MobileRequest MobileRequestError MobileSession upgradeFrom Indictates previous version number only if this is the first launch after app upgrade. MobileSession uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession NetworkSample Data source : Infrastructure NetworkSample event captures the descriptive and state information for each network device associated with a server. It includes the device's interface and address information, as well as current usage data. New Relic samples this data every 10 seconds for each attached network interface and packages it into a NetworkSample event, then sends the raw data to New Relic's collectors every 60 seconds. Attribute name Definition Data types agentName The name of the agent (Infrastructure). NetworkSample ProcessSample StorageSample SystemSample agentVersion The version of the New Relic Infrastructure agent. NetworkSample ProcessSample StorageSample SystemSample criticalViolationCount count The number of times that alert conditions violated critical thresholds, causing critical violations and opening incidents. If this attribute does not exist on the sample, it has zero violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample entityID ID New Relic's unique ID number for the entity that is reporting data. This is used by New Relic to distinguish between customers and their entities. NetworkSample ProcessSample StorageSample SystemSample fullHostname The fully qualified (DNS) hostname. NetworkSample ProcessSample StorageSample SystemSample hardwareAddress The unique hardware address of the interface. NetworkSample hostname The short version of the entity's name. NetworkSample ProcessSample StorageSample SystemSample interfaceName The interface name as reported by the operating system.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.26013,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> data dictionary",
        "sections": "<em>New</em> <em>Relic</em> data dictionary",
        "body": " <em>trace</em>. Included when <em>distributed</em> <em>tracing</em> is enabled. AwsLambdaInvocationError AwsLambdaInvocation <em>Mobile</em>Request <em>Mobile</em>RequestError Span uuid ID A unique identifier assigned by <em>New</em> <em>Relic</em> for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app"
      },
      "id": "603f53b164441f41894e8875"
    },
    {
      "sections": [
        "Set up the trace observer",
        "Tip",
        "Important",
        "Send sample payload",
        "Trace observer endpoints"
      ],
      "title": "Set up the trace observer",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Distributed tracing",
        "Infinite Tracing"
      ],
      "external_id": "bf72691e2db5eb458c5d2e626b75554b2fd3d16b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/distributed-tracing/infinite-tracing/set-trace-observer/",
      "published_at": "2021-12-30T03:11:17Z",
      "updated_at": "2021-12-04T21:50:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you're following the Enable distributed tracing procedures and want to set up Infinite Tracing, you'll need to set up a trace observer. A trace observer is a cloud-based New Relic tool that decides what trace data to keep and send to New Relic. The trace observer lives in New Relic Edge, which is an AWS-based service that provides you with a low-latency and low-cost way to send your telemetry data to New Relic. The trace observer sends data via our Trace API, which is the entry point for all distributed trace data we ingest. Tip This documentation is for our Infinite Tracing feature. To learn about all our distributed tracing options, see Intro to distributed tracing. Set up the trace observer Before setting up a trace observer, understand these points: With the exception of the Trace API, these instructions are not standalone; they're part of larger enable procedures. If you're still figuring out what you need, see Enable distributed tracing. To avoid configuration conflict issues, you should ideally enable Infinite Tracing for all associated services. If some services in a trace have our standard distributed tracing enabled, you should upgrade those to Infinite Tracing. To set up a trace observer: Go to one.newrelic.com, and click Apps. Under Your apps, click New Relic Edge. Select an account in the upper-left dropdown. If you have access to multiple accounts, make sure you're in the account where you want Infinite Tracing enabled. If no trace observers are already present, click New trace observer to add one, fill out the information, and click Create. Important Note: If you select a trace observer in an EU region, you’ll still need a US-based New Relic account because data is reported to US data centers. Under the Endpoints dropdown: Copy the For other integrations endpoint value and have it ready: this will be referred to in later instructions as YOUR_TRACE_OBSERVER_URL. If you're enabling a language agent, also copy the For language agents value and have it ready: this will be referred to as YOUR_TRACE_OBSERVER_HOST. (Optional but recommended) To verify things are working, we recommend sending a sample trace payload. If you're using our Trace API: this step is especially recommended to learn how the API works. Send sample payload Important If you're using Zipkin-format data, see Send Zipkin payload. This test sends a sample trace payload with one trace and two spans from a service named Test Service A. To send this sample request: Get the license key for the account you want to report data to and have it ready. Copy the following curl request into a text editor: curl -i -H \"Content-Type: application/json\" \\ -H \"Api-Key: $YOUR_LICENSE_KEY\" \\ -H 'Data-Format: newrelic' \\ -H 'Data-Format-Version: 1' \\ -X POST \\ -d '[ { \"common\": { \"attributes\": { \"environment\": \"staging\" } }, \"spans\": [ { \"trace.id\": \"123456\", \"id\": \"ABC\", \"attributes\": { \"duration.ms\": 12.53, \"host\": \"host123.example.com\", \"name\": \"/home\", \"service.name\": \"Test Service A\" } }, { \"trace.id\": \"123456\", \"id\": \"DEF\", \"attributes\": { \"duration.ms\": 2.97, \"host\": \"host456.example.com\", \"error.message\": \"Invalid credentials\", \"name\": \"/auth\", \"parent.id\": \"ABC\", \"service.name\": \"Test Service B\" } } ] } ]' \\ '$YOUR_TRACE_OBSERVER_URL' Copy Insert your own values into the curl request: Value Description $YOUR_LICENSE_KEY Replace this with your license key. $YOUR_TRACE_OBSERVER_URL Replace this with the For other integrations endpoint value you copied in a previous step. Copy the curl request into a terminal and execute it. The test should return HTTP/1.1 202 Accepted, indicating success. If it does not, check the following common issues: Confirm that you used the For other integrations endpoint value. Confirm you're using single quotes around YOUR_TRACE_OBSERVER_URL. Check that you're using the correct API key. If your test returned HTTP/1.1 202 Accepted, go to the New Relic UI to see a query of the sample payload data using the span attribute service.name = Test Service A (here's a link for that query). Because the sample payload contains an error attribute, the error sampler will mark it for keeping. If you modify the payload to remove the error attributes, the random sampler may not choose to keep this particular trace. Tip Traces may take up to one minute to show up in the UI. (Optional) There are several ways to configure Infinite Tracing. This configuration can wait until after you've completed the enable procedures. This procedure is complete. Next, return to finish any remaining instructions for the tracing tool you started enabling: Language agents Third-party telemetry integrations (OpenTelemetry and others) Trace API: once the trace observer is set up, you're finished and can start instrumenting your application. Trace observer endpoints In the trace observer UI, there's an Endpoints dropdown. When setting up the trace observer, we have you copy these values for use at various points of our tracing tool setup instructions. There are two values: For language agents: This value is referenced in our code examples as YOUR_TRACE_OBSERVER_HOST. This is used for configuring our language agents to send data to the trace observer. For other integrations: This value is referenced in our code examples as YOUR_TRACE_OBSERVER_URL. This is used for configuring our telemetry integrations and for sending data via the Trace API (including sending sample payloads).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.21445,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set up the <em>trace</em> observer",
        "sections": "Set up the <em>trace</em> observer",
        "tags": "<em>Distributed</em> <em>tracing</em>",
        "body": "If you&#x27;re following the Enable <em>distributed</em> <em>tracing</em> procedures and want to set up Infinite <em>Tracing</em>, you&#x27;ll need to set up a <em>trace</em> observer. A <em>trace</em> observer is a cloud-based <em>New</em> <em>Relic</em> tool that decides what <em>trace</em> data to keep and send to <em>New</em> <em>Relic</em>. The <em>trace</em> observer lives in <em>New</em> <em>Relic</em> Edge, which"
      },
      "id": "6072a6a3e7b9d23abba5c682"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/install-configure/android-agent-crash-reporting": [
    {
      "sections": [
        "Install Android apps with Gradle and Android Studio",
        "Install your Android app",
        "Configure with Gradle and Android Studio",
        "Project level build.gradle file:",
        "App level build.gradle file:",
        "Important",
        "Update your Android installation",
        "Android 4.x: Multidex support",
        "New Relic Gradle Plugin configuration"
      ],
      "title": "Install Android apps with Gradle and Android Studio",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "51fab3eba87ddee949cd4729de8b5f64534de9c7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-android-apps-gradle-android-studio/",
      "published_at": "2021-12-30T06:16:04Z",
      "updated_at": "2021-07-27T17:09:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Gradle or Android Studio, follow these instructions to install New Relic's mobile monitoring for the first time. If you have previously installed the Android agent SDK for mobile monitoring, follow the steps before upgrading to the latest version with Gradle and Android Studio. Install your Android app As part of the installation process for mobile monitoring, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. Go to one.newrelic.com > Mobile. If applicable: From the Mobile apps index, select Add a new app. From the Get started page, select Android as the platform for mobile monitoring. Type a meaningful name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring with Gradle and Android Studio. OR: To complete the configuration process for a new mobile app later: Go to one.newrelic.com > Mobile, then select See instructions next to your mobile app name. To upgrade an existing Android installation: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Configure with Gradle and Android Studio These procedures to configure your Android app with Gradle and Android Studio also appear on the Get started page in New Relic. Merge New Relic's mobile monitoring code in the Gradle & Android Studio tab to your build.gradle file. Project level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. buildscript { repositories { mavenCentral() } dependencies { classpath \"com.newrelic.agent.android:agent-gradle-plugin:AGENT_VERSION\" } } Copy App level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. repositories { mavenCentral() } apply plugin: 'android' apply plugin: 'newrelic' dependencies { compile 'com.newrelic.agent.android:android-agent:AGENT_VERSION' } Copy ProGuard or DexGuard: In your project’s root directory (projectname/app), add a newrelic.properties file with the following line: com.newrelic.application_token=GENERATED_TOKEN Copy Follow the additional, required configuration steps for using ProGuard or DexGuard with New Relic. Set app permissions: Ensure that your Android app requests INTERNET and ACCESS_NETWORK_STATE permissions by adding these lines to your AndroidManifest.xml file: <uses-permission android:name=\"android.permission.INTERNET\" /> <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /> Copy To start New Relic's mobile monitoring agent: In your Default Activity (as defined in your Manifest), import the NewRelic class: import com.newrelic.agent.android.NewRelic; Copy Important We do not support starting the mobile monitoring agent in other classes, as that can cause unexpected or unstable behavior. To initialize mobile monitoring: In the onCreate() method, add this call: NewRelic.withApplicationToken(\"GENERATED_TOKEN\").start(this.getApplication()); Copy Optional: Change the logging level. To build and run your application: Clean your project, then run your app in an emulator or device to generate traffic. Wait a few minutes, then view data for your Android app from the Overview page: Go to one.newrelic.com > Mobile > (select an app). If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI, follow the troubleshooting procedures. Update your Android installation To keep your Android agent up to date, follow the procedures to upgrade the Android agent SDK for New Relic. To install the latest Android version for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Android 4.x: Multidex support New Relic's mobile monitoring for Android versions prior to Android 5.0 (API level 21) use the Dalvik runtime to execute app code. By default, Dalvik limits apps to a single classes.dex bytecode file per APK. In order to get around this limitation, you must enable multidex support. Then you can use the multidex support library, which becomes part of the primary DEX file of your app and then manages access to the additional DEX files and the code they contain. When building each DEX file for a multidex app, the build tools perform complex decision making to determine which classes are needed in the primary DEX file so that your app can start successfully. If any class required during startup is not provided in the primary DEX file, then your app crashes with the error java.lang.NoClassDefFoundError. If you see the java.lang.NoClassDefFoundError error, then you must manually specify these additional classes as required in the primary DEX file: Create a proguard.multidex.config file within the /app folder of your project. Update mypackage to reflect your package name. #################### # keep class names # #################### #Keep New Relic in the main dex -keep class com.newrelic.** { *; } -keep class com.mypackage.activities.** { *; } Copy Merge the following code into the app-level build.gradle file: android { defaultConfig{ … multiDexKeepProguard file(\"proguard.multidex.config\") } } Copy For more information, see the Android Developers documentation on declaring classes required in the primary DEX file. New Relic Gradle Plugin configuration For details on how to configure the behavior of the mobile monitoring agent plugin during Gradle builds, see the New Relic Gradle plugin extension guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.88582,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "sections": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "If you use Gradle or <em>Android</em> Studio, follow these instructions to <em>install</em> <em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for the first time. If you have previously installed the <em>Android</em> agent SDK for <em>mobile</em> <em>monitoring</em>, follow the steps before upgrading to the latest version with Gradle and <em>Android</em> Studio. <em>Install</em>"
      },
      "id": "603ea70128ccbc59c2eba74e"
    },
    {
      "sections": [
        "Configure ProGuard or DexGuard for Android apps",
        "Configure ProGuard",
        "Network library support",
        "Configure DexGuard"
      ],
      "title": "Configure ProGuard or DexGuard for Android apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "8a8df969c4099f75cb214354cef311dfa2ab50e2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/configure-proguard-or-dexguard-android-apps/",
      "published_at": "2021-12-30T06:15:13Z",
      "updated_at": "2021-08-21T09:16:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to support ProGuard or DexGuard with the Android agent. Check our Android compatibility and requirements, and if you have previously installed the Android agent SDK, follow the steps before upgrading to the latest version with ProGuard or DexGuard. Configure ProGuard To add support for ProGuard: Add an exclusion to your app; for example: To support New Relic instrumentation, add keep class. To disable warnings related to unresolved problems, add dont warn. To preserve line numbers for crash reporting, add LineNumberTable. To preserve stack information for handled exceptions, add SourceFile and EnclosingMethod. Add the following to your ProGuard config file (proguard.cfg, proguard-android.txt, proguard-rules.pro, etc.): -keep class com.newrelic.** { *; } -dontwarn com.newrelic.** -keepattributes Exceptions, Signature, InnerClasses, LineNumberTable, SourceFile, EnclosingMethod Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors. Network library support New Relic instrumentation happens before ProGuard obfuscates your code. In order for these libraries to be properly instrumented, their classes must not be obfuscated by ProGuard. Here are examples of rules to be applied to preserve these classes. This is not a complete list. Different rules will be needed depending on your library or version. Library Rules Apache Http -keep class org.apache.http.** { *; } -dontwarn org.apache.http.** Copy OkHttp 2 -keep class com.squareup.okhttp.* { *; } -dontwarn com.squareup.okhttp.** -dontwarn okio.** Copy OkHttp 3 -keep class okhttp3.** { *; } -dontwarn okhttp3.** -dontwarn okio.** Copy Retrofit 2 -keep class retrofit2.** { *; } -dontwarn retrofit2.** Copy Configure DexGuard DexGuard uses the same configuration options as ProGuard, and it can read any pre-existing ProGuard configuration files. DexGuard also has its own set of additional configuration options and provides sample configurations for many common app frameworks. To add support for DexGuard: Add DexGuard to your app and set up the Gradle plugin according to the directions from DexGuard. Create a dexguard-project.txt file to hold specific DexGuard configuration options, and add: -dontnote com.newrelic.agent.android.NewRelic -dontnote com.newrelic.agent.android.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app's buildTypes configuration is similar to this: buildTypes { release { minifyEnabled true proguardFile getDefaultDexGuardFile('dexguard-release.pro') proguardFile 'proguard-rules.pro' proguardFile 'dexguard-project.txt' } ... Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.00864,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "sections": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": ", and add: -dontnote com.newrelic.agent.<em>android.NewRelic</em> -dontnote com.newrelic.agent.<em>android</em>.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app&#x27;s buildTypes configuration is similar to this: buildTypes { release { minifyEnabled"
      },
      "id": "604418de196a6770e7960f6c"
    },
    {
      "sections": [
        "Install the New Relic plugin for Android Instant Apps",
        "Terminology",
        "Install the plugin",
        "Minimal build.gradle example",
        "Instrumentation",
        "ProGuard and Dexguard support",
        "Important",
        "Troubleshoot auto-instrumentation"
      ],
      "title": "Install the New Relic plugin for Android Instant Apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "a9b40dd5eccb3d96a0cdc246eafe66b92fdeab6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-new-relic-plugin-android-instant-apps/",
      "published_at": "2021-12-30T07:08:39Z",
      "updated_at": "2021-07-09T15:02:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Android Instant Apps allow users to quickly use your applications without installation. With the Android agent version 5.17.0 and higher, you can use New Relic to detect and instrument all feature modules for an instant app. Use this documentation along with the standard New Relic procedures to install Android apps with Gradle and Android Studio. After following the standard installation procedures, follow these additional steps for Android instant apps. Terminology This procedure uses the following terms that are specific to the Android Instant Apps plugin: Module: Any packaged class and/or resource collection APK: A module that packages the apps resources and DEX’ed classes Feature module: A slimmed down module that contains only a subset of the total APK Install the plugin To install the New Relic plugin for Android Instant Apps: First follow the steps in the Install Android apps with Gradle and Android Studio documentation. Apply the agent plugin in every project Gradle build file. List the Android agent as a dependency. Start the agent from each Activity class in the feature that could be side-loaded through a Digital Asset Link intent, (for example, mobile.example.com/signin). Minimal build.gradle example apply plugin: ‘com.android.[application|library|feature|instantapp]' apply plugin: ‘newrelic’ dependencies { implementation \"com.newrelic.agent.android:android-agent:${project.agentVersion}\" } Copy Review the considerations for instrumentation. Instrumentation When instrumenting an instant app, be aware of the following considerations with APKs: Instant apps and APKs Comments Instrumentation Instrumentation of instant apps behaves the same as instrumentation with a normal APK. The agent will detect when an APK is an instant app. For feature APKs, the agent will inject a unique build ID that instant apps will use when reporting crashes. The side-loaded (main) activity of every feature must call NewRelic.start() when the activity is created (as per normal instructions). ProGuard and Dexguard support for feature and application APKs Place the newrelic.properties file in the root (main) directory of the project. ProGuard and Dexguard support The Android Studio Gradle plugin will obfuscate any build configuration where minifyEnabled is set to true. In these conditions, the New Relic agent will forward the ProGuard map generated for the build to crash collectors, tagged with a unique build ID generated by the agent. Obfuscation is best configured in the application or instant app project that includes other modules as dependencies. Modules may configure ProGuard as needed. Important When using ProGuard or DexGuard with Android apps, follow the procedures to complete the additional, required configuration steps. For more information, see the ProGuard and DexGuard configuration documentation. Troubleshoot auto-instrumentation If you are not whether the agent is auto-instrumenting an instant app project, try running these steps: Build app with debug (-d, --debug) option, and capture the build log. Search the log for evidence of instant apps by looking for either of these terms: This appears to be an Instant App Copy BuildId[1a2b34c5-def6-7890-g123-h4567890a] Copy The agent will add an attribute named 'instantApp' to the app's Insights session attributes if the app appears to be an instant app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.59676,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "sections": "<em>Install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " and&#x2F;or resource collection APK: A module that packages the apps resources and DEX’ed classes Feature module: A slimmed down module that contains only a subset of the total APK <em>Install</em> the plugin To <em>install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps: First follow the steps in the <em>Install</em> <em>Android</em> apps"
      },
      "id": "603e87a764441fa6934e885e"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/install-configure/configure-new-relic-gradle-plugin": [
    {
      "sections": [
        "Install Android apps with Gradle and Android Studio",
        "Install your Android app",
        "Configure with Gradle and Android Studio",
        "Project level build.gradle file:",
        "App level build.gradle file:",
        "Important",
        "Update your Android installation",
        "Android 4.x: Multidex support",
        "New Relic Gradle Plugin configuration"
      ],
      "title": "Install Android apps with Gradle and Android Studio",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "51fab3eba87ddee949cd4729de8b5f64534de9c7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-android-apps-gradle-android-studio/",
      "published_at": "2021-12-30T06:16:04Z",
      "updated_at": "2021-07-27T17:09:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Gradle or Android Studio, follow these instructions to install New Relic's mobile monitoring for the first time. If you have previously installed the Android agent SDK for mobile monitoring, follow the steps before upgrading to the latest version with Gradle and Android Studio. Install your Android app As part of the installation process for mobile monitoring, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. Go to one.newrelic.com > Mobile. If applicable: From the Mobile apps index, select Add a new app. From the Get started page, select Android as the platform for mobile monitoring. Type a meaningful name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring with Gradle and Android Studio. OR: To complete the configuration process for a new mobile app later: Go to one.newrelic.com > Mobile, then select See instructions next to your mobile app name. To upgrade an existing Android installation: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Configure with Gradle and Android Studio These procedures to configure your Android app with Gradle and Android Studio also appear on the Get started page in New Relic. Merge New Relic's mobile monitoring code in the Gradle & Android Studio tab to your build.gradle file. Project level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. buildscript { repositories { mavenCentral() } dependencies { classpath \"com.newrelic.agent.android:agent-gradle-plugin:AGENT_VERSION\" } } Copy App level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. repositories { mavenCentral() } apply plugin: 'android' apply plugin: 'newrelic' dependencies { compile 'com.newrelic.agent.android:android-agent:AGENT_VERSION' } Copy ProGuard or DexGuard: In your project’s root directory (projectname/app), add a newrelic.properties file with the following line: com.newrelic.application_token=GENERATED_TOKEN Copy Follow the additional, required configuration steps for using ProGuard or DexGuard with New Relic. Set app permissions: Ensure that your Android app requests INTERNET and ACCESS_NETWORK_STATE permissions by adding these lines to your AndroidManifest.xml file: <uses-permission android:name=\"android.permission.INTERNET\" /> <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /> Copy To start New Relic's mobile monitoring agent: In your Default Activity (as defined in your Manifest), import the NewRelic class: import com.newrelic.agent.android.NewRelic; Copy Important We do not support starting the mobile monitoring agent in other classes, as that can cause unexpected or unstable behavior. To initialize mobile monitoring: In the onCreate() method, add this call: NewRelic.withApplicationToken(\"GENERATED_TOKEN\").start(this.getApplication()); Copy Optional: Change the logging level. To build and run your application: Clean your project, then run your app in an emulator or device to generate traffic. Wait a few minutes, then view data for your Android app from the Overview page: Go to one.newrelic.com > Mobile > (select an app). If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI, follow the troubleshooting procedures. Update your Android installation To keep your Android agent up to date, follow the procedures to upgrade the Android agent SDK for New Relic. To install the latest Android version for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Android 4.x: Multidex support New Relic's mobile monitoring for Android versions prior to Android 5.0 (API level 21) use the Dalvik runtime to execute app code. By default, Dalvik limits apps to a single classes.dex bytecode file per APK. In order to get around this limitation, you must enable multidex support. Then you can use the multidex support library, which becomes part of the primary DEX file of your app and then manages access to the additional DEX files and the code they contain. When building each DEX file for a multidex app, the build tools perform complex decision making to determine which classes are needed in the primary DEX file so that your app can start successfully. If any class required during startup is not provided in the primary DEX file, then your app crashes with the error java.lang.NoClassDefFoundError. If you see the java.lang.NoClassDefFoundError error, then you must manually specify these additional classes as required in the primary DEX file: Create a proguard.multidex.config file within the /app folder of your project. Update mypackage to reflect your package name. #################### # keep class names # #################### #Keep New Relic in the main dex -keep class com.newrelic.** { *; } -keep class com.mypackage.activities.** { *; } Copy Merge the following code into the app-level build.gradle file: android { defaultConfig{ … multiDexKeepProguard file(\"proguard.multidex.config\") } } Copy For more information, see the Android Developers documentation on declaring classes required in the primary DEX file. New Relic Gradle Plugin configuration For details on how to configure the behavior of the mobile monitoring agent plugin during Gradle builds, see the New Relic Gradle plugin extension guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.88582,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "sections": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "If you use Gradle or <em>Android</em> Studio, follow these instructions to <em>install</em> <em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for the first time. If you have previously installed the <em>Android</em> agent SDK for <em>mobile</em> <em>monitoring</em>, follow the steps before upgrading to the latest version with Gradle and <em>Android</em> Studio. <em>Install</em>"
      },
      "id": "603ea70128ccbc59c2eba74e"
    },
    {
      "sections": [
        "Configure ProGuard or DexGuard for Android apps",
        "Configure ProGuard",
        "Network library support",
        "Configure DexGuard"
      ],
      "title": "Configure ProGuard or DexGuard for Android apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "8a8df969c4099f75cb214354cef311dfa2ab50e2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/configure-proguard-or-dexguard-android-apps/",
      "published_at": "2021-12-30T06:15:13Z",
      "updated_at": "2021-08-21T09:16:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to support ProGuard or DexGuard with the Android agent. Check our Android compatibility and requirements, and if you have previously installed the Android agent SDK, follow the steps before upgrading to the latest version with ProGuard or DexGuard. Configure ProGuard To add support for ProGuard: Add an exclusion to your app; for example: To support New Relic instrumentation, add keep class. To disable warnings related to unresolved problems, add dont warn. To preserve line numbers for crash reporting, add LineNumberTable. To preserve stack information for handled exceptions, add SourceFile and EnclosingMethod. Add the following to your ProGuard config file (proguard.cfg, proguard-android.txt, proguard-rules.pro, etc.): -keep class com.newrelic.** { *; } -dontwarn com.newrelic.** -keepattributes Exceptions, Signature, InnerClasses, LineNumberTable, SourceFile, EnclosingMethod Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors. Network library support New Relic instrumentation happens before ProGuard obfuscates your code. In order for these libraries to be properly instrumented, their classes must not be obfuscated by ProGuard. Here are examples of rules to be applied to preserve these classes. This is not a complete list. Different rules will be needed depending on your library or version. Library Rules Apache Http -keep class org.apache.http.** { *; } -dontwarn org.apache.http.** Copy OkHttp 2 -keep class com.squareup.okhttp.* { *; } -dontwarn com.squareup.okhttp.** -dontwarn okio.** Copy OkHttp 3 -keep class okhttp3.** { *; } -dontwarn okhttp3.** -dontwarn okio.** Copy Retrofit 2 -keep class retrofit2.** { *; } -dontwarn retrofit2.** Copy Configure DexGuard DexGuard uses the same configuration options as ProGuard, and it can read any pre-existing ProGuard configuration files. DexGuard also has its own set of additional configuration options and provides sample configurations for many common app frameworks. To add support for DexGuard: Add DexGuard to your app and set up the Gradle plugin according to the directions from DexGuard. Create a dexguard-project.txt file to hold specific DexGuard configuration options, and add: -dontnote com.newrelic.agent.android.NewRelic -dontnote com.newrelic.agent.android.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app's buildTypes configuration is similar to this: buildTypes { release { minifyEnabled true proguardFile getDefaultDexGuardFile('dexguard-release.pro') proguardFile 'proguard-rules.pro' proguardFile 'dexguard-project.txt' } ... Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.00864,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "sections": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": ", and add: -dontnote com.newrelic.agent.<em>android.NewRelic</em> -dontnote com.newrelic.agent.<em>android</em>.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app&#x27;s buildTypes configuration is similar to this: buildTypes { release { minifyEnabled"
      },
      "id": "604418de196a6770e7960f6c"
    },
    {
      "sections": [
        "Install the New Relic plugin for Android Instant Apps",
        "Terminology",
        "Install the plugin",
        "Minimal build.gradle example",
        "Instrumentation",
        "ProGuard and Dexguard support",
        "Important",
        "Troubleshoot auto-instrumentation"
      ],
      "title": "Install the New Relic plugin for Android Instant Apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "a9b40dd5eccb3d96a0cdc246eafe66b92fdeab6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-new-relic-plugin-android-instant-apps/",
      "published_at": "2021-12-30T07:08:39Z",
      "updated_at": "2021-07-09T15:02:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Android Instant Apps allow users to quickly use your applications without installation. With the Android agent version 5.17.0 and higher, you can use New Relic to detect and instrument all feature modules for an instant app. Use this documentation along with the standard New Relic procedures to install Android apps with Gradle and Android Studio. After following the standard installation procedures, follow these additional steps for Android instant apps. Terminology This procedure uses the following terms that are specific to the Android Instant Apps plugin: Module: Any packaged class and/or resource collection APK: A module that packages the apps resources and DEX’ed classes Feature module: A slimmed down module that contains only a subset of the total APK Install the plugin To install the New Relic plugin for Android Instant Apps: First follow the steps in the Install Android apps with Gradle and Android Studio documentation. Apply the agent plugin in every project Gradle build file. List the Android agent as a dependency. Start the agent from each Activity class in the feature that could be side-loaded through a Digital Asset Link intent, (for example, mobile.example.com/signin). Minimal build.gradle example apply plugin: ‘com.android.[application|library|feature|instantapp]' apply plugin: ‘newrelic’ dependencies { implementation \"com.newrelic.agent.android:android-agent:${project.agentVersion}\" } Copy Review the considerations for instrumentation. Instrumentation When instrumenting an instant app, be aware of the following considerations with APKs: Instant apps and APKs Comments Instrumentation Instrumentation of instant apps behaves the same as instrumentation with a normal APK. The agent will detect when an APK is an instant app. For feature APKs, the agent will inject a unique build ID that instant apps will use when reporting crashes. The side-loaded (main) activity of every feature must call NewRelic.start() when the activity is created (as per normal instructions). ProGuard and Dexguard support for feature and application APKs Place the newrelic.properties file in the root (main) directory of the project. ProGuard and Dexguard support The Android Studio Gradle plugin will obfuscate any build configuration where minifyEnabled is set to true. In these conditions, the New Relic agent will forward the ProGuard map generated for the build to crash collectors, tagged with a unique build ID generated by the agent. Obfuscation is best configured in the application or instant app project that includes other modules as dependencies. Modules may configure ProGuard as needed. Important When using ProGuard or DexGuard with Android apps, follow the procedures to complete the additional, required configuration steps. For more information, see the ProGuard and DexGuard configuration documentation. Troubleshoot auto-instrumentation If you are not whether the agent is auto-instrumenting an instant app project, try running these steps: Build app with debug (-d, --debug) option, and capture the build log. Search the log for evidence of instant apps by looking for either of these terms: This appears to be an Instant App Copy BuildId[1a2b34c5-def6-7890-g123-h4567890a] Copy The agent will add an attribute named 'instantApp' to the app's Insights session attributes if the app appears to be an instant app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.59676,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "sections": "<em>Install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " and&#x2F;or resource collection APK: A module that packages the apps resources and DEX’ed classes Feature module: A slimmed down module that contains only a subset of the total APK <em>Install</em> the plugin To <em>install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps: First follow the steps in the <em>Install</em> <em>Android</em> apps"
      },
      "id": "603e87a764441fa6934e885e"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/install-configure/configure-proguard-or-dexguard-android-apps": [
    {
      "sections": [
        "Install Android apps with Gradle and Android Studio",
        "Install your Android app",
        "Configure with Gradle and Android Studio",
        "Project level build.gradle file:",
        "App level build.gradle file:",
        "Important",
        "Update your Android installation",
        "Android 4.x: Multidex support",
        "New Relic Gradle Plugin configuration"
      ],
      "title": "Install Android apps with Gradle and Android Studio",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "51fab3eba87ddee949cd4729de8b5f64534de9c7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-android-apps-gradle-android-studio/",
      "published_at": "2021-12-30T06:16:04Z",
      "updated_at": "2021-07-27T17:09:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Gradle or Android Studio, follow these instructions to install New Relic's mobile monitoring for the first time. If you have previously installed the Android agent SDK for mobile monitoring, follow the steps before upgrading to the latest version with Gradle and Android Studio. Install your Android app As part of the installation process for mobile monitoring, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. Go to one.newrelic.com > Mobile. If applicable: From the Mobile apps index, select Add a new app. From the Get started page, select Android as the platform for mobile monitoring. Type a meaningful name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring with Gradle and Android Studio. OR: To complete the configuration process for a new mobile app later: Go to one.newrelic.com > Mobile, then select See instructions next to your mobile app name. To upgrade an existing Android installation: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Configure with Gradle and Android Studio These procedures to configure your Android app with Gradle and Android Studio also appear on the Get started page in New Relic. Merge New Relic's mobile monitoring code in the Gradle & Android Studio tab to your build.gradle file. Project level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. buildscript { repositories { mavenCentral() } dependencies { classpath \"com.newrelic.agent.android:agent-gradle-plugin:AGENT_VERSION\" } } Copy App level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. repositories { mavenCentral() } apply plugin: 'android' apply plugin: 'newrelic' dependencies { compile 'com.newrelic.agent.android:android-agent:AGENT_VERSION' } Copy ProGuard or DexGuard: In your project’s root directory (projectname/app), add a newrelic.properties file with the following line: com.newrelic.application_token=GENERATED_TOKEN Copy Follow the additional, required configuration steps for using ProGuard or DexGuard with New Relic. Set app permissions: Ensure that your Android app requests INTERNET and ACCESS_NETWORK_STATE permissions by adding these lines to your AndroidManifest.xml file: <uses-permission android:name=\"android.permission.INTERNET\" /> <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /> Copy To start New Relic's mobile monitoring agent: In your Default Activity (as defined in your Manifest), import the NewRelic class: import com.newrelic.agent.android.NewRelic; Copy Important We do not support starting the mobile monitoring agent in other classes, as that can cause unexpected or unstable behavior. To initialize mobile monitoring: In the onCreate() method, add this call: NewRelic.withApplicationToken(\"GENERATED_TOKEN\").start(this.getApplication()); Copy Optional: Change the logging level. To build and run your application: Clean your project, then run your app in an emulator or device to generate traffic. Wait a few minutes, then view data for your Android app from the Overview page: Go to one.newrelic.com > Mobile > (select an app). If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI, follow the troubleshooting procedures. Update your Android installation To keep your Android agent up to date, follow the procedures to upgrade the Android agent SDK for New Relic. To install the latest Android version for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Android 4.x: Multidex support New Relic's mobile monitoring for Android versions prior to Android 5.0 (API level 21) use the Dalvik runtime to execute app code. By default, Dalvik limits apps to a single classes.dex bytecode file per APK. In order to get around this limitation, you must enable multidex support. Then you can use the multidex support library, which becomes part of the primary DEX file of your app and then manages access to the additional DEX files and the code they contain. When building each DEX file for a multidex app, the build tools perform complex decision making to determine which classes are needed in the primary DEX file so that your app can start successfully. If any class required during startup is not provided in the primary DEX file, then your app crashes with the error java.lang.NoClassDefFoundError. If you see the java.lang.NoClassDefFoundError error, then you must manually specify these additional classes as required in the primary DEX file: Create a proguard.multidex.config file within the /app folder of your project. Update mypackage to reflect your package name. #################### # keep class names # #################### #Keep New Relic in the main dex -keep class com.newrelic.** { *; } -keep class com.mypackage.activities.** { *; } Copy Merge the following code into the app-level build.gradle file: android { defaultConfig{ … multiDexKeepProguard file(\"proguard.multidex.config\") } } Copy For more information, see the Android Developers documentation on declaring classes required in the primary DEX file. New Relic Gradle Plugin configuration For details on how to configure the behavior of the mobile monitoring agent plugin during Gradle builds, see the New Relic Gradle plugin extension guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.88582,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "sections": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "If you use Gradle or <em>Android</em> Studio, follow these instructions to <em>install</em> <em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for the first time. If you have previously installed the <em>Android</em> agent SDK for <em>mobile</em> <em>monitoring</em>, follow the steps before upgrading to the latest version with Gradle and <em>Android</em> Studio. <em>Install</em>"
      },
      "id": "603ea70128ccbc59c2eba74e"
    },
    {
      "sections": [
        "Install the New Relic plugin for Android Instant Apps",
        "Terminology",
        "Install the plugin",
        "Minimal build.gradle example",
        "Instrumentation",
        "ProGuard and Dexguard support",
        "Important",
        "Troubleshoot auto-instrumentation"
      ],
      "title": "Install the New Relic plugin for Android Instant Apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "a9b40dd5eccb3d96a0cdc246eafe66b92fdeab6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-new-relic-plugin-android-instant-apps/",
      "published_at": "2021-12-30T07:08:39Z",
      "updated_at": "2021-07-09T15:02:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Android Instant Apps allow users to quickly use your applications without installation. With the Android agent version 5.17.0 and higher, you can use New Relic to detect and instrument all feature modules for an instant app. Use this documentation along with the standard New Relic procedures to install Android apps with Gradle and Android Studio. After following the standard installation procedures, follow these additional steps for Android instant apps. Terminology This procedure uses the following terms that are specific to the Android Instant Apps plugin: Module: Any packaged class and/or resource collection APK: A module that packages the apps resources and DEX’ed classes Feature module: A slimmed down module that contains only a subset of the total APK Install the plugin To install the New Relic plugin for Android Instant Apps: First follow the steps in the Install Android apps with Gradle and Android Studio documentation. Apply the agent plugin in every project Gradle build file. List the Android agent as a dependency. Start the agent from each Activity class in the feature that could be side-loaded through a Digital Asset Link intent, (for example, mobile.example.com/signin). Minimal build.gradle example apply plugin: ‘com.android.[application|library|feature|instantapp]' apply plugin: ‘newrelic’ dependencies { implementation \"com.newrelic.agent.android:android-agent:${project.agentVersion}\" } Copy Review the considerations for instrumentation. Instrumentation When instrumenting an instant app, be aware of the following considerations with APKs: Instant apps and APKs Comments Instrumentation Instrumentation of instant apps behaves the same as instrumentation with a normal APK. The agent will detect when an APK is an instant app. For feature APKs, the agent will inject a unique build ID that instant apps will use when reporting crashes. The side-loaded (main) activity of every feature must call NewRelic.start() when the activity is created (as per normal instructions). ProGuard and Dexguard support for feature and application APKs Place the newrelic.properties file in the root (main) directory of the project. ProGuard and Dexguard support The Android Studio Gradle plugin will obfuscate any build configuration where minifyEnabled is set to true. In these conditions, the New Relic agent will forward the ProGuard map generated for the build to crash collectors, tagged with a unique build ID generated by the agent. Obfuscation is best configured in the application or instant app project that includes other modules as dependencies. Modules may configure ProGuard as needed. Important When using ProGuard or DexGuard with Android apps, follow the procedures to complete the additional, required configuration steps. For more information, see the ProGuard and DexGuard configuration documentation. Troubleshoot auto-instrumentation If you are not whether the agent is auto-instrumenting an instant app project, try running these steps: Build app with debug (-d, --debug) option, and capture the build log. Search the log for evidence of instant apps by looking for either of these terms: This appears to be an Instant App Copy BuildId[1a2b34c5-def6-7890-g123-h4567890a] Copy The agent will add an attribute named 'instantApp' to the app's Insights session attributes if the app appears to be an instant app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.59676,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "sections": "<em>Install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " and&#x2F;or resource collection APK: A module that packages the apps resources and DEX’ed classes Feature module: A slimmed down module that contains only a subset of the total APK <em>Install</em> the plugin To <em>install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps: First follow the steps in the <em>Install</em> <em>Android</em> apps"
      },
      "id": "603e87a764441fa6934e885e"
    },
    {
      "sections": [
        "Upgrade the Android agent",
        "Upgrade from Android SDK versions 2 or 3",
        "Upgrade Android SDK version 1"
      ],
      "title": "Upgrade the Android agent",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "eca0e4db3d71cbe83bbb40fdc2e7d026d5e5ed4b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/upgrade-new-relic-mobiles-android-sdk/",
      "published_at": "2021-12-30T11:17:44Z",
      "updated_at": "2021-07-09T15:02:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To ensure you have the most current version of the Android agent, see the Android agent release notes. Instructions to upgrade your Android app will vary, based on which version of the Android agent SDK you are currently using. Upgrade from Android SDK versions 2 or 3 If you have previously installed version 2 or 3 of the Android SDK: Go to one.newrelic.com > Mobile > (select an app) > Settings > Upgrade. Upgrade Android SDK version 1 If you have previously installed version 1 of the Android SDK, follow these steps before upgrading to version 2 or higher. Step Notes Open your AndroidManifest.xml file, and remove the NewRelicApplication class. When you first ran nrandroid-setup, the NewRelicApplication class was added to your AndroidManifest.xml file. This has been removed from the New Relic SDK and is no longer necessary. If you had an existing Application subclass and modified it to inherit from NewRelicApplication, update your subclass to inherit from Application instead. Stop using nrandroid-ant. Mobile monitoring no longer requires the custom Ant wrapper script for Android applications. Once you upgrade, simply use your standard build tools. If you modified an existing Maven configuration to invoke the mobile build steps, remove those modifications, and use the revised build instructions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.59676,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upgrade the <em>Android</em> agent",
        "sections": "Upgrade the <em>Android</em> agent",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " it to inherit from <em>NewRelic</em>Application, update your subclass to inherit from Application instead. Stop using nrandroid-ant. <em>Mobile</em> <em>monitoring</em> no longer requires the custom Ant wrapper script for <em>Android</em> applications. Once you upgrade, simply use your standard build tools. If you modified an existing Maven configuration to invoke the <em>mobile</em> build steps, remove those modifications, and use the revised build instructions."
      },
      "id": "603eae0664441f985b4e8843"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-android-apps-gradle-android-studio": [
    {
      "sections": [
        "Configure ProGuard or DexGuard for Android apps",
        "Configure ProGuard",
        "Network library support",
        "Configure DexGuard"
      ],
      "title": "Configure ProGuard or DexGuard for Android apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "8a8df969c4099f75cb214354cef311dfa2ab50e2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/configure-proguard-or-dexguard-android-apps/",
      "published_at": "2021-12-30T06:15:13Z",
      "updated_at": "2021-08-21T09:16:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to support ProGuard or DexGuard with the Android agent. Check our Android compatibility and requirements, and if you have previously installed the Android agent SDK, follow the steps before upgrading to the latest version with ProGuard or DexGuard. Configure ProGuard To add support for ProGuard: Add an exclusion to your app; for example: To support New Relic instrumentation, add keep class. To disable warnings related to unresolved problems, add dont warn. To preserve line numbers for crash reporting, add LineNumberTable. To preserve stack information for handled exceptions, add SourceFile and EnclosingMethod. Add the following to your ProGuard config file (proguard.cfg, proguard-android.txt, proguard-rules.pro, etc.): -keep class com.newrelic.** { *; } -dontwarn com.newrelic.** -keepattributes Exceptions, Signature, InnerClasses, LineNumberTable, SourceFile, EnclosingMethod Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors. Network library support New Relic instrumentation happens before ProGuard obfuscates your code. In order for these libraries to be properly instrumented, their classes must not be obfuscated by ProGuard. Here are examples of rules to be applied to preserve these classes. This is not a complete list. Different rules will be needed depending on your library or version. Library Rules Apache Http -keep class org.apache.http.** { *; } -dontwarn org.apache.http.** Copy OkHttp 2 -keep class com.squareup.okhttp.* { *; } -dontwarn com.squareup.okhttp.** -dontwarn okio.** Copy OkHttp 3 -keep class okhttp3.** { *; } -dontwarn okhttp3.** -dontwarn okio.** Copy Retrofit 2 -keep class retrofit2.** { *; } -dontwarn retrofit2.** Copy Configure DexGuard DexGuard uses the same configuration options as ProGuard, and it can read any pre-existing ProGuard configuration files. DexGuard also has its own set of additional configuration options and provides sample configurations for many common app frameworks. To add support for DexGuard: Add DexGuard to your app and set up the Gradle plugin according to the directions from DexGuard. Create a dexguard-project.txt file to hold specific DexGuard configuration options, and add: -dontnote com.newrelic.agent.android.NewRelic -dontnote com.newrelic.agent.android.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app's buildTypes configuration is similar to this: buildTypes { release { minifyEnabled true proguardFile getDefaultDexGuardFile('dexguard-release.pro') proguardFile 'proguard-rules.pro' proguardFile 'dexguard-project.txt' } ... Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.00864,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "sections": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": ", and add: -dontnote com.newrelic.agent.<em>android.NewRelic</em> -dontnote com.newrelic.agent.<em>android</em>.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app&#x27;s buildTypes configuration is similar to this: buildTypes { release { minifyEnabled"
      },
      "id": "604418de196a6770e7960f6c"
    },
    {
      "sections": [
        "Install the New Relic plugin for Android Instant Apps",
        "Terminology",
        "Install the plugin",
        "Minimal build.gradle example",
        "Instrumentation",
        "ProGuard and Dexguard support",
        "Important",
        "Troubleshoot auto-instrumentation"
      ],
      "title": "Install the New Relic plugin for Android Instant Apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "a9b40dd5eccb3d96a0cdc246eafe66b92fdeab6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-new-relic-plugin-android-instant-apps/",
      "published_at": "2021-12-30T07:08:39Z",
      "updated_at": "2021-07-09T15:02:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Android Instant Apps allow users to quickly use your applications without installation. With the Android agent version 5.17.0 and higher, you can use New Relic to detect and instrument all feature modules for an instant app. Use this documentation along with the standard New Relic procedures to install Android apps with Gradle and Android Studio. After following the standard installation procedures, follow these additional steps for Android instant apps. Terminology This procedure uses the following terms that are specific to the Android Instant Apps plugin: Module: Any packaged class and/or resource collection APK: A module that packages the apps resources and DEX’ed classes Feature module: A slimmed down module that contains only a subset of the total APK Install the plugin To install the New Relic plugin for Android Instant Apps: First follow the steps in the Install Android apps with Gradle and Android Studio documentation. Apply the agent plugin in every project Gradle build file. List the Android agent as a dependency. Start the agent from each Activity class in the feature that could be side-loaded through a Digital Asset Link intent, (for example, mobile.example.com/signin). Minimal build.gradle example apply plugin: ‘com.android.[application|library|feature|instantapp]' apply plugin: ‘newrelic’ dependencies { implementation \"com.newrelic.agent.android:android-agent:${project.agentVersion}\" } Copy Review the considerations for instrumentation. Instrumentation When instrumenting an instant app, be aware of the following considerations with APKs: Instant apps and APKs Comments Instrumentation Instrumentation of instant apps behaves the same as instrumentation with a normal APK. The agent will detect when an APK is an instant app. For feature APKs, the agent will inject a unique build ID that instant apps will use when reporting crashes. The side-loaded (main) activity of every feature must call NewRelic.start() when the activity is created (as per normal instructions). ProGuard and Dexguard support for feature and application APKs Place the newrelic.properties file in the root (main) directory of the project. ProGuard and Dexguard support The Android Studio Gradle plugin will obfuscate any build configuration where minifyEnabled is set to true. In these conditions, the New Relic agent will forward the ProGuard map generated for the build to crash collectors, tagged with a unique build ID generated by the agent. Obfuscation is best configured in the application or instant app project that includes other modules as dependencies. Modules may configure ProGuard as needed. Important When using ProGuard or DexGuard with Android apps, follow the procedures to complete the additional, required configuration steps. For more information, see the ProGuard and DexGuard configuration documentation. Troubleshoot auto-instrumentation If you are not whether the agent is auto-instrumenting an instant app project, try running these steps: Build app with debug (-d, --debug) option, and capture the build log. Search the log for evidence of instant apps by looking for either of these terms: This appears to be an Instant App Copy BuildId[1a2b34c5-def6-7890-g123-h4567890a] Copy The agent will add an attribute named 'instantApp' to the app's Insights session attributes if the app appears to be an instant app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.59674,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "sections": "<em>Install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " and&#x2F;or resource collection APK: A module that packages the apps resources and DEX’ed classes Feature module: A slimmed down module that contains only a subset of the total APK <em>Install</em> the plugin To <em>install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps: First follow the steps in the <em>Install</em> <em>Android</em> apps"
      },
      "id": "603e87a764441fa6934e885e"
    },
    {
      "sections": [
        "Upgrade the Android agent",
        "Upgrade from Android SDK versions 2 or 3",
        "Upgrade Android SDK version 1"
      ],
      "title": "Upgrade the Android agent",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "eca0e4db3d71cbe83bbb40fdc2e7d026d5e5ed4b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/upgrade-new-relic-mobiles-android-sdk/",
      "published_at": "2021-12-30T11:17:44Z",
      "updated_at": "2021-07-09T15:02:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To ensure you have the most current version of the Android agent, see the Android agent release notes. Instructions to upgrade your Android app will vary, based on which version of the Android agent SDK you are currently using. Upgrade from Android SDK versions 2 or 3 If you have previously installed version 2 or 3 of the Android SDK: Go to one.newrelic.com > Mobile > (select an app) > Settings > Upgrade. Upgrade Android SDK version 1 If you have previously installed version 1 of the Android SDK, follow these steps before upgrading to version 2 or higher. Step Notes Open your AndroidManifest.xml file, and remove the NewRelicApplication class. When you first ran nrandroid-setup, the NewRelicApplication class was added to your AndroidManifest.xml file. This has been removed from the New Relic SDK and is no longer necessary. If you had an existing Application subclass and modified it to inherit from NewRelicApplication, update your subclass to inherit from Application instead. Stop using nrandroid-ant. Mobile monitoring no longer requires the custom Ant wrapper script for Android applications. Once you upgrade, simply use your standard build tools. If you modified an existing Maven configuration to invoke the mobile build steps, remove those modifications, and use the revised build instructions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.59674,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upgrade the <em>Android</em> agent",
        "sections": "Upgrade the <em>Android</em> agent",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " it to inherit from <em>NewRelic</em>Application, update your subclass to inherit from Application instead. Stop using nrandroid-ant. <em>Mobile</em> <em>monitoring</em> no longer requires the custom Ant wrapper script for <em>Android</em> applications. Once you upgrade, simply use your standard build tools. If you modified an existing Maven configuration to invoke the <em>mobile</em> build steps, remove those modifications, and use the revised build instructions."
      },
      "id": "603eae0664441f985b4e8843"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-new-relic-plugin-android-instant-apps": [
    {
      "sections": [
        "Install Android apps with Gradle and Android Studio",
        "Install your Android app",
        "Configure with Gradle and Android Studio",
        "Project level build.gradle file:",
        "App level build.gradle file:",
        "Important",
        "Update your Android installation",
        "Android 4.x: Multidex support",
        "New Relic Gradle Plugin configuration"
      ],
      "title": "Install Android apps with Gradle and Android Studio",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "51fab3eba87ddee949cd4729de8b5f64534de9c7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-android-apps-gradle-android-studio/",
      "published_at": "2021-12-30T06:16:04Z",
      "updated_at": "2021-07-27T17:09:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Gradle or Android Studio, follow these instructions to install New Relic's mobile monitoring for the first time. If you have previously installed the Android agent SDK for mobile monitoring, follow the steps before upgrading to the latest version with Gradle and Android Studio. Install your Android app As part of the installation process for mobile monitoring, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. Go to one.newrelic.com > Mobile. If applicable: From the Mobile apps index, select Add a new app. From the Get started page, select Android as the platform for mobile monitoring. Type a meaningful name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring with Gradle and Android Studio. OR: To complete the configuration process for a new mobile app later: Go to one.newrelic.com > Mobile, then select See instructions next to your mobile app name. To upgrade an existing Android installation: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Configure with Gradle and Android Studio These procedures to configure your Android app with Gradle and Android Studio also appear on the Get started page in New Relic. Merge New Relic's mobile monitoring code in the Gradle & Android Studio tab to your build.gradle file. Project level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. buildscript { repositories { mavenCentral() } dependencies { classpath \"com.newrelic.agent.android:agent-gradle-plugin:AGENT_VERSION\" } } Copy App level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. repositories { mavenCentral() } apply plugin: 'android' apply plugin: 'newrelic' dependencies { compile 'com.newrelic.agent.android:android-agent:AGENT_VERSION' } Copy ProGuard or DexGuard: In your project’s root directory (projectname/app), add a newrelic.properties file with the following line: com.newrelic.application_token=GENERATED_TOKEN Copy Follow the additional, required configuration steps for using ProGuard or DexGuard with New Relic. Set app permissions: Ensure that your Android app requests INTERNET and ACCESS_NETWORK_STATE permissions by adding these lines to your AndroidManifest.xml file: <uses-permission android:name=\"android.permission.INTERNET\" /> <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /> Copy To start New Relic's mobile monitoring agent: In your Default Activity (as defined in your Manifest), import the NewRelic class: import com.newrelic.agent.android.NewRelic; Copy Important We do not support starting the mobile monitoring agent in other classes, as that can cause unexpected or unstable behavior. To initialize mobile monitoring: In the onCreate() method, add this call: NewRelic.withApplicationToken(\"GENERATED_TOKEN\").start(this.getApplication()); Copy Optional: Change the logging level. To build and run your application: Clean your project, then run your app in an emulator or device to generate traffic. Wait a few minutes, then view data for your Android app from the Overview page: Go to one.newrelic.com > Mobile > (select an app). If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI, follow the troubleshooting procedures. Update your Android installation To keep your Android agent up to date, follow the procedures to upgrade the Android agent SDK for New Relic. To install the latest Android version for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Android 4.x: Multidex support New Relic's mobile monitoring for Android versions prior to Android 5.0 (API level 21) use the Dalvik runtime to execute app code. By default, Dalvik limits apps to a single classes.dex bytecode file per APK. In order to get around this limitation, you must enable multidex support. Then you can use the multidex support library, which becomes part of the primary DEX file of your app and then manages access to the additional DEX files and the code they contain. When building each DEX file for a multidex app, the build tools perform complex decision making to determine which classes are needed in the primary DEX file so that your app can start successfully. If any class required during startup is not provided in the primary DEX file, then your app crashes with the error java.lang.NoClassDefFoundError. If you see the java.lang.NoClassDefFoundError error, then you must manually specify these additional classes as required in the primary DEX file: Create a proguard.multidex.config file within the /app folder of your project. Update mypackage to reflect your package name. #################### # keep class names # #################### #Keep New Relic in the main dex -keep class com.newrelic.** { *; } -keep class com.mypackage.activities.** { *; } Copy Merge the following code into the app-level build.gradle file: android { defaultConfig{ … multiDexKeepProguard file(\"proguard.multidex.config\") } } Copy For more information, see the Android Developers documentation on declaring classes required in the primary DEX file. New Relic Gradle Plugin configuration For details on how to configure the behavior of the mobile monitoring agent plugin during Gradle builds, see the New Relic Gradle plugin extension guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.88582,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "sections": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "If you use Gradle or <em>Android</em> Studio, follow these instructions to <em>install</em> <em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for the first time. If you have previously installed the <em>Android</em> agent SDK for <em>mobile</em> <em>monitoring</em>, follow the steps before upgrading to the latest version with Gradle and <em>Android</em> Studio. <em>Install</em>"
      },
      "id": "603ea70128ccbc59c2eba74e"
    },
    {
      "sections": [
        "Configure ProGuard or DexGuard for Android apps",
        "Configure ProGuard",
        "Network library support",
        "Configure DexGuard"
      ],
      "title": "Configure ProGuard or DexGuard for Android apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "8a8df969c4099f75cb214354cef311dfa2ab50e2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/configure-proguard-or-dexguard-android-apps/",
      "published_at": "2021-12-30T06:15:13Z",
      "updated_at": "2021-08-21T09:16:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to support ProGuard or DexGuard with the Android agent. Check our Android compatibility and requirements, and if you have previously installed the Android agent SDK, follow the steps before upgrading to the latest version with ProGuard or DexGuard. Configure ProGuard To add support for ProGuard: Add an exclusion to your app; for example: To support New Relic instrumentation, add keep class. To disable warnings related to unresolved problems, add dont warn. To preserve line numbers for crash reporting, add LineNumberTable. To preserve stack information for handled exceptions, add SourceFile and EnclosingMethod. Add the following to your ProGuard config file (proguard.cfg, proguard-android.txt, proguard-rules.pro, etc.): -keep class com.newrelic.** { *; } -dontwarn com.newrelic.** -keepattributes Exceptions, Signature, InnerClasses, LineNumberTable, SourceFile, EnclosingMethod Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors. Network library support New Relic instrumentation happens before ProGuard obfuscates your code. In order for these libraries to be properly instrumented, their classes must not be obfuscated by ProGuard. Here are examples of rules to be applied to preserve these classes. This is not a complete list. Different rules will be needed depending on your library or version. Library Rules Apache Http -keep class org.apache.http.** { *; } -dontwarn org.apache.http.** Copy OkHttp 2 -keep class com.squareup.okhttp.* { *; } -dontwarn com.squareup.okhttp.** -dontwarn okio.** Copy OkHttp 3 -keep class okhttp3.** { *; } -dontwarn okhttp3.** -dontwarn okio.** Copy Retrofit 2 -keep class retrofit2.** { *; } -dontwarn retrofit2.** Copy Configure DexGuard DexGuard uses the same configuration options as ProGuard, and it can read any pre-existing ProGuard configuration files. DexGuard also has its own set of additional configuration options and provides sample configurations for many common app frameworks. To add support for DexGuard: Add DexGuard to your app and set up the Gradle plugin according to the directions from DexGuard. Create a dexguard-project.txt file to hold specific DexGuard configuration options, and add: -dontnote com.newrelic.agent.android.NewRelic -dontnote com.newrelic.agent.android.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app's buildTypes configuration is similar to this: buildTypes { release { minifyEnabled true proguardFile getDefaultDexGuardFile('dexguard-release.pro') proguardFile 'proguard-rules.pro' proguardFile 'dexguard-project.txt' } ... Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.00864,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "sections": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": ", and add: -dontnote com.newrelic.agent.<em>android.NewRelic</em> -dontnote com.newrelic.agent.<em>android</em>.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app&#x27;s buildTypes configuration is similar to this: buildTypes { release { minifyEnabled"
      },
      "id": "604418de196a6770e7960f6c"
    },
    {
      "sections": [
        "Upgrade the Android agent",
        "Upgrade from Android SDK versions 2 or 3",
        "Upgrade Android SDK version 1"
      ],
      "title": "Upgrade the Android agent",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "eca0e4db3d71cbe83bbb40fdc2e7d026d5e5ed4b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/upgrade-new-relic-mobiles-android-sdk/",
      "published_at": "2021-12-30T11:17:44Z",
      "updated_at": "2021-07-09T15:02:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To ensure you have the most current version of the Android agent, see the Android agent release notes. Instructions to upgrade your Android app will vary, based on which version of the Android agent SDK you are currently using. Upgrade from Android SDK versions 2 or 3 If you have previously installed version 2 or 3 of the Android SDK: Go to one.newrelic.com > Mobile > (select an app) > Settings > Upgrade. Upgrade Android SDK version 1 If you have previously installed version 1 of the Android SDK, follow these steps before upgrading to version 2 or higher. Step Notes Open your AndroidManifest.xml file, and remove the NewRelicApplication class. When you first ran nrandroid-setup, the NewRelicApplication class was added to your AndroidManifest.xml file. This has been removed from the New Relic SDK and is no longer necessary. If you had an existing Application subclass and modified it to inherit from NewRelicApplication, update your subclass to inherit from Application instead. Stop using nrandroid-ant. Mobile monitoring no longer requires the custom Ant wrapper script for Android applications. Once you upgrade, simply use your standard build tools. If you modified an existing Maven configuration to invoke the mobile build steps, remove those modifications, and use the revised build instructions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.59674,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upgrade the <em>Android</em> agent",
        "sections": "Upgrade the <em>Android</em> agent",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " it to inherit from <em>NewRelic</em>Application, update your subclass to inherit from Application instead. Stop using nrandroid-ant. <em>Mobile</em> <em>monitoring</em> no longer requires the custom Ant wrapper script for <em>Android</em> applications. Once you upgrade, simply use your standard build tools. If you modified an existing Maven configuration to invoke the <em>mobile</em> build steps, remove those modifications, and use the revised build instructions."
      },
      "id": "603eae0664441f985b4e8843"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/install-configure/upgrade-new-relic-mobiles-android-sdk": [
    {
      "sections": [
        "Install Android apps with Gradle and Android Studio",
        "Install your Android app",
        "Configure with Gradle and Android Studio",
        "Project level build.gradle file:",
        "App level build.gradle file:",
        "Important",
        "Update your Android installation",
        "Android 4.x: Multidex support",
        "New Relic Gradle Plugin configuration"
      ],
      "title": "Install Android apps with Gradle and Android Studio",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "51fab3eba87ddee949cd4729de8b5f64534de9c7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-android-apps-gradle-android-studio/",
      "published_at": "2021-12-30T06:16:04Z",
      "updated_at": "2021-07-27T17:09:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Gradle or Android Studio, follow these instructions to install New Relic's mobile monitoring for the first time. If you have previously installed the Android agent SDK for mobile monitoring, follow the steps before upgrading to the latest version with Gradle and Android Studio. Install your Android app As part of the installation process for mobile monitoring, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. Go to one.newrelic.com > Mobile. If applicable: From the Mobile apps index, select Add a new app. From the Get started page, select Android as the platform for mobile monitoring. Type a meaningful name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring with Gradle and Android Studio. OR: To complete the configuration process for a new mobile app later: Go to one.newrelic.com > Mobile, then select See instructions next to your mobile app name. To upgrade an existing Android installation: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Configure with Gradle and Android Studio These procedures to configure your Android app with Gradle and Android Studio also appear on the Get started page in New Relic. Merge New Relic's mobile monitoring code in the Gradle & Android Studio tab to your build.gradle file. Project level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. buildscript { repositories { mavenCentral() } dependencies { classpath \"com.newrelic.agent.android:agent-gradle-plugin:AGENT_VERSION\" } } Copy App level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. repositories { mavenCentral() } apply plugin: 'android' apply plugin: 'newrelic' dependencies { compile 'com.newrelic.agent.android:android-agent:AGENT_VERSION' } Copy ProGuard or DexGuard: In your project’s root directory (projectname/app), add a newrelic.properties file with the following line: com.newrelic.application_token=GENERATED_TOKEN Copy Follow the additional, required configuration steps for using ProGuard or DexGuard with New Relic. Set app permissions: Ensure that your Android app requests INTERNET and ACCESS_NETWORK_STATE permissions by adding these lines to your AndroidManifest.xml file: <uses-permission android:name=\"android.permission.INTERNET\" /> <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /> Copy To start New Relic's mobile monitoring agent: In your Default Activity (as defined in your Manifest), import the NewRelic class: import com.newrelic.agent.android.NewRelic; Copy Important We do not support starting the mobile monitoring agent in other classes, as that can cause unexpected or unstable behavior. To initialize mobile monitoring: In the onCreate() method, add this call: NewRelic.withApplicationToken(\"GENERATED_TOKEN\").start(this.getApplication()); Copy Optional: Change the logging level. To build and run your application: Clean your project, then run your app in an emulator or device to generate traffic. Wait a few minutes, then view data for your Android app from the Overview page: Go to one.newrelic.com > Mobile > (select an app). If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI, follow the troubleshooting procedures. Update your Android installation To keep your Android agent up to date, follow the procedures to upgrade the Android agent SDK for New Relic. To install the latest Android version for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Android 4.x: Multidex support New Relic's mobile monitoring for Android versions prior to Android 5.0 (API level 21) use the Dalvik runtime to execute app code. By default, Dalvik limits apps to a single classes.dex bytecode file per APK. In order to get around this limitation, you must enable multidex support. Then you can use the multidex support library, which becomes part of the primary DEX file of your app and then manages access to the additional DEX files and the code they contain. When building each DEX file for a multidex app, the build tools perform complex decision making to determine which classes are needed in the primary DEX file so that your app can start successfully. If any class required during startup is not provided in the primary DEX file, then your app crashes with the error java.lang.NoClassDefFoundError. If you see the java.lang.NoClassDefFoundError error, then you must manually specify these additional classes as required in the primary DEX file: Create a proguard.multidex.config file within the /app folder of your project. Update mypackage to reflect your package name. #################### # keep class names # #################### #Keep New Relic in the main dex -keep class com.newrelic.** { *; } -keep class com.mypackage.activities.** { *; } Copy Merge the following code into the app-level build.gradle file: android { defaultConfig{ … multiDexKeepProguard file(\"proguard.multidex.config\") } } Copy For more information, see the Android Developers documentation on declaring classes required in the primary DEX file. New Relic Gradle Plugin configuration For details on how to configure the behavior of the mobile monitoring agent plugin during Gradle builds, see the New Relic Gradle plugin extension guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.88582,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "sections": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "If you use Gradle or <em>Android</em> Studio, follow these instructions to <em>install</em> <em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for the first time. If you have previously installed the <em>Android</em> agent SDK for <em>mobile</em> <em>monitoring</em>, follow the steps before upgrading to the latest version with Gradle and <em>Android</em> Studio. <em>Install</em>"
      },
      "id": "603ea70128ccbc59c2eba74e"
    },
    {
      "sections": [
        "Configure ProGuard or DexGuard for Android apps",
        "Configure ProGuard",
        "Network library support",
        "Configure DexGuard"
      ],
      "title": "Configure ProGuard or DexGuard for Android apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "8a8df969c4099f75cb214354cef311dfa2ab50e2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/configure-proguard-or-dexguard-android-apps/",
      "published_at": "2021-12-30T06:15:13Z",
      "updated_at": "2021-08-21T09:16:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to support ProGuard or DexGuard with the Android agent. Check our Android compatibility and requirements, and if you have previously installed the Android agent SDK, follow the steps before upgrading to the latest version with ProGuard or DexGuard. Configure ProGuard To add support for ProGuard: Add an exclusion to your app; for example: To support New Relic instrumentation, add keep class. To disable warnings related to unresolved problems, add dont warn. To preserve line numbers for crash reporting, add LineNumberTable. To preserve stack information for handled exceptions, add SourceFile and EnclosingMethod. Add the following to your ProGuard config file (proguard.cfg, proguard-android.txt, proguard-rules.pro, etc.): -keep class com.newrelic.** { *; } -dontwarn com.newrelic.** -keepattributes Exceptions, Signature, InnerClasses, LineNumberTable, SourceFile, EnclosingMethod Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors. Network library support New Relic instrumentation happens before ProGuard obfuscates your code. In order for these libraries to be properly instrumented, their classes must not be obfuscated by ProGuard. Here are examples of rules to be applied to preserve these classes. This is not a complete list. Different rules will be needed depending on your library or version. Library Rules Apache Http -keep class org.apache.http.** { *; } -dontwarn org.apache.http.** Copy OkHttp 2 -keep class com.squareup.okhttp.* { *; } -dontwarn com.squareup.okhttp.** -dontwarn okio.** Copy OkHttp 3 -keep class okhttp3.** { *; } -dontwarn okhttp3.** -dontwarn okio.** Copy Retrofit 2 -keep class retrofit2.** { *; } -dontwarn retrofit2.** Copy Configure DexGuard DexGuard uses the same configuration options as ProGuard, and it can read any pre-existing ProGuard configuration files. DexGuard also has its own set of additional configuration options and provides sample configurations for many common app frameworks. To add support for DexGuard: Add DexGuard to your app and set up the Gradle plugin according to the directions from DexGuard. Create a dexguard-project.txt file to hold specific DexGuard configuration options, and add: -dontnote com.newrelic.agent.android.NewRelic -dontnote com.newrelic.agent.android.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app's buildTypes configuration is similar to this: buildTypes { release { minifyEnabled true proguardFile getDefaultDexGuardFile('dexguard-release.pro') proguardFile 'proguard-rules.pro' proguardFile 'dexguard-project.txt' } ... Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.00864,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "sections": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": ", and add: -dontnote com.newrelic.agent.<em>android.NewRelic</em> -dontnote com.newrelic.agent.<em>android</em>.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app&#x27;s buildTypes configuration is similar to this: buildTypes { release { minifyEnabled"
      },
      "id": "604418de196a6770e7960f6c"
    },
    {
      "sections": [
        "Install the New Relic plugin for Android Instant Apps",
        "Terminology",
        "Install the plugin",
        "Minimal build.gradle example",
        "Instrumentation",
        "ProGuard and Dexguard support",
        "Important",
        "Troubleshoot auto-instrumentation"
      ],
      "title": "Install the New Relic plugin for Android Instant Apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "a9b40dd5eccb3d96a0cdc246eafe66b92fdeab6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-new-relic-plugin-android-instant-apps/",
      "published_at": "2021-12-30T07:08:39Z",
      "updated_at": "2021-07-09T15:02:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Android Instant Apps allow users to quickly use your applications without installation. With the Android agent version 5.17.0 and higher, you can use New Relic to detect and instrument all feature modules for an instant app. Use this documentation along with the standard New Relic procedures to install Android apps with Gradle and Android Studio. After following the standard installation procedures, follow these additional steps for Android instant apps. Terminology This procedure uses the following terms that are specific to the Android Instant Apps plugin: Module: Any packaged class and/or resource collection APK: A module that packages the apps resources and DEX’ed classes Feature module: A slimmed down module that contains only a subset of the total APK Install the plugin To install the New Relic plugin for Android Instant Apps: First follow the steps in the Install Android apps with Gradle and Android Studio documentation. Apply the agent plugin in every project Gradle build file. List the Android agent as a dependency. Start the agent from each Activity class in the feature that could be side-loaded through a Digital Asset Link intent, (for example, mobile.example.com/signin). Minimal build.gradle example apply plugin: ‘com.android.[application|library|feature|instantapp]' apply plugin: ‘newrelic’ dependencies { implementation \"com.newrelic.agent.android:android-agent:${project.agentVersion}\" } Copy Review the considerations for instrumentation. Instrumentation When instrumenting an instant app, be aware of the following considerations with APKs: Instant apps and APKs Comments Instrumentation Instrumentation of instant apps behaves the same as instrumentation with a normal APK. The agent will detect when an APK is an instant app. For feature APKs, the agent will inject a unique build ID that instant apps will use when reporting crashes. The side-loaded (main) activity of every feature must call NewRelic.start() when the activity is created (as per normal instructions). ProGuard and Dexguard support for feature and application APKs Place the newrelic.properties file in the root (main) directory of the project. ProGuard and Dexguard support The Android Studio Gradle plugin will obfuscate any build configuration where minifyEnabled is set to true. In these conditions, the New Relic agent will forward the ProGuard map generated for the build to crash collectors, tagged with a unique build ID generated by the agent. Obfuscation is best configured in the application or instant app project that includes other modules as dependencies. Modules may configure ProGuard as needed. Important When using ProGuard or DexGuard with Android apps, follow the procedures to complete the additional, required configuration steps. For more information, see the ProGuard and DexGuard configuration documentation. Troubleshoot auto-instrumentation If you are not whether the agent is auto-instrumenting an instant app project, try running these steps: Build app with debug (-d, --debug) option, and capture the build log. Search the log for evidence of instant apps by looking for either of these terms: This appears to be an Instant App Copy BuildId[1a2b34c5-def6-7890-g123-h4567890a] Copy The agent will add an attribute named 'instantApp' to the app's Insights session attributes if the app appears to be an instant app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.59674,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "sections": "<em>Install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " and&#x2F;or resource collection APK: A module that packages the apps resources and DEX’ed classes Feature module: A slimmed down module that contains only a subset of the total APK <em>Install</em> the plugin To <em>install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps: First follow the steps in the <em>Install</em> <em>Android</em> apps"
      },
      "id": "603e87a764441fa6934e885e"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/legacy/install-android-apps-android-22-support": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/new-relic-mobile-and-dt/",
      "sections": [
        "New Relic mobile monitoring with distributed tracing",
        "Requirements",
        "Tip",
        "How to set up distributed tracing",
        "Find data",
        "Troubleshooting"
      ],
      "published_at": "2021-12-30T09:14:17Z",
      "title": "New Relic mobile monitoring with distributed tracing",
      "updated_at": "2021-12-30T09:14:16Z",
      "type": "docs",
      "external_id": "c9846b0f2811bb718f79ce7321c4239032eb310e",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic mobile monitoring agents support distributed tracing. This lets you see how your mobile app activity connects to related services. Watch this short video (approx. 2:15 minutes) to learn how to: Find mobile distributed tracing data in New Relic. Filter by standard and custom attributes. Requirements Here's what you need to use distributed tracing with New Relic mobile: Android agent version 6.0.0 or higher XCFramework agent version 7.3.0 Tip Infinite Tracing is not yet available for mobile monitoring. How to set up distributed tracing For mobile agents that support this feature, it’s enabled by default. If you prefer to turn off distributed tracing, see the following: Android feature flag iOS feature flag Find data Mobile spans appear in any New Relic distributed tracing UI where those spans are part of a trace. Here are some tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting mobileApp.name to the browser app name. Query for traces containing at least one mobile app span with mobileApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both mobile and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.6264,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>monitoring</em> with distributed tracing",
        "sections": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>monitoring</em> with distributed tracing",
        "body": ". Requirements Here&#x27;s what you need to use distributed tracing with <em>New</em> <em>Relic</em> <em>mobile</em>: <em>Android</em> agent version 6.0.0 or higher XCFramework agent version 7.3.0 Tip Infinite Tracing is not yet available for <em>mobile</em> <em>monitoring</em>. How to set up distributed tracing For <em>mobile</em> agents that support this feature, it’s"
      },
      "id": "605858d464441f445f868bac"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "1bd72e8f29f5a1b42d0e66894f97010e9a8a0a63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/android-sdk-api-guide/",
      "published_at": "2021-12-30T06:12:18Z",
      "updated_at": "2021-11-05T14:07:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { … Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { … Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.41989,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> SDK API guide",
        "sections": "<em>Android</em> SDK API guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " instrumentation for <em>monitoring</em> your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your <em>mobile</em> app. Record custom metrics. Send custom attributes and events to <em>New</em> <em>Relic</em> Insights. Track networking from libraries not supported"
      },
      "id": "619ea16464441fdb14985230"
    },
    {
      "sections": [
        "No data appears (Android)",
        "Problem",
        "Solution"
      ],
      "title": "No data appears (Android)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Troubleshoot"
      ],
      "external_id": "cab2851a6f3c8bfddb1ed445f8722b3dddff7442",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/troubleshoot/no-data-appears-android/",
      "published_at": "2021-12-30T07:08:39Z",
      "updated_at": "2021-07-09T15:38:22Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After installing the Android agent and waiting at least 5 minutes, no data appears in New Relic UI. Solution If no data appears after you wait at least five minutes, use New Relic Diagnostics to automatically detect common problems and suggest troubleshooting. If that does not solve your issue, try the following: Make sure your system meets the compatibility and requirements. Make sure that you are calling the Android agent on the first line of onCreate() in the MainActivity class and that you are running the agent on the main thread. The Android agent does not support starting the agent in another class. Check whether your Android app exceeds the 64k multidex limit. Increase the logging level and examine your logs for errors: Increase the New Relic logging level to AUDIT using withLogLevel: NewRelic.withApplicationToken(\"YOUR_APP_TOKEN\") .withLogLevel(AgentLog.AUDIT) .start(this.getApplication()); Copy Generate a few minutes of activity in your app. Examine your device log and your application build logs for issues. Confirm the device can reach the mobile monitoring endpoints listed in the Networks doc. If you need additional help, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.09777,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No data appears (<em>Android</em>)",
        "sections": "No data appears (<em>Android</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Problem After installing the <em>Android</em> agent and waiting at least 5 minutes, no data appears in <em>New</em> <em>Relic</em> UI. Solution If no data appears after you wait at least five minutes, use <em>New</em> <em>Relic</em> Diagnostics to automatically detect common problems and suggest troubleshooting. If that does not solve your"
      },
      "id": "603e8eb6196a67b64ea83d81"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/troubleshoot/android-app-exceeds-64k-multidex-limit": [
    {
      "sections": [
        "No data appears (Android)",
        "Problem",
        "Solution"
      ],
      "title": "No data appears (Android)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Troubleshoot"
      ],
      "external_id": "cab2851a6f3c8bfddb1ed445f8722b3dddff7442",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/troubleshoot/no-data-appears-android/",
      "published_at": "2021-12-30T07:08:39Z",
      "updated_at": "2021-07-09T15:38:22Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After installing the Android agent and waiting at least 5 minutes, no data appears in New Relic UI. Solution If no data appears after you wait at least five minutes, use New Relic Diagnostics to automatically detect common problems and suggest troubleshooting. If that does not solve your issue, try the following: Make sure your system meets the compatibility and requirements. Make sure that you are calling the Android agent on the first line of onCreate() in the MainActivity class and that you are running the agent on the main thread. The Android agent does not support starting the agent in another class. Check whether your Android app exceeds the 64k multidex limit. Increase the logging level and examine your logs for errors: Increase the New Relic logging level to AUDIT using withLogLevel: NewRelic.withApplicationToken(\"YOUR_APP_TOKEN\") .withLogLevel(AgentLog.AUDIT) .start(this.getApplication()); Copy Generate a few minutes of activity in your app. Examine your device log and your application build logs for issues. Confirm the device can reach the mobile monitoring endpoints listed in the Networks doc. If you need additional help, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 165.59058,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No data appears (<em>Android</em>)",
        "sections": "No data appears (<em>Android</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Problem After installing the <em>Android</em> agent and waiting at least 5 minutes, no data appears in <em>New</em> <em>Relic</em> UI. Solution If no data appears after you wait at least five minutes, use <em>New</em> <em>Relic</em> Diagnostics to automatically detect common problems and suggest troubleshooting. If that does not solve your"
      },
      "id": "603e8eb6196a67b64ea83d81"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/new-relic-mobile-and-dt/",
      "sections": [
        "New Relic mobile monitoring with distributed tracing",
        "Requirements",
        "Tip",
        "How to set up distributed tracing",
        "Find data",
        "Troubleshooting"
      ],
      "published_at": "2021-12-30T09:14:17Z",
      "title": "New Relic mobile monitoring with distributed tracing",
      "updated_at": "2021-12-30T09:14:16Z",
      "type": "docs",
      "external_id": "c9846b0f2811bb718f79ce7321c4239032eb310e",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic mobile monitoring agents support distributed tracing. This lets you see how your mobile app activity connects to related services. Watch this short video (approx. 2:15 minutes) to learn how to: Find mobile distributed tracing data in New Relic. Filter by standard and custom attributes. Requirements Here's what you need to use distributed tracing with New Relic mobile: Android agent version 6.0.0 or higher XCFramework agent version 7.3.0 Tip Infinite Tracing is not yet available for mobile monitoring. How to set up distributed tracing For mobile agents that support this feature, it’s enabled by default. If you prefer to turn off distributed tracing, see the following: Android feature flag iOS feature flag Find data Mobile spans appear in any New Relic distributed tracing UI where those spans are part of a trace. Here are some tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting mobileApp.name to the browser app name. Query for traces containing at least one mobile app span with mobileApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both mobile and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.74197,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>monitoring</em> with distributed tracing",
        "sections": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>monitoring</em> with distributed tracing",
        "body": ". Requirements Here&#x27;s what you need to use distributed tracing with <em>New</em> <em>Relic</em> <em>mobile</em>: <em>Android</em> agent version 6.0.0 or higher XCFramework agent version 7.3.0 Tip Infinite Tracing is not yet available for <em>mobile</em> <em>monitoring</em>. How to set up distributed tracing For <em>mobile</em> agents that support this feature, it’s"
      },
      "id": "605858d464441f445f868bac"
    },
    {
      "sections": [
        "Install the New Relic plugin for Android Instant Apps",
        "Terminology",
        "Install the plugin",
        "Minimal build.gradle example",
        "Instrumentation",
        "ProGuard and Dexguard support",
        "Important",
        "Troubleshoot auto-instrumentation"
      ],
      "title": "Install the New Relic plugin for Android Instant Apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "a9b40dd5eccb3d96a0cdc246eafe66b92fdeab6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-new-relic-plugin-android-instant-apps/",
      "published_at": "2021-12-30T07:08:39Z",
      "updated_at": "2021-07-09T15:02:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Android Instant Apps allow users to quickly use your applications without installation. With the Android agent version 5.17.0 and higher, you can use New Relic to detect and instrument all feature modules for an instant app. Use this documentation along with the standard New Relic procedures to install Android apps with Gradle and Android Studio. After following the standard installation procedures, follow these additional steps for Android instant apps. Terminology This procedure uses the following terms that are specific to the Android Instant Apps plugin: Module: Any packaged class and/or resource collection APK: A module that packages the apps resources and DEX’ed classes Feature module: A slimmed down module that contains only a subset of the total APK Install the plugin To install the New Relic plugin for Android Instant Apps: First follow the steps in the Install Android apps with Gradle and Android Studio documentation. Apply the agent plugin in every project Gradle build file. List the Android agent as a dependency. Start the agent from each Activity class in the feature that could be side-loaded through a Digital Asset Link intent, (for example, mobile.example.com/signin). Minimal build.gradle example apply plugin: ‘com.android.[application|library|feature|instantapp]' apply plugin: ‘newrelic’ dependencies { implementation \"com.newrelic.agent.android:android-agent:${project.agentVersion}\" } Copy Review the considerations for instrumentation. Instrumentation When instrumenting an instant app, be aware of the following considerations with APKs: Instant apps and APKs Comments Instrumentation Instrumentation of instant apps behaves the same as instrumentation with a normal APK. The agent will detect when an APK is an instant app. For feature APKs, the agent will inject a unique build ID that instant apps will use when reporting crashes. The side-loaded (main) activity of every feature must call NewRelic.start() when the activity is created (as per normal instructions). ProGuard and Dexguard support for feature and application APKs Place the newrelic.properties file in the root (main) directory of the project. ProGuard and Dexguard support The Android Studio Gradle plugin will obfuscate any build configuration where minifyEnabled is set to true. In these conditions, the New Relic agent will forward the ProGuard map generated for the build to crash collectors, tagged with a unique build ID generated by the agent. Obfuscation is best configured in the application or instant app project that includes other modules as dependencies. Modules may configure ProGuard as needed. Important When using ProGuard or DexGuard with Android apps, follow the procedures to complete the additional, required configuration steps. For more information, see the ProGuard and DexGuard configuration documentation. Troubleshoot auto-instrumentation If you are not whether the agent is auto-instrumenting an instant app project, try running these steps: Build app with debug (-d, --debug) option, and capture the build log. Search the log for evidence of instant apps by looking for either of these terms: This appears to be an Instant App Copy BuildId[1a2b34c5-def6-7890-g123-h4567890a] Copy The agent will add an attribute named 'instantApp' to the app's Insights session attributes if the app appears to be an instant app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.6194,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "sections": "Install the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "<em>Android</em> Instant Apps allow users to quickly use your applications without installation. With the <em>Android</em> agent version 5.17.0 and higher, you can use <em>New</em> <em>Relic</em> to detect and instrument all feature modules for an instant app. Use this documentation along with the standard <em>New</em> <em>Relic</em> procedures"
      },
      "id": "603e87a764441fa6934e885e"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/troubleshoot/no-data-appears-android": [
    {
      "sections": [
        "Android app exceeds 64k multidex limit",
        "Problem",
        "Build time error message example",
        "Run time crash message example",
        "Solution"
      ],
      "title": "Android app exceeds 64k multidex limit",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Troubleshoot"
      ],
      "external_id": "4b456c8143055292aa480cc213ffc82b72ddee70",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/troubleshoot/android-app-exceeds-64k-multidex-limit/",
      "published_at": "2021-12-30T06:16:04Z",
      "updated_at": "2021-07-09T15:04:03Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem Your Android app exceeds the 64k limit for the total number of methods that can be referenced within a single Dalvik Executable file (DEX), including methods for frameworks, libraries, and your own Android app code. You see error messages from the agent such as these: Build time error message example > com.android.build.api.transform.TransformException: com.android.ide.common.process.ProcessException: java.util.concurrent.ExecutionException: com.android.dex.DexException: Too many classes in --main-dex-list, main dex capacity exceeded Copy Run time crash message example E/AndroidRuntime: FATAL EXCEPTION: main Process: com.example.mobile.debug, PID: 12345 java.lang.NoClassDefFoundError: com.example.foobar.myapp.MainActivity Copy These exception errors typically occur with Android devices prior to Android 5.0 (API level 21), which requires the multidex support library. Solution To fix build errors or runtime exceptions when using the latest Android build tool: Make sure you have the latest Android agent version. Enable multidex. Enable Proguard or Dexguard to optimize classes and methods in your DEX. If you still have problems with keeping your Android app under the 64k limit, use a keepfile.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 165.58939,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> app exceeds 64k multidex limit",
        "sections": "<em>Android</em> app exceeds 64k multidex limit",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "&#x2F;<em>Android</em>Runtime: FATAL EXCEPTION: main Process: com.example.<em>mobile</em>.debug, PID: 12345 java.lang.NoClassDefFoundError: com.example.foobar.myapp.MainActivity Copy These exception errors typically occur with <em>Android</em> devices prior to <em>Android</em> 5.0 (API level 21), which requires the multidex support library. Solution"
      },
      "id": "60441922196a6721e4960f26"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/new-relic-mobile-and-dt/",
      "sections": [
        "New Relic mobile monitoring with distributed tracing",
        "Requirements",
        "Tip",
        "How to set up distributed tracing",
        "Find data",
        "Troubleshooting"
      ],
      "published_at": "2021-12-30T09:14:17Z",
      "title": "New Relic mobile monitoring with distributed tracing",
      "updated_at": "2021-12-30T09:14:16Z",
      "type": "docs",
      "external_id": "c9846b0f2811bb718f79ce7321c4239032eb310e",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic mobile monitoring agents support distributed tracing. This lets you see how your mobile app activity connects to related services. Watch this short video (approx. 2:15 minutes) to learn how to: Find mobile distributed tracing data in New Relic. Filter by standard and custom attributes. Requirements Here's what you need to use distributed tracing with New Relic mobile: Android agent version 6.0.0 or higher XCFramework agent version 7.3.0 Tip Infinite Tracing is not yet available for mobile monitoring. How to set up distributed tracing For mobile agents that support this feature, it’s enabled by default. If you prefer to turn off distributed tracing, see the following: Android feature flag iOS feature flag Find data Mobile spans appear in any New Relic distributed tracing UI where those spans are part of a trace. Here are some tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting mobileApp.name to the browser app name. Query for traces containing at least one mobile app span with mobileApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both mobile and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.7419,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>monitoring</em> with distributed tracing",
        "sections": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>monitoring</em> with distributed tracing",
        "body": ". Requirements Here&#x27;s what you need to use distributed tracing with <em>New</em> <em>Relic</em> <em>mobile</em>: <em>Android</em> agent version 6.0.0 or higher XCFramework agent version 7.3.0 Tip Infinite Tracing is not yet available for <em>mobile</em> <em>monitoring</em>. How to set up distributed tracing For <em>mobile</em> agents that support this feature, it’s"
      },
      "id": "605858d464441f445f868bac"
    },
    {
      "sections": [
        "Install the New Relic plugin for Android Instant Apps",
        "Terminology",
        "Install the plugin",
        "Minimal build.gradle example",
        "Instrumentation",
        "ProGuard and Dexguard support",
        "Important",
        "Troubleshoot auto-instrumentation"
      ],
      "title": "Install the New Relic plugin for Android Instant Apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "a9b40dd5eccb3d96a0cdc246eafe66b92fdeab6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-new-relic-plugin-android-instant-apps/",
      "published_at": "2021-12-30T07:08:39Z",
      "updated_at": "2021-07-09T15:02:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Android Instant Apps allow users to quickly use your applications without installation. With the Android agent version 5.17.0 and higher, you can use New Relic to detect and instrument all feature modules for an instant app. Use this documentation along with the standard New Relic procedures to install Android apps with Gradle and Android Studio. After following the standard installation procedures, follow these additional steps for Android instant apps. Terminology This procedure uses the following terms that are specific to the Android Instant Apps plugin: Module: Any packaged class and/or resource collection APK: A module that packages the apps resources and DEX’ed classes Feature module: A slimmed down module that contains only a subset of the total APK Install the plugin To install the New Relic plugin for Android Instant Apps: First follow the steps in the Install Android apps with Gradle and Android Studio documentation. Apply the agent plugin in every project Gradle build file. List the Android agent as a dependency. Start the agent from each Activity class in the feature that could be side-loaded through a Digital Asset Link intent, (for example, mobile.example.com/signin). Minimal build.gradle example apply plugin: ‘com.android.[application|library|feature|instantapp]' apply plugin: ‘newrelic’ dependencies { implementation \"com.newrelic.agent.android:android-agent:${project.agentVersion}\" } Copy Review the considerations for instrumentation. Instrumentation When instrumenting an instant app, be aware of the following considerations with APKs: Instant apps and APKs Comments Instrumentation Instrumentation of instant apps behaves the same as instrumentation with a normal APK. The agent will detect when an APK is an instant app. For feature APKs, the agent will inject a unique build ID that instant apps will use when reporting crashes. The side-loaded (main) activity of every feature must call NewRelic.start() when the activity is created (as per normal instructions). ProGuard and Dexguard support for feature and application APKs Place the newrelic.properties file in the root (main) directory of the project. ProGuard and Dexguard support The Android Studio Gradle plugin will obfuscate any build configuration where minifyEnabled is set to true. In these conditions, the New Relic agent will forward the ProGuard map generated for the build to crash collectors, tagged with a unique build ID generated by the agent. Obfuscation is best configured in the application or instant app project that includes other modules as dependencies. Modules may configure ProGuard as needed. Important When using ProGuard or DexGuard with Android apps, follow the procedures to complete the additional, required configuration steps. For more information, see the ProGuard and DexGuard configuration documentation. Troubleshoot auto-instrumentation If you are not whether the agent is auto-instrumenting an instant app project, try running these steps: Build app with debug (-d, --debug) option, and capture the build log. Search the log for evidence of instant apps by looking for either of these terms: This appears to be an Instant App Copy BuildId[1a2b34c5-def6-7890-g123-h4567890a] Copy The agent will add an attribute named 'instantApp' to the app's Insights session attributes if the app appears to be an instant app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.6194,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "sections": "Install the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "<em>Android</em> Instant Apps allow users to quickly use your applications without installation. With the <em>Android</em> agent version 5.17.0 and higher, you can use <em>New</em> <em>Relic</em> to detect and instrument all feature modules for an instant app. Use this documentation along with the standard <em>New</em> <em>Relic</em> procedures"
      },
      "id": "603e87a764441fa6934e885e"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-apps/mobile-app-features/authentication-partner-saml-sso-accounts": [
    {
      "sections": [
        "User settings and authentication",
        "User authentication",
        "User settings",
        "Sign in with additional username",
        "Switch between accounts",
        "Remove or re-add a user name"
      ],
      "title": "User settings and authentication",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Authentication and alerts"
      ],
      "external_id": "4af21c858a77745c2e36e621e551819a9d284d38",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-apps/authentication-alerts/user-settings-authentication/",
      "published_at": "2022-01-01T08:46:27Z",
      "updated_at": "2021-12-14T04:24:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This explains how to authenticate your New Relic mobile app account, and how to add users to or remove them from your mobile device. User authentication Depending on your New Relic account, additional installation or authentication steps may be required when you install the New Relic mobile app. New Relic account Additional requirements New users If you do not already have a New Relic account: From your desktop web browser, create a New Relic account. Install your application with the appropriate New Relic agent. As part of new account setup, you will receive an email with a password reset link. The password reset link expires after 20 minutes for mobile apps. Existing New Relic users No additional requirements; your applications, hosts, and key transactions automatically appear after you sign in. Users with New Relic partner accounts Depending on the partner, you may need to complete a different authentication process. Azure Store users: Due to the deep integration between Azure Storefront and New Relic, Azure Storefront users cannot access their accounts on the New Relic Android or iOS apps. Users with SAML-SSO enabled accounts When you sign in to the New Relic mobile app, your session automatically redirects to your web browser. From there you can sign in to your New Relic SAML-SSO account. If you see any errors when using SAML-SSO accounts on your mobile device, verify that you are able to sign in to one.newrelic.com with a desktop web browser. If no, contact your administrator. If yes, get support at support.newrelic.com. User settings After you sign in, all New Relic accounts and applications associated with the user appear automatically. Sign in with additional username Follow the procedure for your mobile device. Mobile device To sign in to the app with an additional user name: Android To switch users: Log out from the Android device: Main menu > (selected username) > Logout > Confirm. Log in with a new account. iPhone From the app menu, select your account name, then select the Users menu. From the Users menu, select the plus icon. Sign in with the additional username. iPad To access the Users menu: Select the user icon or slide right. From the Users menu, select the plus icon. Sign in with the additional username. Switch between accounts To switch between accounts associated with your username: From the Users menu, select the user name. Select the account name. Remove or re-add a user name To remove a specific username from this device: From the Users menu, select Logout. To remove a user from this device, select the user's red minus icon. Select the user's Log out icon. To add a user again, sign in with that username again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 274.51663,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User settings <em>and</em> <em>authentication</em>",
        "sections": "User settings <em>and</em> <em>authentication</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": " a different <em>authentication</em> process. Azure Store users: Due to the deep integration between Azure Storefront and <em>New</em> <em>Relic</em>, Azure Storefront users cannot access their accounts on the <em>New</em> <em>Relic</em> Android or iOS <em>apps</em>. Users with SAML-SSO enabled accounts When you sign in to the <em>New</em> <em>Relic</em> <em>mobile</em> <em>app</em>, your"
      },
      "id": "604415a728ccbc8fb52c6068"
    },
    {
      "sections": [
        "Troubleshoot SSO accounts using mobile devices",
        "No user name or password",
        "Errors after signing in",
        "Reauthentication problems"
      ],
      "title": "Troubleshoot SSO accounts using mobile devices",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Authentication and alerts"
      ],
      "external_id": "3bdd6c364d59a8b79d67260388100ceac757fcb0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-apps/authentication-alerts/troubleshoot-sso-accounts-using-mobile-devices/",
      "published_at": "2021-12-30T09:49:01Z",
      "updated_at": "2021-12-14T04:23:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Typically when you sign in to the New Relic mobile app, your session redirects automatically to your web browser. From there you can sign in to your New Relic account. Here are troubleshooting tips if you have problems using the New Relic mobile app with your SAML-SSO enabled account. No user name or password You may not have a user name or password for New Relic because some SAML providers will overwrite your password, or because your administrator has not sent you this information. In these situations: From the mobile app's Log in, select the I don't have a password link. Use your mobile device to open your email account. From your email account, retrieve the New Relic authentication email within 20 minutes. Select the Authenticate button or the link below it in the email. Errors after signing in If you see any errors after successfully signing in to your SSO provider with your mobile device, verify that you are able to sign in to one.newrelic.com with a desktop web browser. If no, contact your administrator. If yes, get support at support.newrelic.com. Reauthentication problems If you are using reauthentication on a SAML-SSO account, you must log in to your default account. (All other accounts will be grayed out.) If you attempt to switch to a grayed-out account, an error message will appear, explaining this is currently not supported.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 274.51517,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshoot SSO accounts using <em>mobile</em> devices",
        "sections": "Troubleshoot SSO accounts using <em>mobile</em> devices",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": "Typically when you sign in to the <em>New</em> <em>Relic</em> <em>mobile</em> <em>app</em>, your session redirects automatically to your web browser. From there you can sign in to your <em>New</em> <em>Relic</em> account. Here are troubleshooting tips if you have problems using the <em>New</em> <em>Relic</em> <em>mobile</em> <em>app</em> with your SAML-SSO enabled account. No user name"
      },
      "id": "604415e0196a67fc3f960f42"
    },
    {
      "sections": [
        "Alerting with New Relic mobile apps",
        "Requirements",
        "Turn notifications on or off",
        "View alert incident details",
        "Troubleshoot alert settings",
        "Check notification settings for your mobile device.",
        "Delete the Android or iOS device from your New Relic account.",
        "Uninstall the New Relic mobile app.",
        "Reinstall the New Relic mobile app."
      ],
      "title": "Alerting with New Relic mobile apps",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Authentication and alerts"
      ],
      "external_id": "19bd5fbedd3d386c36cadc21d9dc4c7d6b7f0bce",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-apps/authentication-alerts/alerting-new-relic-mobile-apps/",
      "published_at": "2021-12-31T03:06:25Z",
      "updated_at": "2021-12-14T04:23:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Account administrators can set up configuration to receive push notifications on Android and iOS devices from New Relic Alerts. You can receive alerts from any policy by attaching a user channel to the policy. Requirements This feature is available only to users on the original user model, not to users on the New Relic One user model. As a workaround, you can use the email notification channel. Turn notifications on or off When you log in to your New Relic account from an Android or iOS app, your device is automatically associated with your user channel. Be sure to add the associated user channel to the alert policy. View alert incident details The notification automatically appears on your device's lock screen. To start the New Relic app: Android devices: Tap the notification from the notification drawer. OR iOS devices: Swipe the screen. From the New Relic app's Alerts menu, select any alert to view error details for the associated application. Optional: Select Acknowledge. Optional: To view additional details, select Overview, Violations, or Event log. The main menu's Alerts list shows alerts in the following order, sorted by time: Active incidents Resolved incidents from today Resolved incidents and events from the past week, organized by day Troubleshoot alert settings If alerts are not working on your mobile device: Verify that you meet the requirements. Verify that alerts are enabled. Check your mobile device's notification settings, to ensure New Relic is permitted to send alerts. If the notification settings for your mobile device are correct, but you still do not receive notifications, delete the device from your account, then uninstall and reinstall the New Relic application. Check notification settings for your mobile device. Follow the procedure for your mobile device. Device To check notification settings: Android From your Android device's Settings, select Sound and notification. Check the settings for sound volume. Optional: Enable Also vibrate for calls. Check the settings for Interruptions. Check the settings for Notification. Check the settings for App notifications: Select the New Relic app, then check the settings for Block and Priority. iOS Ensure Do Not Disturb is off: From the iOS Settings app, select Do Not Disturb, and check that the Manual switch is off. Ensure the New Relic app is allowed to send notifications: From the iOS Settings app, select Notifications, and locate the New Relic app from the app list. Ensure that the Allow Notifications switch is on. Ensure that the alert style is set to Banners or Alerts. Optional: To enable audio alerts, set Sounds to on. Delete the Android or iOS device from your New Relic account. To delete the mobile device from your New Relic account, use the public graphql api api.newrelic.com/graphiql in a web browser: Query current devices by selecting actor -> mobilePushNotification -> devices and selecting appVersion, deviceId, and deviceName. Run this query to get the list of devices. Mutate to remove a device by selecting mutation -> mobilePushNotificationRemoveDevice, and passing in the deviceId from the list above. Or you can remove the device from the in-app Settings option from the menu -> Settings Look under Push notification devices, and remove from there. On iOS, slide from right to left to Delete a device, on Android, tap Delete Continue with the steps to reinstall the New Relic app from your device. Uninstall the New Relic mobile app. Follow the procedure to uninstall the New Relic app from your device, then reinstall it. Device To uninstall the New Relic app: Android From your Android device's Settings, select Apps, then select the New Relic app. Select Uninstall. Continue with the steps to reinstall the New Relic app. iOS From your iOS home screen, tap and hold the New Relic icon until it shakes. To delete the app, select the X icon. Continue with the steps to reinstall the New Relic app. Reinstall the New Relic mobile app. To reinstall the New Relic mobile app: From your Android device, select Google Play Store. OR From your iOS device's home screen, select App Store. Search for New Relic. Download the app. When the download finishes, sign in to your New Relic mobile app with your New Relic account.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 274.51367,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerting</em> with <em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "sections": "<em>Alerting</em> with <em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": " channel to the <em>alert</em> policy. View <em>alert</em> incident details The notification automatically appears on your device&#x27;s lock screen. To start the <em>New</em> <em>Relic</em> <em>app</em>: Android devices: Tap the notification from the notification drawer. OR iOS devices: Swipe the screen. From the <em>New</em> <em>Relic</em> <em>app</em>&#x27;s <em>Alerts</em> menu, select"
      },
      "id": "603e9efd64441f19a14e88ab"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-cordova-phonegap/get-started/introduction-new-relic-cordova": [
    {
      "sections": [
        "Introduction to New Relic",
        "Get started with New Relic",
        "All the answers in one place",
        "Bring all your data together",
        "Analyze your data",
        "Respond to incidents faster",
        "Troubleshoot from anywhere in your stack"
      ],
      "title": "Introduction to New Relic",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Welcome to New Relic",
        "Get started"
      ],
      "external_id": "f47a40a9afd699e69c351f5e87f64ed5dadd7e43",
      "image": "https://docs.newrelic.com/static/44970161aec793f3141cfcdc0fc96a57/c1b63/observability.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/intro-new-relic/",
      "published_at": "2021-12-31T01:18:23Z",
      "updated_at": "2021-12-31T01:18:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic is an observability platform that helps you build better software. You can bring in data from any digital source so that you can fully understand your system and how to improve it. This short video shows twenty of the most common ways to get your data into New Relic (approx. 5:22 minutes): With New Relic, you can: Bring all your data together: Instrument everything and import data from across your technology stack using our agents, integrations, and APIs, and access it from a single UI. Analyze your data: Get all your data at your fingertips to find the root causes of problems and optimize your systems. Build dashboards and charts or use our powerful query language. Respond to incidents quickly: Our machine learning solution proactively detects and explains anomalies and warns you before they become problems. Get started with New Relic Here's how you can quickly get started capturing and analyzing your data: If you don't have a New Relic account, sign up at newrelic.com/signup. It's free, forever! Follow the steps in our Add your data UI page to get data flowing in. For your first install, we recommend the Guided install option, which will set up many integrations with a single command. Once you have data coming into New Relic, learn more about the New Relic UI or set up Alerts. All the answers in one place New Relic is built for full stack observability. It links all relevant data so that you get the whole picture of everything that enables your systems to deliver value to your customers, from the container running a microservice in the cloud to a mobile website's shopping cart button. Monitoring vs. observability: New Relic provides answers to essential questions in one place. As just one example of what you can do with New Relic, imagine you are a Kubernetes administrator overseeing many clusters and pods of software containers. Where do you start troubleshooting? This short video shows how you can locate a problem cluster and use distributed tracing to find relevant logs: Bring all your data together Capture, organize, and make sense of your data in New Relic One, no matter where it comes from. Use our agents and integrations to automatically collect data from common frameworks and tools, or use our APIs for data that’s more specific to your business or technology. If you don't see your technologies or tasks listed here, see a larger list at New Relic Instant Observability. There you will find integrations bundled into quickstarts, providing you instant access to pre-built dashboards and alerts specific to your technology. If you want to... New Relic can help you... Instrument your application Instrument your code: Use our APM agents to automatically instrument your applications in C, Go, Java, .NET, Node.js, PHP, Python, and Ruby. Track transactions: Gather distributed tracing details as your transactions cross boundaries between apps and services. Instrument your environment Instrument your infrastructure: Observe your entire environment (including Linux, Windows, AWS, Azure, Google Cloud Platform, Kubernetes, Docker, and more). Collect and centralize logs: See your log data in context with your other application and infrastructure data. Save time switching between tools and reach solutions more quickly. Instrument your digital experiences Enhance browser performance: Decrease page load times, as well as triage and eliminate errors. Monitor mobile apps: Troubleshoot crashes and check the health of your Android and iOS apps with our mobile agents. Simulate user activity: Ensure you’re meeting customer expectations by running automated checks to monitor key user flows and experiences. Send data via APIs or build your own solution Collect data without an agent: Call our APIs directly if you prefer to use OpenTelemetry or other agents. Build your own integration: You can use our Flex tool, or one of language-specific SDKs for creating your own exporters to send data to New Relic. As a full platform user you get access to our entire set of observability tools in New Relic One: Application monitoring Browser monitoring Mobile monitoring Synthetic monitoring Serverless monitoring Infrastructure monitoring Log management You can start anywhere, but you'll never get lost. True observability across your entire stack means that you're in control. Analyze your data With your data secure at New Relic, our platform can alert you to problems and help you organize, process, and understand your data, whether it's metrics, events, logs, or traces: Explore your data visually: Jump into our data explorer to navigate all your data and make connections between your entities without any knowledge of query languages. Query and visualize your data: Use our curated dashboard visualizations or create your own. Use NRQL (New Relic Query Language) to slice and dice your data and dig deeper into questions. Query your data programmatically: Access your data through our NerdGraph GraphQL API. Easily prototype queries in our GraphiQL editor. Respond to incidents faster DevOps, site-reliability, and network operation teams need reliable, real-time alerts and anomaly detection to ensure their systems are always up and running efficiently. Let Applied Intelligence, our hybrid machine learning engine, automatically detect anomalies, reduce alert noise, and enrich incidents with context so that you can respond faster to incidents. Proactive detection: Be notified of unusual app behavior and get an analysis of this unusual behavior sent to Slack. Not using Slack? Set up a webhook to deliver messages when you need them. Get notifications: Set up alerts across your data sources and get notified when systems need your attention. Preserve your attention and control how many threshold violations should fire before you're notified. Troubleshoot from anywhere in your stack Being fully connected, the New Relic UI allows you to start your observability journey from any element of your stack. For example, you can get to crucial infrastructure logs from traces of an application running on a problematic Kubernetes pod. Use the Explorer in New Relic One to access and observe the full stack of your software, see performance data and alerting status at a glance, and check relationships. We provide you with a simple yet powerful visual tool to monitor all your entities, that is, anything we can identify that reports data. In the New Relic ecosystem, entities include basic components like applications, hosts, containers, or database services, but they can also refer to custom groupings of such elements. You can also create your own entities. The more entities you instrument, the more data you'll bring in. The more data you've brought to New Relic, the more you'll understand your metrics, events, logs, and traces.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.40213,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em>",
        "sections": "<em>Get</em> <em>started</em> with <em>New</em> <em>Relic</em>",
        "tags": "<em>Get</em> <em>started</em>",
        "body": "-specific SDKs for creating your own exporters to send data to <em>New</em> <em>Relic</em>. As a full platform user you <em>get</em> access to our entire set of observability tools in <em>New</em> <em>Relic</em> One: Application <em>monitoring</em> Browser <em>monitoring</em> <em>Mobile</em> <em>monitoring</em> Synthetic <em>monitoring</em> Serverless <em>monitoring</em> Infrastructure <em>monitoring</em> Log"
      },
      "id": "619d5b3e196a6705bda0837d"
    },
    {
      "sections": [
        "Get started with New Relic observability",
        "Get your data into New Relic with our quickstarts",
        "Some technical detail",
        "Guided install for New Relic",
        "All the answers in one place"
      ],
      "title": "Get started with New Relic observability",
      "type": "docs",
      "tags": [
        "Observe everything",
        "Get started"
      ],
      "external_id": "30f87d5f702f926efec49b59591679fa93627ad5",
      "image": "https://docs.newrelic.com/static/44970161aec793f3141cfcdc0fc96a57/c1b63/observability-2.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/get-started-full-stack-observability/",
      "published_at": "2021-12-31T01:18:16Z",
      "updated_at": "2021-12-31T01:18:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "True observability is the power of knowing what's happening across your digital system and why it's happening—at any time, whatever solution you’re using. It’s getting the whole picture of everything that enables your applications and devices to deliver value to your customers, from the container running a microservice in the cloud to a mobile website's shopping cart button. Our platform goes beyond simple monitoring by offering you observability: data insights to help you make proactive and predictive improvements to your environment. A comparison between simple monitoring and observability. Get your data into New Relic with our quickstarts New Relic I/O is a rich catalog of open-source quickstarts that automatically include integrations, dashboards, and alerts for you to use immediately. Popular technologies such as Node.js, Python, and Ruby have full-featured quickstarts, while others contain a mixture of tools. Each quickstart is created by observability experts around the world, vetted by New Relic, and ready for you to install with one click. Leverage community expertise and get more value out of your telemetry data with New Relic I/O, your hub for instant observability. Ready to get started? Find your quickstart in New Relic I/O: New Relic I/O New Relic I/O is open source, which means that you can modify and improve existing quickstarts, or build new ones, to suit your needs. We thoroughly review external edits to our quickstarts for value and quality. Interested in contributing to the community? Check out our contributor guide in GitHub. Some technical detail New Relic quickstarts use open source installation recipes to instrument integrations using our guided install process. Guided install for New Relic Alternatively, if you're comfortable with the command line, our guided install discovers the applications, infrastructure, and log sources running in your environment, and recommends which ones should be instrumented. The install automates the configuration and deployment of each system you choose to instrument. If your account reports data through our EU data center, click EU Guided install. Guided install EU Guided install All the answers in one place Once your data is in New Relic, we give you a UI with tools to cut through the layers of complexity surrounding your systems. This is all in one platform so you don't need to switch between diagnostic applications. You can interrogate your data for patterns, discover them using our data platform, or get proactive results from our machine learning tools. As a full platform user you get access to our entire set of observability tools. All our tools are interconnected and accessible in New Relic One. All the data you bring to New Relic through agents and integrations are metrics, events, logs, and traces that feed our platform's analytics and monitoring capabilities. New Relic links your data in a meaningful way so that you can explore it, build dashboards, and set up alerts. Our out-of-the-box observability UI experiences allow to visualize, analyze, and troubleshoot your entire software stack in one unified platform. The New Relic Explorer consolidates all the entities in your system, and how they're connected, in a single place, so you can easily detect performance trends and issues. By automatically connecting infrastructure health with application performance and end-user behavior, you can cut through the noise to find useful signals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.11049,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> <em>started</em> with <em>New</em> <em>Relic</em> observability",
        "sections": "<em>Get</em> <em>started</em> with <em>New</em> <em>Relic</em> observability",
        "tags": "<em>Get</em> <em>started</em>",
        "body": ". Ready to <em>get</em> <em>started</em>? Find your quickstart in <em>New</em> <em>Relic</em> I&#x2F;O: <em>New</em> <em>Relic</em> I&#x2F;O <em>New</em> <em>Relic</em> I&#x2F;O is open source, which means that you can modify and improve existing quickstarts, or build <em>new</em> ones, to suit your needs. We thoroughly review external edits to our quickstarts for value and quality. Interested"
      },
      "id": "61743c6764441f60375fd317"
    },
    {
      "sections": [
        "Introduction to mobile monitoring",
        "How we use mobile monitoring",
        "1. Alert notification shows new version crashes",
        "2. Crash analysis pinpoints exception, location, and more",
        "3. Problem solved, focus on improving app performance",
        "Improve frontend and backend performance",
        "Get started with mobile monitoring"
      ],
      "title": "Introduction to mobile monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile",
        "Get started"
      ],
      "external_id": "4e60f9568c1ffaf583f47bebfe1cecf5bde82a5b",
      "image": "https://docs.newrelic.com/static/3a1763e0e671b37ba517401ae6c5fb62/8c557/mobile-nrOne-summary072820.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile/get-started/introduction-mobile-monitoring/",
      "published_at": "2022-01-02T01:46:47Z",
      "updated_at": "2021-11-24T20:15:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring capabilities help you gain deeper visibility into how to analyze your Android and iOS application performance and troubleshoot crashes. You can also examine HTTP and other network performance for unexpected lag, which will in turn help you collaborate more efficiently with your backend teams. You'll be able to configure mobile monitoring to suit your environnment after you create a New Relic account (it's free, forever!) and install mobile monitoring for your Android, iOS, or Cordova environment. How we use mobile monitoring At New Relic, we have our own mobile developers who create iOS and Android apps so our customers can use New Relic from their mobile devices. During a feature deploy, we encountered a small bug that caused an edge case crash with our Android app. This happened after we had created, tested, and deployed the new feature. Because we work at New Relic, we also use New Relic One to analyze and troubleshoot our mobile apps. To give you an idea of how to explore the power of mobile monitoring, here's an example of how our own mobile engineers used it to track this small bug. A workflow to identify and resolve mobile app crashes using New Relic. 1. Alert notification shows new version crashes The night after a new release, our on-call developer received an alert notification on his mobile phone. The Alerts page indicated that some customers were seeing crashes on the new version of our Android app. Moving to his desktop browser, he checked the Summary page. The overview showed an increase in crashes for the newest version. By filtering for the latest version and setting the time picker to the past 24 hours, he could proceed with crash analysis. An example of using the mobile Summary page to filter to an Android version with crashes. 2. Crash analysis pinpoints exception, location, and more By clicking the Crashes chart title on the mobile Summary page, the Crash analysis page opened with the same 24-hour time frame and filter to this Android version. Here our developer could see a significant number of crashes for the selected version. This reinforced his suspicion there was bad code somewhere in the recent deployment. The developer clicked the link for the crash type to examine the exception, location, and error message. He also examined the stack trace, interaction trail, and event trail to quickly understand where users were impacted. An example of using the Crash analysis page to track down the cause for crashes for a new release by examining the exception, location, and error message. From here the developer saw the error. The new feature had a specific line of bad code that was crashing the app for customers who only used New Relic to monitor one app rather than multiple apps. The team released a hot fix in less than an hour, and the crash rate quickly de-escalated to 0.2%. 3. Problem solved, focus on improving app performance The problem was solved, but the team continues to use New Relic to make sure the most important workflows are running correctly and quickly. We also share HTTP and other network performance trends with our backend API developer teams. Improve frontend and backend performance More than a tool for crash analysis, our mobile monitoring capabilities can help you identify opportunities to speed app performance. For example, you can: Create dashboards to query, visualize, and share performance data. Identify handled exceptions to streamline workflows. See trends with sessions, devices, geographical locations, operating systems, carriers, requests and responses, etc. with crash profiles and HTTP profiles. Set up alert notifications for execution time, errors, etc. Define custom attributes and events to obtain additional, specific details about the mobile data that matters the most to your organization. And more! In addition to crash analysis, do more to fine-tune mobile app performance. Great mobile apps increasingly rely on backend systems to power their functionality, such as requesting product information, authenticating users, or streaming media content. But some backend issues can lead to upstream mobile app crashes, freezes, and broken functionality that impacts end users, including: Changed or non-versioned API endpoints Bad payloads API timeouts Slow or deprecated API endpoints You can use the network pages in our mobile monitoring UI to identify problems that surface through HTTP requests, errors, and other network issues. You can also query your data. Then create dashboards and share this information with backend API developer teams and others in your organization to help improve the overall end user experience with your mobile app. You can also improve your customers' overall digital experience: Get rapid visibility into how your end users experience your mobile apps and web browsers. Analyze actual or simulated end-user behavior to hone in on metrics like load time, availability, and errors, while staying grounded in the backend services that enable these digital experiences. Get started with mobile monitoring Before you install and configure New Relic's functionality for your mobile applications, follow these guidelines for compatibility and other requirements: Android compatibility and requirements iOS compatibility and requirements Then continue with the installation and configuration procedures for your Android, iOS, tvOS, or Cordova application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 87.28639,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>mobile</em> <em>monitoring</em>",
        "sections": "<em>Get</em> <em>started</em> with <em>mobile</em> <em>monitoring</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": " with your backend teams. You&#x27;ll be able to configure <em>mobile</em> <em>monitoring</em> to suit your environnment after you create a <em>New</em> <em>Relic</em> account (it&#x27;s free, forever!) and install <em>mobile</em> <em>monitoring</em> for your Android, iOS, or <em>Cordova</em> environment. How we use <em>mobile</em> <em>monitoring</em> At <em>New</em> <em>Relic</em>, we have our own <em>mobile</em>"
      },
      "id": "603eb1c4e7b9d217802a07a7"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project": [
    {
      "sections": [
        "iOS agent configuration and feature flags",
        "Enable or disable feature flags",
        "Crash and error reporting feature flag",
        "NRFeatureFlag_CrashReporting",
        "NRFeatureFlag_HandledExceptionEvents",
        "Distributed tracing",
        "NRFeatureFlag_DistributedTracing",
        "Interactions feature flags",
        "NRFeatureFlag_DefaultInteractions",
        "NRFeatureFlag_InteractionTracing",
        "NRFeatureFlag_SwiftInteractionTracing",
        "Caution",
        "Networking feature flags",
        "NRFeatureFlag_ExperimentalNetworkingInstrumentation",
        "NRFeatureFlag_NSURLSessionInstrumentation",
        "NRFeatureFlag_NetworkRequestEvents",
        "NRFeatureFlag_RequestErrorEvents",
        "NRFeatureFlag_HttpResponseBodyCapture"
      ],
      "title": "iOS agent configuration and feature flags",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "538f198af51ca5659916c98e634f1142ec387bca",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/ios-agent-configuration-feature-flags/",
      "published_at": "2021-12-30T07:47:01Z",
      "updated_at": "2021-11-05T14:19:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's iOS agent provides configuration settings to change the default behavior of the agent. If used, implement these flags just before calling: Objective-C: +[NewRelic startWithApplicationToken:] Swift: NewRelic.start(withApplicationToken:) Enable or disable feature flags To configure feature flags, use the following method defined in NewRelic.h: iOS language Procedure Objective-C In Objective-C, these features are bitmasked, so you can use a | to enable or disable multiple features at the same time. Enable a feature flag: +[NewRelic enableFeatures:(NRMAFeatureFlags)flags]; Copy Disable a feature flag: +[NewRelic disableFeatures:(NRMAFeatureFlags)flags]; Copy Here is an example where: Interaction tracing and experimental networking instrumentation are enabled. NSURLSession instrumentation and crash reporting are disabled. [NewRelic enableFeatures:NRFeatureFlag_SwiftInteractionTracing | NRFeatureFlag_ExperimentalNetworkingInstrumentation]; [NewRelic disableFeatures:NRFeatureFlag_NSURLSessionInstrumentation | NRFeatureFlag_CrashReporting]; [NewRelic startWithApplicationToken:...]; Copy Swift Enable a feature flag: NewRelic.enableFeatures(NRMAFeatureFlags.[NRMAFeatureFlag]) Copy Disable a feature flag: NewRelic.disableFeatures(NRMAFeatureFlags.[NRMAFeatureFlag]) Copy Example to disable interaction tracing: NewRelic.disableFeatures(NRMAFeatureFlags.NRFeatureFlag_DefaultInteractions) Copy Crash and error reporting feature flag If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_CrashReporting Enable (default) or disable crash reporting, which appears on the Crash analysis page. Type Boolean Default true NRFeatureFlag_HandledExceptionEvents Globally enable (default) or disable recording handled exceptions events, which appear on the Handled exception page. Type Boolean Default true Distributed tracing NRFeatureFlag_DistributedTracing Enable or disable the adding of distributed tracing headers to network requests. Refer to How New Relic distributed tracing works for more information on distributed tracing in mobile apps. Type Boolean Default true Interactions feature flags If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_DefaultInteractions Enable (default) or disable interaction tracing only for default instrumented classes and methods. Custom interactions will be reported. The traces will appear on the Interactions page. Type Boolean Default true NRFeatureFlag_InteractionTracing Globally enable (default) or disable interaction traces, which appear on the Interactions page. Interaction tracing will be disabled after the agent has started. Interactions for any activity or methods executed prior to starting the agent may still appear on the Interactions page. Type Boolean Default true NRFeatureFlag_SwiftInteractionTracing Caution Before enabling this feature, see Enable Swift interaction traces. If proper steps are not taken, enabling this feature may cause instability. Enable or disable (default) interaction tracing for Swift code. The traces appear on the Interactions page. This feature will always be disabled if NRFeatureFlag_InteractionTracing is disabled. Type Boolean Default false Networking feature flags If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_ExperimentalNetworkingInstrumentation Caution Enabling this feature flag call may decrease the stability of applications. Avoid using unless instructed by New Relic. Enable or disable (default) experimental networking instrumentation. This forces all NSURLConnection network requests through the NRMAURProtocol. Type Boolean Default false NRFeatureFlag_NSURLSessionInstrumentation Enable (default) or disable networking instrumentation for NSURLSession. These URL traces are sent to the HTTP Requests page. Type Boolean Default true NRFeatureFlag_NetworkRequestEvents Enable or disable (default) networking instrumentation. This sends the HTTP response data as MobileRequest events. Available for iOS Agent version 5.14.0 and higher Type Boolean Default true - Enabled by default as of 6.0.0 NRFeatureFlag_RequestErrorEvents Enable (default) or disable HTTP request error event generation of instrumented network calls that result in an error or failure. These events are reported as MobileRequestError events. Available for iOS Agent version 5.11.0 and higher Type Boolean Default true NRFeatureFlag_HttpResponseBodyCapture Enable or disable capture of HTTP response bodies for HTTP error traces, and MobileRequestError events. Type Boolean Default true",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.28207,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> agent <em>configuration</em> and feature flags",
        "sections": "<em>iOS</em> agent <em>configuration</em> and feature flags",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> agent provides <em>configuration</em> settings to change the default behavior of the agent. If used, implement these flags just before calling: Objective-C: +[<em>NewRelic</em> startWithApplicationToken:] Swift: <em>NewRelic</em>.start(withApplicationToken:) Enable or disable feature flags To configure"
      },
      "id": "619eaa7e28ccbc1559b9b002"
    },
    {
      "sections": [
        "Upload dSYM files",
        "Automatic script",
        "Identify missing dSYMs",
        "Upload dSYM files through the mobile monitoring UI",
        "Manually upload dSYM files",
        "Via Python script (agent versions 6.0.0 or higher)",
        "Via command line",
        "Troubleshooting",
        "Auto-upload failure",
        "Missing dSYMs"
      ],
      "title": "Upload dSYM files",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "3655f49cf0e1ae693de0f8ea45bf4e5e6437e399",
      "image": "https://docs.newrelic.com/static/5c859575f391fbb1eaa18243a8c97000/8c557/Screen-Shot-2014-09-23-at-11.30.35-AM_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/upload-dsyms-bitcode-apps/",
      "published_at": "2021-12-30T02:14:03Z",
      "updated_at": "2021-09-27T15:06:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your app's dSYM files are stored in Xcode's dSYM archive path folder. This is the folder where the iOS agent gets the dSYM files that are used to symbolicate your crash reports. New Relic provides a post-build script as part of the iOS agent's install process and the tvOS agent's install process. This script automatically uploads your app's dSYM files. Automatic script The script automatically uploads dSYM files only for release builds. Non-release builds must upload their files either manually or through the mobile monitoring UI. Bitcode-enabled apps have their dSYM files generated by Apple. You must download the dSYM files for Bitcode-enabled apps from Apple and upload them to New Relic. If you see unreadable machine code in the Crashes page, your dSYM files may not be uploaded correctly. In some cases, you may need to manually upload dSYM files. The automatic script uses Python 2. As of October 2019 with macOS 10.15 (Catalina), Python won't be installed by default. If you're using the automatic script (recommended), you may need to manually install Python 2. If you're using Homebrew, see Python on Homebrew. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: From the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Upload dSYM files through the mobile monitoring UI You can easily upload your dSYM files directly from the New Relic One UI. The maximum file size is 600 MB. To upload your dSYM files: Go to one.newrelic.com and click Mobile. Then select your app from the list. View Crash analysis. Select a specific crash from the Crash types list. Click Upload dSYM. You can either drag and drop your dSYMs directly, or select the file form your computer. Manually upload dSYM files In some circumstances, New Relic's automatic upload of dSYM files may fail. If a dSYM upload is attempted and fails, it creates a build error with a detailed message. For example, if there's a network failure and the dSYM upload isn't completed, Xcode will report an error. For additional information about how New Relic handles dSYM uploads, see New Relic's Online Technical Community. If the automatic upload fails, you can manually upload your dSYM file. If you have multiple dSYM files, they can be within a single zip with a maximum file size of 600 MB. The YOUR_NEW_RELIC_APPLICATION_TOKEN value in the commands below is the same key used for +[NewRelic startWithApplicationToken:] (in Objective-C) or NewRelic.start(withApplicationToken:) (in Swift). To manually upload your dSYM files: Via Python script (agent versions 6.0.0 or higher) In iOS agent versions 6.0.0 or higher, the agent includes a Python script that automatically processes and uploads symbols. You can call this script from the command line: NewRelicAgent.framework/Resources/generateMap.py \"DSYM_ARCHIVE_PATH\" \"YOUR_NEW_RELIC_APPLICATION_TOKEN\" Copy Via command line To manually upload individual dSYM files from the command line: Zip up your dSYM file or files using the following command. Replace ~ /ZIPPED_DSYM_PATH with your new dSYM archive path and file name (for example, Users/my-name/desktop). Also replace ~ /dSYM_PATH with your existing dSYM file path. /usr/bin/zip --recurse-paths --quiet \"~/ZIPPED_DSYM_PATH\" \"~/dSYM_PATH\" Copy Upload the dSYM zip file using the following command: For US accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.newrelic.com/symbol Copy For EU accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.eu01.nr-data.net/symbol Copy Troubleshooting Auto-upload failure If a dSYM auto-upload failed, the Report Navigator may have a fully formed cURL command. You can use this cURL command to reattempt an upload. Depending on the error, you may also need to follow some of the dSYM manual upload steps. Here is an example of a successful dSYM upload in the Report Navigator: Example: A successful dSYM upload in the Report Navigator. Missing dSYMs If dSYM files are missing, you may need to check Xcode build settings to ensure the file is being generated. Frameworks which are built locally have separate build settings and may need to be updated as well. Build settings: Debug Information Format : Dwarf with dSYM File Deployment Postprocessing: Yes Strip Linked Product: Yes Strip Debug Symbols During Copy : Yes Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.73927,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Upload dSYM files through the <em>mobile</em> <em>monitoring</em> UI",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Your app&#x27;s dSYM files are stored in Xcode&#x27;s dSYM archive path folder. This is the folder where the <em>iOS</em> agent gets the dSYM files that are used to symbolicate your crash reports. <em>New</em> <em>Relic</em> provides a post-build script as part of the <em>iOS</em> agent&#x27;s install process and the tv<em>OS</em> agent&#x27;s install process"
      },
      "id": "60441960e7b9d24f705799ca"
    },
    {
      "sections": [
        "iOS agent compatibility and requirements",
        "Foreground monitoring",
        "iOS requirements",
        "Testing is not supported",
        "Potential method replacement conflicts"
      ],
      "title": "iOS agent compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "544e062fdc57c4545c2f36b54b38f95b30b3c25e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/new-relic-ios-compatibility-requirements/",
      "published_at": "2021-12-30T11:17:44Z",
      "updated_at": "2021-12-19T19:52:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install and configure the iOS agent, follow these guidelines for compatibility and other requirements. Foreground monitoring The iOS agent only monitors your app while it is in the foreground. The agent does not monitor background services while the app is closed. For more information, see our Mobile data privacy and security documentation. iOS requirements Make sure your iOS app meets these requirements: Component iOS application requirements Operating system iOS 9 or higher For Bitcode support, use SDK version 5.3.0 or higher. API/SDK NSURLConnection and AFNetworking are supported. NSURLSession supports upload and data tags only. ASIHttpRequest networking APIs are deprecated as of iOS agent version 5.8.2. Network traffic for UIWebView and WKWebView is supported. However, WKWebView Transfer size and Http errors are not supported. Languages Objective-C Swift: Works with both network traces and crash reporting, but no interaction traces by default. Interaction traces must be enabled for Swift. Devices Any iOS compatible device: iPhones, iPads, etc. File sizes The agent adds about 2 to 12 megabytes to your iOS release app, depending on platform build. Architectures ARM 64-bit. SHA-2 As a standard security measure for data collection, New Relic requires that your application server supports SHA-2 (256-bit). SHA-1 is not supported. Xcode To take advantage of New Relic's iOS features, make sure you have the latest version of Xcode. arm64e support To be able to properly symbolicate crashes from devices with arm64e architectures, make sure your Xcode settings are enabled for pointer authentication. For more information, see the Apple developer documentation. CocoaPods In order to use the latest XCFramework Agent, use CocoaPods version 1.10.1 or higher. Testing is not supported Our agents are designed and tested to work in a normal app lifecycle. New Relic does not support running any testing environment on applications with the agent. Testing can cause conflicts and unpredictable behavior. Potential method replacement conflicts Our iOS agent utilizes method replacement during run time. This may result in a conflict with other libraries that also implement method replacement, such as ReactiveCocoa, Firebase, Aspects, and AppleGuice.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.6204,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> agent compatibility and requirements",
        "sections": "<em>iOS</em> agent compatibility and requirements",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Before you install and configure the <em>iOS</em> agent, follow these guidelines for compatibility and other requirements. Foreground <em>monitoring</em> The <em>iOS</em> agent only monitors your app while it is in the foreground. The agent does not <em>monitor</em> background services while the app is closed. For more information"
      },
      "id": "6044196064441f4f10378f04"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/configuration/enable-swift-interaction-traces": [
    {
      "sections": [
        "iOS agent configuration and feature flags",
        "Enable or disable feature flags",
        "Crash and error reporting feature flag",
        "NRFeatureFlag_CrashReporting",
        "NRFeatureFlag_HandledExceptionEvents",
        "Distributed tracing",
        "NRFeatureFlag_DistributedTracing",
        "Interactions feature flags",
        "NRFeatureFlag_DefaultInteractions",
        "NRFeatureFlag_InteractionTracing",
        "NRFeatureFlag_SwiftInteractionTracing",
        "Caution",
        "Networking feature flags",
        "NRFeatureFlag_ExperimentalNetworkingInstrumentation",
        "NRFeatureFlag_NSURLSessionInstrumentation",
        "NRFeatureFlag_NetworkRequestEvents",
        "NRFeatureFlag_RequestErrorEvents",
        "NRFeatureFlag_HttpResponseBodyCapture"
      ],
      "title": "iOS agent configuration and feature flags",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "538f198af51ca5659916c98e634f1142ec387bca",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/ios-agent-configuration-feature-flags/",
      "published_at": "2021-12-30T07:47:01Z",
      "updated_at": "2021-11-05T14:19:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's iOS agent provides configuration settings to change the default behavior of the agent. If used, implement these flags just before calling: Objective-C: +[NewRelic startWithApplicationToken:] Swift: NewRelic.start(withApplicationToken:) Enable or disable feature flags To configure feature flags, use the following method defined in NewRelic.h: iOS language Procedure Objective-C In Objective-C, these features are bitmasked, so you can use a | to enable or disable multiple features at the same time. Enable a feature flag: +[NewRelic enableFeatures:(NRMAFeatureFlags)flags]; Copy Disable a feature flag: +[NewRelic disableFeatures:(NRMAFeatureFlags)flags]; Copy Here is an example where: Interaction tracing and experimental networking instrumentation are enabled. NSURLSession instrumentation and crash reporting are disabled. [NewRelic enableFeatures:NRFeatureFlag_SwiftInteractionTracing | NRFeatureFlag_ExperimentalNetworkingInstrumentation]; [NewRelic disableFeatures:NRFeatureFlag_NSURLSessionInstrumentation | NRFeatureFlag_CrashReporting]; [NewRelic startWithApplicationToken:...]; Copy Swift Enable a feature flag: NewRelic.enableFeatures(NRMAFeatureFlags.[NRMAFeatureFlag]) Copy Disable a feature flag: NewRelic.disableFeatures(NRMAFeatureFlags.[NRMAFeatureFlag]) Copy Example to disable interaction tracing: NewRelic.disableFeatures(NRMAFeatureFlags.NRFeatureFlag_DefaultInteractions) Copy Crash and error reporting feature flag If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_CrashReporting Enable (default) or disable crash reporting, which appears on the Crash analysis page. Type Boolean Default true NRFeatureFlag_HandledExceptionEvents Globally enable (default) or disable recording handled exceptions events, which appear on the Handled exception page. Type Boolean Default true Distributed tracing NRFeatureFlag_DistributedTracing Enable or disable the adding of distributed tracing headers to network requests. Refer to How New Relic distributed tracing works for more information on distributed tracing in mobile apps. Type Boolean Default true Interactions feature flags If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_DefaultInteractions Enable (default) or disable interaction tracing only for default instrumented classes and methods. Custom interactions will be reported. The traces will appear on the Interactions page. Type Boolean Default true NRFeatureFlag_InteractionTracing Globally enable (default) or disable interaction traces, which appear on the Interactions page. Interaction tracing will be disabled after the agent has started. Interactions for any activity or methods executed prior to starting the agent may still appear on the Interactions page. Type Boolean Default true NRFeatureFlag_SwiftInteractionTracing Caution Before enabling this feature, see Enable Swift interaction traces. If proper steps are not taken, enabling this feature may cause instability. Enable or disable (default) interaction tracing for Swift code. The traces appear on the Interactions page. This feature will always be disabled if NRFeatureFlag_InteractionTracing is disabled. Type Boolean Default false Networking feature flags If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_ExperimentalNetworkingInstrumentation Caution Enabling this feature flag call may decrease the stability of applications. Avoid using unless instructed by New Relic. Enable or disable (default) experimental networking instrumentation. This forces all NSURLConnection network requests through the NRMAURProtocol. Type Boolean Default false NRFeatureFlag_NSURLSessionInstrumentation Enable (default) or disable networking instrumentation for NSURLSession. These URL traces are sent to the HTTP Requests page. Type Boolean Default true NRFeatureFlag_NetworkRequestEvents Enable or disable (default) networking instrumentation. This sends the HTTP response data as MobileRequest events. Available for iOS Agent version 5.14.0 and higher Type Boolean Default true - Enabled by default as of 6.0.0 NRFeatureFlag_RequestErrorEvents Enable (default) or disable HTTP request error event generation of instrumented network calls that result in an error or failure. These events are reported as MobileRequestError events. Available for iOS Agent version 5.11.0 and higher Type Boolean Default true NRFeatureFlag_HttpResponseBodyCapture Enable or disable capture of HTTP response bodies for HTTP error traces, and MobileRequestError events. Type Boolean Default true",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.28207,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> agent <em>configuration</em> and feature flags",
        "sections": "<em>iOS</em> agent <em>configuration</em> and feature flags",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> agent provides <em>configuration</em> settings to change the default behavior of the agent. If used, implement these flags just before calling: Objective-C: +[<em>NewRelic</em> startWithApplicationToken:] Swift: <em>NewRelic</em>.start(withApplicationToken:) Enable or disable feature flags To configure"
      },
      "id": "619eaa7e28ccbc1559b9b002"
    },
    {
      "sections": [
        "Upload dSYM files",
        "Automatic script",
        "Identify missing dSYMs",
        "Upload dSYM files through the mobile monitoring UI",
        "Manually upload dSYM files",
        "Via Python script (agent versions 6.0.0 or higher)",
        "Via command line",
        "Troubleshooting",
        "Auto-upload failure",
        "Missing dSYMs"
      ],
      "title": "Upload dSYM files",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "3655f49cf0e1ae693de0f8ea45bf4e5e6437e399",
      "image": "https://docs.newrelic.com/static/5c859575f391fbb1eaa18243a8c97000/8c557/Screen-Shot-2014-09-23-at-11.30.35-AM_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/upload-dsyms-bitcode-apps/",
      "published_at": "2021-12-30T02:14:03Z",
      "updated_at": "2021-09-27T15:06:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your app's dSYM files are stored in Xcode's dSYM archive path folder. This is the folder where the iOS agent gets the dSYM files that are used to symbolicate your crash reports. New Relic provides a post-build script as part of the iOS agent's install process and the tvOS agent's install process. This script automatically uploads your app's dSYM files. Automatic script The script automatically uploads dSYM files only for release builds. Non-release builds must upload their files either manually or through the mobile monitoring UI. Bitcode-enabled apps have their dSYM files generated by Apple. You must download the dSYM files for Bitcode-enabled apps from Apple and upload them to New Relic. If you see unreadable machine code in the Crashes page, your dSYM files may not be uploaded correctly. In some cases, you may need to manually upload dSYM files. The automatic script uses Python 2. As of October 2019 with macOS 10.15 (Catalina), Python won't be installed by default. If you're using the automatic script (recommended), you may need to manually install Python 2. If you're using Homebrew, see Python on Homebrew. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: From the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Upload dSYM files through the mobile monitoring UI You can easily upload your dSYM files directly from the New Relic One UI. The maximum file size is 600 MB. To upload your dSYM files: Go to one.newrelic.com and click Mobile. Then select your app from the list. View Crash analysis. Select a specific crash from the Crash types list. Click Upload dSYM. You can either drag and drop your dSYMs directly, or select the file form your computer. Manually upload dSYM files In some circumstances, New Relic's automatic upload of dSYM files may fail. If a dSYM upload is attempted and fails, it creates a build error with a detailed message. For example, if there's a network failure and the dSYM upload isn't completed, Xcode will report an error. For additional information about how New Relic handles dSYM uploads, see New Relic's Online Technical Community. If the automatic upload fails, you can manually upload your dSYM file. If you have multiple dSYM files, they can be within a single zip with a maximum file size of 600 MB. The YOUR_NEW_RELIC_APPLICATION_TOKEN value in the commands below is the same key used for +[NewRelic startWithApplicationToken:] (in Objective-C) or NewRelic.start(withApplicationToken:) (in Swift). To manually upload your dSYM files: Via Python script (agent versions 6.0.0 or higher) In iOS agent versions 6.0.0 or higher, the agent includes a Python script that automatically processes and uploads symbols. You can call this script from the command line: NewRelicAgent.framework/Resources/generateMap.py \"DSYM_ARCHIVE_PATH\" \"YOUR_NEW_RELIC_APPLICATION_TOKEN\" Copy Via command line To manually upload individual dSYM files from the command line: Zip up your dSYM file or files using the following command. Replace ~ /ZIPPED_DSYM_PATH with your new dSYM archive path and file name (for example, Users/my-name/desktop). Also replace ~ /dSYM_PATH with your existing dSYM file path. /usr/bin/zip --recurse-paths --quiet \"~/ZIPPED_DSYM_PATH\" \"~/dSYM_PATH\" Copy Upload the dSYM zip file using the following command: For US accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.newrelic.com/symbol Copy For EU accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.eu01.nr-data.net/symbol Copy Troubleshooting Auto-upload failure If a dSYM auto-upload failed, the Report Navigator may have a fully formed cURL command. You can use this cURL command to reattempt an upload. Depending on the error, you may also need to follow some of the dSYM manual upload steps. Here is an example of a successful dSYM upload in the Report Navigator: Example: A successful dSYM upload in the Report Navigator. Missing dSYMs If dSYM files are missing, you may need to check Xcode build settings to ensure the file is being generated. Frameworks which are built locally have separate build settings and may need to be updated as well. Build settings: Debug Information Format : Dwarf with dSYM File Deployment Postprocessing: Yes Strip Linked Product: Yes Strip Debug Symbols During Copy : Yes Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.73927,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Upload dSYM files through the <em>mobile</em> <em>monitoring</em> UI",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Your app&#x27;s dSYM files are stored in Xcode&#x27;s dSYM archive path folder. This is the folder where the <em>iOS</em> agent gets the dSYM files that are used to symbolicate your crash reports. <em>New</em> <em>Relic</em> provides a post-build script as part of the <em>iOS</em> agent&#x27;s install process and the tv<em>OS</em> agent&#x27;s install process"
      },
      "id": "60441960e7b9d24f705799ca"
    },
    {
      "sections": [
        "iOS agent compatibility and requirements",
        "Foreground monitoring",
        "iOS requirements",
        "Testing is not supported",
        "Potential method replacement conflicts"
      ],
      "title": "iOS agent compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "544e062fdc57c4545c2f36b54b38f95b30b3c25e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/new-relic-ios-compatibility-requirements/",
      "published_at": "2021-12-30T11:17:44Z",
      "updated_at": "2021-12-19T19:52:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install and configure the iOS agent, follow these guidelines for compatibility and other requirements. Foreground monitoring The iOS agent only monitors your app while it is in the foreground. The agent does not monitor background services while the app is closed. For more information, see our Mobile data privacy and security documentation. iOS requirements Make sure your iOS app meets these requirements: Component iOS application requirements Operating system iOS 9 or higher For Bitcode support, use SDK version 5.3.0 or higher. API/SDK NSURLConnection and AFNetworking are supported. NSURLSession supports upload and data tags only. ASIHttpRequest networking APIs are deprecated as of iOS agent version 5.8.2. Network traffic for UIWebView and WKWebView is supported. However, WKWebView Transfer size and Http errors are not supported. Languages Objective-C Swift: Works with both network traces and crash reporting, but no interaction traces by default. Interaction traces must be enabled for Swift. Devices Any iOS compatible device: iPhones, iPads, etc. File sizes The agent adds about 2 to 12 megabytes to your iOS release app, depending on platform build. Architectures ARM 64-bit. SHA-2 As a standard security measure for data collection, New Relic requires that your application server supports SHA-2 (256-bit). SHA-1 is not supported. Xcode To take advantage of New Relic's iOS features, make sure you have the latest version of Xcode. arm64e support To be able to properly symbolicate crashes from devices with arm64e architectures, make sure your Xcode settings are enabled for pointer authentication. For more information, see the Apple developer documentation. CocoaPods In order to use the latest XCFramework Agent, use CocoaPods version 1.10.1 or higher. Testing is not supported Our agents are designed and tested to work in a normal app lifecycle. New Relic does not support running any testing environment on applications with the agent. Testing can cause conflicts and unpredictable behavior. Potential method replacement conflicts Our iOS agent utilizes method replacement during run time. This may result in a conflict with other libraries that also implement method replacement, such as ReactiveCocoa, Firebase, Aspects, and AppleGuice.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.6204,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> agent compatibility and requirements",
        "sections": "<em>iOS</em> agent compatibility and requirements",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Before you install and configure the <em>iOS</em> agent, follow these guidelines for compatibility and other requirements. Foreground <em>monitoring</em> The <em>iOS</em> agent only monitors your app while it is in the foreground. The agent does not <em>monitor</em> background services while the app is closed. For more information"
      },
      "id": "6044196064441f4f10378f04"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/configuration/ios-device-id-obfuscation": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/attribute-dictionary/",
      "sections": [
        "New Relic data dictionary",
        "AjaxRequest",
        "AwsLambdaInvocation",
        "AwsLambdaInvocationError",
        "BrowserInteraction",
        "BrowserTiming",
        "ContainerSample",
        "DistributedTraceSummary",
        "InfrastructureEvent",
        "JavaScriptError",
        "Metric",
        "Mobile",
        "MobileCrash",
        "MobileHandledException",
        "MobileRequest",
        "MobileRequestError",
        "MobileSession",
        "NetworkSample",
        "NrAiIncident",
        "NrAuditEvent",
        "NrConsumption",
        "NrDailyUsage",
        "NrIntegrationError",
        "NrMTDConsumption",
        "NrUsage",
        "PageAction",
        "PageView",
        "PageViewTiming",
        "ProcessSample",
        "Span",
        "StorageSample",
        "SyntheticCheck",
        "SyntheticRequest",
        "SyntheticsPrivateLocationStatus",
        "SyntheticsPrivateMinion",
        "SystemSample",
        "Transaction",
        "TransactionError",
        "WorkloadStatus"
      ],
      "published_at": "2022-01-02T01:46:43Z",
      "title": "New Relic data dictionary",
      "updated_at": "2022-01-01T01:43:39Z",
      "type": "docs",
      "external_id": "cbca3a897621bcbb31159067d6d4ec27c5178fe4",
      "document_type": "views_page_content",
      "popularity": 1,
      "body": "AjaxRequest Data source : Browser agent An AjaxRequest event is created automatically when an Ajax request occurs during a BrowserInteraction event. The event attributes track geographic and browser info. Attribute name Definition Data types actionText The text of the HTML element that was clicked when a browser interaction started. Added to BrowserInteraction and any AjaxRequest, JavaScriptError and BrowserTiming events that occurred during that interaction. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError appId ID The ID of your application, as recorded by New Relic. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserInteractionName The name of the interaction. This is either the targetGroupedUrl or the custom name set via the API. AjaxRequest BrowserInteraction BrowserTiming city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView eventId ID A value that you can link to multiple BrowserInteraction events so you can view the interactions that occurred surrounding a specific event. For example, you can see the browser interactions that occurred prior to a JS error. AjaxRequest BrowserInteraction BrowserTiming groupedPageURL The grouped URL of the view that made the AJAX request. For example: myapp.com/acct/*/dash. AjaxRequest BrowserTiming groupedRequestUrl The grouped URL of the AJAX request. For example: myapp.com/acct/*/ajax. AjaxRequest Span hostname The fully qualified domain name (FQDN) of the request URL. AjaxRequest httpMethod enum The HTTP method of the AJAX request. Example: POST. AjaxRequest httpResponseCode enum The HTTP response code. Example: 200. AjaxRequest jsDuration seconds (s) The total duration, in seconds, spent on JavaScript execution. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. This attribute doesn't exist for initial page load events. AjaxRequest BrowserInteraction BrowserTiming pageUrl The URL of the page that was loaded for the PageView. For example: http://www.newrelic.com. This URL does not include query parameters. AjaxRequest BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError port enum The request port. AjaxRequest Span priority Likelihood this event will be saved. AjaxRequest regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming requestBodySize bytes (B) The payload size of the request body, in bytes. AjaxRequest requestUrl The URL of the AJAX request. For example: myapp.com/acct/1/ajax. AjaxRequest responseBodySize bytes (B) The payload size of the response body, in bytes. AjaxRequest session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span timeSinceBrowserInteractionStart seconds (s) The time in seconds between the start of the BrowserInteraction and the start of the request. AjaxRequest BrowserTiming timeToLastCallbackEnd seconds (s) The duration, in seconds, from the start of the request (timestamp) to the end of the last callback. This is not just an additive function; the callback time can overlap with the wait time. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserInteraction BrowserTiming timeToLoadEventStart seconds (s) The time, in seconds, from the start of the AJAX request to the start of its load event. This value represents the duration of the AJAX request with single page app (SPA) monitoring. For more information, see the Mozilla developer documentation about XMLHttpRequest load events. AjaxRequest timeToSettle seconds (s) The time, in seconds, from the start of the request to when all resulting callbacks (including callbacks of subsequent AJAX requests) are complete. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserTiming timestamp The time (date, hour, minute, second) at which the interaction occurred. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming Span userAgentName The browser’s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browser’s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browser’s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming AwsLambdaInvocation Data source : AWS Lambda This event is reported by New Relic monitoring for AWS Lambda. This event captures overall function timing and associated metadata. A single AwsLambdaInvocation event is generated for each invocation. Attribute name Definition Data types aws.lambda.arn The Amazon Resource Name (ARN) of the instrumented Lambda function. AwsLambdaInvocationError AwsLambdaInvocation aws.lambda.coldStart A Boolean indicating if the AWS Lambda invocation is a cold start. AwsLambdaInvocationError AwsLambdaInvocation aws.lambda.eventSource.arn The Amazon Resource Name (ARN) of the entity that invoked the instrumented Lambda function. AwsLambdaInvocationError AwsLambdaInvocation aws.requestId ID AWS identifier of the invocation. AwsLambdaInvocationError AwsLambdaInvocation databaseCallCount count The number of database calls made by this transaction. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError databaseDuration seconds (s) The database response time in seconds. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError duration seconds (s) The total invocation time for the transaction, in seconds. (Data source: AWS Lambda) AwsLambdaInvocationError AwsLambdaInvocation externalCallCount count The number of external calls made by this transaction. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError externalDuration seconds (s) The total response time of all external (out-of-process) services, in seconds. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError newRelic.ingestPoint Where the data point entered the platform (such as browser.spans, or api.traces). AwsLambdaInvocationError AwsLambdaInvocation Span parent.account ID If a distributed tracing payload is received, this is the account identifier for the transaction's upstream caller. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError parent.app ID If a distributed tracing payload is received, this is the application identifier. APM agents retrieve this value in the connect response under the key primary_application_id. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError parent.transportType When a distributed tracing payload is received, the method of transport for the payload. Example values: Unknown, HTTP, HTTPS, Kafka, JMS, IronMQ, AMQP, Queue, or Other. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError parent.type If a distributed trace payload was received, the parent's data source type. Example values: App, Browser, Mobile. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.accept The types as read from the HTTP Accept request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.contentLength bytes (B) Incoming request size in bytes as read from the Content-Length HTTP request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.contentType Incoming request content-type as read from the HTTP request header Content-Type. Example value: application/octet-stream. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.host The name from the HTTP host request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.referer The incoming request referer as read from the Referer request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.userAgent The contents of the User-Agent HTTP header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.method The HTTP request method used. Example values: POST, GET. AwsLambdaInvocationError AwsLambdaInvocation Span Transaction TransactionError response.headers.contentLength bytes (B) The outgoing response size in bytes as read from the Content-Length response header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError response.headers.contentType For an HTTP response, the data type of the returned response. Example values: text/html, application/json. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError response.status bytes (B) The response code for an HTTP request AwsLambdaInvocation totalTime seconds (s) The sum of all async components' duration, in seconds. An async component is a method or function where there is no instrumented encapsulating method or function. AwsLambdaInvocation Transaction traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocationError AwsLambdaInvocation MobileRequest MobileRequestError Span type The New Relic event type. Example values: Transaction, Span. AwsLambdaInvocationError AwsLambdaInvocation AwsLambdaInvocationError Data source : AWS Lambda This event is reported by New Relic monitoring for AWS Lambda. It's generated when an error occurs during a Lambda function invocation. Attribute name Definition Data types aws.lambda.arn The Amazon Resource Name (ARN) of the instrumented Lambda function. AwsLambdaInvocationError AwsLambdaInvocation aws.lambda.coldStart A Boolean indicating if the AWS Lambda invocation is a cold start. AwsLambdaInvocationError AwsLambdaInvocation aws.lambda.eventSource.arn The Amazon Resource Name (ARN) of the entity that invoked the instrumented Lambda function. AwsLambdaInvocationError AwsLambdaInvocation aws.requestId ID AWS identifier of the invocation. AwsLambdaInvocationError AwsLambdaInvocation databaseCallCount count The number of database calls made by this transaction. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError databaseDuration seconds (s) The database response time in seconds. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError duration seconds (s) The total invocation time for the transaction, in seconds. (Data source: AWS Lambda) AwsLambdaInvocationError AwsLambdaInvocation error.class The class name or type for the error. This will be server and platform specific. AwsLambdaInvocationError TransactionError error.message The error message for the transaction. This will be server and platform specific. AwsLambdaInvocationError TransactionError externalCallCount count The number of external calls made by this transaction. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError externalDuration seconds (s) The total response time of all external (out-of-process) services, in seconds. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError newRelic.ingestPoint Where the data point entered the platform (such as browser.spans, or api.traces). AwsLambdaInvocationError AwsLambdaInvocation Span parent.account ID If a distributed tracing payload is received, this is the account identifier for the transaction's upstream caller. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError parent.app ID If a distributed tracing payload is received, this is the application identifier. APM agents retrieve this value in the connect response under the key primary_application_id. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError parent.transportType When a distributed tracing payload is received, the method of transport for the payload. Example values: Unknown, HTTP, HTTPS, Kafka, JMS, IronMQ, AMQP, Queue, or Other. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError parent.type If a distributed trace payload was received, the parent's data source type. Example values: App, Browser, Mobile. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.accept The types as read from the HTTP Accept request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.contentLength bytes (B) Incoming request size in bytes as read from the Content-Length HTTP request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.contentType Incoming request content-type as read from the HTTP request header Content-Type. Example value: application/octet-stream. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.host The name from the HTTP host request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.referer The incoming request referer as read from the Referer request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.userAgent The contents of the User-Agent HTTP header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.method The HTTP request method used. Example values: POST, GET. AwsLambdaInvocationError AwsLambdaInvocation Span Transaction TransactionError response.headers.contentLength bytes (B) The outgoing response size in bytes as read from the Content-Length response header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError response.headers.contentType For an HTTP response, the data type of the returned response. Example values: text/html, application/json. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError stackTrace The error stack trace. The format will be different depending on the agent language. AwsLambdaInvocationError traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocationError AwsLambdaInvocation MobileRequest MobileRequestError Span transactionName Name of the transaction in which the error occurred. Example value: Controller/customers/show. Value may be 'Unknown' if an error occurs outside of a transaction. AwsLambdaInvocationError TransactionError type The New Relic event type. Example values: Transaction, Span. AwsLambdaInvocationError AwsLambdaInvocation BrowserInteraction Data source : Browser agent A BrowserInteraction represents a unit of work in a browser session, triggered by a user interacting with the webpage. It captures information about the session, AJAX calls and custom JavaScript timing that occurred as a result of the interaction. Initial load and route changes are captured as special types of browser interactions, and are used for SPA monitoring. Attribute name Definition Data types actionText The text of the HTML element that was clicked when a browser interaction started. Added to BrowserInteraction and any AjaxRequest, JavaScriptError and BrowserTiming events that occurred during that interaction. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError ajaxCount count A count of all XHRs included in the timing of a SPA interaction. BrowserInteraction appId ID The ID of your application, as recorded by New Relic. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming backendTransactionName The name of the backend transaction that served the initial page load. BrowserInteraction browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserInteractionName The name of the interaction. This is either the targetGroupedUrl or the custom name set via the API. AjaxRequest BrowserInteraction BrowserTiming category The type of interaction; either initial page load, route change, or custom. BrowserInteraction city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView domain The domain portion of the request URL. BrowserInteraction JavaScriptError PageView PageViewTiming duration seconds (s) The total time elapsed of the interaction event BrowserInteraction eventId ID A value that you can link to multiple BrowserInteraction events so you can view the interactions that occurred surrounding a specific event. For example, you can see the browser interactions that occurred prior to a JS error. AjaxRequest BrowserInteraction BrowserTiming firstContentfulPaint firstContentfulPaint is the point when the browser renders the first bit of content from the DOM, which may be text, an image, SVG, or a <canvas> element. Google's User-centric Performance Metrics contains detailed information about its Paint Timing API and firstContentfulPaint. See Compatibility and requirements for New Relic Browser for additional information about firstContentfulPaint browser compatibility. BrowserInteraction PageView firstPaint firstPaint marks the point when the browser renders anything that is visually different from what was on the screen prior to navigation. This includes non-default background paint and the enclosing box of an iframe. Google's User-centric Performance Metrics contains detailed information about its Paint Timing API and firstPaint. See Compatibility and requirements for New Relic Browser for additional information about firstPaint browser compatibility. BrowserInteraction PageView jsDuration seconds (s) The total duration, in seconds, spent on JavaScript execution. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. This attribute doesn't exist for initial page load events. AjaxRequest BrowserInteraction BrowserTiming monitorAccountId The Synthetics account from which you are running the monitor. BrowserInteraction JavaScriptError monitorId ID A unique number identifying a particular monitor. BrowserInteraction JavaScriptError SyntheticCheck monitorJobId ID The ID of a single Synthetics monitor run, which began at a specific time and originated from a specific location. BrowserInteraction JavaScriptError parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError previousGroupedUrl The grouped version of the URL in the browser at the start of the interaction. BrowserInteraction previousRouteName The route name of the page at the start of the interaction. This is the last value passed by setCurrentRouteName before the start of the interaction. BrowserInteraction previousURL The ungrouped URL in the browser at the start of the interaction. BrowserInteraction regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span targetGroupedUrl The grouped version of the URL in the browser at the end of the interaction. BrowserInteraction targetRouteName The route name for the page at the end of the interaction. The last value passed by setCurrentRouteName before the end of the interaction. BrowserInteraction targetUrl The ungrouped URL in the browser at the end of the interaction. BrowserInteraction timeToConnectEnd seconds (s) The time, in seconds, from the start of the interaction to the connectEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToConnectStart seconds (s) The time, in seconds, from the start of the interaction to the connectStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomComplete seconds (s) The time, in seconds, from the start of the interaction to the domComplete, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomContentLoadedEventEnd seconds (s) The time, in seconds, from the start of the interaction to the domContentLoadedEventEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomContentLoadedEventStart seconds (s) The time, in seconds, from the start of the interaction to the domContentLoadedEventStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomInteractive seconds (s) The time, in seconds, from the start of the interaction to the domInteractive, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomLoading seconds (s) The time, in seconds, from the start of the interaction to the domLoading, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomainLookupEnd seconds (s) The time, in seconds, from the start of the interaction to the domainLookupEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomainLookupStart seconds (s) The time, in seconds, from the start of the interaction to the domainLookupStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToFetchStart seconds (s) The time, in seconds, from the start of the interaction to the fetchStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToLastCallbackEnd seconds (s) The duration, in seconds, from the start of the request (timestamp) to the end of the last callback. This is not just an additive function; the callback time can overlap with the wait time. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserInteraction BrowserTiming timeToLoadEventEnd seconds (s) The time, in seconds, from the start of the interaction to the loadEventEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToLoadEventStart seconds (s) The time, in seconds, from the start of the interaction to the loadEventStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information, see our documentation about instrumentation for the Navigation Timing API. BrowserInteraction timeToRedirectEnd seconds (s) The time, in seconds, from the start of the interaction to the redirectEnd, as defined by the Navigation Timing API. This attribute exists only for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToRedirectStart seconds (s) The time, in seconds, from the start of the interaction to the redirectStart, as defined by the Navigation Timing API. This attribute exists only for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToRequestStart seconds (s) The time, in seconds, from the start of the interaction to the requestStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToResponseEnd seconds (s) The time, in seconds, from the start of the interaction to the responseEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToResponseStart seconds (s) The time, in seconds, from the start of the interaction to the responseStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToSecureConnectionStart seconds (s) The time, in seconds, from the start of the interaction to the secureConnectionStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToUnloadEventEnd seconds (s) The time, in seconds, from the start of the interaction to the unloadEventEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToUnloadEventStart seconds (s) The time, in seconds, from the start of the interaction to the unloadEventStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timestamp The time (date, hour, minute, second) at which the interaction occurred. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming Span trigger The cause of the route change or page load. The default values are click, submit, popstate, or initial page load. For a custom event created with the API, the default value for trigger will be api. This value can also be set via the API. BrowserInteraction userAgentName The browser’s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browser’s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browser’s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming BrowserTiming Data source : Browser agent BrowserTiming is a custom event that captures SPA timing data for browser interactions started using the custom createTracer SPA API method. BrowserTiming contains many of the same attributes used by other events, especially AjaxRequest. Attribute name Definition Data types actionText The text of the HTML element that was clicked when a browser interaction started. Added to BrowserInteraction and any AjaxRequest, JavaScriptError and BrowserTiming events that occurred during that interaction. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError appId ID The ID of your application, as recorded by New Relic. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserInteractionName The name of the interaction. This is either the targetGroupedUrl or the custom name set via the API. AjaxRequest BrowserInteraction BrowserTiming browserTimingName The name of the event. This is taken from the name argument of createTracer. BrowserTiming city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView eventId ID A value that you can link to multiple BrowserInteraction events so you can view the interactions that occurred surrounding a specific event. For example, you can see the browser interactions that occurred prior to a JS error. AjaxRequest BrowserInteraction BrowserTiming groupedPageURL The grouped URL of the view that made the AJAX request. For example: myapp.com/acct/*/dash. AjaxRequest BrowserTiming jsDuration seconds (s) The total duration, in seconds, spent on JavaScript execution. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. This attribute doesn't exist for initial page load events. AjaxRequest BrowserInteraction BrowserTiming pageUrl The URL of the page that was loaded for the PageView. For example: http://www.newrelic.com. This URL does not include query parameters. AjaxRequest BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span timeSinceBrowserInteractionStart seconds (s) The time in seconds between the start of the BrowserInteraction and the start of the request. AjaxRequest BrowserTiming timeToLastCallbackEnd seconds (s) The duration, in seconds, from the start of the request (timestamp) to the end of the last callback. This is not just an additive function; the callback time can overlap with the wait time. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserInteraction BrowserTiming timeToSettle seconds (s) The time, in seconds, from the start of the request to when all resulting callbacks (including callbacks of subsequent AJAX requests) are complete. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserTiming timeToTracedCallbackStart seconds (s) The time in seconds from the start of the custom tracer until the start of the traced callback. This attribute is unique to the BrowserTiming event. BrowserTiming timestamp The time (date, hour, minute, second) at which the interaction occurred. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming Span tracedCallbackDuration seconds (s) The duration in seconds of the traced callback. This attribute is unique to the BrowserTiming event. BrowserTiming userAgentName The browser’s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browser’s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browser’s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming ContainerSample Data source : Infrastructure This event is reported by the New Relic Infrastructure agent. It collects data from all the Docker containers on the host (which may or may not be running). It includes the container's ID, name, image, image name, and metrics about CPU, memory and networking. We take a snapshot of this data every 15 seconds for each container and package it into this event, which is then sent to New Relic. This data appears on the Containers UI page. Attribute name Definition Data types StorageDataAvailableBytes bytes (B) Data space available in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageDataTotalBytes bytes (B) Total Data space in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageDataUsagePercent percentage (%) Percent of Data space used in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageDataUsedBytes bytes (B) Data space used by the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataAvailableBytes bytes (B) Metadata space available in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataTotalBytes bytes (B) Total Metadata space in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataUsagePercent percentage (%) Percent of Metadata space used in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataUsedBytes bytes (B) Metadata space used by the Storage Driver. Only Device Mapper driver is supported. ContainerSample commandLine The command line used in the container. ContainerSample containerId ID The unique Docker container ID. ContainerSample cpuKernelPercent percentage (%) CPU time percentage used in kernel space. ContainerSample cpuLimitCores count Number of cores available for the container. ContainerSample cpuPercent percentage (%) CPU usage percentage used. ContainerSample cpuShares count Number of CPU shares assigned to the container. ContainerSample cpuThrottlePeriods count Total number of periods throttled. ContainerSample cpuThrottleTimeMs milliseconds (ms) Total throttling time in milliseconds. ContainerSample cpuUsedCores percentage (%) CPU usage per core. ContainerSample cpuUsedCoresPercent percentage (%) CPU usage percentage per core. ContainerSample cpuUserPercent percentage (%) CPU time percentage used in user space. ContainerSample criticalViolationCount count The number of times that alert conditions violated critical thresholds, causing critical violations and opening incidents. If this attribute does not exist on the sample, it has zero violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample image ID The Docker image ID for the image the container is based on. ContainerSample imageName The Docker image name for the container. ContainerSample label_KEY Docker labels associated with this container (where KEY represents a custom label's key value). ContainerSample memoryCacheBytes count The amount of memory used by the container that can be associated precisely with a block on a block device. ContainerSample memoryKernelUsageBytes bytes (B) The amount of current kernel memory allocation. ContainerSample memoryResidentSizeBytes bytes (B) The amount of memory that doesn't correspond to anything on disk: stacks, heaps, and anonymous memory maps. ContainerSample memorySizeLimitBytes bytes (B) The total amount of memory the container is allowed to use. ContainerSample memorySoftLimitBytes bytes (B) The soft limit of memory usage equivalent to the memory reservation of the container. ContainerSample memorySwapLimitBytes bytes (B) The total amount of memory the container is using, including swap. ContainerSample memorySwapLimitUsagePercent percentage (%) This metric is calculated as the percentage of memorySwapUsageBytes over memorySwapLimitBytes, if the limit exists. ContainerSample memorySwapOnlyUsageBytes bytes (B) The amount of swap memory the container is using. This memory doesn't include non-swap memory. ContainerSample memorySwapUsageBytes bytes (B) The amount of memory swap the container is using, including swap. ContainerSample memoryUsageBytes bytes (B) This metric doesn't account for swap usage. ContainerSample memoryUsageLimitPercent percentage (%) This metric is calculated as the memoryUsageBytes percentage over memorySizeLimitBytes, if the limit exists. ContainerSample name The Docker container name. ContainerSample networkRxBytes bytes (B) Total number of received bytes. ContainerSample networkRxBytesPerSecond rate Number of received bytes per second. ContainerSample networkRxDropped count Total number of received packets dropped. ContainerSample networkRxDroppedPerSecond rate Number of received packets dropped per second. ContainerSample networkRxError count Total number of received packets with error. ContainerSample networkRxErrorsPerSecond rate Number of received packets with error per second. ContainerSample networkRxPackets count Total number of received packets. ContainerSample networkRxPacketsPerSecond rate Number of received packets with error per second. ContainerSample networkTxBytesPerSecond rate Number of transmitted bytes per second. ContainerSample networkTxDropped count Total number of transmitted packets dropped. ContainerSample networkTxDroppedPerSecond rate Number of transmitted packets dropped per second. ContainerSample networkTxErrors count Total number of transmitted packets with error. ContainerSample networkTxErrorsPerSecond rate Number of transmitted packets with error per second. ContainerSample networkTxPackets count Total number of transmitted packets. ContainerSample networkTxPacketsPerSecond rate Number of transmitted packets per second. ContainerSample networksTxBytes count Total number of bytes transmitted. ContainerSample restartCount count The number of times the container was restarted. ContainerSample state It can be: created, restarting, running, removing, paused, exited, or dead. ContainerSample status Holds the current container state. ContainerSample warningViolationCount count The number of times that alert conditions violated warning thresholds, causing warning violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample DistributedTraceSummary Data source : Distributed Tracing This event contains summary data about a distributed trace and provides an aggregated view of distributed tracing data. DistributedTraceSummary events are generated by New Relic and are triggered by distributed tracing data from agents or the Trace API. Attribute name Definition Data types accountIds A comma delimited list of newrelic accountIds that took part in this trace. DistributedTraceSummary backend.duration.ms milliseconds (ms) The total elapsed time in milliseconds of all backend services in this trace. DistributedTraceSummary backend.timestamp milliseconds (ms) The timestamp of the first span in this trace from a backend entity. In distributed tracing, any events that are not from client-side applications contributed to the backend duration. DistributedTraceSummary duration.ms The duration of the entire distributed trace, including both backend and client-side entities. the earliest span to the latest. DistributedTraceSummary entityCount count The number of unique entities that took part in this trace. DistributedTraceSummary entityGuids A comma delimited list of entity GUIDs for entities that participated in this trace. These GUIDs are assigned by New Relic for the New Relic-monitored entity (host, application, etc.). Each GUID is stored as a Base64 encoded value. DistributedTraceSummary errorCount count The number of events in this distributed trace that were identified as errors. DistributedTraceSummary newRelic.traceFilter.type The name of the trace filter used by the Infinite Tracing trace observer to select this trace. DistributedTraceSummary Span root.entity.accountId The New Relic account ID that the root entity of this trace reports data to. DistributedTraceSummary root.entity.guid The entity GUID associated with the root entity of this trace. DistributedTraceSummary root.entity.name The name of the root entity of this trace. DistributedTraceSummary root.span.duration.ms milliseconds (ms) The elapsed time in milliseconds of the root span of this trace. The root of a distributed trace is the first span, and will have a null value for parent.id. DistributedTraceSummary root.span.id The unique identifier of the root span of this trace. The root of a distributed trace is the first span, and it has a null value for parent.id. DistributedTraceSummary root.span.name The name of the root span of this trace. DistributedTraceSummary root.span.timestamp milliseconds (ms) The timestamp of the root span of this trace. The root of a distributed trace is the first span, and will have a null value for parent.id. DistributedTraceSummary spanCount count The number of events in this distributed trace. Events in a distributed trace can have several event types, including Span, Transaction, and TransactionError. DistributedTraceSummary timestamp milliseconds (ms) The timestamp of the root span in this distributed trace. DistributedTraceSummary trace.id ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. DistributedTraceSummary MobileRequest MobileRequestError Span Transaction TransactionError InfrastructureEvent Data sources : InfrastructureCloudTrail InfrastructureEvent describes changes (deltas) that occur in a system's live state. When an inventory or system state is added, removed, or changed, Infrastructure will produce an InfrastructureEvent that logs that activity. Attribute name Definition Data types category A New Relic category used to organize events in the UI. For example: automation, notification, and service. InfrastructureEvent changeType A simple classification of the type of change made to the entity: added, modified, or removed. InfrastructureEvent changedPath The fully specified name of the item that changed. This is constructed by taking the source and adding one or more additional path elements that uniquely identify the item that changed. InfrastructureEvent deltaId Delta refers to a recorded change in the system. The deltaId is a number used by New Relic to organize incoming inventory change data. InfrastructureEvent eventId The unique ID of the event, generated by New Relic. InfrastructureEvent format The type of infrastructure event. Each format type includes attributes that may be used to render the event in the UI. InfrastructureEvent newStatus The new agent status: disconnected or connected. InfrastructureEvent newValue If a change is made to the entity, this attribute contains the new value of the inventory that was changed. This will have no value if no change has been made. The value will display approximately 4K bytes of data. InfrastructureEvent oldValue If a change is made to the entity, this attribute contains the old value of the inventory that was changed. This will be blank if no change has been made. InfrastructureEvent provider For integrations that use generic event types (like the DatastoreSample event), the provider value specifies the source of the data (the service, or a sub-category of data from that service). Some Insights events are generic and are used by several integrations. For example, the DatastoreSample event is used by several integrations, including the AWS DynamoDB integration and the AWS RDS integration. In these cases, the provider attribute value represents the source of that attribute. This will usually be the service that data comes from or, for integrations that use several provider values, a certain sub-category of data from that service. When a provider value is present for a generic event, that event will have additional integration-specific attributes attached to it. Here’s an example of an Insights NRQL query that returns the attributes present for a DatastoreSample event reported by the AWS RDS integration: SELECT * from DatastoreSample where provider = 'RdsDbCluster' InfrastructureEvent source The fully specified origin of this inventory item. This is typically in the form category/plugin, where plugin is the generic word used for the tool that gathered this data. InfrastructureEvent summary A summary of the change that happened. Uses a human-friendly string, such as Agent disconnected. InfrastructureEvent violationUpdateType The type of change to the violation: For example: open or closed. InfrastructureEvent JavaScriptError Data source : Browser agent As JavaScript errors are triggered, we capture details as events. The JavaScriptError event contains information to help you segment errors to understand how they impact performance. Attribute name Definition Data types actionText The text of the HTML element that was clicked when a browser interaction started. Added to BrowserInteraction and any AjaxRequest, JavaScriptError and BrowserTiming events that occurred during that interaction. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError appId ID The identification number for the reporting browser agent. JavaScriptError appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserStackHash ID An unique identifier generated for a stack trace. The browserStackHash for a stack trace is different across different browsers. An identical stack trace will generate the same identifier. JavaScriptError city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView domain The domain portion of the request URL. BrowserInteraction JavaScriptError PageView PageViewTiming entityGuid The unique identifier of the monitor referenced in New Relic One. JavaScriptError SyntheticCheck SyntheticRequest errorClass The error type of the JavaScript Error object. Examples: ReferenceError, SyntaxError, and UncaughtException. JavaScriptError errorMessage The error message that was delivered. JavaScriptError firstErrorInSession A value to indicate whether or not this was the first JS error in the session. Example: true. JavaScriptError monitorAccountId The Synthetics account from which you are running the monitor. BrowserInteraction JavaScriptError monitorId ID A unique number identifying a particular monitor. BrowserInteraction JavaScriptError SyntheticCheck monitorJobId ID The ID of a single Synthetics monitor run, which began at a specific time and originated from a specific location. BrowserInteraction JavaScriptError pageUrl The URL of the page that was loaded for the PageView. For example: http://www.newrelic.com. This URL does not include query parameters. AjaxRequest BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming releaseIds ID The releases in which the app was updated. Example: {\\\"jQuery\\\":\\\"v3.1.1\\\",\\\"multiverse\\\":\\\"96e9ac7\\\"}. JavaScriptError requestUri The URI of the requested resource. JavaScriptError session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span stackHash ID A unique identifier generated by the Browser agent for a stack trace. The stackHash for a stack trace is the same across different browsers. An identical stack trace will generate the same identifier. JavaScriptError stackTrace A collection of the active stack frames when the error occurred. JavaScriptError stackTraceGzip A compressed version of the stackTrace attribute. JavaScriptError timestamp The time that the error occurred, in Unix time. JavaScriptError transactionName The full metric name of the transaction in which the error occurred, or Unknown if the error occurs outside of a transaction. JavaScriptError userAgentName The browser’s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browser’s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browser’s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Metric Data source : Metrics Represents a metric data point (a measurement over a range of time, or a sample at a specific point in time) with multiple attributes attached, which allow for in-depth analysis and querying. This metric data comes from our Metric API, our Telemetry SDKs, network performance monitoring, and some of our open-source exporters/integrations. Attribute name Definition Data types endTimestamp milliseconds (ms) The end of the time range associated with the metric, in Unix time, in milliseconds. This is calculated by adding the metric interval to the timestamp of the metric (timestamp + interval.ms). Metric interval.ms milliseconds (ms) The length of the time window. Metric metricName Name of the metric. Metric newrelic.source The source of this data. For example: metricAPI. Metric timestamp milliseconds (ms) The start time for the metric, in Unix time. Metric Mobile Data source : Mobile A Mobile event is created when a crash occurs, when an interaction ends or has run for 1 second, or if a session completes after the app is closed, backgrounded, or has run for 10 minutes. Mobile events were once the only event type and were generated for every event, but now there are several specialized event types. Recommendation: Upgrade to the most recent mobile monitoring agent version to take full advantage of the new event types. Attribute name Definition Data types category The type of data, either session or interaction. Mobile MobileSession interactionDuration For interaction category events only. This is the total time for the interaction to render on the device. In addition to render time, this usually includes all external calls associated with the interaction. Currently, this attribute is measured in seconds for Android devices and in milliseconds for iOS devices. Mobile name For interaction category events only. This is the label of the interaction associated with the event. It is by default assigned by New Relic. For example: ApplicationsListFragment or Display iOS_Example.MasterViewController. Mobile reportedTimestampMs For interaction category events only. The UTC based timestamp for when the event was sent to New Relic. This is different from the attribute ‘timestamp’, which is when the event began. Mobile MobileCrash Data source : Mobile The MobileCrash event is created when an app crashes. MobileCrash includes attributes such as crash line number, class, and crash message. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appToken The mobile application license token. MobileCrash appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession architecture The processor architecture of the device. For example: armv7 or arm64. MobileCrash asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession bundleId ID The unique string used to identify the application. MobileCrash MobileSession carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession crashException The exception associated with the crash, if one is present. For example: java.lang.NullPointerException. MobileCrash crashFingerprint ID The New Relic-generated fingerprint used to uniquely identify the crash and other crashes identical to this one. MobileCrash crashLocationFile The file in which the crash occurred. MobileCrash crashMessage The message associated with the crash, if one is present. MobileCrash deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceName The device's name. MobileCrash deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession diskAvailable bytes (B) Space available on the device, in bytes. MobileCrash interactionHistory The client interactions with the application that led to the crash. MobileCrash isFirstOccurrence A boolean value indicating whether or not this was the first occurrence of the crash. MobileCrash lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession modelNumber The model of the device. This is the same as the session-level deviceModel attribute. MobileCrash networkStatus The type of network that the device was on at the time of crash, such as wifi or LTE. MobileCrash newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession occurrenceId ID The ID for this instance of the crash. MobileCrash orientation The orientation of the device, such as landscape or portrait. MobileCrash osBuild For Android only. The specific build of the Android OS. MobileCrash MobileHandledException osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession parentProcess The parent process that launched the crashing process. MobileCrash parentProcessId ID The parent identification number (PID) of the parent process. MobileCrash platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession processId ID The PID of the previously running process on the device. MobileCrash processName The name of the previously running process. MobileCrash processPath The path to the binary. MobileCrash reportedTimestampMs The UTC timestamp for when the event was received by New Relic. (This is different from timestamp, which is when the MobileSession event began that crashed.) MobileCrash runTime For Android only. The Android Runtime version where the exception/crash was generated. MobileCrash MobileHandledException sessionCrashed A boolean value indicating whether or not that session crashed. MobileCrash MobileSession sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession symbolicated A boolean value indicating whether or not the crash was properly symbolicated. MobileCrash timeSinceLastInteraction milliseconds (ms) The time, in milliseconds, since the interaction before a crash event. MobileCrash userImageUuids ID The array of build UUIDs for applications and libraries. MobileCrash uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession MobileHandledException Data source : Mobile MobileHandledException is sent when an exception is caught and is used for non-fatal exceptions reported to New Relic using the recordHandledException API for Android or iOS. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileRequestError MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileRequestError MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileRequestError MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession exceptionAppBuildUuid ID The build uuid of the application binary in which the exception was caught. MobileHandledException exceptionCause The unsymbolicated, platform-specific cause of the exception. MobileHandledException exceptionLocation New Relic defined location of an exception. Contains a combination of exception file name, class, line number, and method. MobileHandledException exceptionLocationClass The class that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionLocationFile The class that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionLocationLibraryOffset For XCFramework agent only. The library offset of the library that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionLocationLine Comes from the exception: The line number where the exception was generated. Only present if symbolication succeeded. MobileHandledException exceptionLocationMethod The method that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionMessage The unsymbolicated message from the exception. It can be user-generated or a generic system message. For Android, this is the Throwable message. MobileHandledException exceptionName The unsymbolicated exception type. MobileHandledException fingerprint ID The New Relic-generated identifier used to group like exceptions. MobileHandledException handledExceptionUuid ID The unique ID of the exception event. MobileHandledException lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession libraryName For XCFramework agent only. The library name where the exception was generated. MobileHandledException libraryStartAddr For XCFramework agent only. The library start address where the exception was generated. MobileHandledException memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession occurrenceTimestamp Agent-reported epoch timestamp of the handled exception. MobileHandledException osBuild For Android only. The specific build of the Android OS. MobileCrash MobileHandledException osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileRequestError MobileSession runTime For Android only. The Android Runtime version where the exception/crash was generated. MobileCrash MobileHandledException sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession timestamp Epoch timestamp of the handled exception. This exception timestamp represents the time New Relic created the event, if it's older than two days or some other unexpected time. MobileHandledException uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession MobileRequest Data source : Mobile A MobileRequest event is created when an HTTP request successfully completes, resulting in a response code below 400. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession bytesReceived bytes (B) Optional: If the application received a response from the requestUrl, the size of that response in bytes. MobileRequest MobileRequestError bytesSent bytes (B) Optional: If the application sent a request to the requestUrl, the size of that request in bytes. MobileRequest MobileRequestError carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession connectionType The type of connection which the device was using, such as 2G or 3G. MobileRequest MobileRequestError countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileRequestError MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileRequestError MobileSession deviceGroup The category of the device, such as iPhone or Tablet. MobileRequest MobileRequestError MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceSize The display size of the device: Small, normal, large, xlarge. MobileRequest MobileRequestError deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileRequestError MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession duration seconds (s) Optional: The time to complete the request, measured in fractional seconds. MobileRequest MobileRequestError guid ID The unique identifier for the segment. This is equivalent to spanID in OpenTracing semantics. MobileRequest MobileRequestError Span lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileRequestError MobileSession requestDomain The domain that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestFingerprint ID The New Relic-generated identifier used to group like request events. MobileRequest requestMethod The REST method (GET, PUT, POST, etc.) that the application attempted when the event occurred. MobileRequest MobileRequestError requestPath The path that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUrl The URL that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUuid ID A unique identifer for the request event. MobileRequest MobileRequestError responseTime seconds (s) The time between the request and the response in fractional seconds. MobileRequest MobileRequestError sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession statusCode Optional: The HTTP status code for the HTTP event. MobileRequest MobileRequestError timestamp The UTC epoch time at which an event began. MobileRequest MobileRequestError MobileSession trace.id ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. DistributedTraceSummary MobileRequest MobileRequestError Span Transaction TransactionError traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocationError AwsLambdaInvocation MobileRequest MobileRequestError Span uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession MobileRequestError Data source : Mobile A MobileRequestError is used for HTTP errors or network failures. HTTP errors are HTTP requests that have a status code greater than 400. A network failure is a HTTP request that results in no response. The event is sent when the HTTP request completes. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession bytesReceived bytes (B) Optional: If the application received a response from the requestUrl, the size of that response in bytes. MobileRequest MobileRequestError bytesSent bytes (B) Optional: If the application sent a request to the requestUrl, the size of that request in bytes. MobileRequest MobileRequestError carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession connectionType The type of connection which the device was using, such as 2G or 3G. MobileRequest MobileRequestError countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileRequestError MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileRequestError MobileSession deviceGroup The category of the device, such as iPhone or Tablet. MobileRequest MobileRequestError MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceSize The display size of the device: Small, normal, large, xlarge. MobileRequest MobileRequestError deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileRequestError MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession duration seconds (s) Optional: The time to complete the request, measured in fractional seconds. MobileRequest MobileRequestError errorType Either HTTPError or NetworkFailure, depending on whether the error is a result of a failed request to a host or a failure on the cellular network. MobileRequestError guid ID The unique identifier for the segment. This is equivalent to spanID in OpenTracing semantics. MobileRequest MobileRequestError Span lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession networkError The error message associated with the iOS NSURL Error code. See networkErrorCode for more information. MobileRequestError networkErrorCode If the error is a network error, this is the iOS network error code. For Android applications, this is the mapped value. MobileRequestError newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileRequestError MobileSession requestDomain The domain that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestErrorFingerprint ID The New Relic-generated identifier used to group like request error events. MobileRequestError requestMethod The REST method (GET, PUT, POST, etc.) that the application attempted when the event occurred. MobileRequest MobileRequestError requestPath The path that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUrl The URL that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUuid ID A unique identifer for the request event. MobileRequest MobileRequestError responseBody Optional: The response that is sent from the requestDomain for the HTTP error, up to 4096 bytes. MobileRequestError responseTime seconds (s) The time between the request and the response in fractional seconds. MobileRequest MobileRequestError sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession statusCode Optional: The HTTP status code for the HTTP event. MobileRequest MobileRequestError timestamp The UTC epoch time at which an event began. MobileRequest MobileRequestError MobileSession trace.id ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. DistributedTraceSummary MobileRequest MobileRequestError Span Transaction TransactionError traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocationError AwsLambdaInvocation MobileRequest MobileRequestError Span uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession MobileSession Data source : Mobile A MobileSession event is sent when an app is closed, backgrounded, or when 10 minutes of active use has elapsed. This is the source of the general session data used by the other mobile monitoring events. MobileSession captures attributes such as device type, device OS, and geographical information. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession bundleId ID The unique string used to identify the application. MobileCrash MobileSession carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession category The type of data, either session or interaction. Mobile MobileSession city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileRequestError MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileRequestError MobileSession deviceGroup The category of the device, such as iPhone or Tablet. MobileRequest MobileRequestError MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileRequestError MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession install Indicates true only if the current session is the first session after app install. MobileSession lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession newRelicAgent The New Relic agent running on the application. For example: the iOSAgent or the androidAgent. MobileSession newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileRequestError MobileSession sessionCrashed A boolean value indicating whether or not that session crashed. MobileCrash MobileSession sessionDuration seconds (s) The length of time for which the user used the application in seconds. If the session crashes, sessionDuration is not captured (although other events and attributes are still recorded). For sessions longer than 10 minutes, events in the Interaction and Custom event categories are sent to Insights while the session is ongoing, and therefore do not have sessionDuration attributes. Events recorded near the end of the session will include the duration, as will the Session event category. MobileSession sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession timeSinceLoad seconds (s) The time, in seconds, from the beginning of the mobile session to the time the event occurred. MobileSession timestamp The UTC epoch time at which an event began. MobileRequest MobileRequestError MobileSession upgradeFrom Indictates previous version number only if this is the first launch after app upgrade. MobileSession uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession NetworkSample Data source : Infrastructure NetworkSample event captures the descriptive and state information for each network device associated with a server. It includes the device's interface and address information, as well as current usage data. New Relic samples this data every 10 seconds for each attached network interface and packages it into a NetworkSample event, then sends the raw data to New Relic's collectors every 60 seconds. Attribute name Definition Data types agentName The name of the agent (Infrastructure). NetworkSample ProcessSample StorageSample SystemSample agentVersion The version of the New Relic Infrastructure agent. NetworkSample ProcessSample StorageSample SystemSample criticalViolationCount count The number of times that alert conditions violated critical thresholds, causing critical violations and opening incidents. If this attribute does not exist on the sample, it has zero violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample entityID ID New Relic's unique ID number for the entity that is reporting data. This is used by New Relic to distinguish between customers and their entities. NetworkSample ProcessSample StorageSample SystemSample fullHostname The fully qualified (DNS) hostname. NetworkSample ProcessSample StorageSample SystemSample hardwareAddress The unique hardware address of the interface. NetworkSample hostname The short version of the entity's name. NetworkSample ProcessSample StorageSample SystemSample interfaceName The interface name as reported by the operating system.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 306.18594,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>InfrastructureEvent</em>",
        "body": " to render on the <em>device</em>. In addition to render time, this usually includes all external calls associated with the interaction. Currently, this attribute is measured in seconds for Android devices and in milliseconds for <em>iOS</em> devices. Mobile name For interaction category events only. This is the label"
      },
      "id": "603f53b164441f41894e8875"
    },
    {
      "sections": [
        "iOS agent compatibility and requirements",
        "Foreground monitoring",
        "iOS requirements",
        "Testing is not supported",
        "Potential method replacement conflicts"
      ],
      "title": "iOS agent compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "544e062fdc57c4545c2f36b54b38f95b30b3c25e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/new-relic-ios-compatibility-requirements/",
      "published_at": "2021-12-30T11:17:44Z",
      "updated_at": "2021-12-19T19:52:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install and configure the iOS agent, follow these guidelines for compatibility and other requirements. Foreground monitoring The iOS agent only monitors your app while it is in the foreground. The agent does not monitor background services while the app is closed. For more information, see our Mobile data privacy and security documentation. iOS requirements Make sure your iOS app meets these requirements: Component iOS application requirements Operating system iOS 9 or higher For Bitcode support, use SDK version 5.3.0 or higher. API/SDK NSURLConnection and AFNetworking are supported. NSURLSession supports upload and data tags only. ASIHttpRequest networking APIs are deprecated as of iOS agent version 5.8.2. Network traffic for UIWebView and WKWebView is supported. However, WKWebView Transfer size and Http errors are not supported. Languages Objective-C Swift: Works with both network traces and crash reporting, but no interaction traces by default. Interaction traces must be enabled for Swift. Devices Any iOS compatible device: iPhones, iPads, etc. File sizes The agent adds about 2 to 12 megabytes to your iOS release app, depending on platform build. Architectures ARM 64-bit. SHA-2 As a standard security measure for data collection, New Relic requires that your application server supports SHA-2 (256-bit). SHA-1 is not supported. Xcode To take advantage of New Relic's iOS features, make sure you have the latest version of Xcode. arm64e support To be able to properly symbolicate crashes from devices with arm64e architectures, make sure your Xcode settings are enabled for pointer authentication. For more information, see the Apple developer documentation. CocoaPods In order to use the latest XCFramework Agent, use CocoaPods version 1.10.1 or higher. Testing is not supported Our agents are designed and tested to work in a normal app lifecycle. New Relic does not support running any testing environment on applications with the agent. Testing can cause conflicts and unpredictable behavior. Potential method replacement conflicts Our iOS agent utilizes method replacement during run time. This may result in a conflict with other libraries that also implement method replacement, such as ReactiveCocoa, Firebase, Aspects, and AppleGuice.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 243.54892,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> agent compatibility and requirements",
        "sections": "<em>iOS</em> agent compatibility and requirements",
        "tags": "New Relic Mobile <em>iOS</em>",
        "body": " network traces and crash reporting, but no interaction traces by default. Interaction traces must be enabled for Swift. Devices Any <em>iOS</em> compatible <em>device</em>: <em>i</em>Phones, <em>i</em>Pads, etc. File sizes The agent adds about 2 to 12 megabytes to your <em>iOS</em> release app, depending on platform build. Architectures ARM 64"
      },
      "id": "6044196064441f4f10378f04"
    },
    {
      "sections": [
        "Alerting with New Relic mobile apps",
        "Requirements",
        "Turn notifications on or off",
        "View alert incident details",
        "Troubleshoot alert settings",
        "Check notification settings for your mobile device.",
        "Delete the Android or iOS device from your New Relic account.",
        "Uninstall the New Relic mobile app.",
        "Reinstall the New Relic mobile app."
      ],
      "title": "Alerting with New Relic mobile apps",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Authentication and alerts"
      ],
      "external_id": "19bd5fbedd3d386c36cadc21d9dc4c7d6b7f0bce",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-apps/authentication-alerts/alerting-new-relic-mobile-apps/",
      "published_at": "2021-12-31T03:06:25Z",
      "updated_at": "2021-12-14T04:23:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Account administrators can set up configuration to receive push notifications on Android and iOS devices from New Relic Alerts. You can receive alerts from any policy by attaching a user channel to the policy. Requirements This feature is available only to users on the original user model, not to users on the New Relic One user model. As a workaround, you can use the email notification channel. Turn notifications on or off When you log in to your New Relic account from an Android or iOS app, your device is automatically associated with your user channel. Be sure to add the associated user channel to the alert policy. View alert incident details The notification automatically appears on your device's lock screen. To start the New Relic app: Android devices: Tap the notification from the notification drawer. OR iOS devices: Swipe the screen. From the New Relic app's Alerts menu, select any alert to view error details for the associated application. Optional: Select Acknowledge. Optional: To view additional details, select Overview, Violations, or Event log. The main menu's Alerts list shows alerts in the following order, sorted by time: Active incidents Resolved incidents from today Resolved incidents and events from the past week, organized by day Troubleshoot alert settings If alerts are not working on your mobile device: Verify that you meet the requirements. Verify that alerts are enabled. Check your mobile device's notification settings, to ensure New Relic is permitted to send alerts. If the notification settings for your mobile device are correct, but you still do not receive notifications, delete the device from your account, then uninstall and reinstall the New Relic application. Check notification settings for your mobile device. Follow the procedure for your mobile device. Device To check notification settings: Android From your Android device's Settings, select Sound and notification. Check the settings for sound volume. Optional: Enable Also vibrate for calls. Check the settings for Interruptions. Check the settings for Notification. Check the settings for App notifications: Select the New Relic app, then check the settings for Block and Priority. iOS Ensure Do Not Disturb is off: From the iOS Settings app, select Do Not Disturb, and check that the Manual switch is off. Ensure the New Relic app is allowed to send notifications: From the iOS Settings app, select Notifications, and locate the New Relic app from the app list. Ensure that the Allow Notifications switch is on. Ensure that the alert style is set to Banners or Alerts. Optional: To enable audio alerts, set Sounds to on. Delete the Android or iOS device from your New Relic account. To delete the mobile device from your New Relic account, use the public graphql api api.newrelic.com/graphiql in a web browser: Query current devices by selecting actor -> mobilePushNotification -> devices and selecting appVersion, deviceId, and deviceName. Run this query to get the list of devices. Mutate to remove a device by selecting mutation -> mobilePushNotificationRemoveDevice, and passing in the deviceId from the list above. Or you can remove the device from the in-app Settings option from the menu -> Settings Look under Push notification devices, and remove from there. On iOS, slide from right to left to Delete a device, on Android, tap Delete Continue with the steps to reinstall the New Relic app from your device. Uninstall the New Relic mobile app. Follow the procedure to uninstall the New Relic app from your device, then reinstall it. Device To uninstall the New Relic app: Android From your Android device's Settings, select Apps, then select the New Relic app. Select Uninstall. Continue with the steps to reinstall the New Relic app. iOS From your iOS home screen, tap and hold the New Relic icon until it shakes. To delete the app, select the X icon. Continue with the steps to reinstall the New Relic app. Reinstall the New Relic mobile app. To reinstall the New Relic mobile app: From your Android device, select Google Play Store. OR From your iOS device's home screen, select App Store. Search for New Relic. Download the app. When the download finishes, sign in to your New Relic mobile app with your New Relic account.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 238.94942,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Delete the Android or <em>iOS</em> <em>device</em> from your New Relic account.",
        "body": ". Mutate to remove a <em>device</em> by selecting mutation -&gt; mobilePushNotificationRemove<em>Device</em>, and passing in the <em>deviceId</em> from the list above. Or you can remove the <em>device</em> from the in-app Settings option from the menu -&gt; Settings Look under Push notification devices, and remove from there. On <em>iOS</em>, slide"
      },
      "id": "603e9efd64441f19a14e88ab"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/configuration/ios-tvos-crash-reporting": [
    {
      "sections": [
        "iOS agent configuration and feature flags",
        "Enable or disable feature flags",
        "Crash and error reporting feature flag",
        "NRFeatureFlag_CrashReporting",
        "NRFeatureFlag_HandledExceptionEvents",
        "Distributed tracing",
        "NRFeatureFlag_DistributedTracing",
        "Interactions feature flags",
        "NRFeatureFlag_DefaultInteractions",
        "NRFeatureFlag_InteractionTracing",
        "NRFeatureFlag_SwiftInteractionTracing",
        "Caution",
        "Networking feature flags",
        "NRFeatureFlag_ExperimentalNetworkingInstrumentation",
        "NRFeatureFlag_NSURLSessionInstrumentation",
        "NRFeatureFlag_NetworkRequestEvents",
        "NRFeatureFlag_RequestErrorEvents",
        "NRFeatureFlag_HttpResponseBodyCapture"
      ],
      "title": "iOS agent configuration and feature flags",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "538f198af51ca5659916c98e634f1142ec387bca",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/ios-agent-configuration-feature-flags/",
      "published_at": "2021-12-30T07:47:01Z",
      "updated_at": "2021-11-05T14:19:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's iOS agent provides configuration settings to change the default behavior of the agent. If used, implement these flags just before calling: Objective-C: +[NewRelic startWithApplicationToken:] Swift: NewRelic.start(withApplicationToken:) Enable or disable feature flags To configure feature flags, use the following method defined in NewRelic.h: iOS language Procedure Objective-C In Objective-C, these features are bitmasked, so you can use a | to enable or disable multiple features at the same time. Enable a feature flag: +[NewRelic enableFeatures:(NRMAFeatureFlags)flags]; Copy Disable a feature flag: +[NewRelic disableFeatures:(NRMAFeatureFlags)flags]; Copy Here is an example where: Interaction tracing and experimental networking instrumentation are enabled. NSURLSession instrumentation and crash reporting are disabled. [NewRelic enableFeatures:NRFeatureFlag_SwiftInteractionTracing | NRFeatureFlag_ExperimentalNetworkingInstrumentation]; [NewRelic disableFeatures:NRFeatureFlag_NSURLSessionInstrumentation | NRFeatureFlag_CrashReporting]; [NewRelic startWithApplicationToken:...]; Copy Swift Enable a feature flag: NewRelic.enableFeatures(NRMAFeatureFlags.[NRMAFeatureFlag]) Copy Disable a feature flag: NewRelic.disableFeatures(NRMAFeatureFlags.[NRMAFeatureFlag]) Copy Example to disable interaction tracing: NewRelic.disableFeatures(NRMAFeatureFlags.NRFeatureFlag_DefaultInteractions) Copy Crash and error reporting feature flag If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_CrashReporting Enable (default) or disable crash reporting, which appears on the Crash analysis page. Type Boolean Default true NRFeatureFlag_HandledExceptionEvents Globally enable (default) or disable recording handled exceptions events, which appear on the Handled exception page. Type Boolean Default true Distributed tracing NRFeatureFlag_DistributedTracing Enable or disable the adding of distributed tracing headers to network requests. Refer to How New Relic distributed tracing works for more information on distributed tracing in mobile apps. Type Boolean Default true Interactions feature flags If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_DefaultInteractions Enable (default) or disable interaction tracing only for default instrumented classes and methods. Custom interactions will be reported. The traces will appear on the Interactions page. Type Boolean Default true NRFeatureFlag_InteractionTracing Globally enable (default) or disable interaction traces, which appear on the Interactions page. Interaction tracing will be disabled after the agent has started. Interactions for any activity or methods executed prior to starting the agent may still appear on the Interactions page. Type Boolean Default true NRFeatureFlag_SwiftInteractionTracing Caution Before enabling this feature, see Enable Swift interaction traces. If proper steps are not taken, enabling this feature may cause instability. Enable or disable (default) interaction tracing for Swift code. The traces appear on the Interactions page. This feature will always be disabled if NRFeatureFlag_InteractionTracing is disabled. Type Boolean Default false Networking feature flags If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_ExperimentalNetworkingInstrumentation Caution Enabling this feature flag call may decrease the stability of applications. Avoid using unless instructed by New Relic. Enable or disable (default) experimental networking instrumentation. This forces all NSURLConnection network requests through the NRMAURProtocol. Type Boolean Default false NRFeatureFlag_NSURLSessionInstrumentation Enable (default) or disable networking instrumentation for NSURLSession. These URL traces are sent to the HTTP Requests page. Type Boolean Default true NRFeatureFlag_NetworkRequestEvents Enable or disable (default) networking instrumentation. This sends the HTTP response data as MobileRequest events. Available for iOS Agent version 5.14.0 and higher Type Boolean Default true - Enabled by default as of 6.0.0 NRFeatureFlag_RequestErrorEvents Enable (default) or disable HTTP request error event generation of instrumented network calls that result in an error or failure. These events are reported as MobileRequestError events. Available for iOS Agent version 5.11.0 and higher Type Boolean Default true NRFeatureFlag_HttpResponseBodyCapture Enable or disable capture of HTTP response bodies for HTTP error traces, and MobileRequestError events. Type Boolean Default true",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.28207,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> agent <em>configuration</em> and feature flags",
        "sections": "<em>iOS</em> agent <em>configuration</em> and feature flags",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> agent provides <em>configuration</em> settings to change the default behavior of the agent. If used, implement these flags just before calling: Objective-C: +[<em>NewRelic</em> startWithApplicationToken:] Swift: <em>NewRelic</em>.start(withApplicationToken:) Enable or disable feature flags To configure"
      },
      "id": "619eaa7e28ccbc1559b9b002"
    },
    {
      "sections": [
        "Upload dSYM files",
        "Automatic script",
        "Identify missing dSYMs",
        "Upload dSYM files through the mobile monitoring UI",
        "Manually upload dSYM files",
        "Via Python script (agent versions 6.0.0 or higher)",
        "Via command line",
        "Troubleshooting",
        "Auto-upload failure",
        "Missing dSYMs"
      ],
      "title": "Upload dSYM files",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "3655f49cf0e1ae693de0f8ea45bf4e5e6437e399",
      "image": "https://docs.newrelic.com/static/5c859575f391fbb1eaa18243a8c97000/8c557/Screen-Shot-2014-09-23-at-11.30.35-AM_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/upload-dsyms-bitcode-apps/",
      "published_at": "2021-12-30T02:14:03Z",
      "updated_at": "2021-09-27T15:06:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your app's dSYM files are stored in Xcode's dSYM archive path folder. This is the folder where the iOS agent gets the dSYM files that are used to symbolicate your crash reports. New Relic provides a post-build script as part of the iOS agent's install process and the tvOS agent's install process. This script automatically uploads your app's dSYM files. Automatic script The script automatically uploads dSYM files only for release builds. Non-release builds must upload their files either manually or through the mobile monitoring UI. Bitcode-enabled apps have their dSYM files generated by Apple. You must download the dSYM files for Bitcode-enabled apps from Apple and upload them to New Relic. If you see unreadable machine code in the Crashes page, your dSYM files may not be uploaded correctly. In some cases, you may need to manually upload dSYM files. The automatic script uses Python 2. As of October 2019 with macOS 10.15 (Catalina), Python won't be installed by default. If you're using the automatic script (recommended), you may need to manually install Python 2. If you're using Homebrew, see Python on Homebrew. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: From the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Upload dSYM files through the mobile monitoring UI You can easily upload your dSYM files directly from the New Relic One UI. The maximum file size is 600 MB. To upload your dSYM files: Go to one.newrelic.com and click Mobile. Then select your app from the list. View Crash analysis. Select a specific crash from the Crash types list. Click Upload dSYM. You can either drag and drop your dSYMs directly, or select the file form your computer. Manually upload dSYM files In some circumstances, New Relic's automatic upload of dSYM files may fail. If a dSYM upload is attempted and fails, it creates a build error with a detailed message. For example, if there's a network failure and the dSYM upload isn't completed, Xcode will report an error. For additional information about how New Relic handles dSYM uploads, see New Relic's Online Technical Community. If the automatic upload fails, you can manually upload your dSYM file. If you have multiple dSYM files, they can be within a single zip with a maximum file size of 600 MB. The YOUR_NEW_RELIC_APPLICATION_TOKEN value in the commands below is the same key used for +[NewRelic startWithApplicationToken:] (in Objective-C) or NewRelic.start(withApplicationToken:) (in Swift). To manually upload your dSYM files: Via Python script (agent versions 6.0.0 or higher) In iOS agent versions 6.0.0 or higher, the agent includes a Python script that automatically processes and uploads symbols. You can call this script from the command line: NewRelicAgent.framework/Resources/generateMap.py \"DSYM_ARCHIVE_PATH\" \"YOUR_NEW_RELIC_APPLICATION_TOKEN\" Copy Via command line To manually upload individual dSYM files from the command line: Zip up your dSYM file or files using the following command. Replace ~ /ZIPPED_DSYM_PATH with your new dSYM archive path and file name (for example, Users/my-name/desktop). Also replace ~ /dSYM_PATH with your existing dSYM file path. /usr/bin/zip --recurse-paths --quiet \"~/ZIPPED_DSYM_PATH\" \"~/dSYM_PATH\" Copy Upload the dSYM zip file using the following command: For US accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.newrelic.com/symbol Copy For EU accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.eu01.nr-data.net/symbol Copy Troubleshooting Auto-upload failure If a dSYM auto-upload failed, the Report Navigator may have a fully formed cURL command. You can use this cURL command to reattempt an upload. Depending on the error, you may also need to follow some of the dSYM manual upload steps. Here is an example of a successful dSYM upload in the Report Navigator: Example: A successful dSYM upload in the Report Navigator. Missing dSYMs If dSYM files are missing, you may need to check Xcode build settings to ensure the file is being generated. Frameworks which are built locally have separate build settings and may need to be updated as well. Build settings: Debug Information Format : Dwarf with dSYM File Deployment Postprocessing: Yes Strip Linked Product: Yes Strip Debug Symbols During Copy : Yes Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.73927,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Upload dSYM files through the <em>mobile</em> <em>monitoring</em> UI",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Your app&#x27;s dSYM files are stored in Xcode&#x27;s dSYM archive path folder. This is the folder where the <em>iOS</em> agent gets the dSYM files that are used to symbolicate your crash reports. <em>New</em> <em>Relic</em> provides a post-build script as part of the <em>iOS</em> agent&#x27;s install process and the tv<em>OS</em> agent&#x27;s install process"
      },
      "id": "60441960e7b9d24f705799ca"
    },
    {
      "sections": [
        "iOS agent compatibility and requirements",
        "Foreground monitoring",
        "iOS requirements",
        "Testing is not supported",
        "Potential method replacement conflicts"
      ],
      "title": "iOS agent compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "544e062fdc57c4545c2f36b54b38f95b30b3c25e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/new-relic-ios-compatibility-requirements/",
      "published_at": "2021-12-30T11:17:44Z",
      "updated_at": "2021-12-19T19:52:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install and configure the iOS agent, follow these guidelines for compatibility and other requirements. Foreground monitoring The iOS agent only monitors your app while it is in the foreground. The agent does not monitor background services while the app is closed. For more information, see our Mobile data privacy and security documentation. iOS requirements Make sure your iOS app meets these requirements: Component iOS application requirements Operating system iOS 9 or higher For Bitcode support, use SDK version 5.3.0 or higher. API/SDK NSURLConnection and AFNetworking are supported. NSURLSession supports upload and data tags only. ASIHttpRequest networking APIs are deprecated as of iOS agent version 5.8.2. Network traffic for UIWebView and WKWebView is supported. However, WKWebView Transfer size and Http errors are not supported. Languages Objective-C Swift: Works with both network traces and crash reporting, but no interaction traces by default. Interaction traces must be enabled for Swift. Devices Any iOS compatible device: iPhones, iPads, etc. File sizes The agent adds about 2 to 12 megabytes to your iOS release app, depending on platform build. Architectures ARM 64-bit. SHA-2 As a standard security measure for data collection, New Relic requires that your application server supports SHA-2 (256-bit). SHA-1 is not supported. Xcode To take advantage of New Relic's iOS features, make sure you have the latest version of Xcode. arm64e support To be able to properly symbolicate crashes from devices with arm64e architectures, make sure your Xcode settings are enabled for pointer authentication. For more information, see the Apple developer documentation. CocoaPods In order to use the latest XCFramework Agent, use CocoaPods version 1.10.1 or higher. Testing is not supported Our agents are designed and tested to work in a normal app lifecycle. New Relic does not support running any testing environment on applications with the agent. Testing can cause conflicts and unpredictable behavior. Potential method replacement conflicts Our iOS agent utilizes method replacement during run time. This may result in a conflict with other libraries that also implement method replacement, such as ReactiveCocoa, Firebase, Aspects, and AppleGuice.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.62038,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> agent compatibility and requirements",
        "sections": "<em>iOS</em> agent compatibility and requirements",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Before you install and configure the <em>iOS</em> agent, follow these guidelines for compatibility and other requirements. Foreground <em>monitoring</em> The <em>iOS</em> agent only monitors your app while it is in the foreground. The agent does not <em>monitor</em> background services while the app is closed. For more information"
      },
      "id": "6044196064441f4f10378f04"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/configuration/retrieve-dsyms-bitcode-apps": [
    {
      "sections": [
        "iOS agent configuration and feature flags",
        "Enable or disable feature flags",
        "Crash and error reporting feature flag",
        "NRFeatureFlag_CrashReporting",
        "NRFeatureFlag_HandledExceptionEvents",
        "Distributed tracing",
        "NRFeatureFlag_DistributedTracing",
        "Interactions feature flags",
        "NRFeatureFlag_DefaultInteractions",
        "NRFeatureFlag_InteractionTracing",
        "NRFeatureFlag_SwiftInteractionTracing",
        "Caution",
        "Networking feature flags",
        "NRFeatureFlag_ExperimentalNetworkingInstrumentation",
        "NRFeatureFlag_NSURLSessionInstrumentation",
        "NRFeatureFlag_NetworkRequestEvents",
        "NRFeatureFlag_RequestErrorEvents",
        "NRFeatureFlag_HttpResponseBodyCapture"
      ],
      "title": "iOS agent configuration and feature flags",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "538f198af51ca5659916c98e634f1142ec387bca",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/ios-agent-configuration-feature-flags/",
      "published_at": "2021-12-30T07:47:01Z",
      "updated_at": "2021-11-05T14:19:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's iOS agent provides configuration settings to change the default behavior of the agent. If used, implement these flags just before calling: Objective-C: +[NewRelic startWithApplicationToken:] Swift: NewRelic.start(withApplicationToken:) Enable or disable feature flags To configure feature flags, use the following method defined in NewRelic.h: iOS language Procedure Objective-C In Objective-C, these features are bitmasked, so you can use a | to enable or disable multiple features at the same time. Enable a feature flag: +[NewRelic enableFeatures:(NRMAFeatureFlags)flags]; Copy Disable a feature flag: +[NewRelic disableFeatures:(NRMAFeatureFlags)flags]; Copy Here is an example where: Interaction tracing and experimental networking instrumentation are enabled. NSURLSession instrumentation and crash reporting are disabled. [NewRelic enableFeatures:NRFeatureFlag_SwiftInteractionTracing | NRFeatureFlag_ExperimentalNetworkingInstrumentation]; [NewRelic disableFeatures:NRFeatureFlag_NSURLSessionInstrumentation | NRFeatureFlag_CrashReporting]; [NewRelic startWithApplicationToken:...]; Copy Swift Enable a feature flag: NewRelic.enableFeatures(NRMAFeatureFlags.[NRMAFeatureFlag]) Copy Disable a feature flag: NewRelic.disableFeatures(NRMAFeatureFlags.[NRMAFeatureFlag]) Copy Example to disable interaction tracing: NewRelic.disableFeatures(NRMAFeatureFlags.NRFeatureFlag_DefaultInteractions) Copy Crash and error reporting feature flag If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_CrashReporting Enable (default) or disable crash reporting, which appears on the Crash analysis page. Type Boolean Default true NRFeatureFlag_HandledExceptionEvents Globally enable (default) or disable recording handled exceptions events, which appear on the Handled exception page. Type Boolean Default true Distributed tracing NRFeatureFlag_DistributedTracing Enable or disable the adding of distributed tracing headers to network requests. Refer to How New Relic distributed tracing works for more information on distributed tracing in mobile apps. Type Boolean Default true Interactions feature flags If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_DefaultInteractions Enable (default) or disable interaction tracing only for default instrumented classes and methods. Custom interactions will be reported. The traces will appear on the Interactions page. Type Boolean Default true NRFeatureFlag_InteractionTracing Globally enable (default) or disable interaction traces, which appear on the Interactions page. Interaction tracing will be disabled after the agent has started. Interactions for any activity or methods executed prior to starting the agent may still appear on the Interactions page. Type Boolean Default true NRFeatureFlag_SwiftInteractionTracing Caution Before enabling this feature, see Enable Swift interaction traces. If proper steps are not taken, enabling this feature may cause instability. Enable or disable (default) interaction tracing for Swift code. The traces appear on the Interactions page. This feature will always be disabled if NRFeatureFlag_InteractionTracing is disabled. Type Boolean Default false Networking feature flags If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_ExperimentalNetworkingInstrumentation Caution Enabling this feature flag call may decrease the stability of applications. Avoid using unless instructed by New Relic. Enable or disable (default) experimental networking instrumentation. This forces all NSURLConnection network requests through the NRMAURProtocol. Type Boolean Default false NRFeatureFlag_NSURLSessionInstrumentation Enable (default) or disable networking instrumentation for NSURLSession. These URL traces are sent to the HTTP Requests page. Type Boolean Default true NRFeatureFlag_NetworkRequestEvents Enable or disable (default) networking instrumentation. This sends the HTTP response data as MobileRequest events. Available for iOS Agent version 5.14.0 and higher Type Boolean Default true - Enabled by default as of 6.0.0 NRFeatureFlag_RequestErrorEvents Enable (default) or disable HTTP request error event generation of instrumented network calls that result in an error or failure. These events are reported as MobileRequestError events. Available for iOS Agent version 5.11.0 and higher Type Boolean Default true NRFeatureFlag_HttpResponseBodyCapture Enable or disable capture of HTTP response bodies for HTTP error traces, and MobileRequestError events. Type Boolean Default true",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.28207,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> agent <em>configuration</em> and feature flags",
        "sections": "<em>iOS</em> agent <em>configuration</em> and feature flags",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> agent provides <em>configuration</em> settings to change the default behavior of the agent. If used, implement these flags just before calling: Objective-C: +[<em>NewRelic</em> startWithApplicationToken:] Swift: <em>NewRelic</em>.start(withApplicationToken:) Enable or disable feature flags To configure"
      },
      "id": "619eaa7e28ccbc1559b9b002"
    },
    {
      "sections": [
        "Upload dSYM files",
        "Automatic script",
        "Identify missing dSYMs",
        "Upload dSYM files through the mobile monitoring UI",
        "Manually upload dSYM files",
        "Via Python script (agent versions 6.0.0 or higher)",
        "Via command line",
        "Troubleshooting",
        "Auto-upload failure",
        "Missing dSYMs"
      ],
      "title": "Upload dSYM files",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "3655f49cf0e1ae693de0f8ea45bf4e5e6437e399",
      "image": "https://docs.newrelic.com/static/5c859575f391fbb1eaa18243a8c97000/8c557/Screen-Shot-2014-09-23-at-11.30.35-AM_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/upload-dsyms-bitcode-apps/",
      "published_at": "2021-12-30T02:14:03Z",
      "updated_at": "2021-09-27T15:06:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your app's dSYM files are stored in Xcode's dSYM archive path folder. This is the folder where the iOS agent gets the dSYM files that are used to symbolicate your crash reports. New Relic provides a post-build script as part of the iOS agent's install process and the tvOS agent's install process. This script automatically uploads your app's dSYM files. Automatic script The script automatically uploads dSYM files only for release builds. Non-release builds must upload their files either manually or through the mobile monitoring UI. Bitcode-enabled apps have their dSYM files generated by Apple. You must download the dSYM files for Bitcode-enabled apps from Apple and upload them to New Relic. If you see unreadable machine code in the Crashes page, your dSYM files may not be uploaded correctly. In some cases, you may need to manually upload dSYM files. The automatic script uses Python 2. As of October 2019 with macOS 10.15 (Catalina), Python won't be installed by default. If you're using the automatic script (recommended), you may need to manually install Python 2. If you're using Homebrew, see Python on Homebrew. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: From the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Upload dSYM files through the mobile monitoring UI You can easily upload your dSYM files directly from the New Relic One UI. The maximum file size is 600 MB. To upload your dSYM files: Go to one.newrelic.com and click Mobile. Then select your app from the list. View Crash analysis. Select a specific crash from the Crash types list. Click Upload dSYM. You can either drag and drop your dSYMs directly, or select the file form your computer. Manually upload dSYM files In some circumstances, New Relic's automatic upload of dSYM files may fail. If a dSYM upload is attempted and fails, it creates a build error with a detailed message. For example, if there's a network failure and the dSYM upload isn't completed, Xcode will report an error. For additional information about how New Relic handles dSYM uploads, see New Relic's Online Technical Community. If the automatic upload fails, you can manually upload your dSYM file. If you have multiple dSYM files, they can be within a single zip with a maximum file size of 600 MB. The YOUR_NEW_RELIC_APPLICATION_TOKEN value in the commands below is the same key used for +[NewRelic startWithApplicationToken:] (in Objective-C) or NewRelic.start(withApplicationToken:) (in Swift). To manually upload your dSYM files: Via Python script (agent versions 6.0.0 or higher) In iOS agent versions 6.0.0 or higher, the agent includes a Python script that automatically processes and uploads symbols. You can call this script from the command line: NewRelicAgent.framework/Resources/generateMap.py \"DSYM_ARCHIVE_PATH\" \"YOUR_NEW_RELIC_APPLICATION_TOKEN\" Copy Via command line To manually upload individual dSYM files from the command line: Zip up your dSYM file or files using the following command. Replace ~ /ZIPPED_DSYM_PATH with your new dSYM archive path and file name (for example, Users/my-name/desktop). Also replace ~ /dSYM_PATH with your existing dSYM file path. /usr/bin/zip --recurse-paths --quiet \"~/ZIPPED_DSYM_PATH\" \"~/dSYM_PATH\" Copy Upload the dSYM zip file using the following command: For US accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.newrelic.com/symbol Copy For EU accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.eu01.nr-data.net/symbol Copy Troubleshooting Auto-upload failure If a dSYM auto-upload failed, the Report Navigator may have a fully formed cURL command. You can use this cURL command to reattempt an upload. Depending on the error, you may also need to follow some of the dSYM manual upload steps. Here is an example of a successful dSYM upload in the Report Navigator: Example: A successful dSYM upload in the Report Navigator. Missing dSYMs If dSYM files are missing, you may need to check Xcode build settings to ensure the file is being generated. Frameworks which are built locally have separate build settings and may need to be updated as well. Build settings: Debug Information Format : Dwarf with dSYM File Deployment Postprocessing: Yes Strip Linked Product: Yes Strip Debug Symbols During Copy : Yes Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.73927,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Upload dSYM files through the <em>mobile</em> <em>monitoring</em> UI",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Your app&#x27;s dSYM files are stored in Xcode&#x27;s dSYM archive path folder. This is the folder where the <em>iOS</em> agent gets the dSYM files that are used to symbolicate your crash reports. <em>New</em> <em>Relic</em> provides a post-build script as part of the <em>iOS</em> agent&#x27;s install process and the tv<em>OS</em> agent&#x27;s install process"
      },
      "id": "60441960e7b9d24f705799ca"
    },
    {
      "sections": [
        "iOS agent compatibility and requirements",
        "Foreground monitoring",
        "iOS requirements",
        "Testing is not supported",
        "Potential method replacement conflicts"
      ],
      "title": "iOS agent compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "544e062fdc57c4545c2f36b54b38f95b30b3c25e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/new-relic-ios-compatibility-requirements/",
      "published_at": "2021-12-30T11:17:44Z",
      "updated_at": "2021-12-19T19:52:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install and configure the iOS agent, follow these guidelines for compatibility and other requirements. Foreground monitoring The iOS agent only monitors your app while it is in the foreground. The agent does not monitor background services while the app is closed. For more information, see our Mobile data privacy and security documentation. iOS requirements Make sure your iOS app meets these requirements: Component iOS application requirements Operating system iOS 9 or higher For Bitcode support, use SDK version 5.3.0 or higher. API/SDK NSURLConnection and AFNetworking are supported. NSURLSession supports upload and data tags only. ASIHttpRequest networking APIs are deprecated as of iOS agent version 5.8.2. Network traffic for UIWebView and WKWebView is supported. However, WKWebView Transfer size and Http errors are not supported. Languages Objective-C Swift: Works with both network traces and crash reporting, but no interaction traces by default. Interaction traces must be enabled for Swift. Devices Any iOS compatible device: iPhones, iPads, etc. File sizes The agent adds about 2 to 12 megabytes to your iOS release app, depending on platform build. Architectures ARM 64-bit. SHA-2 As a standard security measure for data collection, New Relic requires that your application server supports SHA-2 (256-bit). SHA-1 is not supported. Xcode To take advantage of New Relic's iOS features, make sure you have the latest version of Xcode. arm64e support To be able to properly symbolicate crashes from devices with arm64e architectures, make sure your Xcode settings are enabled for pointer authentication. For more information, see the Apple developer documentation. CocoaPods In order to use the latest XCFramework Agent, use CocoaPods version 1.10.1 or higher. Testing is not supported Our agents are designed and tested to work in a normal app lifecycle. New Relic does not support running any testing environment on applications with the agent. Testing can cause conflicts and unpredictable behavior. Potential method replacement conflicts Our iOS agent utilizes method replacement during run time. This may result in a conflict with other libraries that also implement method replacement, such as ReactiveCocoa, Firebase, Aspects, and AppleGuice.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.62035,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> agent compatibility and requirements",
        "sections": "<em>iOS</em> agent compatibility and requirements",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Before you install and configure the <em>iOS</em> agent, follow these guidelines for compatibility and other requirements. Foreground <em>monitoring</em> The <em>iOS</em> agent only monitors your app while it is in the foreground. The agent does not <em>monitor</em> background services while the app is closed. For more information"
      },
      "id": "6044196064441f4f10378f04"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/configuration/upload-dsyms-bitcode-apps": [
    {
      "sections": [
        "iOS agent configuration and feature flags",
        "Enable or disable feature flags",
        "Crash and error reporting feature flag",
        "NRFeatureFlag_CrashReporting",
        "NRFeatureFlag_HandledExceptionEvents",
        "Distributed tracing",
        "NRFeatureFlag_DistributedTracing",
        "Interactions feature flags",
        "NRFeatureFlag_DefaultInteractions",
        "NRFeatureFlag_InteractionTracing",
        "NRFeatureFlag_SwiftInteractionTracing",
        "Caution",
        "Networking feature flags",
        "NRFeatureFlag_ExperimentalNetworkingInstrumentation",
        "NRFeatureFlag_NSURLSessionInstrumentation",
        "NRFeatureFlag_NetworkRequestEvents",
        "NRFeatureFlag_RequestErrorEvents",
        "NRFeatureFlag_HttpResponseBodyCapture"
      ],
      "title": "iOS agent configuration and feature flags",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "538f198af51ca5659916c98e634f1142ec387bca",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/ios-agent-configuration-feature-flags/",
      "published_at": "2021-12-30T07:47:01Z",
      "updated_at": "2021-11-05T14:19:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's iOS agent provides configuration settings to change the default behavior of the agent. If used, implement these flags just before calling: Objective-C: +[NewRelic startWithApplicationToken:] Swift: NewRelic.start(withApplicationToken:) Enable or disable feature flags To configure feature flags, use the following method defined in NewRelic.h: iOS language Procedure Objective-C In Objective-C, these features are bitmasked, so you can use a | to enable or disable multiple features at the same time. Enable a feature flag: +[NewRelic enableFeatures:(NRMAFeatureFlags)flags]; Copy Disable a feature flag: +[NewRelic disableFeatures:(NRMAFeatureFlags)flags]; Copy Here is an example where: Interaction tracing and experimental networking instrumentation are enabled. NSURLSession instrumentation and crash reporting are disabled. [NewRelic enableFeatures:NRFeatureFlag_SwiftInteractionTracing | NRFeatureFlag_ExperimentalNetworkingInstrumentation]; [NewRelic disableFeatures:NRFeatureFlag_NSURLSessionInstrumentation | NRFeatureFlag_CrashReporting]; [NewRelic startWithApplicationToken:...]; Copy Swift Enable a feature flag: NewRelic.enableFeatures(NRMAFeatureFlags.[NRMAFeatureFlag]) Copy Disable a feature flag: NewRelic.disableFeatures(NRMAFeatureFlags.[NRMAFeatureFlag]) Copy Example to disable interaction tracing: NewRelic.disableFeatures(NRMAFeatureFlags.NRFeatureFlag_DefaultInteractions) Copy Crash and error reporting feature flag If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_CrashReporting Enable (default) or disable crash reporting, which appears on the Crash analysis page. Type Boolean Default true NRFeatureFlag_HandledExceptionEvents Globally enable (default) or disable recording handled exceptions events, which appear on the Handled exception page. Type Boolean Default true Distributed tracing NRFeatureFlag_DistributedTracing Enable or disable the adding of distributed tracing headers to network requests. Refer to How New Relic distributed tracing works for more information on distributed tracing in mobile apps. Type Boolean Default true Interactions feature flags If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_DefaultInteractions Enable (default) or disable interaction tracing only for default instrumented classes and methods. Custom interactions will be reported. The traces will appear on the Interactions page. Type Boolean Default true NRFeatureFlag_InteractionTracing Globally enable (default) or disable interaction traces, which appear on the Interactions page. Interaction tracing will be disabled after the agent has started. Interactions for any activity or methods executed prior to starting the agent may still appear on the Interactions page. Type Boolean Default true NRFeatureFlag_SwiftInteractionTracing Caution Before enabling this feature, see Enable Swift interaction traces. If proper steps are not taken, enabling this feature may cause instability. Enable or disable (default) interaction tracing for Swift code. The traces appear on the Interactions page. This feature will always be disabled if NRFeatureFlag_InteractionTracing is disabled. Type Boolean Default false Networking feature flags If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_ExperimentalNetworkingInstrumentation Caution Enabling this feature flag call may decrease the stability of applications. Avoid using unless instructed by New Relic. Enable or disable (default) experimental networking instrumentation. This forces all NSURLConnection network requests through the NRMAURProtocol. Type Boolean Default false NRFeatureFlag_NSURLSessionInstrumentation Enable (default) or disable networking instrumentation for NSURLSession. These URL traces are sent to the HTTP Requests page. Type Boolean Default true NRFeatureFlag_NetworkRequestEvents Enable or disable (default) networking instrumentation. This sends the HTTP response data as MobileRequest events. Available for iOS Agent version 5.14.0 and higher Type Boolean Default true - Enabled by default as of 6.0.0 NRFeatureFlag_RequestErrorEvents Enable (default) or disable HTTP request error event generation of instrumented network calls that result in an error or failure. These events are reported as MobileRequestError events. Available for iOS Agent version 5.11.0 and higher Type Boolean Default true NRFeatureFlag_HttpResponseBodyCapture Enable or disable capture of HTTP response bodies for HTTP error traces, and MobileRequestError events. Type Boolean Default true",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.28207,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> agent <em>configuration</em> and feature flags",
        "sections": "<em>iOS</em> agent <em>configuration</em> and feature flags",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> agent provides <em>configuration</em> settings to change the default behavior of the agent. If used, implement these flags just before calling: Objective-C: +[<em>NewRelic</em> startWithApplicationToken:] Swift: <em>NewRelic</em>.start(withApplicationToken:) Enable or disable feature flags To configure"
      },
      "id": "619eaa7e28ccbc1559b9b002"
    },
    {
      "sections": [
        "iOS agent compatibility and requirements",
        "Foreground monitoring",
        "iOS requirements",
        "Testing is not supported",
        "Potential method replacement conflicts"
      ],
      "title": "iOS agent compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "544e062fdc57c4545c2f36b54b38f95b30b3c25e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/new-relic-ios-compatibility-requirements/",
      "published_at": "2021-12-30T11:17:44Z",
      "updated_at": "2021-12-19T19:52:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install and configure the iOS agent, follow these guidelines for compatibility and other requirements. Foreground monitoring The iOS agent only monitors your app while it is in the foreground. The agent does not monitor background services while the app is closed. For more information, see our Mobile data privacy and security documentation. iOS requirements Make sure your iOS app meets these requirements: Component iOS application requirements Operating system iOS 9 or higher For Bitcode support, use SDK version 5.3.0 or higher. API/SDK NSURLConnection and AFNetworking are supported. NSURLSession supports upload and data tags only. ASIHttpRequest networking APIs are deprecated as of iOS agent version 5.8.2. Network traffic for UIWebView and WKWebView is supported. However, WKWebView Transfer size and Http errors are not supported. Languages Objective-C Swift: Works with both network traces and crash reporting, but no interaction traces by default. Interaction traces must be enabled for Swift. Devices Any iOS compatible device: iPhones, iPads, etc. File sizes The agent adds about 2 to 12 megabytes to your iOS release app, depending on platform build. Architectures ARM 64-bit. SHA-2 As a standard security measure for data collection, New Relic requires that your application server supports SHA-2 (256-bit). SHA-1 is not supported. Xcode To take advantage of New Relic's iOS features, make sure you have the latest version of Xcode. arm64e support To be able to properly symbolicate crashes from devices with arm64e architectures, make sure your Xcode settings are enabled for pointer authentication. For more information, see the Apple developer documentation. CocoaPods In order to use the latest XCFramework Agent, use CocoaPods version 1.10.1 or higher. Testing is not supported Our agents are designed and tested to work in a normal app lifecycle. New Relic does not support running any testing environment on applications with the agent. Testing can cause conflicts and unpredictable behavior. Potential method replacement conflicts Our iOS agent utilizes method replacement during run time. This may result in a conflict with other libraries that also implement method replacement, such as ReactiveCocoa, Firebase, Aspects, and AppleGuice.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.62035,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> agent compatibility and requirements",
        "sections": "<em>iOS</em> agent compatibility and requirements",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Before you install and configure the <em>iOS</em> agent, follow these guidelines for compatibility and other requirements. Foreground <em>monitoring</em> The <em>iOS</em> agent only monitors your app while it is in the foreground. The agent does not <em>monitor</em> background services while the app is closed. For more information"
      },
      "id": "6044196064441f4f10378f04"
    },
    {
      "sections": [
        "Retrieve dSYMs for Bitcode apps",
        "Identify missing dSYMs",
        "Download dSYM files using iTunes Connect",
        "Download dSYM files using Xcode's app archive",
        "Upload dSYMs"
      ],
      "title": "Retrieve dSYMs for Bitcode apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "34e375873e36095062eccef6d99f26be7562308f",
      "image": "https://docs.newrelic.com/static/041368cdc60d9252ad80c2c37321b805/ec3e2/screen-dsym2.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/retrieve-dsyms-bitcode-apps/",
      "published_at": "2021-12-30T09:17:01Z",
      "updated_at": "2021-07-09T19:35:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Bitcode is a feature that gives Apple the ability to re-compile iOS and tvOS applications for specific users' hardware. This provides a smaller download size for end users. For more about this process, see Apple's Bitcode and app thinning documentation. When Apple compiles an app, the dSYM files are also compiled. For New Relic to be able to symbolicate crashes of your Bitcode-enabled app, these dSYM files need to be downloaded from Apple and then uploaded to New Relic. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: from the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Download dSYM files using iTunes Connect To download the dSYM files you need for your app: Log in to Apple iTunes Connect. Select My Apps > (selected app) > Activity. From the list of builds for your application, select the build number you need for the dSYM. Select Download dSYM. Then, to upload the resulting zip file directly to New Relic: Follow the instructions to manually upload dSYM, and skip step 1. Unpack one dSYM contained in this zip file to retrieve a build UUID that you can upload. (Follow the last step in the manual upload instructions.) Once New Relic receives the zip file, the build UUIDs for all other dSYMs contained in that zip file will be identified. Download dSYM files using Xcode's app archive Use the app version and build number to identify the applicable app archive in the Xcode Organizer and download the dSYMs. Using Xcode to download dSYMs: From the Archives tab, select the app and version/build, then select Download dSYMs. Open the Xcode Organizer: From the Xcode menu, select Window > Organizer > Archives > (select a mobile app). From Version, select the archive that matches the app version (listed first) and build number (following the app version in parentheses). Select Download dSYMs. The dSYMs will be downloaded from Apple if available and if the file names contain a series of letters and numbers. If the dSYM files are named after the the dependencies in your project, the download will not be successful. Upload dSYMs Once you have located the dSYMs, follow the instructions to upload a dSYM for each zipped dSYM.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.5055,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Identify</em> missing dSYMs",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Bitcode is a feature that gives Apple the ability to re-compile <em>iOS</em> and tv<em>OS</em> applications for specific users&#x27; hardware. This provides a smaller download size for end users. For more about this process, see Apple&#x27;s Bitcode and app thinning documentation. When Apple compiles an app, the dSYM files"
      },
      "id": "6044144228ccbc04a2303885"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios": [
    {
      "sections": [
        "iOS agent compatibility and requirements",
        "Foreground monitoring",
        "iOS requirements",
        "Testing is not supported",
        "Potential method replacement conflicts"
      ],
      "title": "iOS agent compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "544e062fdc57c4545c2f36b54b38f95b30b3c25e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/new-relic-ios-compatibility-requirements/",
      "published_at": "2021-12-30T11:17:44Z",
      "updated_at": "2021-12-19T19:52:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install and configure the iOS agent, follow these guidelines for compatibility and other requirements. Foreground monitoring The iOS agent only monitors your app while it is in the foreground. The agent does not monitor background services while the app is closed. For more information, see our Mobile data privacy and security documentation. iOS requirements Make sure your iOS app meets these requirements: Component iOS application requirements Operating system iOS 9 or higher For Bitcode support, use SDK version 5.3.0 or higher. API/SDK NSURLConnection and AFNetworking are supported. NSURLSession supports upload and data tags only. ASIHttpRequest networking APIs are deprecated as of iOS agent version 5.8.2. Network traffic for UIWebView and WKWebView is supported. However, WKWebView Transfer size and Http errors are not supported. Languages Objective-C Swift: Works with both network traces and crash reporting, but no interaction traces by default. Interaction traces must be enabled for Swift. Devices Any iOS compatible device: iPhones, iPads, etc. File sizes The agent adds about 2 to 12 megabytes to your iOS release app, depending on platform build. Architectures ARM 64-bit. SHA-2 As a standard security measure for data collection, New Relic requires that your application server supports SHA-2 (256-bit). SHA-1 is not supported. Xcode To take advantage of New Relic's iOS features, make sure you have the latest version of Xcode. arm64e support To be able to properly symbolicate crashes from devices with arm64e architectures, make sure your Xcode settings are enabled for pointer authentication. For more information, see the Apple developer documentation. CocoaPods In order to use the latest XCFramework Agent, use CocoaPods version 1.10.1 or higher. Testing is not supported Our agents are designed and tested to work in a normal app lifecycle. New Relic does not support running any testing environment on applications with the agent. Testing can cause conflicts and unpredictable behavior. Potential method replacement conflicts Our iOS agent utilizes method replacement during run time. This may result in a conflict with other libraries that also implement method replacement, such as ReactiveCocoa, Firebase, Aspects, and AppleGuice.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.35579,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> agent compatibility and requirements",
        "sections": "<em>iOS</em> agent compatibility and requirements",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Before you install and configure the <em>iOS</em> agent, follow these guidelines for compatibility and other requirements. Foreground <em>monitoring</em> The <em>iOS</em> agent only monitors your app while it is in the foreground. The agent does not <em>monitor</em> background services while the app is closed. For more information"
      },
      "id": "6044196064441f4f10378f04"
    },
    {
      "sections": [
        "CocoaPods installation",
        "Install your iOS application",
        "Configure using Objective-C",
        "Important",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "9a062745f628f66e34f865a47d58713f12e59ac9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/cocoapods-installation/",
      "published_at": "2021-12-30T07:44:57Z",
      "updated_at": "2021-10-01T20:15:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply to iOS apps using Cocoapods. For other types, see iOS installation and configuration. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps list, select Add a new app. From the Get Started page, select iOS as the platform for mobile monitoring. Type a name for your mobile app, then select Continue. If your installation does not automatically include the prefix header, follow the steps to add the prefix header to your project. Continue with the steps to configure New Relic for mobile monitoring. Configure using Objective-C These procedures to configure your iOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your APP_NAME-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: [NewRelic startWithApplicationToken:@\"APP_TOKEN\"]; Copy Important The agent must be on the first line of didFinishLaunchingWithOptions and run on the main thread to ensure proper instrumentation. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Configure using Swift These procedures to configure your iOS app with CocoaPods and Swift also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your APP_NAME-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: NewRelic.start(withApplicationToken:\"APP_TOKEN\") Copy Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling NewRelic.start(withApplicationToken): [NRLogger setLogLevels:NRLogLevelALL]; Copy For Swift apps: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.83458,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods <em>installation</em>",
        "sections": "<em>Install</em> your <em>iOS</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps list, select Add a <em>new</em> app. From the <em>Get</em> <em>Started</em> page, select <em>iOS</em> as the platform for <em>mobile</em> <em>monitoring</em>. Type a name for your <em>mobile</em> app, then select Continue"
      },
      "id": "603ea15d64441fef3d4e8867"
    },
    {
      "sections": [
        "tvOS installation and configuration",
        "Tip",
        "Installing your tvOS application",
        "Configuring your tvOS application",
        "Executing a demo crash (optional)",
        "Changing the logging level (optional)"
      ],
      "title": "tvOS installation and configuration",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "04798a275a7591bfbafb5437194cfbab4b33d8e3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/tvos-installation-configuration/",
      "published_at": "2021-12-30T03:33:41Z",
      "updated_at": "2021-07-09T10:39:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to install and configure the tvOS agent. Tip tvOS apps using Cocoapods have separate installation procedures. Installing your tvOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor. For Admins with existing New Relic accounts, follow these steps to install and configure your application. (If you don't have a New Relic account, signup at newrelic.com/signup—it's free, forever.) Go to one.newrelic.com and click Mobile. If applicable: From the Mobile Apps list, select Add a new app From the Get Started page, select tvOS as the platform for mobile monitoring. Type a name for your mobile app, and select Continue. Configuring your tvOS application These procedures to configure your tvOS app are also available on the Get Started page in the mobile monitoring UI. Download and unzip the tvOS SDK. To add the New Relic tvOS Mobile Framework to your Xcode project: Use Finder to drag the NewRelicAgentTVOS.framework folder into your Xcode project, and drop it onto your Project in the Project Navigator window. Follow the prompts to copy items into destination and to create folder references. Add the SystemConfiguration.framework, libc++.tbd, and libz.tbd libraries to your Linker settings. To start the agent: Import the tvOS agent header at the top of your prefix.pch. Add + [ NewRelic startWithApplicationToken: < appToken>] to the top of -application:didFinishLaunchingWithOptions: in your AppDelegate.m using the unique application token that is automatically generated. Add a build script to your target's Build Phases and paste the following, replacing PUT_NEW_RELIC_APP_TOKEN_HERE with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, and then run it in the simulator or other device. Within a few minutes you will begin to see data for your iOS app: Go to one.newrelic.com > Mobile > (selected app). If you don't, see No data appears. Executing a demo crash (optional) If you have trouble getting your app to crash, the New Relic agent provides an API to execute a demo crash. Recommendation: Add one of these lines of code to a button click event handler as applicable: [NewRelic crashNow]; Copy OR [NewRelic crashNow:@\"<reason>\"]; Copy Changing the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling startWithApplicationToken: [NRLogger setLogLevels:NRLogLevelALL]; Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.58992,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "tvOS <em>installation</em> and configuration",
        "sections": "tvOS <em>installation</em> and configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": ". If applicable: From the <em>Mobile</em> Apps list, select Add a <em>new</em> app From the <em>Get</em> <em>Started</em> page, select tv<em>OS</em> as the platform for <em>mobile</em> <em>monitoring</em>. Type a name for your <em>mobile</em> app, and select Continue. Configuring your tv<em>OS</em> application These procedures to configure your tv<em>OS</em> app are also available on the <em>Get</em>"
      },
      "id": "60441ac5e7b9d26bb55799b6"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/get-started/new-relic-ios-compatibility-requirements": [
    {
      "sections": [
        "CocoaPods installation",
        "Install your iOS application",
        "Configure using Objective-C",
        "Important",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "9a062745f628f66e34f865a47d58713f12e59ac9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/cocoapods-installation/",
      "published_at": "2021-12-30T07:44:57Z",
      "updated_at": "2021-10-01T20:15:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply to iOS apps using Cocoapods. For other types, see iOS installation and configuration. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps list, select Add a new app. From the Get Started page, select iOS as the platform for mobile monitoring. Type a name for your mobile app, then select Continue. If your installation does not automatically include the prefix header, follow the steps to add the prefix header to your project. Continue with the steps to configure New Relic for mobile monitoring. Configure using Objective-C These procedures to configure your iOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your APP_NAME-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: [NewRelic startWithApplicationToken:@\"APP_TOKEN\"]; Copy Important The agent must be on the first line of didFinishLaunchingWithOptions and run on the main thread to ensure proper instrumentation. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Configure using Swift These procedures to configure your iOS app with CocoaPods and Swift also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your APP_NAME-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: NewRelic.start(withApplicationToken:\"APP_TOKEN\") Copy Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling NewRelic.start(withApplicationToken): [NRLogger setLogLevels:NRLogLevelALL]; Copy For Swift apps: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.83458,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods <em>installation</em>",
        "sections": "<em>Install</em> your <em>iOS</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps list, select Add a <em>new</em> app. From the <em>Get</em> <em>Started</em> page, select <em>iOS</em> as the platform for <em>mobile</em> <em>monitoring</em>. Type a name for your <em>mobile</em> app, then select Continue"
      },
      "id": "603ea15d64441fef3d4e8867"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-12-30T02:13:19Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.75381,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "tvOS installation and configuration",
        "Tip",
        "Installing your tvOS application",
        "Configuring your tvOS application",
        "Executing a demo crash (optional)",
        "Changing the logging level (optional)"
      ],
      "title": "tvOS installation and configuration",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "04798a275a7591bfbafb5437194cfbab4b33d8e3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/tvos-installation-configuration/",
      "published_at": "2021-12-30T03:33:41Z",
      "updated_at": "2021-07-09T10:39:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to install and configure the tvOS agent. Tip tvOS apps using Cocoapods have separate installation procedures. Installing your tvOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor. For Admins with existing New Relic accounts, follow these steps to install and configure your application. (If you don't have a New Relic account, signup at newrelic.com/signup—it's free, forever.) Go to one.newrelic.com and click Mobile. If applicable: From the Mobile Apps list, select Add a new app From the Get Started page, select tvOS as the platform for mobile monitoring. Type a name for your mobile app, and select Continue. Configuring your tvOS application These procedures to configure your tvOS app are also available on the Get Started page in the mobile monitoring UI. Download and unzip the tvOS SDK. To add the New Relic tvOS Mobile Framework to your Xcode project: Use Finder to drag the NewRelicAgentTVOS.framework folder into your Xcode project, and drop it onto your Project in the Project Navigator window. Follow the prompts to copy items into destination and to create folder references. Add the SystemConfiguration.framework, libc++.tbd, and libz.tbd libraries to your Linker settings. To start the agent: Import the tvOS agent header at the top of your prefix.pch. Add + [ NewRelic startWithApplicationToken: < appToken>] to the top of -application:didFinishLaunchingWithOptions: in your AppDelegate.m using the unique application token that is automatically generated. Add a build script to your target's Build Phases and paste the following, replacing PUT_NEW_RELIC_APP_TOKEN_HERE with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, and then run it in the simulator or other device. Within a few minutes you will begin to see data for your iOS app: Go to one.newrelic.com > Mobile > (selected app). If you don't, see No data appears. Executing a demo crash (optional) If you have trouble getting your app to crash, the New Relic agent provides an API to execute a demo crash. Recommendation: Add one of these lines of code to a button click event handler as applicable: [NewRelic crashNow]; Copy OR [NewRelic crashNow:@\"<reason>\"]; Copy Changing the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling startWithApplicationToken: [NRLogger setLogLevels:NRLogLevelALL]; Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.58992,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "tvOS <em>installation</em> and configuration",
        "sections": "tvOS <em>installation</em> and configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": ". If applicable: From the <em>Mobile</em> Apps list, select Add a <em>new</em> app From the <em>Get</em> <em>Started</em> page, select tv<em>OS</em> as the platform for <em>mobile</em> <em>monitoring</em>. Type a name for your <em>mobile</em> app, and select Continue. Configuring your tv<em>OS</em> application These procedures to configure your tv<em>OS</em> app are also available on the <em>Get</em>"
      },
      "id": "60441ac5e7b9d26bb55799b6"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/installation/cocoapods-installation": [
    {
      "sections": [
        "iOS agent compatibility and requirements",
        "Foreground monitoring",
        "iOS requirements",
        "Testing is not supported",
        "Potential method replacement conflicts"
      ],
      "title": "iOS agent compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "544e062fdc57c4545c2f36b54b38f95b30b3c25e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/new-relic-ios-compatibility-requirements/",
      "published_at": "2021-12-30T11:17:44Z",
      "updated_at": "2021-12-19T19:52:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install and configure the iOS agent, follow these guidelines for compatibility and other requirements. Foreground monitoring The iOS agent only monitors your app while it is in the foreground. The agent does not monitor background services while the app is closed. For more information, see our Mobile data privacy and security documentation. iOS requirements Make sure your iOS app meets these requirements: Component iOS application requirements Operating system iOS 9 or higher For Bitcode support, use SDK version 5.3.0 or higher. API/SDK NSURLConnection and AFNetworking are supported. NSURLSession supports upload and data tags only. ASIHttpRequest networking APIs are deprecated as of iOS agent version 5.8.2. Network traffic for UIWebView and WKWebView is supported. However, WKWebView Transfer size and Http errors are not supported. Languages Objective-C Swift: Works with both network traces and crash reporting, but no interaction traces by default. Interaction traces must be enabled for Swift. Devices Any iOS compatible device: iPhones, iPads, etc. File sizes The agent adds about 2 to 12 megabytes to your iOS release app, depending on platform build. Architectures ARM 64-bit. SHA-2 As a standard security measure for data collection, New Relic requires that your application server supports SHA-2 (256-bit). SHA-1 is not supported. Xcode To take advantage of New Relic's iOS features, make sure you have the latest version of Xcode. arm64e support To be able to properly symbolicate crashes from devices with arm64e architectures, make sure your Xcode settings are enabled for pointer authentication. For more information, see the Apple developer documentation. CocoaPods In order to use the latest XCFramework Agent, use CocoaPods version 1.10.1 or higher. Testing is not supported Our agents are designed and tested to work in a normal app lifecycle. New Relic does not support running any testing environment on applications with the agent. Testing can cause conflicts and unpredictable behavior. Potential method replacement conflicts Our iOS agent utilizes method replacement during run time. This may result in a conflict with other libraries that also implement method replacement, such as ReactiveCocoa, Firebase, Aspects, and AppleGuice.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.6203,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> agent compatibility and requirements",
        "sections": "<em>iOS</em> agent compatibility and requirements",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Before you install and configure the <em>iOS</em> agent, follow these guidelines for compatibility and other requirements. Foreground <em>monitoring</em> The <em>iOS</em> agent only monitors your app while it is in the foreground. The agent does not <em>monitor</em> background services while the app is closed. For more information"
      },
      "id": "6044196064441f4f10378f04"
    },
    {
      "sections": [
        "iOS manual installation",
        "Install your iOS application",
        "Add the New Relic framework to your app",
        "Important",
        "Optional: Execute a demo crash",
        "Optional: Change the logging level"
      ],
      "title": "iOS manual installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "0a674eb7f3756cd5d124c6dcf2344edf38e40a8a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/ios-manual-installation/",
      "published_at": "2021-12-30T03:31:08Z",
      "updated_at": "2021-07-27T15:09:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To install and configure New Relic functionality with your iOS applications, follow these procedures. If your iOS app uses Cocoapods, follow the Cocoapods installation procedures. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps index, select Add a new app. From the Get started page, select XCFramework as the platform for mobile monitoring. Type a name for your mobile app, and select Continue. Continue with the steps to configure New Relic. Add the New Relic framework to your app Download and unzip the iOS SDK for New Relic. To add the New Relic framework to your Xcode project: Use Finder to drag the NewRelicAgent.framework folder into your Xcode project, and drop it onto your project in the Project navigator window, under Frameworks, Libraries, and Embedded Content. Make sure Embed & Sign is selected under the Embed dropdown menu. Implement the agent using the appropriate method: Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Language Procedure Objective-C To start the agent: Import the New Relic header at the top of your prefix.pch. Add +[NewRelic startWithApplicationToken:@\"<appToken>\"] to the top of -application:didFinishLaunchingWithOptions: in your AppDelegate.m, using the unique application token that is automatically generated. Swift Create a bridging header file: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. Delete Placeholder.m. Import the New Relic agent by adding #import \"NewRelic/NewRelic.h\" to the top of MyApp-Bridging-Header.h. Add NewRelic.start(withApplicationToken: \">appToken>\") to the top of application(_:didFinishLaunchingWithOptions:) in your AppDelegate.swift using the unique application token that is automatically generated. Add a build script to your target's Build Phases. Ensure the new build script is the very last build phase, then paste the following, replacing PUT_NEW_RELIC_APP_TOKEN_HERE with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, and then run it in the simulator or other device. Optional: Execute a demo crash If you have trouble getting your app to crash, the New Relic agent provides an API to execute a demo crash. Recommendation: Add one of these lines of code to a button click event handler as applicable: Language Code Objective-C Crash: [NewRelic crashNow]; Copy Crash with log message: [NewRelic crashNow:@\"<reason>\"]; Copy Swift Crash: NewRelic.crashNow() Copy Crash with log message: NewRelic.crashNow(_ message:) Copy Optional: Change the logging level Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add the following method: Language Code Objective-C Just before calling startWithApplicationToken in AppDelegate.m, add: [NRLogger setLogLevels:NRLogLevelALL]; Copy Swift Just before calling start(withApplicationToken:) in AppDelegate.swift, add: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.833,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> manual <em>installation</em>",
        "sections": "<em>iOS</em> manual <em>installation</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " token. This is a 40-character hexadecimal string for authenticating each <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps index, select Add a <em>new</em> app. From the Get started page, select XCFramework"
      },
      "id": "603ea44864441f80904e8899"
    },
    {
      "sections": [
        "Upgrade the iOS agent",
        "Replace your iOS framework"
      ],
      "title": "Upgrade the iOS agent",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "f51e93fbddfa6fd7b531f2b8dc071cfebb8c7fc9",
      "image": "https://docs.newrelic.com/static/ce6f593163d7f9a6c7a72509d4d947bd/8c557/screen-mobile-monitoring-upgrade-ios_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/upgrade-new-relic-mobiles-ios-sdk/",
      "published_at": "2021-12-30T06:06:39Z",
      "updated_at": "2021-07-09T14:20:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You must be an account Admin to install, configure, and upgrade the iOS agent. For information about the latest version, refer to the release notes. Replace your iOS framework Admins: You must replace the earlier version of your iOS agent framework before upgrading to a newer version of the iOS SDK. Here is an example of the workflow to remove your existing iOS agent framework so you can replace it with a newer version. From the Project Navigator (CMD 1) in Xcode, search for NewRelicAgent.framework. Right-click or control-click NewRelicAgent.framework, and select Show in Finder. Drag NewRelicAgent.framework to the trash. Verify that the Xcode project highlights the reference to NewRelicAgent.framework in red. Right-click or control-click NewRelicAgent.framework, and select Delete to remove the obsolete reference from the project. Continue with the standard installation procedures for iOS app monitoring at one.newrelic.com > Mobile > (select an app) > Settings > Installation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.96472,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upgrade the <em>iOS</em> agent",
        "sections": "Upgrade the <em>iOS</em> agent",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>NewRelic</em>Agent.framework to the trash. Verify that the Xcode project highlights the reference to <em>NewRelic</em>Agent.framework in red. Right-click or control-click <em>NewRelic</em>Agent.framework, and select Delete to remove the obsolete reference from the project. Continue with the standard <em>installation</em> procedures for <em>iOS</em> app <em>monitoring</em> at one.newrelic.com &gt; <em>Mobile</em> &gt; (select an app) &gt; Settings &gt; <em>Installation</em>."
      },
      "id": "603eab6a196a672442a83da7"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/installation/ios-manual-installation": [
    {
      "sections": [
        "CocoaPods installation",
        "Install your iOS application",
        "Configure using Objective-C",
        "Important",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "9a062745f628f66e34f865a47d58713f12e59ac9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/cocoapods-installation/",
      "published_at": "2021-12-30T07:44:57Z",
      "updated_at": "2021-10-01T20:15:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply to iOS apps using Cocoapods. For other types, see iOS installation and configuration. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps list, select Add a new app. From the Get Started page, select iOS as the platform for mobile monitoring. Type a name for your mobile app, then select Continue. If your installation does not automatically include the prefix header, follow the steps to add the prefix header to your project. Continue with the steps to configure New Relic for mobile monitoring. Configure using Objective-C These procedures to configure your iOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your APP_NAME-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: [NewRelic startWithApplicationToken:@\"APP_TOKEN\"]; Copy Important The agent must be on the first line of didFinishLaunchingWithOptions and run on the main thread to ensure proper instrumentation. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Configure using Swift These procedures to configure your iOS app with CocoaPods and Swift also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your APP_NAME-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: NewRelic.start(withApplicationToken:\"APP_TOKEN\") Copy Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling NewRelic.start(withApplicationToken): [NRLogger setLogLevels:NRLogLevelALL]; Copy For Swift apps: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.69351,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods <em>installation</em>",
        "sections": "<em>Install</em> your <em>iOS</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps list, select Add a <em>new</em> app. From the Get Started page, select <em>iOS</em> as the platform for <em>mobile</em> <em>monitoring</em>. Type a name for your <em>mobile</em> app, then select Continue"
      },
      "id": "603ea15d64441fef3d4e8867"
    },
    {
      "sections": [
        "iOS agent compatibility and requirements",
        "Foreground monitoring",
        "iOS requirements",
        "Testing is not supported",
        "Potential method replacement conflicts"
      ],
      "title": "iOS agent compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "544e062fdc57c4545c2f36b54b38f95b30b3c25e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/new-relic-ios-compatibility-requirements/",
      "published_at": "2021-12-30T11:17:44Z",
      "updated_at": "2021-12-19T19:52:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install and configure the iOS agent, follow these guidelines for compatibility and other requirements. Foreground monitoring The iOS agent only monitors your app while it is in the foreground. The agent does not monitor background services while the app is closed. For more information, see our Mobile data privacy and security documentation. iOS requirements Make sure your iOS app meets these requirements: Component iOS application requirements Operating system iOS 9 or higher For Bitcode support, use SDK version 5.3.0 or higher. API/SDK NSURLConnection and AFNetworking are supported. NSURLSession supports upload and data tags only. ASIHttpRequest networking APIs are deprecated as of iOS agent version 5.8.2. Network traffic for UIWebView and WKWebView is supported. However, WKWebView Transfer size and Http errors are not supported. Languages Objective-C Swift: Works with both network traces and crash reporting, but no interaction traces by default. Interaction traces must be enabled for Swift. Devices Any iOS compatible device: iPhones, iPads, etc. File sizes The agent adds about 2 to 12 megabytes to your iOS release app, depending on platform build. Architectures ARM 64-bit. SHA-2 As a standard security measure for data collection, New Relic requires that your application server supports SHA-2 (256-bit). SHA-1 is not supported. Xcode To take advantage of New Relic's iOS features, make sure you have the latest version of Xcode. arm64e support To be able to properly symbolicate crashes from devices with arm64e architectures, make sure your Xcode settings are enabled for pointer authentication. For more information, see the Apple developer documentation. CocoaPods In order to use the latest XCFramework Agent, use CocoaPods version 1.10.1 or higher. Testing is not supported Our agents are designed and tested to work in a normal app lifecycle. New Relic does not support running any testing environment on applications with the agent. Testing can cause conflicts and unpredictable behavior. Potential method replacement conflicts Our iOS agent utilizes method replacement during run time. This may result in a conflict with other libraries that also implement method replacement, such as ReactiveCocoa, Firebase, Aspects, and AppleGuice.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.6203,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> agent compatibility and requirements",
        "sections": "<em>iOS</em> agent compatibility and requirements",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Before you install and configure the <em>iOS</em> agent, follow these guidelines for compatibility and other requirements. Foreground <em>monitoring</em> The <em>iOS</em> agent only monitors your app while it is in the foreground. The agent does not <em>monitor</em> background services while the app is closed. For more information"
      },
      "id": "6044196064441f4f10378f04"
    },
    {
      "sections": [
        "Upgrade the iOS agent",
        "Replace your iOS framework"
      ],
      "title": "Upgrade the iOS agent",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "f51e93fbddfa6fd7b531f2b8dc071cfebb8c7fc9",
      "image": "https://docs.newrelic.com/static/ce6f593163d7f9a6c7a72509d4d947bd/8c557/screen-mobile-monitoring-upgrade-ios_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/upgrade-new-relic-mobiles-ios-sdk/",
      "published_at": "2021-12-30T06:06:39Z",
      "updated_at": "2021-07-09T14:20:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You must be an account Admin to install, configure, and upgrade the iOS agent. For information about the latest version, refer to the release notes. Replace your iOS framework Admins: You must replace the earlier version of your iOS agent framework before upgrading to a newer version of the iOS SDK. Here is an example of the workflow to remove your existing iOS agent framework so you can replace it with a newer version. From the Project Navigator (CMD 1) in Xcode, search for NewRelicAgent.framework. Right-click or control-click NewRelicAgent.framework, and select Show in Finder. Drag NewRelicAgent.framework to the trash. Verify that the Xcode project highlights the reference to NewRelicAgent.framework in red. Right-click or control-click NewRelicAgent.framework, and select Delete to remove the obsolete reference from the project. Continue with the standard installation procedures for iOS app monitoring at one.newrelic.com > Mobile > (select an app) > Settings > Installation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.96472,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upgrade the <em>iOS</em> agent",
        "sections": "Upgrade the <em>iOS</em> agent",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>NewRelic</em>Agent.framework to the trash. Verify that the Xcode project highlights the reference to <em>NewRelic</em>Agent.framework in red. Right-click or control-click <em>NewRelic</em>Agent.framework, and select Delete to remove the obsolete reference from the project. Continue with the standard <em>installation</em> procedures for <em>iOS</em> app <em>monitoring</em> at one.newrelic.com &gt; <em>Mobile</em> &gt; (select an app) &gt; Settings &gt; <em>Installation</em>."
      },
      "id": "603eab6a196a672442a83da7"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/installation/spm-installation": [
    {
      "sections": [
        "PHP agent installation overview",
        "PHP components",
        "Install the agent",
        "Tip",
        "RedHat or CentOS",
        "Ubuntu or Debian",
        "Tar archive",
        "View logs for your APM and infrastructure data",
        "Install PHP with partnership accounts"
      ],
      "title": "PHP agent installation overview",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "Installation"
      ],
      "external_id": "09b58ebc9092c835d89eebc9cf97ca5cb95a2571",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/php-agent/installation/php-agent-installation-overview/",
      "published_at": "2021-12-30T23:51:38Z",
      "updated_at": "2021-11-15T18:40:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our PHP agent auto-instruments your code so you can start monitoring applications. You can use our guided installation for an automated install, or follow the instructions in this document to complete a basic PHP agent installation. Either way, you need a New Relic account. (It's free, forever.) Get an account Start guided install EU guided install PHP components Our PHP agent consists of two basic components: A PHP extension, which collects data from your application A local proxy daemon, which transmits the data to New Relic Your system's configuration components, including the web server, operating system, system permissions, PHP installation itself, package manager, etc., are all important factors during installation and configuration, because the agent is a part of that. For more information about supported PHP releases, frameworks, and other system requirements, see PHP compatibility and requirements. Install the agent Follow this general process to install the agent on your system. The agent installation package or tar archive includes the interactive newrelic-install script, which automates some installation tasks. Tip If your application is frequently inactive, we recommend you generate some data by interacting with the application or site. This will help ensure the agent initially connects. If you haven't already, create a New Relic account. It's free, forever. Ensure your system meets the agent's requirements, including appropriate system permissions. From your Account settings, copy your license key information. Install the agent package or tar archive on your system. RedHat or CentOS The most common way to install the agent on RedHat or CentOS is with the installation package (.rpm) and the package manager. You can tell the package manager to get it from the New Relic repository, or you can download the .rpm file directly from the New Relic website. Install the package with your preferred package manager (yum or rpm) and then run the newrelic-install script. Ubuntu or Debian Install the package either with apt-get or with dpkg commands. Typically, running the newrelic-install script is not required. Tar archive The .tar archive method is the most generic method you can use on all supported operating systems. Download the compressed tar archive for your system if any of these situations apply to you: Your operating system is not listed here. You are not using a package manager. Other methods are unsuccessful. Install the tar archive of the agent on any supported platform. Change the default application name to a meaningful name. Optional: Change other agent configuration settings to further customize your installation. Restart your web server (Apache, Nginx, PHP-FPM, etc.). Recommendation: To help ensure the PHP agent is initiated, especially if your application has infrequent activity, generate some data by using the app for a few seconds. Wait a few minutes for your application to send data to New Relic. Then, check your app's performance in the New Relic UI. View logs for your APM and infrastructure data You can also bring your logs and application's data together to make troubleshooting easier and faster. With logs in context, you can see log messages related to your errors and traces directly in your app's UI. You can also see logs in context of your infrastructure data, such as Kubernetes clusters. No need to switch to another UI page in New Relic One. Install PHP with partnership accounts Installation procedures may be different for admins who install the PHP agent through a New Relic partnership. For more information, see: AWS Heroku Magento Shared hosting providers Other partnership installation procedures Not all partners support PHP agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 211.8546,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "PHP agent <em>installation</em> overview",
        "sections": "PHP agent <em>installation</em> overview",
        "tags": "<em>Installation</em>",
        "body": ", operating system, system permissions, PHP <em>installation</em> itself, <em>package</em> <em>manager</em>, etc., are all important factors during <em>installation</em> and configuration, because the agent is a part of that. For more information about supported PHP releases, frameworks, and other system requirements, see PHP"
      },
      "id": "617e9d27e7b9d29455c04c8b"
    },
    {
      "sections": [
        "Install New Relic",
        "Install APM",
        "Install browser monitoring",
        "Install infrastructure monitoring",
        "Install mobile monitoring",
        "Install synthetic monitors",
        "Troubleshooting"
      ],
      "title": "Install New Relic ",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Install and configure"
      ],
      "external_id": "819ccfd8df22ff322271245ca0831bf53609b91f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/cross-product-functions/install-configure/install-new-relic/",
      "published_at": "2021-12-31T01:40:19Z",
      "updated_at": "2021-12-30T20:03:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you sign up for a New Relic account (it's free, forever!) and install any of our monitoring services, you can start working with your data. Get started quickly with our New Relic Instant Observability quickstarts. Alternatively, use our guided install. Here are links to instructions on how to install New Relic monitoring services: APM Browser Infrastructure Mobile Synthetic monitors Integrations for third-party telemetry services Data ingest APIs (metrics, events, logs, traces) Install APM C Go Java .NET For Windows .NET applications on IIS, use our guided install in New Relic One to get started with APM. If you're on an EU server, use our launcher for EU accounts instead. Node.js PHP Python Ruby Install browser monitoring See browser monitoring install. Install infrastructure monitoring Linux guided install for infrastructure monitoring Linux procedures for infrastructure monitoring Windows Kubernetes Prometheus On-host integrations (for services like NGINX, StatsD, MySQL, etc.) AWS cloud integrations Azure cloud integrations Google Cloud Platform Install mobile monitoring Android iOS Install synthetic monitors Synthetic monitoring doesn't require installation, except for its private minions feature. Troubleshooting You should start seeing your data in the New Relic UI after installing the agent, generating some traffic, and waiting a few minutes. If no data appears, follow our troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.36685,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> New Relic ",
        "sections": "<em>Install</em> New Relic",
        "tags": "<em>Install</em> and configure",
        "body": " monitoring Windows Kubernetes Prometheus On-host integrations (for services like NGINX, StatsD, MySQL, etc.) AWS cloud integrations Azure cloud integrations Google Cloud Platform Install mobile monitoring Android iOS Install synthetic monitors Synthetic monitoring doesn&#x27;t require <em>installation</em>, except"
      },
      "id": "61b8148ce7b9d22373ef3a8b"
    },
    {
      "sections": [
        "Install .NET agent for Linux",
        "Install overview",
        "Step 1. Download and install the agent",
        "Caution",
        "Install with apt (Debian, Linux Mint, or Ubuntu)",
        "Install with dpkg (Debian, Linux Mint, or Ubuntu)",
        "Install with rpm or yum (CentOS, Oracle Linux, or RHEL)",
        "Important",
        "Install with tarball",
        "Step 2. Enable the agent",
        "Set environment variables manually",
        "Start your app with run.sh",
        "Use setenv.sh",
        "Tip",
        "Step 3. View your data in New Relic"
      ],
      "title": "Install .NET agent for Linux",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Installation"
      ],
      "external_id": "be917224e43540ecd58100debfb696d8cebf23e5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/installation/install-net-agent-linux/",
      "published_at": "2021-12-31T02:27:19Z",
      "updated_at": "2021-11-06T23:46:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install and enable New Relic's .NET agent on Linux for application performance monitoring. Install overview The instructions in this document are for a standard .NET agent installation on Linux. However, some setups have specific install documentation that you should read first: ASP.NET Core Azure installations NuGet install Docker container install Step 1. Download and install the agent Caution Security notice: Make sure that the location where you install the .NET agent is configured to prevent unauthorized access. Before you can install, you need a New Relic account (It's free, forever!). Get an account To install the .NET agent on a Linux system with a package manager: Install the agent. These details are the same for all installations using a package manager: Install location: /usr/local/newrelic-netcore20-agent. The file newrelic-netcore20-agent-path.sh is placed in /etc/profile.d, and this will set the CORECLR_NEWRELIC_HOME environment variable on system start. The path to newrelic.config file is ${CORECLR_NEWRELIC_HOME}/newrelic.config. Follow the instructions for your package manager: Install with apt (Debian, Linux Mint, or Ubuntu) Configure the New Relic apt repository by adding deb http://apt.newrelic.com/debian/ newrelic non-free to /etc/apt/sources.list.d/newrelic.list: echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | sudo tee /etc/apt/sources.list.d/newrelic.list Copy Enable New Relic's GPG key to allow apt to find New Relic packages. To avoid possible errors about public keys, run this command as root: wget -O- https://download.newrelic.com/548C16BF.gpg | sudo apt-key add - Copy Update the local package list: sudo apt-get update Copy Install the agent: sudo apt-get install newrelic-netcore20-agent Copy Install with dpkg (Debian, Linux Mint, or Ubuntu) Go to download.newrelic.com/dot_net_agent/latest_release, and copy the URL that corresponds to your architecture and to the latest newrelic-netcore20-agent package. Download the package with wget, replacing https://LINK_TO_PACKAGE with the full URL of the package: wget -L https://LINK_TO_PACKAGE Copy Install the agent, replacing VERSION with the current version: sudo dpkg -i newrelic-netcore20-agent_VERSION_ARCHITECTURE.deb Copy Install with rpm or yum (CentOS, Oracle Linux, or RHEL) Important New Relic does not currently offer Linux rpm packages for ARM64, instead leverage the tarball to install on these platforms. Configure the New Relic rpm repository: sudo rpm -Uvh http://yum.newrelic.com/pub/newrelic/el5/x86_64/newrelic-repo-5-3.noarch.rpm cat << REPO | sudo tee \"/etc/yum.repos.d/newrelic-netcore20-agent.repo\" [newrelic-netcore20-agent-repo] name=New Relic .NET Core packages for Enterprise Linux baseurl=http://yum.newrelic.com/pub/newrelic/el7/\\$basearch enabled=1 gpgcheck=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-NewRelic REPO Copy Install the agent, replacing VERSION with the current version: Install with rpm: sudo rpm -i newrelic-netcore20-agent_VERSION.x86_64.rpm Copy Install with yum: sudo yum install newrelic-netcore20-agent Copy Install with tarball Go to download.newrelic.com/dot_net_agent/latest_release, and copy the URL that corresponds to your architecture and to the latest newrelic-netcore20-agent-VERSION.tar.gz package. Download the package with wget, replacing https://LINK_TO_PACKAGE with the full URL of the package: wget -L https://LINK_TO_PACKAGE Copy Extract the agent: tar xzf newrelic*.tar.gz Copy Move the newrelic-netcore20-agent directory to /usr/local or your preferred install location. Verify that the environment variable CORECLR_NEWRELIC_HOME points to the newrelic-netcore20-agent directory and that the directory is readable by monitored .NET processes. Important If CORECLR_NEWRELIC_HOME does not exist, create it and point it to the newrelic-netcore20-agent directory. Verify that the logs directory in the agent home directory is writeable by monitored .NET processes. Continue to step 2. Step 2. Enable the agent Use one of the following methods to set the environment variables that enable the agent and define your license key. For an ASP.NET Core app targeting .NET Core, use the environment variable method. Set environment variables manually You can configure your environment using a custom script. The script must define the variables before your app starts. Caution Set the environment variables for each application that you want to instrument. If you set these environment variables globally, you could instrument .NET processes other than your apps. Set the following environment variables, replacing PATH_TO_AGENT_DIRECTORY with the actual path to the .NET Core agent installation folder: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_NEWRELIC_HOME=PATH_TO_AGENT_DIRECTORY CORECLR_PROFILER_PATH=\"PATH_TO_AGENT_DIRECTORY/libNewRelicProfiler.so\" Copy Use one of the following methods to set your license key (required) and your app name (optional). Set via environment variable: NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Set in newrelic.config with the licenseKey and name elements. When setting the app name, give your app a meaningful name. Start your app with run.sh Use run.sh to start your app. For example: $CORECLR_NEWRELIC_HOME/run.sh dotnet MYAPP.dll Copy Use one of the following methods to set your license key (required) and your app name (optional): Set via environment variable: NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Set in newrelic.config with the licenseKey and name elements. When setting the app name, give your app a meaningful name. Use setenv.sh Except for CORECLR_NEWRELIC_HOME, the source /usr/local/newrelic-netcore20-agent/setenv.sh script included with the .NET agent configures the environment variables automatically. Tip Set these environment variables before running any apps that you want instrumented. This sets the environment variables only for the current shell and any child processes of that shell. Set the CORECLR_NEWRELIC_HOME environment variable to the .NET agent installation directory. Use one of the following methods to set your license key (required) and your app name (optional): Set via environment variable: NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Set in newrelic.config with the licenseKey and name elements. When setting the app name, give your app a meaningful name. Run the setenv.sh script located in the directory where you installed the .NET agent. Continue to step 3. Step 3. View your data in New Relic After you finish enabling the .NET agent: Start or restart your application. Generate some traffic, then wait a few minutes for data to appear in the New Relic UI. If no data appears for your application after a few minutes, follow the troubleshooting procedures. For an in-depth explanation of how to troubleshoot any problems with your .NET agent installation, see .NET agent install for .NET Core: a troubleshooting guide in New Relic's Explorers Hub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.5494,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .NET agent for Linux",
        "sections": "<em>Install</em> .NET agent for Linux",
        "tags": "<em>Installation</em>",
        "body": " account (It&#x27;s free, forever!). Get an account To install the .NET agent on a Linux system with a <em>package</em> <em>manager</em>: Install the agent. These details are the same for all installations using a <em>package</em> <em>manager</em>: Install location: &#x2F;usr&#x2F;local&#x2F;newrelic-netcore20-agent. The file newrelic-netcore20-agent"
      },
      "id": "617e9b2d28ccbc6a037ff431"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/installation/upgrade-new-relic-mobiles-ios-sdk": [
    {
      "sections": [
        "CocoaPods installation",
        "Install your iOS application",
        "Configure using Objective-C",
        "Important",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "9a062745f628f66e34f865a47d58713f12e59ac9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/cocoapods-installation/",
      "published_at": "2021-12-30T07:44:57Z",
      "updated_at": "2021-10-01T20:15:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply to iOS apps using Cocoapods. For other types, see iOS installation and configuration. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps list, select Add a new app. From the Get Started page, select iOS as the platform for mobile monitoring. Type a name for your mobile app, then select Continue. If your installation does not automatically include the prefix header, follow the steps to add the prefix header to your project. Continue with the steps to configure New Relic for mobile monitoring. Configure using Objective-C These procedures to configure your iOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your APP_NAME-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: [NewRelic startWithApplicationToken:@\"APP_TOKEN\"]; Copy Important The agent must be on the first line of didFinishLaunchingWithOptions and run on the main thread to ensure proper instrumentation. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Configure using Swift These procedures to configure your iOS app with CocoaPods and Swift also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your APP_NAME-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: NewRelic.start(withApplicationToken:\"APP_TOKEN\") Copy Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling NewRelic.start(withApplicationToken): [NRLogger setLogLevels:NRLogLevelALL]; Copy For Swift apps: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.69351,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods <em>installation</em>",
        "sections": "<em>Install</em> your <em>iOS</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps list, select Add a <em>new</em> app. From the Get Started page, select <em>iOS</em> as the platform for <em>mobile</em> <em>monitoring</em>. Type a name for your <em>mobile</em> app, then select Continue"
      },
      "id": "603ea15d64441fef3d4e8867"
    },
    {
      "sections": [
        "iOS agent compatibility and requirements",
        "Foreground monitoring",
        "iOS requirements",
        "Testing is not supported",
        "Potential method replacement conflicts"
      ],
      "title": "iOS agent compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "544e062fdc57c4545c2f36b54b38f95b30b3c25e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/new-relic-ios-compatibility-requirements/",
      "published_at": "2021-12-30T11:17:44Z",
      "updated_at": "2021-12-19T19:52:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install and configure the iOS agent, follow these guidelines for compatibility and other requirements. Foreground monitoring The iOS agent only monitors your app while it is in the foreground. The agent does not monitor background services while the app is closed. For more information, see our Mobile data privacy and security documentation. iOS requirements Make sure your iOS app meets these requirements: Component iOS application requirements Operating system iOS 9 or higher For Bitcode support, use SDK version 5.3.0 or higher. API/SDK NSURLConnection and AFNetworking are supported. NSURLSession supports upload and data tags only. ASIHttpRequest networking APIs are deprecated as of iOS agent version 5.8.2. Network traffic for UIWebView and WKWebView is supported. However, WKWebView Transfer size and Http errors are not supported. Languages Objective-C Swift: Works with both network traces and crash reporting, but no interaction traces by default. Interaction traces must be enabled for Swift. Devices Any iOS compatible device: iPhones, iPads, etc. File sizes The agent adds about 2 to 12 megabytes to your iOS release app, depending on platform build. Architectures ARM 64-bit. SHA-2 As a standard security measure for data collection, New Relic requires that your application server supports SHA-2 (256-bit). SHA-1 is not supported. Xcode To take advantage of New Relic's iOS features, make sure you have the latest version of Xcode. arm64e support To be able to properly symbolicate crashes from devices with arm64e architectures, make sure your Xcode settings are enabled for pointer authentication. For more information, see the Apple developer documentation. CocoaPods In order to use the latest XCFramework Agent, use CocoaPods version 1.10.1 or higher. Testing is not supported Our agents are designed and tested to work in a normal app lifecycle. New Relic does not support running any testing environment on applications with the agent. Testing can cause conflicts and unpredictable behavior. Potential method replacement conflicts Our iOS agent utilizes method replacement during run time. This may result in a conflict with other libraries that also implement method replacement, such as ReactiveCocoa, Firebase, Aspects, and AppleGuice.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.62027,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> agent compatibility and requirements",
        "sections": "<em>iOS</em> agent compatibility and requirements",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Before you install and configure the <em>iOS</em> agent, follow these guidelines for compatibility and other requirements. Foreground <em>monitoring</em> The <em>iOS</em> agent only monitors your app while it is in the foreground. The agent does not <em>monitor</em> background services while the app is closed. For more information"
      },
      "id": "6044196064441f4f10378f04"
    },
    {
      "sections": [
        "iOS manual installation",
        "Install your iOS application",
        "Add the New Relic framework to your app",
        "Important",
        "Optional: Execute a demo crash",
        "Optional: Change the logging level"
      ],
      "title": "iOS manual installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "0a674eb7f3756cd5d124c6dcf2344edf38e40a8a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/ios-manual-installation/",
      "published_at": "2021-12-30T03:31:08Z",
      "updated_at": "2021-07-27T15:09:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To install and configure New Relic functionality with your iOS applications, follow these procedures. If your iOS app uses Cocoapods, follow the Cocoapods installation procedures. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps index, select Add a new app. From the Get started page, select XCFramework as the platform for mobile monitoring. Type a name for your mobile app, and select Continue. Continue with the steps to configure New Relic. Add the New Relic framework to your app Download and unzip the iOS SDK for New Relic. To add the New Relic framework to your Xcode project: Use Finder to drag the NewRelicAgent.framework folder into your Xcode project, and drop it onto your project in the Project navigator window, under Frameworks, Libraries, and Embedded Content. Make sure Embed & Sign is selected under the Embed dropdown menu. Implement the agent using the appropriate method: Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Language Procedure Objective-C To start the agent: Import the New Relic header at the top of your prefix.pch. Add +[NewRelic startWithApplicationToken:@\"<appToken>\"] to the top of -application:didFinishLaunchingWithOptions: in your AppDelegate.m, using the unique application token that is automatically generated. Swift Create a bridging header file: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. Delete Placeholder.m. Import the New Relic agent by adding #import \"NewRelic/NewRelic.h\" to the top of MyApp-Bridging-Header.h. Add NewRelic.start(withApplicationToken: \">appToken>\") to the top of application(_:didFinishLaunchingWithOptions:) in your AppDelegate.swift using the unique application token that is automatically generated. Add a build script to your target's Build Phases. Ensure the new build script is the very last build phase, then paste the following, replacing PUT_NEW_RELIC_APP_TOKEN_HERE with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, and then run it in the simulator or other device. Optional: Execute a demo crash If you have trouble getting your app to crash, the New Relic agent provides an API to execute a demo crash. Recommendation: Add one of these lines of code to a button click event handler as applicable: Language Code Objective-C Crash: [NewRelic crashNow]; Copy Crash with log message: [NewRelic crashNow:@\"<reason>\"]; Copy Swift Crash: NewRelic.crashNow() Copy Crash with log message: NewRelic.crashNow(_ message:) Copy Optional: Change the logging level Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add the following method: Language Code Objective-C Just before calling startWithApplicationToken in AppDelegate.m, add: [NRLogger setLogLevels:NRLogLevelALL]; Copy Swift Just before calling start(withApplicationToken:) in AppDelegate.swift, add: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.833,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> manual <em>installation</em>",
        "sections": "<em>iOS</em> manual <em>installation</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " token. This is a 40-character hexadecimal string for authenticating each <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps index, select Add a <em>new</em> app. From the Get started page, select XCFramework"
      },
      "id": "603ea44864441f80904e8899"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/crashnow-ios-sdk-api": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-12-30T09:15:19Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 256.41547,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "211136f4a8e7f940d7f6ef753a1445eaed46bd92",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/ios-sdk-api-guide/",
      "published_at": "2021-12-30T07:47:02Z",
      "updated_at": "2021-11-05T14:07:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 245.9144,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " attributes and events you can send to to <em>New</em> <em>Relic</em> Insights, see the <em>iOS</em> <em>SDK</em> <em>API</em> reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by <em>New</em> <em>Relic</em>"
      },
      "id": "619e9c2128ccbcbf64b9abeb"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-12-30T02:13:19Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.51505,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/current-session-id": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-12-30T09:15:19Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 256.41547,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "211136f4a8e7f940d7f6ef753a1445eaed46bd92",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/ios-sdk-api-guide/",
      "published_at": "2021-12-30T07:47:02Z",
      "updated_at": "2021-11-05T14:07:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 245.9144,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " attributes and events you can send to to <em>New</em> <em>Relic</em> Insights, see the <em>iOS</em> <em>SDK</em> <em>API</em> reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by <em>New</em> <em>Relic</em>"
      },
      "id": "619e9c2128ccbcbf64b9abeb"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-12-30T02:13:19Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.51505,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/increment-attribute": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-12-30T09:15:19Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 256.41547,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "211136f4a8e7f940d7f6ef753a1445eaed46bd92",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/ios-sdk-api-guide/",
      "published_at": "2021-12-30T07:47:02Z",
      "updated_at": "2021-11-05T14:07:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 245.9144,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " attributes and events you can send to to <em>New</em> <em>Relic</em> Insights, see the <em>iOS</em> <em>SDK</em> <em>API</em> reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by <em>New</em> <em>Relic</em>"
      },
      "id": "619e9c2128ccbcbf64b9abeb"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-12-30T02:13:19Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.51505,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/ios-agent-configuration-feature-flags": [
    {
      "sections": [
        "Upload dSYM files",
        "Automatic script",
        "Identify missing dSYMs",
        "Upload dSYM files through the mobile monitoring UI",
        "Manually upload dSYM files",
        "Via Python script (agent versions 6.0.0 or higher)",
        "Via command line",
        "Troubleshooting",
        "Auto-upload failure",
        "Missing dSYMs"
      ],
      "title": "Upload dSYM files",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "3655f49cf0e1ae693de0f8ea45bf4e5e6437e399",
      "image": "https://docs.newrelic.com/static/5c859575f391fbb1eaa18243a8c97000/8c557/Screen-Shot-2014-09-23-at-11.30.35-AM_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/upload-dsyms-bitcode-apps/",
      "published_at": "2021-12-30T02:14:03Z",
      "updated_at": "2021-09-27T15:06:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your app's dSYM files are stored in Xcode's dSYM archive path folder. This is the folder where the iOS agent gets the dSYM files that are used to symbolicate your crash reports. New Relic provides a post-build script as part of the iOS agent's install process and the tvOS agent's install process. This script automatically uploads your app's dSYM files. Automatic script The script automatically uploads dSYM files only for release builds. Non-release builds must upload their files either manually or through the mobile monitoring UI. Bitcode-enabled apps have their dSYM files generated by Apple. You must download the dSYM files for Bitcode-enabled apps from Apple and upload them to New Relic. If you see unreadable machine code in the Crashes page, your dSYM files may not be uploaded correctly. In some cases, you may need to manually upload dSYM files. The automatic script uses Python 2. As of October 2019 with macOS 10.15 (Catalina), Python won't be installed by default. If you're using the automatic script (recommended), you may need to manually install Python 2. If you're using Homebrew, see Python on Homebrew. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: From the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Upload dSYM files through the mobile monitoring UI You can easily upload your dSYM files directly from the New Relic One UI. The maximum file size is 600 MB. To upload your dSYM files: Go to one.newrelic.com and click Mobile. Then select your app from the list. View Crash analysis. Select a specific crash from the Crash types list. Click Upload dSYM. You can either drag and drop your dSYMs directly, or select the file form your computer. Manually upload dSYM files In some circumstances, New Relic's automatic upload of dSYM files may fail. If a dSYM upload is attempted and fails, it creates a build error with a detailed message. For example, if there's a network failure and the dSYM upload isn't completed, Xcode will report an error. For additional information about how New Relic handles dSYM uploads, see New Relic's Online Technical Community. If the automatic upload fails, you can manually upload your dSYM file. If you have multiple dSYM files, they can be within a single zip with a maximum file size of 600 MB. The YOUR_NEW_RELIC_APPLICATION_TOKEN value in the commands below is the same key used for +[NewRelic startWithApplicationToken:] (in Objective-C) or NewRelic.start(withApplicationToken:) (in Swift). To manually upload your dSYM files: Via Python script (agent versions 6.0.0 or higher) In iOS agent versions 6.0.0 or higher, the agent includes a Python script that automatically processes and uploads symbols. You can call this script from the command line: NewRelicAgent.framework/Resources/generateMap.py \"DSYM_ARCHIVE_PATH\" \"YOUR_NEW_RELIC_APPLICATION_TOKEN\" Copy Via command line To manually upload individual dSYM files from the command line: Zip up your dSYM file or files using the following command. Replace ~ /ZIPPED_DSYM_PATH with your new dSYM archive path and file name (for example, Users/my-name/desktop). Also replace ~ /dSYM_PATH with your existing dSYM file path. /usr/bin/zip --recurse-paths --quiet \"~/ZIPPED_DSYM_PATH\" \"~/dSYM_PATH\" Copy Upload the dSYM zip file using the following command: For US accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.newrelic.com/symbol Copy For EU accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.eu01.nr-data.net/symbol Copy Troubleshooting Auto-upload failure If a dSYM auto-upload failed, the Report Navigator may have a fully formed cURL command. You can use this cURL command to reattempt an upload. Depending on the error, you may also need to follow some of the dSYM manual upload steps. Here is an example of a successful dSYM upload in the Report Navigator: Example: A successful dSYM upload in the Report Navigator. Missing dSYMs If dSYM files are missing, you may need to check Xcode build settings to ensure the file is being generated. Frameworks which are built locally have separate build settings and may need to be updated as well. Build settings: Debug Information Format : Dwarf with dSYM File Deployment Postprocessing: Yes Strip Linked Product: Yes Strip Debug Symbols During Copy : Yes Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.73927,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Upload dSYM files through the <em>mobile</em> <em>monitoring</em> UI",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Your app&#x27;s dSYM files are stored in Xcode&#x27;s dSYM archive path folder. This is the folder where the <em>iOS</em> agent gets the dSYM files that are used to symbolicate your crash reports. <em>New</em> <em>Relic</em> provides a post-build script as part of the <em>iOS</em> agent&#x27;s install process and the tv<em>OS</em> agent&#x27;s install process"
      },
      "id": "60441960e7b9d24f705799ca"
    },
    {
      "sections": [
        "iOS agent compatibility and requirements",
        "Foreground monitoring",
        "iOS requirements",
        "Testing is not supported",
        "Potential method replacement conflicts"
      ],
      "title": "iOS agent compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "544e062fdc57c4545c2f36b54b38f95b30b3c25e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/new-relic-ios-compatibility-requirements/",
      "published_at": "2021-12-30T11:17:44Z",
      "updated_at": "2021-12-19T19:52:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install and configure the iOS agent, follow these guidelines for compatibility and other requirements. Foreground monitoring The iOS agent only monitors your app while it is in the foreground. The agent does not monitor background services while the app is closed. For more information, see our Mobile data privacy and security documentation. iOS requirements Make sure your iOS app meets these requirements: Component iOS application requirements Operating system iOS 9 or higher For Bitcode support, use SDK version 5.3.0 or higher. API/SDK NSURLConnection and AFNetworking are supported. NSURLSession supports upload and data tags only. ASIHttpRequest networking APIs are deprecated as of iOS agent version 5.8.2. Network traffic for UIWebView and WKWebView is supported. However, WKWebView Transfer size and Http errors are not supported. Languages Objective-C Swift: Works with both network traces and crash reporting, but no interaction traces by default. Interaction traces must be enabled for Swift. Devices Any iOS compatible device: iPhones, iPads, etc. File sizes The agent adds about 2 to 12 megabytes to your iOS release app, depending on platform build. Architectures ARM 64-bit. SHA-2 As a standard security measure for data collection, New Relic requires that your application server supports SHA-2 (256-bit). SHA-1 is not supported. Xcode To take advantage of New Relic's iOS features, make sure you have the latest version of Xcode. arm64e support To be able to properly symbolicate crashes from devices with arm64e architectures, make sure your Xcode settings are enabled for pointer authentication. For more information, see the Apple developer documentation. CocoaPods In order to use the latest XCFramework Agent, use CocoaPods version 1.10.1 or higher. Testing is not supported Our agents are designed and tested to work in a normal app lifecycle. New Relic does not support running any testing environment on applications with the agent. Testing can cause conflicts and unpredictable behavior. Potential method replacement conflicts Our iOS agent utilizes method replacement during run time. This may result in a conflict with other libraries that also implement method replacement, such as ReactiveCocoa, Firebase, Aspects, and AppleGuice.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.62021,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> agent compatibility and requirements",
        "sections": "<em>iOS</em> agent compatibility and requirements",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Before you install and configure the <em>iOS</em> agent, follow these guidelines for compatibility and other requirements. Foreground <em>monitoring</em> The <em>iOS</em> agent only monitors your app while it is in the foreground. The agent does not <em>monitor</em> background services while the app is closed. For more information"
      },
      "id": "6044196064441f4f10378f04"
    },
    {
      "sections": [
        "Retrieve dSYMs for Bitcode apps",
        "Identify missing dSYMs",
        "Download dSYM files using iTunes Connect",
        "Download dSYM files using Xcode's app archive",
        "Upload dSYMs"
      ],
      "title": "Retrieve dSYMs for Bitcode apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "34e375873e36095062eccef6d99f26be7562308f",
      "image": "https://docs.newrelic.com/static/041368cdc60d9252ad80c2c37321b805/ec3e2/screen-dsym2.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/retrieve-dsyms-bitcode-apps/",
      "published_at": "2021-12-30T09:17:01Z",
      "updated_at": "2021-07-09T19:35:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Bitcode is a feature that gives Apple the ability to re-compile iOS and tvOS applications for specific users' hardware. This provides a smaller download size for end users. For more about this process, see Apple's Bitcode and app thinning documentation. When Apple compiles an app, the dSYM files are also compiled. For New Relic to be able to symbolicate crashes of your Bitcode-enabled app, these dSYM files need to be downloaded from Apple and then uploaded to New Relic. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: from the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Download dSYM files using iTunes Connect To download the dSYM files you need for your app: Log in to Apple iTunes Connect. Select My Apps > (selected app) > Activity. From the list of builds for your application, select the build number you need for the dSYM. Select Download dSYM. Then, to upload the resulting zip file directly to New Relic: Follow the instructions to manually upload dSYM, and skip step 1. Unpack one dSYM contained in this zip file to retrieve a build UUID that you can upload. (Follow the last step in the manual upload instructions.) Once New Relic receives the zip file, the build UUIDs for all other dSYMs contained in that zip file will be identified. Download dSYM files using Xcode's app archive Use the app version and build number to identify the applicable app archive in the Xcode Organizer and download the dSYMs. Using Xcode to download dSYMs: From the Archives tab, select the app and version/build, then select Download dSYMs. Open the Xcode Organizer: From the Xcode menu, select Window > Organizer > Archives > (select a mobile app). From Version, select the archive that matches the app version (listed first) and build number (following the app version in parentheses). Select Download dSYMs. The dSYMs will be downloaded from Apple if available and if the file names contain a series of letters and numbers. If the dSYM files are named after the the dependencies in your project, the download will not be successful. Upload dSYMs Once you have located the dSYMs, follow the instructions to upload a dSYM for each zipped dSYM.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.5055,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Identify</em> missing dSYMs",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Bitcode is a feature that gives Apple the ability to re-compile <em>iOS</em> and tv<em>OS</em> applications for specific users&#x27; hardware. This provides a smaller download size for end users. For more about this process, see Apple&#x27;s Bitcode and app thinning documentation. When Apple compiles an app, the dSYM files"
      },
      "id": "6044144228ccbc04a2303885"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/ios-sdk-api-guide": [
    {
      "sections": [
        "iOS agent compatibility and requirements",
        "Foreground monitoring",
        "iOS requirements",
        "Testing is not supported",
        "Potential method replacement conflicts"
      ],
      "title": "iOS agent compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "544e062fdc57c4545c2f36b54b38f95b30b3c25e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/new-relic-ios-compatibility-requirements/",
      "published_at": "2021-12-30T11:17:44Z",
      "updated_at": "2021-12-19T19:52:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install and configure the iOS agent, follow these guidelines for compatibility and other requirements. Foreground monitoring The iOS agent only monitors your app while it is in the foreground. The agent does not monitor background services while the app is closed. For more information, see our Mobile data privacy and security documentation. iOS requirements Make sure your iOS app meets these requirements: Component iOS application requirements Operating system iOS 9 or higher For Bitcode support, use SDK version 5.3.0 or higher. API/SDK NSURLConnection and AFNetworking are supported. NSURLSession supports upload and data tags only. ASIHttpRequest networking APIs are deprecated as of iOS agent version 5.8.2. Network traffic for UIWebView and WKWebView is supported. However, WKWebView Transfer size and Http errors are not supported. Languages Objective-C Swift: Works with both network traces and crash reporting, but no interaction traces by default. Interaction traces must be enabled for Swift. Devices Any iOS compatible device: iPhones, iPads, etc. File sizes The agent adds about 2 to 12 megabytes to your iOS release app, depending on platform build. Architectures ARM 64-bit. SHA-2 As a standard security measure for data collection, New Relic requires that your application server supports SHA-2 (256-bit). SHA-1 is not supported. Xcode To take advantage of New Relic's iOS features, make sure you have the latest version of Xcode. arm64e support To be able to properly symbolicate crashes from devices with arm64e architectures, make sure your Xcode settings are enabled for pointer authentication. For more information, see the Apple developer documentation. CocoaPods In order to use the latest XCFramework Agent, use CocoaPods version 1.10.1 or higher. Testing is not supported Our agents are designed and tested to work in a normal app lifecycle. New Relic does not support running any testing environment on applications with the agent. Testing can cause conflicts and unpredictable behavior. Potential method replacement conflicts Our iOS agent utilizes method replacement during run time. This may result in a conflict with other libraries that also implement method replacement, such as ReactiveCocoa, Firebase, Aspects, and AppleGuice.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.83377,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> agent compatibility and requirements",
        "sections": "<em>iOS</em> agent compatibility and requirements",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Before you install and configure the <em>iOS</em> agent, follow these guidelines for compatibility and other requirements. Foreground <em>monitoring</em> The <em>iOS</em> agent only monitors your app while it is in the foreground. The agent does not <em>monitor</em> background services while the app is closed. For more information"
      },
      "id": "6044196064441f4f10378f04"
    },
    {
      "sections": [
        "iOS agent configuration and feature flags",
        "Enable or disable feature flags",
        "Crash and error reporting feature flag",
        "NRFeatureFlag_CrashReporting",
        "NRFeatureFlag_HandledExceptionEvents",
        "Distributed tracing",
        "NRFeatureFlag_DistributedTracing",
        "Interactions feature flags",
        "NRFeatureFlag_DefaultInteractions",
        "NRFeatureFlag_InteractionTracing",
        "NRFeatureFlag_SwiftInteractionTracing",
        "Caution",
        "Networking feature flags",
        "NRFeatureFlag_ExperimentalNetworkingInstrumentation",
        "NRFeatureFlag_NSURLSessionInstrumentation",
        "NRFeatureFlag_NetworkRequestEvents",
        "NRFeatureFlag_RequestErrorEvents",
        "NRFeatureFlag_HttpResponseBodyCapture"
      ],
      "title": "iOS agent configuration and feature flags",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "538f198af51ca5659916c98e634f1142ec387bca",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/ios-agent-configuration-feature-flags/",
      "published_at": "2021-12-30T07:47:01Z",
      "updated_at": "2021-11-05T14:19:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's iOS agent provides configuration settings to change the default behavior of the agent. If used, implement these flags just before calling: Objective-C: +[NewRelic startWithApplicationToken:] Swift: NewRelic.start(withApplicationToken:) Enable or disable feature flags To configure feature flags, use the following method defined in NewRelic.h: iOS language Procedure Objective-C In Objective-C, these features are bitmasked, so you can use a | to enable or disable multiple features at the same time. Enable a feature flag: +[NewRelic enableFeatures:(NRMAFeatureFlags)flags]; Copy Disable a feature flag: +[NewRelic disableFeatures:(NRMAFeatureFlags)flags]; Copy Here is an example where: Interaction tracing and experimental networking instrumentation are enabled. NSURLSession instrumentation and crash reporting are disabled. [NewRelic enableFeatures:NRFeatureFlag_SwiftInteractionTracing | NRFeatureFlag_ExperimentalNetworkingInstrumentation]; [NewRelic disableFeatures:NRFeatureFlag_NSURLSessionInstrumentation | NRFeatureFlag_CrashReporting]; [NewRelic startWithApplicationToken:...]; Copy Swift Enable a feature flag: NewRelic.enableFeatures(NRMAFeatureFlags.[NRMAFeatureFlag]) Copy Disable a feature flag: NewRelic.disableFeatures(NRMAFeatureFlags.[NRMAFeatureFlag]) Copy Example to disable interaction tracing: NewRelic.disableFeatures(NRMAFeatureFlags.NRFeatureFlag_DefaultInteractions) Copy Crash and error reporting feature flag If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_CrashReporting Enable (default) or disable crash reporting, which appears on the Crash analysis page. Type Boolean Default true NRFeatureFlag_HandledExceptionEvents Globally enable (default) or disable recording handled exceptions events, which appear on the Handled exception page. Type Boolean Default true Distributed tracing NRFeatureFlag_DistributedTracing Enable or disable the adding of distributed tracing headers to network requests. Refer to How New Relic distributed tracing works for more information on distributed tracing in mobile apps. Type Boolean Default true Interactions feature flags If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_DefaultInteractions Enable (default) or disable interaction tracing only for default instrumented classes and methods. Custom interactions will be reported. The traces will appear on the Interactions page. Type Boolean Default true NRFeatureFlag_InteractionTracing Globally enable (default) or disable interaction traces, which appear on the Interactions page. Interaction tracing will be disabled after the agent has started. Interactions for any activity or methods executed prior to starting the agent may still appear on the Interactions page. Type Boolean Default true NRFeatureFlag_SwiftInteractionTracing Caution Before enabling this feature, see Enable Swift interaction traces. If proper steps are not taken, enabling this feature may cause instability. Enable or disable (default) interaction tracing for Swift code. The traces appear on the Interactions page. This feature will always be disabled if NRFeatureFlag_InteractionTracing is disabled. Type Boolean Default false Networking feature flags If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_ExperimentalNetworkingInstrumentation Caution Enabling this feature flag call may decrease the stability of applications. Avoid using unless instructed by New Relic. Enable or disable (default) experimental networking instrumentation. This forces all NSURLConnection network requests through the NRMAURProtocol. Type Boolean Default false NRFeatureFlag_NSURLSessionInstrumentation Enable (default) or disable networking instrumentation for NSURLSession. These URL traces are sent to the HTTP Requests page. Type Boolean Default true NRFeatureFlag_NetworkRequestEvents Enable or disable (default) networking instrumentation. This sends the HTTP response data as MobileRequest events. Available for iOS Agent version 5.14.0 and higher Type Boolean Default true - Enabled by default as of 6.0.0 NRFeatureFlag_RequestErrorEvents Enable (default) or disable HTTP request error event generation of instrumented network calls that result in an error or failure. These events are reported as MobileRequestError events. Available for iOS Agent version 5.11.0 and higher Type Boolean Default true NRFeatureFlag_HttpResponseBodyCapture Enable or disable capture of HTTP response bodies for HTTP error traces, and MobileRequestError events. Type Boolean Default true",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.32927,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> agent configuration and feature flags",
        "sections": "<em>iOS</em> agent configuration and feature flags",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> agent provides configuration settings to change the default behavior of the agent. If used, implement these flags just before calling: Objective-C: +[<em>NewRelic</em> startWithApplicationToken:] Swift: <em>NewRelic</em>.start(withApplicationToken:) Enable or disable feature flags To configure"
      },
      "id": "619eaa7e28ccbc1559b9b002"
    },
    {
      "sections": [
        "CocoaPods installation",
        "Install your iOS application",
        "Configure using Objective-C",
        "Important",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "9a062745f628f66e34f865a47d58713f12e59ac9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/cocoapods-installation/",
      "published_at": "2021-12-30T07:44:57Z",
      "updated_at": "2021-10-01T20:15:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply to iOS apps using Cocoapods. For other types, see iOS installation and configuration. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps list, select Add a new app. From the Get Started page, select iOS as the platform for mobile monitoring. Type a name for your mobile app, then select Continue. If your installation does not automatically include the prefix header, follow the steps to add the prefix header to your project. Continue with the steps to configure New Relic for mobile monitoring. Configure using Objective-C These procedures to configure your iOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your APP_NAME-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: [NewRelic startWithApplicationToken:@\"APP_TOKEN\"]; Copy Important The agent must be on the first line of didFinishLaunchingWithOptions and run on the main thread to ensure proper instrumentation. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Configure using Swift These procedures to configure your iOS app with CocoaPods and Swift also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your APP_NAME-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: NewRelic.start(withApplicationToken:\"APP_TOKEN\") Copy Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling NewRelic.start(withApplicationToken): [NRLogger setLogLevels:NRLogLevelALL]; Copy For Swift apps: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.824905,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods <em>installation</em>",
        "sections": "<em>Install</em> your <em>iOS</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps list, select Add a <em>new</em> app. From the Get Started page, select <em>iOS</em> as the platform for <em>mobile</em> <em>monitoring</em>. Type a name for your <em>mobile</em> app, then select Continue"
      },
      "id": "603ea15d64441fef3d4e8867"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/record-breadcrumb": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-12-30T09:15:19Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 256.41547,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "211136f4a8e7f940d7f6ef753a1445eaed46bd92",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/ios-sdk-api-guide/",
      "published_at": "2021-12-30T07:47:02Z",
      "updated_at": "2021-11-05T14:07:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 245.91438,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " attributes and events you can send to to <em>New</em> <em>Relic</em> Insights, see the <em>iOS</em> <em>SDK</em> <em>API</em> reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by <em>New</em> <em>Relic</em>"
      },
      "id": "619e9c2128ccbcbf64b9abeb"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-12-30T02:13:19Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.51505,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/record-handled-exception": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-12-30T09:15:19Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 256.41547,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "211136f4a8e7f940d7f6ef753a1445eaed46bd92",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/ios-sdk-api-guide/",
      "published_at": "2021-12-30T07:47:02Z",
      "updated_at": "2021-11-05T14:07:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 245.91438,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " attributes and events you can send to to <em>New</em> <em>Relic</em> Insights, see the <em>iOS</em> <em>SDK</em> <em>API</em> reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by <em>New</em> <em>Relic</em>"
      },
      "id": "619e9c2128ccbcbf64b9abeb"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-12-30T02:13:19Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.51505,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/recordcustomevent-ios-sdk-api": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-12-30T09:15:19Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 256.41547,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "211136f4a8e7f940d7f6ef753a1445eaed46bd92",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/ios-sdk-api-guide/",
      "published_at": "2021-12-30T07:47:02Z",
      "updated_at": "2021-11-05T14:07:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 245.91438,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " attributes and events you can send to to <em>New</em> <em>Relic</em> Insights, see the <em>iOS</em> <em>SDK</em> <em>API</em> reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by <em>New</em> <em>Relic</em>"
      },
      "id": "619e9c2128ccbcbf64b9abeb"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-12-30T02:13:19Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.51505,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/recorderror-ios-sdk-api": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-12-30T09:15:19Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 256.41547,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "211136f4a8e7f940d7f6ef753a1445eaed46bd92",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/ios-sdk-api-guide/",
      "published_at": "2021-12-30T07:47:02Z",
      "updated_at": "2021-11-05T14:07:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 245.91438,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " attributes and events you can send to to <em>New</em> <em>Relic</em> Insights, see the <em>iOS</em> <em>SDK</em> <em>API</em> reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by <em>New</em> <em>Relic</em>"
      },
      "id": "619e9c2128ccbcbf64b9abeb"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-12-30T02:13:19Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.51505,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/recordmetric-ios-sdk-api": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-12-30T09:15:19Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 256.41547,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "211136f4a8e7f940d7f6ef753a1445eaed46bd92",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/ios-sdk-api-guide/",
      "published_at": "2021-12-30T07:47:02Z",
      "updated_at": "2021-11-05T14:07:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 245.91437,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " attributes and events you can send to to <em>New</em> <em>Relic</em> Insights, see the <em>iOS</em> <em>SDK</em> <em>API</em> reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by <em>New</em> <em>Relic</em>"
      },
      "id": "619e9c2128ccbcbf64b9abeb"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-12-30T02:13:19Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.51505,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/remove-all-attributes": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-12-30T09:15:19Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 256.41547,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "211136f4a8e7f940d7f6ef753a1445eaed46bd92",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/ios-sdk-api-guide/",
      "published_at": "2021-12-30T07:47:02Z",
      "updated_at": "2021-11-05T14:07:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 245.91437,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " attributes and events you can send to to <em>New</em> <em>Relic</em> Insights, see the <em>iOS</em> <em>SDK</em> <em>API</em> reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by <em>New</em> <em>Relic</em>"
      },
      "id": "619e9c2128ccbcbf64b9abeb"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-12-30T02:13:19Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.51505,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/remove-attribute": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-12-30T09:15:19Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 256.41547,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "211136f4a8e7f940d7f6ef753a1445eaed46bd92",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/ios-sdk-api-guide/",
      "published_at": "2021-12-30T07:47:02Z",
      "updated_at": "2021-11-05T14:07:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 245.91437,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " attributes and events you can send to to <em>New</em> <em>Relic</em> Insights, see the <em>iOS</em> <em>SDK</em> <em>API</em> reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by <em>New</em> <em>Relic</em>"
      },
      "id": "619e9c2128ccbcbf64b9abeb"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-12-30T02:13:19Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.51505,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/set-attribute": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-12-30T09:15:19Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 256.41547,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "211136f4a8e7f940d7f6ef753a1445eaed46bd92",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/ios-sdk-api-guide/",
      "published_at": "2021-12-30T07:47:02Z",
      "updated_at": "2021-11-05T14:07:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 245.91437,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " attributes and events you can send to to <em>New</em> <em>Relic</em> Insights, see the <em>iOS</em> <em>SDK</em> <em>API</em> reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by <em>New</em> <em>Relic</em>"
      },
      "id": "619e9c2128ccbcbf64b9abeb"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-12-30T02:13:19Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.51505,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/set-max-event-buffer-time": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-12-30T09:15:19Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 256.41547,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "211136f4a8e7f940d7f6ef753a1445eaed46bd92",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/ios-sdk-api-guide/",
      "published_at": "2021-12-30T07:47:02Z",
      "updated_at": "2021-11-05T14:07:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 245.91437,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " attributes and events you can send to to <em>New</em> <em>Relic</em> Insights, see the <em>iOS</em> <em>SDK</em> <em>API</em> reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by <em>New</em> <em>Relic</em>"
      },
      "id": "619e9c2128ccbcbf64b9abeb"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-12-30T02:13:19Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.51505,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/set-max-event-pool-size": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-12-30T09:15:19Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 256.41547,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "211136f4a8e7f940d7f6ef753a1445eaed46bd92",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/ios-sdk-api-guide/",
      "published_at": "2021-12-30T07:47:02Z",
      "updated_at": "2021-11-05T14:07:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 245.91437,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " attributes and events you can send to to <em>New</em> <em>Relic</em> Insights, see the <em>iOS</em> <em>SDK</em> <em>API</em> reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by <em>New</em> <em>Relic</em>"
      },
      "id": "619e9c2128ccbcbf64b9abeb"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-12-30T02:13:19Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.51505,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/set-user-id": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-12-30T09:15:19Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your target’s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using Xcode to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 256.41547,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "211136f4a8e7f940d7f6ef753a1445eaed46bd92",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/ios-sdk-api-guide/",
      "published_at": "2021-12-30T07:47:02Z",
      "updated_at": "2021-11-05T14:07:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 245.91435,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "sections": "<em>iOS</em> <em>SDK</em> <em>API</em> guide",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " attributes and events you can send to to <em>New</em> <em>Relic</em> Insights, see the <em>iOS</em> <em>SDK</em> <em>API</em> reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by <em>New</em> <em>Relic</em>"
      },
      "id": "619e9c2128ccbcbf64b9abeb"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-12-30T02:13:19Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.51505,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/troubleshoot/no-data-appears-ios": [
    {
      "sections": [
        "iOS agent compatibility and requirements",
        "Foreground monitoring",
        "iOS requirements",
        "Testing is not supported",
        "Potential method replacement conflicts"
      ],
      "title": "iOS agent compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "544e062fdc57c4545c2f36b54b38f95b30b3c25e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/new-relic-ios-compatibility-requirements/",
      "published_at": "2021-12-30T11:17:44Z",
      "updated_at": "2021-12-19T19:52:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install and configure the iOS agent, follow these guidelines for compatibility and other requirements. Foreground monitoring The iOS agent only monitors your app while it is in the foreground. The agent does not monitor background services while the app is closed. For more information, see our Mobile data privacy and security documentation. iOS requirements Make sure your iOS app meets these requirements: Component iOS application requirements Operating system iOS 9 or higher For Bitcode support, use SDK version 5.3.0 or higher. API/SDK NSURLConnection and AFNetworking are supported. NSURLSession supports upload and data tags only. ASIHttpRequest networking APIs are deprecated as of iOS agent version 5.8.2. Network traffic for UIWebView and WKWebView is supported. However, WKWebView Transfer size and Http errors are not supported. Languages Objective-C Swift: Works with both network traces and crash reporting, but no interaction traces by default. Interaction traces must be enabled for Swift. Devices Any iOS compatible device: iPhones, iPads, etc. File sizes The agent adds about 2 to 12 megabytes to your iOS release app, depending on platform build. Architectures ARM 64-bit. SHA-2 As a standard security measure for data collection, New Relic requires that your application server supports SHA-2 (256-bit). SHA-1 is not supported. Xcode To take advantage of New Relic's iOS features, make sure you have the latest version of Xcode. arm64e support To be able to properly symbolicate crashes from devices with arm64e architectures, make sure your Xcode settings are enabled for pointer authentication. For more information, see the Apple developer documentation. CocoaPods In order to use the latest XCFramework Agent, use CocoaPods version 1.10.1 or higher. Testing is not supported Our agents are designed and tested to work in a normal app lifecycle. New Relic does not support running any testing environment on applications with the agent. Testing can cause conflicts and unpredictable behavior. Potential method replacement conflicts Our iOS agent utilizes method replacement during run time. This may result in a conflict with other libraries that also implement method replacement, such as ReactiveCocoa, Firebase, Aspects, and AppleGuice.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.8336,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> agent compatibility and requirements",
        "sections": "<em>iOS</em> agent compatibility and requirements",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Before you install and configure the <em>iOS</em> agent, follow these guidelines for compatibility and other requirements. Foreground <em>monitoring</em> The <em>iOS</em> agent only monitors your app while it is in the foreground. The agent does not <em>monitor</em> background services while the app is closed. For more information"
      },
      "id": "6044196064441f4f10378f04"
    },
    {
      "sections": [
        "iOS agent configuration and feature flags",
        "Enable or disable feature flags",
        "Crash and error reporting feature flag",
        "NRFeatureFlag_CrashReporting",
        "NRFeatureFlag_HandledExceptionEvents",
        "Distributed tracing",
        "NRFeatureFlag_DistributedTracing",
        "Interactions feature flags",
        "NRFeatureFlag_DefaultInteractions",
        "NRFeatureFlag_InteractionTracing",
        "NRFeatureFlag_SwiftInteractionTracing",
        "Caution",
        "Networking feature flags",
        "NRFeatureFlag_ExperimentalNetworkingInstrumentation",
        "NRFeatureFlag_NSURLSessionInstrumentation",
        "NRFeatureFlag_NetworkRequestEvents",
        "NRFeatureFlag_RequestErrorEvents",
        "NRFeatureFlag_HttpResponseBodyCapture"
      ],
      "title": "iOS agent configuration and feature flags",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "538f198af51ca5659916c98e634f1142ec387bca",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/ios-agent-configuration-feature-flags/",
      "published_at": "2021-12-30T07:47:01Z",
      "updated_at": "2021-11-05T14:19:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's iOS agent provides configuration settings to change the default behavior of the agent. If used, implement these flags just before calling: Objective-C: +[NewRelic startWithApplicationToken:] Swift: NewRelic.start(withApplicationToken:) Enable or disable feature flags To configure feature flags, use the following method defined in NewRelic.h: iOS language Procedure Objective-C In Objective-C, these features are bitmasked, so you can use a | to enable or disable multiple features at the same time. Enable a feature flag: +[NewRelic enableFeatures:(NRMAFeatureFlags)flags]; Copy Disable a feature flag: +[NewRelic disableFeatures:(NRMAFeatureFlags)flags]; Copy Here is an example where: Interaction tracing and experimental networking instrumentation are enabled. NSURLSession instrumentation and crash reporting are disabled. [NewRelic enableFeatures:NRFeatureFlag_SwiftInteractionTracing | NRFeatureFlag_ExperimentalNetworkingInstrumentation]; [NewRelic disableFeatures:NRFeatureFlag_NSURLSessionInstrumentation | NRFeatureFlag_CrashReporting]; [NewRelic startWithApplicationToken:...]; Copy Swift Enable a feature flag: NewRelic.enableFeatures(NRMAFeatureFlags.[NRMAFeatureFlag]) Copy Disable a feature flag: NewRelic.disableFeatures(NRMAFeatureFlags.[NRMAFeatureFlag]) Copy Example to disable interaction tracing: NewRelic.disableFeatures(NRMAFeatureFlags.NRFeatureFlag_DefaultInteractions) Copy Crash and error reporting feature flag If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_CrashReporting Enable (default) or disable crash reporting, which appears on the Crash analysis page. Type Boolean Default true NRFeatureFlag_HandledExceptionEvents Globally enable (default) or disable recording handled exceptions events, which appear on the Handled exception page. Type Boolean Default true Distributed tracing NRFeatureFlag_DistributedTracing Enable or disable the adding of distributed tracing headers to network requests. Refer to How New Relic distributed tracing works for more information on distributed tracing in mobile apps. Type Boolean Default true Interactions feature flags If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_DefaultInteractions Enable (default) or disable interaction tracing only for default instrumented classes and methods. Custom interactions will be reported. The traces will appear on the Interactions page. Type Boolean Default true NRFeatureFlag_InteractionTracing Globally enable (default) or disable interaction traces, which appear on the Interactions page. Interaction tracing will be disabled after the agent has started. Interactions for any activity or methods executed prior to starting the agent may still appear on the Interactions page. Type Boolean Default true NRFeatureFlag_SwiftInteractionTracing Caution Before enabling this feature, see Enable Swift interaction traces. If proper steps are not taken, enabling this feature may cause instability. Enable or disable (default) interaction tracing for Swift code. The traces appear on the Interactions page. This feature will always be disabled if NRFeatureFlag_InteractionTracing is disabled. Type Boolean Default false Networking feature flags If used, be sure to call the feature flag before the New Relic iOS agent start call. NRFeatureFlag_ExperimentalNetworkingInstrumentation Caution Enabling this feature flag call may decrease the stability of applications. Avoid using unless instructed by New Relic. Enable or disable (default) experimental networking instrumentation. This forces all NSURLConnection network requests through the NRMAURProtocol. Type Boolean Default false NRFeatureFlag_NSURLSessionInstrumentation Enable (default) or disable networking instrumentation for NSURLSession. These URL traces are sent to the HTTP Requests page. Type Boolean Default true NRFeatureFlag_NetworkRequestEvents Enable or disable (default) networking instrumentation. This sends the HTTP response data as MobileRequest events. Available for iOS Agent version 5.14.0 and higher Type Boolean Default true - Enabled by default as of 6.0.0 NRFeatureFlag_RequestErrorEvents Enable (default) or disable HTTP request error event generation of instrumented network calls that result in an error or failure. These events are reported as MobileRequestError events. Available for iOS Agent version 5.11.0 and higher Type Boolean Default true NRFeatureFlag_HttpResponseBodyCapture Enable or disable capture of HTTP response bodies for HTTP error traces, and MobileRequestError events. Type Boolean Default true",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.32925,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> agent configuration and feature flags",
        "sections": "<em>iOS</em> agent configuration and feature flags",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> agent provides configuration settings to change the default behavior of the agent. If used, implement these flags just before calling: Objective-C: +[<em>NewRelic</em> startWithApplicationToken:] Swift: <em>NewRelic</em>.start(withApplicationToken:) Enable or disable feature flags To configure"
      },
      "id": "619eaa7e28ccbc1559b9b002"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-12-30T02:13:19Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.89979,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/tvos/cocoapods-tvos-installation-configuration": [
    {
      "sections": [
        "New Relic for tvOS compatibility and requirements",
        "tvOS requirements"
      ],
      "title": "New Relic for tvOS compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "ceb80d833a4f472ce844f6aafecd0f50625b3911",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/new-relic-tvos-compatibility-requirements/",
      "published_at": "2021-12-30T03:33:40Z",
      "updated_at": "2021-07-09T13:30:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install and configure the tvOS agent, make sure your tvOS app meets these requirements. tvOS requirements Make sure your tvOS app meets these requirements: Mobile monitoring tvOS requirements Operating system tvOS 9 or higher API/SDK NSURLConnection, AFNetworking, and ASIHttpRequest networking APIs Languages Objective-C Swift: Works with both network traces and crash reporting, but no interaction traces by default. To enable this, see Enabling interaction tracing in Swift. Devices Any tvOS compatible device (Apple TV 4th generation or higher) File sizes The tvOS agent adds about 270K to your tvOS release app. Architectures ARM 64-bit",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 289.12076,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> for <em>tvOS</em> compatibility and requirements",
        "sections": "<em>New</em> <em>Relic</em> for <em>tvOS</em> compatibility and requirements",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Before you install and configure the <em>tvOS</em> agent, make sure your <em>tvOS</em> app meets these requirements. <em>tvOS</em> requirements Make sure your <em>tvOS</em> app meets these requirements: <em>Mobile</em> <em>monitoring</em> <em>tvOS</em> requirements Operating system <em>tvOS</em> 9 or higher API&#x2F;SDK NSURLConnection, AFNetworking, and ASIHttpRequest"
      },
      "id": "60441ac6196a67e457960f6d"
    },
    {
      "sections": [
        "Upgrade the tvOS SDK",
        "Contents",
        "Replacing your tvOS framework"
      ],
      "title": "Upgrade the tvOS SDK",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "f5d6d3d356952d185b96aa409605b79e3ace8ec9",
      "image": "https://docs.newrelic.com/static/a3b6801675529d8f4eba123cf08e8f1f/c1b63/Mobile_tvOS_replace-framework_1.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/upgrading-new-relic-mobiles-tvos-sdk/",
      "published_at": "2021-12-30T03:33:40Z",
      "updated_at": "2021-07-09T08:17:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You must be the account Admin to install, configure, and upgrade the tvOS agent. For information about the latest version, refer to the release notes. Contents Replacing your tvOS framework Admins: You must replace the earlier version of your tvOS agent framework before upgrading to a newer version of the tvOS SDK. Here is an example of the workflow to remove your existing tvOS agent framework so you can replace it with a newer version. From the Project Navigator (CMD 1) in Xcode, search for NewRelicAgentTVOS.framework. Right-click or control-click NewRelicAgentTVOS.framework, and select Show in Finder. Drag NewRelicAgentTVOS.framework to the trash. Verify that the Xcode project highlights the reference to NewRelicAgentTVOS.framework in red. Right-click or control-click NewRelicAgentTVOS.framework, and select Delete to remove the obsolete reference from the project. Follow standard installation procedures for tvOS app monitoring.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 288.48972,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upgrade the <em>tvOS</em> SDK",
        "sections": "Upgrade the <em>tvOS</em> SDK",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " in Finder. Drag <em>NewRelicAgentTVOS</em>.framework to the trash. Verify that the Xcode project highlights the reference to <em>NewRelicAgentTVOS</em>.framework in red. Right-click or control-click <em>NewRelicAgentTVOS</em>.framework, and select Delete to remove the obsolete reference from the project. Follow standard installation procedures for <em>tvOS</em> app <em>monitoring</em>."
      },
      "id": "604416cc64441f805c378ecf"
    },
    {
      "sections": [
        "tvOS installation and configuration",
        "Tip",
        "Installing your tvOS application",
        "Configuring your tvOS application",
        "Executing a demo crash (optional)",
        "Changing the logging level (optional)"
      ],
      "title": "tvOS installation and configuration",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "04798a275a7591bfbafb5437194cfbab4b33d8e3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/tvos-installation-configuration/",
      "published_at": "2021-12-30T03:33:41Z",
      "updated_at": "2021-07-09T10:39:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to install and configure the tvOS agent. Tip tvOS apps using Cocoapods have separate installation procedures. Installing your tvOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor. For Admins with existing New Relic accounts, follow these steps to install and configure your application. (If you don't have a New Relic account, signup at newrelic.com/signup—it's free, forever.) Go to one.newrelic.com and click Mobile. If applicable: From the Mobile Apps list, select Add a new app From the Get Started page, select tvOS as the platform for mobile monitoring. Type a name for your mobile app, and select Continue. Configuring your tvOS application These procedures to configure your tvOS app are also available on the Get Started page in the mobile monitoring UI. Download and unzip the tvOS SDK. To add the New Relic tvOS Mobile Framework to your Xcode project: Use Finder to drag the NewRelicAgentTVOS.framework folder into your Xcode project, and drop it onto your Project in the Project Navigator window. Follow the prompts to copy items into destination and to create folder references. Add the SystemConfiguration.framework, libc++.tbd, and libz.tbd libraries to your Linker settings. To start the agent: Import the tvOS agent header at the top of your prefix.pch. Add + [ NewRelic startWithApplicationToken: < appToken>] to the top of -application:didFinishLaunchingWithOptions: in your AppDelegate.m using the unique application token that is automatically generated. Add a build script to your target's Build Phases and paste the following, replacing PUT_NEW_RELIC_APP_TOKEN_HERE with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, and then run it in the simulator or other device. Within a few minutes you will begin to see data for your iOS app: Go to one.newrelic.com > Mobile > (selected app). If you don't, see No data appears. Executing a demo crash (optional) If you have trouble getting your app to crash, the New Relic agent provides an API to execute a demo crash. Recommendation: Add one of these lines of code to a button click event handler as applicable: [NewRelic crashNow]; Copy OR [NewRelic crashNow:@\"<reason>\"]; Copy Changing the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling startWithApplicationToken: [NRLogger setLogLevels:NRLogLevelALL]; Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 287.02368,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>tvOS</em> <em>installation</em> and configuration",
        "sections": "<em>tvOS</em> <em>installation</em> and configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " Started page in the <em>mobile</em> <em>monitoring</em> UI. Download and unzip the <em>tvOS</em> SDK. To add the <em>New</em> <em>Relic</em> <em>tvOS</em> <em>Mobile</em> Framework to your Xcode project: Use Finder to drag the <em>NewRelicAgentTVOS</em>.framework folder into your Xcode project, and drop it onto your Project in the Project Navigator window. Follow the prompts"
      },
      "id": "60441ac5e7b9d26bb55799b6"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/tvos/new-relic-tvos-compatibility-requirements": [
    {
      "sections": [
        "Upgrade the tvOS SDK",
        "Contents",
        "Replacing your tvOS framework"
      ],
      "title": "Upgrade the tvOS SDK",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "f5d6d3d356952d185b96aa409605b79e3ace8ec9",
      "image": "https://docs.newrelic.com/static/a3b6801675529d8f4eba123cf08e8f1f/c1b63/Mobile_tvOS_replace-framework_1.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/upgrading-new-relic-mobiles-tvos-sdk/",
      "published_at": "2021-12-30T03:33:40Z",
      "updated_at": "2021-07-09T08:17:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You must be the account Admin to install, configure, and upgrade the tvOS agent. For information about the latest version, refer to the release notes. Contents Replacing your tvOS framework Admins: You must replace the earlier version of your tvOS agent framework before upgrading to a newer version of the tvOS SDK. Here is an example of the workflow to remove your existing tvOS agent framework so you can replace it with a newer version. From the Project Navigator (CMD 1) in Xcode, search for NewRelicAgentTVOS.framework. Right-click or control-click NewRelicAgentTVOS.framework, and select Show in Finder. Drag NewRelicAgentTVOS.framework to the trash. Verify that the Xcode project highlights the reference to NewRelicAgentTVOS.framework in red. Right-click or control-click NewRelicAgentTVOS.framework, and select Delete to remove the obsolete reference from the project. Follow standard installation procedures for tvOS app monitoring.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 288.48972,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upgrade the <em>tvOS</em> SDK",
        "sections": "Upgrade the <em>tvOS</em> SDK",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " in Finder. Drag <em>NewRelicAgentTVOS</em>.framework to the trash. Verify that the Xcode project highlights the reference to <em>NewRelicAgentTVOS</em>.framework in red. Right-click or control-click <em>NewRelicAgentTVOS</em>.framework, and select Delete to remove the obsolete reference from the project. Follow standard installation procedures for <em>tvOS</em> app <em>monitoring</em>."
      },
      "id": "604416cc64441f805c378ecf"
    },
    {
      "sections": [
        "tvOS installation and configuration",
        "Tip",
        "Installing your tvOS application",
        "Configuring your tvOS application",
        "Executing a demo crash (optional)",
        "Changing the logging level (optional)"
      ],
      "title": "tvOS installation and configuration",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "04798a275a7591bfbafb5437194cfbab4b33d8e3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/tvos-installation-configuration/",
      "published_at": "2021-12-30T03:33:41Z",
      "updated_at": "2021-07-09T10:39:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to install and configure the tvOS agent. Tip tvOS apps using Cocoapods have separate installation procedures. Installing your tvOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor. For Admins with existing New Relic accounts, follow these steps to install and configure your application. (If you don't have a New Relic account, signup at newrelic.com/signup—it's free, forever.) Go to one.newrelic.com and click Mobile. If applicable: From the Mobile Apps list, select Add a new app From the Get Started page, select tvOS as the platform for mobile monitoring. Type a name for your mobile app, and select Continue. Configuring your tvOS application These procedures to configure your tvOS app are also available on the Get Started page in the mobile monitoring UI. Download and unzip the tvOS SDK. To add the New Relic tvOS Mobile Framework to your Xcode project: Use Finder to drag the NewRelicAgentTVOS.framework folder into your Xcode project, and drop it onto your Project in the Project Navigator window. Follow the prompts to copy items into destination and to create folder references. Add the SystemConfiguration.framework, libc++.tbd, and libz.tbd libraries to your Linker settings. To start the agent: Import the tvOS agent header at the top of your prefix.pch. Add + [ NewRelic startWithApplicationToken: < appToken>] to the top of -application:didFinishLaunchingWithOptions: in your AppDelegate.m using the unique application token that is automatically generated. Add a build script to your target's Build Phases and paste the following, replacing PUT_NEW_RELIC_APP_TOKEN_HERE with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, and then run it in the simulator or other device. Within a few minutes you will begin to see data for your iOS app: Go to one.newrelic.com > Mobile > (selected app). If you don't, see No data appears. Executing a demo crash (optional) If you have trouble getting your app to crash, the New Relic agent provides an API to execute a demo crash. Recommendation: Add one of these lines of code to a button click event handler as applicable: [NewRelic crashNow]; Copy OR [NewRelic crashNow:@\"<reason>\"]; Copy Changing the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling startWithApplicationToken: [NRLogger setLogLevels:NRLogLevelALL]; Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 287.02368,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>tvOS</em> <em>installation</em> and configuration",
        "sections": "<em>tvOS</em> <em>installation</em> and configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " Started page in the <em>mobile</em> <em>monitoring</em> UI. Download and unzip the <em>tvOS</em> SDK. To add the <em>New</em> <em>Relic</em> <em>tvOS</em> <em>Mobile</em> Framework to your Xcode project: Use Finder to drag the <em>NewRelicAgentTVOS</em>.framework folder into your Xcode project, and drop it onto your Project in the Project Navigator window. Follow the prompts"
      },
      "id": "60441ac5e7b9d26bb55799b6"
    },
    {
      "sections": [
        "CocoaPods for tvOS installation and configuration",
        "Install your tvOS application",
        "Configure using Objective-C",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods for tvOS installation and configuration",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "dd8c9ed16a980b08c67150dada56e129900202bd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/cocoapods-tvos-installation-configuration/",
      "published_at": "2021-12-30T03:32:43Z",
      "updated_at": "2021-07-21T20:49:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply only to tvOS apps using Cocoapods. For all other types of tvOS apps, see tvOS installation and configuration. Install your tvOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: Select Add more data, select XCFramework. From the drawer, select the New Relic account you would like to add your tvOS application to, and select Continue. Type a name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring. Configure using Objective-C These procedures to configure your tvOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your [app_name]-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions: [NewRelicAgent startWithApplicationToken:@\"<appToken>\"]; Copy Add a build script to your target's Build Phases and paste the following, replacing \"PUT_NEW_RELIC_APP_TOKEN_HERE\" with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/bash \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, then run it in the simulator or other device. Within a few minutes you will begin to see data for your app: Go to one.newrelic.com > Mobile > (select an app). Configure using Swift These procedures to configure your tvOS app with CocoaPods and Swift are also available on the Get Started page in the mobile monitoring UI: In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your [ app_name]-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions: NewRelic.startWithApplicationToken(\"<appToken>\"); Copy Add a build script to your target's Build Phases and paste the following, replacing NEW_RELIC_APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/bash \"${SCRIPT}\" NEW_RELIC_APP_TOKEN Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling startWithApplicationToken: [NRLogger setLogLevels:NRLogLevelALL]; Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 285.2001,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods for <em>tvOS</em> <em>installation</em> and configuration",
        "sections": "CocoaPods for <em>tvOS</em> <em>installation</em> and configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " for authenticating each <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: Select Add more data, select XCFramework. From the drawer, select the <em>New</em> <em>Relic</em> account you would like to add your <em>tvOS</em> application to, and select"
      },
      "id": "60441ac6196a6710e4960f57"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/tvos/tvos-installation-configuration": [
    {
      "sections": [
        "New Relic for tvOS compatibility and requirements",
        "tvOS requirements"
      ],
      "title": "New Relic for tvOS compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "ceb80d833a4f472ce844f6aafecd0f50625b3911",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/new-relic-tvos-compatibility-requirements/",
      "published_at": "2021-12-30T03:33:40Z",
      "updated_at": "2021-07-09T13:30:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install and configure the tvOS agent, make sure your tvOS app meets these requirements. tvOS requirements Make sure your tvOS app meets these requirements: Mobile monitoring tvOS requirements Operating system tvOS 9 or higher API/SDK NSURLConnection, AFNetworking, and ASIHttpRequest networking APIs Languages Objective-C Swift: Works with both network traces and crash reporting, but no interaction traces by default. To enable this, see Enabling interaction tracing in Swift. Devices Any tvOS compatible device (Apple TV 4th generation or higher) File sizes The tvOS agent adds about 270K to your tvOS release app. Architectures ARM 64-bit",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 289.12076,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> for <em>tvOS</em> compatibility and requirements",
        "sections": "<em>New</em> <em>Relic</em> for <em>tvOS</em> compatibility and requirements",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Before you install and configure the <em>tvOS</em> agent, make sure your <em>tvOS</em> app meets these requirements. <em>tvOS</em> requirements Make sure your <em>tvOS</em> app meets these requirements: <em>Mobile</em> <em>monitoring</em> <em>tvOS</em> requirements Operating system <em>tvOS</em> 9 or higher API&#x2F;SDK NSURLConnection, AFNetworking, and ASIHttpRequest"
      },
      "id": "60441ac6196a67e457960f6d"
    },
    {
      "sections": [
        "Upgrade the tvOS SDK",
        "Contents",
        "Replacing your tvOS framework"
      ],
      "title": "Upgrade the tvOS SDK",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "f5d6d3d356952d185b96aa409605b79e3ace8ec9",
      "image": "https://docs.newrelic.com/static/a3b6801675529d8f4eba123cf08e8f1f/c1b63/Mobile_tvOS_replace-framework_1.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/upgrading-new-relic-mobiles-tvos-sdk/",
      "published_at": "2021-12-30T03:33:40Z",
      "updated_at": "2021-07-09T08:17:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You must be the account Admin to install, configure, and upgrade the tvOS agent. For information about the latest version, refer to the release notes. Contents Replacing your tvOS framework Admins: You must replace the earlier version of your tvOS agent framework before upgrading to a newer version of the tvOS SDK. Here is an example of the workflow to remove your existing tvOS agent framework so you can replace it with a newer version. From the Project Navigator (CMD 1) in Xcode, search for NewRelicAgentTVOS.framework. Right-click or control-click NewRelicAgentTVOS.framework, and select Show in Finder. Drag NewRelicAgentTVOS.framework to the trash. Verify that the Xcode project highlights the reference to NewRelicAgentTVOS.framework in red. Right-click or control-click NewRelicAgentTVOS.framework, and select Delete to remove the obsolete reference from the project. Follow standard installation procedures for tvOS app monitoring.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 288.48972,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upgrade the <em>tvOS</em> SDK",
        "sections": "Upgrade the <em>tvOS</em> SDK",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " in Finder. Drag <em>NewRelicAgentTVOS</em>.framework to the trash. Verify that the Xcode project highlights the reference to <em>NewRelicAgentTVOS</em>.framework in red. Right-click or control-click <em>NewRelicAgentTVOS</em>.framework, and select Delete to remove the obsolete reference from the project. Follow standard installation procedures for <em>tvOS</em> app <em>monitoring</em>."
      },
      "id": "604416cc64441f805c378ecf"
    },
    {
      "sections": [
        "CocoaPods for tvOS installation and configuration",
        "Install your tvOS application",
        "Configure using Objective-C",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods for tvOS installation and configuration",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "dd8c9ed16a980b08c67150dada56e129900202bd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/cocoapods-tvos-installation-configuration/",
      "published_at": "2021-12-30T03:32:43Z",
      "updated_at": "2021-07-21T20:49:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply only to tvOS apps using Cocoapods. For all other types of tvOS apps, see tvOS installation and configuration. Install your tvOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: Select Add more data, select XCFramework. From the drawer, select the New Relic account you would like to add your tvOS application to, and select Continue. Type a name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring. Configure using Objective-C These procedures to configure your tvOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your [app_name]-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions: [NewRelicAgent startWithApplicationToken:@\"<appToken>\"]; Copy Add a build script to your target's Build Phases and paste the following, replacing \"PUT_NEW_RELIC_APP_TOKEN_HERE\" with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/bash \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, then run it in the simulator or other device. Within a few minutes you will begin to see data for your app: Go to one.newrelic.com > Mobile > (select an app). Configure using Swift These procedures to configure your tvOS app with CocoaPods and Swift are also available on the Get Started page in the mobile monitoring UI: In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your [ app_name]-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions: NewRelic.startWithApplicationToken(\"<appToken>\"); Copy Add a build script to your target's Build Phases and paste the following, replacing NEW_RELIC_APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/bash \"${SCRIPT}\" NEW_RELIC_APP_TOKEN Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling startWithApplicationToken: [NRLogger setLogLevels:NRLogLevelALL]; Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 285.2001,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods for <em>tvOS</em> <em>installation</em> and configuration",
        "sections": "CocoaPods for <em>tvOS</em> <em>installation</em> and configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " for authenticating each <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: Select Add more data, select XCFramework. From the drawer, select the <em>New</em> <em>Relic</em> account you would like to add your <em>tvOS</em> application to, and select"
      },
      "id": "60441ac6196a6710e4960f57"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/tvos/upgrading-new-relic-mobiles-tvos-sdk": [
    {
      "sections": [
        "New Relic for tvOS compatibility and requirements",
        "tvOS requirements"
      ],
      "title": "New Relic for tvOS compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "ceb80d833a4f472ce844f6aafecd0f50625b3911",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/new-relic-tvos-compatibility-requirements/",
      "published_at": "2021-12-30T03:33:40Z",
      "updated_at": "2021-07-09T13:30:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install and configure the tvOS agent, make sure your tvOS app meets these requirements. tvOS requirements Make sure your tvOS app meets these requirements: Mobile monitoring tvOS requirements Operating system tvOS 9 or higher API/SDK NSURLConnection, AFNetworking, and ASIHttpRequest networking APIs Languages Objective-C Swift: Works with both network traces and crash reporting, but no interaction traces by default. To enable this, see Enabling interaction tracing in Swift. Devices Any tvOS compatible device (Apple TV 4th generation or higher) File sizes The tvOS agent adds about 270K to your tvOS release app. Architectures ARM 64-bit",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 289.12076,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> for <em>tvOS</em> compatibility and requirements",
        "sections": "<em>New</em> <em>Relic</em> for <em>tvOS</em> compatibility and requirements",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Before you install and configure the <em>tvOS</em> agent, make sure your <em>tvOS</em> app meets these requirements. <em>tvOS</em> requirements Make sure your <em>tvOS</em> app meets these requirements: <em>Mobile</em> <em>monitoring</em> <em>tvOS</em> requirements Operating system <em>tvOS</em> 9 or higher API&#x2F;SDK NSURLConnection, AFNetworking, and ASIHttpRequest"
      },
      "id": "60441ac6196a67e457960f6d"
    },
    {
      "sections": [
        "tvOS installation and configuration",
        "Tip",
        "Installing your tvOS application",
        "Configuring your tvOS application",
        "Executing a demo crash (optional)",
        "Changing the logging level (optional)"
      ],
      "title": "tvOS installation and configuration",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "04798a275a7591bfbafb5437194cfbab4b33d8e3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/tvos-installation-configuration/",
      "published_at": "2021-12-30T03:33:41Z",
      "updated_at": "2021-07-09T10:39:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to install and configure the tvOS agent. Tip tvOS apps using Cocoapods have separate installation procedures. Installing your tvOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor. For Admins with existing New Relic accounts, follow these steps to install and configure your application. (If you don't have a New Relic account, signup at newrelic.com/signup—it's free, forever.) Go to one.newrelic.com and click Mobile. If applicable: From the Mobile Apps list, select Add a new app From the Get Started page, select tvOS as the platform for mobile monitoring. Type a name for your mobile app, and select Continue. Configuring your tvOS application These procedures to configure your tvOS app are also available on the Get Started page in the mobile monitoring UI. Download and unzip the tvOS SDK. To add the New Relic tvOS Mobile Framework to your Xcode project: Use Finder to drag the NewRelicAgentTVOS.framework folder into your Xcode project, and drop it onto your Project in the Project Navigator window. Follow the prompts to copy items into destination and to create folder references. Add the SystemConfiguration.framework, libc++.tbd, and libz.tbd libraries to your Linker settings. To start the agent: Import the tvOS agent header at the top of your prefix.pch. Add + [ NewRelic startWithApplicationToken: < appToken>] to the top of -application:didFinishLaunchingWithOptions: in your AppDelegate.m using the unique application token that is automatically generated. Add a build script to your target's Build Phases and paste the following, replacing PUT_NEW_RELIC_APP_TOKEN_HERE with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, and then run it in the simulator or other device. Within a few minutes you will begin to see data for your iOS app: Go to one.newrelic.com > Mobile > (selected app). If you don't, see No data appears. Executing a demo crash (optional) If you have trouble getting your app to crash, the New Relic agent provides an API to execute a demo crash. Recommendation: Add one of these lines of code to a button click event handler as applicable: [NewRelic crashNow]; Copy OR [NewRelic crashNow:@\"<reason>\"]; Copy Changing the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling startWithApplicationToken: [NRLogger setLogLevels:NRLogLevelALL]; Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 287.02368,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>tvOS</em> <em>installation</em> and configuration",
        "sections": "<em>tvOS</em> <em>installation</em> and configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " Started page in the <em>mobile</em> <em>monitoring</em> UI. Download and unzip the <em>tvOS</em> SDK. To add the <em>New</em> <em>Relic</em> <em>tvOS</em> <em>Mobile</em> Framework to your Xcode project: Use Finder to drag the <em>NewRelicAgentTVOS</em>.framework folder into your Xcode project, and drop it onto your Project in the Project Navigator window. Follow the prompts"
      },
      "id": "60441ac5e7b9d26bb55799b6"
    },
    {
      "sections": [
        "CocoaPods for tvOS installation and configuration",
        "Install your tvOS application",
        "Configure using Objective-C",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods for tvOS installation and configuration",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "dd8c9ed16a980b08c67150dada56e129900202bd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/cocoapods-tvos-installation-configuration/",
      "published_at": "2021-12-30T03:32:43Z",
      "updated_at": "2021-07-21T20:49:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply only to tvOS apps using Cocoapods. For all other types of tvOS apps, see tvOS installation and configuration. Install your tvOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: Select Add more data, select XCFramework. From the drawer, select the New Relic account you would like to add your tvOS application to, and select Continue. Type a name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring. Configure using Objective-C These procedures to configure your tvOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your [app_name]-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions: [NewRelicAgent startWithApplicationToken:@\"<appToken>\"]; Copy Add a build script to your target's Build Phases and paste the following, replacing \"PUT_NEW_RELIC_APP_TOKEN_HERE\" with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/bash \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, then run it in the simulator or other device. Within a few minutes you will begin to see data for your app: Go to one.newrelic.com > Mobile > (select an app). Configure using Swift These procedures to configure your tvOS app with CocoaPods and Swift are also available on the Get Started page in the mobile monitoring UI: In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your [ app_name]-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions: NewRelic.startWithApplicationToken(\"<appToken>\"); Copy Add a build script to your target's Build Phases and paste the following, replacing NEW_RELIC_APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/bash \"${SCRIPT}\" NEW_RELIC_APP_TOKEN Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling startWithApplicationToken: [NRLogger setLogLevels:NRLogLevelALL]; Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 285.2001,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods for <em>tvOS</em> <em>installation</em> and configuration",
        "sections": "CocoaPods for <em>tvOS</em> <em>installation</em> and configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " for authenticating each <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: Select Add more data, select XCFramework. From the drawer, select the <em>New</em> <em>Relic</em> account you would like to add your <em>tvOS</em> application to, and select"
      },
      "id": "60441ac6196a6710e4960f57"
    }
  ],
  "/docs/more-integrations/grafana-integrations/get-started/grafana-support-prometheus-promql": [
    {
      "sections": [
        "Get started with New Relic observability",
        "Get your data into New Relic with our quickstarts",
        "Some technical detail",
        "Guided install for New Relic",
        "All the answers in one place"
      ],
      "title": "Get started with New Relic observability",
      "type": "docs",
      "tags": [
        "Observe everything",
        "Get started"
      ],
      "external_id": "30f87d5f702f926efec49b59591679fa93627ad5",
      "image": "https://docs.newrelic.com/static/44970161aec793f3141cfcdc0fc96a57/c1b63/observability-2.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/get-started-full-stack-observability/",
      "published_at": "2021-12-31T01:18:16Z",
      "updated_at": "2021-12-31T01:18:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "True observability is the power of knowing what's happening across your digital system and why it's happening—at any time, whatever solution you’re using. It’s getting the whole picture of everything that enables your applications and devices to deliver value to your customers, from the container running a microservice in the cloud to a mobile website's shopping cart button. Our platform goes beyond simple monitoring by offering you observability: data insights to help you make proactive and predictive improvements to your environment. A comparison between simple monitoring and observability. Get your data into New Relic with our quickstarts New Relic I/O is a rich catalog of open-source quickstarts that automatically include integrations, dashboards, and alerts for you to use immediately. Popular technologies such as Node.js, Python, and Ruby have full-featured quickstarts, while others contain a mixture of tools. Each quickstart is created by observability experts around the world, vetted by New Relic, and ready for you to install with one click. Leverage community expertise and get more value out of your telemetry data with New Relic I/O, your hub for instant observability. Ready to get started? Find your quickstart in New Relic I/O: New Relic I/O New Relic I/O is open source, which means that you can modify and improve existing quickstarts, or build new ones, to suit your needs. We thoroughly review external edits to our quickstarts for value and quality. Interested in contributing to the community? Check out our contributor guide in GitHub. Some technical detail New Relic quickstarts use open source installation recipes to instrument integrations using our guided install process. Guided install for New Relic Alternatively, if you're comfortable with the command line, our guided install discovers the applications, infrastructure, and log sources running in your environment, and recommends which ones should be instrumented. The install automates the configuration and deployment of each system you choose to instrument. If your account reports data through our EU data center, click EU Guided install. Guided install EU Guided install All the answers in one place Once your data is in New Relic, we give you a UI with tools to cut through the layers of complexity surrounding your systems. This is all in one platform so you don't need to switch between diagnostic applications. You can interrogate your data for patterns, discover them using our data platform, or get proactive results from our machine learning tools. As a full platform user you get access to our entire set of observability tools. All our tools are interconnected and accessible in New Relic One. All the data you bring to New Relic through agents and integrations are metrics, events, logs, and traces that feed our platform's analytics and monitoring capabilities. New Relic links your data in a meaningful way so that you can explore it, build dashboards, and set up alerts. Our out-of-the-box observability UI experiences allow to visualize, analyze, and troubleshoot your entire software stack in one unified platform. The New Relic Explorer consolidates all the entities in your system, and how they're connected, in a single place, so you can easily detect performance trends and issues. By automatically connecting infrastructure health with application performance and end-user behavior, you can cut through the noise to find useful signals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 130.85892,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> <em>started</em> with New Relic observability",
        "sections": "<em>Get</em> <em>started</em> with New Relic observability",
        "tags": "<em>Get</em> <em>started</em>",
        "body": ". <em>Get</em> your data into New Relic with our quickstarts New Relic I&#x2F;O is a rich catalog of open-source quickstarts that automatically include <em>integrations</em>, dashboards, and alerts for you to use immediately. Popular technologies such as Node.js, Python, and Ruby have full-featured quickstarts, while"
      },
      "id": "61743c6764441f60375fd317"
    },
    {
      "sections": [
        "Introduction to Azure monitoring integrations",
        "Requirements",
        "Features",
        "Cost considerations"
      ],
      "title": "Introduction to Azure monitoring integrations",
      "type": "docs",
      "tags": [
        "Integrations",
        "Microsoft Azure integrations",
        "Get started"
      ],
      "external_id": "7ce4149eca2602fa1a29c921fa8876ad96abd254",
      "image": "",
      "url": "https://docs.newrelic.com/docs/infrastructure/microsoft-azure-integrations/get-started/introduction-azure-monitoring-integrations/",
      "published_at": "2021-12-30T11:01:12Z",
      "updated_at": "2021-12-25T13:06:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Microsoft Azure integrations allow you to monitor and report data about your Azure services to New Relic, providing a comprehensive view of your entire architecture in one place. The Azure integrations are not the same as APM's .NET support for Azure. Requirements Check the Azure integrations documentation for requirements on individual integrations. New Relic cannot obtain monitoring data from resources that are located in Azure Government or that were created through the classic deployment model. Features After you activate your Azure integration, New Relic begins to query your Azure platform services according to a regular polling interval. You can use our integrations UI to: View performance data from Integrations dashboards that automatically scale as you make changes to your ecosystem. Manage alert conditions with alerts. Query your data. Cost considerations When evaluating the cost of the Microsoft Azure integrations with New Relic, consider Azure's Monitor Pricing. Refer to the \"Metric queries\" cost item in the Azure pricing documentation. Pricing is based on the number of API calls per month. An estimation of the API calls peformed by New Relic to the different Azure services can be seen in the UI, under Infrastructure > Azure > Azure Status Dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.1775,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to Azure monitoring <em>integrations</em>",
        "sections": "Introduction to Azure monitoring <em>integrations</em>",
        "tags": "<em>Get</em> <em>started</em>",
        "body": "Our Microsoft Azure <em>integrations</em> allow you to monitor and report data about your Azure services to New Relic, providing a comprehensive view of your entire architecture in one place. The Azure <em>integrations</em> are not the same as APM&#x27;s .NET support for Azure. Requirements Check the Azure <em>integrations</em>"
      },
      "id": "617d53f828ccbcd2fd7ffaf2"
    },
    {
      "sections": [
        "Introduction to New Relic NerdGraph, our GraphQL API",
        "What is NerdGraph?",
        "Important",
        "Use the GraphiQL explorer",
        "Requirements and endpoints",
        "What can you do with NerdGraph?",
        "NerdGraph terminology",
        "Tips on using the GraphiQL explorer",
        "Query accounts a New Relic user can access",
        "Query user, account, and NRQL in one request"
      ],
      "title": "Introduction to New Relic NerdGraph, our GraphQL API",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Get started"
      ],
      "external_id": "e8e96c16cd75f494ebfacb3bc53b4ee9ccf1c727",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph/",
      "published_at": "2021-12-30T03:45:24Z",
      "updated_at": "2021-12-25T06:06:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NerdGraph is our GraphQL-format API that lets you query New Relic data and configure some New Relic features. After you sign up for a free New Relic account and install any of our monitoring services, you can get started with NerdGraph. What is NerdGraph? New Relic has several APIs. NerdGraph is the API we recommend for querying New Relic data and for performing some specific configurations (learn more about features). NerdGraph provides a single API interface for returning data from New Relic’s various APIs and microservices. Over time, other configuration capabilities will be added to NerdGraph. Important NerdGraph isn’t used for data ingest. For that, you'd use our data ingest APIs. NerdGraph is built using GraphQL, which is an open source API format that allows you to request exactly the data needed, with no over-fetching or under-fetching. For a lesson in how to use NerdGraph, watch this 7-minute video: Want to watch more video tutorials? Go to the New Relic University’s Intro to NerdGraph. Or see the online course on New Relic APIs. Use the GraphiQL explorer To get started using GraphQL, we recommend playing around with our GraphiQL explorer (GraphiQL is an open source graphical interface for using GraphQL). You can use it to explore our data schema, to read built-in object definitions, and to build and execute queries. To use GraphQL, you’ll need a user-specific New Relic API key called a user key. You can generate one or find an existing one from the GraphiQL explorer’s API key dropdown. To find the GraphiQL explorer: If your New Relic account uses an EU data center, go to api.eu.newrelic.com/graphiql. Otherwise use api.newrelic.com/graphiql. For tips on how to build queries, see Build queries. Requirements and endpoints To use NerdGraph, you need a New Relic user key, which can be generated and accessed from the GraphiQL explorer. The endpoints are: Main endpoint: https://api.newrelic.com/graphql Endpoint for accounts using EU data center: https://api.eu.newrelic.com/graphql To access the endpoint, use the following cURL command: curl -X POST https://api.newrelic.com/graphql \\ -H 'Content-Type: application/json' \\ -H 'API-Key: YOUR_NEW_RELIC_USER_KEY' \\ -d '{ \"query\": \"{ requestContext { userId apiKey } }\" } ' Copy What can you do with NerdGraph? NerdGraph functionality can be broken down into two main categories: Querying New Relic data. You can fetch data for a variety of purposes, including using it in a programmatic workflow, or building a New Relic One app for custom data visualizations. Configuring New Relic features. There are a variety of configurations available and more will be added over time. You can do things like add tags, configure workloads, or customize \"golden metrics.\" You can use NerdGraph to return a wide range of New Relic data but we’ve created some tutorials for common use cases: Topic Tutorials Your monitored entities Get data about entities Understand entity relationships and dependencies (used to build service maps) Query and configure \"golden metrics\" (important entity metrics) Querying data Query using NRQL (our query language) Tags Add and manage tags APM agents APM agent configuration Dashboards Create dashboards Export dashboards to other accounts Export dashboards as files Migrate from Insights Dashboard API to NerdGraph Alerts See all alert-related tutorials Applied Intelligence View and configure topology Workloads View and configure workloads Service Levels Configure and manage Service Levels Manage keys Create and manage keys (license keys used for data ingest, and user keys) Manage data Convert event data to metric data Drop data Distributed tracing Query distributed tracing data Configure Infinite Tracing New Relic One apps Build a New Relic One app Cloud integrations (AWS, Azure, GCP) Configure cloud integrations Partners and resellers Manage subscriptions (only for partners using original pricing model) Data partitions Manage data partitions Date retention Manage data retention NerdGraph terminology The following are terms that originate with GraphQL (the API format NerdGraph uses). Term Definition Queries and mutations There are two classes of GraphQL operations: Queries are basic requests used only to fetch data. These queries are not static, meaning that you can ask for more data or less data, depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Mutations are requests that perform an action, such as creating a resource or changing configuration. Mutations require the keyword mutation, as well as the name of the mutation. Type Data in GraphQL is organized into types. Types can be scalars (like strings, numbers, or booleans) or object types. An object type is a custom type made up of a collection of fields. For example, an object type called User may represent a user in a system. Field A field represents a piece of information on an object type that can be queried. Fields can be scalars, lists, or objects. For example, a User object type could have a string field called name. Interface An interface is an abstract type that represents a collection of common fields that other object types can implement. Tips on using the GraphiQL explorer You can make queries with the NerdGraph GraphiQL explorer. The explorer provides built-in schema definitions and features, including auto-complete and query validation. Query accounts a New Relic user can access You can query for the name of an account that an actor (a New Relic authorized user) has access to: query { actor { account(id: YOUR_ACCOUNT_ID) { name } } } Copy The response will mirror the query structure you defined in the request, making it easy to ask for the specific data that you want. { \"data\": { \"actor\": { \"account\": { \"name\": \"Data Nerd\" } } } } Copy Query user, account, and NRQL in one request The graph structure shows its capabilities when queries become more complex. For example, you can query for user information, account information, and make a NRQL query with one request. With REST API, this would take three different requests to three different endpoints. query { actor { account(id: YOUR_ACCOUNT_ID) { name nrql(query: \"SELECT * FROM Transaction\") { results } } user { name id } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 95.652374,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Get</em> <em>started</em>",
        "body": "NerdGraph is our GraphQL-format API that lets you query New Relic data and configure some New Relic features. After you sign up for a free New Relic account and install any of our monitoring services, you can <em>get</em> <em>started</em> with NerdGraph. What is NerdGraph? New Relic has several APIs. NerdGraph"
      },
      "id": "6043ff97196a67d0a0960f55"
    }
  ],
  "/docs/more-integrations/grafana-integrations/set-configure/configure-new-relic-prometheus-data-source-grafana": [
    {
      "sections": [
        "Grafana support with Prometheus and PromQL",
        "Use existing Grafana dashboards with New Relic",
        "Compatibility and requirements",
        "Support for PromQL",
        "Get data flowing in Grafana",
        "What’s next?"
      ],
      "title": "Grafana support with Prometheus and PromQL",
      "type": "docs",
      "tags": [
        "Integrations",
        "Grafana integrations",
        "Get started"
      ],
      "external_id": "f65c7d9ecdd0bdcabc33b3668f12bf9a958fa940",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/grafana-integrations/get-started/grafana-support-prometheus-promql/",
      "published_at": "2021-12-30T03:34:27Z",
      "updated_at": "2021-10-24T03:13:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In Grafana, you can configure New Relic as a Prometheus data source. Not only that, within Grafana you can query metrics stored in New Relic using the PromQL query language. Use existing Grafana dashboards with New Relic When you integrate Prometheus metrics with New Relic via Remote Write or the OpenMetrics Integration (2.0+) and configure New Relic as a Prometheus data source in Grafana, you can use existing Grafana dashboards and seamlessly tap into the additional monitoring, reliability, and scale we provide. Compatibility and requirements Before you begin, make sure you’ve finished integrating Prometheus metrics and are running a recent enough version of Grafana. You should have either the Remote Write or the OpenMetrics Integration ( v2.0+) set up before you can configure New Relic Prometheus data sources in Grafana. You can only configure New Relic Prometheus data sources using this method in Grafana versions 6.7.0 or newer. You will need to configure custom headers in the UI, and this isn’t possible with earlier versions. For details, see Configure New Relic as a Prometheus data source for Grafana. Support for PromQL Our Prometheus API emulates Prometheus' query APIs. We support the Prometheus query language (PromQL) through our PromQL-style query mode. We do our best to automatically translate PromQL syntax queries into the closest NRQL approximation. For more information on how this works and differences you may observe between Prometheus and New Relic, see Supported PromQL features. Get data flowing in Grafana To make your New Relic data available in Grafana, you can configure a new or existing Prometheus data source in just a couple of simple steps: In the Grafana UI, add and configure a new data source. Save the new data source and start viewing your data. What’s next? Ready to configure a Grafana data source? Read the how-to documentation for setting up the Prometheus remote write integration or the Prometheus OpenMetrics Integration. Read the how-to documentation for configuring Prometheus data sources in Grafana.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.63532,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Grafana</em> support with Prometheus <em>and</em> PromQL",
        "sections": "<em>Grafana</em> support with Prometheus <em>and</em> PromQL",
        "tags": "<em>Grafana</em> <em>integrations</em>",
        "body": " integrating Prometheus metrics and are running a recent enough version of <em>Grafana</em>. You should have either the Remote Write or the OpenMetrics Integration ( v2.0+) <em>set</em> <em>up</em> before you can <em>configure</em> New Relic Prometheus data sources in <em>Grafana</em>. You can only <em>configure</em> New Relic Prometheus data sources using"
      },
      "id": "617db2fd196a6792daf7c5cc"
    },
    {
      "sections": [
        "Kamon reporter",
        "Enable Kamon reporter",
        "Find your data",
        "Resources"
      ],
      "title": "Kamon reporter",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "Kamon"
      ],
      "external_id": "c4101137c4f04a6c6e2fef03f2ab83774a8320f2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/kamon/kamon-reporter/",
      "published_at": "2021-12-30T03:35:14Z",
      "updated_at": "2021-10-24T00:59:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Kamon provides an instrumentation toolkit that specializes in automatic instrumentation of Scala and Akka applications. It consists of APIs for metric and tracing instrumentation and automatic instrumentation modules that create application metrics and distributed traces. Kamon also provides reporter modules to transfer telemetry data to a backend of your choice. New Relic's Kamon reporter is included in the Kamon Bundle, and you can configure it to send telemetry data from your Kamon-instrumented applications to your New Relic account. Enable Kamon reporter To enable our Kamon reporter: If you haven't already, create a New Relic account. It's free, forever. Follow the Kamon reporter installation instructions. Optional: Instead of using the native Kamon trace sampling, you can enable our Infinite Tracing feature. If you use this option, you will typically want to configure Kamon to send us all trace data (learn more about sampling). To enable Infinite Tracing: In the New Relic UI, set up a trace observer. Configure our Kamon reporter to send data to the trace observer: Set the span-ingest-uri value to YOUR_TRACE_OBSERVER_URL in your kamon.newrelic configuration block. Find your data To find your data, go to one.newrelic.com and go to Your applications > Explorer. From the Entities screen, search for your service by name. New Relic provides an out-of-the-box overview that includes charts for some of the most useful metrics provided by Kamon instrumentation. If you're also sending distributed tracing data, the Distributed tracing feature is available to query and view traces. You can use the out-of-the-box overview as a starting point to build your own dashboards. Click on the ... icon in a chart to add that chart to a dashboard or view the query behind the chart to modify it and it add it to your dashboard. For more on how to query your data once it's in New Relic, see Query your data and Introduction to NRQL. Resources Our Kamon reporter resources include: Installation and configuration guide (Kamon site) Integration specs (New Relic GitHub)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 47.289555,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Integrations</em>",
        "body": " us all trace data (learn more about sampling). To enable Infinite Tracing: In the New Relic UI, <em>set</em> <em>up</em> a trace observer. <em>Configure</em> our Kamon reporter to send data to the trace observer: <em>Set</em> the span-ingest-uri value to YOUR_TRACE_OBSERVER_URL in your kamon.newrelic configuration block. Find your"
      },
      "id": "617d77ec196a678a5cf7de1a"
    },
    {
      "sections": [
        "Install New Relic",
        "Install APM",
        "Install browser monitoring",
        "Install infrastructure monitoring",
        "Install mobile monitoring",
        "Install synthetic monitors",
        "Troubleshooting"
      ],
      "title": "Install New Relic ",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Install and configure"
      ],
      "external_id": "819ccfd8df22ff322271245ca0831bf53609b91f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/cross-product-functions/install-configure/install-new-relic/",
      "published_at": "2021-12-31T01:40:19Z",
      "updated_at": "2021-12-30T20:03:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you sign up for a New Relic account (it's free, forever!) and install any of our monitoring services, you can start working with your data. Get started quickly with our New Relic Instant Observability quickstarts. Alternatively, use our guided install. Here are links to instructions on how to install New Relic monitoring services: APM Browser Infrastructure Mobile Synthetic monitors Integrations for third-party telemetry services Data ingest APIs (metrics, events, logs, traces) Install APM C Go Java .NET For Windows .NET applications on IIS, use our guided install in New Relic One to get started with APM. If you're on an EU server, use our launcher for EU accounts instead. Node.js PHP Python Ruby Install browser monitoring See browser monitoring install. Install infrastructure monitoring Linux guided install for infrastructure monitoring Linux procedures for infrastructure monitoring Windows Kubernetes Prometheus On-host integrations (for services like NGINX, StatsD, MySQL, etc.) AWS cloud integrations Azure cloud integrations Google Cloud Platform Install mobile monitoring Android iOS Install synthetic monitors Synthetic monitoring doesn't require installation, except for its private minions feature. Troubleshooting You should start seeing your data in the New Relic UI after installing the agent, generating some traffic, and waiting a few minutes. If no data appears, follow our troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 45.173717,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "Install <em>and</em> <em>configure</em>",
        "body": "After you sign <em>up</em> for a New Relic account (it&#x27;s free, forever!) and install any of our monitoring services, you can start working with your data. Get started quickly with our New Relic Instant Observability quickstarts. Alternatively, use our guided install. Here are links to instructions on how"
      },
      "id": "61b8148ce7b9d22373ef3a8b"
    }
  ],
  "/docs/more-integrations/open-source-telemetry-integrations/dropwizard/dropwizard-reporter": [
    {
      "sections": [
        "Introduction to OpenTelemetry with New Relic",
        "Benefits of OpenTelemetry",
        "Should I use OpenTelemetry instrumentation or New Relic agents?",
        "OpenTelemetry: A work in progress",
        "New Relic's APM agents",
        "How OpenTelemetry works with New Relic",
        "Important",
        "Traces",
        "Metrics",
        "Logs",
        "Next steps"
      ],
      "title": "Introduction to OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "67818451ffb7594e3c27526f4082bd1bc007bc51",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/introduction-opentelemetry-new-relic/",
      "published_at": "2021-12-30T03:36:05Z",
      "updated_at": "2021-12-20T05:36:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Are you already familiar with OpenTelemetry and want to begin the setup? Check out our quick start: Quick start If you don't have one already, create a New Relic account. It's free, forever. If you're just getting acquainted with OpenTelemetry, this is what we'll explore here: Benefits of OpenTelemetry Should I use OpenTelemetry or New Relic agents? How OpenTelemetry works with New Relic Benefits of OpenTelemetry OpenTelemetry provides a secure, vendor-neutral specification for service instrumentation so that you can export data to distinct backends of your choice, such as New Relic. OpenTelemetry offers a single set of APIs and libraries that standardize how you collect and transfer telemetry data for your services. The following components make up the OpenTelemetry project: Specifications for the core pillars of observability to drive consistency across all projects. New Relic supports all of these signals: traces, metrics, and logs (see details below) APIs that contain interfaces and implementations based on the specifications SDKs (reference implementations of the APIs) created specifically for languages like Java, Python, Go, Erlang, and more Collectors that offer a vendor-agnostic implementation for processing and exporting Exporters that enable you to send data to a backend of your choice The components of OpenTelemetry work together to create some distinct advantages for capturing telemetry data: Feature Description Ubiquitous instrumentation A single, open standard of instrumentation provides better coverage and flexibility as engineers from all over the world contribute to the instrumentation. Future proof As the instrumentation gets built into libraries and frameworks, and as more vendors move to support this open standard, you can be confident that you won’t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build integrations into OpenTelemetry or add instrumentation directly to source code, ensuring end users can easily monitor these new technologies. Simplified choice You don’t need to decide which instrumentation option to use (a proprietary option or one of the other open standards). Cross-platform compatibility OpenTelemetry supports a variety of languages and backends. It represents a vendor-neutral path for capturing and transmitting telemetry to backends without altering existing instrumentation. Streamlined observability It is easier for vendors to support and test against a single standard as they don’t need to develop their own agents or collectors. High dimensionality OpenTelemetry uses dimensional metrics, so you can filter and facet on more aspects of the data, such as AWS regions, Kubernetes clusters, or service versions. Dimensional metrics also lead to less time between occurrence and reporting. Should I use OpenTelemetry instrumentation or New Relic agents? As you consider OpenTelemetry, you may also be looking at New Relic APM agents that also capture telemetry data. As you'd expect, there is a lot of overlap between features available from OpenTelemetry agents and SDKs versus those available from New Relic APM agents. This is especially true if you're interested in distributed tracing telemetry data. The choice you make depends on what you need. We recommend that you explore both New Relic and OpenTelemetry instrumentation or discuss this with us in our CNCF Slack channel to decide what works best for you. OpenTelemetry: A work in progress OpenTelemetry is still an emerging standard, so your choices may be affected by what's available. You can check on the current state of the specification at the OpenTelemetry site. The current state of language-specific OpenTelemetry APIs and SDKs varies: some languages are still pre-alpha and may be missing instructions on how to instrument your service. Most languages have some implementation of traces that is sufficient to start exporting data to New Relic. Check out this table in GitHub that provides an overview of the state of OpenTelemetry specification compliance for each language. For languages that New Relic does not currently provide an agent or SDK, OpenTelemetry may offer you a good alternative. Also, in cases where you want explicit control over sampling of your telemetry data, OpenTelemetry provides a lot of flexibility. As OpenTelemetry matures, New Relic will continue to support new OpenTelemetry data models and to provide a curated UI experience for our customers. New Relic's APM agents In general, New Relic's APM agents will collect more telemetry data for your services, and they offer a wide range of configuration options and an extensive set of auto-instrumentation capabilities. New Relic's APM agents offer detailed transaction trace visibility for individual services. They also offer predefined sampling to balance the performance impact of your instrumentation against the need to capture enough data to gain helpful insights. How OpenTelemetry works with New Relic New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemetry community to export your data to New Relic. The following tables show the supported features for each telemetry signal. If you have questions about these or have an unsupported use case, please contact us in our CNCF Slack channel, and watch this page for future updates. Important New Relic's exporters for OpenTelemetry are now deprecated in favor of exporting data to New Relic using OTLP. Traces New Relic offers support for the OTLP ingest of trace signals. The maturity of the upstream specification is stable. OpenTelemetry traces and spans are compatible with New Relic traces and spans. OpenTelemetry spans optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter span data at query time. OpenTelemetry span metadata (for example, name, kind, and trace_id) also map directly to dimensions on NewRelic spans. At this time, New Relic does not support span links or array attributes. For details, see the Traces section of our best practices guide. Feature Supported Span events ✅ Span linking ❌ Array of primitives (homogeneous) ❌ Metrics New Relic offers support for the OTLP ingest of metric signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. Here are the OpenTelemetry data types we support and their associated mappings. For details, see the Metrics section of our best practices guide. Metric Type Supported Delta sums ✅ Cumulative sums ✅ Gauges ✅ Delta histograms ✅ Summary ✅ Cumulative histograms ❌ Exemplars ❌ Array of primitives (homogeneous) ❌ Logs New Relic offers support for the OTLP ingest of log signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. OpenTelemetry logs are compatible with New Relic logs. OpenTelemetry logs optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter log data at query time. OpenTelemetry log metadata (for example, name, severity_text, and trace_id) also map directly to dimensions on New Relic logs. NewRelic currently supports all OpenTelemetry log message types except for arrays. For more details, see the Logs section of our best practices guide. Feature Supported Description LogRecord body ✅ Supported types: string, boolean, int, double, bytes LogRecord attributes ✅ Supported types: string, boolean, int, double, bytes LogRecord fields ✅ Examples: name, severity_text, trace_id Array messages ❌ Array attributes ❌ Next steps Follow the OpenTelemetry quick start to help you get started. You'll also want to review the best practices guide for getting the most out of the data you export to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 195.41473,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "sections": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " won’t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build <em>integrations</em> into <em>OpenTelemetry</em> or add instrumentation directly to <em>source</em> code, ensuring end users can easily monitor these new technologies. Simplified choice You don’t need"
      },
      "id": "6174afe1e7b9d2748213b3a6"
    },
    {
      "sections": [
        "Troubleshooting OpenTelemetry with New Relic",
        "OpenTelemetry data sent via OTLP is not queryable",
        "Problem",
        "Solution",
        "Important",
        "OpenTelemetry entities or relationships are missing",
        "Tip"
      ],
      "title": "Troubleshooting OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "9478cc98ba9216af5ad8c74883abdf14565a21a4",
      "image": "https://docs.newrelic.com/static/93271ff8121b09ca17395fdf3f27e700/c1b63/otlp-troubleshooting-facet-query.png",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-troubleshooting/",
      "published_at": "2021-12-30T07:49:15Z",
      "updated_at": "2021-12-04T16:46:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Troubleshooting OpenTelemetry with New Relic may just be a matter of making sure you are following best practices, but sometimes you may need to take additional steps to diagnose your issues. Here are some examples of specific problems you might encounter, along with steps and tools to resolve them. OpenTelemetry data sent via OTLP is not queryable Problem You sent OpenTelemetry metrics, logs, or traces using OTLP and are unable to view the data. Before digging deeper, make sure you've checked the following: The OTLP endpoint configured matches one of our documented endpoints, is properly formatted, and includes the official default port, 4317. Sending OTLP data via port 443 is not supported at this time. Please note the specific endpoint for FedRAMP compliance, if applicable. The outbound traffic is not restricted by a firewall. Our Networks document explains domains and network blocks that you may need to explicitly allow. The client is configured to use TLS 1.2 or higher and the request includes the api-key header with a valid New Relic account (ingest) license key. Requests include valid protobuf payloads and use gRPC and HTTP/2 transport, preferably with gzip compression enabled. Sending protobuf or JSON-encoded payloads over HTTP/1.1 is not supported at this time. Client output and logs do not indicate 4xx or 5xx response codes are being returned. Solution There are number of tools you can use to validate the successful delivery of telemetry data to our platform. A good first step is to check the data management hub to facet data ingest and determine how much data is arriving from various sources. You can also use the data explorer or query builder to look for data faceted by instrumentation.provider or newrelic.source attributes: FROM Log, Metric, Span SELECT datapointcount() WHERE instrumentation.provider = 'opentelemetry' FACET instrumentation.provider, newrelic.source Copy This query should tell you whether data is arriving via OTLP. If the data you expect is not present, try removing the WHERE clause or checking for integration errors. Querying NrIntegrationError events can help you determine whether you have configuration or format issues or if you've run into our platform limits. Important The ingest limits for metrics, logs, and traces via OTLP are the same as our other data ingest API limits. Various parts of the New Relic UI rely on the presence of specific attributes to function properly. You can use the NRQL console feature in many places to check the WHERE or FACET clauses of the query for required attributes. You can also edit those clauses and re-run the query to determine whether there is data present with those attributes missing. Examples of required attributes include service.name and service.instance.id. For a more complete list of examples, see resources. OpenTelemetry entities or relationships are missing Problem You sent OpenTelemetry data from a service or infrastructure component and either the entity or its relationships are missing or incorrect. Solution OpenTelemetry entities will be synthesized based on the public rules described for the EXT-SERVICE entity type. The standard rule to match relies on the presence of the service.name dimension which follows the OpenTelemetry semantic conventions. To set the service.name with the OpenTelemetry Java SDK, include it in your resource: var resource = Resource.getDefault() .merge(Resource.builder().put(SERVICE_NAME, serviceName).build()); Copy Depending on the SDK, you may also set the service.name by declaring it in the OTEL_RESOURCE_ATTRIBUTES or OTEL_SERVICE_NAME environment variables. For Logs, you can use a structured log template to inject the service.name. Here are some log examples: Setting the service name Logs in context with Log4j2 Tip For more OpenTelemetry examples with New Relic, visit the newrelic-opentelemetry-examples repository on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.04047,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshooting <em>OpenTelemetry</em> with New Relic",
        "sections": "Troubleshooting <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": "Troubleshooting <em>OpenTelemetry</em> with New Relic may just be a matter of making sure you are following best practices, but sometimes you may need to take additional steps to diagnose your issues. Here are some examples of specific problems you might encounter, along with steps and tools to resolve them"
      },
      "id": "618e863f196a67bd4ce723da"
    },
    {
      "sections": [
        "OpenTelemetry quick start",
        "Step 1. Prerequisites",
        "Step 2. Instrument your service with OpenTelemetry",
        "Step 3. Export your telemetry data to New Relic",
        "Review New Relic settings for exports",
        "Important",
        "Complete the export configuration steps",
        "Export data to an OpenTelemetry Collector (optional)",
        "Step 4. View your data in the New Relic UI",
        "View our OpenTelemetry examples",
        "What's next?"
      ],
      "title": "OpenTelemetry quick start",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "067b2e00bd167f4d78a1398575acd6f3ac76e069",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-quick-start/",
      "published_at": "2021-12-30T03:36:45Z",
      "updated_at": "2021-12-04T16:46:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "OpenTelemetry is a flexible toolkit that you can implement in a variety of ways. We recommend a basic four-step approach for setting up OpenTelemetry with New Relic. Here's an overview of the process, followed by details for each step. Prerequisites Instrument your service with OpenTelemetry Export your telemetry data to New Relic View your data in the New Relic UI Step 1. Prerequisites First things first: If we don’t already know you, sign up for a free New Relic account. Copy your account license key. Step 2. Instrument your service with OpenTelemetry To get started, you instrument your service with OpenTelemetry. OpenTelemetry has language-specific products and SDKs to help you. Many languages offer out-the-box instrumentation for common libraries and frameworks. Each language also provides an API for further instrumenting your service manually. Go to the repository for your language and follow the instructions to instrument your service. When you're done, return here to complete Step 3. Export your telemetry data to New Relic. C++ Erlang Go Java Javascript/Node.js .NET PHP Python Ruby Rust Swift ...See a complete list of languages in GitHub Step 3. Export your telemetry data to New Relic The OpenTelemetry Protocol, or OTLP for short, is a general purpose telemetry data delivery protocol designed for the OpenTelemetry project. This protocol describes how to encode and transmit telemetry data, which makes it a natural choice for data transport. Each language SDK provides an OTLP exporter you can configure to export data over OTLP. In this step, we focus on how to configure an OTLP exporter in your service to export data directly to New Relic. If you prefer to export your data first to an OpenTelemetry collector, we have separate instructions. Here's an example of sending data from your service directly to New Relic. To complete this third step, first familiarize yourself with some required New Relic settings, and then complete the steps in the OTLP exporter documentation for your language. Review New Relic settings for exports Before you go to the external OTLP exporter documentation, consult the table below so you're ready to do the following: Configure the OTLP exporter to add a header (api-key) whose value is the license key for the New Relic account you want to send data to. Based on your region, configure the endpoint where the exporter sends data to New Relic. Region gRPC HTTP/1.1 Endpoint API header name API header value TLS encryption required US ✅ ❌ https://otlp.nr-data.net:4317 api-key License key ✅ EU ✅ ❌ https://otlp.eu01.nr-data.net:4317 api-key License key ✅ Important If you have FedRamp compliance constraints, you will need to use https://gov-otlp.nr-data.net:4317. Please see FedRAMP-compliant endpoints for further information. Important In Node.js, the opentelemetry-collector-grpc library requires additional options to enable TLS. Complete the export configuration steps Click on the link below for your language and complete the configuration steps. When you're done, return here to complete Step 4. View your data in the New Relic UI. C++ Erlang Go Java Javascript/Node.js .NET PHP Python Ruby Rust Swift ...Find additional OTLP language support in GitHub Export data to an OpenTelemetry Collector (optional) The OpenTelemetry Collector is a configurable and extensible software component to receive, process, and export telemetry data. When you set up a collector, it can operate as a gateway or as an agent: Gateway: The collector receives data from a variety of sources and applies standard processing before exporting to some backend. Agent: The collector is deployed on each host in an environment and can collect telemetry data about the host and processes running on it. When you use a collector, you start by following the same routine as above for setting up OTLP in your service. In this case, instead of exporting data directly to New Relic, you export through a collector that you set up. In the collector, you configure the OTLP exporter to export data to New Relic. When your data goes through a collector, the transport looks like this: Here's a Docker example of how to set up and run an OpenTelemetry collector with the collector YAML: Save the following as otel-config.yaml: receivers: otlp: protocols: grpc: http: processors: batch: exporters: otlp: endpoint: ${OTEL_EXPORTER_OTLP_ENDPOINT} headers: api-key: ${NEW_RELIC_LICENSE_KEY} service: pipelines: traces: receivers: [otlp] processors: [batch] exporters: [otlp] metrics: receivers: [otlp] processors: [batch] exporters: [otlp] logs: receivers: [otlp] processors: [batch] exporters: [otlp] Copy Run the OpenTelemetry collector, making sure you replace OTLP_ENDPOINT_HERE with the appropriate endpoint and replace YOUR_KEY_HERE with your account's license key: export OTEL_EXPORTER_OTLP_ENDPOINT=OTLP_ENDPOINT_HERE export NEW_RELIC_LICENSE_KEY=YOUR_KEY_HERE docker run --rm \\ -e OTEL_EXPORTER_OTLP_ENDPOINT \\ -e NEW_RELIC_LICENSE_KEY \\ -p 4317:4317 \\ -v \"${PWD}/otel-config.yaml\":/otel-config.yaml \\ --config otel-config.yaml \\ --name otelcol \\ otel/opentelemetry-collector Copy Step 4. View your data in the New Relic UI Once you’ve instrumented your service and configured it to export its data to New Relic, watch the New Relic One user interface for your traces, metrics, and logs! The UI for OpenTelemetry has some similarities to the APM agent UI, so if you are familiar with that, you can go right to the UI. If you need help understanding your OpenTelemetry UI options or how to make sure your data appears in the UI, see View your OpenTelemetry data in New Relic. View our OpenTelemetry examples View some of our examples for using OpenTelemetry with New Relic. What's next? After you do your initial setup, check out our best-practices guide for tips about various configurations to improve your use of OpenTelemetry and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.03998,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>OpenTelemetry</em> quick start",
        "sections": "<em>OpenTelemetry</em> quick start",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": "<em>OpenTelemetry</em> is a flexible toolkit that you can implement in a variety of ways. We recommend a basic four-step approach for setting up <em>OpenTelemetry</em> with New Relic. Here&#x27;s an overview of the process, followed by details for each step. Prerequisites Instrument your service with <em>OpenTelemetry</em> Export"
      },
      "id": "617dca7464441f8186fbc951"
    }
  ],
  "/docs/more-integrations/open-source-telemetry-integrations/elixir/elixir-open-source-agent": [
    {
      "sections": [
        "Roku open-source agent",
        "Tip",
        "Get started",
        "For more help"
      ],
      "title": "Roku open-source agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Open-source licensed agents",
        "Open-source licensed agents"
      ],
      "external_id": "9113b5f4268014cb3a98e101a4e5df65e03232ed",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/roku/roku-open-source-video-agent/",
      "published_at": "2021-12-30T07:49:14Z",
      "updated_at": "2021-10-30T16:50:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Monitor Roku behavior with New Relic using the Roku open-source agent. The agent contains two parts, to capture two separate categories of Roku behavior: App events like app starts and HTTP requests Video playback within the app Tip This agent is released as open source on GitHub. A change log is also available there for the latest updates. Get started For requirements, installation, and configuration information, see the Open Source Roku Agent README on GitHub. Visit New Relic’s Roku repository on GitHub for questions about installation, usage, or other topics. Report issues or bugs as an issue in the GitHub repository. For more help Recommendations for learning more: Browse New Relic's Explorers Hub for community discussions about the open-source Roku agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 384.29803,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Roku <em>open</em>-<em>source</em> <em>agent</em>",
        "sections": "Roku <em>open</em>-<em>source</em> <em>agent</em>",
        "tags": "<em>Open</em>-<em>source</em> <em>licensed</em> <em>agents</em>",
        "body": "Monitor Roku behavior with New Relic using the Roku <em>open</em>-<em>source</em> <em>agent</em>. The <em>agent</em> contains two parts, to capture two separate categories of Roku behavior: App events like app starts and HTTP requests Video playback within the app Tip This <em>agent</em> is released as <em>open</em> <em>source</em> on GitHub. A change log"
      },
      "id": "617d77eb196a675297f7da00"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Monitor your network devices with New Relic",
        "Query data with NRQL"
      ],
      "published_at": "2022-01-02T01:39:10Z",
      "title": "Collect data",
      "updated_at": "2022-01-02T01:39:10Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source APIs, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with NerdGraph Try NerdGraph and build the queries you need 25 min Monitor your network devices with New Relic Monitor your network devices with New Relic 45 min Query data with NRQL Query default data, custom events, and attributes 10 min",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 33.003967,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Collect data - any <em>source</em>",
        "body": "Through our opensource <em>agents</em> or APIs, New Relic makes it easy to collect data from any <em>source</em>. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "Generate trace log for troubleshooting (Node.js)",
        "Important",
        "Generate log files",
        "Examine log file"
      ],
      "title": "Generate trace log for troubleshooting (Node.js)",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Troubleshooting"
      ],
      "external_id": "3421d4243bcf05070a999d7bc79eab6c6f1372a0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/nodejs-agent/troubleshooting/generate-trace-log-troubleshooting-nodejs/",
      "published_at": "2021-12-31T01:39:27Z",
      "updated_at": "2021-12-31T00:07:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your New Relic Node.js agent log captures errors at the default info level. However, when troubleshooting or debugging, generate a more verbose trace log to help find and investigate problems. Important The trace log setting is a highly verbose logging level. To reduce disk space consumption, return the logging : { section's level to its original setting after testing. Generate log files To generate the detailed trace log file: Edit your newrelic.js file and change the logging section's level to trace, or if using environment variables, set the NEW_RELIC_LOG_LEVEL to trace. logging: { level: 'trace' } Copy Restart Node. Exercise your web application for about five minutes to generate sufficient logging data. After testing, change the level to a less verbose logging level, such as info (default). Open and examine the generated log file. Examine log file By default, the Node.js agent stores the log file in the current working directory as newrelic_agent.log. If the log file or folder are not visible: Check whether you have set the logging path to stdout or stderr. Verify that the current working directory is the same as the directory where you expect the log file to be located.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 29.74707,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Agents</em>",
        "body": ": &#x27;trace&#x27; } Copy Restart Node. Exercise your web application for about five minutes to generate sufficient logging data. After testing, change the level to a less verbose logging level, such as info (default). <em>Open</em> and examine the generated log file. Examine log file By default, the Node.js <em>agent</em>"
      },
      "id": "617ea562e7b9d2fd44c05078"
    }
  ],
  "/docs/more-integrations/open-source-telemetry-integrations/kamon/kamon-reporter": [
    {
      "sections": [
        "Introduction to OpenTelemetry with New Relic",
        "Benefits of OpenTelemetry",
        "Should I use OpenTelemetry instrumentation or New Relic agents?",
        "OpenTelemetry: A work in progress",
        "New Relic's APM agents",
        "How OpenTelemetry works with New Relic",
        "Important",
        "Traces",
        "Metrics",
        "Logs",
        "Next steps"
      ],
      "title": "Introduction to OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "67818451ffb7594e3c27526f4082bd1bc007bc51",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/introduction-opentelemetry-new-relic/",
      "published_at": "2021-12-30T03:36:05Z",
      "updated_at": "2021-12-20T05:36:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Are you already familiar with OpenTelemetry and want to begin the setup? Check out our quick start: Quick start If you don't have one already, create a New Relic account. It's free, forever. If you're just getting acquainted with OpenTelemetry, this is what we'll explore here: Benefits of OpenTelemetry Should I use OpenTelemetry or New Relic agents? How OpenTelemetry works with New Relic Benefits of OpenTelemetry OpenTelemetry provides a secure, vendor-neutral specification for service instrumentation so that you can export data to distinct backends of your choice, such as New Relic. OpenTelemetry offers a single set of APIs and libraries that standardize how you collect and transfer telemetry data for your services. The following components make up the OpenTelemetry project: Specifications for the core pillars of observability to drive consistency across all projects. New Relic supports all of these signals: traces, metrics, and logs (see details below) APIs that contain interfaces and implementations based on the specifications SDKs (reference implementations of the APIs) created specifically for languages like Java, Python, Go, Erlang, and more Collectors that offer a vendor-agnostic implementation for processing and exporting Exporters that enable you to send data to a backend of your choice The components of OpenTelemetry work together to create some distinct advantages for capturing telemetry data: Feature Description Ubiquitous instrumentation A single, open standard of instrumentation provides better coverage and flexibility as engineers from all over the world contribute to the instrumentation. Future proof As the instrumentation gets built into libraries and frameworks, and as more vendors move to support this open standard, you can be confident that you won’t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build integrations into OpenTelemetry or add instrumentation directly to source code, ensuring end users can easily monitor these new technologies. Simplified choice You don’t need to decide which instrumentation option to use (a proprietary option or one of the other open standards). Cross-platform compatibility OpenTelemetry supports a variety of languages and backends. It represents a vendor-neutral path for capturing and transmitting telemetry to backends without altering existing instrumentation. Streamlined observability It is easier for vendors to support and test against a single standard as they don’t need to develop their own agents or collectors. High dimensionality OpenTelemetry uses dimensional metrics, so you can filter and facet on more aspects of the data, such as AWS regions, Kubernetes clusters, or service versions. Dimensional metrics also lead to less time between occurrence and reporting. Should I use OpenTelemetry instrumentation or New Relic agents? As you consider OpenTelemetry, you may also be looking at New Relic APM agents that also capture telemetry data. As you'd expect, there is a lot of overlap between features available from OpenTelemetry agents and SDKs versus those available from New Relic APM agents. This is especially true if you're interested in distributed tracing telemetry data. The choice you make depends on what you need. We recommend that you explore both New Relic and OpenTelemetry instrumentation or discuss this with us in our CNCF Slack channel to decide what works best for you. OpenTelemetry: A work in progress OpenTelemetry is still an emerging standard, so your choices may be affected by what's available. You can check on the current state of the specification at the OpenTelemetry site. The current state of language-specific OpenTelemetry APIs and SDKs varies: some languages are still pre-alpha and may be missing instructions on how to instrument your service. Most languages have some implementation of traces that is sufficient to start exporting data to New Relic. Check out this table in GitHub that provides an overview of the state of OpenTelemetry specification compliance for each language. For languages that New Relic does not currently provide an agent or SDK, OpenTelemetry may offer you a good alternative. Also, in cases where you want explicit control over sampling of your telemetry data, OpenTelemetry provides a lot of flexibility. As OpenTelemetry matures, New Relic will continue to support new OpenTelemetry data models and to provide a curated UI experience for our customers. New Relic's APM agents In general, New Relic's APM agents will collect more telemetry data for your services, and they offer a wide range of configuration options and an extensive set of auto-instrumentation capabilities. New Relic's APM agents offer detailed transaction trace visibility for individual services. They also offer predefined sampling to balance the performance impact of your instrumentation against the need to capture enough data to gain helpful insights. How OpenTelemetry works with New Relic New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemetry community to export your data to New Relic. The following tables show the supported features for each telemetry signal. If you have questions about these or have an unsupported use case, please contact us in our CNCF Slack channel, and watch this page for future updates. Important New Relic's exporters for OpenTelemetry are now deprecated in favor of exporting data to New Relic using OTLP. Traces New Relic offers support for the OTLP ingest of trace signals. The maturity of the upstream specification is stable. OpenTelemetry traces and spans are compatible with New Relic traces and spans. OpenTelemetry spans optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter span data at query time. OpenTelemetry span metadata (for example, name, kind, and trace_id) also map directly to dimensions on NewRelic spans. At this time, New Relic does not support span links or array attributes. For details, see the Traces section of our best practices guide. Feature Supported Span events ✅ Span linking ❌ Array of primitives (homogeneous) ❌ Metrics New Relic offers support for the OTLP ingest of metric signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. Here are the OpenTelemetry data types we support and their associated mappings. For details, see the Metrics section of our best practices guide. Metric Type Supported Delta sums ✅ Cumulative sums ✅ Gauges ✅ Delta histograms ✅ Summary ✅ Cumulative histograms ❌ Exemplars ❌ Array of primitives (homogeneous) ❌ Logs New Relic offers support for the OTLP ingest of log signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. OpenTelemetry logs are compatible with New Relic logs. OpenTelemetry logs optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter log data at query time. OpenTelemetry log metadata (for example, name, severity_text, and trace_id) also map directly to dimensions on New Relic logs. NewRelic currently supports all OpenTelemetry log message types except for arrays. For more details, see the Logs section of our best practices guide. Feature Supported Description LogRecord body ✅ Supported types: string, boolean, int, double, bytes LogRecord attributes ✅ Supported types: string, boolean, int, double, bytes LogRecord fields ✅ Examples: name, severity_text, trace_id Array messages ❌ Array attributes ❌ Next steps Follow the OpenTelemetry quick start to help you get started. You'll also want to review the best practices guide for getting the most out of the data you export to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 195.4147,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "sections": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " won’t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build <em>integrations</em> into <em>OpenTelemetry</em> or add instrumentation directly to <em>source</em> code, ensuring end users can easily monitor these new technologies. Simplified choice You don’t need"
      },
      "id": "6174afe1e7b9d2748213b3a6"
    },
    {
      "sections": [
        "Troubleshooting OpenTelemetry with New Relic",
        "OpenTelemetry data sent via OTLP is not queryable",
        "Problem",
        "Solution",
        "Important",
        "OpenTelemetry entities or relationships are missing",
        "Tip"
      ],
      "title": "Troubleshooting OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "9478cc98ba9216af5ad8c74883abdf14565a21a4",
      "image": "https://docs.newrelic.com/static/93271ff8121b09ca17395fdf3f27e700/c1b63/otlp-troubleshooting-facet-query.png",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-troubleshooting/",
      "published_at": "2021-12-30T07:49:15Z",
      "updated_at": "2021-12-04T16:46:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Troubleshooting OpenTelemetry with New Relic may just be a matter of making sure you are following best practices, but sometimes you may need to take additional steps to diagnose your issues. Here are some examples of specific problems you might encounter, along with steps and tools to resolve them. OpenTelemetry data sent via OTLP is not queryable Problem You sent OpenTelemetry metrics, logs, or traces using OTLP and are unable to view the data. Before digging deeper, make sure you've checked the following: The OTLP endpoint configured matches one of our documented endpoints, is properly formatted, and includes the official default port, 4317. Sending OTLP data via port 443 is not supported at this time. Please note the specific endpoint for FedRAMP compliance, if applicable. The outbound traffic is not restricted by a firewall. Our Networks document explains domains and network blocks that you may need to explicitly allow. The client is configured to use TLS 1.2 or higher and the request includes the api-key header with a valid New Relic account (ingest) license key. Requests include valid protobuf payloads and use gRPC and HTTP/2 transport, preferably with gzip compression enabled. Sending protobuf or JSON-encoded payloads over HTTP/1.1 is not supported at this time. Client output and logs do not indicate 4xx or 5xx response codes are being returned. Solution There are number of tools you can use to validate the successful delivery of telemetry data to our platform. A good first step is to check the data management hub to facet data ingest and determine how much data is arriving from various sources. You can also use the data explorer or query builder to look for data faceted by instrumentation.provider or newrelic.source attributes: FROM Log, Metric, Span SELECT datapointcount() WHERE instrumentation.provider = 'opentelemetry' FACET instrumentation.provider, newrelic.source Copy This query should tell you whether data is arriving via OTLP. If the data you expect is not present, try removing the WHERE clause or checking for integration errors. Querying NrIntegrationError events can help you determine whether you have configuration or format issues or if you've run into our platform limits. Important The ingest limits for metrics, logs, and traces via OTLP are the same as our other data ingest API limits. Various parts of the New Relic UI rely on the presence of specific attributes to function properly. You can use the NRQL console feature in many places to check the WHERE or FACET clauses of the query for required attributes. You can also edit those clauses and re-run the query to determine whether there is data present with those attributes missing. Examples of required attributes include service.name and service.instance.id. For a more complete list of examples, see resources. OpenTelemetry entities or relationships are missing Problem You sent OpenTelemetry data from a service or infrastructure component and either the entity or its relationships are missing or incorrect. Solution OpenTelemetry entities will be synthesized based on the public rules described for the EXT-SERVICE entity type. The standard rule to match relies on the presence of the service.name dimension which follows the OpenTelemetry semantic conventions. To set the service.name with the OpenTelemetry Java SDK, include it in your resource: var resource = Resource.getDefault() .merge(Resource.builder().put(SERVICE_NAME, serviceName).build()); Copy Depending on the SDK, you may also set the service.name by declaring it in the OTEL_RESOURCE_ATTRIBUTES or OTEL_SERVICE_NAME environment variables. For Logs, you can use a structured log template to inject the service.name. Here are some log examples: Setting the service name Logs in context with Log4j2 Tip For more OpenTelemetry examples with New Relic, visit the newrelic-opentelemetry-examples repository on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.04047,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshooting <em>OpenTelemetry</em> with New Relic",
        "sections": "Troubleshooting <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": "Troubleshooting <em>OpenTelemetry</em> with New Relic may just be a matter of making sure you are following best practices, but sometimes you may need to take additional steps to diagnose your issues. Here are some examples of specific problems you might encounter, along with steps and tools to resolve them"
      },
      "id": "618e863f196a67bd4ce723da"
    },
    {
      "sections": [
        "OpenTelemetry quick start",
        "Step 1. Prerequisites",
        "Step 2. Instrument your service with OpenTelemetry",
        "Step 3. Export your telemetry data to New Relic",
        "Review New Relic settings for exports",
        "Important",
        "Complete the export configuration steps",
        "Export data to an OpenTelemetry Collector (optional)",
        "Step 4. View your data in the New Relic UI",
        "View our OpenTelemetry examples",
        "What's next?"
      ],
      "title": "OpenTelemetry quick start",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "067b2e00bd167f4d78a1398575acd6f3ac76e069",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-quick-start/",
      "published_at": "2021-12-30T03:36:45Z",
      "updated_at": "2021-12-04T16:46:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "OpenTelemetry is a flexible toolkit that you can implement in a variety of ways. We recommend a basic four-step approach for setting up OpenTelemetry with New Relic. Here's an overview of the process, followed by details for each step. Prerequisites Instrument your service with OpenTelemetry Export your telemetry data to New Relic View your data in the New Relic UI Step 1. Prerequisites First things first: If we don’t already know you, sign up for a free New Relic account. Copy your account license key. Step 2. Instrument your service with OpenTelemetry To get started, you instrument your service with OpenTelemetry. OpenTelemetry has language-specific products and SDKs to help you. Many languages offer out-the-box instrumentation for common libraries and frameworks. Each language also provides an API for further instrumenting your service manually. Go to the repository for your language and follow the instructions to instrument your service. When you're done, return here to complete Step 3. Export your telemetry data to New Relic. C++ Erlang Go Java Javascript/Node.js .NET PHP Python Ruby Rust Swift ...See a complete list of languages in GitHub Step 3. Export your telemetry data to New Relic The OpenTelemetry Protocol, or OTLP for short, is a general purpose telemetry data delivery protocol designed for the OpenTelemetry project. This protocol describes how to encode and transmit telemetry data, which makes it a natural choice for data transport. Each language SDK provides an OTLP exporter you can configure to export data over OTLP. In this step, we focus on how to configure an OTLP exporter in your service to export data directly to New Relic. If you prefer to export your data first to an OpenTelemetry collector, we have separate instructions. Here's an example of sending data from your service directly to New Relic. To complete this third step, first familiarize yourself with some required New Relic settings, and then complete the steps in the OTLP exporter documentation for your language. Review New Relic settings for exports Before you go to the external OTLP exporter documentation, consult the table below so you're ready to do the following: Configure the OTLP exporter to add a header (api-key) whose value is the license key for the New Relic account you want to send data to. Based on your region, configure the endpoint where the exporter sends data to New Relic. Region gRPC HTTP/1.1 Endpoint API header name API header value TLS encryption required US ✅ ❌ https://otlp.nr-data.net:4317 api-key License key ✅ EU ✅ ❌ https://otlp.eu01.nr-data.net:4317 api-key License key ✅ Important If you have FedRamp compliance constraints, you will need to use https://gov-otlp.nr-data.net:4317. Please see FedRAMP-compliant endpoints for further information. Important In Node.js, the opentelemetry-collector-grpc library requires additional options to enable TLS. Complete the export configuration steps Click on the link below for your language and complete the configuration steps. When you're done, return here to complete Step 4. View your data in the New Relic UI. C++ Erlang Go Java Javascript/Node.js .NET PHP Python Ruby Rust Swift ...Find additional OTLP language support in GitHub Export data to an OpenTelemetry Collector (optional) The OpenTelemetry Collector is a configurable and extensible software component to receive, process, and export telemetry data. When you set up a collector, it can operate as a gateway or as an agent: Gateway: The collector receives data from a variety of sources and applies standard processing before exporting to some backend. Agent: The collector is deployed on each host in an environment and can collect telemetry data about the host and processes running on it. When you use a collector, you start by following the same routine as above for setting up OTLP in your service. In this case, instead of exporting data directly to New Relic, you export through a collector that you set up. In the collector, you configure the OTLP exporter to export data to New Relic. When your data goes through a collector, the transport looks like this: Here's a Docker example of how to set up and run an OpenTelemetry collector with the collector YAML: Save the following as otel-config.yaml: receivers: otlp: protocols: grpc: http: processors: batch: exporters: otlp: endpoint: ${OTEL_EXPORTER_OTLP_ENDPOINT} headers: api-key: ${NEW_RELIC_LICENSE_KEY} service: pipelines: traces: receivers: [otlp] processors: [batch] exporters: [otlp] metrics: receivers: [otlp] processors: [batch] exporters: [otlp] logs: receivers: [otlp] processors: [batch] exporters: [otlp] Copy Run the OpenTelemetry collector, making sure you replace OTLP_ENDPOINT_HERE with the appropriate endpoint and replace YOUR_KEY_HERE with your account's license key: export OTEL_EXPORTER_OTLP_ENDPOINT=OTLP_ENDPOINT_HERE export NEW_RELIC_LICENSE_KEY=YOUR_KEY_HERE docker run --rm \\ -e OTEL_EXPORTER_OTLP_ENDPOINT \\ -e NEW_RELIC_LICENSE_KEY \\ -p 4317:4317 \\ -v \"${PWD}/otel-config.yaml\":/otel-config.yaml \\ --config otel-config.yaml \\ --name otelcol \\ otel/opentelemetry-collector Copy Step 4. View your data in the New Relic UI Once you’ve instrumented your service and configured it to export its data to New Relic, watch the New Relic One user interface for your traces, metrics, and logs! The UI for OpenTelemetry has some similarities to the APM agent UI, so if you are familiar with that, you can go right to the UI. If you need help understanding your OpenTelemetry UI options or how to make sure your data appears in the UI, see View your OpenTelemetry data in New Relic. View our OpenTelemetry examples View some of our examples for using OpenTelemetry with New Relic. What's next? After you do your initial setup, check out our best-practices guide for tips about various configurations to improve your use of OpenTelemetry and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.03998,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>OpenTelemetry</em> quick start",
        "sections": "<em>OpenTelemetry</em> quick start",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": "<em>OpenTelemetry</em> is a flexible toolkit that you can implement in a variety of ways. We recommend a basic four-step approach for setting up <em>OpenTelemetry</em> with New Relic. Here&#x27;s an overview of the process, followed by details for each step. Prerequisites Instrument your service with <em>OpenTelemetry</em> Export"
      },
      "id": "617dca7464441f8186fbc951"
    }
  ],
  "/docs/more-integrations/open-source-telemetry-integrations/micrometer/micrometer-metrics-registry": [
    {
      "sections": [
        "Introduction to OpenTelemetry with New Relic",
        "Benefits of OpenTelemetry",
        "Should I use OpenTelemetry instrumentation or New Relic agents?",
        "OpenTelemetry: A work in progress",
        "New Relic's APM agents",
        "How OpenTelemetry works with New Relic",
        "Important",
        "Traces",
        "Metrics",
        "Logs",
        "Next steps"
      ],
      "title": "Introduction to OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "67818451ffb7594e3c27526f4082bd1bc007bc51",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/introduction-opentelemetry-new-relic/",
      "published_at": "2021-12-30T03:36:05Z",
      "updated_at": "2021-12-20T05:36:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Are you already familiar with OpenTelemetry and want to begin the setup? Check out our quick start: Quick start If you don't have one already, create a New Relic account. It's free, forever. If you're just getting acquainted with OpenTelemetry, this is what we'll explore here: Benefits of OpenTelemetry Should I use OpenTelemetry or New Relic agents? How OpenTelemetry works with New Relic Benefits of OpenTelemetry OpenTelemetry provides a secure, vendor-neutral specification for service instrumentation so that you can export data to distinct backends of your choice, such as New Relic. OpenTelemetry offers a single set of APIs and libraries that standardize how you collect and transfer telemetry data for your services. The following components make up the OpenTelemetry project: Specifications for the core pillars of observability to drive consistency across all projects. New Relic supports all of these signals: traces, metrics, and logs (see details below) APIs that contain interfaces and implementations based on the specifications SDKs (reference implementations of the APIs) created specifically for languages like Java, Python, Go, Erlang, and more Collectors that offer a vendor-agnostic implementation for processing and exporting Exporters that enable you to send data to a backend of your choice The components of OpenTelemetry work together to create some distinct advantages for capturing telemetry data: Feature Description Ubiquitous instrumentation A single, open standard of instrumentation provides better coverage and flexibility as engineers from all over the world contribute to the instrumentation. Future proof As the instrumentation gets built into libraries and frameworks, and as more vendors move to support this open standard, you can be confident that you won’t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build integrations into OpenTelemetry or add instrumentation directly to source code, ensuring end users can easily monitor these new technologies. Simplified choice You don’t need to decide which instrumentation option to use (a proprietary option or one of the other open standards). Cross-platform compatibility OpenTelemetry supports a variety of languages and backends. It represents a vendor-neutral path for capturing and transmitting telemetry to backends without altering existing instrumentation. Streamlined observability It is easier for vendors to support and test against a single standard as they don’t need to develop their own agents or collectors. High dimensionality OpenTelemetry uses dimensional metrics, so you can filter and facet on more aspects of the data, such as AWS regions, Kubernetes clusters, or service versions. Dimensional metrics also lead to less time between occurrence and reporting. Should I use OpenTelemetry instrumentation or New Relic agents? As you consider OpenTelemetry, you may also be looking at New Relic APM agents that also capture telemetry data. As you'd expect, there is a lot of overlap between features available from OpenTelemetry agents and SDKs versus those available from New Relic APM agents. This is especially true if you're interested in distributed tracing telemetry data. The choice you make depends on what you need. We recommend that you explore both New Relic and OpenTelemetry instrumentation or discuss this with us in our CNCF Slack channel to decide what works best for you. OpenTelemetry: A work in progress OpenTelemetry is still an emerging standard, so your choices may be affected by what's available. You can check on the current state of the specification at the OpenTelemetry site. The current state of language-specific OpenTelemetry APIs and SDKs varies: some languages are still pre-alpha and may be missing instructions on how to instrument your service. Most languages have some implementation of traces that is sufficient to start exporting data to New Relic. Check out this table in GitHub that provides an overview of the state of OpenTelemetry specification compliance for each language. For languages that New Relic does not currently provide an agent or SDK, OpenTelemetry may offer you a good alternative. Also, in cases where you want explicit control over sampling of your telemetry data, OpenTelemetry provides a lot of flexibility. As OpenTelemetry matures, New Relic will continue to support new OpenTelemetry data models and to provide a curated UI experience for our customers. New Relic's APM agents In general, New Relic's APM agents will collect more telemetry data for your services, and they offer a wide range of configuration options and an extensive set of auto-instrumentation capabilities. New Relic's APM agents offer detailed transaction trace visibility for individual services. They also offer predefined sampling to balance the performance impact of your instrumentation against the need to capture enough data to gain helpful insights. How OpenTelemetry works with New Relic New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemetry community to export your data to New Relic. The following tables show the supported features for each telemetry signal. If you have questions about these or have an unsupported use case, please contact us in our CNCF Slack channel, and watch this page for future updates. Important New Relic's exporters for OpenTelemetry are now deprecated in favor of exporting data to New Relic using OTLP. Traces New Relic offers support for the OTLP ingest of trace signals. The maturity of the upstream specification is stable. OpenTelemetry traces and spans are compatible with New Relic traces and spans. OpenTelemetry spans optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter span data at query time. OpenTelemetry span metadata (for example, name, kind, and trace_id) also map directly to dimensions on NewRelic spans. At this time, New Relic does not support span links or array attributes. For details, see the Traces section of our best practices guide. Feature Supported Span events ✅ Span linking ❌ Array of primitives (homogeneous) ❌ Metrics New Relic offers support for the OTLP ingest of metric signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. Here are the OpenTelemetry data types we support and their associated mappings. For details, see the Metrics section of our best practices guide. Metric Type Supported Delta sums ✅ Cumulative sums ✅ Gauges ✅ Delta histograms ✅ Summary ✅ Cumulative histograms ❌ Exemplars ❌ Array of primitives (homogeneous) ❌ Logs New Relic offers support for the OTLP ingest of log signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. OpenTelemetry logs are compatible with New Relic logs. OpenTelemetry logs optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter log data at query time. OpenTelemetry log metadata (for example, name, severity_text, and trace_id) also map directly to dimensions on New Relic logs. NewRelic currently supports all OpenTelemetry log message types except for arrays. For more details, see the Logs section of our best practices guide. Feature Supported Description LogRecord body ✅ Supported types: string, boolean, int, double, bytes LogRecord attributes ✅ Supported types: string, boolean, int, double, bytes LogRecord fields ✅ Examples: name, severity_text, trace_id Array messages ❌ Array attributes ❌ Next steps Follow the OpenTelemetry quick start to help you get started. You'll also want to review the best practices guide for getting the most out of the data you export to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 196.77255,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "sections": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " won’t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build <em>integrations</em> into <em>OpenTelemetry</em> or add instrumentation directly to <em>source</em> code, ensuring end users can easily monitor these new technologies. Simplified choice You don’t need"
      },
      "id": "6174afe1e7b9d2748213b3a6"
    },
    {
      "sections": [
        "Troubleshooting OpenTelemetry with New Relic",
        "OpenTelemetry data sent via OTLP is not queryable",
        "Problem",
        "Solution",
        "Important",
        "OpenTelemetry entities or relationships are missing",
        "Tip"
      ],
      "title": "Troubleshooting OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "9478cc98ba9216af5ad8c74883abdf14565a21a4",
      "image": "https://docs.newrelic.com/static/93271ff8121b09ca17395fdf3f27e700/c1b63/otlp-troubleshooting-facet-query.png",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-troubleshooting/",
      "published_at": "2021-12-30T07:49:15Z",
      "updated_at": "2021-12-04T16:46:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Troubleshooting OpenTelemetry with New Relic may just be a matter of making sure you are following best practices, but sometimes you may need to take additional steps to diagnose your issues. Here are some examples of specific problems you might encounter, along with steps and tools to resolve them. OpenTelemetry data sent via OTLP is not queryable Problem You sent OpenTelemetry metrics, logs, or traces using OTLP and are unable to view the data. Before digging deeper, make sure you've checked the following: The OTLP endpoint configured matches one of our documented endpoints, is properly formatted, and includes the official default port, 4317. Sending OTLP data via port 443 is not supported at this time. Please note the specific endpoint for FedRAMP compliance, if applicable. The outbound traffic is not restricted by a firewall. Our Networks document explains domains and network blocks that you may need to explicitly allow. The client is configured to use TLS 1.2 or higher and the request includes the api-key header with a valid New Relic account (ingest) license key. Requests include valid protobuf payloads and use gRPC and HTTP/2 transport, preferably with gzip compression enabled. Sending protobuf or JSON-encoded payloads over HTTP/1.1 is not supported at this time. Client output and logs do not indicate 4xx or 5xx response codes are being returned. Solution There are number of tools you can use to validate the successful delivery of telemetry data to our platform. A good first step is to check the data management hub to facet data ingest and determine how much data is arriving from various sources. You can also use the data explorer or query builder to look for data faceted by instrumentation.provider or newrelic.source attributes: FROM Log, Metric, Span SELECT datapointcount() WHERE instrumentation.provider = 'opentelemetry' FACET instrumentation.provider, newrelic.source Copy This query should tell you whether data is arriving via OTLP. If the data you expect is not present, try removing the WHERE clause or checking for integration errors. Querying NrIntegrationError events can help you determine whether you have configuration or format issues or if you've run into our platform limits. Important The ingest limits for metrics, logs, and traces via OTLP are the same as our other data ingest API limits. Various parts of the New Relic UI rely on the presence of specific attributes to function properly. You can use the NRQL console feature in many places to check the WHERE or FACET clauses of the query for required attributes. You can also edit those clauses and re-run the query to determine whether there is data present with those attributes missing. Examples of required attributes include service.name and service.instance.id. For a more complete list of examples, see resources. OpenTelemetry entities or relationships are missing Problem You sent OpenTelemetry data from a service or infrastructure component and either the entity or its relationships are missing or incorrect. Solution OpenTelemetry entities will be synthesized based on the public rules described for the EXT-SERVICE entity type. The standard rule to match relies on the presence of the service.name dimension which follows the OpenTelemetry semantic conventions. To set the service.name with the OpenTelemetry Java SDK, include it in your resource: var resource = Resource.getDefault() .merge(Resource.builder().put(SERVICE_NAME, serviceName).build()); Copy Depending on the SDK, you may also set the service.name by declaring it in the OTEL_RESOURCE_ATTRIBUTES or OTEL_SERVICE_NAME environment variables. For Logs, you can use a structured log template to inject the service.name. Here are some log examples: Setting the service name Logs in context with Log4j2 Tip For more OpenTelemetry examples with New Relic, visit the newrelic-opentelemetry-examples repository on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.20117,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshooting <em>OpenTelemetry</em> with New Relic",
        "sections": "Troubleshooting <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": "Troubleshooting <em>OpenTelemetry</em> with New Relic may just be a matter of making sure you are following best practices, but sometimes you may need to take additional steps to diagnose your issues. Here are some examples of specific problems you might encounter, along with steps and tools to resolve them"
      },
      "id": "618e863f196a67bd4ce723da"
    },
    {
      "sections": [
        "OpenTelemetry quick start",
        "Step 1. Prerequisites",
        "Step 2. Instrument your service with OpenTelemetry",
        "Step 3. Export your telemetry data to New Relic",
        "Review New Relic settings for exports",
        "Important",
        "Complete the export configuration steps",
        "Export data to an OpenTelemetry Collector (optional)",
        "Step 4. View your data in the New Relic UI",
        "View our OpenTelemetry examples",
        "What's next?"
      ],
      "title": "OpenTelemetry quick start",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "067b2e00bd167f4d78a1398575acd6f3ac76e069",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-quick-start/",
      "published_at": "2021-12-30T03:36:45Z",
      "updated_at": "2021-12-04T16:46:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "OpenTelemetry is a flexible toolkit that you can implement in a variety of ways. We recommend a basic four-step approach for setting up OpenTelemetry with New Relic. Here's an overview of the process, followed by details for each step. Prerequisites Instrument your service with OpenTelemetry Export your telemetry data to New Relic View your data in the New Relic UI Step 1. Prerequisites First things first: If we don’t already know you, sign up for a free New Relic account. Copy your account license key. Step 2. Instrument your service with OpenTelemetry To get started, you instrument your service with OpenTelemetry. OpenTelemetry has language-specific products and SDKs to help you. Many languages offer out-the-box instrumentation for common libraries and frameworks. Each language also provides an API for further instrumenting your service manually. Go to the repository for your language and follow the instructions to instrument your service. When you're done, return here to complete Step 3. Export your telemetry data to New Relic. C++ Erlang Go Java Javascript/Node.js .NET PHP Python Ruby Rust Swift ...See a complete list of languages in GitHub Step 3. Export your telemetry data to New Relic The OpenTelemetry Protocol, or OTLP for short, is a general purpose telemetry data delivery protocol designed for the OpenTelemetry project. This protocol describes how to encode and transmit telemetry data, which makes it a natural choice for data transport. Each language SDK provides an OTLP exporter you can configure to export data over OTLP. In this step, we focus on how to configure an OTLP exporter in your service to export data directly to New Relic. If you prefer to export your data first to an OpenTelemetry collector, we have separate instructions. Here's an example of sending data from your service directly to New Relic. To complete this third step, first familiarize yourself with some required New Relic settings, and then complete the steps in the OTLP exporter documentation for your language. Review New Relic settings for exports Before you go to the external OTLP exporter documentation, consult the table below so you're ready to do the following: Configure the OTLP exporter to add a header (api-key) whose value is the license key for the New Relic account you want to send data to. Based on your region, configure the endpoint where the exporter sends data to New Relic. Region gRPC HTTP/1.1 Endpoint API header name API header value TLS encryption required US ✅ ❌ https://otlp.nr-data.net:4317 api-key License key ✅ EU ✅ ❌ https://otlp.eu01.nr-data.net:4317 api-key License key ✅ Important If you have FedRamp compliance constraints, you will need to use https://gov-otlp.nr-data.net:4317. Please see FedRAMP-compliant endpoints for further information. Important In Node.js, the opentelemetry-collector-grpc library requires additional options to enable TLS. Complete the export configuration steps Click on the link below for your language and complete the configuration steps. When you're done, return here to complete Step 4. View your data in the New Relic UI. C++ Erlang Go Java Javascript/Node.js .NET PHP Python Ruby Rust Swift ...Find additional OTLP language support in GitHub Export data to an OpenTelemetry Collector (optional) The OpenTelemetry Collector is a configurable and extensible software component to receive, process, and export telemetry data. When you set up a collector, it can operate as a gateway or as an agent: Gateway: The collector receives data from a variety of sources and applies standard processing before exporting to some backend. Agent: The collector is deployed on each host in an environment and can collect telemetry data about the host and processes running on it. When you use a collector, you start by following the same routine as above for setting up OTLP in your service. In this case, instead of exporting data directly to New Relic, you export through a collector that you set up. In the collector, you configure the OTLP exporter to export data to New Relic. When your data goes through a collector, the transport looks like this: Here's a Docker example of how to set up and run an OpenTelemetry collector with the collector YAML: Save the following as otel-config.yaml: receivers: otlp: protocols: grpc: http: processors: batch: exporters: otlp: endpoint: ${OTEL_EXPORTER_OTLP_ENDPOINT} headers: api-key: ${NEW_RELIC_LICENSE_KEY} service: pipelines: traces: receivers: [otlp] processors: [batch] exporters: [otlp] metrics: receivers: [otlp] processors: [batch] exporters: [otlp] logs: receivers: [otlp] processors: [batch] exporters: [otlp] Copy Run the OpenTelemetry collector, making sure you replace OTLP_ENDPOINT_HERE with the appropriate endpoint and replace YOUR_KEY_HERE with your account's license key: export OTEL_EXPORTER_OTLP_ENDPOINT=OTLP_ENDPOINT_HERE export NEW_RELIC_LICENSE_KEY=YOUR_KEY_HERE docker run --rm \\ -e OTEL_EXPORTER_OTLP_ENDPOINT \\ -e NEW_RELIC_LICENSE_KEY \\ -p 4317:4317 \\ -v \"${PWD}/otel-config.yaml\":/otel-config.yaml \\ --config otel-config.yaml \\ --name otelcol \\ otel/opentelemetry-collector Copy Step 4. View your data in the New Relic UI Once you’ve instrumented your service and configured it to export its data to New Relic, watch the New Relic One user interface for your traces, metrics, and logs! The UI for OpenTelemetry has some similarities to the APM agent UI, so if you are familiar with that, you can go right to the UI. If you need help understanding your OpenTelemetry UI options or how to make sure your data appears in the UI, see View your OpenTelemetry data in New Relic. View our OpenTelemetry examples View some of our examples for using OpenTelemetry with New Relic. What's next? After you do your initial setup, check out our best-practices guide for tips about various configurations to improve your use of OpenTelemetry and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.20068,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>OpenTelemetry</em> quick start",
        "sections": "<em>OpenTelemetry</em> quick start",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": "<em>OpenTelemetry</em> is a flexible toolkit that you can implement in a variety of ways. We recommend a basic four-step approach for setting up <em>OpenTelemetry</em> with New Relic. Here&#x27;s an overview of the process, followed by details for each step. Prerequisites Instrument your service with <em>OpenTelemetry</em> Export"
      },
      "id": "617dca7464441f8186fbc951"
    }
  ],
  "/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/introduction-opentelemetry-new-relic": [
    {
      "sections": [
        "OpenTelemetry quick start",
        "Step 1. Prerequisites",
        "Step 2. Instrument your service with OpenTelemetry",
        "Step 3. Export your telemetry data to New Relic",
        "Review New Relic settings for exports",
        "Important",
        "Complete the export configuration steps",
        "Export data to an OpenTelemetry Collector (optional)",
        "Step 4. View your data in the New Relic UI",
        "View our OpenTelemetry examples",
        "What's next?"
      ],
      "title": "OpenTelemetry quick start",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "067b2e00bd167f4d78a1398575acd6f3ac76e069",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-quick-start/",
      "published_at": "2021-12-30T03:36:45Z",
      "updated_at": "2021-12-04T16:46:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "OpenTelemetry is a flexible toolkit that you can implement in a variety of ways. We recommend a basic four-step approach for setting up OpenTelemetry with New Relic. Here's an overview of the process, followed by details for each step. Prerequisites Instrument your service with OpenTelemetry Export your telemetry data to New Relic View your data in the New Relic UI Step 1. Prerequisites First things first: If we don’t already know you, sign up for a free New Relic account. Copy your account license key. Step 2. Instrument your service with OpenTelemetry To get started, you instrument your service with OpenTelemetry. OpenTelemetry has language-specific products and SDKs to help you. Many languages offer out-the-box instrumentation for common libraries and frameworks. Each language also provides an API for further instrumenting your service manually. Go to the repository for your language and follow the instructions to instrument your service. When you're done, return here to complete Step 3. Export your telemetry data to New Relic. C++ Erlang Go Java Javascript/Node.js .NET PHP Python Ruby Rust Swift ...See a complete list of languages in GitHub Step 3. Export your telemetry data to New Relic The OpenTelemetry Protocol, or OTLP for short, is a general purpose telemetry data delivery protocol designed for the OpenTelemetry project. This protocol describes how to encode and transmit telemetry data, which makes it a natural choice for data transport. Each language SDK provides an OTLP exporter you can configure to export data over OTLP. In this step, we focus on how to configure an OTLP exporter in your service to export data directly to New Relic. If you prefer to export your data first to an OpenTelemetry collector, we have separate instructions. Here's an example of sending data from your service directly to New Relic. To complete this third step, first familiarize yourself with some required New Relic settings, and then complete the steps in the OTLP exporter documentation for your language. Review New Relic settings for exports Before you go to the external OTLP exporter documentation, consult the table below so you're ready to do the following: Configure the OTLP exporter to add a header (api-key) whose value is the license key for the New Relic account you want to send data to. Based on your region, configure the endpoint where the exporter sends data to New Relic. Region gRPC HTTP/1.1 Endpoint API header name API header value TLS encryption required US ✅ ❌ https://otlp.nr-data.net:4317 api-key License key ✅ EU ✅ ❌ https://otlp.eu01.nr-data.net:4317 api-key License key ✅ Important If you have FedRamp compliance constraints, you will need to use https://gov-otlp.nr-data.net:4317. Please see FedRAMP-compliant endpoints for further information. Important In Node.js, the opentelemetry-collector-grpc library requires additional options to enable TLS. Complete the export configuration steps Click on the link below for your language and complete the configuration steps. When you're done, return here to complete Step 4. View your data in the New Relic UI. C++ Erlang Go Java Javascript/Node.js .NET PHP Python Ruby Rust Swift ...Find additional OTLP language support in GitHub Export data to an OpenTelemetry Collector (optional) The OpenTelemetry Collector is a configurable and extensible software component to receive, process, and export telemetry data. When you set up a collector, it can operate as a gateway or as an agent: Gateway: The collector receives data from a variety of sources and applies standard processing before exporting to some backend. Agent: The collector is deployed on each host in an environment and can collect telemetry data about the host and processes running on it. When you use a collector, you start by following the same routine as above for setting up OTLP in your service. In this case, instead of exporting data directly to New Relic, you export through a collector that you set up. In the collector, you configure the OTLP exporter to export data to New Relic. When your data goes through a collector, the transport looks like this: Here's a Docker example of how to set up and run an OpenTelemetry collector with the collector YAML: Save the following as otel-config.yaml: receivers: otlp: protocols: grpc: http: processors: batch: exporters: otlp: endpoint: ${OTEL_EXPORTER_OTLP_ENDPOINT} headers: api-key: ${NEW_RELIC_LICENSE_KEY} service: pipelines: traces: receivers: [otlp] processors: [batch] exporters: [otlp] metrics: receivers: [otlp] processors: [batch] exporters: [otlp] logs: receivers: [otlp] processors: [batch] exporters: [otlp] Copy Run the OpenTelemetry collector, making sure you replace OTLP_ENDPOINT_HERE with the appropriate endpoint and replace YOUR_KEY_HERE with your account's license key: export OTEL_EXPORTER_OTLP_ENDPOINT=OTLP_ENDPOINT_HERE export NEW_RELIC_LICENSE_KEY=YOUR_KEY_HERE docker run --rm \\ -e OTEL_EXPORTER_OTLP_ENDPOINT \\ -e NEW_RELIC_LICENSE_KEY \\ -p 4317:4317 \\ -v \"${PWD}/otel-config.yaml\":/otel-config.yaml \\ --config otel-config.yaml \\ --name otelcol \\ otel/opentelemetry-collector Copy Step 4. View your data in the New Relic UI Once you’ve instrumented your service and configured it to export its data to New Relic, watch the New Relic One user interface for your traces, metrics, and logs! The UI for OpenTelemetry has some similarities to the APM agent UI, so if you are familiar with that, you can go right to the UI. If you need help understanding your OpenTelemetry UI options or how to make sure your data appears in the UI, see View your OpenTelemetry data in New Relic. View our OpenTelemetry examples View some of our examples for using OpenTelemetry with New Relic. What's next? After you do your initial setup, check out our best-practices guide for tips about various configurations to improve your use of OpenTelemetry and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 243.45438,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>OpenTelemetry</em> quick start",
        "sections": "<em>OpenTelemetry</em> quick start",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": "<em>OpenTelemetry</em> is a flexible toolkit that you can implement in a variety of ways. We recommend a basic four-step approach for setting up <em>OpenTelemetry</em> with New Relic. Here&#x27;s an overview of the process, followed by details for each step. Prerequisites Instrument your service with <em>OpenTelemetry</em> Export"
      },
      "id": "617dca7464441f8186fbc951"
    },
    {
      "sections": [
        "Troubleshooting OpenTelemetry with New Relic",
        "OpenTelemetry data sent via OTLP is not queryable",
        "Problem",
        "Solution",
        "Important",
        "OpenTelemetry entities or relationships are missing",
        "Tip"
      ],
      "title": "Troubleshooting OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "9478cc98ba9216af5ad8c74883abdf14565a21a4",
      "image": "https://docs.newrelic.com/static/93271ff8121b09ca17395fdf3f27e700/c1b63/otlp-troubleshooting-facet-query.png",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-troubleshooting/",
      "published_at": "2021-12-30T07:49:15Z",
      "updated_at": "2021-12-04T16:46:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Troubleshooting OpenTelemetry with New Relic may just be a matter of making sure you are following best practices, but sometimes you may need to take additional steps to diagnose your issues. Here are some examples of specific problems you might encounter, along with steps and tools to resolve them. OpenTelemetry data sent via OTLP is not queryable Problem You sent OpenTelemetry metrics, logs, or traces using OTLP and are unable to view the data. Before digging deeper, make sure you've checked the following: The OTLP endpoint configured matches one of our documented endpoints, is properly formatted, and includes the official default port, 4317. Sending OTLP data via port 443 is not supported at this time. Please note the specific endpoint for FedRAMP compliance, if applicable. The outbound traffic is not restricted by a firewall. Our Networks document explains domains and network blocks that you may need to explicitly allow. The client is configured to use TLS 1.2 or higher and the request includes the api-key header with a valid New Relic account (ingest) license key. Requests include valid protobuf payloads and use gRPC and HTTP/2 transport, preferably with gzip compression enabled. Sending protobuf or JSON-encoded payloads over HTTP/1.1 is not supported at this time. Client output and logs do not indicate 4xx or 5xx response codes are being returned. Solution There are number of tools you can use to validate the successful delivery of telemetry data to our platform. A good first step is to check the data management hub to facet data ingest and determine how much data is arriving from various sources. You can also use the data explorer or query builder to look for data faceted by instrumentation.provider or newrelic.source attributes: FROM Log, Metric, Span SELECT datapointcount() WHERE instrumentation.provider = 'opentelemetry' FACET instrumentation.provider, newrelic.source Copy This query should tell you whether data is arriving via OTLP. If the data you expect is not present, try removing the WHERE clause or checking for integration errors. Querying NrIntegrationError events can help you determine whether you have configuration or format issues or if you've run into our platform limits. Important The ingest limits for metrics, logs, and traces via OTLP are the same as our other data ingest API limits. Various parts of the New Relic UI rely on the presence of specific attributes to function properly. You can use the NRQL console feature in many places to check the WHERE or FACET clauses of the query for required attributes. You can also edit those clauses and re-run the query to determine whether there is data present with those attributes missing. Examples of required attributes include service.name and service.instance.id. For a more complete list of examples, see resources. OpenTelemetry entities or relationships are missing Problem You sent OpenTelemetry data from a service or infrastructure component and either the entity or its relationships are missing or incorrect. Solution OpenTelemetry entities will be synthesized based on the public rules described for the EXT-SERVICE entity type. The standard rule to match relies on the presence of the service.name dimension which follows the OpenTelemetry semantic conventions. To set the service.name with the OpenTelemetry Java SDK, include it in your resource: var resource = Resource.getDefault() .merge(Resource.builder().put(SERVICE_NAME, serviceName).build()); Copy Depending on the SDK, you may also set the service.name by declaring it in the OTEL_RESOURCE_ATTRIBUTES or OTEL_SERVICE_NAME environment variables. For Logs, you can use a structured log template to inject the service.name. Here are some log examples: Setting the service name Logs in context with Log4j2 Tip For more OpenTelemetry examples with New Relic, visit the newrelic-opentelemetry-examples repository on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 242.83435,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshooting <em>OpenTelemetry</em> with New Relic",
        "sections": "Troubleshooting <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": "Troubleshooting <em>OpenTelemetry</em> with New Relic may just be a matter of making sure you are following best practices, but sometimes you may need to take additional steps to diagnose your issues. Here are some examples of specific problems you might encounter, along with steps and tools to resolve them"
      },
      "id": "618e863f196a67bd4ce723da"
    },
    {
      "sections": [
        "Best practices for OpenTelemetry with New Relic",
        "Tip",
        "Resources",
        "Batching",
        "Caution",
        "Compression",
        "Traces",
        "Required fields",
        "Sampling",
        "OpenTelemetry built-in samplers",
        "OpenTelemetry tail-based samplers",
        "New Relic tail-based sampling with Infinite Tracing",
        "Important",
        "Metrics",
        "Sum metrics",
        "Delta sums",
        "Cumulative sums",
        "Sum configuration examples",
        "Gauge metrics",
        "Histogram metrics",
        "Summary metrics",
        "Start time",
        "Array values for attributes",
        "Exemplars",
        "How to query metrics",
        "Query cumulative sums stored as gauges",
        "Example: Raw gauge value for cumulative sums",
        "Example: Rate of change with cumulative sums as gauges",
        "Query gauge metrics",
        "Query histogram metrics",
        "Example: Normal distribution",
        "Example: Heat map",
        "Logs",
        "Send logs to New Relic",
        "Application log correlation",
        "View OpenTelemetry logs",
        "The time field"
      ],
      "title": "Best practices for OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "b26055149cf57bdca8f27ae00d3ac93f75e4cc86",
      "image": "https://docs.newrelic.com/static/38ea1bb698187129fb2d8d38ea2dcde8/c1b63/sum-derivative-function.png",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-concepts/",
      "published_at": "2021-12-30T03:36:45Z",
      "updated_at": "2021-11-13T14:55:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are some best practices based on how OpenTelemetry works with New Relic: Resources Batching Compression Traces Metrics Logs Tip For information about resolving specific issues, see our troubleshooting guide. Resources A resource in OpenTelemetry represents information about an entity generating telemetry data. All telemetry data sent to New Relic is expected to be associated with a resource so that it can be linked with the appropriate entity in New Relic. The OpenTelemetry Resource SDK specification defines the functionality implemented by all language SDKs for defining a resource. The following suites of attributes are defined by the OpenTelemetry resource semantic conventions. These attributes are usually set by creating a resource using the OpenTelemetry SDK. service.* attributes service.name attribute is required to associate your resource with an entity in the UI service.instance.id is required for certain panes to light up telemetry.sdk.language=java is required to see data in the JVM section Batching Caution Avoid getting rate limited! You should batch requests sent to the OTLP endpoint as described in this section. By default, the OpenTelemetry SDKs and Collector send one (1) data point per request. Using these defaults, it is likely your account will be rate limited. All OpenTelemetry SDKs and Collectors provide a BatchProcessor, which batches data points in memory. This batching allows requests to be sent with more than one (1) data point. Component Batch Processor Collector Batch Processor Go SDK BatchSpanProcessor JS SDK BatchSpanProcessor Python SDK BatchExportSpanProcessor Compression New Relic supports gzip compression for OTLP payloads exported over gRPC. To maximize the amount of data you can send per request, we recommend enabling compression in all OTLP exporters. If there are other compression formats you'd like to see us support, please let us know in the CNCF Slack channel. Traces Familiarize yourself with these trace topics to ensure your traces and spans appear in New Relic. Required fields The startTimeUnixNano and endTimeUnixNano fields on spans are required according to the OpenTelemetry protocol for trace data. When startTimeUnixNano is not present, the span is dropped and a NrIntegrationError is created. When endTimeUnixNano is not present, the duration of your span is large and negative. The timeUnixNano field on span events is required. When timeUnixNano is not present, the span event is dropped and a NrIntegrationError is created. The traceId and spanId fields on spans are required according to the OpenTelemetry protocol for trace data. When traceId or spanId are not present, the span is dropped and a NrIntegrationError is created. Sampling Trace data is the most mature OpenTelemetry data type. Because of this, New Relic's OpenTelemetry user experience is largely based on trace data and is therefore influenced by your sampling strategy. You can configure sampling in a number of places: Service: Use the OpenTelemetry SDK for your language. Collector: If you're running your own instance of the OpenTelemetry collector, you can configure it to do more sophisticated forms of sampling, such as tail-based sampling (see below). Check out this documentation about how to configure different types of sampling: OpenTelemetry built-in samplers Built-in samplers implemented by the OpenTelemetry SDK for each language. OpenTelemetry tail-based samplers The OpenTelemetry collector has a tail-based sampling processor. We have an example demonstrating the use of the tail-based sampling processor. New Relic tail-based sampling with Infinite Tracing Infinite Tracing is New Relic's tail-based sampling option. You can use this in conjunction with your OpenTelemetry instrumented services. In setting up Infinite Tracing, you need to override the default span endpoint and send telemetry data to the New Relic trace observer: Important Currently, Infinite Tracing does not support OTLP ingest. You must run your own instance of the OpenTelemetry Collector and configure it to use the New Relic exporter. Follow the steps in Set up the trace observer to get the value for YOUR_TRACE_OBSERVER_URL. Use the value of YOUR_TRACE_OBSERVER_URL to configure your integration. Since you want New Relic to analyze all your traces, make sure to verify that your OpenTelemetry integrations use the AlwaysOn sampler. Metrics OpenTelemetry metrics are largely compatible with New Relic dimensional metrics. We support OpenTelemetry metrics v0.10. All of the supported metric types include an independent set of associated attributes (name-value pairs) which map directly to dimensions you can use to facet or filter metric data at query time. OpenTelemetry metrics are accompanied by a set of resource attributes that identify the originating entity that produced them and map to dimensions for faceting and filtering. The OpenTelemetry data model for metrics defines a number of different metric types: sum, gauge, histogram, and summary. Sum metrics OpenTelemetry sums are a scalar metric that is the sum of all data points over a given time window. Sums have a notion of temporality indicating whether reported values incorporate previous measurements (cumulative temporality) or not (delta temporality). In addition, sums can either be monotonic (only go up or only go down) or non-monotonic (go up and down). Delta sums In New Relic, delta metrics are handled differently depending on whether they are monotonic or non-monotonic: Monotonic delta sums are mapped to the count metric type. Non-monotonic delta sums are mapped to the gauge metric type. Cumulative sums Monotonic and non-monotonic cumulative sums are mapped to the New Relic gauge metric type. Sum configuration examples To understand how to configure aggregation temporality, see these examples using the Java and Go OpenTelemetry SDKs. Gauge metrics OpenTelemetry gauge metric data points represent a sampled value at a given time. These values are converted to the New Relic gauge metric type. OpenTelemetry gauges do not have an aggregation temporality, but the sampled values can be aggregated at query time. Histogram metrics OpenTelemetry histograms compactly represent a population of recorded values along with a total count and sum. Optionally, histograms may include a series of buckets with explicit bounds and a count value for that bucket’s population. OpenTelemetry histograms are converted to New Relic’s distribution metric type, which is backed by a scaled exponential base 2 histogram (see NrSketch for a more thorough explanation). Counts from OpenTelemetry histogram buckets are assigned to New Relic’s distribution metric buckets using linear interpolation. Also, OpenTelemetry has negative and positive infinity bound buckets which we represent in New Relic as zero-width buckets. We do this because we do not have a representation for negative and positive infinity. For example, an OpenTelemetry bucket with bounds [-∞, 10) will be represented by a [10,10) zero width New Relic bucket. You may see exaggerated bucket counts at the endpoints of your distribution due to this translation. Summary metrics OpenTelemetry summary metric data points are used to represent quantile summaries (for example, P99 latency). These map directly to the New Relic summary metric type. Summary metric data points include count, sum, and quantile values, with 0.0 as min and 1.0 as max. OpenTelemetry provides summary metrics for compatibility with other formats. Start time The startTimeUnixNano field is optional according to the OpenTelemetry specification. When this field is provided, it is used for the timestamp on the resulting NewRelic metric, and the duration is calculated as timeUnixNano - startTimeUnixNano. The duration field is used to calculate the queryable endTimeStamp attribute on the New Relic metric, but it serves no other semantic purpose. If startTimeUnixNano is not provided, then timeUnixNano is used for the timestamp field on the resulting NewRelic metric, and the duration field is set to zero. Array values for attributes OpenTelemetry metrics and other signals may include attributes that consist of a homogenous array of primitive types. These attributes are not supported by New Relic. Exemplars OpenTelemetry defines exemplar values that allow other signals, like traces, to be connected to a metric event and provide context. Exemplars are not supported by New Relic. How to query metrics Consider these tips for building metric NRQL queries in New Relic. Query cumulative sums stored as gauges Since cumulative sums are converted to gauges, here are some ways to query your data: Example: Raw gauge value for cumulative sums To view the raw gauge value for cumulative sums, you can use the latest() NRQL function: SELECT latest(totalApiBytesSent) FROM Metric TIMESERIES FACET description, statusCode Copy Example: Rate of change with cumulative sums as gauges To see the rate of change over a given time interval for a cumulative sum stored as a gauge, you can use the derivative() NRQL function: SELECT derivative(totalApiBytesSent, 1 second) FROM Metric TIMESERIES 5 MINUTES SLIDE BY 1 MINUTE FACET description, statusCode Copy New Relic does not currently support either reporting on resets and gaps or accounting for them with cumulative counters. Query gauge metrics When New Relic converts cumulative sums to gauges, you can query them using either the latest() or derivative() NRQL functions. The function you choose depends on whether you want to see the raw value or compute the rate of change. Query histogram metrics New Relic histograms translated from OpenTelemetry metrics have the same query semantics as other New Relic histograms. Namely, the histogram() NRQL function can be used to represent the histogram with a configurable number of buckets and bucket width. Note that you may see larger bucket counts at the endpoint buckets. This is because we are adding negative and positive infinity bound OpenTelemetry buckets into a zero width New Relic bucket. Example: Normal distribution FROM Metric SELECT histogram(test.histogram, buckets: 100, width: 1000) WHERE distributionType = 'Normal Distribution' SINCE 1 day ago Copy Example: Heat map The FACET keyword is also available to create heat map charts. FROM Metric SELECT histogram(test.histogram, buckets: 100, width: 1000) FACET distributionType SINCE 1 day ago Copy Important The TIMESERIES keyword is not supported for New Relic histograms. Logs Logs generated from your applications and environment are an important piece of telemetry. They may represent application logs, machine generated events, or system logs. OpenTelemetry has defined a log data model for representing log data. You can send logs using OpenTelemetry tooling, correlate them with applications, and view them in New Relic. Send logs to New Relic The OpenTelemetry Collector and OpenTelemetry Collector Contrib repositories contain a number of components for consuming log data. The general pattern is to configure the collector to: Receive logs from any of the log receivers. Some of the receiver options include Filelog Receiver, Fluent Forward Receiver, and Syslog Receiver. Process logs, potentially annotating them with resource information. Some of the processor options include Resource Detection Processor and Resource Processor. Export logs to New Relic via the OTLP exporter. Application log correlation Application logs are more useful if they're correlated with other telemetry data produced by the application. The OpenTelemetry semantic convention for services specifies service.name as a required field. All application metric, trace, and log data sent to New Relic with the same service.name are associated with the same entity. The specifics of how logs get annotated with the service.name resource attribute depends on the application's environment: Applications may produce structured JSON logs, which you can configure to include service.name as another field. You can deploy applications alongside a dedicated Collector Agent instance, which you can configure with a Resource Processor to annotate logs with the service.name attribute. Optionally, additional application trace context (sometimes called execution context) can be propagated to log messages. The setup and availability of this depends on the language and logging framework used by the application. The general strategy is to set up the application to write structured JSON logs and to configure it to extract trace context into specified trace context fields on available log messages. The Logs in Context with Log4j2 example in GitHub demonstrates an end-to-end working example for a simple Java application using Log4j2. View OpenTelemetry logs Here are two ways you can view logs: Look in the New Relic Logs UI. If your logs are correlated with an application, view them in the context of the application. The time field The timeUnixNano field is optional according to the OpenTelemetry specification for log data. When timeUnixNano is not present New Relic will use the time that the data was received for the New Relic log timestamp.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 223.37346,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Best practices for <em>OpenTelemetry</em> with New Relic",
        "sections": "Best practices for <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " of YOUR_TRACE_OBSERVER_URL to configure your integration. Since you want New Relic to analyze all your traces, make sure to verify that your <em>OpenTelemetry</em> <em>integrations</em> use the AlwaysOn sampler. Metrics <em>OpenTelemetry</em> metrics are largely compatible with New Relic dimensional metrics. We support <em>OpenTelemetry</em>"
      },
      "id": "617d77ec28ccbc08677ff6b5"
    }
  ],
  "/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-concepts": [
    {
      "sections": [
        "Introduction to OpenTelemetry with New Relic",
        "Benefits of OpenTelemetry",
        "Should I use OpenTelemetry instrumentation or New Relic agents?",
        "OpenTelemetry: A work in progress",
        "New Relic's APM agents",
        "How OpenTelemetry works with New Relic",
        "Important",
        "Traces",
        "Metrics",
        "Logs",
        "Next steps"
      ],
      "title": "Introduction to OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "67818451ffb7594e3c27526f4082bd1bc007bc51",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/introduction-opentelemetry-new-relic/",
      "published_at": "2021-12-30T03:36:05Z",
      "updated_at": "2021-12-20T05:36:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Are you already familiar with OpenTelemetry and want to begin the setup? Check out our quick start: Quick start If you don't have one already, create a New Relic account. It's free, forever. If you're just getting acquainted with OpenTelemetry, this is what we'll explore here: Benefits of OpenTelemetry Should I use OpenTelemetry or New Relic agents? How OpenTelemetry works with New Relic Benefits of OpenTelemetry OpenTelemetry provides a secure, vendor-neutral specification for service instrumentation so that you can export data to distinct backends of your choice, such as New Relic. OpenTelemetry offers a single set of APIs and libraries that standardize how you collect and transfer telemetry data for your services. The following components make up the OpenTelemetry project: Specifications for the core pillars of observability to drive consistency across all projects. New Relic supports all of these signals: traces, metrics, and logs (see details below) APIs that contain interfaces and implementations based on the specifications SDKs (reference implementations of the APIs) created specifically for languages like Java, Python, Go, Erlang, and more Collectors that offer a vendor-agnostic implementation for processing and exporting Exporters that enable you to send data to a backend of your choice The components of OpenTelemetry work together to create some distinct advantages for capturing telemetry data: Feature Description Ubiquitous instrumentation A single, open standard of instrumentation provides better coverage and flexibility as engineers from all over the world contribute to the instrumentation. Future proof As the instrumentation gets built into libraries and frameworks, and as more vendors move to support this open standard, you can be confident that you won’t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build integrations into OpenTelemetry or add instrumentation directly to source code, ensuring end users can easily monitor these new technologies. Simplified choice You don’t need to decide which instrumentation option to use (a proprietary option or one of the other open standards). Cross-platform compatibility OpenTelemetry supports a variety of languages and backends. It represents a vendor-neutral path for capturing and transmitting telemetry to backends without altering existing instrumentation. Streamlined observability It is easier for vendors to support and test against a single standard as they don’t need to develop their own agents or collectors. High dimensionality OpenTelemetry uses dimensional metrics, so you can filter and facet on more aspects of the data, such as AWS regions, Kubernetes clusters, or service versions. Dimensional metrics also lead to less time between occurrence and reporting. Should I use OpenTelemetry instrumentation or New Relic agents? As you consider OpenTelemetry, you may also be looking at New Relic APM agents that also capture telemetry data. As you'd expect, there is a lot of overlap between features available from OpenTelemetry agents and SDKs versus those available from New Relic APM agents. This is especially true if you're interested in distributed tracing telemetry data. The choice you make depends on what you need. We recommend that you explore both New Relic and OpenTelemetry instrumentation or discuss this with us in our CNCF Slack channel to decide what works best for you. OpenTelemetry: A work in progress OpenTelemetry is still an emerging standard, so your choices may be affected by what's available. You can check on the current state of the specification at the OpenTelemetry site. The current state of language-specific OpenTelemetry APIs and SDKs varies: some languages are still pre-alpha and may be missing instructions on how to instrument your service. Most languages have some implementation of traces that is sufficient to start exporting data to New Relic. Check out this table in GitHub that provides an overview of the state of OpenTelemetry specification compliance for each language. For languages that New Relic does not currently provide an agent or SDK, OpenTelemetry may offer you a good alternative. Also, in cases where you want explicit control over sampling of your telemetry data, OpenTelemetry provides a lot of flexibility. As OpenTelemetry matures, New Relic will continue to support new OpenTelemetry data models and to provide a curated UI experience for our customers. New Relic's APM agents In general, New Relic's APM agents will collect more telemetry data for your services, and they offer a wide range of configuration options and an extensive set of auto-instrumentation capabilities. New Relic's APM agents offer detailed transaction trace visibility for individual services. They also offer predefined sampling to balance the performance impact of your instrumentation against the need to capture enough data to gain helpful insights. How OpenTelemetry works with New Relic New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemetry community to export your data to New Relic. The following tables show the supported features for each telemetry signal. If you have questions about these or have an unsupported use case, please contact us in our CNCF Slack channel, and watch this page for future updates. Important New Relic's exporters for OpenTelemetry are now deprecated in favor of exporting data to New Relic using OTLP. Traces New Relic offers support for the OTLP ingest of trace signals. The maturity of the upstream specification is stable. OpenTelemetry traces and spans are compatible with New Relic traces and spans. OpenTelemetry spans optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter span data at query time. OpenTelemetry span metadata (for example, name, kind, and trace_id) also map directly to dimensions on NewRelic spans. At this time, New Relic does not support span links or array attributes. For details, see the Traces section of our best practices guide. Feature Supported Span events ✅ Span linking ❌ Array of primitives (homogeneous) ❌ Metrics New Relic offers support for the OTLP ingest of metric signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. Here are the OpenTelemetry data types we support and their associated mappings. For details, see the Metrics section of our best practices guide. Metric Type Supported Delta sums ✅ Cumulative sums ✅ Gauges ✅ Delta histograms ✅ Summary ✅ Cumulative histograms ❌ Exemplars ❌ Array of primitives (homogeneous) ❌ Logs New Relic offers support for the OTLP ingest of log signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. OpenTelemetry logs are compatible with New Relic logs. OpenTelemetry logs optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter log data at query time. OpenTelemetry log metadata (for example, name, severity_text, and trace_id) also map directly to dimensions on New Relic logs. NewRelic currently supports all OpenTelemetry log message types except for arrays. For more details, see the Logs section of our best practices guide. Feature Supported Description LogRecord body ✅ Supported types: string, boolean, int, double, bytes LogRecord attributes ✅ Supported types: string, boolean, int, double, bytes LogRecord fields ✅ Examples: name, severity_text, trace_id Array messages ❌ Array attributes ❌ Next steps Follow the OpenTelemetry quick start to help you get started. You'll also want to review the best practices guide for getting the most out of the data you export to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 285.7299,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "sections": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " won’t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build <em>integrations</em> into <em>OpenTelemetry</em> or add instrumentation directly to <em>source</em> code, ensuring end users can easily monitor these new technologies. Simplified choice You don’t need"
      },
      "id": "6174afe1e7b9d2748213b3a6"
    },
    {
      "sections": [
        "OpenTelemetry quick start",
        "Step 1. Prerequisites",
        "Step 2. Instrument your service with OpenTelemetry",
        "Step 3. Export your telemetry data to New Relic",
        "Review New Relic settings for exports",
        "Important",
        "Complete the export configuration steps",
        "Export data to an OpenTelemetry Collector (optional)",
        "Step 4. View your data in the New Relic UI",
        "View our OpenTelemetry examples",
        "What's next?"
      ],
      "title": "OpenTelemetry quick start",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "067b2e00bd167f4d78a1398575acd6f3ac76e069",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-quick-start/",
      "published_at": "2021-12-30T03:36:45Z",
      "updated_at": "2021-12-04T16:46:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "OpenTelemetry is a flexible toolkit that you can implement in a variety of ways. We recommend a basic four-step approach for setting up OpenTelemetry with New Relic. Here's an overview of the process, followed by details for each step. Prerequisites Instrument your service with OpenTelemetry Export your telemetry data to New Relic View your data in the New Relic UI Step 1. Prerequisites First things first: If we don’t already know you, sign up for a free New Relic account. Copy your account license key. Step 2. Instrument your service with OpenTelemetry To get started, you instrument your service with OpenTelemetry. OpenTelemetry has language-specific products and SDKs to help you. Many languages offer out-the-box instrumentation for common libraries and frameworks. Each language also provides an API for further instrumenting your service manually. Go to the repository for your language and follow the instructions to instrument your service. When you're done, return here to complete Step 3. Export your telemetry data to New Relic. C++ Erlang Go Java Javascript/Node.js .NET PHP Python Ruby Rust Swift ...See a complete list of languages in GitHub Step 3. Export your telemetry data to New Relic The OpenTelemetry Protocol, or OTLP for short, is a general purpose telemetry data delivery protocol designed for the OpenTelemetry project. This protocol describes how to encode and transmit telemetry data, which makes it a natural choice for data transport. Each language SDK provides an OTLP exporter you can configure to export data over OTLP. In this step, we focus on how to configure an OTLP exporter in your service to export data directly to New Relic. If you prefer to export your data first to an OpenTelemetry collector, we have separate instructions. Here's an example of sending data from your service directly to New Relic. To complete this third step, first familiarize yourself with some required New Relic settings, and then complete the steps in the OTLP exporter documentation for your language. Review New Relic settings for exports Before you go to the external OTLP exporter documentation, consult the table below so you're ready to do the following: Configure the OTLP exporter to add a header (api-key) whose value is the license key for the New Relic account you want to send data to. Based on your region, configure the endpoint where the exporter sends data to New Relic. Region gRPC HTTP/1.1 Endpoint API header name API header value TLS encryption required US ✅ ❌ https://otlp.nr-data.net:4317 api-key License key ✅ EU ✅ ❌ https://otlp.eu01.nr-data.net:4317 api-key License key ✅ Important If you have FedRamp compliance constraints, you will need to use https://gov-otlp.nr-data.net:4317. Please see FedRAMP-compliant endpoints for further information. Important In Node.js, the opentelemetry-collector-grpc library requires additional options to enable TLS. Complete the export configuration steps Click on the link below for your language and complete the configuration steps. When you're done, return here to complete Step 4. View your data in the New Relic UI. C++ Erlang Go Java Javascript/Node.js .NET PHP Python Ruby Rust Swift ...Find additional OTLP language support in GitHub Export data to an OpenTelemetry Collector (optional) The OpenTelemetry Collector is a configurable and extensible software component to receive, process, and export telemetry data. When you set up a collector, it can operate as a gateway or as an agent: Gateway: The collector receives data from a variety of sources and applies standard processing before exporting to some backend. Agent: The collector is deployed on each host in an environment and can collect telemetry data about the host and processes running on it. When you use a collector, you start by following the same routine as above for setting up OTLP in your service. In this case, instead of exporting data directly to New Relic, you export through a collector that you set up. In the collector, you configure the OTLP exporter to export data to New Relic. When your data goes through a collector, the transport looks like this: Here's a Docker example of how to set up and run an OpenTelemetry collector with the collector YAML: Save the following as otel-config.yaml: receivers: otlp: protocols: grpc: http: processors: batch: exporters: otlp: endpoint: ${OTEL_EXPORTER_OTLP_ENDPOINT} headers: api-key: ${NEW_RELIC_LICENSE_KEY} service: pipelines: traces: receivers: [otlp] processors: [batch] exporters: [otlp] metrics: receivers: [otlp] processors: [batch] exporters: [otlp] logs: receivers: [otlp] processors: [batch] exporters: [otlp] Copy Run the OpenTelemetry collector, making sure you replace OTLP_ENDPOINT_HERE with the appropriate endpoint and replace YOUR_KEY_HERE with your account's license key: export OTEL_EXPORTER_OTLP_ENDPOINT=OTLP_ENDPOINT_HERE export NEW_RELIC_LICENSE_KEY=YOUR_KEY_HERE docker run --rm \\ -e OTEL_EXPORTER_OTLP_ENDPOINT \\ -e NEW_RELIC_LICENSE_KEY \\ -p 4317:4317 \\ -v \"${PWD}/otel-config.yaml\":/otel-config.yaml \\ --config otel-config.yaml \\ --name otelcol \\ otel/opentelemetry-collector Copy Step 4. View your data in the New Relic UI Once you’ve instrumented your service and configured it to export its data to New Relic, watch the New Relic One user interface for your traces, metrics, and logs! The UI for OpenTelemetry has some similarities to the APM agent UI, so if you are familiar with that, you can go right to the UI. If you need help understanding your OpenTelemetry UI options or how to make sure your data appears in the UI, see View your OpenTelemetry data in New Relic. View our OpenTelemetry examples View some of our examples for using OpenTelemetry with New Relic. What's next? After you do your initial setup, check out our best-practices guide for tips about various configurations to improve your use of OpenTelemetry and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 243.45436,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>OpenTelemetry</em> quick start",
        "sections": "<em>OpenTelemetry</em> quick start",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": "<em>OpenTelemetry</em> is a flexible toolkit that you can implement in a variety of ways. We recommend a basic four-step approach for setting up <em>OpenTelemetry</em> with New Relic. Here&#x27;s an overview of the process, followed by details for each step. Prerequisites Instrument your service with <em>OpenTelemetry</em> Export"
      },
      "id": "617dca7464441f8186fbc951"
    },
    {
      "sections": [
        "Troubleshooting OpenTelemetry with New Relic",
        "OpenTelemetry data sent via OTLP is not queryable",
        "Problem",
        "Solution",
        "Important",
        "OpenTelemetry entities or relationships are missing",
        "Tip"
      ],
      "title": "Troubleshooting OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "9478cc98ba9216af5ad8c74883abdf14565a21a4",
      "image": "https://docs.newrelic.com/static/93271ff8121b09ca17395fdf3f27e700/c1b63/otlp-troubleshooting-facet-query.png",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-troubleshooting/",
      "published_at": "2021-12-30T07:49:15Z",
      "updated_at": "2021-12-04T16:46:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Troubleshooting OpenTelemetry with New Relic may just be a matter of making sure you are following best practices, but sometimes you may need to take additional steps to diagnose your issues. Here are some examples of specific problems you might encounter, along with steps and tools to resolve them. OpenTelemetry data sent via OTLP is not queryable Problem You sent OpenTelemetry metrics, logs, or traces using OTLP and are unable to view the data. Before digging deeper, make sure you've checked the following: The OTLP endpoint configured matches one of our documented endpoints, is properly formatted, and includes the official default port, 4317. Sending OTLP data via port 443 is not supported at this time. Please note the specific endpoint for FedRAMP compliance, if applicable. The outbound traffic is not restricted by a firewall. Our Networks document explains domains and network blocks that you may need to explicitly allow. The client is configured to use TLS 1.2 or higher and the request includes the api-key header with a valid New Relic account (ingest) license key. Requests include valid protobuf payloads and use gRPC and HTTP/2 transport, preferably with gzip compression enabled. Sending protobuf or JSON-encoded payloads over HTTP/1.1 is not supported at this time. Client output and logs do not indicate 4xx or 5xx response codes are being returned. Solution There are number of tools you can use to validate the successful delivery of telemetry data to our platform. A good first step is to check the data management hub to facet data ingest and determine how much data is arriving from various sources. You can also use the data explorer or query builder to look for data faceted by instrumentation.provider or newrelic.source attributes: FROM Log, Metric, Span SELECT datapointcount() WHERE instrumentation.provider = 'opentelemetry' FACET instrumentation.provider, newrelic.source Copy This query should tell you whether data is arriving via OTLP. If the data you expect is not present, try removing the WHERE clause or checking for integration errors. Querying NrIntegrationError events can help you determine whether you have configuration or format issues or if you've run into our platform limits. Important The ingest limits for metrics, logs, and traces via OTLP are the same as our other data ingest API limits. Various parts of the New Relic UI rely on the presence of specific attributes to function properly. You can use the NRQL console feature in many places to check the WHERE or FACET clauses of the query for required attributes. You can also edit those clauses and re-run the query to determine whether there is data present with those attributes missing. Examples of required attributes include service.name and service.instance.id. For a more complete list of examples, see resources. OpenTelemetry entities or relationships are missing Problem You sent OpenTelemetry data from a service or infrastructure component and either the entity or its relationships are missing or incorrect. Solution OpenTelemetry entities will be synthesized based on the public rules described for the EXT-SERVICE entity type. The standard rule to match relies on the presence of the service.name dimension which follows the OpenTelemetry semantic conventions. To set the service.name with the OpenTelemetry Java SDK, include it in your resource: var resource = Resource.getDefault() .merge(Resource.builder().put(SERVICE_NAME, serviceName).build()); Copy Depending on the SDK, you may also set the service.name by declaring it in the OTEL_RESOURCE_ATTRIBUTES or OTEL_SERVICE_NAME environment variables. For Logs, you can use a structured log template to inject the service.name. Here are some log examples: Setting the service name Logs in context with Log4j2 Tip For more OpenTelemetry examples with New Relic, visit the newrelic-opentelemetry-examples repository on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 242.83432,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshooting <em>OpenTelemetry</em> with New Relic",
        "sections": "Troubleshooting <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": "Troubleshooting <em>OpenTelemetry</em> with New Relic may just be a matter of making sure you are following best practices, but sometimes you may need to take additional steps to diagnose your issues. Here are some examples of specific problems you might encounter, along with steps and tools to resolve them"
      },
      "id": "618e863f196a67bd4ce723da"
    }
  ],
  "/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-legacy-new-relic-exporters": [
    {
      "sections": [
        "Introduction to OpenTelemetry with New Relic",
        "Benefits of OpenTelemetry",
        "Should I use OpenTelemetry instrumentation or New Relic agents?",
        "OpenTelemetry: A work in progress",
        "New Relic's APM agents",
        "How OpenTelemetry works with New Relic",
        "Important",
        "Traces",
        "Metrics",
        "Logs",
        "Next steps"
      ],
      "title": "Introduction to OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "67818451ffb7594e3c27526f4082bd1bc007bc51",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/introduction-opentelemetry-new-relic/",
      "published_at": "2021-12-30T03:36:05Z",
      "updated_at": "2021-12-20T05:36:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Are you already familiar with OpenTelemetry and want to begin the setup? Check out our quick start: Quick start If you don't have one already, create a New Relic account. It's free, forever. If you're just getting acquainted with OpenTelemetry, this is what we'll explore here: Benefits of OpenTelemetry Should I use OpenTelemetry or New Relic agents? How OpenTelemetry works with New Relic Benefits of OpenTelemetry OpenTelemetry provides a secure, vendor-neutral specification for service instrumentation so that you can export data to distinct backends of your choice, such as New Relic. OpenTelemetry offers a single set of APIs and libraries that standardize how you collect and transfer telemetry data for your services. The following components make up the OpenTelemetry project: Specifications for the core pillars of observability to drive consistency across all projects. New Relic supports all of these signals: traces, metrics, and logs (see details below) APIs that contain interfaces and implementations based on the specifications SDKs (reference implementations of the APIs) created specifically for languages like Java, Python, Go, Erlang, and more Collectors that offer a vendor-agnostic implementation for processing and exporting Exporters that enable you to send data to a backend of your choice The components of OpenTelemetry work together to create some distinct advantages for capturing telemetry data: Feature Description Ubiquitous instrumentation A single, open standard of instrumentation provides better coverage and flexibility as engineers from all over the world contribute to the instrumentation. Future proof As the instrumentation gets built into libraries and frameworks, and as more vendors move to support this open standard, you can be confident that you won’t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build integrations into OpenTelemetry or add instrumentation directly to source code, ensuring end users can easily monitor these new technologies. Simplified choice You don’t need to decide which instrumentation option to use (a proprietary option or one of the other open standards). Cross-platform compatibility OpenTelemetry supports a variety of languages and backends. It represents a vendor-neutral path for capturing and transmitting telemetry to backends without altering existing instrumentation. Streamlined observability It is easier for vendors to support and test against a single standard as they don’t need to develop their own agents or collectors. High dimensionality OpenTelemetry uses dimensional metrics, so you can filter and facet on more aspects of the data, such as AWS regions, Kubernetes clusters, or service versions. Dimensional metrics also lead to less time between occurrence and reporting. Should I use OpenTelemetry instrumentation or New Relic agents? As you consider OpenTelemetry, you may also be looking at New Relic APM agents that also capture telemetry data. As you'd expect, there is a lot of overlap between features available from OpenTelemetry agents and SDKs versus those available from New Relic APM agents. This is especially true if you're interested in distributed tracing telemetry data. The choice you make depends on what you need. We recommend that you explore both New Relic and OpenTelemetry instrumentation or discuss this with us in our CNCF Slack channel to decide what works best for you. OpenTelemetry: A work in progress OpenTelemetry is still an emerging standard, so your choices may be affected by what's available. You can check on the current state of the specification at the OpenTelemetry site. The current state of language-specific OpenTelemetry APIs and SDKs varies: some languages are still pre-alpha and may be missing instructions on how to instrument your service. Most languages have some implementation of traces that is sufficient to start exporting data to New Relic. Check out this table in GitHub that provides an overview of the state of OpenTelemetry specification compliance for each language. For languages that New Relic does not currently provide an agent or SDK, OpenTelemetry may offer you a good alternative. Also, in cases where you want explicit control over sampling of your telemetry data, OpenTelemetry provides a lot of flexibility. As OpenTelemetry matures, New Relic will continue to support new OpenTelemetry data models and to provide a curated UI experience for our customers. New Relic's APM agents In general, New Relic's APM agents will collect more telemetry data for your services, and they offer a wide range of configuration options and an extensive set of auto-instrumentation capabilities. New Relic's APM agents offer detailed transaction trace visibility for individual services. They also offer predefined sampling to balance the performance impact of your instrumentation against the need to capture enough data to gain helpful insights. How OpenTelemetry works with New Relic New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemetry community to export your data to New Relic. The following tables show the supported features for each telemetry signal. If you have questions about these or have an unsupported use case, please contact us in our CNCF Slack channel, and watch this page for future updates. Important New Relic's exporters for OpenTelemetry are now deprecated in favor of exporting data to New Relic using OTLP. Traces New Relic offers support for the OTLP ingest of trace signals. The maturity of the upstream specification is stable. OpenTelemetry traces and spans are compatible with New Relic traces and spans. OpenTelemetry spans optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter span data at query time. OpenTelemetry span metadata (for example, name, kind, and trace_id) also map directly to dimensions on NewRelic spans. At this time, New Relic does not support span links or array attributes. For details, see the Traces section of our best practices guide. Feature Supported Span events ✅ Span linking ❌ Array of primitives (homogeneous) ❌ Metrics New Relic offers support for the OTLP ingest of metric signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. Here are the OpenTelemetry data types we support and their associated mappings. For details, see the Metrics section of our best practices guide. Metric Type Supported Delta sums ✅ Cumulative sums ✅ Gauges ✅ Delta histograms ✅ Summary ✅ Cumulative histograms ❌ Exemplars ❌ Array of primitives (homogeneous) ❌ Logs New Relic offers support for the OTLP ingest of log signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. OpenTelemetry logs are compatible with New Relic logs. OpenTelemetry logs optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter log data at query time. OpenTelemetry log metadata (for example, name, severity_text, and trace_id) also map directly to dimensions on New Relic logs. NewRelic currently supports all OpenTelemetry log message types except for arrays. For more details, see the Logs section of our best practices guide. Feature Supported Description LogRecord body ✅ Supported types: string, boolean, int, double, bytes LogRecord attributes ✅ Supported types: string, boolean, int, double, bytes LogRecord fields ✅ Examples: name, severity_text, trace_id Array messages ❌ Array attributes ❌ Next steps Follow the OpenTelemetry quick start to help you get started. You'll also want to review the best practices guide for getting the most out of the data you export to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 285.7299,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "sections": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " won’t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build <em>integrations</em> into <em>OpenTelemetry</em> or add instrumentation directly to <em>source</em> code, ensuring end users can easily monitor these new technologies. Simplified choice You don’t need"
      },
      "id": "6174afe1e7b9d2748213b3a6"
    },
    {
      "sections": [
        "OpenTelemetry quick start",
        "Step 1. Prerequisites",
        "Step 2. Instrument your service with OpenTelemetry",
        "Step 3. Export your telemetry data to New Relic",
        "Review New Relic settings for exports",
        "Important",
        "Complete the export configuration steps",
        "Export data to an OpenTelemetry Collector (optional)",
        "Step 4. View your data in the New Relic UI",
        "View our OpenTelemetry examples",
        "What's next?"
      ],
      "title": "OpenTelemetry quick start",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "067b2e00bd167f4d78a1398575acd6f3ac76e069",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-quick-start/",
      "published_at": "2021-12-30T03:36:45Z",
      "updated_at": "2021-12-04T16:46:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "OpenTelemetry is a flexible toolkit that you can implement in a variety of ways. We recommend a basic four-step approach for setting up OpenTelemetry with New Relic. Here's an overview of the process, followed by details for each step. Prerequisites Instrument your service with OpenTelemetry Export your telemetry data to New Relic View your data in the New Relic UI Step 1. Prerequisites First things first: If we don’t already know you, sign up for a free New Relic account. Copy your account license key. Step 2. Instrument your service with OpenTelemetry To get started, you instrument your service with OpenTelemetry. OpenTelemetry has language-specific products and SDKs to help you. Many languages offer out-the-box instrumentation for common libraries and frameworks. Each language also provides an API for further instrumenting your service manually. Go to the repository for your language and follow the instructions to instrument your service. When you're done, return here to complete Step 3. Export your telemetry data to New Relic. C++ Erlang Go Java Javascript/Node.js .NET PHP Python Ruby Rust Swift ...See a complete list of languages in GitHub Step 3. Export your telemetry data to New Relic The OpenTelemetry Protocol, or OTLP for short, is a general purpose telemetry data delivery protocol designed for the OpenTelemetry project. This protocol describes how to encode and transmit telemetry data, which makes it a natural choice for data transport. Each language SDK provides an OTLP exporter you can configure to export data over OTLP. In this step, we focus on how to configure an OTLP exporter in your service to export data directly to New Relic. If you prefer to export your data first to an OpenTelemetry collector, we have separate instructions. Here's an example of sending data from your service directly to New Relic. To complete this third step, first familiarize yourself with some required New Relic settings, and then complete the steps in the OTLP exporter documentation for your language. Review New Relic settings for exports Before you go to the external OTLP exporter documentation, consult the table below so you're ready to do the following: Configure the OTLP exporter to add a header (api-key) whose value is the license key for the New Relic account you want to send data to. Based on your region, configure the endpoint where the exporter sends data to New Relic. Region gRPC HTTP/1.1 Endpoint API header name API header value TLS encryption required US ✅ ❌ https://otlp.nr-data.net:4317 api-key License key ✅ EU ✅ ❌ https://otlp.eu01.nr-data.net:4317 api-key License key ✅ Important If you have FedRamp compliance constraints, you will need to use https://gov-otlp.nr-data.net:4317. Please see FedRAMP-compliant endpoints for further information. Important In Node.js, the opentelemetry-collector-grpc library requires additional options to enable TLS. Complete the export configuration steps Click on the link below for your language and complete the configuration steps. When you're done, return here to complete Step 4. View your data in the New Relic UI. C++ Erlang Go Java Javascript/Node.js .NET PHP Python Ruby Rust Swift ...Find additional OTLP language support in GitHub Export data to an OpenTelemetry Collector (optional) The OpenTelemetry Collector is a configurable and extensible software component to receive, process, and export telemetry data. When you set up a collector, it can operate as a gateway or as an agent: Gateway: The collector receives data from a variety of sources and applies standard processing before exporting to some backend. Agent: The collector is deployed on each host in an environment and can collect telemetry data about the host and processes running on it. When you use a collector, you start by following the same routine as above for setting up OTLP in your service. In this case, instead of exporting data directly to New Relic, you export through a collector that you set up. In the collector, you configure the OTLP exporter to export data to New Relic. When your data goes through a collector, the transport looks like this: Here's a Docker example of how to set up and run an OpenTelemetry collector with the collector YAML: Save the following as otel-config.yaml: receivers: otlp: protocols: grpc: http: processors: batch: exporters: otlp: endpoint: ${OTEL_EXPORTER_OTLP_ENDPOINT} headers: api-key: ${NEW_RELIC_LICENSE_KEY} service: pipelines: traces: receivers: [otlp] processors: [batch] exporters: [otlp] metrics: receivers: [otlp] processors: [batch] exporters: [otlp] logs: receivers: [otlp] processors: [batch] exporters: [otlp] Copy Run the OpenTelemetry collector, making sure you replace OTLP_ENDPOINT_HERE with the appropriate endpoint and replace YOUR_KEY_HERE with your account's license key: export OTEL_EXPORTER_OTLP_ENDPOINT=OTLP_ENDPOINT_HERE export NEW_RELIC_LICENSE_KEY=YOUR_KEY_HERE docker run --rm \\ -e OTEL_EXPORTER_OTLP_ENDPOINT \\ -e NEW_RELIC_LICENSE_KEY \\ -p 4317:4317 \\ -v \"${PWD}/otel-config.yaml\":/otel-config.yaml \\ --config otel-config.yaml \\ --name otelcol \\ otel/opentelemetry-collector Copy Step 4. View your data in the New Relic UI Once you’ve instrumented your service and configured it to export its data to New Relic, watch the New Relic One user interface for your traces, metrics, and logs! The UI for OpenTelemetry has some similarities to the APM agent UI, so if you are familiar with that, you can go right to the UI. If you need help understanding your OpenTelemetry UI options or how to make sure your data appears in the UI, see View your OpenTelemetry data in New Relic. View our OpenTelemetry examples View some of our examples for using OpenTelemetry with New Relic. What's next? After you do your initial setup, check out our best-practices guide for tips about various configurations to improve your use of OpenTelemetry and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 243.45436,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>OpenTelemetry</em> quick start",
        "sections": "<em>OpenTelemetry</em> quick start",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": "<em>OpenTelemetry</em> is a flexible toolkit that you can implement in a variety of ways. We recommend a basic four-step approach for setting up <em>OpenTelemetry</em> with New Relic. Here&#x27;s an overview of the process, followed by details for each step. Prerequisites Instrument your service with <em>OpenTelemetry</em> Export"
      },
      "id": "617dca7464441f8186fbc951"
    },
    {
      "sections": [
        "Troubleshooting OpenTelemetry with New Relic",
        "OpenTelemetry data sent via OTLP is not queryable",
        "Problem",
        "Solution",
        "Important",
        "OpenTelemetry entities or relationships are missing",
        "Tip"
      ],
      "title": "Troubleshooting OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "9478cc98ba9216af5ad8c74883abdf14565a21a4",
      "image": "https://docs.newrelic.com/static/93271ff8121b09ca17395fdf3f27e700/c1b63/otlp-troubleshooting-facet-query.png",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-troubleshooting/",
      "published_at": "2021-12-30T07:49:15Z",
      "updated_at": "2021-12-04T16:46:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Troubleshooting OpenTelemetry with New Relic may just be a matter of making sure you are following best practices, but sometimes you may need to take additional steps to diagnose your issues. Here are some examples of specific problems you might encounter, along with steps and tools to resolve them. OpenTelemetry data sent via OTLP is not queryable Problem You sent OpenTelemetry metrics, logs, or traces using OTLP and are unable to view the data. Before digging deeper, make sure you've checked the following: The OTLP endpoint configured matches one of our documented endpoints, is properly formatted, and includes the official default port, 4317. Sending OTLP data via port 443 is not supported at this time. Please note the specific endpoint for FedRAMP compliance, if applicable. The outbound traffic is not restricted by a firewall. Our Networks document explains domains and network blocks that you may need to explicitly allow. The client is configured to use TLS 1.2 or higher and the request includes the api-key header with a valid New Relic account (ingest) license key. Requests include valid protobuf payloads and use gRPC and HTTP/2 transport, preferably with gzip compression enabled. Sending protobuf or JSON-encoded payloads over HTTP/1.1 is not supported at this time. Client output and logs do not indicate 4xx or 5xx response codes are being returned. Solution There are number of tools you can use to validate the successful delivery of telemetry data to our platform. A good first step is to check the data management hub to facet data ingest and determine how much data is arriving from various sources. You can also use the data explorer or query builder to look for data faceted by instrumentation.provider or newrelic.source attributes: FROM Log, Metric, Span SELECT datapointcount() WHERE instrumentation.provider = 'opentelemetry' FACET instrumentation.provider, newrelic.source Copy This query should tell you whether data is arriving via OTLP. If the data you expect is not present, try removing the WHERE clause or checking for integration errors. Querying NrIntegrationError events can help you determine whether you have configuration or format issues or if you've run into our platform limits. Important The ingest limits for metrics, logs, and traces via OTLP are the same as our other data ingest API limits. Various parts of the New Relic UI rely on the presence of specific attributes to function properly. You can use the NRQL console feature in many places to check the WHERE or FACET clauses of the query for required attributes. You can also edit those clauses and re-run the query to determine whether there is data present with those attributes missing. Examples of required attributes include service.name and service.instance.id. For a more complete list of examples, see resources. OpenTelemetry entities or relationships are missing Problem You sent OpenTelemetry data from a service or infrastructure component and either the entity or its relationships are missing or incorrect. Solution OpenTelemetry entities will be synthesized based on the public rules described for the EXT-SERVICE entity type. The standard rule to match relies on the presence of the service.name dimension which follows the OpenTelemetry semantic conventions. To set the service.name with the OpenTelemetry Java SDK, include it in your resource: var resource = Resource.getDefault() .merge(Resource.builder().put(SERVICE_NAME, serviceName).build()); Copy Depending on the SDK, you may also set the service.name by declaring it in the OTEL_RESOURCE_ATTRIBUTES or OTEL_SERVICE_NAME environment variables. For Logs, you can use a structured log template to inject the service.name. Here are some log examples: Setting the service name Logs in context with Log4j2 Tip For more OpenTelemetry examples with New Relic, visit the newrelic-opentelemetry-examples repository on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 242.83432,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshooting <em>OpenTelemetry</em> with New Relic",
        "sections": "Troubleshooting <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": "Troubleshooting <em>OpenTelemetry</em> with New Relic may just be a matter of making sure you are following best practices, but sometimes you may need to take additional steps to diagnose your issues. Here are some examples of specific problems you might encounter, along with steps and tools to resolve them"
      },
      "id": "618e863f196a67bd4ce723da"
    }
  ],
  "/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-quick-start": [
    {
      "sections": [
        "Introduction to OpenTelemetry with New Relic",
        "Benefits of OpenTelemetry",
        "Should I use OpenTelemetry instrumentation or New Relic agents?",
        "OpenTelemetry: A work in progress",
        "New Relic's APM agents",
        "How OpenTelemetry works with New Relic",
        "Important",
        "Traces",
        "Metrics",
        "Logs",
        "Next steps"
      ],
      "title": "Introduction to OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "67818451ffb7594e3c27526f4082bd1bc007bc51",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/introduction-opentelemetry-new-relic/",
      "published_at": "2021-12-30T03:36:05Z",
      "updated_at": "2021-12-20T05:36:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Are you already familiar with OpenTelemetry and want to begin the setup? Check out our quick start: Quick start If you don't have one already, create a New Relic account. It's free, forever. If you're just getting acquainted with OpenTelemetry, this is what we'll explore here: Benefits of OpenTelemetry Should I use OpenTelemetry or New Relic agents? How OpenTelemetry works with New Relic Benefits of OpenTelemetry OpenTelemetry provides a secure, vendor-neutral specification for service instrumentation so that you can export data to distinct backends of your choice, such as New Relic. OpenTelemetry offers a single set of APIs and libraries that standardize how you collect and transfer telemetry data for your services. The following components make up the OpenTelemetry project: Specifications for the core pillars of observability to drive consistency across all projects. New Relic supports all of these signals: traces, metrics, and logs (see details below) APIs that contain interfaces and implementations based on the specifications SDKs (reference implementations of the APIs) created specifically for languages like Java, Python, Go, Erlang, and more Collectors that offer a vendor-agnostic implementation for processing and exporting Exporters that enable you to send data to a backend of your choice The components of OpenTelemetry work together to create some distinct advantages for capturing telemetry data: Feature Description Ubiquitous instrumentation A single, open standard of instrumentation provides better coverage and flexibility as engineers from all over the world contribute to the instrumentation. Future proof As the instrumentation gets built into libraries and frameworks, and as more vendors move to support this open standard, you can be confident that you won’t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build integrations into OpenTelemetry or add instrumentation directly to source code, ensuring end users can easily monitor these new technologies. Simplified choice You don’t need to decide which instrumentation option to use (a proprietary option or one of the other open standards). Cross-platform compatibility OpenTelemetry supports a variety of languages and backends. It represents a vendor-neutral path for capturing and transmitting telemetry to backends without altering existing instrumentation. Streamlined observability It is easier for vendors to support and test against a single standard as they don’t need to develop their own agents or collectors. High dimensionality OpenTelemetry uses dimensional metrics, so you can filter and facet on more aspects of the data, such as AWS regions, Kubernetes clusters, or service versions. Dimensional metrics also lead to less time between occurrence and reporting. Should I use OpenTelemetry instrumentation or New Relic agents? As you consider OpenTelemetry, you may also be looking at New Relic APM agents that also capture telemetry data. As you'd expect, there is a lot of overlap between features available from OpenTelemetry agents and SDKs versus those available from New Relic APM agents. This is especially true if you're interested in distributed tracing telemetry data. The choice you make depends on what you need. We recommend that you explore both New Relic and OpenTelemetry instrumentation or discuss this with us in our CNCF Slack channel to decide what works best for you. OpenTelemetry: A work in progress OpenTelemetry is still an emerging standard, so your choices may be affected by what's available. You can check on the current state of the specification at the OpenTelemetry site. The current state of language-specific OpenTelemetry APIs and SDKs varies: some languages are still pre-alpha and may be missing instructions on how to instrument your service. Most languages have some implementation of traces that is sufficient to start exporting data to New Relic. Check out this table in GitHub that provides an overview of the state of OpenTelemetry specification compliance for each language. For languages that New Relic does not currently provide an agent or SDK, OpenTelemetry may offer you a good alternative. Also, in cases where you want explicit control over sampling of your telemetry data, OpenTelemetry provides a lot of flexibility. As OpenTelemetry matures, New Relic will continue to support new OpenTelemetry data models and to provide a curated UI experience for our customers. New Relic's APM agents In general, New Relic's APM agents will collect more telemetry data for your services, and they offer a wide range of configuration options and an extensive set of auto-instrumentation capabilities. New Relic's APM agents offer detailed transaction trace visibility for individual services. They also offer predefined sampling to balance the performance impact of your instrumentation against the need to capture enough data to gain helpful insights. How OpenTelemetry works with New Relic New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemetry community to export your data to New Relic. The following tables show the supported features for each telemetry signal. If you have questions about these or have an unsupported use case, please contact us in our CNCF Slack channel, and watch this page for future updates. Important New Relic's exporters for OpenTelemetry are now deprecated in favor of exporting data to New Relic using OTLP. Traces New Relic offers support for the OTLP ingest of trace signals. The maturity of the upstream specification is stable. OpenTelemetry traces and spans are compatible with New Relic traces and spans. OpenTelemetry spans optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter span data at query time. OpenTelemetry span metadata (for example, name, kind, and trace_id) also map directly to dimensions on NewRelic spans. At this time, New Relic does not support span links or array attributes. For details, see the Traces section of our best practices guide. Feature Supported Span events ✅ Span linking ❌ Array of primitives (homogeneous) ❌ Metrics New Relic offers support for the OTLP ingest of metric signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. Here are the OpenTelemetry data types we support and their associated mappings. For details, see the Metrics section of our best practices guide. Metric Type Supported Delta sums ✅ Cumulative sums ✅ Gauges ✅ Delta histograms ✅ Summary ✅ Cumulative histograms ❌ Exemplars ❌ Array of primitives (homogeneous) ❌ Logs New Relic offers support for the OTLP ingest of log signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. OpenTelemetry logs are compatible with New Relic logs. OpenTelemetry logs optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter log data at query time. OpenTelemetry log metadata (for example, name, severity_text, and trace_id) also map directly to dimensions on New Relic logs. NewRelic currently supports all OpenTelemetry log message types except for arrays. For more details, see the Logs section of our best practices guide. Feature Supported Description LogRecord body ✅ Supported types: string, boolean, int, double, bytes LogRecord attributes ✅ Supported types: string, boolean, int, double, bytes LogRecord fields ✅ Examples: name, severity_text, trace_id Array messages ❌ Array attributes ❌ Next steps Follow the OpenTelemetry quick start to help you get started. You'll also want to review the best practices guide for getting the most out of the data you export to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 285.72983,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "sections": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " won’t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build <em>integrations</em> into <em>OpenTelemetry</em> or add instrumentation directly to <em>source</em> code, ensuring end users can easily monitor these new technologies. Simplified choice You don’t need"
      },
      "id": "6174afe1e7b9d2748213b3a6"
    },
    {
      "sections": [
        "Troubleshooting OpenTelemetry with New Relic",
        "OpenTelemetry data sent via OTLP is not queryable",
        "Problem",
        "Solution",
        "Important",
        "OpenTelemetry entities or relationships are missing",
        "Tip"
      ],
      "title": "Troubleshooting OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "9478cc98ba9216af5ad8c74883abdf14565a21a4",
      "image": "https://docs.newrelic.com/static/93271ff8121b09ca17395fdf3f27e700/c1b63/otlp-troubleshooting-facet-query.png",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-troubleshooting/",
      "published_at": "2021-12-30T07:49:15Z",
      "updated_at": "2021-12-04T16:46:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Troubleshooting OpenTelemetry with New Relic may just be a matter of making sure you are following best practices, but sometimes you may need to take additional steps to diagnose your issues. Here are some examples of specific problems you might encounter, along with steps and tools to resolve them. OpenTelemetry data sent via OTLP is not queryable Problem You sent OpenTelemetry metrics, logs, or traces using OTLP and are unable to view the data. Before digging deeper, make sure you've checked the following: The OTLP endpoint configured matches one of our documented endpoints, is properly formatted, and includes the official default port, 4317. Sending OTLP data via port 443 is not supported at this time. Please note the specific endpoint for FedRAMP compliance, if applicable. The outbound traffic is not restricted by a firewall. Our Networks document explains domains and network blocks that you may need to explicitly allow. The client is configured to use TLS 1.2 or higher and the request includes the api-key header with a valid New Relic account (ingest) license key. Requests include valid protobuf payloads and use gRPC and HTTP/2 transport, preferably with gzip compression enabled. Sending protobuf or JSON-encoded payloads over HTTP/1.1 is not supported at this time. Client output and logs do not indicate 4xx or 5xx response codes are being returned. Solution There are number of tools you can use to validate the successful delivery of telemetry data to our platform. A good first step is to check the data management hub to facet data ingest and determine how much data is arriving from various sources. You can also use the data explorer or query builder to look for data faceted by instrumentation.provider or newrelic.source attributes: FROM Log, Metric, Span SELECT datapointcount() WHERE instrumentation.provider = 'opentelemetry' FACET instrumentation.provider, newrelic.source Copy This query should tell you whether data is arriving via OTLP. If the data you expect is not present, try removing the WHERE clause or checking for integration errors. Querying NrIntegrationError events can help you determine whether you have configuration or format issues or if you've run into our platform limits. Important The ingest limits for metrics, logs, and traces via OTLP are the same as our other data ingest API limits. Various parts of the New Relic UI rely on the presence of specific attributes to function properly. You can use the NRQL console feature in many places to check the WHERE or FACET clauses of the query for required attributes. You can also edit those clauses and re-run the query to determine whether there is data present with those attributes missing. Examples of required attributes include service.name and service.instance.id. For a more complete list of examples, see resources. OpenTelemetry entities or relationships are missing Problem You sent OpenTelemetry data from a service or infrastructure component and either the entity or its relationships are missing or incorrect. Solution OpenTelemetry entities will be synthesized based on the public rules described for the EXT-SERVICE entity type. The standard rule to match relies on the presence of the service.name dimension which follows the OpenTelemetry semantic conventions. To set the service.name with the OpenTelemetry Java SDK, include it in your resource: var resource = Resource.getDefault() .merge(Resource.builder().put(SERVICE_NAME, serviceName).build()); Copy Depending on the SDK, you may also set the service.name by declaring it in the OTEL_RESOURCE_ATTRIBUTES or OTEL_SERVICE_NAME environment variables. For Logs, you can use a structured log template to inject the service.name. Here are some log examples: Setting the service name Logs in context with Log4j2 Tip For more OpenTelemetry examples with New Relic, visit the newrelic-opentelemetry-examples repository on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 242.8343,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshooting <em>OpenTelemetry</em> with New Relic",
        "sections": "Troubleshooting <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": "Troubleshooting <em>OpenTelemetry</em> with New Relic may just be a matter of making sure you are following best practices, but sometimes you may need to take additional steps to diagnose your issues. Here are some examples of specific problems you might encounter, along with steps and tools to resolve them"
      },
      "id": "618e863f196a67bd4ce723da"
    },
    {
      "sections": [
        "Best practices for OpenTelemetry with New Relic",
        "Tip",
        "Resources",
        "Batching",
        "Caution",
        "Compression",
        "Traces",
        "Required fields",
        "Sampling",
        "OpenTelemetry built-in samplers",
        "OpenTelemetry tail-based samplers",
        "New Relic tail-based sampling with Infinite Tracing",
        "Important",
        "Metrics",
        "Sum metrics",
        "Delta sums",
        "Cumulative sums",
        "Sum configuration examples",
        "Gauge metrics",
        "Histogram metrics",
        "Summary metrics",
        "Start time",
        "Array values for attributes",
        "Exemplars",
        "How to query metrics",
        "Query cumulative sums stored as gauges",
        "Example: Raw gauge value for cumulative sums",
        "Example: Rate of change with cumulative sums as gauges",
        "Query gauge metrics",
        "Query histogram metrics",
        "Example: Normal distribution",
        "Example: Heat map",
        "Logs",
        "Send logs to New Relic",
        "Application log correlation",
        "View OpenTelemetry logs",
        "The time field"
      ],
      "title": "Best practices for OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "b26055149cf57bdca8f27ae00d3ac93f75e4cc86",
      "image": "https://docs.newrelic.com/static/38ea1bb698187129fb2d8d38ea2dcde8/c1b63/sum-derivative-function.png",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-concepts/",
      "published_at": "2021-12-30T03:36:45Z",
      "updated_at": "2021-11-13T14:55:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are some best practices based on how OpenTelemetry works with New Relic: Resources Batching Compression Traces Metrics Logs Tip For information about resolving specific issues, see our troubleshooting guide. Resources A resource in OpenTelemetry represents information about an entity generating telemetry data. All telemetry data sent to New Relic is expected to be associated with a resource so that it can be linked with the appropriate entity in New Relic. The OpenTelemetry Resource SDK specification defines the functionality implemented by all language SDKs for defining a resource. The following suites of attributes are defined by the OpenTelemetry resource semantic conventions. These attributes are usually set by creating a resource using the OpenTelemetry SDK. service.* attributes service.name attribute is required to associate your resource with an entity in the UI service.instance.id is required for certain panes to light up telemetry.sdk.language=java is required to see data in the JVM section Batching Caution Avoid getting rate limited! You should batch requests sent to the OTLP endpoint as described in this section. By default, the OpenTelemetry SDKs and Collector send one (1) data point per request. Using these defaults, it is likely your account will be rate limited. All OpenTelemetry SDKs and Collectors provide a BatchProcessor, which batches data points in memory. This batching allows requests to be sent with more than one (1) data point. Component Batch Processor Collector Batch Processor Go SDK BatchSpanProcessor JS SDK BatchSpanProcessor Python SDK BatchExportSpanProcessor Compression New Relic supports gzip compression for OTLP payloads exported over gRPC. To maximize the amount of data you can send per request, we recommend enabling compression in all OTLP exporters. If there are other compression formats you'd like to see us support, please let us know in the CNCF Slack channel. Traces Familiarize yourself with these trace topics to ensure your traces and spans appear in New Relic. Required fields The startTimeUnixNano and endTimeUnixNano fields on spans are required according to the OpenTelemetry protocol for trace data. When startTimeUnixNano is not present, the span is dropped and a NrIntegrationError is created. When endTimeUnixNano is not present, the duration of your span is large and negative. The timeUnixNano field on span events is required. When timeUnixNano is not present, the span event is dropped and a NrIntegrationError is created. The traceId and spanId fields on spans are required according to the OpenTelemetry protocol for trace data. When traceId or spanId are not present, the span is dropped and a NrIntegrationError is created. Sampling Trace data is the most mature OpenTelemetry data type. Because of this, New Relic's OpenTelemetry user experience is largely based on trace data and is therefore influenced by your sampling strategy. You can configure sampling in a number of places: Service: Use the OpenTelemetry SDK for your language. Collector: If you're running your own instance of the OpenTelemetry collector, you can configure it to do more sophisticated forms of sampling, such as tail-based sampling (see below). Check out this documentation about how to configure different types of sampling: OpenTelemetry built-in samplers Built-in samplers implemented by the OpenTelemetry SDK for each language. OpenTelemetry tail-based samplers The OpenTelemetry collector has a tail-based sampling processor. We have an example demonstrating the use of the tail-based sampling processor. New Relic tail-based sampling with Infinite Tracing Infinite Tracing is New Relic's tail-based sampling option. You can use this in conjunction with your OpenTelemetry instrumented services. In setting up Infinite Tracing, you need to override the default span endpoint and send telemetry data to the New Relic trace observer: Important Currently, Infinite Tracing does not support OTLP ingest. You must run your own instance of the OpenTelemetry Collector and configure it to use the New Relic exporter. Follow the steps in Set up the trace observer to get the value for YOUR_TRACE_OBSERVER_URL. Use the value of YOUR_TRACE_OBSERVER_URL to configure your integration. Since you want New Relic to analyze all your traces, make sure to verify that your OpenTelemetry integrations use the AlwaysOn sampler. Metrics OpenTelemetry metrics are largely compatible with New Relic dimensional metrics. We support OpenTelemetry metrics v0.10. All of the supported metric types include an independent set of associated attributes (name-value pairs) which map directly to dimensions you can use to facet or filter metric data at query time. OpenTelemetry metrics are accompanied by a set of resource attributes that identify the originating entity that produced them and map to dimensions for faceting and filtering. The OpenTelemetry data model for metrics defines a number of different metric types: sum, gauge, histogram, and summary. Sum metrics OpenTelemetry sums are a scalar metric that is the sum of all data points over a given time window. Sums have a notion of temporality indicating whether reported values incorporate previous measurements (cumulative temporality) or not (delta temporality). In addition, sums can either be monotonic (only go up or only go down) or non-monotonic (go up and down). Delta sums In New Relic, delta metrics are handled differently depending on whether they are monotonic or non-monotonic: Monotonic delta sums are mapped to the count metric type. Non-monotonic delta sums are mapped to the gauge metric type. Cumulative sums Monotonic and non-monotonic cumulative sums are mapped to the New Relic gauge metric type. Sum configuration examples To understand how to configure aggregation temporality, see these examples using the Java and Go OpenTelemetry SDKs. Gauge metrics OpenTelemetry gauge metric data points represent a sampled value at a given time. These values are converted to the New Relic gauge metric type. OpenTelemetry gauges do not have an aggregation temporality, but the sampled values can be aggregated at query time. Histogram metrics OpenTelemetry histograms compactly represent a population of recorded values along with a total count and sum. Optionally, histograms may include a series of buckets with explicit bounds and a count value for that bucket’s population. OpenTelemetry histograms are converted to New Relic’s distribution metric type, which is backed by a scaled exponential base 2 histogram (see NrSketch for a more thorough explanation). Counts from OpenTelemetry histogram buckets are assigned to New Relic’s distribution metric buckets using linear interpolation. Also, OpenTelemetry has negative and positive infinity bound buckets which we represent in New Relic as zero-width buckets. We do this because we do not have a representation for negative and positive infinity. For example, an OpenTelemetry bucket with bounds [-∞, 10) will be represented by a [10,10) zero width New Relic bucket. You may see exaggerated bucket counts at the endpoints of your distribution due to this translation. Summary metrics OpenTelemetry summary metric data points are used to represent quantile summaries (for example, P99 latency). These map directly to the New Relic summary metric type. Summary metric data points include count, sum, and quantile values, with 0.0 as min and 1.0 as max. OpenTelemetry provides summary metrics for compatibility with other formats. Start time The startTimeUnixNano field is optional according to the OpenTelemetry specification. When this field is provided, it is used for the timestamp on the resulting NewRelic metric, and the duration is calculated as timeUnixNano - startTimeUnixNano. The duration field is used to calculate the queryable endTimeStamp attribute on the New Relic metric, but it serves no other semantic purpose. If startTimeUnixNano is not provided, then timeUnixNano is used for the timestamp field on the resulting NewRelic metric, and the duration field is set to zero. Array values for attributes OpenTelemetry metrics and other signals may include attributes that consist of a homogenous array of primitive types. These attributes are not supported by New Relic. Exemplars OpenTelemetry defines exemplar values that allow other signals, like traces, to be connected to a metric event and provide context. Exemplars are not supported by New Relic. How to query metrics Consider these tips for building metric NRQL queries in New Relic. Query cumulative sums stored as gauges Since cumulative sums are converted to gauges, here are some ways to query your data: Example: Raw gauge value for cumulative sums To view the raw gauge value for cumulative sums, you can use the latest() NRQL function: SELECT latest(totalApiBytesSent) FROM Metric TIMESERIES FACET description, statusCode Copy Example: Rate of change with cumulative sums as gauges To see the rate of change over a given time interval for a cumulative sum stored as a gauge, you can use the derivative() NRQL function: SELECT derivative(totalApiBytesSent, 1 second) FROM Metric TIMESERIES 5 MINUTES SLIDE BY 1 MINUTE FACET description, statusCode Copy New Relic does not currently support either reporting on resets and gaps or accounting for them with cumulative counters. Query gauge metrics When New Relic converts cumulative sums to gauges, you can query them using either the latest() or derivative() NRQL functions. The function you choose depends on whether you want to see the raw value or compute the rate of change. Query histogram metrics New Relic histograms translated from OpenTelemetry metrics have the same query semantics as other New Relic histograms. Namely, the histogram() NRQL function can be used to represent the histogram with a configurable number of buckets and bucket width. Note that you may see larger bucket counts at the endpoint buckets. This is because we are adding negative and positive infinity bound OpenTelemetry buckets into a zero width New Relic bucket. Example: Normal distribution FROM Metric SELECT histogram(test.histogram, buckets: 100, width: 1000) WHERE distributionType = 'Normal Distribution' SINCE 1 day ago Copy Example: Heat map The FACET keyword is also available to create heat map charts. FROM Metric SELECT histogram(test.histogram, buckets: 100, width: 1000) FACET distributionType SINCE 1 day ago Copy Important The TIMESERIES keyword is not supported for New Relic histograms. Logs Logs generated from your applications and environment are an important piece of telemetry. They may represent application logs, machine generated events, or system logs. OpenTelemetry has defined a log data model for representing log data. You can send logs using OpenTelemetry tooling, correlate them with applications, and view them in New Relic. Send logs to New Relic The OpenTelemetry Collector and OpenTelemetry Collector Contrib repositories contain a number of components for consuming log data. The general pattern is to configure the collector to: Receive logs from any of the log receivers. Some of the receiver options include Filelog Receiver, Fluent Forward Receiver, and Syslog Receiver. Process logs, potentially annotating them with resource information. Some of the processor options include Resource Detection Processor and Resource Processor. Export logs to New Relic via the OTLP exporter. Application log correlation Application logs are more useful if they're correlated with other telemetry data produced by the application. The OpenTelemetry semantic convention for services specifies service.name as a required field. All application metric, trace, and log data sent to New Relic with the same service.name are associated with the same entity. The specifics of how logs get annotated with the service.name resource attribute depends on the application's environment: Applications may produce structured JSON logs, which you can configure to include service.name as another field. You can deploy applications alongside a dedicated Collector Agent instance, which you can configure with a Resource Processor to annotate logs with the service.name attribute. Optionally, additional application trace context (sometimes called execution context) can be propagated to log messages. The setup and availability of this depends on the language and logging framework used by the application. The general strategy is to set up the application to write structured JSON logs and to configure it to extract trace context into specified trace context fields on available log messages. The Logs in Context with Log4j2 example in GitHub demonstrates an end-to-end working example for a simple Java application using Log4j2. View OpenTelemetry logs Here are two ways you can view logs: Look in the New Relic Logs UI. If your logs are correlated with an application, view them in the context of the application. The time field The timeUnixNano field is optional according to the OpenTelemetry specification for log data. When timeUnixNano is not present New Relic will use the time that the data was received for the New Relic log timestamp.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 223.37344,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Best practices for <em>OpenTelemetry</em> with New Relic",
        "sections": "Best practices for <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " of YOUR_TRACE_OBSERVER_URL to configure your integration. Since you want New Relic to analyze all your traces, make sure to verify that your <em>OpenTelemetry</em> <em>integrations</em> use the AlwaysOn sampler. Metrics <em>OpenTelemetry</em> metrics are largely compatible with New Relic dimensional metrics. We support <em>OpenTelemetry</em>"
      },
      "id": "617d77ec28ccbc08677ff6b5"
    }
  ],
  "/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-troubleshooting": [
    {
      "sections": [
        "Introduction to OpenTelemetry with New Relic",
        "Benefits of OpenTelemetry",
        "Should I use OpenTelemetry instrumentation or New Relic agents?",
        "OpenTelemetry: A work in progress",
        "New Relic's APM agents",
        "How OpenTelemetry works with New Relic",
        "Important",
        "Traces",
        "Metrics",
        "Logs",
        "Next steps"
      ],
      "title": "Introduction to OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "67818451ffb7594e3c27526f4082bd1bc007bc51",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/introduction-opentelemetry-new-relic/",
      "published_at": "2021-12-30T03:36:05Z",
      "updated_at": "2021-12-20T05:36:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Are you already familiar with OpenTelemetry and want to begin the setup? Check out our quick start: Quick start If you don't have one already, create a New Relic account. It's free, forever. If you're just getting acquainted with OpenTelemetry, this is what we'll explore here: Benefits of OpenTelemetry Should I use OpenTelemetry or New Relic agents? How OpenTelemetry works with New Relic Benefits of OpenTelemetry OpenTelemetry provides a secure, vendor-neutral specification for service instrumentation so that you can export data to distinct backends of your choice, such as New Relic. OpenTelemetry offers a single set of APIs and libraries that standardize how you collect and transfer telemetry data for your services. The following components make up the OpenTelemetry project: Specifications for the core pillars of observability to drive consistency across all projects. New Relic supports all of these signals: traces, metrics, and logs (see details below) APIs that contain interfaces and implementations based on the specifications SDKs (reference implementations of the APIs) created specifically for languages like Java, Python, Go, Erlang, and more Collectors that offer a vendor-agnostic implementation for processing and exporting Exporters that enable you to send data to a backend of your choice The components of OpenTelemetry work together to create some distinct advantages for capturing telemetry data: Feature Description Ubiquitous instrumentation A single, open standard of instrumentation provides better coverage and flexibility as engineers from all over the world contribute to the instrumentation. Future proof As the instrumentation gets built into libraries and frameworks, and as more vendors move to support this open standard, you can be confident that you won’t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build integrations into OpenTelemetry or add instrumentation directly to source code, ensuring end users can easily monitor these new technologies. Simplified choice You don’t need to decide which instrumentation option to use (a proprietary option or one of the other open standards). Cross-platform compatibility OpenTelemetry supports a variety of languages and backends. It represents a vendor-neutral path for capturing and transmitting telemetry to backends without altering existing instrumentation. Streamlined observability It is easier for vendors to support and test against a single standard as they don’t need to develop their own agents or collectors. High dimensionality OpenTelemetry uses dimensional metrics, so you can filter and facet on more aspects of the data, such as AWS regions, Kubernetes clusters, or service versions. Dimensional metrics also lead to less time between occurrence and reporting. Should I use OpenTelemetry instrumentation or New Relic agents? As you consider OpenTelemetry, you may also be looking at New Relic APM agents that also capture telemetry data. As you'd expect, there is a lot of overlap between features available from OpenTelemetry agents and SDKs versus those available from New Relic APM agents. This is especially true if you're interested in distributed tracing telemetry data. The choice you make depends on what you need. We recommend that you explore both New Relic and OpenTelemetry instrumentation or discuss this with us in our CNCF Slack channel to decide what works best for you. OpenTelemetry: A work in progress OpenTelemetry is still an emerging standard, so your choices may be affected by what's available. You can check on the current state of the specification at the OpenTelemetry site. The current state of language-specific OpenTelemetry APIs and SDKs varies: some languages are still pre-alpha and may be missing instructions on how to instrument your service. Most languages have some implementation of traces that is sufficient to start exporting data to New Relic. Check out this table in GitHub that provides an overview of the state of OpenTelemetry specification compliance for each language. For languages that New Relic does not currently provide an agent or SDK, OpenTelemetry may offer you a good alternative. Also, in cases where you want explicit control over sampling of your telemetry data, OpenTelemetry provides a lot of flexibility. As OpenTelemetry matures, New Relic will continue to support new OpenTelemetry data models and to provide a curated UI experience for our customers. New Relic's APM agents In general, New Relic's APM agents will collect more telemetry data for your services, and they offer a wide range of configuration options and an extensive set of auto-instrumentation capabilities. New Relic's APM agents offer detailed transaction trace visibility for individual services. They also offer predefined sampling to balance the performance impact of your instrumentation against the need to capture enough data to gain helpful insights. How OpenTelemetry works with New Relic New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemetry community to export your data to New Relic. The following tables show the supported features for each telemetry signal. If you have questions about these or have an unsupported use case, please contact us in our CNCF Slack channel, and watch this page for future updates. Important New Relic's exporters for OpenTelemetry are now deprecated in favor of exporting data to New Relic using OTLP. Traces New Relic offers support for the OTLP ingest of trace signals. The maturity of the upstream specification is stable. OpenTelemetry traces and spans are compatible with New Relic traces and spans. OpenTelemetry spans optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter span data at query time. OpenTelemetry span metadata (for example, name, kind, and trace_id) also map directly to dimensions on NewRelic spans. At this time, New Relic does not support span links or array attributes. For details, see the Traces section of our best practices guide. Feature Supported Span events ✅ Span linking ❌ Array of primitives (homogeneous) ❌ Metrics New Relic offers support for the OTLP ingest of metric signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. Here are the OpenTelemetry data types we support and their associated mappings. For details, see the Metrics section of our best practices guide. Metric Type Supported Delta sums ✅ Cumulative sums ✅ Gauges ✅ Delta histograms ✅ Summary ✅ Cumulative histograms ❌ Exemplars ❌ Array of primitives (homogeneous) ❌ Logs New Relic offers support for the OTLP ingest of log signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. OpenTelemetry logs are compatible with New Relic logs. OpenTelemetry logs optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter log data at query time. OpenTelemetry log metadata (for example, name, severity_text, and trace_id) also map directly to dimensions on New Relic logs. NewRelic currently supports all OpenTelemetry log message types except for arrays. For more details, see the Logs section of our best practices guide. Feature Supported Description LogRecord body ✅ Supported types: string, boolean, int, double, bytes LogRecord attributes ✅ Supported types: string, boolean, int, double, bytes LogRecord fields ✅ Examples: name, severity_text, trace_id Array messages ❌ Array attributes ❌ Next steps Follow the OpenTelemetry quick start to help you get started. You'll also want to review the best practices guide for getting the most out of the data you export to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 285.72983,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "sections": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " won’t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build <em>integrations</em> into <em>OpenTelemetry</em> or add instrumentation directly to <em>source</em> code, ensuring end users can easily monitor these new technologies. Simplified choice You don’t need"
      },
      "id": "6174afe1e7b9d2748213b3a6"
    },
    {
      "sections": [
        "OpenTelemetry quick start",
        "Step 1. Prerequisites",
        "Step 2. Instrument your service with OpenTelemetry",
        "Step 3. Export your telemetry data to New Relic",
        "Review New Relic settings for exports",
        "Important",
        "Complete the export configuration steps",
        "Export data to an OpenTelemetry Collector (optional)",
        "Step 4. View your data in the New Relic UI",
        "View our OpenTelemetry examples",
        "What's next?"
      ],
      "title": "OpenTelemetry quick start",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "067b2e00bd167f4d78a1398575acd6f3ac76e069",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-quick-start/",
      "published_at": "2021-12-30T03:36:45Z",
      "updated_at": "2021-12-04T16:46:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "OpenTelemetry is a flexible toolkit that you can implement in a variety of ways. We recommend a basic four-step approach for setting up OpenTelemetry with New Relic. Here's an overview of the process, followed by details for each step. Prerequisites Instrument your service with OpenTelemetry Export your telemetry data to New Relic View your data in the New Relic UI Step 1. Prerequisites First things first: If we don’t already know you, sign up for a free New Relic account. Copy your account license key. Step 2. Instrument your service with OpenTelemetry To get started, you instrument your service with OpenTelemetry. OpenTelemetry has language-specific products and SDKs to help you. Many languages offer out-the-box instrumentation for common libraries and frameworks. Each language also provides an API for further instrumenting your service manually. Go to the repository for your language and follow the instructions to instrument your service. When you're done, return here to complete Step 3. Export your telemetry data to New Relic. C++ Erlang Go Java Javascript/Node.js .NET PHP Python Ruby Rust Swift ...See a complete list of languages in GitHub Step 3. Export your telemetry data to New Relic The OpenTelemetry Protocol, or OTLP for short, is a general purpose telemetry data delivery protocol designed for the OpenTelemetry project. This protocol describes how to encode and transmit telemetry data, which makes it a natural choice for data transport. Each language SDK provides an OTLP exporter you can configure to export data over OTLP. In this step, we focus on how to configure an OTLP exporter in your service to export data directly to New Relic. If you prefer to export your data first to an OpenTelemetry collector, we have separate instructions. Here's an example of sending data from your service directly to New Relic. To complete this third step, first familiarize yourself with some required New Relic settings, and then complete the steps in the OTLP exporter documentation for your language. Review New Relic settings for exports Before you go to the external OTLP exporter documentation, consult the table below so you're ready to do the following: Configure the OTLP exporter to add a header (api-key) whose value is the license key for the New Relic account you want to send data to. Based on your region, configure the endpoint where the exporter sends data to New Relic. Region gRPC HTTP/1.1 Endpoint API header name API header value TLS encryption required US ✅ ❌ https://otlp.nr-data.net:4317 api-key License key ✅ EU ✅ ❌ https://otlp.eu01.nr-data.net:4317 api-key License key ✅ Important If you have FedRamp compliance constraints, you will need to use https://gov-otlp.nr-data.net:4317. Please see FedRAMP-compliant endpoints for further information. Important In Node.js, the opentelemetry-collector-grpc library requires additional options to enable TLS. Complete the export configuration steps Click on the link below for your language and complete the configuration steps. When you're done, return here to complete Step 4. View your data in the New Relic UI. C++ Erlang Go Java Javascript/Node.js .NET PHP Python Ruby Rust Swift ...Find additional OTLP language support in GitHub Export data to an OpenTelemetry Collector (optional) The OpenTelemetry Collector is a configurable and extensible software component to receive, process, and export telemetry data. When you set up a collector, it can operate as a gateway or as an agent: Gateway: The collector receives data from a variety of sources and applies standard processing before exporting to some backend. Agent: The collector is deployed on each host in an environment and can collect telemetry data about the host and processes running on it. When you use a collector, you start by following the same routine as above for setting up OTLP in your service. In this case, instead of exporting data directly to New Relic, you export through a collector that you set up. In the collector, you configure the OTLP exporter to export data to New Relic. When your data goes through a collector, the transport looks like this: Here's a Docker example of how to set up and run an OpenTelemetry collector with the collector YAML: Save the following as otel-config.yaml: receivers: otlp: protocols: grpc: http: processors: batch: exporters: otlp: endpoint: ${OTEL_EXPORTER_OTLP_ENDPOINT} headers: api-key: ${NEW_RELIC_LICENSE_KEY} service: pipelines: traces: receivers: [otlp] processors: [batch] exporters: [otlp] metrics: receivers: [otlp] processors: [batch] exporters: [otlp] logs: receivers: [otlp] processors: [batch] exporters: [otlp] Copy Run the OpenTelemetry collector, making sure you replace OTLP_ENDPOINT_HERE with the appropriate endpoint and replace YOUR_KEY_HERE with your account's license key: export OTEL_EXPORTER_OTLP_ENDPOINT=OTLP_ENDPOINT_HERE export NEW_RELIC_LICENSE_KEY=YOUR_KEY_HERE docker run --rm \\ -e OTEL_EXPORTER_OTLP_ENDPOINT \\ -e NEW_RELIC_LICENSE_KEY \\ -p 4317:4317 \\ -v \"${PWD}/otel-config.yaml\":/otel-config.yaml \\ --config otel-config.yaml \\ --name otelcol \\ otel/opentelemetry-collector Copy Step 4. View your data in the New Relic UI Once you’ve instrumented your service and configured it to export its data to New Relic, watch the New Relic One user interface for your traces, metrics, and logs! The UI for OpenTelemetry has some similarities to the APM agent UI, so if you are familiar with that, you can go right to the UI. If you need help understanding your OpenTelemetry UI options or how to make sure your data appears in the UI, see View your OpenTelemetry data in New Relic. View our OpenTelemetry examples View some of our examples for using OpenTelemetry with New Relic. What's next? After you do your initial setup, check out our best-practices guide for tips about various configurations to improve your use of OpenTelemetry and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 243.45435,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>OpenTelemetry</em> quick start",
        "sections": "<em>OpenTelemetry</em> quick start",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": "<em>OpenTelemetry</em> is a flexible toolkit that you can implement in a variety of ways. We recommend a basic four-step approach for setting up <em>OpenTelemetry</em> with New Relic. Here&#x27;s an overview of the process, followed by details for each step. Prerequisites Instrument your service with <em>OpenTelemetry</em> Export"
      },
      "id": "617dca7464441f8186fbc951"
    },
    {
      "sections": [
        "Best practices for OpenTelemetry with New Relic",
        "Tip",
        "Resources",
        "Batching",
        "Caution",
        "Compression",
        "Traces",
        "Required fields",
        "Sampling",
        "OpenTelemetry built-in samplers",
        "OpenTelemetry tail-based samplers",
        "New Relic tail-based sampling with Infinite Tracing",
        "Important",
        "Metrics",
        "Sum metrics",
        "Delta sums",
        "Cumulative sums",
        "Sum configuration examples",
        "Gauge metrics",
        "Histogram metrics",
        "Summary metrics",
        "Start time",
        "Array values for attributes",
        "Exemplars",
        "How to query metrics",
        "Query cumulative sums stored as gauges",
        "Example: Raw gauge value for cumulative sums",
        "Example: Rate of change with cumulative sums as gauges",
        "Query gauge metrics",
        "Query histogram metrics",
        "Example: Normal distribution",
        "Example: Heat map",
        "Logs",
        "Send logs to New Relic",
        "Application log correlation",
        "View OpenTelemetry logs",
        "The time field"
      ],
      "title": "Best practices for OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "b26055149cf57bdca8f27ae00d3ac93f75e4cc86",
      "image": "https://docs.newrelic.com/static/38ea1bb698187129fb2d8d38ea2dcde8/c1b63/sum-derivative-function.png",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-concepts/",
      "published_at": "2021-12-30T03:36:45Z",
      "updated_at": "2021-11-13T14:55:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are some best practices based on how OpenTelemetry works with New Relic: Resources Batching Compression Traces Metrics Logs Tip For information about resolving specific issues, see our troubleshooting guide. Resources A resource in OpenTelemetry represents information about an entity generating telemetry data. All telemetry data sent to New Relic is expected to be associated with a resource so that it can be linked with the appropriate entity in New Relic. The OpenTelemetry Resource SDK specification defines the functionality implemented by all language SDKs for defining a resource. The following suites of attributes are defined by the OpenTelemetry resource semantic conventions. These attributes are usually set by creating a resource using the OpenTelemetry SDK. service.* attributes service.name attribute is required to associate your resource with an entity in the UI service.instance.id is required for certain panes to light up telemetry.sdk.language=java is required to see data in the JVM section Batching Caution Avoid getting rate limited! You should batch requests sent to the OTLP endpoint as described in this section. By default, the OpenTelemetry SDKs and Collector send one (1) data point per request. Using these defaults, it is likely your account will be rate limited. All OpenTelemetry SDKs and Collectors provide a BatchProcessor, which batches data points in memory. This batching allows requests to be sent with more than one (1) data point. Component Batch Processor Collector Batch Processor Go SDK BatchSpanProcessor JS SDK BatchSpanProcessor Python SDK BatchExportSpanProcessor Compression New Relic supports gzip compression for OTLP payloads exported over gRPC. To maximize the amount of data you can send per request, we recommend enabling compression in all OTLP exporters. If there are other compression formats you'd like to see us support, please let us know in the CNCF Slack channel. Traces Familiarize yourself with these trace topics to ensure your traces and spans appear in New Relic. Required fields The startTimeUnixNano and endTimeUnixNano fields on spans are required according to the OpenTelemetry protocol for trace data. When startTimeUnixNano is not present, the span is dropped and a NrIntegrationError is created. When endTimeUnixNano is not present, the duration of your span is large and negative. The timeUnixNano field on span events is required. When timeUnixNano is not present, the span event is dropped and a NrIntegrationError is created. The traceId and spanId fields on spans are required according to the OpenTelemetry protocol for trace data. When traceId or spanId are not present, the span is dropped and a NrIntegrationError is created. Sampling Trace data is the most mature OpenTelemetry data type. Because of this, New Relic's OpenTelemetry user experience is largely based on trace data and is therefore influenced by your sampling strategy. You can configure sampling in a number of places: Service: Use the OpenTelemetry SDK for your language. Collector: If you're running your own instance of the OpenTelemetry collector, you can configure it to do more sophisticated forms of sampling, such as tail-based sampling (see below). Check out this documentation about how to configure different types of sampling: OpenTelemetry built-in samplers Built-in samplers implemented by the OpenTelemetry SDK for each language. OpenTelemetry tail-based samplers The OpenTelemetry collector has a tail-based sampling processor. We have an example demonstrating the use of the tail-based sampling processor. New Relic tail-based sampling with Infinite Tracing Infinite Tracing is New Relic's tail-based sampling option. You can use this in conjunction with your OpenTelemetry instrumented services. In setting up Infinite Tracing, you need to override the default span endpoint and send telemetry data to the New Relic trace observer: Important Currently, Infinite Tracing does not support OTLP ingest. You must run your own instance of the OpenTelemetry Collector and configure it to use the New Relic exporter. Follow the steps in Set up the trace observer to get the value for YOUR_TRACE_OBSERVER_URL. Use the value of YOUR_TRACE_OBSERVER_URL to configure your integration. Since you want New Relic to analyze all your traces, make sure to verify that your OpenTelemetry integrations use the AlwaysOn sampler. Metrics OpenTelemetry metrics are largely compatible with New Relic dimensional metrics. We support OpenTelemetry metrics v0.10. All of the supported metric types include an independent set of associated attributes (name-value pairs) which map directly to dimensions you can use to facet or filter metric data at query time. OpenTelemetry metrics are accompanied by a set of resource attributes that identify the originating entity that produced them and map to dimensions for faceting and filtering. The OpenTelemetry data model for metrics defines a number of different metric types: sum, gauge, histogram, and summary. Sum metrics OpenTelemetry sums are a scalar metric that is the sum of all data points over a given time window. Sums have a notion of temporality indicating whether reported values incorporate previous measurements (cumulative temporality) or not (delta temporality). In addition, sums can either be monotonic (only go up or only go down) or non-monotonic (go up and down). Delta sums In New Relic, delta metrics are handled differently depending on whether they are monotonic or non-monotonic: Monotonic delta sums are mapped to the count metric type. Non-monotonic delta sums are mapped to the gauge metric type. Cumulative sums Monotonic and non-monotonic cumulative sums are mapped to the New Relic gauge metric type. Sum configuration examples To understand how to configure aggregation temporality, see these examples using the Java and Go OpenTelemetry SDKs. Gauge metrics OpenTelemetry gauge metric data points represent a sampled value at a given time. These values are converted to the New Relic gauge metric type. OpenTelemetry gauges do not have an aggregation temporality, but the sampled values can be aggregated at query time. Histogram metrics OpenTelemetry histograms compactly represent a population of recorded values along with a total count and sum. Optionally, histograms may include a series of buckets with explicit bounds and a count value for that bucket’s population. OpenTelemetry histograms are converted to New Relic’s distribution metric type, which is backed by a scaled exponential base 2 histogram (see NrSketch for a more thorough explanation). Counts from OpenTelemetry histogram buckets are assigned to New Relic’s distribution metric buckets using linear interpolation. Also, OpenTelemetry has negative and positive infinity bound buckets which we represent in New Relic as zero-width buckets. We do this because we do not have a representation for negative and positive infinity. For example, an OpenTelemetry bucket with bounds [-∞, 10) will be represented by a [10,10) zero width New Relic bucket. You may see exaggerated bucket counts at the endpoints of your distribution due to this translation. Summary metrics OpenTelemetry summary metric data points are used to represent quantile summaries (for example, P99 latency). These map directly to the New Relic summary metric type. Summary metric data points include count, sum, and quantile values, with 0.0 as min and 1.0 as max. OpenTelemetry provides summary metrics for compatibility with other formats. Start time The startTimeUnixNano field is optional according to the OpenTelemetry specification. When this field is provided, it is used for the timestamp on the resulting NewRelic metric, and the duration is calculated as timeUnixNano - startTimeUnixNano. The duration field is used to calculate the queryable endTimeStamp attribute on the New Relic metric, but it serves no other semantic purpose. If startTimeUnixNano is not provided, then timeUnixNano is used for the timestamp field on the resulting NewRelic metric, and the duration field is set to zero. Array values for attributes OpenTelemetry metrics and other signals may include attributes that consist of a homogenous array of primitive types. These attributes are not supported by New Relic. Exemplars OpenTelemetry defines exemplar values that allow other signals, like traces, to be connected to a metric event and provide context. Exemplars are not supported by New Relic. How to query metrics Consider these tips for building metric NRQL queries in New Relic. Query cumulative sums stored as gauges Since cumulative sums are converted to gauges, here are some ways to query your data: Example: Raw gauge value for cumulative sums To view the raw gauge value for cumulative sums, you can use the latest() NRQL function: SELECT latest(totalApiBytesSent) FROM Metric TIMESERIES FACET description, statusCode Copy Example: Rate of change with cumulative sums as gauges To see the rate of change over a given time interval for a cumulative sum stored as a gauge, you can use the derivative() NRQL function: SELECT derivative(totalApiBytesSent, 1 second) FROM Metric TIMESERIES 5 MINUTES SLIDE BY 1 MINUTE FACET description, statusCode Copy New Relic does not currently support either reporting on resets and gaps or accounting for them with cumulative counters. Query gauge metrics When New Relic converts cumulative sums to gauges, you can query them using either the latest() or derivative() NRQL functions. The function you choose depends on whether you want to see the raw value or compute the rate of change. Query histogram metrics New Relic histograms translated from OpenTelemetry metrics have the same query semantics as other New Relic histograms. Namely, the histogram() NRQL function can be used to represent the histogram with a configurable number of buckets and bucket width. Note that you may see larger bucket counts at the endpoint buckets. This is because we are adding negative and positive infinity bound OpenTelemetry buckets into a zero width New Relic bucket. Example: Normal distribution FROM Metric SELECT histogram(test.histogram, buckets: 100, width: 1000) WHERE distributionType = 'Normal Distribution' SINCE 1 day ago Copy Example: Heat map The FACET keyword is also available to create heat map charts. FROM Metric SELECT histogram(test.histogram, buckets: 100, width: 1000) FACET distributionType SINCE 1 day ago Copy Important The TIMESERIES keyword is not supported for New Relic histograms. Logs Logs generated from your applications and environment are an important piece of telemetry. They may represent application logs, machine generated events, or system logs. OpenTelemetry has defined a log data model for representing log data. You can send logs using OpenTelemetry tooling, correlate them with applications, and view them in New Relic. Send logs to New Relic The OpenTelemetry Collector and OpenTelemetry Collector Contrib repositories contain a number of components for consuming log data. The general pattern is to configure the collector to: Receive logs from any of the log receivers. Some of the receiver options include Filelog Receiver, Fluent Forward Receiver, and Syslog Receiver. Process logs, potentially annotating them with resource information. Some of the processor options include Resource Detection Processor and Resource Processor. Export logs to New Relic via the OTLP exporter. Application log correlation Application logs are more useful if they're correlated with other telemetry data produced by the application. The OpenTelemetry semantic convention for services specifies service.name as a required field. All application metric, trace, and log data sent to New Relic with the same service.name are associated with the same entity. The specifics of how logs get annotated with the service.name resource attribute depends on the application's environment: Applications may produce structured JSON logs, which you can configure to include service.name as another field. You can deploy applications alongside a dedicated Collector Agent instance, which you can configure with a Resource Processor to annotate logs with the service.name attribute. Optionally, additional application trace context (sometimes called execution context) can be propagated to log messages. The setup and availability of this depends on the language and logging framework used by the application. The general strategy is to set up the application to write structured JSON logs and to configure it to extract trace context into specified trace context fields on available log messages. The Logs in Context with Log4j2 example in GitHub demonstrates an end-to-end working example for a simple Java application using Log4j2. View OpenTelemetry logs Here are two ways you can view logs: Look in the New Relic Logs UI. If your logs are correlated with an application, view them in the context of the application. The time field The timeUnixNano field is optional according to the OpenTelemetry specification for log data. When timeUnixNano is not present New Relic will use the time that the data was received for the New Relic log timestamp.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 223.37344,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Best practices for <em>OpenTelemetry</em> with New Relic",
        "sections": "Best practices for <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " of YOUR_TRACE_OBSERVER_URL to configure your integration. Since you want New Relic to analyze all your traces, make sure to verify that your <em>OpenTelemetry</em> <em>integrations</em> use the AlwaysOn sampler. Metrics <em>OpenTelemetry</em> metrics are largely compatible with New Relic dimensional metrics. We support <em>OpenTelemetry</em>"
      },
      "id": "617d77ec28ccbc08677ff6b5"
    }
  ],
  "/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-opentelemetry-data-new-relic": [
    {
      "sections": [
        "Introduction to OpenTelemetry with New Relic",
        "Benefits of OpenTelemetry",
        "Should I use OpenTelemetry instrumentation or New Relic agents?",
        "OpenTelemetry: A work in progress",
        "New Relic's APM agents",
        "How OpenTelemetry works with New Relic",
        "Important",
        "Traces",
        "Metrics",
        "Logs",
        "Next steps"
      ],
      "title": "Introduction to OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "67818451ffb7594e3c27526f4082bd1bc007bc51",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/introduction-opentelemetry-new-relic/",
      "published_at": "2021-12-30T03:36:05Z",
      "updated_at": "2021-12-20T05:36:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Are you already familiar with OpenTelemetry and want to begin the setup? Check out our quick start: Quick start If you don't have one already, create a New Relic account. It's free, forever. If you're just getting acquainted with OpenTelemetry, this is what we'll explore here: Benefits of OpenTelemetry Should I use OpenTelemetry or New Relic agents? How OpenTelemetry works with New Relic Benefits of OpenTelemetry OpenTelemetry provides a secure, vendor-neutral specification for service instrumentation so that you can export data to distinct backends of your choice, such as New Relic. OpenTelemetry offers a single set of APIs and libraries that standardize how you collect and transfer telemetry data for your services. The following components make up the OpenTelemetry project: Specifications for the core pillars of observability to drive consistency across all projects. New Relic supports all of these signals: traces, metrics, and logs (see details below) APIs that contain interfaces and implementations based on the specifications SDKs (reference implementations of the APIs) created specifically for languages like Java, Python, Go, Erlang, and more Collectors that offer a vendor-agnostic implementation for processing and exporting Exporters that enable you to send data to a backend of your choice The components of OpenTelemetry work together to create some distinct advantages for capturing telemetry data: Feature Description Ubiquitous instrumentation A single, open standard of instrumentation provides better coverage and flexibility as engineers from all over the world contribute to the instrumentation. Future proof As the instrumentation gets built into libraries and frameworks, and as more vendors move to support this open standard, you can be confident that you won’t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build integrations into OpenTelemetry or add instrumentation directly to source code, ensuring end users can easily monitor these new technologies. Simplified choice You don’t need to decide which instrumentation option to use (a proprietary option or one of the other open standards). Cross-platform compatibility OpenTelemetry supports a variety of languages and backends. It represents a vendor-neutral path for capturing and transmitting telemetry to backends without altering existing instrumentation. Streamlined observability It is easier for vendors to support and test against a single standard as they don’t need to develop their own agents or collectors. High dimensionality OpenTelemetry uses dimensional metrics, so you can filter and facet on more aspects of the data, such as AWS regions, Kubernetes clusters, or service versions. Dimensional metrics also lead to less time between occurrence and reporting. Should I use OpenTelemetry instrumentation or New Relic agents? As you consider OpenTelemetry, you may also be looking at New Relic APM agents that also capture telemetry data. As you'd expect, there is a lot of overlap between features available from OpenTelemetry agents and SDKs versus those available from New Relic APM agents. This is especially true if you're interested in distributed tracing telemetry data. The choice you make depends on what you need. We recommend that you explore both New Relic and OpenTelemetry instrumentation or discuss this with us in our CNCF Slack channel to decide what works best for you. OpenTelemetry: A work in progress OpenTelemetry is still an emerging standard, so your choices may be affected by what's available. You can check on the current state of the specification at the OpenTelemetry site. The current state of language-specific OpenTelemetry APIs and SDKs varies: some languages are still pre-alpha and may be missing instructions on how to instrument your service. Most languages have some implementation of traces that is sufficient to start exporting data to New Relic. Check out this table in GitHub that provides an overview of the state of OpenTelemetry specification compliance for each language. For languages that New Relic does not currently provide an agent or SDK, OpenTelemetry may offer you a good alternative. Also, in cases where you want explicit control over sampling of your telemetry data, OpenTelemetry provides a lot of flexibility. As OpenTelemetry matures, New Relic will continue to support new OpenTelemetry data models and to provide a curated UI experience for our customers. New Relic's APM agents In general, New Relic's APM agents will collect more telemetry data for your services, and they offer a wide range of configuration options and an extensive set of auto-instrumentation capabilities. New Relic's APM agents offer detailed transaction trace visibility for individual services. They also offer predefined sampling to balance the performance impact of your instrumentation against the need to capture enough data to gain helpful insights. How OpenTelemetry works with New Relic New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemetry community to export your data to New Relic. The following tables show the supported features for each telemetry signal. If you have questions about these or have an unsupported use case, please contact us in our CNCF Slack channel, and watch this page for future updates. Important New Relic's exporters for OpenTelemetry are now deprecated in favor of exporting data to New Relic using OTLP. Traces New Relic offers support for the OTLP ingest of trace signals. The maturity of the upstream specification is stable. OpenTelemetry traces and spans are compatible with New Relic traces and spans. OpenTelemetry spans optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter span data at query time. OpenTelemetry span metadata (for example, name, kind, and trace_id) also map directly to dimensions on NewRelic spans. At this time, New Relic does not support span links or array attributes. For details, see the Traces section of our best practices guide. Feature Supported Span events ✅ Span linking ❌ Array of primitives (homogeneous) ❌ Metrics New Relic offers support for the OTLP ingest of metric signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. Here are the OpenTelemetry data types we support and their associated mappings. For details, see the Metrics section of our best practices guide. Metric Type Supported Delta sums ✅ Cumulative sums ✅ Gauges ✅ Delta histograms ✅ Summary ✅ Cumulative histograms ❌ Exemplars ❌ Array of primitives (homogeneous) ❌ Logs New Relic offers support for the OTLP ingest of log signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. OpenTelemetry logs are compatible with New Relic logs. OpenTelemetry logs optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter log data at query time. OpenTelemetry log metadata (for example, name, severity_text, and trace_id) also map directly to dimensions on New Relic logs. NewRelic currently supports all OpenTelemetry log message types except for arrays. For more details, see the Logs section of our best practices guide. Feature Supported Description LogRecord body ✅ Supported types: string, boolean, int, double, bytes LogRecord attributes ✅ Supported types: string, boolean, int, double, bytes LogRecord fields ✅ Examples: name, severity_text, trace_id Array messages ❌ Array attributes ❌ Next steps Follow the OpenTelemetry quick start to help you get started. You'll also want to review the best practices guide for getting the most out of the data you export to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 285.72977,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "sections": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " won’t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build <em>integrations</em> into <em>OpenTelemetry</em> or add instrumentation directly to <em>source</em> code, ensuring end users can easily monitor these new technologies. Simplified choice You don’t need"
      },
      "id": "6174afe1e7b9d2748213b3a6"
    },
    {
      "sections": [
        "OpenTelemetry quick start",
        "Step 1. Prerequisites",
        "Step 2. Instrument your service with OpenTelemetry",
        "Step 3. Export your telemetry data to New Relic",
        "Review New Relic settings for exports",
        "Important",
        "Complete the export configuration steps",
        "Export data to an OpenTelemetry Collector (optional)",
        "Step 4. View your data in the New Relic UI",
        "View our OpenTelemetry examples",
        "What's next?"
      ],
      "title": "OpenTelemetry quick start",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "067b2e00bd167f4d78a1398575acd6f3ac76e069",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-quick-start/",
      "published_at": "2021-12-30T03:36:45Z",
      "updated_at": "2021-12-04T16:46:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "OpenTelemetry is a flexible toolkit that you can implement in a variety of ways. We recommend a basic four-step approach for setting up OpenTelemetry with New Relic. Here's an overview of the process, followed by details for each step. Prerequisites Instrument your service with OpenTelemetry Export your telemetry data to New Relic View your data in the New Relic UI Step 1. Prerequisites First things first: If we don’t already know you, sign up for a free New Relic account. Copy your account license key. Step 2. Instrument your service with OpenTelemetry To get started, you instrument your service with OpenTelemetry. OpenTelemetry has language-specific products and SDKs to help you. Many languages offer out-the-box instrumentation for common libraries and frameworks. Each language also provides an API for further instrumenting your service manually. Go to the repository for your language and follow the instructions to instrument your service. When you're done, return here to complete Step 3. Export your telemetry data to New Relic. C++ Erlang Go Java Javascript/Node.js .NET PHP Python Ruby Rust Swift ...See a complete list of languages in GitHub Step 3. Export your telemetry data to New Relic The OpenTelemetry Protocol, or OTLP for short, is a general purpose telemetry data delivery protocol designed for the OpenTelemetry project. This protocol describes how to encode and transmit telemetry data, which makes it a natural choice for data transport. Each language SDK provides an OTLP exporter you can configure to export data over OTLP. In this step, we focus on how to configure an OTLP exporter in your service to export data directly to New Relic. If you prefer to export your data first to an OpenTelemetry collector, we have separate instructions. Here's an example of sending data from your service directly to New Relic. To complete this third step, first familiarize yourself with some required New Relic settings, and then complete the steps in the OTLP exporter documentation for your language. Review New Relic settings for exports Before you go to the external OTLP exporter documentation, consult the table below so you're ready to do the following: Configure the OTLP exporter to add a header (api-key) whose value is the license key for the New Relic account you want to send data to. Based on your region, configure the endpoint where the exporter sends data to New Relic. Region gRPC HTTP/1.1 Endpoint API header name API header value TLS encryption required US ✅ ❌ https://otlp.nr-data.net:4317 api-key License key ✅ EU ✅ ❌ https://otlp.eu01.nr-data.net:4317 api-key License key ✅ Important If you have FedRamp compliance constraints, you will need to use https://gov-otlp.nr-data.net:4317. Please see FedRAMP-compliant endpoints for further information. Important In Node.js, the opentelemetry-collector-grpc library requires additional options to enable TLS. Complete the export configuration steps Click on the link below for your language and complete the configuration steps. When you're done, return here to complete Step 4. View your data in the New Relic UI. C++ Erlang Go Java Javascript/Node.js .NET PHP Python Ruby Rust Swift ...Find additional OTLP language support in GitHub Export data to an OpenTelemetry Collector (optional) The OpenTelemetry Collector is a configurable and extensible software component to receive, process, and export telemetry data. When you set up a collector, it can operate as a gateway or as an agent: Gateway: The collector receives data from a variety of sources and applies standard processing before exporting to some backend. Agent: The collector is deployed on each host in an environment and can collect telemetry data about the host and processes running on it. When you use a collector, you start by following the same routine as above for setting up OTLP in your service. In this case, instead of exporting data directly to New Relic, you export through a collector that you set up. In the collector, you configure the OTLP exporter to export data to New Relic. When your data goes through a collector, the transport looks like this: Here's a Docker example of how to set up and run an OpenTelemetry collector with the collector YAML: Save the following as otel-config.yaml: receivers: otlp: protocols: grpc: http: processors: batch: exporters: otlp: endpoint: ${OTEL_EXPORTER_OTLP_ENDPOINT} headers: api-key: ${NEW_RELIC_LICENSE_KEY} service: pipelines: traces: receivers: [otlp] processors: [batch] exporters: [otlp] metrics: receivers: [otlp] processors: [batch] exporters: [otlp] logs: receivers: [otlp] processors: [batch] exporters: [otlp] Copy Run the OpenTelemetry collector, making sure you replace OTLP_ENDPOINT_HERE with the appropriate endpoint and replace YOUR_KEY_HERE with your account's license key: export OTEL_EXPORTER_OTLP_ENDPOINT=OTLP_ENDPOINT_HERE export NEW_RELIC_LICENSE_KEY=YOUR_KEY_HERE docker run --rm \\ -e OTEL_EXPORTER_OTLP_ENDPOINT \\ -e NEW_RELIC_LICENSE_KEY \\ -p 4317:4317 \\ -v \"${PWD}/otel-config.yaml\":/otel-config.yaml \\ --config otel-config.yaml \\ --name otelcol \\ otel/opentelemetry-collector Copy Step 4. View your data in the New Relic UI Once you’ve instrumented your service and configured it to export its data to New Relic, watch the New Relic One user interface for your traces, metrics, and logs! The UI for OpenTelemetry has some similarities to the APM agent UI, so if you are familiar with that, you can go right to the UI. If you need help understanding your OpenTelemetry UI options or how to make sure your data appears in the UI, see View your OpenTelemetry data in New Relic. View our OpenTelemetry examples View some of our examples for using OpenTelemetry with New Relic. What's next? After you do your initial setup, check out our best-practices guide for tips about various configurations to improve your use of OpenTelemetry and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 243.45433,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>OpenTelemetry</em> quick start",
        "sections": "<em>OpenTelemetry</em> quick start",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": "<em>OpenTelemetry</em> is a flexible toolkit that you can implement in a variety of ways. We recommend a basic four-step approach for setting up <em>OpenTelemetry</em> with New Relic. Here&#x27;s an overview of the process, followed by details for each step. Prerequisites Instrument your service with <em>OpenTelemetry</em> Export"
      },
      "id": "617dca7464441f8186fbc951"
    },
    {
      "sections": [
        "Troubleshooting OpenTelemetry with New Relic",
        "OpenTelemetry data sent via OTLP is not queryable",
        "Problem",
        "Solution",
        "Important",
        "OpenTelemetry entities or relationships are missing",
        "Tip"
      ],
      "title": "Troubleshooting OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "9478cc98ba9216af5ad8c74883abdf14565a21a4",
      "image": "https://docs.newrelic.com/static/93271ff8121b09ca17395fdf3f27e700/c1b63/otlp-troubleshooting-facet-query.png",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-troubleshooting/",
      "published_at": "2021-12-30T07:49:15Z",
      "updated_at": "2021-12-04T16:46:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Troubleshooting OpenTelemetry with New Relic may just be a matter of making sure you are following best practices, but sometimes you may need to take additional steps to diagnose your issues. Here are some examples of specific problems you might encounter, along with steps and tools to resolve them. OpenTelemetry data sent via OTLP is not queryable Problem You sent OpenTelemetry metrics, logs, or traces using OTLP and are unable to view the data. Before digging deeper, make sure you've checked the following: The OTLP endpoint configured matches one of our documented endpoints, is properly formatted, and includes the official default port, 4317. Sending OTLP data via port 443 is not supported at this time. Please note the specific endpoint for FedRAMP compliance, if applicable. The outbound traffic is not restricted by a firewall. Our Networks document explains domains and network blocks that you may need to explicitly allow. The client is configured to use TLS 1.2 or higher and the request includes the api-key header with a valid New Relic account (ingest) license key. Requests include valid protobuf payloads and use gRPC and HTTP/2 transport, preferably with gzip compression enabled. Sending protobuf or JSON-encoded payloads over HTTP/1.1 is not supported at this time. Client output and logs do not indicate 4xx or 5xx response codes are being returned. Solution There are number of tools you can use to validate the successful delivery of telemetry data to our platform. A good first step is to check the data management hub to facet data ingest and determine how much data is arriving from various sources. You can also use the data explorer or query builder to look for data faceted by instrumentation.provider or newrelic.source attributes: FROM Log, Metric, Span SELECT datapointcount() WHERE instrumentation.provider = 'opentelemetry' FACET instrumentation.provider, newrelic.source Copy This query should tell you whether data is arriving via OTLP. If the data you expect is not present, try removing the WHERE clause or checking for integration errors. Querying NrIntegrationError events can help you determine whether you have configuration or format issues or if you've run into our platform limits. Important The ingest limits for metrics, logs, and traces via OTLP are the same as our other data ingest API limits. Various parts of the New Relic UI rely on the presence of specific attributes to function properly. You can use the NRQL console feature in many places to check the WHERE or FACET clauses of the query for required attributes. You can also edit those clauses and re-run the query to determine whether there is data present with those attributes missing. Examples of required attributes include service.name and service.instance.id. For a more complete list of examples, see resources. OpenTelemetry entities or relationships are missing Problem You sent OpenTelemetry data from a service or infrastructure component and either the entity or its relationships are missing or incorrect. Solution OpenTelemetry entities will be synthesized based on the public rules described for the EXT-SERVICE entity type. The standard rule to match relies on the presence of the service.name dimension which follows the OpenTelemetry semantic conventions. To set the service.name with the OpenTelemetry Java SDK, include it in your resource: var resource = Resource.getDefault() .merge(Resource.builder().put(SERVICE_NAME, serviceName).build()); Copy Depending on the SDK, you may also set the service.name by declaring it in the OTEL_RESOURCE_ATTRIBUTES or OTEL_SERVICE_NAME environment variables. For Logs, you can use a structured log template to inject the service.name. Here are some log examples: Setting the service name Logs in context with Log4j2 Tip For more OpenTelemetry examples with New Relic, visit the newrelic-opentelemetry-examples repository on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 242.83429,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshooting <em>OpenTelemetry</em> with New Relic",
        "sections": "Troubleshooting <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": "Troubleshooting <em>OpenTelemetry</em> with New Relic may just be a matter of making sure you are following best practices, but sometimes you may need to take additional steps to diagnose your issues. Here are some examples of specific problems you might encounter, along with steps and tools to resolve them"
      },
      "id": "618e863f196a67bd4ce723da"
    }
  ],
  "/docs/more-integrations/open-source-telemetry-integrations/roku/roku-open-source-video-agent": [
    {
      "sections": [
        "Elixir open-source agent",
        "Tip",
        "Get started"
      ],
      "title": "Elixir open-source agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Open-source licensed agents",
        "Open-source licensed agents"
      ],
      "external_id": "a7f59fd6f610fc5dfe045ac848d15bf65541483b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/elixir/elixir-open-source-agent/",
      "published_at": "2021-12-30T03:35:57Z",
      "updated_at": "2021-10-30T22:42:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Monitor Elixir behavior with New Relic using the Elixir open-source agent. The agent: Helps you track transactions, distributed traces, and other parts of your application’s behavior Provides an overview of underlying BEAM activity Tip This agent is released as open source on GitHub. A change log is also available there for the latest updates. Get started For requirements, installation, and configuration information, see the Open Source Elixir Agent README on GitHub. Visit New Relic’s Elixir repository on GitHub for questions about installation, usage, or other topics. Report issues or bugs as an issue in the GitHub repository.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 384.4727,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Elixir <em>open</em>-<em>source</em> <em>agent</em>",
        "sections": "Elixir <em>open</em>-<em>source</em> <em>agent</em>",
        "tags": "<em>Open</em>-<em>source</em> <em>licensed</em> <em>agents</em>",
        "body": "Monitor Elixir behavior with New Relic using the Elixir <em>open</em>-<em>source</em> <em>agent</em>. The <em>agent</em>: Helps you track transactions, distributed traces, and other parts of your application’s behavior Provides an overview of underlying BEAM activity Tip This <em>agent</em> is released as <em>open</em> <em>source</em> on GitHub. A change log"
      },
      "id": "617dca4364441fd946fbc710"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Monitor your network devices with New Relic",
        "Query data with NRQL"
      ],
      "published_at": "2022-01-02T01:39:10Z",
      "title": "Collect data",
      "updated_at": "2022-01-02T01:39:10Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source APIs, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with NerdGraph Try NerdGraph and build the queries you need 25 min Monitor your network devices with New Relic Monitor your network devices with New Relic 45 min Query data with NRQL Query default data, custom events, and attributes 10 min",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 33.003864,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Collect data - any <em>source</em>",
        "body": "Through our opensource <em>agents</em> or APIs, New Relic makes it easy to collect data from any <em>source</em>. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "Generate trace log for troubleshooting (Node.js)",
        "Important",
        "Generate log files",
        "Examine log file"
      ],
      "title": "Generate trace log for troubleshooting (Node.js)",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Troubleshooting"
      ],
      "external_id": "3421d4243bcf05070a999d7bc79eab6c6f1372a0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/nodejs-agent/troubleshooting/generate-trace-log-troubleshooting-nodejs/",
      "published_at": "2021-12-31T01:39:27Z",
      "updated_at": "2021-12-31T00:07:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your New Relic Node.js agent log captures errors at the default info level. However, when troubleshooting or debugging, generate a more verbose trace log to help find and investigate problems. Important The trace log setting is a highly verbose logging level. To reduce disk space consumption, return the logging : { section's level to its original setting after testing. Generate log files To generate the detailed trace log file: Edit your newrelic.js file and change the logging section's level to trace, or if using environment variables, set the NEW_RELIC_LOG_LEVEL to trace. logging: { level: 'trace' } Copy Restart Node. Exercise your web application for about five minutes to generate sufficient logging data. After testing, change the level to a less verbose logging level, such as info (default). Open and examine the generated log file. Examine log file By default, the Node.js agent stores the log file in the current working directory as newrelic_agent.log. If the log file or folder are not visible: Check whether you have set the logging path to stdout or stderr. Verify that the current working directory is the same as the directory where you expect the log file to be located.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 29.747002,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Agents</em>",
        "body": ": &#x27;trace&#x27; } Copy Restart Node. Exercise your web application for about five minutes to generate sufficient logging data. After testing, change the level to a less verbose logging level, such as info (default). <em>Open</em> and examine the generated log file. Examine log file By default, the Node.js <em>agent</em>"
      },
      "id": "617ea562e7b9d2fd44c05078"
    }
  ],
  "/docs/nerdgraph-anomaly-detector-configurations-api-tutorial": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Monitor your network devices with New Relic",
        "Query data with NRQL"
      ],
      "published_at": "2022-01-02T01:39:10Z",
      "title": "Collect data",
      "updated_at": "2022-01-02T01:39:10Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source APIs, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with NerdGraph Try NerdGraph and build the queries you need 25 min Monitor your network devices with New Relic Monitor your network devices with New Relic 45 min Query data with NRQL Query default data, custom events, and attributes 10 min",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 338.59293,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build queries with <em>NerdGraph</em>",
        "body": " data - any source <em>APIs</em>, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with <em>NerdGraph</em> Try <em>NerdGraph</em> and build the queries"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "Introduction to New Relic NerdGraph, our GraphQL API",
        "What is NerdGraph?",
        "Important",
        "Use the GraphiQL explorer",
        "Requirements and endpoints",
        "What can you do with NerdGraph?",
        "NerdGraph terminology",
        "Tips on using the GraphiQL explorer",
        "Query accounts a New Relic user can access",
        "Query user, account, and NRQL in one request"
      ],
      "title": "Introduction to New Relic NerdGraph, our GraphQL API",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Get started"
      ],
      "external_id": "e8e96c16cd75f494ebfacb3bc53b4ee9ccf1c727",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph/",
      "published_at": "2021-12-30T03:45:24Z",
      "updated_at": "2021-12-25T06:06:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NerdGraph is our GraphQL-format API that lets you query New Relic data and configure some New Relic features. After you sign up for a free New Relic account and install any of our monitoring services, you can get started with NerdGraph. What is NerdGraph? New Relic has several APIs. NerdGraph is the API we recommend for querying New Relic data and for performing some specific configurations (learn more about features). NerdGraph provides a single API interface for returning data from New Relic’s various APIs and microservices. Over time, other configuration capabilities will be added to NerdGraph. Important NerdGraph isn’t used for data ingest. For that, you'd use our data ingest APIs. NerdGraph is built using GraphQL, which is an open source API format that allows you to request exactly the data needed, with no over-fetching or under-fetching. For a lesson in how to use NerdGraph, watch this 7-minute video: Want to watch more video tutorials? Go to the New Relic University’s Intro to NerdGraph. Or see the online course on New Relic APIs. Use the GraphiQL explorer To get started using GraphQL, we recommend playing around with our GraphiQL explorer (GraphiQL is an open source graphical interface for using GraphQL). You can use it to explore our data schema, to read built-in object definitions, and to build and execute queries. To use GraphQL, you’ll need a user-specific New Relic API key called a user key. You can generate one or find an existing one from the GraphiQL explorer’s API key dropdown. To find the GraphiQL explorer: If your New Relic account uses an EU data center, go to api.eu.newrelic.com/graphiql. Otherwise use api.newrelic.com/graphiql. For tips on how to build queries, see Build queries. Requirements and endpoints To use NerdGraph, you need a New Relic user key, which can be generated and accessed from the GraphiQL explorer. The endpoints are: Main endpoint: https://api.newrelic.com/graphql Endpoint for accounts using EU data center: https://api.eu.newrelic.com/graphql To access the endpoint, use the following cURL command: curl -X POST https://api.newrelic.com/graphql \\ -H 'Content-Type: application/json' \\ -H 'API-Key: YOUR_NEW_RELIC_USER_KEY' \\ -d '{ \"query\": \"{ requestContext { userId apiKey } }\" } ' Copy What can you do with NerdGraph? NerdGraph functionality can be broken down into two main categories: Querying New Relic data. You can fetch data for a variety of purposes, including using it in a programmatic workflow, or building a New Relic One app for custom data visualizations. Configuring New Relic features. There are a variety of configurations available and more will be added over time. You can do things like add tags, configure workloads, or customize \"golden metrics.\" You can use NerdGraph to return a wide range of New Relic data but we’ve created some tutorials for common use cases: Topic Tutorials Your monitored entities Get data about entities Understand entity relationships and dependencies (used to build service maps) Query and configure \"golden metrics\" (important entity metrics) Querying data Query using NRQL (our query language) Tags Add and manage tags APM agents APM agent configuration Dashboards Create dashboards Export dashboards to other accounts Export dashboards as files Migrate from Insights Dashboard API to NerdGraph Alerts See all alert-related tutorials Applied Intelligence View and configure topology Workloads View and configure workloads Service Levels Configure and manage Service Levels Manage keys Create and manage keys (license keys used for data ingest, and user keys) Manage data Convert event data to metric data Drop data Distributed tracing Query distributed tracing data Configure Infinite Tracing New Relic One apps Build a New Relic One app Cloud integrations (AWS, Azure, GCP) Configure cloud integrations Partners and resellers Manage subscriptions (only for partners using original pricing model) Data partitions Manage data partitions Date retention Manage data retention NerdGraph terminology The following are terms that originate with GraphQL (the API format NerdGraph uses). Term Definition Queries and mutations There are two classes of GraphQL operations: Queries are basic requests used only to fetch data. These queries are not static, meaning that you can ask for more data or less data, depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Mutations are requests that perform an action, such as creating a resource or changing configuration. Mutations require the keyword mutation, as well as the name of the mutation. Type Data in GraphQL is organized into types. Types can be scalars (like strings, numbers, or booleans) or object types. An object type is a custom type made up of a collection of fields. For example, an object type called User may represent a user in a system. Field A field represents a piece of information on an object type that can be queried. Fields can be scalars, lists, or objects. For example, a User object type could have a string field called name. Interface An interface is an abstract type that represents a collection of common fields that other object types can implement. Tips on using the GraphiQL explorer You can make queries with the NerdGraph GraphiQL explorer. The explorer provides built-in schema definitions and features, including auto-complete and query validation. Query accounts a New Relic user can access You can query for the name of an account that an actor (a New Relic authorized user) has access to: query { actor { account(id: YOUR_ACCOUNT_ID) { name } } } Copy The response will mirror the query structure you defined in the request, making it easy to ask for the specific data that you want. { \"data\": { \"actor\": { \"account\": { \"name\": \"Data Nerd\" } } } } Copy Query user, account, and NRQL in one request The graph structure shows its capabilities when queries become more complex. For example, you can query for user information, account information, and make a NRQL query with one request. With REST API, this would take three different requests to three different endpoints. query { actor { account(id: YOUR_ACCOUNT_ID) { name nrql(query: \"SELECT * FROM Transaction\") { results } } user { name id } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 246.57938,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>NerdGraph</em>, our <em>GraphQL</em> <em>API</em>",
        "sections": "Introduction to New Relic <em>NerdGraph</em>, our <em>GraphQL</em> <em>API</em>",
        "tags": "<em>APIs</em>",
        "body": "<em>NerdGraph</em> is our <em>Graph</em>QL-format <em>API</em> that lets you query New Relic data and configure some New Relic features. After you sign up for a free New Relic account and install any of our monitoring services, you can get started with <em>NerdGraph</em>. What is <em>NerdGraph</em>? New Relic has several <em>APIs</em>. <em>NerdGraph</em>"
      },
      "id": "6043ff97196a67d0a0960f55"
    },
    {
      "sections": [
        "NerdGraph tutorial: View entity data",
        "Important",
        "Entity definition",
        "Requirements",
        "Search for entities",
        "Caution",
        "Search with queryBuilder",
        "Search with freeform query",
        "Fetch entities by GUID",
        "Example queries",
        "Get entity data using queryBuilder",
        "Get data for infrastructure integration entities in search results",
        "Get alert information on alertable entities in search results",
        "Get summary data on APM entities in search results",
        "Get data specific to each entity type in search results",
        "Get all tags for each entity in search results",
        "Use tags to filter entity results",
        "Aggregate results by an attribute or a tag",
        "Get the nextCursor for paginated search results",
        "Delete entities"
      ],
      "title": "NerdGraph tutorial: View entity data",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "82cba56e3512473f842550da49290068828ede3f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-entities-api-tutorial/",
      "published_at": "2021-12-30T05:27:33Z",
      "updated_at": "2021-12-25T05:03:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With NerdGraph, you can query details about your monitored entities. Important To work with an entity's golden metrics and tags, see the golden metrics API tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes (but is not limited to): Applications monitored by APM. Cloud integrations, services, and hosts monitored by our infrastructure monitoring. To view entity details in the UI, you can use the Explorer. When working with entities in NerdGraph, it's important to keep in mind that: A unique entity GUID identifies an entity. An entity exists over a span of time, even if it's a short period. An entity provides a useful entry point for exploring data about specific metrics and events, or for contextualizing data related to other entities. Requirements To use entities, you need a user key. Search for entities New Relic searches for entities by their attributes, primarily their name, but also by type of entity and other values. The search returns basic data about entities matching the search criteria. Then, from the basic query results, you can query a specific entity by its GUID. Besides domainType, other common entity attributes are: id accountId name domainId alertSeverity reporting You can filter by any of the above attributes. Additionally, you can use tags for filtering too. Caution You cannot filter by custom, root-level entity properties. Custom properties are only retrieved as part of the entity’s metadata in the actual search response. To filter by a custom field, transform it into an entity tag. You can craft a query in one of two ways: Use the queryBuilder argument to help you craft a query. Use the freeform query argument to build your own search. To use NerdGraph to query one or more entities, you can search by attribute or GUID. In addition to the examples below, we highly recommend exploring the API using the NerdGraph GraphiQL explorer, and benefiting from its inline documentation. Search with queryBuilder The queryBuilder argument is useful to construct simple queries. It allows you to add filters to your query from a predefined list of attributes, and their typical values. For more advanced queries, use the query argument instead. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { name entityType guid } } } } } Copy Search with freeform query This is useful to craft more complex queries. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: query($query: String! ) { actor { entitySearch(query: $query) { count results { entities { name entityType guid } } } } } Copy Add the following variables to the Query variables section in NerdGraph: {\"query\": \"name LIKE 'nerd-graph' AND domainType IN ('APM-APPLICATION')\"} Copy Fetch entities by GUID When you know the GUID of the entity you want to fetch, you can just use the entity attribute: { actor { entity(guid: \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\") { name entityType } } } Copy This can also be written as a search query: { actor { entitySearch(query: \"id = 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3'\") { query results { entities { name entityType } } } } } Copy Or, to fetch multiple entities at the same time, you can use the entities attribute: { actor { entities(guids: [\"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\", \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3\"]) { name entityType } } } Copy Otherwise, use a search query: { actor { entitySearch(query: \"id in ('MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3', 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3')\") { query results { entities { name entityType } } } } } Copy Example queries Queries are requests that are intended to only fetch data (and don't have any other effect). NerdGraph queries are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it's supported by the schema. Entities in NerdGraph rely on GraphQL interfaces, a concept that allows objects to share common fields. Interfaces are used to provide data for specific entity types, as you will see in many of these NerdGraph query examples. Get entity data using queryBuilder If you aren't sure how to start crafting an entity search query, use NerdGraph to help you build one. Next, retrieve entity data and the query string that was built. Request the query field in your results to see the query string built by the queryBuilder argument. You cannot use the query and queryBuilder arguments at the same time. We highly recommend exploring the API using the NerdGraph GraphiQL explorer, and using its inline documentation to see the query options available to you. { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get data for infrastructure integration entities in search results There are many different types of Infrastructure integration entities and they are listed separately from other entity types. Use the infrastructureIntegrationType input argument to explore them. You cannot use the query and queryBuilder arguments at the same time. Use infrastructureIntegrationType in place of the type input argument. We highly recommend exploring the API using the NerdGraph GraphiQL explorer and using its inline documentation to see the query options available to you. { actor { entitySearch(queryBuilder: { infrastructureIntegrationType : F5_NODE}) { query results { entities { entityType domain } } } } } Copy Get alert information on alertable entities in search results Fetch the alert severity of any entity that can be monitored by New Relic's alerts. This NerdGraph query will tell you if we are currently receiving data from your application (using the reporting field). If the entity is an alertable type, results will include the alert severity of the entity. If the results include entities that are not alertable, they will not include the AlertableEntityOutline fields. { actor { entitySearch(query: \"name like 'nerdgraph' and alertSeverity is not null\") { results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get summary data on APM entities in search results Different entity types have specific data associated with them. The following NerdGraph query example shows a selection of fields available for APM application entities: More summary data can be requested in your query. If entities of other types are returned in your search results, they will not include these fields. { actor { entitySearch(query: \"name like 'nerdgraph' and domainType = 'APM-APPLICATION'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate apdexScore webResponseTimeAverage responseTimeAverage } } } } } } } Copy Get data specific to each entity type in search results Different entity types have specific data associated with them. This NerdGraph query example requests the name for all entities regardless of which entity type they are, as well as the error rate for APM, browser monitoring, and mobile entities. If entities of other types are returned in your search results, they will not include an error rate field. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate } } ... on BrowserApplicationEntityOutline { browserSummary { jsErrorRate } } ... on MobileApplicationEntityOutline { mobileSummary { httpErrorRate } } } } } } } Copy Get all tags for each entity in search results This NerdGraph query example fetches tags for every entity returned in the search results. For more information, see the NerdGraph GraphiQL tagging tutorial. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name tags { key values } } } } } } Copy Use tags to filter entity results This NerdGraph query example filters entities that belong to the INFRA domain and belong to awsRegion us-east-1, and returns their name in the search results. { actor { entitySearch(query: \"domain = 'INFRA' and tags.aws.awsRegion = 'us-east-1'\") { results { entities { name } } } } } Copy Additionally, filtering can be done by whether a given tag is present. The following query filters entities of the domainType BROWSER-APPLICATION and have the tag clusterAgentId defined. { actor { entitySearch(query: \"domainType = 'BROWSER-APPLICATION' and tags.clusterAgentId is not null\") { results { entities { name } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Aggregate results by an attribute or a tag This NerdGraph query example filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, and returns their name in the search results. Then aggregates results to get the total number of entities grouped by New Relic account id. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION'\") { facetedCounts(facets: {facetCriterion: {facet: ACCOUNT_ID}}) { counts { count facet } } } } } Copy Additionally, aggregation can be done by tags too; the following query filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, then aggregates results to get the total number of entities grouped by Agent language. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION' and tags.aws.awsRegion = 'us-east-1'\") { facetedCounts(facets: {facetCriterion: {tag: \"language\"}}) { counts { count facet } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Get the nextCursor for paginated search results The NerdGraph GraphiQL explorer paginates results from an entity search. If your search criteria yields more than the API limit and you want to view the rest of the results, you can request nextCursor in your initial request, and use its value in another query to retrieve the following \"page\" of results. If there are no more results, nextCursor will be null. { actor { entitySearch(query: \"name like 'nerd-graph'\") { results { nextCursor entities { name } } } } } Copy Use the value of nextCursor in your next search: { actor { entitySearch(query: \"name like 'nerd-graph'\") { results(cursor: \"next_cursor_value\") { nextCursor entities { name } } } } } Copy Delete entities You can manually delete any entity in your account by using the NerdGraph API. To do so, run this query with the entity's GUID in the NerdGraph GraphiQL explorer: mutation { entityDelete(guids: [\"EntityGuid\"]) { deletedEntities failures } } Copy Important Currently, you can only remove the following entity types using the Nerdgraph API: APM-APPLICATION, EXT-SERVICE, and REF-REPOSITORY. You may see a deleted entity in your UI if a New Relic agent reindexes it again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 245.9112,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View entity data",
        "sections": "<em>NerdGraph</em> tutorial: View entity data",
        "tags": "<em>APIs</em>",
        "body": "With <em>NerdGraph</em>, you can query details about your monitored entities. Important To work with an entity&#x27;s golden metrics and tags, see the golden metrics <em>API</em> tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes"
      },
      "id": "6044058c64441f2d4f378ed9"
    }
  ],
  "/docs/network-performance-monitoring/advanced/advanced-config": [
    {
      "sections": [
        "SNMP device profiles",
        "Get started",
        "Tip",
        "Make requests through GitHub",
        "Contribute profiles and modifications publicly",
        "What kinds of OIDs should I actually include in a profile?",
        "Use custom profiles privately"
      ],
      "title": "SNMP device profiles",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Advanced configuration"
      ],
      "external_id": "9b38a960070da5782cfd75e087db62f15fb71223",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/advanced/snmp-profiles/",
      "published_at": "2021-12-30T03:03:05Z",
      "updated_at": "2021-12-15T00:37:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Profiles define what SNMP OIDs we want to collect and send to your New Relic account. This document explains how to modify an existing profile or create a new profile. Get started If you've decided to build a custom profile or modify one of our open source profiles, you need a few essential tools: A GitHub account: This enables you to raise issues and contribute changes to Kentik's open source profiles. An SNMP walk from a network device where you want to work on a profile. For more information, see our documentation on setting up SNMP and using snmpwalk. Permissions to perform Docker pull on the server that hosts your ktranslate container. This document covers: Making requests for new or modified profiles through GitHub to be worked on by the maintainers Contributing your own profiles and modifications publicly Using custom profiles privately Tip Support for all things relating to kentik/snmp-profiles is handled through GitHub issues. New Relic technical support is not able to provide any additional help beyond redirecting you back to raise an issue there. Make requests through GitHub This is the most common and simple scenario, for cases where you don't have the time or expertise with SNMP to do these yourself. After you provide the relevant data, our team will build the profile for you. Log into GitHub and go to the snmp-profiles repo. Click the Issues tab near the top. Click New issue. To request a new profile, look for the SNMP Profile Request section, and click Get started. Provide all requested information in the template, such as the device vendor, model, snmp object identifier, and a sanitized SNMP walk. For all other requests, use Open a blank issue. Tip Providing an SNMP walk is critical as we cannot do any work on the profile without these. This is not the same as an MIB file. The maintainers of the repo will review the information you provided and, if there is anything missing, they will follow up with you. Once all the necessary data is provided, they will add it to the queue of profiles to be built. After it is added to the repo, the issue will be closed, and all you have to do is update the ktranslate docker container on your end, and the newest profiles will automatically be loaded. Contribute profiles and modifications publicly We gladly accept contributions from anyone who wants to help out to either create new profiles or improve the existing profiles. To familiarize yourself with the structure of a profile, review this highly commented template.yml on GitHub. Log into GitHub and go to the snmp-profiles repo. To create a copy of the same information in your account, click the fork button near the top. Within your fork,make necessary changes to the files, or create new vendor directories and profiles as needed. Be sure to pass your profile through a YAML validator, such as codebeautify, before submitting a pull request. When you are done with your changes, submit a pull request to the upstream repo. The maintainers will review the change, and discuss any necessary feedback. When everyone is aligned, it will be merged. Shortly after a merge, new SNMP profiles are automatically available by pulling the new version of the Docker image and launching a new container in your environment. For more information, see our documentation about SNMP manual setup. Tip Be sure to sync your fork regularly to keep it up to date with changes in the upstream repo. What kinds of OIDs should I actually include in a profile? In many cases SNMP offers a lot of data, but much of that data does not provide actionable information. Or, the data provides value that is so uncommon and low impact, it might not be worth bringing into your New Relic account. You want to focus on collecting data that lets you know if there is anything that would stop the device from being able to perform whatever functions you expect it to perform. Building on from that, you should collect measurements that tell you how well it is performing those functions. Example 1: For a device operating as a VPN concentrator, we would collect high-level system metrics like: CPU and memory utilization Hardware sensor information to make sure that the device isn't going to shut itself down due to things like fan failures OIDs that tell us about the aggregated connections and throughput Example 2: An example of data that is available but provides very poor value is an OID table that lists all the running processes on a network appliance. Coming from a server admin perspective, that might sound useful, but since this is an appliance, you normally do not have the capability or the need to do anything with the processes that run inside it. Polling and storing tables with hundreds of items that you can't actually do anything with would not be efficient. Use custom profiles privately For cases where you want to make a change to a profile, but you know that it is a scenario that is very unique and would not apply to other customers you can locally edit the profiles. The way this is done is by using Docker's volume mount to pass in your customized files to the ktranslate container inside the etc/ktranslate/profiles/ directory. There are other ways you could accomplish this but in this example we will demonstrate using a git fork and clone. Ensure you are in the directory you want to keep the files in, then clone your fork of the GitHub repo to your Docker host: git clone https://github.com/<YourGitUser>/snmp-profiles.git Copy Get the command you would normally use to launch the SNMP container, and add a second volume mount argument after the one where we passed in the snmp-base.yaml. -v `pwd`/snmp-profiles/profiles:/etc/ktranslate/profiles \\ Copy The mount command replaces the built-in profiles directory with your customized data. The end result will be be similar to this: docker run -ti --name ktranslate-discovery --rm --net=host \\ --user `id -u`:`id -g` \\ -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ -v `pwd`/snmp-profiles/profiles:/etc/ktranslate/profiles \\ kentik/ktranslate:v2 \\ -snmp /snmp-base.yaml \\ -log_level info \\ -snmp_discovery=true Copy Tip Be sure to pass your custom version of the profiles in every time you launch a discovery container or SNMP polling container. If you don't use it consistently for all SNMP instances sets, this can cause unreliable behavior.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 211.46645,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Network</em> <em>performance</em> <em>monitoring</em>",
        "body": ": A GitHub account: This enables you to raise issues and contribute changes to Kentik&#x27;s open source profiles. An SNMP walk from a <em>network</em> device where you want to work on a profile. For more information, see our documentation on setting up SNMP and using snmpwalk. Permissions to <em>perform</em> Docker pull"
      },
      "id": "61b33254196a67414ea5c67b"
    },
    {
      "sections": [
        "Managing the 'ktranslate' Docker container",
        "Container requirements",
        "Tip",
        "Updating the container",
        "Important",
        "Container runtime options"
      ],
      "title": "Managing the 'ktranslate' Docker container",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Advanced configuration",
        "ktranslate"
      ],
      "external_id": "4e9ead4f2e8850ba061754bccb3fe5eed25b8c56",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/advanced/ktranslate-container-management/",
      "published_at": "2021-12-30T03:02:29Z",
      "updated_at": "2021-12-19T05:13:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This page outlines the options for management of the ktranslate container used by New Relic NPM. Container requirements We recommend the following resources for the ktranslate container image: Disk 100MB available disk space CPU SNMP Polling/Trap Collection: 1 CPU core dedicated for every ~1,000 devices Device Flow Collection: 1 CPU core dedicated for every ~2,000 flows per second (fps) Syslog Message Collection: 1 CPU core dedicated for every ~2,000 messages per second Memory ktranslate is not generally constrained by memory resources. The amount of memory on your host should be driven by the types of applications/containers you plan to run. For a general idea, we commonly see success with image sizes as small as the AWS t2.micro which has 1 vCPU and 1.0 GB of available RAM. Tip The ktranslate container image runs a single \"job type\" at a time. For instance, a container deployed for SNMP polling and trap collection will not be used for flow collection. Furthermore, containers deployed for flow collection are limited to a single -nf.source type per container. This means that it is common to have multiple containers deployed to a single Docker host at any given time. They can also share a common configuration file, but do not have to. Updating the container Keeping the ktranslate container image up to date is good practice to both receive the latest updates and resolve common problems through various bug fixes applied during the development lifecycle. It is recommended to always pull the latest available image when redeploying your containers. Pull the latest container image available bash Copy $ docker pull kentik/ktranslate:v2 Collect the IDs and names of any existing containers bash Copy $ docker ps -a --filter ancestor=kentik/ktranslate:v2 --format \"{{.ID}} - {{.Names}}\" Output Example: 3297b134a352 - ktranslate-snmp 4962a854b386 - ktranslate-sflow Copy Remove any pre-existing containers bash Copy $ docker rm -f $CONTAINER_ID Redeploy your ktranslate container using the original settings you deployed with from either SNMP, flow data, or syslog collection. Important The configuration file used by ktranslate is applied to the container at runtime. Changes to this file require you to remove and restart your running container(s) to apply the edits. Container runtime options Below are the various options available during Docker runtime for the ktranslate container image: Option name Type Required Description -snmp Flag ✓ Sets the path to the snmp-base.yaml file on the Docker container, based on the volume mount from the Docker host passed as an option during runtime. -nr_account_id Flag ✓ The New Relic One account ID that ktranslate will ship data to. -log_level Flag Overrides the default info log level for ktranslate. The available options are debug, info, warn, or error. -snmp_discovery Flag Used to setup the container in SNMP discovery mode. -tee_logs Flag Forwards Docker logs from ktranslate into New Relic One Logs. -metrics=jchf Flag Forwards health metrics from ktranslate into New Relic One. -service_name Flag Appended to the container name in Docker logs to help isolate logs from various containers in New Relic One Logs. -nr_region Flag Sets the regional API endpoints for ktranslate to forward telemetry to New Relic One. Options are US, EU, and GOV (FedRAMP). -max_threads Flag Lets you process higher volumes of data. We recommend one CPU core available for every 2,000 flows per second (fps) of network flow data sent, or every 1,000 SNMP devices being monitored, or every 2,000 syslog messages per second collected by a container. The default is 1. -sample_rate Flag Changes the default sample rate value at which flows are passed to New Relic One Events. This does not speed up the local configuration of flow sample rate on a device, but it can slow it down. Setting this to 1 will enable capturing all flows sent to the container. The default is 1000. -nf.workers Flag Overrides the number of workers used in processing network packets. Use one worker for every 4,000 of flows per second (fps) of network flow data sent. The default is 1. -nf.port Flag Overrides the listening port for incoming flow packets. The default is 9995. -nf.source Flag ✓ (For flow containers) Sets up the type of flow this container will process. Options are ipfix, netflow5, netflow9, and sflow. -application_map Flag Sets the path to an application map file on the Docker container, based on a volume mount from the Docker host passed as an option during runtime. -dns Flag Sets the IP:Port for ktranslate to use during DNS resolution of IP addresses. Setting this affects the results for the dst_host and src_host fields. nr1.flow Argument ✓ (For flow containers) This argument statically sets the following flags: compression: gzip, sink: new_relic, format: new_relic, max_before_sample: 100, flow_only:true. nr1.snmp Argument ✓ (For SNMP containers) This argument statically sets the following options: compression: gzip, sink: new_relic, format: new_relic_metric, max_flows_per_message: 100. nr1.syslog Argument ✓ (For syslog containers) This argument statically sets the following flags: compression: gzip, sink: new_relic, format: new_relic_metric, syslog:\"0.0.0.0:5143\". NEW_RELIC_API_KEY Environment Variable ✓ Environment variable that must be used during Docker runtime to hold the New Relic license key for ktranslate to send data to the New Relic APIs. Ex: -e NEW_RELIC_API_KEY=$LICENSE_KEY. HTTPS_PROXY Environment Variable Environment variable that can be used during Docker runtime to setup ktranslate to ship data to New Relic via proxy. Ex: -e HTTPS_PROXY=https://user:password@hostname:port.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 207.15717,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Network</em> <em>performance</em> <em>monitoring</em>",
        "body": " share a common <em>configuration</em> file, but do not have to. Updating the container Keeping the ktranslate container image up to date is good practice to both receive the latest updates and resolve common problems through various bug fixes applied during the development lifecycle. It is recommended"
      },
      "id": "61b9386a28ccbc8dca96f412"
    },
    {
      "sections": [
        "Visualize your network performance data in New Relic One",
        "Prerequisites",
        "Add the Network dashboards to your account",
        "Tip",
        "Start exploring your network performance data"
      ],
      "title": "Visualize your network performance data in New Relic One",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Monitoring"
      ],
      "external_id": "a9e82cf586cd71595b0fd3bdcc831768578417cf",
      "image": "https://docs.newrelic.com/static/f6a643a55e2f9a2b070d85ab9174ba48/c1b63/flow_data_dashboard.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/monitoring-network-data/visualize-network-data/",
      "published_at": "2021-12-30T09:50:55Z",
      "updated_at": "2021-12-30T09:50:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you set up your network data for performance monitoring, you can go to New Relic One and install several custom-curated visualizations designed specifically for network performance monitoring. Then, after you set up these visualizations, you can start exploring the network data your devices are reporting to New Relic One. You can group and monitor your switches, routers, etc. in dashboards. This helps you quickly aggregate, isolate, and analyze the health of your network. For some examples of monitoring your network in New Relic One, watch this short video (approx. 3:45 minutes). Prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. Having set up your Network Performance Monitoring devices. Read how to: Set up SNMP data monitoring. Set up network flow data monitoring. Add the custom visualizations app to your account: Go to one.newrelic.com > Apps, and search for Network Agent Visualizations. Click the app, and then click Open visualization. one.newrelic.com > Apps, and search for Network Agent Visualizations. From the Account ID dropdown, select the account you want to add the visualizations to, and click Enable. Add the Network dashboards to your account You can go to New Relic One and import several dashboards to see curated views of your network telemetry, including the GeoMap and Sankey custom visualizations from the prerequisites. Go to one.newrelic.com > Apps, and search for Quickstarts. Click Quickstarts. In the search bar, search for Network, then click one of the dashboards: Use the Network - Data Ingest and Cardinality dashboard to analyze usage trends. Use the Network - Routers and Switches dashboard for SNMP data from router and switch entities. Use the Network - Flow Devices dashboard for network flow data. one.newrelic.com > Apps, and search for Network. Click Import. Select the account where you want to add the dashboard. Optional: Edit the dashboard name. Click Import dashboard. Tip If you want to read more about custom visualizations in New Relic One, see the introduction to custom visualizations. Start exploring your network performance data Once you've finished setting up these dashboards, you can start seeing your network data by going to Dashboards or Explorer in New Relic One: From one.newrelic.com > Dashboards: For usage trend analysis, you'll see the following dashboard: Dashboard for analyzing network telemetry usage trends in New Relic One. For SNMP data, you'll see the following dashboard: Dashboard for SNMP data from router and switch entities in New Relic One. For network flow data, you'll see the following dashboard: Dashboard for network flow data monitoring in New Relic One. From one.newrelic.com > Explorer: Entities are listed under the Network category in the left-hand side menu. Open a specific device to see the details and trend of its performance. On the top right-hand side, click Lookout to see anomalies. Lookout view for Network Performance Monitoring in New Relic One. To learn how to troubleshoot network data in Navigator and Lookout, watch this short video (approx. 3:15 minutes).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 195.87686,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Visualize your <em>network</em> <em>performance</em> data in New Relic One",
        "sections": "Visualize your <em>network</em> <em>performance</em> data in New Relic One",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": "After you set up your <em>network</em> data for <em>performance</em> <em>monitoring</em>, you can go to New Relic One and install several custom-curated visualizations designed specifically for <em>network</em> <em>performance</em> <em>monitoring</em>. Then, after you set up these visualizations, you can start exploring the <em>network</em> data your devices"
      },
      "id": "6127249b64441f621ea47c42"
    }
  ],
  "/docs/network-performance-monitoring/advanced/ktranslate-container-health": [
    {
      "sections": [
        "Visualize your network performance data in New Relic One",
        "Prerequisites",
        "Add the Network dashboards to your account",
        "Tip",
        "Start exploring your network performance data"
      ],
      "title": "Visualize your network performance data in New Relic One",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Monitoring"
      ],
      "external_id": "a9e82cf586cd71595b0fd3bdcc831768578417cf",
      "image": "https://docs.newrelic.com/static/f6a643a55e2f9a2b070d85ab9174ba48/c1b63/flow_data_dashboard.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/monitoring-network-data/visualize-network-data/",
      "published_at": "2021-12-30T09:50:55Z",
      "updated_at": "2021-12-30T09:50:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you set up your network data for performance monitoring, you can go to New Relic One and install several custom-curated visualizations designed specifically for network performance monitoring. Then, after you set up these visualizations, you can start exploring the network data your devices are reporting to New Relic One. You can group and monitor your switches, routers, etc. in dashboards. This helps you quickly aggregate, isolate, and analyze the health of your network. For some examples of monitoring your network in New Relic One, watch this short video (approx. 3:45 minutes). Prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. Having set up your Network Performance Monitoring devices. Read how to: Set up SNMP data monitoring. Set up network flow data monitoring. Add the custom visualizations app to your account: Go to one.newrelic.com > Apps, and search for Network Agent Visualizations. Click the app, and then click Open visualization. one.newrelic.com > Apps, and search for Network Agent Visualizations. From the Account ID dropdown, select the account you want to add the visualizations to, and click Enable. Add the Network dashboards to your account You can go to New Relic One and import several dashboards to see curated views of your network telemetry, including the GeoMap and Sankey custom visualizations from the prerequisites. Go to one.newrelic.com > Apps, and search for Quickstarts. Click Quickstarts. In the search bar, search for Network, then click one of the dashboards: Use the Network - Data Ingest and Cardinality dashboard to analyze usage trends. Use the Network - Routers and Switches dashboard for SNMP data from router and switch entities. Use the Network - Flow Devices dashboard for network flow data. one.newrelic.com > Apps, and search for Network. Click Import. Select the account where you want to add the dashboard. Optional: Edit the dashboard name. Click Import dashboard. Tip If you want to read more about custom visualizations in New Relic One, see the introduction to custom visualizations. Start exploring your network performance data Once you've finished setting up these dashboards, you can start seeing your network data by going to Dashboards or Explorer in New Relic One: From one.newrelic.com > Dashboards: For usage trend analysis, you'll see the following dashboard: Dashboard for analyzing network telemetry usage trends in New Relic One. For SNMP data, you'll see the following dashboard: Dashboard for SNMP data from router and switch entities in New Relic One. For network flow data, you'll see the following dashboard: Dashboard for network flow data monitoring in New Relic One. From one.newrelic.com > Explorer: Entities are listed under the Network category in the left-hand side menu. Open a specific device to see the details and trend of its performance. On the top right-hand side, click Lookout to see anomalies. Lookout view for Network Performance Monitoring in New Relic One. To learn how to troubleshoot network data in Navigator and Lookout, watch this short video (approx. 3:15 minutes).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 197.698,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Visualize your <em>network</em> <em>performance</em> data in New Relic One",
        "sections": "Visualize your <em>network</em> <em>performance</em> data in New Relic One",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": "After you set up your <em>network</em> data for <em>performance</em> <em>monitoring</em>, you can go to New Relic One and install several custom-curated visualizations designed specifically for <em>network</em> <em>performance</em> <em>monitoring</em>. Then, after you set up these visualizations, you can start exploring the <em>network</em> data your devices"
      },
      "id": "6127249b64441f621ea47c42"
    },
    {
      "sections": [
        "Advanced configuration for Network Performance Monitoring",
        "SNMP-base YAML sample file",
        "Devices section",
        "Trap section",
        "Discovery section",
        "Global section",
        "Optional SNMPv3 configuration",
        "Tip",
        "Optional external config files",
        "Discovery CIDRs",
        "Devices",
        "The match_attributes attribute",
        "Default 'OR' with null and empty values",
        "'AND', omit null and empty values",
        "Single match, omit null and empty values",
        "The flow_only attribute",
        "The response_time and ping_only attributes",
        "Flow data application mapping",
        "Flow data input filtering",
        "Example Filters"
      ],
      "title": "Advanced configuration for Network Performance Monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Advanced configuration"
      ],
      "external_id": "61f8c58056547c4a9a2c534617559472e3e62fd1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/advanced/advanced-config/",
      "published_at": "2021-12-30T03:03:15Z",
      "updated_at": "2021-12-19T05:14:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you want to explore all the options you can use when configuring the monitoring of your network performance, see the following sections. SNMP-base YAML sample file Here's an example of the various configuration options available in the snmp-base.yaml file used by the ktranslate docker image to poll for SNMP and flow data devices. You can also see a heavily-commented sample in the ktranslate repository on GitHub. devices: # Sample of SNMP v2c device ups_snmpv2c__10.10.0.201: device_name: ups_snmpv2c device_ip: 10.10.0.201 snmp_comm: public oid: .1.3.6.1.4.1.318.1.3.27 description: \"APC Web/SNMP Management Card (MB:v4.1.0 PF:v6.2.1 PN:apc_hw05_aos_621.bin AF1:v6.2.1 AN1:apc_hw05_sumx_621.bin MN:AP9537SUM HR:05 SN: ABC123DEF456 MD:05/21/2016) (Embedded PowerNet SNMP Agent SW v2.2 compatible)\" last_checked: 2021-11-09T18:14:59.907821489Z mib_profile: apc_ups.yml provider: kentik-ups poll_time_sec: 300 retries: 1 timeout_ms: 5000 user_tags: owning_team: dc_ops discovered_mibs: - PowerNet-MIB_UPS - TCP-MIB - UDP-MIB # Sample of SNMP v3 device router_snmpv3__10.10.0.202: device_name: router_snmpv3 device_ip: 10.10.0.202 snmp_v3: user_name: userNamev3 authentication_protocol: MD5 authentication_passphrase: authPassPrivacy privacy_protocol: AES256 privacy_passphrase: passPrivacy oid: .1.3.6.1.4.1.9.1.544 description: \"Cisco IOS Software, 3800 Software (C3845-ADVENTERPRISEK9-M), Version 15.1(3)T4, RELEASE SOFTWARE (fc1)\\r\\nTechnical Support: http://www.cisco.com/techsupport\\r\\nCopyright (c) 1986-2012 by Cisco Systems, Inc.\\r\\nCompiled Thu 24-May-12 04:27 by prod_rel_team\" last_checked: 2021-11-09T18:14:59.907821489Z mib_profile: cisco-asr.yml provider: kentik-router user_tags: owning_team: core-networking discovered_mibs: - BGP4-MIB - CISCO-MEMORY-POOL-MIB - CISCO-PROCESS-MIB - IF-MIB - OSPF-MIB engine_id: \"80:00:01:01:0a:14:1e:28\" match_attributes: if_interface_name: \"^Ten.*|^Gig.*\" \"!if_Alias\": \"[Uu]plink\" # Sample of SNMP v1 device netbotz_snmpv1__10.10.0.203: device_name: netbotz_snmpv1 device_ip: 10.10.0.201 snmp_comm: public use_snmp_v1: true oid: .1.3.6.1.4.1.5528.100.20.10.2013 description: \"Linux netbotz930A7A 2.6.12 #307 Wed Dec 29 15:25:32 EST 2010 ppc\" last_checked: 2021-11-09T18:14:59.907821489Z mib_profile: apc-netbotz.yml provider: kentik-netbotz user_tags: owning_team: sys_ops discovered_mibs: - IF-MIB - IP-MIB - TCP-MIB - UDP-MIB no_use_bulkwalkall: true # Sample of \"flow only\" device flow_only__10.10.0.210: device_name: flow_only device_ip: 10.10.0.210 user_tags: owning_team: net_eng flow_only: true # Sample of \"ping only\" device ping_only__10.10.0.220: device_name: ping_only device_ip: 10.10.0.220 user_tags: owning_team: load_balancing ping_only: true trap: listen: 127.0.0.1:1162 community: public version: \"\" transport: \"\" v3_config: null discovery: cidrs: - 10.0.0.0/24 - 10.0.0.202/32 debug: false ports: - 161 - 1161 default_communities: - public - public123 - Publ!cABC use_snmp_v1: false default_v3: null add_mibs: true threads: 4 add_devices: true replace_devices: true no_dedupe_engine_id: false global: poll_time_sec: 60 drop_if_outside_poll: false mib_profile_dir: /etc/ktranslate/profiles mibs_db: /etc/ktranslate/mibs.db mibs_enabled: - BGP4-MIB - CISCO-MEMORY-POOL-MIB - CISCO-PROCESS-MIB - IF-MIB - IP-MIB - OSPF-MIB - PowerNet-MIB_UPS - TCP-MIB - UDP-MIB timeout_ms: 3000 retries: 0 global_v3: null response_time: false user_tags: environment: production match_attributes: if_Description: \".*WAN.*\" Copy Devices section Key name Required Description device_name ✓ Name of the device. This is the unique identifier for the device in New Relic One. device_ip ✓ Target IP of the device. snmp_comm ✓ (Required for SNMPv1/2c) SNMPv1/2c community string to use. use_snmp_v1 ✓ (Required for SNMPv1) Indicates whether to use SNMPv1. By default, it's set to false. snmp_v3 ✓ (Required for SNMPv3) SNMP v3 config debug Indicates whether to enable debug level logging during SNMP polling. By default, it's set to false. port Port to send SNMP queries to. By default, it's set to port 161. oid ✓ (Required for SNMP polling) The discovered systemObjectID | sysObjectID | sysOID for the device. This is used to match the device to a known SNMP profile and set the provider attribute. If no match is found, this sets the provider as a kentik-default device. description The discovered sysDescr of the device. This field is informational. last_checked Timestamp when this device was last discovered by the ktranslate docker image. This field is informational. mib_profile ✓ (Required for SNMP polling) SNMP Profile file that was associated with this device during the discovery run based on its sysOID. If this starts with a bang (!) token, it will override the automatic matching from the sysOID and use a manual override. Ex: \"!cisco-asa.yml\" (quotes are required). provider ✓ (Required for New Relic One) Value used during entity synthesis for New Relic One. This is automatically created based on the matched mib_profile. poll_time_sec Indicates the SNMP polling frequency in seconds. This setting is used to override the global.poll_time_sec attribute. retries Indicates the number of attempts to retry polling SNMP OIDs. This setting is used to override the global.retries attribute. timeout_ms Indicates the SNMP polling timeout in milliseconds. This setting is used to override the global.timeout_ms attribute. user_tags key:value pair attributes to give more context to the device. Tags at this level will be appended to any tags applied in the global.user_tags attribute. discovered_mibs List of MIBs pulled from matched mib_profile that this device can respond to. This field is informational. engine_id The unique engine ID discovered for this device's SNMP agent. Generally found during SNMP v3 discovery. This field is informational. match_attributes attribute:regex pairs to add metrics to allowlist. Pairs at this level will be appended to any pairs applied in the global.match_attributes attribute. Uses the RE2 syntax and has a default OR operator. Prefix key with ! to force to AND operators. monitor_admin_shut Indicates whether to monitor interfaces in Administratively Shutdown status. By default, it's set to false. no_use_bulkwalkall Disables the SNMP GETBULK request action when true. By default, it's set to false. ping_only Disables all SNMP polling and enables response time polling when true. This setting is used to override the global.response_time attribute. By default, it's set to false. flow_only Disables all SNMP polling when true. By default, it's set to false. Trap section Key name Required Description listen ✓ Listening IP port for receiving SNMP traps. By default it's set to 127.0.0.1:1162, using the SNMP Trap default of 162 requires running Docker as root. community SNMPv1/v2c community string for receiving SNMP traps. version SNMP version to use. Options are v1, v2c, and v3. By default, it's set to v2c. transport SNMP transport protocol to use. Options are TCP and UDP. By default, it's set to UDP v3_config SNMP v3 config to use. Only used if version: v3. Discovery section Key name Required Description cidrs ✓ Array of target IP ranges in CIDR notation. debug Indicates whether to enable debug level logging during discovery. By default, it's set to false ports ✓ Array of target ports to scan during SNMP polling. default_communities ✓ (Required for SNMPv1/2c) Array of SNMPv1/v2c community strings to scan during SNMP polling. This array is evaluated in order and discovery accepts the first passing community. use_snmp_v1 ✓ (Required for SNMPv1) Indicates whether to use SNMPv1 during discovery. By default, it's set to false default_v3 ✓ (Required for SNMPv3) SNMPv3 configuration to scan during SNMP polling. add_devices ✓ Indicates whether to add discovered devices to the devices section of the snmp-base.yaml file. By default, it's set to true. add_mibs ✓ Indicates whether to add discovered MIBs to the global.mibs_enabled section of the snmp-base.yaml file. By default, it's set to true. threads ✓ Integer limit of threads to use during discovery. It should be less than the number of cores available to the container. By default it's set to 4. replace_devices ✓ Indicates whether to replace discovered devices if they already exist in the devices section of the snmp-base.yaml file. By default, it's set to false. no_dedup_engine_id When set to true, disables deduplication of discovered devices if it appears that they are the same device, based on their reported SNMP engine ID. By default, it's set to false Global section Key name Required Description poll_time_sec ✓ Time in seconds to poll devices. This can be overridden per device using the devices.<deviceName>.poll_time_sec attribute. By default, it's set to 60. drop_if_outside_poll Indicates whether to drop all values from this cycle if polling takes longer than the value set in poll_time_sec. By default, it's set to false mib_profile_dir Directory to find curated MIB profiles. These are pulled into the ktranslate image automatically from Kentik's snmp-profiles repository and can be overridden at Docker runtime by creating a volume mount of your own local directory of profiles. mibs_db mibs_enabled ✓ Array of all active MIBs the ktranslate docker image will poll. This list is automatically generated during discovery if the discovery_add_mibs attribute is true. MIBs not listed here will not be polled on any device in the configuration file. You can specify a SNMP table directly in a MIB file using MIB-NAME.tableName syntax. Ex: HOST-RESOURCES-MIB.hrProcessorTable. timeout_ms ✓ Time in milliseconds SNMP queries timeout. This can be overridden per device using the devices.<deviceName>.timeout_ms attribute. By default, it's set to 5000 retries ✓ Number of attempts to retry failed SNMP polls. This can be overridden per device using the devices.<deviceName>.retries attribute. By default, it's set to 0 user_tags key:value pair attributes to give more context to the device. Tags at this level will be applied to all devices in the configuration file. match_attributes attribute:regex pairs to add metrics to allowlist. Pairs at this level will matched against all devices in the configuration file. Uses the RE2 syntax and has a default OR operator. Prefix key with ! to force to AND operators. response_time Indicates whether response time polling is enabled for all devices in the configuration file. By default, it's set to false. Optional SNMPv3 configuration Key name Required Description user_name ✓ User name for SNMPv3 authentication authentication_protocol ✓ SNMPv3 authentication protocol. The possible values are NoAuth, MD5, or SHA authentication_passphrase SNMPv3 authentication passphrase privacy_protocol ✓ SNMPv3 privacy protocol. The possible values are AuthNoPriv, DES, AES, AES192, AES256, AES192C, or AES256C privacy_passphrase SNMPv3 privacy passphrase context_engine_id SNMPv3 context engine ID context_name SNMPv3 context name Tip You can use AWS Secrets Manager natively in your SNMP v3 config using the aws.sm.$SECRET_NAME syntax, replacing $SECRET_NAME as necessary to have ktranslate pull in your credentials during Docker runtime. Optional external config files To support a wide variety of configuration and automation needs, you can use external files that you volume mount into your Docker container to decouple certain elements of the standard configuration file. The syntax for these files is \"@fileName.extension\", including the double quotes. Discovery CIDRs Example: discovery: cidrs: \"@cidrs.yaml\" Copy The CIDRs file should use a YAML list syntax like this: - 10.10.0.0/24 - 10.20.0.0/24 - 192.168.0.21/32 Copy Devices Example: devices: - \"@neteng-devices.yaml\" - \"@dc-ops.yaml\" Copy The device files should use the same syntax as the standard devices section of the main config file, omitting the optional fields that are generated during discovery: devices: # Sample of SNMP v2c device ups_snmpv2c__10.10.0.201: device_name: ups_snmpv2c device_ip: 10.10.0.201 snmp_comm: public oid: .1.3.6.1.4.1.318.1.3.27 mib_profile: apc_ups.yml provider: kentik-ups poll_time_sec: 300 retries: 1 timeout_ms: 5000 user_tags: owning_team: dc_ops Copy The match_attributes attribute To support filtering of data that does not create value for your observability needs, you can set the global.match_attributes.{} and/or devices.<deviceName>.match_attributes.{} attribute map. This will provide filtering at the ktranslate level, before shipping data to New Relic, giving you granular control over monitoring of things like interfaces. The default behavior of this map is an OR condition, but you can override this and force an AND operator by prefixing your key name with !. This is also useful to return only matched items and omit all null and \"\" (empty) results. Default 'OR' with null and empty values Match when if_Alias begins with Uplink OR when if_interface_name begins with Gig, keep all null and \"\" values: devices: deviceName: ... match_attributes: if_Alias: \"^Uplink.*\" if_interface_name: \"^Gig.*\" Copy 'AND', omit null and empty values Match when if_Alias begins with Uplink AND when if_interface_name begins with Gig, drop all null and \"\" values: devices: deviceName: ... match_attributes: if_Alias: \"^Uplink.*\" \"!if_interface_name\": \"^Gig.*\" Copy Single match, omit null and empty values Match when if_Alias begins with Uplink, drop all null and \"\" values: devices: deviceName: ... match_attributes: \"!if_Alias\": \"^Uplink.*\" Copy The flow_only attribute To support monitoring of devices where performance statistics are nor accessible, available, or desired, you can set the devices.<deviceName>.flow_only attribute to true. This will generate a Flow Device entity in New Relic One which will only have telemetry in the KFlow event namespace. Alternatively, collecting flow telemetry from a device that is in your configuration file as an SNMP device will add decoration of the KFlow data to the pre-existing entity, such as a Router or Firewall. In New Relic One, you can see the results of this polling by investigating the following events: FROM KFlow SELECT count(*) FACET device_name WHERE instrumentation.name = 'netflow-events' TIMESERIES Copy The response_time and ping_only attributes To support monitoring of devices where performance statistics are not accessible or available, or in simple cases where basic round-trip time (RTT) monitoring is required, you can either set the global.response_time or devices.<deviceName>.ping_only attributes to true. This feature uses the go-ping package to send unprivileged UDP packets to devices in order to collect the average, min, and max RTT for the endpoint based on sending 1 packet/sec from ktranslate to the device IP address. Setting the global.response_time attribute to true will add RTT monitoring on top of existing SNMP polling. devices.<deviceName>.ping_only: true will allow you to monitor devices with only the UDP packets for RTT and no SNMP polling. In New Relic One, you can see the results of this polling by investigating the following metrics: FROM Metric SELECT average(kentik.ping.AvgRttMs) AS 'Average', max(kentik.ping.MaxRttMs) AS 'Max', min(kentik.ping.MinRttMs) AS 'Min' FACET device_name TIMESERIES Copy Tip You can use the ping_only attribute in replacement of the flow_only attribute if you would like to collect RTT metrics from a flow device. If both ping_only and flow_only are true, the device will be treated as a flow_only device. Flow data application mapping By default, flow telemetry is mapped to known applications based on evaluation of the layer 4 port in use on a specific flow conversation. If needed, you can override the default mapping by providing a YAML file during Docker runtime to the -application_map flag. This will allow you to specify application names based on ports you identify. Example syntax: applications: - ports: [9092, 9093] name: kafka - ports: [80, 8080] name: http - ports: [443, 8443] name: https Copy Flow data input filtering By default, flow data containers will collect and process every flow packet they receive. If needed, you can add an inclusion filter to the -nf.source flag that will ignore all traffic not matching the filter you provide. Syntax: --filters $TYPE,$FIELD,$FUNCTION,$MATCH Argument Name Required Description $TYPE ✓ The type of filter to apply. Possible values are string, int, and addr. $FIELD ✓ The name of the field to evaluate the match pattern against. $FUNCTION ✓ The type of function to use during evaluation. Possible values are Equal: ==, NotEqual: !=, LessThan: <, GreaterThan: >, Contains: % $MATCH ✓ The value to be used as a match pattern. Example Filters Only collect flow data from source addresses in the 10.0.0.0/24 CIDR range -nf.source sflow --filters addr,src_addr,%,10.10.0.0/24 Copy Only collect flow data where the destination port is not equal to 8531 -nf.source netflow5 --filters int,l4_dst_port,!=,8531 Copy You can also add multiple filters together with an inherited AND operator Only collect flow data from source addresses in the 10.0.0.0/24 CIDR range AND where the destination port is not equal to 8531 --filters addr,src_addr,%,10.0.0.0/24 --filters int,l4_dst_port,!=,8531 Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.18547,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Advanced configuration for <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "sections": "Advanced configuration for <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "tags": "<em>Network</em> <em>performance</em> <em>monitoring</em>",
        "body": "If you want to explore all the options you can use when configuring the <em>monitoring</em> of your <em>network</em> <em>performance</em>, see the following sections. SNMP-base YAML sample file Here&#x27;s an example of the various configuration options available in the snmp-base.yaml file used by the ktranslate docker image"
      },
      "id": "61b9389664441f8fc3d7182e"
    },
    {
      "sections": [
        "SNMP device profiles",
        "Get started",
        "Tip",
        "Make requests through GitHub",
        "Contribute profiles and modifications publicly",
        "What kinds of OIDs should I actually include in a profile?",
        "Use custom profiles privately"
      ],
      "title": "SNMP device profiles",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Advanced configuration"
      ],
      "external_id": "9b38a960070da5782cfd75e087db62f15fb71223",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/advanced/snmp-profiles/",
      "published_at": "2021-12-30T03:03:05Z",
      "updated_at": "2021-12-15T00:37:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Profiles define what SNMP OIDs we want to collect and send to your New Relic account. This document explains how to modify an existing profile or create a new profile. Get started If you've decided to build a custom profile or modify one of our open source profiles, you need a few essential tools: A GitHub account: This enables you to raise issues and contribute changes to Kentik's open source profiles. An SNMP walk from a network device where you want to work on a profile. For more information, see our documentation on setting up SNMP and using snmpwalk. Permissions to perform Docker pull on the server that hosts your ktranslate container. This document covers: Making requests for new or modified profiles through GitHub to be worked on by the maintainers Contributing your own profiles and modifications publicly Using custom profiles privately Tip Support for all things relating to kentik/snmp-profiles is handled through GitHub issues. New Relic technical support is not able to provide any additional help beyond redirecting you back to raise an issue there. Make requests through GitHub This is the most common and simple scenario, for cases where you don't have the time or expertise with SNMP to do these yourself. After you provide the relevant data, our team will build the profile for you. Log into GitHub and go to the snmp-profiles repo. Click the Issues tab near the top. Click New issue. To request a new profile, look for the SNMP Profile Request section, and click Get started. Provide all requested information in the template, such as the device vendor, model, snmp object identifier, and a sanitized SNMP walk. For all other requests, use Open a blank issue. Tip Providing an SNMP walk is critical as we cannot do any work on the profile without these. This is not the same as an MIB file. The maintainers of the repo will review the information you provided and, if there is anything missing, they will follow up with you. Once all the necessary data is provided, they will add it to the queue of profiles to be built. After it is added to the repo, the issue will be closed, and all you have to do is update the ktranslate docker container on your end, and the newest profiles will automatically be loaded. Contribute profiles and modifications publicly We gladly accept contributions from anyone who wants to help out to either create new profiles or improve the existing profiles. To familiarize yourself with the structure of a profile, review this highly commented template.yml on GitHub. Log into GitHub and go to the snmp-profiles repo. To create a copy of the same information in your account, click the fork button near the top. Within your fork,make necessary changes to the files, or create new vendor directories and profiles as needed. Be sure to pass your profile through a YAML validator, such as codebeautify, before submitting a pull request. When you are done with your changes, submit a pull request to the upstream repo. The maintainers will review the change, and discuss any necessary feedback. When everyone is aligned, it will be merged. Shortly after a merge, new SNMP profiles are automatically available by pulling the new version of the Docker image and launching a new container in your environment. For more information, see our documentation about SNMP manual setup. Tip Be sure to sync your fork regularly to keep it up to date with changes in the upstream repo. What kinds of OIDs should I actually include in a profile? In many cases SNMP offers a lot of data, but much of that data does not provide actionable information. Or, the data provides value that is so uncommon and low impact, it might not be worth bringing into your New Relic account. You want to focus on collecting data that lets you know if there is anything that would stop the device from being able to perform whatever functions you expect it to perform. Building on from that, you should collect measurements that tell you how well it is performing those functions. Example 1: For a device operating as a VPN concentrator, we would collect high-level system metrics like: CPU and memory utilization Hardware sensor information to make sure that the device isn't going to shut itself down due to things like fan failures OIDs that tell us about the aggregated connections and throughput Example 2: An example of data that is available but provides very poor value is an OID table that lists all the running processes on a network appliance. Coming from a server admin perspective, that might sound useful, but since this is an appliance, you normally do not have the capability or the need to do anything with the processes that run inside it. Polling and storing tables with hundreds of items that you can't actually do anything with would not be efficient. Use custom profiles privately For cases where you want to make a change to a profile, but you know that it is a scenario that is very unique and would not apply to other customers you can locally edit the profiles. The way this is done is by using Docker's volume mount to pass in your customized files to the ktranslate container inside the etc/ktranslate/profiles/ directory. There are other ways you could accomplish this but in this example we will demonstrate using a git fork and clone. Ensure you are in the directory you want to keep the files in, then clone your fork of the GitHub repo to your Docker host: git clone https://github.com/<YourGitUser>/snmp-profiles.git Copy Get the command you would normally use to launch the SNMP container, and add a second volume mount argument after the one where we passed in the snmp-base.yaml. -v `pwd`/snmp-profiles/profiles:/etc/ktranslate/profiles \\ Copy The mount command replaces the built-in profiles directory with your customized data. The end result will be be similar to this: docker run -ti --name ktranslate-discovery --rm --net=host \\ --user `id -u`:`id -g` \\ -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ -v `pwd`/snmp-profiles/profiles:/etc/ktranslate/profiles \\ kentik/ktranslate:v2 \\ -snmp /snmp-base.yaml \\ -log_level info \\ -snmp_discovery=true Copy Tip Be sure to pass your custom version of the profiles in every time you launch a discovery container or SNMP polling container. If you don't use it consistently for all SNMP instances sets, this can cause unreliable behavior.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.50562,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Network</em> <em>performance</em> <em>monitoring</em>",
        "body": ": A GitHub account: This enables you to raise issues and contribute changes to Kentik&#x27;s open source profiles. An SNMP walk from a <em>network</em> device where you want to work on a profile. For more information, see our documentation on setting up SNMP and using snmpwalk. Permissions to <em>perform</em> Docker pull"
      },
      "id": "61b33254196a67414ea5c67b"
    }
  ],
  "/docs/network-performance-monitoring/advanced/ktranslate-container-management": [
    {
      "sections": [
        "Advanced configuration for Network Performance Monitoring",
        "SNMP-base YAML sample file",
        "Devices section",
        "Trap section",
        "Discovery section",
        "Global section",
        "Optional SNMPv3 configuration",
        "Tip",
        "Optional external config files",
        "Discovery CIDRs",
        "Devices",
        "The match_attributes attribute",
        "Default 'OR' with null and empty values",
        "'AND', omit null and empty values",
        "Single match, omit null and empty values",
        "The flow_only attribute",
        "The response_time and ping_only attributes",
        "Flow data application mapping",
        "Flow data input filtering",
        "Example Filters"
      ],
      "title": "Advanced configuration for Network Performance Monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Advanced configuration"
      ],
      "external_id": "61f8c58056547c4a9a2c534617559472e3e62fd1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/advanced/advanced-config/",
      "published_at": "2021-12-30T03:03:15Z",
      "updated_at": "2021-12-19T05:14:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you want to explore all the options you can use when configuring the monitoring of your network performance, see the following sections. SNMP-base YAML sample file Here's an example of the various configuration options available in the snmp-base.yaml file used by the ktranslate docker image to poll for SNMP and flow data devices. You can also see a heavily-commented sample in the ktranslate repository on GitHub. devices: # Sample of SNMP v2c device ups_snmpv2c__10.10.0.201: device_name: ups_snmpv2c device_ip: 10.10.0.201 snmp_comm: public oid: .1.3.6.1.4.1.318.1.3.27 description: \"APC Web/SNMP Management Card (MB:v4.1.0 PF:v6.2.1 PN:apc_hw05_aos_621.bin AF1:v6.2.1 AN1:apc_hw05_sumx_621.bin MN:AP9537SUM HR:05 SN: ABC123DEF456 MD:05/21/2016) (Embedded PowerNet SNMP Agent SW v2.2 compatible)\" last_checked: 2021-11-09T18:14:59.907821489Z mib_profile: apc_ups.yml provider: kentik-ups poll_time_sec: 300 retries: 1 timeout_ms: 5000 user_tags: owning_team: dc_ops discovered_mibs: - PowerNet-MIB_UPS - TCP-MIB - UDP-MIB # Sample of SNMP v3 device router_snmpv3__10.10.0.202: device_name: router_snmpv3 device_ip: 10.10.0.202 snmp_v3: user_name: userNamev3 authentication_protocol: MD5 authentication_passphrase: authPassPrivacy privacy_protocol: AES256 privacy_passphrase: passPrivacy oid: .1.3.6.1.4.1.9.1.544 description: \"Cisco IOS Software, 3800 Software (C3845-ADVENTERPRISEK9-M), Version 15.1(3)T4, RELEASE SOFTWARE (fc1)\\r\\nTechnical Support: http://www.cisco.com/techsupport\\r\\nCopyright (c) 1986-2012 by Cisco Systems, Inc.\\r\\nCompiled Thu 24-May-12 04:27 by prod_rel_team\" last_checked: 2021-11-09T18:14:59.907821489Z mib_profile: cisco-asr.yml provider: kentik-router user_tags: owning_team: core-networking discovered_mibs: - BGP4-MIB - CISCO-MEMORY-POOL-MIB - CISCO-PROCESS-MIB - IF-MIB - OSPF-MIB engine_id: \"80:00:01:01:0a:14:1e:28\" match_attributes: if_interface_name: \"^Ten.*|^Gig.*\" \"!if_Alias\": \"[Uu]plink\" # Sample of SNMP v1 device netbotz_snmpv1__10.10.0.203: device_name: netbotz_snmpv1 device_ip: 10.10.0.201 snmp_comm: public use_snmp_v1: true oid: .1.3.6.1.4.1.5528.100.20.10.2013 description: \"Linux netbotz930A7A 2.6.12 #307 Wed Dec 29 15:25:32 EST 2010 ppc\" last_checked: 2021-11-09T18:14:59.907821489Z mib_profile: apc-netbotz.yml provider: kentik-netbotz user_tags: owning_team: sys_ops discovered_mibs: - IF-MIB - IP-MIB - TCP-MIB - UDP-MIB no_use_bulkwalkall: true # Sample of \"flow only\" device flow_only__10.10.0.210: device_name: flow_only device_ip: 10.10.0.210 user_tags: owning_team: net_eng flow_only: true # Sample of \"ping only\" device ping_only__10.10.0.220: device_name: ping_only device_ip: 10.10.0.220 user_tags: owning_team: load_balancing ping_only: true trap: listen: 127.0.0.1:1162 community: public version: \"\" transport: \"\" v3_config: null discovery: cidrs: - 10.0.0.0/24 - 10.0.0.202/32 debug: false ports: - 161 - 1161 default_communities: - public - public123 - Publ!cABC use_snmp_v1: false default_v3: null add_mibs: true threads: 4 add_devices: true replace_devices: true no_dedupe_engine_id: false global: poll_time_sec: 60 drop_if_outside_poll: false mib_profile_dir: /etc/ktranslate/profiles mibs_db: /etc/ktranslate/mibs.db mibs_enabled: - BGP4-MIB - CISCO-MEMORY-POOL-MIB - CISCO-PROCESS-MIB - IF-MIB - IP-MIB - OSPF-MIB - PowerNet-MIB_UPS - TCP-MIB - UDP-MIB timeout_ms: 3000 retries: 0 global_v3: null response_time: false user_tags: environment: production match_attributes: if_Description: \".*WAN.*\" Copy Devices section Key name Required Description device_name ✓ Name of the device. This is the unique identifier for the device in New Relic One. device_ip ✓ Target IP of the device. snmp_comm ✓ (Required for SNMPv1/2c) SNMPv1/2c community string to use. use_snmp_v1 ✓ (Required for SNMPv1) Indicates whether to use SNMPv1. By default, it's set to false. snmp_v3 ✓ (Required for SNMPv3) SNMP v3 config debug Indicates whether to enable debug level logging during SNMP polling. By default, it's set to false. port Port to send SNMP queries to. By default, it's set to port 161. oid ✓ (Required for SNMP polling) The discovered systemObjectID | sysObjectID | sysOID for the device. This is used to match the device to a known SNMP profile and set the provider attribute. If no match is found, this sets the provider as a kentik-default device. description The discovered sysDescr of the device. This field is informational. last_checked Timestamp when this device was last discovered by the ktranslate docker image. This field is informational. mib_profile ✓ (Required for SNMP polling) SNMP Profile file that was associated with this device during the discovery run based on its sysOID. If this starts with a bang (!) token, it will override the automatic matching from the sysOID and use a manual override. Ex: \"!cisco-asa.yml\" (quotes are required). provider ✓ (Required for New Relic One) Value used during entity synthesis for New Relic One. This is automatically created based on the matched mib_profile. poll_time_sec Indicates the SNMP polling frequency in seconds. This setting is used to override the global.poll_time_sec attribute. retries Indicates the number of attempts to retry polling SNMP OIDs. This setting is used to override the global.retries attribute. timeout_ms Indicates the SNMP polling timeout in milliseconds. This setting is used to override the global.timeout_ms attribute. user_tags key:value pair attributes to give more context to the device. Tags at this level will be appended to any tags applied in the global.user_tags attribute. discovered_mibs List of MIBs pulled from matched mib_profile that this device can respond to. This field is informational. engine_id The unique engine ID discovered for this device's SNMP agent. Generally found during SNMP v3 discovery. This field is informational. match_attributes attribute:regex pairs to add metrics to allowlist. Pairs at this level will be appended to any pairs applied in the global.match_attributes attribute. Uses the RE2 syntax and has a default OR operator. Prefix key with ! to force to AND operators. monitor_admin_shut Indicates whether to monitor interfaces in Administratively Shutdown status. By default, it's set to false. no_use_bulkwalkall Disables the SNMP GETBULK request action when true. By default, it's set to false. ping_only Disables all SNMP polling and enables response time polling when true. This setting is used to override the global.response_time attribute. By default, it's set to false. flow_only Disables all SNMP polling when true. By default, it's set to false. Trap section Key name Required Description listen ✓ Listening IP port for receiving SNMP traps. By default it's set to 127.0.0.1:1162, using the SNMP Trap default of 162 requires running Docker as root. community SNMPv1/v2c community string for receiving SNMP traps. version SNMP version to use. Options are v1, v2c, and v3. By default, it's set to v2c. transport SNMP transport protocol to use. Options are TCP and UDP. By default, it's set to UDP v3_config SNMP v3 config to use. Only used if version: v3. Discovery section Key name Required Description cidrs ✓ Array of target IP ranges in CIDR notation. debug Indicates whether to enable debug level logging during discovery. By default, it's set to false ports ✓ Array of target ports to scan during SNMP polling. default_communities ✓ (Required for SNMPv1/2c) Array of SNMPv1/v2c community strings to scan during SNMP polling. This array is evaluated in order and discovery accepts the first passing community. use_snmp_v1 ✓ (Required for SNMPv1) Indicates whether to use SNMPv1 during discovery. By default, it's set to false default_v3 ✓ (Required for SNMPv3) SNMPv3 configuration to scan during SNMP polling. add_devices ✓ Indicates whether to add discovered devices to the devices section of the snmp-base.yaml file. By default, it's set to true. add_mibs ✓ Indicates whether to add discovered MIBs to the global.mibs_enabled section of the snmp-base.yaml file. By default, it's set to true. threads ✓ Integer limit of threads to use during discovery. It should be less than the number of cores available to the container. By default it's set to 4. replace_devices ✓ Indicates whether to replace discovered devices if they already exist in the devices section of the snmp-base.yaml file. By default, it's set to false. no_dedup_engine_id When set to true, disables deduplication of discovered devices if it appears that they are the same device, based on their reported SNMP engine ID. By default, it's set to false Global section Key name Required Description poll_time_sec ✓ Time in seconds to poll devices. This can be overridden per device using the devices.<deviceName>.poll_time_sec attribute. By default, it's set to 60. drop_if_outside_poll Indicates whether to drop all values from this cycle if polling takes longer than the value set in poll_time_sec. By default, it's set to false mib_profile_dir Directory to find curated MIB profiles. These are pulled into the ktranslate image automatically from Kentik's snmp-profiles repository and can be overridden at Docker runtime by creating a volume mount of your own local directory of profiles. mibs_db mibs_enabled ✓ Array of all active MIBs the ktranslate docker image will poll. This list is automatically generated during discovery if the discovery_add_mibs attribute is true. MIBs not listed here will not be polled on any device in the configuration file. You can specify a SNMP table directly in a MIB file using MIB-NAME.tableName syntax. Ex: HOST-RESOURCES-MIB.hrProcessorTable. timeout_ms ✓ Time in milliseconds SNMP queries timeout. This can be overridden per device using the devices.<deviceName>.timeout_ms attribute. By default, it's set to 5000 retries ✓ Number of attempts to retry failed SNMP polls. This can be overridden per device using the devices.<deviceName>.retries attribute. By default, it's set to 0 user_tags key:value pair attributes to give more context to the device. Tags at this level will be applied to all devices in the configuration file. match_attributes attribute:regex pairs to add metrics to allowlist. Pairs at this level will matched against all devices in the configuration file. Uses the RE2 syntax and has a default OR operator. Prefix key with ! to force to AND operators. response_time Indicates whether response time polling is enabled for all devices in the configuration file. By default, it's set to false. Optional SNMPv3 configuration Key name Required Description user_name ✓ User name for SNMPv3 authentication authentication_protocol ✓ SNMPv3 authentication protocol. The possible values are NoAuth, MD5, or SHA authentication_passphrase SNMPv3 authentication passphrase privacy_protocol ✓ SNMPv3 privacy protocol. The possible values are AuthNoPriv, DES, AES, AES192, AES256, AES192C, or AES256C privacy_passphrase SNMPv3 privacy passphrase context_engine_id SNMPv3 context engine ID context_name SNMPv3 context name Tip You can use AWS Secrets Manager natively in your SNMP v3 config using the aws.sm.$SECRET_NAME syntax, replacing $SECRET_NAME as necessary to have ktranslate pull in your credentials during Docker runtime. Optional external config files To support a wide variety of configuration and automation needs, you can use external files that you volume mount into your Docker container to decouple certain elements of the standard configuration file. The syntax for these files is \"@fileName.extension\", including the double quotes. Discovery CIDRs Example: discovery: cidrs: \"@cidrs.yaml\" Copy The CIDRs file should use a YAML list syntax like this: - 10.10.0.0/24 - 10.20.0.0/24 - 192.168.0.21/32 Copy Devices Example: devices: - \"@neteng-devices.yaml\" - \"@dc-ops.yaml\" Copy The device files should use the same syntax as the standard devices section of the main config file, omitting the optional fields that are generated during discovery: devices: # Sample of SNMP v2c device ups_snmpv2c__10.10.0.201: device_name: ups_snmpv2c device_ip: 10.10.0.201 snmp_comm: public oid: .1.3.6.1.4.1.318.1.3.27 mib_profile: apc_ups.yml provider: kentik-ups poll_time_sec: 300 retries: 1 timeout_ms: 5000 user_tags: owning_team: dc_ops Copy The match_attributes attribute To support filtering of data that does not create value for your observability needs, you can set the global.match_attributes.{} and/or devices.<deviceName>.match_attributes.{} attribute map. This will provide filtering at the ktranslate level, before shipping data to New Relic, giving you granular control over monitoring of things like interfaces. The default behavior of this map is an OR condition, but you can override this and force an AND operator by prefixing your key name with !. This is also useful to return only matched items and omit all null and \"\" (empty) results. Default 'OR' with null and empty values Match when if_Alias begins with Uplink OR when if_interface_name begins with Gig, keep all null and \"\" values: devices: deviceName: ... match_attributes: if_Alias: \"^Uplink.*\" if_interface_name: \"^Gig.*\" Copy 'AND', omit null and empty values Match when if_Alias begins with Uplink AND when if_interface_name begins with Gig, drop all null and \"\" values: devices: deviceName: ... match_attributes: if_Alias: \"^Uplink.*\" \"!if_interface_name\": \"^Gig.*\" Copy Single match, omit null and empty values Match when if_Alias begins with Uplink, drop all null and \"\" values: devices: deviceName: ... match_attributes: \"!if_Alias\": \"^Uplink.*\" Copy The flow_only attribute To support monitoring of devices where performance statistics are nor accessible, available, or desired, you can set the devices.<deviceName>.flow_only attribute to true. This will generate a Flow Device entity in New Relic One which will only have telemetry in the KFlow event namespace. Alternatively, collecting flow telemetry from a device that is in your configuration file as an SNMP device will add decoration of the KFlow data to the pre-existing entity, such as a Router or Firewall. In New Relic One, you can see the results of this polling by investigating the following events: FROM KFlow SELECT count(*) FACET device_name WHERE instrumentation.name = 'netflow-events' TIMESERIES Copy The response_time and ping_only attributes To support monitoring of devices where performance statistics are not accessible or available, or in simple cases where basic round-trip time (RTT) monitoring is required, you can either set the global.response_time or devices.<deviceName>.ping_only attributes to true. This feature uses the go-ping package to send unprivileged UDP packets to devices in order to collect the average, min, and max RTT for the endpoint based on sending 1 packet/sec from ktranslate to the device IP address. Setting the global.response_time attribute to true will add RTT monitoring on top of existing SNMP polling. devices.<deviceName>.ping_only: true will allow you to monitor devices with only the UDP packets for RTT and no SNMP polling. In New Relic One, you can see the results of this polling by investigating the following metrics: FROM Metric SELECT average(kentik.ping.AvgRttMs) AS 'Average', max(kentik.ping.MaxRttMs) AS 'Max', min(kentik.ping.MinRttMs) AS 'Min' FACET device_name TIMESERIES Copy Tip You can use the ping_only attribute in replacement of the flow_only attribute if you would like to collect RTT metrics from a flow device. If both ping_only and flow_only are true, the device will be treated as a flow_only device. Flow data application mapping By default, flow telemetry is mapped to known applications based on evaluation of the layer 4 port in use on a specific flow conversation. If needed, you can override the default mapping by providing a YAML file during Docker runtime to the -application_map flag. This will allow you to specify application names based on ports you identify. Example syntax: applications: - ports: [9092, 9093] name: kafka - ports: [80, 8080] name: http - ports: [443, 8443] name: https Copy Flow data input filtering By default, flow data containers will collect and process every flow packet they receive. If needed, you can add an inclusion filter to the -nf.source flag that will ignore all traffic not matching the filter you provide. Syntax: --filters $TYPE,$FIELD,$FUNCTION,$MATCH Argument Name Required Description $TYPE ✓ The type of filter to apply. Possible values are string, int, and addr. $FIELD ✓ The name of the field to evaluate the match pattern against. $FUNCTION ✓ The type of function to use during evaluation. Possible values are Equal: ==, NotEqual: !=, LessThan: <, GreaterThan: >, Contains: % $MATCH ✓ The value to be used as a match pattern. Example Filters Only collect flow data from source addresses in the 10.0.0.0/24 CIDR range -nf.source sflow --filters addr,src_addr,%,10.10.0.0/24 Copy Only collect flow data where the destination port is not equal to 8531 -nf.source netflow5 --filters int,l4_dst_port,!=,8531 Copy You can also add multiple filters together with an inherited AND operator Only collect flow data from source addresses in the 10.0.0.0/24 CIDR range AND where the destination port is not equal to 8531 --filters addr,src_addr,%,10.0.0.0/24 --filters int,l4_dst_port,!=,8531 Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 309.90512,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Advanced</em> <em>configuration</em> for <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "sections": "<em>Advanced</em> <em>configuration</em> for <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "tags": "<em>Network</em> <em>performance</em> <em>monitoring</em>",
        "body": "If you want to explore all the options you can use when configuring the <em>monitoring</em> of your <em>network</em> <em>performance</em>, see the following sections. SNMP-base YAML sample file Here&#x27;s an example of the various <em>configuration</em> options available in the snmp-base.yaml file used by the <em>ktranslate</em> docker image"
      },
      "id": "61b9389664441f8fc3d7182e"
    },
    {
      "sections": [
        "SNMP device profiles",
        "Get started",
        "Tip",
        "Make requests through GitHub",
        "Contribute profiles and modifications publicly",
        "What kinds of OIDs should I actually include in a profile?",
        "Use custom profiles privately"
      ],
      "title": "SNMP device profiles",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Advanced configuration"
      ],
      "external_id": "9b38a960070da5782cfd75e087db62f15fb71223",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/advanced/snmp-profiles/",
      "published_at": "2021-12-30T03:03:05Z",
      "updated_at": "2021-12-15T00:37:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Profiles define what SNMP OIDs we want to collect and send to your New Relic account. This document explains how to modify an existing profile or create a new profile. Get started If you've decided to build a custom profile or modify one of our open source profiles, you need a few essential tools: A GitHub account: This enables you to raise issues and contribute changes to Kentik's open source profiles. An SNMP walk from a network device where you want to work on a profile. For more information, see our documentation on setting up SNMP and using snmpwalk. Permissions to perform Docker pull on the server that hosts your ktranslate container. This document covers: Making requests for new or modified profiles through GitHub to be worked on by the maintainers Contributing your own profiles and modifications publicly Using custom profiles privately Tip Support for all things relating to kentik/snmp-profiles is handled through GitHub issues. New Relic technical support is not able to provide any additional help beyond redirecting you back to raise an issue there. Make requests through GitHub This is the most common and simple scenario, for cases where you don't have the time or expertise with SNMP to do these yourself. After you provide the relevant data, our team will build the profile for you. Log into GitHub and go to the snmp-profiles repo. Click the Issues tab near the top. Click New issue. To request a new profile, look for the SNMP Profile Request section, and click Get started. Provide all requested information in the template, such as the device vendor, model, snmp object identifier, and a sanitized SNMP walk. For all other requests, use Open a blank issue. Tip Providing an SNMP walk is critical as we cannot do any work on the profile without these. This is not the same as an MIB file. The maintainers of the repo will review the information you provided and, if there is anything missing, they will follow up with you. Once all the necessary data is provided, they will add it to the queue of profiles to be built. After it is added to the repo, the issue will be closed, and all you have to do is update the ktranslate docker container on your end, and the newest profiles will automatically be loaded. Contribute profiles and modifications publicly We gladly accept contributions from anyone who wants to help out to either create new profiles or improve the existing profiles. To familiarize yourself with the structure of a profile, review this highly commented template.yml on GitHub. Log into GitHub and go to the snmp-profiles repo. To create a copy of the same information in your account, click the fork button near the top. Within your fork,make necessary changes to the files, or create new vendor directories and profiles as needed. Be sure to pass your profile through a YAML validator, such as codebeautify, before submitting a pull request. When you are done with your changes, submit a pull request to the upstream repo. The maintainers will review the change, and discuss any necessary feedback. When everyone is aligned, it will be merged. Shortly after a merge, new SNMP profiles are automatically available by pulling the new version of the Docker image and launching a new container in your environment. For more information, see our documentation about SNMP manual setup. Tip Be sure to sync your fork regularly to keep it up to date with changes in the upstream repo. What kinds of OIDs should I actually include in a profile? In many cases SNMP offers a lot of data, but much of that data does not provide actionable information. Or, the data provides value that is so uncommon and low impact, it might not be worth bringing into your New Relic account. You want to focus on collecting data that lets you know if there is anything that would stop the device from being able to perform whatever functions you expect it to perform. Building on from that, you should collect measurements that tell you how well it is performing those functions. Example 1: For a device operating as a VPN concentrator, we would collect high-level system metrics like: CPU and memory utilization Hardware sensor information to make sure that the device isn't going to shut itself down due to things like fan failures OIDs that tell us about the aggregated connections and throughput Example 2: An example of data that is available but provides very poor value is an OID table that lists all the running processes on a network appliance. Coming from a server admin perspective, that might sound useful, but since this is an appliance, you normally do not have the capability or the need to do anything with the processes that run inside it. Polling and storing tables with hundreds of items that you can't actually do anything with would not be efficient. Use custom profiles privately For cases where you want to make a change to a profile, but you know that it is a scenario that is very unique and would not apply to other customers you can locally edit the profiles. The way this is done is by using Docker's volume mount to pass in your customized files to the ktranslate container inside the etc/ktranslate/profiles/ directory. There are other ways you could accomplish this but in this example we will demonstrate using a git fork and clone. Ensure you are in the directory you want to keep the files in, then clone your fork of the GitHub repo to your Docker host: git clone https://github.com/<YourGitUser>/snmp-profiles.git Copy Get the command you would normally use to launch the SNMP container, and add a second volume mount argument after the one where we passed in the snmp-base.yaml. -v `pwd`/snmp-profiles/profiles:/etc/ktranslate/profiles \\ Copy The mount command replaces the built-in profiles directory with your customized data. The end result will be be similar to this: docker run -ti --name ktranslate-discovery --rm --net=host \\ --user `id -u`:`id -g` \\ -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ -v `pwd`/snmp-profiles/profiles:/etc/ktranslate/profiles \\ kentik/ktranslate:v2 \\ -snmp /snmp-base.yaml \\ -log_level info \\ -snmp_discovery=true Copy Tip Be sure to pass your custom version of the profiles in every time you launch a discovery container or SNMP polling container. If you don't use it consistently for all SNMP instances sets, this can cause unreliable behavior.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 308.21332,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Network</em> <em>performance</em> <em>monitoring</em>",
        "body": ": A GitHub account: This enables you to raise issues and contribute changes to Kentik&#x27;s open source profiles. An SNMP walk from a <em>network</em> device where you want to work on a profile. For more information, see our documentation on setting up SNMP and using snmpwalk. Permissions to <em>perform</em> Docker pull"
      },
      "id": "61b33254196a67414ea5c67b"
    },
    {
      "sections": [
        "ktranslate Docker container health monitoring",
        "Logs from ktranslate",
        "Tip",
        "Optional log parsing rule",
        "Common log searches",
        "What version of ktranslate am I running?",
        "What arguments were passed to Docker at runtime?",
        "What errors am I experiencing?",
        "Is my match_attributes filter working on my device?",
        "Metrics from ktranslate",
        "Common metrics searches",
        "What are the current versions of my ktranslate applications?",
        "What is the health of my ktranslate application?",
        "What is the health of my deliveries to New Relic One?",
        "What is the health of my SNMP collection overall?",
        "What devices are failing SNMP collection?",
        "What is the health of my flow data collection?",
        "What is the health of my syslog collection?"
      ],
      "title": "ktranslate Docker container health monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring"
      ],
      "external_id": "a6a4a6194c420409a30f75d437e27998235b84bc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/advanced/ktranslate-container-health/",
      "published_at": "2021-12-30T03:02:12Z",
      "updated_at": "2021-12-16T01:45:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "While running the ktranslate Docker container for New Relic network performance monitoring, you can monitor the health of the container to proactively detect potential issues. The ktranslate container image has the -tee_logs=true and -metrics=jchf settings available during runtime, which allow it to send health metrics into New Relic One directly. These are enabled by default when installing network performance monitoring via the New Relic One guided install. We recommend you to set them up when installing network performance monitoring manually. Logs from ktranslate Tip If you want to check the logs locally from the Docker host, run docker logs $CONTAINER_NAME. For example, docker logs ktranslate-snmp. The -tee_logs=true option sends logs to New Relic One when polling devices. To see them, do the following: Go to one.newrelic.com > Logs. In Find logs where, enter collector.name:\"ktranslate\" and click Query logs. Optional log parsing rule We recommend you to add a parsing rule to New Relic One logs to break the logs from ktranslate into fields that are easily searchable. This is especially helpful when you are running more than one container as it allows you to then search by the value of --service_name from the Docker container. Using the New Relic One logs UI, use the following patterns: Rule Name: ktranslate-health logs Query Attribute: \"plugin.type\" Query Value: \"ktranslate-health\" Parsing logic: %{NOTSPACE:time} ktranslate/%{NOTSPACE:container_service} \\[%{NOTSPACE:severity}\\] %{GREEDYDATA:message} Copy Alternatively, you can use New Relic's Nerdgraph API to manage your parsing rules. A sample of the logConfigurationsCreateParsingRule is below, you will need to replace $ACCOUNT_ID with the ID of your target account. mutation { logConfigurationsCreateParsingRule( accountId: $ACCOUNT_ID, rule: { description: \"ktranslate-health logs\", enabled: true, grok: \"%{NOTSPACE:time} ktranslate/%{NOTSPACE:container_service} \\\\[%{NOTSPACE:severity}\\\\] %{GREEDYDATA:message}\", lucene: \"\\\"plugin.type\\\":\\\"ktranslate-health\\\"\", nrql: \"SELECT * FROM Log WHERE `plugin.type` = 'ktranslate-health'\" } ) { errors { message type } rule { accountId id enabled description grok lucene nrql } } } Copy The result of this parsing rule is splitting a raw message from this: { \"collector.name\": \"ktranslate\", \"instrumentation.provider\": \"kentik\", \"message\": \"2021-12-08T14:59:56.007 ktranslate/snmp [Info] nrmFormat New Metadata for cisco-7513\", \"newrelic.source\": \"api.logs\", \"plugin.type\": \"ktranslate-health\", \"timestamp\": 1638975596000 } Copy To this, creating the searchable fields of container_service, severity, and time; as well as trimming the message field to more actionable data: { \"collector.name\": \"ktranslate\", \"container_service\": \"snmp\", \"instrumentation.provider\": \"kentik\", \"message\": \"nrmFormat New Metadata for cisco-7513\", \"newrelic.source\": \"api.logs\", \"plugin.type\": \"ktranslate-health\", \"severity\": \"Info\", \"time\": \"2021-12-08T15:29:56.026\", \"timestamp\": 1638977396000 } Copy Common log searches Below are some common searches that can be used during troubleshooting to gather data for support: What version of ktranslate am I running? Logs UI: bash Copy $ collector.name:\"ktranslate\" message:\"*KTranslate Running -- Version*\" NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `message` LIKE '%KTranslate Running -- Version%' Copy Expected Results: bash Copy $ KTranslate Running -- Version kt-2021-12-06-1546870234; Build Mon Dec 6 22:22:56 UTC 2021 What arguments were passed to Docker at runtime? Logs UI: bash Copy $ collector.name:\"ktranslate\" message:\"*KTranslate CLI:*\" NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `message` LIKE '%KTranslate CLI:%' Copy Expected Results: bash Copy $ KTranslate CLI: [ktranslate -listen off -mapping /etc/ktranslate/config.json -geo /etc/ktranslate/GeoLite2-Country.mmdb -udrs /etc/ktranslate/udr.csv -api_devices /etc/ktranslate/devices.json -asn /etc/ktranslate/GeoLite2-ASN.mmdb -log_level info -snmp /snmp-base.yaml -nr_account_id=2583772 -log_level=info -metrics=jchf -tee_logs=true -service_name=snmp nr1.snmp] What errors am I experiencing? Without a parsing rule applied to your logs Logs UI: bash Copy $ collector.name:\"ktranslate\" message:-*\\[Info\\]* NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `message` NOT LIKE '%[Info]%' Copy With a parsing rule applied to your logs Logs UI: bash Copy $ collector.name:\"ktranslate\" severity:-\"Info\" NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `severity` != 'Info' Copy Expected Results: bash Copy $ KTranslate>cisco-7513 There was an SNMP polling error with the CustomDeviceMetrics walking OID .1.3.6.1.2.1.4.31.1.1.21 after 0 retries: request timeout (after 0 retries). Is my match_attributes filter working on my device? Logs UI: bash Copy $ collector.name:\"ktranslate\" message:\"*Match Attribute*\" NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `message` LIKE '%Match Attribute%' Copy Expected Results: bash Copy $ KTranslate>cisco-7513 Added 1 Match Attribute(s) All devices are expected to have at least 1 Match Attribute inherited from the default monitor_admin_shut: true configuration. You should expect a value of 2 to be shown for a device that you have added a single match attribute to. Tip You can further filter these results by adding the device name to your query: collector.name:\"ktranslate\" message:\"*$DEVICE_NAME*Match Attribute*\". Metrics from ktranslate The -metrics option captures the following performance metrics when polling devices: Metric Granularity Description baseserver_healthcheck_execution_total Top Level Rate of internal health checks. Shows mostly that things are not deadlocked and should always be greater than 0. inputq Top Level Messages per second (msg/sec) received over the last 60 seconds from all SNMP, Flow, and VPC inputs combined. jchfq Top Level Gauge rate with number of available pre-allocated buffers. It should be about 8,000. delivery_metrics_nr Delivery to New Relic One Batches per second (batches/sec) sent over the last 60 seconds for all metrics to New Relic One. delivery_logs_nr Delivery to New Relic One Logs per second (logs/sec) sent over the last 60 seconds for all logs to New Relic One. delivery_wins_nr Delivery to New Relic One Wins per second (wins/sec) of 200 HTTP codes received over the last 60 seconds from sending metrics and events to New Relic One. device_metrics SNMP Polls per second (polls/sec) of SNMP polling over the last 60 seconds for device level metrics. interface_metrics SNMP Polls per second (polls/sec) of SNMP polling over the last 60 seconds for interface level metrics. snmp_fail SNMP Gauge to monitor if SNMP polling is working faceted by device_name. Where 1 means good and 2 means fail. netflow.flows Netflow Flows per second (fps) received over the last 60 seconds for all device flow data: IPFIX, NetFlow, or sFlow. syslog_queue Syslog Gauge of syslog messages waiting to be processed. syslog_errors Syslog Errors per second (errors/sec) over the last 60 seconds while processing syslog messages. syslog_messages Syslog Messages per second (msg/sec) received over the last 60 seconds for all syslog data. Common metrics searches To see these metrics in New Relic One: Go to one.newrelic.com and click Query your data. Enter one of the following NRQL queries: What are the current versions of my ktranslate applications? FROM Metric SELECT latest(ver) AS 'image_version' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What is the health of my ktranslate application? FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.baseserver_healthcheck_execution_total) AS 'healthcheck_total', latest(kentik.ktranslate.chf.kkc.inputq) AS 'input_per_second', latest(kentik.ktranslate.chf.kkc.jchfq) AS 'buffer' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What is the health of my deliveries to New Relic One? FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.delivery_metrics_nr) AS 'delivery_metric_batches_per_second', latest(kentik.ktranslate.chf.kkc.delivery_logs_nr) AS 'delivery_logs_per_second', latest(kentik.ktranslate.chf.kkc.delivery_wins_nr) AS 'delivery_wins_per_second' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What is the health of my SNMP collection overall? FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.device_metrics) AS 'device_polls_per_second', latest(kentik.ktranslate.chf.kkc.interface_metrics) AS 'interface_polls_per_second' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What devices are failing SNMP collection? SELECT max(snmp_fail) FROM ( FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.snmp_fail) AS 'snmp_fail' FACET host AS 'docker_host', svc AS 'container_service', device_name AS 'snmp_device' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' ) FACET docker_host, container_service, snmp_device WHERE snmp_fail = 2 Copy What is the health of my flow data collection? FROM Metric SELECT max(kentik.ktranslate.chf.kkc.netflow) AS 'flows_per_second' FACET host AS 'docker_host', svc AS 'container_service', device_name AS 'flow_device' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What is the health of my syslog collection? FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.syslog_queue) AS 'syslog_queue_total', latest(kentik.ktranslate.chf.kkc.syslog_errors) AS 'syslog_errors_per_second', latest(kentik.ktranslate.chf.kkc.syslog_messages) AS 'syslog_messages_per_second' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 270.74878,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>ktranslate</em> Docker container health <em>monitoring</em>",
        "sections": "<em>ktranslate</em> Docker container health <em>monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": "While running the <em>ktranslate</em> Docker container for New Relic <em>network</em> <em>performance</em> <em>monitoring</em>, you can <em>monitor</em> the health of the container to proactively detect potential issues. The <em>ktranslate</em> container image has the -tee_logs=true and -metrics=jchf settings available during runtime, which allow"
      },
      "id": "61b9389528ccbcb4d396ee5e"
    }
  ],
  "/docs/network-performance-monitoring/advanced/snmp-profiles": [
    {
      "sections": [
        "Advanced configuration for Network Performance Monitoring",
        "SNMP-base YAML sample file",
        "Devices section",
        "Trap section",
        "Discovery section",
        "Global section",
        "Optional SNMPv3 configuration",
        "Tip",
        "Optional external config files",
        "Discovery CIDRs",
        "Devices",
        "The match_attributes attribute",
        "Default 'OR' with null and empty values",
        "'AND', omit null and empty values",
        "Single match, omit null and empty values",
        "The flow_only attribute",
        "The response_time and ping_only attributes",
        "Flow data application mapping",
        "Flow data input filtering",
        "Example Filters"
      ],
      "title": "Advanced configuration for Network Performance Monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Advanced configuration"
      ],
      "external_id": "61f8c58056547c4a9a2c534617559472e3e62fd1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/advanced/advanced-config/",
      "published_at": "2021-12-30T03:03:15Z",
      "updated_at": "2021-12-19T05:14:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you want to explore all the options you can use when configuring the monitoring of your network performance, see the following sections. SNMP-base YAML sample file Here's an example of the various configuration options available in the snmp-base.yaml file used by the ktranslate docker image to poll for SNMP and flow data devices. You can also see a heavily-commented sample in the ktranslate repository on GitHub. devices: # Sample of SNMP v2c device ups_snmpv2c__10.10.0.201: device_name: ups_snmpv2c device_ip: 10.10.0.201 snmp_comm: public oid: .1.3.6.1.4.1.318.1.3.27 description: \"APC Web/SNMP Management Card (MB:v4.1.0 PF:v6.2.1 PN:apc_hw05_aos_621.bin AF1:v6.2.1 AN1:apc_hw05_sumx_621.bin MN:AP9537SUM HR:05 SN: ABC123DEF456 MD:05/21/2016) (Embedded PowerNet SNMP Agent SW v2.2 compatible)\" last_checked: 2021-11-09T18:14:59.907821489Z mib_profile: apc_ups.yml provider: kentik-ups poll_time_sec: 300 retries: 1 timeout_ms: 5000 user_tags: owning_team: dc_ops discovered_mibs: - PowerNet-MIB_UPS - TCP-MIB - UDP-MIB # Sample of SNMP v3 device router_snmpv3__10.10.0.202: device_name: router_snmpv3 device_ip: 10.10.0.202 snmp_v3: user_name: userNamev3 authentication_protocol: MD5 authentication_passphrase: authPassPrivacy privacy_protocol: AES256 privacy_passphrase: passPrivacy oid: .1.3.6.1.4.1.9.1.544 description: \"Cisco IOS Software, 3800 Software (C3845-ADVENTERPRISEK9-M), Version 15.1(3)T4, RELEASE SOFTWARE (fc1)\\r\\nTechnical Support: http://www.cisco.com/techsupport\\r\\nCopyright (c) 1986-2012 by Cisco Systems, Inc.\\r\\nCompiled Thu 24-May-12 04:27 by prod_rel_team\" last_checked: 2021-11-09T18:14:59.907821489Z mib_profile: cisco-asr.yml provider: kentik-router user_tags: owning_team: core-networking discovered_mibs: - BGP4-MIB - CISCO-MEMORY-POOL-MIB - CISCO-PROCESS-MIB - IF-MIB - OSPF-MIB engine_id: \"80:00:01:01:0a:14:1e:28\" match_attributes: if_interface_name: \"^Ten.*|^Gig.*\" \"!if_Alias\": \"[Uu]plink\" # Sample of SNMP v1 device netbotz_snmpv1__10.10.0.203: device_name: netbotz_snmpv1 device_ip: 10.10.0.201 snmp_comm: public use_snmp_v1: true oid: .1.3.6.1.4.1.5528.100.20.10.2013 description: \"Linux netbotz930A7A 2.6.12 #307 Wed Dec 29 15:25:32 EST 2010 ppc\" last_checked: 2021-11-09T18:14:59.907821489Z mib_profile: apc-netbotz.yml provider: kentik-netbotz user_tags: owning_team: sys_ops discovered_mibs: - IF-MIB - IP-MIB - TCP-MIB - UDP-MIB no_use_bulkwalkall: true # Sample of \"flow only\" device flow_only__10.10.0.210: device_name: flow_only device_ip: 10.10.0.210 user_tags: owning_team: net_eng flow_only: true # Sample of \"ping only\" device ping_only__10.10.0.220: device_name: ping_only device_ip: 10.10.0.220 user_tags: owning_team: load_balancing ping_only: true trap: listen: 127.0.0.1:1162 community: public version: \"\" transport: \"\" v3_config: null discovery: cidrs: - 10.0.0.0/24 - 10.0.0.202/32 debug: false ports: - 161 - 1161 default_communities: - public - public123 - Publ!cABC use_snmp_v1: false default_v3: null add_mibs: true threads: 4 add_devices: true replace_devices: true no_dedupe_engine_id: false global: poll_time_sec: 60 drop_if_outside_poll: false mib_profile_dir: /etc/ktranslate/profiles mibs_db: /etc/ktranslate/mibs.db mibs_enabled: - BGP4-MIB - CISCO-MEMORY-POOL-MIB - CISCO-PROCESS-MIB - IF-MIB - IP-MIB - OSPF-MIB - PowerNet-MIB_UPS - TCP-MIB - UDP-MIB timeout_ms: 3000 retries: 0 global_v3: null response_time: false user_tags: environment: production match_attributes: if_Description: \".*WAN.*\" Copy Devices section Key name Required Description device_name ✓ Name of the device. This is the unique identifier for the device in New Relic One. device_ip ✓ Target IP of the device. snmp_comm ✓ (Required for SNMPv1/2c) SNMPv1/2c community string to use. use_snmp_v1 ✓ (Required for SNMPv1) Indicates whether to use SNMPv1. By default, it's set to false. snmp_v3 ✓ (Required for SNMPv3) SNMP v3 config debug Indicates whether to enable debug level logging during SNMP polling. By default, it's set to false. port Port to send SNMP queries to. By default, it's set to port 161. oid ✓ (Required for SNMP polling) The discovered systemObjectID | sysObjectID | sysOID for the device. This is used to match the device to a known SNMP profile and set the provider attribute. If no match is found, this sets the provider as a kentik-default device. description The discovered sysDescr of the device. This field is informational. last_checked Timestamp when this device was last discovered by the ktranslate docker image. This field is informational. mib_profile ✓ (Required for SNMP polling) SNMP Profile file that was associated with this device during the discovery run based on its sysOID. If this starts with a bang (!) token, it will override the automatic matching from the sysOID and use a manual override. Ex: \"!cisco-asa.yml\" (quotes are required). provider ✓ (Required for New Relic One) Value used during entity synthesis for New Relic One. This is automatically created based on the matched mib_profile. poll_time_sec Indicates the SNMP polling frequency in seconds. This setting is used to override the global.poll_time_sec attribute. retries Indicates the number of attempts to retry polling SNMP OIDs. This setting is used to override the global.retries attribute. timeout_ms Indicates the SNMP polling timeout in milliseconds. This setting is used to override the global.timeout_ms attribute. user_tags key:value pair attributes to give more context to the device. Tags at this level will be appended to any tags applied in the global.user_tags attribute. discovered_mibs List of MIBs pulled from matched mib_profile that this device can respond to. This field is informational. engine_id The unique engine ID discovered for this device's SNMP agent. Generally found during SNMP v3 discovery. This field is informational. match_attributes attribute:regex pairs to add metrics to allowlist. Pairs at this level will be appended to any pairs applied in the global.match_attributes attribute. Uses the RE2 syntax and has a default OR operator. Prefix key with ! to force to AND operators. monitor_admin_shut Indicates whether to monitor interfaces in Administratively Shutdown status. By default, it's set to false. no_use_bulkwalkall Disables the SNMP GETBULK request action when true. By default, it's set to false. ping_only Disables all SNMP polling and enables response time polling when true. This setting is used to override the global.response_time attribute. By default, it's set to false. flow_only Disables all SNMP polling when true. By default, it's set to false. Trap section Key name Required Description listen ✓ Listening IP port for receiving SNMP traps. By default it's set to 127.0.0.1:1162, using the SNMP Trap default of 162 requires running Docker as root. community SNMPv1/v2c community string for receiving SNMP traps. version SNMP version to use. Options are v1, v2c, and v3. By default, it's set to v2c. transport SNMP transport protocol to use. Options are TCP and UDP. By default, it's set to UDP v3_config SNMP v3 config to use. Only used if version: v3. Discovery section Key name Required Description cidrs ✓ Array of target IP ranges in CIDR notation. debug Indicates whether to enable debug level logging during discovery. By default, it's set to false ports ✓ Array of target ports to scan during SNMP polling. default_communities ✓ (Required for SNMPv1/2c) Array of SNMPv1/v2c community strings to scan during SNMP polling. This array is evaluated in order and discovery accepts the first passing community. use_snmp_v1 ✓ (Required for SNMPv1) Indicates whether to use SNMPv1 during discovery. By default, it's set to false default_v3 ✓ (Required for SNMPv3) SNMPv3 configuration to scan during SNMP polling. add_devices ✓ Indicates whether to add discovered devices to the devices section of the snmp-base.yaml file. By default, it's set to true. add_mibs ✓ Indicates whether to add discovered MIBs to the global.mibs_enabled section of the snmp-base.yaml file. By default, it's set to true. threads ✓ Integer limit of threads to use during discovery. It should be less than the number of cores available to the container. By default it's set to 4. replace_devices ✓ Indicates whether to replace discovered devices if they already exist in the devices section of the snmp-base.yaml file. By default, it's set to false. no_dedup_engine_id When set to true, disables deduplication of discovered devices if it appears that they are the same device, based on their reported SNMP engine ID. By default, it's set to false Global section Key name Required Description poll_time_sec ✓ Time in seconds to poll devices. This can be overridden per device using the devices.<deviceName>.poll_time_sec attribute. By default, it's set to 60. drop_if_outside_poll Indicates whether to drop all values from this cycle if polling takes longer than the value set in poll_time_sec. By default, it's set to false mib_profile_dir Directory to find curated MIB profiles. These are pulled into the ktranslate image automatically from Kentik's snmp-profiles repository and can be overridden at Docker runtime by creating a volume mount of your own local directory of profiles. mibs_db mibs_enabled ✓ Array of all active MIBs the ktranslate docker image will poll. This list is automatically generated during discovery if the discovery_add_mibs attribute is true. MIBs not listed here will not be polled on any device in the configuration file. You can specify a SNMP table directly in a MIB file using MIB-NAME.tableName syntax. Ex: HOST-RESOURCES-MIB.hrProcessorTable. timeout_ms ✓ Time in milliseconds SNMP queries timeout. This can be overridden per device using the devices.<deviceName>.timeout_ms attribute. By default, it's set to 5000 retries ✓ Number of attempts to retry failed SNMP polls. This can be overridden per device using the devices.<deviceName>.retries attribute. By default, it's set to 0 user_tags key:value pair attributes to give more context to the device. Tags at this level will be applied to all devices in the configuration file. match_attributes attribute:regex pairs to add metrics to allowlist. Pairs at this level will matched against all devices in the configuration file. Uses the RE2 syntax and has a default OR operator. Prefix key with ! to force to AND operators. response_time Indicates whether response time polling is enabled for all devices in the configuration file. By default, it's set to false. Optional SNMPv3 configuration Key name Required Description user_name ✓ User name for SNMPv3 authentication authentication_protocol ✓ SNMPv3 authentication protocol. The possible values are NoAuth, MD5, or SHA authentication_passphrase SNMPv3 authentication passphrase privacy_protocol ✓ SNMPv3 privacy protocol. The possible values are AuthNoPriv, DES, AES, AES192, AES256, AES192C, or AES256C privacy_passphrase SNMPv3 privacy passphrase context_engine_id SNMPv3 context engine ID context_name SNMPv3 context name Tip You can use AWS Secrets Manager natively in your SNMP v3 config using the aws.sm.$SECRET_NAME syntax, replacing $SECRET_NAME as necessary to have ktranslate pull in your credentials during Docker runtime. Optional external config files To support a wide variety of configuration and automation needs, you can use external files that you volume mount into your Docker container to decouple certain elements of the standard configuration file. The syntax for these files is \"@fileName.extension\", including the double quotes. Discovery CIDRs Example: discovery: cidrs: \"@cidrs.yaml\" Copy The CIDRs file should use a YAML list syntax like this: - 10.10.0.0/24 - 10.20.0.0/24 - 192.168.0.21/32 Copy Devices Example: devices: - \"@neteng-devices.yaml\" - \"@dc-ops.yaml\" Copy The device files should use the same syntax as the standard devices section of the main config file, omitting the optional fields that are generated during discovery: devices: # Sample of SNMP v2c device ups_snmpv2c__10.10.0.201: device_name: ups_snmpv2c device_ip: 10.10.0.201 snmp_comm: public oid: .1.3.6.1.4.1.318.1.3.27 mib_profile: apc_ups.yml provider: kentik-ups poll_time_sec: 300 retries: 1 timeout_ms: 5000 user_tags: owning_team: dc_ops Copy The match_attributes attribute To support filtering of data that does not create value for your observability needs, you can set the global.match_attributes.{} and/or devices.<deviceName>.match_attributes.{} attribute map. This will provide filtering at the ktranslate level, before shipping data to New Relic, giving you granular control over monitoring of things like interfaces. The default behavior of this map is an OR condition, but you can override this and force an AND operator by prefixing your key name with !. This is also useful to return only matched items and omit all null and \"\" (empty) results. Default 'OR' with null and empty values Match when if_Alias begins with Uplink OR when if_interface_name begins with Gig, keep all null and \"\" values: devices: deviceName: ... match_attributes: if_Alias: \"^Uplink.*\" if_interface_name: \"^Gig.*\" Copy 'AND', omit null and empty values Match when if_Alias begins with Uplink AND when if_interface_name begins with Gig, drop all null and \"\" values: devices: deviceName: ... match_attributes: if_Alias: \"^Uplink.*\" \"!if_interface_name\": \"^Gig.*\" Copy Single match, omit null and empty values Match when if_Alias begins with Uplink, drop all null and \"\" values: devices: deviceName: ... match_attributes: \"!if_Alias\": \"^Uplink.*\" Copy The flow_only attribute To support monitoring of devices where performance statistics are nor accessible, available, or desired, you can set the devices.<deviceName>.flow_only attribute to true. This will generate a Flow Device entity in New Relic One which will only have telemetry in the KFlow event namespace. Alternatively, collecting flow telemetry from a device that is in your configuration file as an SNMP device will add decoration of the KFlow data to the pre-existing entity, such as a Router or Firewall. In New Relic One, you can see the results of this polling by investigating the following events: FROM KFlow SELECT count(*) FACET device_name WHERE instrumentation.name = 'netflow-events' TIMESERIES Copy The response_time and ping_only attributes To support monitoring of devices where performance statistics are not accessible or available, or in simple cases where basic round-trip time (RTT) monitoring is required, you can either set the global.response_time or devices.<deviceName>.ping_only attributes to true. This feature uses the go-ping package to send unprivileged UDP packets to devices in order to collect the average, min, and max RTT for the endpoint based on sending 1 packet/sec from ktranslate to the device IP address. Setting the global.response_time attribute to true will add RTT monitoring on top of existing SNMP polling. devices.<deviceName>.ping_only: true will allow you to monitor devices with only the UDP packets for RTT and no SNMP polling. In New Relic One, you can see the results of this polling by investigating the following metrics: FROM Metric SELECT average(kentik.ping.AvgRttMs) AS 'Average', max(kentik.ping.MaxRttMs) AS 'Max', min(kentik.ping.MinRttMs) AS 'Min' FACET device_name TIMESERIES Copy Tip You can use the ping_only attribute in replacement of the flow_only attribute if you would like to collect RTT metrics from a flow device. If both ping_only and flow_only are true, the device will be treated as a flow_only device. Flow data application mapping By default, flow telemetry is mapped to known applications based on evaluation of the layer 4 port in use on a specific flow conversation. If needed, you can override the default mapping by providing a YAML file during Docker runtime to the -application_map flag. This will allow you to specify application names based on ports you identify. Example syntax: applications: - ports: [9092, 9093] name: kafka - ports: [80, 8080] name: http - ports: [443, 8443] name: https Copy Flow data input filtering By default, flow data containers will collect and process every flow packet they receive. If needed, you can add an inclusion filter to the -nf.source flag that will ignore all traffic not matching the filter you provide. Syntax: --filters $TYPE,$FIELD,$FUNCTION,$MATCH Argument Name Required Description $TYPE ✓ The type of filter to apply. Possible values are string, int, and addr. $FIELD ✓ The name of the field to evaluate the match pattern against. $FUNCTION ✓ The type of function to use during evaluation. Possible values are Equal: ==, NotEqual: !=, LessThan: <, GreaterThan: >, Contains: % $MATCH ✓ The value to be used as a match pattern. Example Filters Only collect flow data from source addresses in the 10.0.0.0/24 CIDR range -nf.source sflow --filters addr,src_addr,%,10.10.0.0/24 Copy Only collect flow data where the destination port is not equal to 8531 -nf.source netflow5 --filters int,l4_dst_port,!=,8531 Copy You can also add multiple filters together with an inherited AND operator Only collect flow data from source addresses in the 10.0.0.0/24 CIDR range AND where the destination port is not equal to 8531 --filters addr,src_addr,%,10.0.0.0/24 --filters int,l4_dst_port,!=,8531 Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 223.27704,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Advanced</em> <em>configuration</em> for <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "sections": "<em>Advanced</em> <em>configuration</em> for <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "tags": "<em>Network</em> <em>performance</em> <em>monitoring</em>",
        "body": "If you want to explore all the options you can use when configuring the <em>monitoring</em> of your <em>network</em> <em>performance</em>, see the following sections. SNMP-base YAML sample file Here&#x27;s an example of the various <em>configuration</em> options available in the snmp-base.yaml file used by the ktranslate docker image"
      },
      "id": "61b9389664441f8fc3d7182e"
    },
    {
      "sections": [
        "Managing the 'ktranslate' Docker container",
        "Container requirements",
        "Tip",
        "Updating the container",
        "Important",
        "Container runtime options"
      ],
      "title": "Managing the 'ktranslate' Docker container",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Advanced configuration",
        "ktranslate"
      ],
      "external_id": "4e9ead4f2e8850ba061754bccb3fe5eed25b8c56",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/advanced/ktranslate-container-management/",
      "published_at": "2021-12-30T03:02:29Z",
      "updated_at": "2021-12-19T05:13:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This page outlines the options for management of the ktranslate container used by New Relic NPM. Container requirements We recommend the following resources for the ktranslate container image: Disk 100MB available disk space CPU SNMP Polling/Trap Collection: 1 CPU core dedicated for every ~1,000 devices Device Flow Collection: 1 CPU core dedicated for every ~2,000 flows per second (fps) Syslog Message Collection: 1 CPU core dedicated for every ~2,000 messages per second Memory ktranslate is not generally constrained by memory resources. The amount of memory on your host should be driven by the types of applications/containers you plan to run. For a general idea, we commonly see success with image sizes as small as the AWS t2.micro which has 1 vCPU and 1.0 GB of available RAM. Tip The ktranslate container image runs a single \"job type\" at a time. For instance, a container deployed for SNMP polling and trap collection will not be used for flow collection. Furthermore, containers deployed for flow collection are limited to a single -nf.source type per container. This means that it is common to have multiple containers deployed to a single Docker host at any given time. They can also share a common configuration file, but do not have to. Updating the container Keeping the ktranslate container image up to date is good practice to both receive the latest updates and resolve common problems through various bug fixes applied during the development lifecycle. It is recommended to always pull the latest available image when redeploying your containers. Pull the latest container image available bash Copy $ docker pull kentik/ktranslate:v2 Collect the IDs and names of any existing containers bash Copy $ docker ps -a --filter ancestor=kentik/ktranslate:v2 --format \"{{.ID}} - {{.Names}}\" Output Example: 3297b134a352 - ktranslate-snmp 4962a854b386 - ktranslate-sflow Copy Remove any pre-existing containers bash Copy $ docker rm -f $CONTAINER_ID Redeploy your ktranslate container using the original settings you deployed with from either SNMP, flow data, or syslog collection. Important The configuration file used by ktranslate is applied to the container at runtime. Changes to this file require you to remove and restart your running container(s) to apply the edits. Container runtime options Below are the various options available during Docker runtime for the ktranslate container image: Option name Type Required Description -snmp Flag ✓ Sets the path to the snmp-base.yaml file on the Docker container, based on the volume mount from the Docker host passed as an option during runtime. -nr_account_id Flag ✓ The New Relic One account ID that ktranslate will ship data to. -log_level Flag Overrides the default info log level for ktranslate. The available options are debug, info, warn, or error. -snmp_discovery Flag Used to setup the container in SNMP discovery mode. -tee_logs Flag Forwards Docker logs from ktranslate into New Relic One Logs. -metrics=jchf Flag Forwards health metrics from ktranslate into New Relic One. -service_name Flag Appended to the container name in Docker logs to help isolate logs from various containers in New Relic One Logs. -nr_region Flag Sets the regional API endpoints for ktranslate to forward telemetry to New Relic One. Options are US, EU, and GOV (FedRAMP). -max_threads Flag Lets you process higher volumes of data. We recommend one CPU core available for every 2,000 flows per second (fps) of network flow data sent, or every 1,000 SNMP devices being monitored, or every 2,000 syslog messages per second collected by a container. The default is 1. -sample_rate Flag Changes the default sample rate value at which flows are passed to New Relic One Events. This does not speed up the local configuration of flow sample rate on a device, but it can slow it down. Setting this to 1 will enable capturing all flows sent to the container. The default is 1000. -nf.workers Flag Overrides the number of workers used in processing network packets. Use one worker for every 4,000 of flows per second (fps) of network flow data sent. The default is 1. -nf.port Flag Overrides the listening port for incoming flow packets. The default is 9995. -nf.source Flag ✓ (For flow containers) Sets up the type of flow this container will process. Options are ipfix, netflow5, netflow9, and sflow. -application_map Flag Sets the path to an application map file on the Docker container, based on a volume mount from the Docker host passed as an option during runtime. -dns Flag Sets the IP:Port for ktranslate to use during DNS resolution of IP addresses. Setting this affects the results for the dst_host and src_host fields. nr1.flow Argument ✓ (For flow containers) This argument statically sets the following flags: compression: gzip, sink: new_relic, format: new_relic, max_before_sample: 100, flow_only:true. nr1.snmp Argument ✓ (For SNMP containers) This argument statically sets the following options: compression: gzip, sink: new_relic, format: new_relic_metric, max_flows_per_message: 100. nr1.syslog Argument ✓ (For syslog containers) This argument statically sets the following flags: compression: gzip, sink: new_relic, format: new_relic_metric, syslog:\"0.0.0.0:5143\". NEW_RELIC_API_KEY Environment Variable ✓ Environment variable that must be used during Docker runtime to hold the New Relic license key for ktranslate to send data to the New Relic APIs. Ex: -e NEW_RELIC_API_KEY=$LICENSE_KEY. HTTPS_PROXY Environment Variable Environment variable that can be used during Docker runtime to setup ktranslate to ship data to New Relic via proxy. Ex: -e HTTPS_PROXY=https://user:password@hostname:port.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 207.15709,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Network</em> <em>performance</em> <em>monitoring</em>",
        "body": " share a common <em>configuration</em> file, but do not have to. Updating the container Keeping the ktranslate container image up to date is good practice to both receive the latest updates and resolve common problems through various bug fixes applied during the development lifecycle. It is recommended"
      },
      "id": "61b9386a28ccbc8dca96f412"
    },
    {
      "sections": [
        "Visualize your network performance data in New Relic One",
        "Prerequisites",
        "Add the Network dashboards to your account",
        "Tip",
        "Start exploring your network performance data"
      ],
      "title": "Visualize your network performance data in New Relic One",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Monitoring"
      ],
      "external_id": "a9e82cf586cd71595b0fd3bdcc831768578417cf",
      "image": "https://docs.newrelic.com/static/f6a643a55e2f9a2b070d85ab9174ba48/c1b63/flow_data_dashboard.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/monitoring-network-data/visualize-network-data/",
      "published_at": "2021-12-30T09:50:55Z",
      "updated_at": "2021-12-30T09:50:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you set up your network data for performance monitoring, you can go to New Relic One and install several custom-curated visualizations designed specifically for network performance monitoring. Then, after you set up these visualizations, you can start exploring the network data your devices are reporting to New Relic One. You can group and monitor your switches, routers, etc. in dashboards. This helps you quickly aggregate, isolate, and analyze the health of your network. For some examples of monitoring your network in New Relic One, watch this short video (approx. 3:45 minutes). Prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. Having set up your Network Performance Monitoring devices. Read how to: Set up SNMP data monitoring. Set up network flow data monitoring. Add the custom visualizations app to your account: Go to one.newrelic.com > Apps, and search for Network Agent Visualizations. Click the app, and then click Open visualization. one.newrelic.com > Apps, and search for Network Agent Visualizations. From the Account ID dropdown, select the account you want to add the visualizations to, and click Enable. Add the Network dashboards to your account You can go to New Relic One and import several dashboards to see curated views of your network telemetry, including the GeoMap and Sankey custom visualizations from the prerequisites. Go to one.newrelic.com > Apps, and search for Quickstarts. Click Quickstarts. In the search bar, search for Network, then click one of the dashboards: Use the Network - Data Ingest and Cardinality dashboard to analyze usage trends. Use the Network - Routers and Switches dashboard for SNMP data from router and switch entities. Use the Network - Flow Devices dashboard for network flow data. one.newrelic.com > Apps, and search for Network. Click Import. Select the account where you want to add the dashboard. Optional: Edit the dashboard name. Click Import dashboard. Tip If you want to read more about custom visualizations in New Relic One, see the introduction to custom visualizations. Start exploring your network performance data Once you've finished setting up these dashboards, you can start seeing your network data by going to Dashboards or Explorer in New Relic One: From one.newrelic.com > Dashboards: For usage trend analysis, you'll see the following dashboard: Dashboard for analyzing network telemetry usage trends in New Relic One. For SNMP data, you'll see the following dashboard: Dashboard for SNMP data from router and switch entities in New Relic One. For network flow data, you'll see the following dashboard: Dashboard for network flow data monitoring in New Relic One. From one.newrelic.com > Explorer: Entities are listed under the Network category in the left-hand side menu. Open a specific device to see the details and trend of its performance. On the top right-hand side, click Lookout to see anomalies. Lookout view for Network Performance Monitoring in New Relic One. To learn how to troubleshoot network data in Navigator and Lookout, watch this short video (approx. 3:15 minutes).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 195.87666,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Visualize your <em>network</em> <em>performance</em> data in New Relic One",
        "sections": "Visualize your <em>network</em> <em>performance</em> data in New Relic One",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": "After you set up your <em>network</em> data for <em>performance</em> <em>monitoring</em>, you can go to New Relic One and install several custom-curated visualizations designed specifically for <em>network</em> <em>performance</em> <em>monitoring</em>. Then, after you set up these visualizations, you can start exploring the <em>network</em> data your devices"
      },
      "id": "6127249b64441f621ea47c42"
    }
  ],
  "/docs/network-performance-monitoring/get-started/npm-introduction": [
    {
      "sections": [
        "Visualize your network performance data in New Relic One",
        "Prerequisites",
        "Add the Network dashboards to your account",
        "Tip",
        "Start exploring your network performance data"
      ],
      "title": "Visualize your network performance data in New Relic One",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Monitoring"
      ],
      "external_id": "a9e82cf586cd71595b0fd3bdcc831768578417cf",
      "image": "https://docs.newrelic.com/static/f6a643a55e2f9a2b070d85ab9174ba48/c1b63/flow_data_dashboard.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/monitoring-network-data/visualize-network-data/",
      "published_at": "2021-12-30T09:50:55Z",
      "updated_at": "2021-12-30T09:50:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you set up your network data for performance monitoring, you can go to New Relic One and install several custom-curated visualizations designed specifically for network performance monitoring. Then, after you set up these visualizations, you can start exploring the network data your devices are reporting to New Relic One. You can group and monitor your switches, routers, etc. in dashboards. This helps you quickly aggregate, isolate, and analyze the health of your network. For some examples of monitoring your network in New Relic One, watch this short video (approx. 3:45 minutes). Prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. Having set up your Network Performance Monitoring devices. Read how to: Set up SNMP data monitoring. Set up network flow data monitoring. Add the custom visualizations app to your account: Go to one.newrelic.com > Apps, and search for Network Agent Visualizations. Click the app, and then click Open visualization. one.newrelic.com > Apps, and search for Network Agent Visualizations. From the Account ID dropdown, select the account you want to add the visualizations to, and click Enable. Add the Network dashboards to your account You can go to New Relic One and import several dashboards to see curated views of your network telemetry, including the GeoMap and Sankey custom visualizations from the prerequisites. Go to one.newrelic.com > Apps, and search for Quickstarts. Click Quickstarts. In the search bar, search for Network, then click one of the dashboards: Use the Network - Data Ingest and Cardinality dashboard to analyze usage trends. Use the Network - Routers and Switches dashboard for SNMP data from router and switch entities. Use the Network - Flow Devices dashboard for network flow data. one.newrelic.com > Apps, and search for Network. Click Import. Select the account where you want to add the dashboard. Optional: Edit the dashboard name. Click Import dashboard. Tip If you want to read more about custom visualizations in New Relic One, see the introduction to custom visualizations. Start exploring your network performance data Once you've finished setting up these dashboards, you can start seeing your network data by going to Dashboards or Explorer in New Relic One: From one.newrelic.com > Dashboards: For usage trend analysis, you'll see the following dashboard: Dashboard for analyzing network telemetry usage trends in New Relic One. For SNMP data, you'll see the following dashboard: Dashboard for SNMP data from router and switch entities in New Relic One. For network flow data, you'll see the following dashboard: Dashboard for network flow data monitoring in New Relic One. From one.newrelic.com > Explorer: Entities are listed under the Network category in the left-hand side menu. Open a specific device to see the details and trend of its performance. On the top right-hand side, click Lookout to see anomalies. Lookout view for Network Performance Monitoring in New Relic One. To learn how to troubleshoot network data in Navigator and Lookout, watch this short video (approx. 3:15 minutes).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 197.6978,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Visualize your <em>network</em> <em>performance</em> data in New Relic One",
        "sections": "<em>Start</em> exploring your <em>network</em> <em>performance</em> data",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": "After you set up your <em>network</em> data for <em>performance</em> <em>monitoring</em>, you can go to New Relic One and install several custom-curated visualizations designed specifically for <em>network</em> <em>performance</em> <em>monitoring</em>. Then, after you set up these visualizations, you can <em>start</em> exploring the <em>network</em> data your devices"
      },
      "id": "6127249b64441f621ea47c42"
    },
    {
      "sections": [
        "SNMP device profiles",
        "Get started",
        "Tip",
        "Make requests through GitHub",
        "Contribute profiles and modifications publicly",
        "What kinds of OIDs should I actually include in a profile?",
        "Use custom profiles privately"
      ],
      "title": "SNMP device profiles",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Advanced configuration"
      ],
      "external_id": "9b38a960070da5782cfd75e087db62f15fb71223",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/advanced/snmp-profiles/",
      "published_at": "2021-12-30T03:03:05Z",
      "updated_at": "2021-12-15T00:37:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Profiles define what SNMP OIDs we want to collect and send to your New Relic account. This document explains how to modify an existing profile or create a new profile. Get started If you've decided to build a custom profile or modify one of our open source profiles, you need a few essential tools: A GitHub account: This enables you to raise issues and contribute changes to Kentik's open source profiles. An SNMP walk from a network device where you want to work on a profile. For more information, see our documentation on setting up SNMP and using snmpwalk. Permissions to perform Docker pull on the server that hosts your ktranslate container. This document covers: Making requests for new or modified profiles through GitHub to be worked on by the maintainers Contributing your own profiles and modifications publicly Using custom profiles privately Tip Support for all things relating to kentik/snmp-profiles is handled through GitHub issues. New Relic technical support is not able to provide any additional help beyond redirecting you back to raise an issue there. Make requests through GitHub This is the most common and simple scenario, for cases where you don't have the time or expertise with SNMP to do these yourself. After you provide the relevant data, our team will build the profile for you. Log into GitHub and go to the snmp-profiles repo. Click the Issues tab near the top. Click New issue. To request a new profile, look for the SNMP Profile Request section, and click Get started. Provide all requested information in the template, such as the device vendor, model, snmp object identifier, and a sanitized SNMP walk. For all other requests, use Open a blank issue. Tip Providing an SNMP walk is critical as we cannot do any work on the profile without these. This is not the same as an MIB file. The maintainers of the repo will review the information you provided and, if there is anything missing, they will follow up with you. Once all the necessary data is provided, they will add it to the queue of profiles to be built. After it is added to the repo, the issue will be closed, and all you have to do is update the ktranslate docker container on your end, and the newest profiles will automatically be loaded. Contribute profiles and modifications publicly We gladly accept contributions from anyone who wants to help out to either create new profiles or improve the existing profiles. To familiarize yourself with the structure of a profile, review this highly commented template.yml on GitHub. Log into GitHub and go to the snmp-profiles repo. To create a copy of the same information in your account, click the fork button near the top. Within your fork,make necessary changes to the files, or create new vendor directories and profiles as needed. Be sure to pass your profile through a YAML validator, such as codebeautify, before submitting a pull request. When you are done with your changes, submit a pull request to the upstream repo. The maintainers will review the change, and discuss any necessary feedback. When everyone is aligned, it will be merged. Shortly after a merge, new SNMP profiles are automatically available by pulling the new version of the Docker image and launching a new container in your environment. For more information, see our documentation about SNMP manual setup. Tip Be sure to sync your fork regularly to keep it up to date with changes in the upstream repo. What kinds of OIDs should I actually include in a profile? In many cases SNMP offers a lot of data, but much of that data does not provide actionable information. Or, the data provides value that is so uncommon and low impact, it might not be worth bringing into your New Relic account. You want to focus on collecting data that lets you know if there is anything that would stop the device from being able to perform whatever functions you expect it to perform. Building on from that, you should collect measurements that tell you how well it is performing those functions. Example 1: For a device operating as a VPN concentrator, we would collect high-level system metrics like: CPU and memory utilization Hardware sensor information to make sure that the device isn't going to shut itself down due to things like fan failures OIDs that tell us about the aggregated connections and throughput Example 2: An example of data that is available but provides very poor value is an OID table that lists all the running processes on a network appliance. Coming from a server admin perspective, that might sound useful, but since this is an appliance, you normally do not have the capability or the need to do anything with the processes that run inside it. Polling and storing tables with hundreds of items that you can't actually do anything with would not be efficient. Use custom profiles privately For cases where you want to make a change to a profile, but you know that it is a scenario that is very unique and would not apply to other customers you can locally edit the profiles. The way this is done is by using Docker's volume mount to pass in your customized files to the ktranslate container inside the etc/ktranslate/profiles/ directory. There are other ways you could accomplish this but in this example we will demonstrate using a git fork and clone. Ensure you are in the directory you want to keep the files in, then clone your fork of the GitHub repo to your Docker host: git clone https://github.com/<YourGitUser>/snmp-profiles.git Copy Get the command you would normally use to launch the SNMP container, and add a second volume mount argument after the one where we passed in the snmp-base.yaml. -v `pwd`/snmp-profiles/profiles:/etc/ktranslate/profiles \\ Copy The mount command replaces the built-in profiles directory with your customized data. The end result will be be similar to this: docker run -ti --name ktranslate-discovery --rm --net=host \\ --user `id -u`:`id -g` \\ -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ -v `pwd`/snmp-profiles/profiles:/etc/ktranslate/profiles \\ kentik/ktranslate:v2 \\ -snmp /snmp-base.yaml \\ -log_level info \\ -snmp_discovery=true Copy Tip Be sure to pass your custom version of the profiles in every time you launch a discovery container or SNMP polling container. If you don't use it consistently for all SNMP instances sets, this can cause unreliable behavior.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 155.04675,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Get</em> <em>started</em>",
        "tags": "<em>Network</em> <em>performance</em> <em>monitoring</em>",
        "body": "Profiles define what SNMP OIDs we want to collect and send to your New Relic account. This document explains how to modify an existing profile or create a new profile. <em>Get</em> <em>started</em> If you&#x27;ve decided to build a custom profile or modify one of our open source profiles, you need a few essential tools"
      },
      "id": "61b33254196a67414ea5c67b"
    },
    {
      "sections": [
        "ktranslate Docker container health monitoring",
        "Logs from ktranslate",
        "Tip",
        "Optional log parsing rule",
        "Common log searches",
        "What version of ktranslate am I running?",
        "What arguments were passed to Docker at runtime?",
        "What errors am I experiencing?",
        "Is my match_attributes filter working on my device?",
        "Metrics from ktranslate",
        "Common metrics searches",
        "What are the current versions of my ktranslate applications?",
        "What is the health of my ktranslate application?",
        "What is the health of my deliveries to New Relic One?",
        "What is the health of my SNMP collection overall?",
        "What devices are failing SNMP collection?",
        "What is the health of my flow data collection?",
        "What is the health of my syslog collection?"
      ],
      "title": "ktranslate Docker container health monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring"
      ],
      "external_id": "a6a4a6194c420409a30f75d437e27998235b84bc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/advanced/ktranslate-container-health/",
      "published_at": "2021-12-30T03:02:12Z",
      "updated_at": "2021-12-16T01:45:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "While running the ktranslate Docker container for New Relic network performance monitoring, you can monitor the health of the container to proactively detect potential issues. The ktranslate container image has the -tee_logs=true and -metrics=jchf settings available during runtime, which allow it to send health metrics into New Relic One directly. These are enabled by default when installing network performance monitoring via the New Relic One guided install. We recommend you to set them up when installing network performance monitoring manually. Logs from ktranslate Tip If you want to check the logs locally from the Docker host, run docker logs $CONTAINER_NAME. For example, docker logs ktranslate-snmp. The -tee_logs=true option sends logs to New Relic One when polling devices. To see them, do the following: Go to one.newrelic.com > Logs. In Find logs where, enter collector.name:\"ktranslate\" and click Query logs. Optional log parsing rule We recommend you to add a parsing rule to New Relic One logs to break the logs from ktranslate into fields that are easily searchable. This is especially helpful when you are running more than one container as it allows you to then search by the value of --service_name from the Docker container. Using the New Relic One logs UI, use the following patterns: Rule Name: ktranslate-health logs Query Attribute: \"plugin.type\" Query Value: \"ktranslate-health\" Parsing logic: %{NOTSPACE:time} ktranslate/%{NOTSPACE:container_service} \\[%{NOTSPACE:severity}\\] %{GREEDYDATA:message} Copy Alternatively, you can use New Relic's Nerdgraph API to manage your parsing rules. A sample of the logConfigurationsCreateParsingRule is below, you will need to replace $ACCOUNT_ID with the ID of your target account. mutation { logConfigurationsCreateParsingRule( accountId: $ACCOUNT_ID, rule: { description: \"ktranslate-health logs\", enabled: true, grok: \"%{NOTSPACE:time} ktranslate/%{NOTSPACE:container_service} \\\\[%{NOTSPACE:severity}\\\\] %{GREEDYDATA:message}\", lucene: \"\\\"plugin.type\\\":\\\"ktranslate-health\\\"\", nrql: \"SELECT * FROM Log WHERE `plugin.type` = 'ktranslate-health'\" } ) { errors { message type } rule { accountId id enabled description grok lucene nrql } } } Copy The result of this parsing rule is splitting a raw message from this: { \"collector.name\": \"ktranslate\", \"instrumentation.provider\": \"kentik\", \"message\": \"2021-12-08T14:59:56.007 ktranslate/snmp [Info] nrmFormat New Metadata for cisco-7513\", \"newrelic.source\": \"api.logs\", \"plugin.type\": \"ktranslate-health\", \"timestamp\": 1638975596000 } Copy To this, creating the searchable fields of container_service, severity, and time; as well as trimming the message field to more actionable data: { \"collector.name\": \"ktranslate\", \"container_service\": \"snmp\", \"instrumentation.provider\": \"kentik\", \"message\": \"nrmFormat New Metadata for cisco-7513\", \"newrelic.source\": \"api.logs\", \"plugin.type\": \"ktranslate-health\", \"severity\": \"Info\", \"time\": \"2021-12-08T15:29:56.026\", \"timestamp\": 1638977396000 } Copy Common log searches Below are some common searches that can be used during troubleshooting to gather data for support: What version of ktranslate am I running? Logs UI: bash Copy $ collector.name:\"ktranslate\" message:\"*KTranslate Running -- Version*\" NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `message` LIKE '%KTranslate Running -- Version%' Copy Expected Results: bash Copy $ KTranslate Running -- Version kt-2021-12-06-1546870234; Build Mon Dec 6 22:22:56 UTC 2021 What arguments were passed to Docker at runtime? Logs UI: bash Copy $ collector.name:\"ktranslate\" message:\"*KTranslate CLI:*\" NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `message` LIKE '%KTranslate CLI:%' Copy Expected Results: bash Copy $ KTranslate CLI: [ktranslate -listen off -mapping /etc/ktranslate/config.json -geo /etc/ktranslate/GeoLite2-Country.mmdb -udrs /etc/ktranslate/udr.csv -api_devices /etc/ktranslate/devices.json -asn /etc/ktranslate/GeoLite2-ASN.mmdb -log_level info -snmp /snmp-base.yaml -nr_account_id=2583772 -log_level=info -metrics=jchf -tee_logs=true -service_name=snmp nr1.snmp] What errors am I experiencing? Without a parsing rule applied to your logs Logs UI: bash Copy $ collector.name:\"ktranslate\" message:-*\\[Info\\]* NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `message` NOT LIKE '%[Info]%' Copy With a parsing rule applied to your logs Logs UI: bash Copy $ collector.name:\"ktranslate\" severity:-\"Info\" NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `severity` != 'Info' Copy Expected Results: bash Copy $ KTranslate>cisco-7513 There was an SNMP polling error with the CustomDeviceMetrics walking OID .1.3.6.1.2.1.4.31.1.1.21 after 0 retries: request timeout (after 0 retries). Is my match_attributes filter working on my device? Logs UI: bash Copy $ collector.name:\"ktranslate\" message:\"*Match Attribute*\" NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `message` LIKE '%Match Attribute%' Copy Expected Results: bash Copy $ KTranslate>cisco-7513 Added 1 Match Attribute(s) All devices are expected to have at least 1 Match Attribute inherited from the default monitor_admin_shut: true configuration. You should expect a value of 2 to be shown for a device that you have added a single match attribute to. Tip You can further filter these results by adding the device name to your query: collector.name:\"ktranslate\" message:\"*$DEVICE_NAME*Match Attribute*\". Metrics from ktranslate The -metrics option captures the following performance metrics when polling devices: Metric Granularity Description baseserver_healthcheck_execution_total Top Level Rate of internal health checks. Shows mostly that things are not deadlocked and should always be greater than 0. inputq Top Level Messages per second (msg/sec) received over the last 60 seconds from all SNMP, Flow, and VPC inputs combined. jchfq Top Level Gauge rate with number of available pre-allocated buffers. It should be about 8,000. delivery_metrics_nr Delivery to New Relic One Batches per second (batches/sec) sent over the last 60 seconds for all metrics to New Relic One. delivery_logs_nr Delivery to New Relic One Logs per second (logs/sec) sent over the last 60 seconds for all logs to New Relic One. delivery_wins_nr Delivery to New Relic One Wins per second (wins/sec) of 200 HTTP codes received over the last 60 seconds from sending metrics and events to New Relic One. device_metrics SNMP Polls per second (polls/sec) of SNMP polling over the last 60 seconds for device level metrics. interface_metrics SNMP Polls per second (polls/sec) of SNMP polling over the last 60 seconds for interface level metrics. snmp_fail SNMP Gauge to monitor if SNMP polling is working faceted by device_name. Where 1 means good and 2 means fail. netflow.flows Netflow Flows per second (fps) received over the last 60 seconds for all device flow data: IPFIX, NetFlow, or sFlow. syslog_queue Syslog Gauge of syslog messages waiting to be processed. syslog_errors Syslog Errors per second (errors/sec) over the last 60 seconds while processing syslog messages. syslog_messages Syslog Messages per second (msg/sec) received over the last 60 seconds for all syslog data. Common metrics searches To see these metrics in New Relic One: Go to one.newrelic.com and click Query your data. Enter one of the following NRQL queries: What are the current versions of my ktranslate applications? FROM Metric SELECT latest(ver) AS 'image_version' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What is the health of my ktranslate application? FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.baseserver_healthcheck_execution_total) AS 'healthcheck_total', latest(kentik.ktranslate.chf.kkc.inputq) AS 'input_per_second', latest(kentik.ktranslate.chf.kkc.jchfq) AS 'buffer' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What is the health of my deliveries to New Relic One? FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.delivery_metrics_nr) AS 'delivery_metric_batches_per_second', latest(kentik.ktranslate.chf.kkc.delivery_logs_nr) AS 'delivery_logs_per_second', latest(kentik.ktranslate.chf.kkc.delivery_wins_nr) AS 'delivery_wins_per_second' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What is the health of my SNMP collection overall? FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.device_metrics) AS 'device_polls_per_second', latest(kentik.ktranslate.chf.kkc.interface_metrics) AS 'interface_polls_per_second' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What devices are failing SNMP collection? SELECT max(snmp_fail) FROM ( FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.snmp_fail) AS 'snmp_fail' FACET host AS 'docker_host', svc AS 'container_service', device_name AS 'snmp_device' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' ) FACET docker_host, container_service, snmp_device WHERE snmp_fail = 2 Copy What is the health of my flow data collection? FROM Metric SELECT max(kentik.ktranslate.chf.kkc.netflow) AS 'flows_per_second' FACET host AS 'docker_host', svc AS 'container_service', device_name AS 'flow_device' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What is the health of my syslog collection? FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.syslog_queue) AS 'syslog_queue_total', latest(kentik.ktranslate.chf.kkc.syslog_errors) AS 'syslog_errors_per_second', latest(kentik.ktranslate.chf.kkc.syslog_messages) AS 'syslog_messages_per_second' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.21634,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "ktranslate Docker container health <em>monitoring</em>",
        "sections": "ktranslate Docker container health <em>monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": "While running the ktranslate Docker container for New Relic <em>network</em> <em>performance</em> <em>monitoring</em>, you can <em>monitor</em> the health of the container to proactively detect potential issues. The ktranslate container image has the -tee_logs=true and -metrics=jchf settings available during runtime, which allow"
      },
      "id": "61b9389528ccbcb4d396ee5e"
    }
  ],
  "/docs/network-performance-monitoring/monitoring-network-data/visualize-network-data": [
    {
      "sections": [
        "ktranslate Docker container health monitoring",
        "Logs from ktranslate",
        "Tip",
        "Optional log parsing rule",
        "Common log searches",
        "What version of ktranslate am I running?",
        "What arguments were passed to Docker at runtime?",
        "What errors am I experiencing?",
        "Is my match_attributes filter working on my device?",
        "Metrics from ktranslate",
        "Common metrics searches",
        "What are the current versions of my ktranslate applications?",
        "What is the health of my ktranslate application?",
        "What is the health of my deliveries to New Relic One?",
        "What is the health of my SNMP collection overall?",
        "What devices are failing SNMP collection?",
        "What is the health of my flow data collection?",
        "What is the health of my syslog collection?"
      ],
      "title": "ktranslate Docker container health monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring"
      ],
      "external_id": "a6a4a6194c420409a30f75d437e27998235b84bc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/advanced/ktranslate-container-health/",
      "published_at": "2021-12-30T03:02:12Z",
      "updated_at": "2021-12-16T01:45:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "While running the ktranslate Docker container for New Relic network performance monitoring, you can monitor the health of the container to proactively detect potential issues. The ktranslate container image has the -tee_logs=true and -metrics=jchf settings available during runtime, which allow it to send health metrics into New Relic One directly. These are enabled by default when installing network performance monitoring via the New Relic One guided install. We recommend you to set them up when installing network performance monitoring manually. Logs from ktranslate Tip If you want to check the logs locally from the Docker host, run docker logs $CONTAINER_NAME. For example, docker logs ktranslate-snmp. The -tee_logs=true option sends logs to New Relic One when polling devices. To see them, do the following: Go to one.newrelic.com > Logs. In Find logs where, enter collector.name:\"ktranslate\" and click Query logs. Optional log parsing rule We recommend you to add a parsing rule to New Relic One logs to break the logs from ktranslate into fields that are easily searchable. This is especially helpful when you are running more than one container as it allows you to then search by the value of --service_name from the Docker container. Using the New Relic One logs UI, use the following patterns: Rule Name: ktranslate-health logs Query Attribute: \"plugin.type\" Query Value: \"ktranslate-health\" Parsing logic: %{NOTSPACE:time} ktranslate/%{NOTSPACE:container_service} \\[%{NOTSPACE:severity}\\] %{GREEDYDATA:message} Copy Alternatively, you can use New Relic's Nerdgraph API to manage your parsing rules. A sample of the logConfigurationsCreateParsingRule is below, you will need to replace $ACCOUNT_ID with the ID of your target account. mutation { logConfigurationsCreateParsingRule( accountId: $ACCOUNT_ID, rule: { description: \"ktranslate-health logs\", enabled: true, grok: \"%{NOTSPACE:time} ktranslate/%{NOTSPACE:container_service} \\\\[%{NOTSPACE:severity}\\\\] %{GREEDYDATA:message}\", lucene: \"\\\"plugin.type\\\":\\\"ktranslate-health\\\"\", nrql: \"SELECT * FROM Log WHERE `plugin.type` = 'ktranslate-health'\" } ) { errors { message type } rule { accountId id enabled description grok lucene nrql } } } Copy The result of this parsing rule is splitting a raw message from this: { \"collector.name\": \"ktranslate\", \"instrumentation.provider\": \"kentik\", \"message\": \"2021-12-08T14:59:56.007 ktranslate/snmp [Info] nrmFormat New Metadata for cisco-7513\", \"newrelic.source\": \"api.logs\", \"plugin.type\": \"ktranslate-health\", \"timestamp\": 1638975596000 } Copy To this, creating the searchable fields of container_service, severity, and time; as well as trimming the message field to more actionable data: { \"collector.name\": \"ktranslate\", \"container_service\": \"snmp\", \"instrumentation.provider\": \"kentik\", \"message\": \"nrmFormat New Metadata for cisco-7513\", \"newrelic.source\": \"api.logs\", \"plugin.type\": \"ktranslate-health\", \"severity\": \"Info\", \"time\": \"2021-12-08T15:29:56.026\", \"timestamp\": 1638977396000 } Copy Common log searches Below are some common searches that can be used during troubleshooting to gather data for support: What version of ktranslate am I running? Logs UI: bash Copy $ collector.name:\"ktranslate\" message:\"*KTranslate Running -- Version*\" NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `message` LIKE '%KTranslate Running -- Version%' Copy Expected Results: bash Copy $ KTranslate Running -- Version kt-2021-12-06-1546870234; Build Mon Dec 6 22:22:56 UTC 2021 What arguments were passed to Docker at runtime? Logs UI: bash Copy $ collector.name:\"ktranslate\" message:\"*KTranslate CLI:*\" NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `message` LIKE '%KTranslate CLI:%' Copy Expected Results: bash Copy $ KTranslate CLI: [ktranslate -listen off -mapping /etc/ktranslate/config.json -geo /etc/ktranslate/GeoLite2-Country.mmdb -udrs /etc/ktranslate/udr.csv -api_devices /etc/ktranslate/devices.json -asn /etc/ktranslate/GeoLite2-ASN.mmdb -log_level info -snmp /snmp-base.yaml -nr_account_id=2583772 -log_level=info -metrics=jchf -tee_logs=true -service_name=snmp nr1.snmp] What errors am I experiencing? Without a parsing rule applied to your logs Logs UI: bash Copy $ collector.name:\"ktranslate\" message:-*\\[Info\\]* NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `message` NOT LIKE '%[Info]%' Copy With a parsing rule applied to your logs Logs UI: bash Copy $ collector.name:\"ktranslate\" severity:-\"Info\" NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `severity` != 'Info' Copy Expected Results: bash Copy $ KTranslate>cisco-7513 There was an SNMP polling error with the CustomDeviceMetrics walking OID .1.3.6.1.2.1.4.31.1.1.21 after 0 retries: request timeout (after 0 retries). Is my match_attributes filter working on my device? Logs UI: bash Copy $ collector.name:\"ktranslate\" message:\"*Match Attribute*\" NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `message` LIKE '%Match Attribute%' Copy Expected Results: bash Copy $ KTranslate>cisco-7513 Added 1 Match Attribute(s) All devices are expected to have at least 1 Match Attribute inherited from the default monitor_admin_shut: true configuration. You should expect a value of 2 to be shown for a device that you have added a single match attribute to. Tip You can further filter these results by adding the device name to your query: collector.name:\"ktranslate\" message:\"*$DEVICE_NAME*Match Attribute*\". Metrics from ktranslate The -metrics option captures the following performance metrics when polling devices: Metric Granularity Description baseserver_healthcheck_execution_total Top Level Rate of internal health checks. Shows mostly that things are not deadlocked and should always be greater than 0. inputq Top Level Messages per second (msg/sec) received over the last 60 seconds from all SNMP, Flow, and VPC inputs combined. jchfq Top Level Gauge rate with number of available pre-allocated buffers. It should be about 8,000. delivery_metrics_nr Delivery to New Relic One Batches per second (batches/sec) sent over the last 60 seconds for all metrics to New Relic One. delivery_logs_nr Delivery to New Relic One Logs per second (logs/sec) sent over the last 60 seconds for all logs to New Relic One. delivery_wins_nr Delivery to New Relic One Wins per second (wins/sec) of 200 HTTP codes received over the last 60 seconds from sending metrics and events to New Relic One. device_metrics SNMP Polls per second (polls/sec) of SNMP polling over the last 60 seconds for device level metrics. interface_metrics SNMP Polls per second (polls/sec) of SNMP polling over the last 60 seconds for interface level metrics. snmp_fail SNMP Gauge to monitor if SNMP polling is working faceted by device_name. Where 1 means good and 2 means fail. netflow.flows Netflow Flows per second (fps) received over the last 60 seconds for all device flow data: IPFIX, NetFlow, or sFlow. syslog_queue Syslog Gauge of syslog messages waiting to be processed. syslog_errors Syslog Errors per second (errors/sec) over the last 60 seconds while processing syslog messages. syslog_messages Syslog Messages per second (msg/sec) received over the last 60 seconds for all syslog data. Common metrics searches To see these metrics in New Relic One: Go to one.newrelic.com and click Query your data. Enter one of the following NRQL queries: What are the current versions of my ktranslate applications? FROM Metric SELECT latest(ver) AS 'image_version' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What is the health of my ktranslate application? FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.baseserver_healthcheck_execution_total) AS 'healthcheck_total', latest(kentik.ktranslate.chf.kkc.inputq) AS 'input_per_second', latest(kentik.ktranslate.chf.kkc.jchfq) AS 'buffer' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What is the health of my deliveries to New Relic One? FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.delivery_metrics_nr) AS 'delivery_metric_batches_per_second', latest(kentik.ktranslate.chf.kkc.delivery_logs_nr) AS 'delivery_logs_per_second', latest(kentik.ktranslate.chf.kkc.delivery_wins_nr) AS 'delivery_wins_per_second' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What is the health of my SNMP collection overall? FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.device_metrics) AS 'device_polls_per_second', latest(kentik.ktranslate.chf.kkc.interface_metrics) AS 'interface_polls_per_second' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What devices are failing SNMP collection? SELECT max(snmp_fail) FROM ( FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.snmp_fail) AS 'snmp_fail' FACET host AS 'docker_host', svc AS 'container_service', device_name AS 'snmp_device' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' ) FACET docker_host, container_service, snmp_device WHERE snmp_fail = 2 Copy What is the health of my flow data collection? FROM Metric SELECT max(kentik.ktranslate.chf.kkc.netflow) AS 'flows_per_second' FACET host AS 'docker_host', svc AS 'container_service', device_name AS 'flow_device' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What is the health of my syslog collection? FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.syslog_queue) AS 'syslog_queue_total', latest(kentik.ktranslate.chf.kkc.syslog_errors) AS 'syslog_errors_per_second', latest(kentik.ktranslate.chf.kkc.syslog_messages) AS 'syslog_messages_per_second' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.32925,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "ktranslate Docker container health <em>monitoring</em>",
        "sections": "ktranslate Docker container health <em>monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": "While running the ktranslate Docker container for New Relic <em>network</em> <em>performance</em> <em>monitoring</em>, you can <em>monitor</em> the health of the container to proactively detect potential issues. The ktranslate container image has the -tee_logs=true and -metrics=jchf settings available during runtime, which allow"
      },
      "id": "61b9389528ccbcb4d396ee5e"
    },
    {
      "sections": [
        "Advanced configuration for Network Performance Monitoring",
        "SNMP-base YAML sample file",
        "Devices section",
        "Trap section",
        "Discovery section",
        "Global section",
        "Optional SNMPv3 configuration",
        "Tip",
        "Optional external config files",
        "Discovery CIDRs",
        "Devices",
        "The match_attributes attribute",
        "Default 'OR' with null and empty values",
        "'AND', omit null and empty values",
        "Single match, omit null and empty values",
        "The flow_only attribute",
        "The response_time and ping_only attributes",
        "Flow data application mapping",
        "Flow data input filtering",
        "Example Filters"
      ],
      "title": "Advanced configuration for Network Performance Monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Advanced configuration"
      ],
      "external_id": "61f8c58056547c4a9a2c534617559472e3e62fd1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/advanced/advanced-config/",
      "published_at": "2021-12-30T03:03:15Z",
      "updated_at": "2021-12-19T05:14:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you want to explore all the options you can use when configuring the monitoring of your network performance, see the following sections. SNMP-base YAML sample file Here's an example of the various configuration options available in the snmp-base.yaml file used by the ktranslate docker image to poll for SNMP and flow data devices. You can also see a heavily-commented sample in the ktranslate repository on GitHub. devices: # Sample of SNMP v2c device ups_snmpv2c__10.10.0.201: device_name: ups_snmpv2c device_ip: 10.10.0.201 snmp_comm: public oid: .1.3.6.1.4.1.318.1.3.27 description: \"APC Web/SNMP Management Card (MB:v4.1.0 PF:v6.2.1 PN:apc_hw05_aos_621.bin AF1:v6.2.1 AN1:apc_hw05_sumx_621.bin MN:AP9537SUM HR:05 SN: ABC123DEF456 MD:05/21/2016) (Embedded PowerNet SNMP Agent SW v2.2 compatible)\" last_checked: 2021-11-09T18:14:59.907821489Z mib_profile: apc_ups.yml provider: kentik-ups poll_time_sec: 300 retries: 1 timeout_ms: 5000 user_tags: owning_team: dc_ops discovered_mibs: - PowerNet-MIB_UPS - TCP-MIB - UDP-MIB # Sample of SNMP v3 device router_snmpv3__10.10.0.202: device_name: router_snmpv3 device_ip: 10.10.0.202 snmp_v3: user_name: userNamev3 authentication_protocol: MD5 authentication_passphrase: authPassPrivacy privacy_protocol: AES256 privacy_passphrase: passPrivacy oid: .1.3.6.1.4.1.9.1.544 description: \"Cisco IOS Software, 3800 Software (C3845-ADVENTERPRISEK9-M), Version 15.1(3)T4, RELEASE SOFTWARE (fc1)\\r\\nTechnical Support: http://www.cisco.com/techsupport\\r\\nCopyright (c) 1986-2012 by Cisco Systems, Inc.\\r\\nCompiled Thu 24-May-12 04:27 by prod_rel_team\" last_checked: 2021-11-09T18:14:59.907821489Z mib_profile: cisco-asr.yml provider: kentik-router user_tags: owning_team: core-networking discovered_mibs: - BGP4-MIB - CISCO-MEMORY-POOL-MIB - CISCO-PROCESS-MIB - IF-MIB - OSPF-MIB engine_id: \"80:00:01:01:0a:14:1e:28\" match_attributes: if_interface_name: \"^Ten.*|^Gig.*\" \"!if_Alias\": \"[Uu]plink\" # Sample of SNMP v1 device netbotz_snmpv1__10.10.0.203: device_name: netbotz_snmpv1 device_ip: 10.10.0.201 snmp_comm: public use_snmp_v1: true oid: .1.3.6.1.4.1.5528.100.20.10.2013 description: \"Linux netbotz930A7A 2.6.12 #307 Wed Dec 29 15:25:32 EST 2010 ppc\" last_checked: 2021-11-09T18:14:59.907821489Z mib_profile: apc-netbotz.yml provider: kentik-netbotz user_tags: owning_team: sys_ops discovered_mibs: - IF-MIB - IP-MIB - TCP-MIB - UDP-MIB no_use_bulkwalkall: true # Sample of \"flow only\" device flow_only__10.10.0.210: device_name: flow_only device_ip: 10.10.0.210 user_tags: owning_team: net_eng flow_only: true # Sample of \"ping only\" device ping_only__10.10.0.220: device_name: ping_only device_ip: 10.10.0.220 user_tags: owning_team: load_balancing ping_only: true trap: listen: 127.0.0.1:1162 community: public version: \"\" transport: \"\" v3_config: null discovery: cidrs: - 10.0.0.0/24 - 10.0.0.202/32 debug: false ports: - 161 - 1161 default_communities: - public - public123 - Publ!cABC use_snmp_v1: false default_v3: null add_mibs: true threads: 4 add_devices: true replace_devices: true no_dedupe_engine_id: false global: poll_time_sec: 60 drop_if_outside_poll: false mib_profile_dir: /etc/ktranslate/profiles mibs_db: /etc/ktranslate/mibs.db mibs_enabled: - BGP4-MIB - CISCO-MEMORY-POOL-MIB - CISCO-PROCESS-MIB - IF-MIB - IP-MIB - OSPF-MIB - PowerNet-MIB_UPS - TCP-MIB - UDP-MIB timeout_ms: 3000 retries: 0 global_v3: null response_time: false user_tags: environment: production match_attributes: if_Description: \".*WAN.*\" Copy Devices section Key name Required Description device_name ✓ Name of the device. This is the unique identifier for the device in New Relic One. device_ip ✓ Target IP of the device. snmp_comm ✓ (Required for SNMPv1/2c) SNMPv1/2c community string to use. use_snmp_v1 ✓ (Required for SNMPv1) Indicates whether to use SNMPv1. By default, it's set to false. snmp_v3 ✓ (Required for SNMPv3) SNMP v3 config debug Indicates whether to enable debug level logging during SNMP polling. By default, it's set to false. port Port to send SNMP queries to. By default, it's set to port 161. oid ✓ (Required for SNMP polling) The discovered systemObjectID | sysObjectID | sysOID for the device. This is used to match the device to a known SNMP profile and set the provider attribute. If no match is found, this sets the provider as a kentik-default device. description The discovered sysDescr of the device. This field is informational. last_checked Timestamp when this device was last discovered by the ktranslate docker image. This field is informational. mib_profile ✓ (Required for SNMP polling) SNMP Profile file that was associated with this device during the discovery run based on its sysOID. If this starts with a bang (!) token, it will override the automatic matching from the sysOID and use a manual override. Ex: \"!cisco-asa.yml\" (quotes are required). provider ✓ (Required for New Relic One) Value used during entity synthesis for New Relic One. This is automatically created based on the matched mib_profile. poll_time_sec Indicates the SNMP polling frequency in seconds. This setting is used to override the global.poll_time_sec attribute. retries Indicates the number of attempts to retry polling SNMP OIDs. This setting is used to override the global.retries attribute. timeout_ms Indicates the SNMP polling timeout in milliseconds. This setting is used to override the global.timeout_ms attribute. user_tags key:value pair attributes to give more context to the device. Tags at this level will be appended to any tags applied in the global.user_tags attribute. discovered_mibs List of MIBs pulled from matched mib_profile that this device can respond to. This field is informational. engine_id The unique engine ID discovered for this device's SNMP agent. Generally found during SNMP v3 discovery. This field is informational. match_attributes attribute:regex pairs to add metrics to allowlist. Pairs at this level will be appended to any pairs applied in the global.match_attributes attribute. Uses the RE2 syntax and has a default OR operator. Prefix key with ! to force to AND operators. monitor_admin_shut Indicates whether to monitor interfaces in Administratively Shutdown status. By default, it's set to false. no_use_bulkwalkall Disables the SNMP GETBULK request action when true. By default, it's set to false. ping_only Disables all SNMP polling and enables response time polling when true. This setting is used to override the global.response_time attribute. By default, it's set to false. flow_only Disables all SNMP polling when true. By default, it's set to false. Trap section Key name Required Description listen ✓ Listening IP port for receiving SNMP traps. By default it's set to 127.0.0.1:1162, using the SNMP Trap default of 162 requires running Docker as root. community SNMPv1/v2c community string for receiving SNMP traps. version SNMP version to use. Options are v1, v2c, and v3. By default, it's set to v2c. transport SNMP transport protocol to use. Options are TCP and UDP. By default, it's set to UDP v3_config SNMP v3 config to use. Only used if version: v3. Discovery section Key name Required Description cidrs ✓ Array of target IP ranges in CIDR notation. debug Indicates whether to enable debug level logging during discovery. By default, it's set to false ports ✓ Array of target ports to scan during SNMP polling. default_communities ✓ (Required for SNMPv1/2c) Array of SNMPv1/v2c community strings to scan during SNMP polling. This array is evaluated in order and discovery accepts the first passing community. use_snmp_v1 ✓ (Required for SNMPv1) Indicates whether to use SNMPv1 during discovery. By default, it's set to false default_v3 ✓ (Required for SNMPv3) SNMPv3 configuration to scan during SNMP polling. add_devices ✓ Indicates whether to add discovered devices to the devices section of the snmp-base.yaml file. By default, it's set to true. add_mibs ✓ Indicates whether to add discovered MIBs to the global.mibs_enabled section of the snmp-base.yaml file. By default, it's set to true. threads ✓ Integer limit of threads to use during discovery. It should be less than the number of cores available to the container. By default it's set to 4. replace_devices ✓ Indicates whether to replace discovered devices if they already exist in the devices section of the snmp-base.yaml file. By default, it's set to false. no_dedup_engine_id When set to true, disables deduplication of discovered devices if it appears that they are the same device, based on their reported SNMP engine ID. By default, it's set to false Global section Key name Required Description poll_time_sec ✓ Time in seconds to poll devices. This can be overridden per device using the devices.<deviceName>.poll_time_sec attribute. By default, it's set to 60. drop_if_outside_poll Indicates whether to drop all values from this cycle if polling takes longer than the value set in poll_time_sec. By default, it's set to false mib_profile_dir Directory to find curated MIB profiles. These are pulled into the ktranslate image automatically from Kentik's snmp-profiles repository and can be overridden at Docker runtime by creating a volume mount of your own local directory of profiles. mibs_db mibs_enabled ✓ Array of all active MIBs the ktranslate docker image will poll. This list is automatically generated during discovery if the discovery_add_mibs attribute is true. MIBs not listed here will not be polled on any device in the configuration file. You can specify a SNMP table directly in a MIB file using MIB-NAME.tableName syntax. Ex: HOST-RESOURCES-MIB.hrProcessorTable. timeout_ms ✓ Time in milliseconds SNMP queries timeout. This can be overridden per device using the devices.<deviceName>.timeout_ms attribute. By default, it's set to 5000 retries ✓ Number of attempts to retry failed SNMP polls. This can be overridden per device using the devices.<deviceName>.retries attribute. By default, it's set to 0 user_tags key:value pair attributes to give more context to the device. Tags at this level will be applied to all devices in the configuration file. match_attributes attribute:regex pairs to add metrics to allowlist. Pairs at this level will matched against all devices in the configuration file. Uses the RE2 syntax and has a default OR operator. Prefix key with ! to force to AND operators. response_time Indicates whether response time polling is enabled for all devices in the configuration file. By default, it's set to false. Optional SNMPv3 configuration Key name Required Description user_name ✓ User name for SNMPv3 authentication authentication_protocol ✓ SNMPv3 authentication protocol. The possible values are NoAuth, MD5, or SHA authentication_passphrase SNMPv3 authentication passphrase privacy_protocol ✓ SNMPv3 privacy protocol. The possible values are AuthNoPriv, DES, AES, AES192, AES256, AES192C, or AES256C privacy_passphrase SNMPv3 privacy passphrase context_engine_id SNMPv3 context engine ID context_name SNMPv3 context name Tip You can use AWS Secrets Manager natively in your SNMP v3 config using the aws.sm.$SECRET_NAME syntax, replacing $SECRET_NAME as necessary to have ktranslate pull in your credentials during Docker runtime. Optional external config files To support a wide variety of configuration and automation needs, you can use external files that you volume mount into your Docker container to decouple certain elements of the standard configuration file. The syntax for these files is \"@fileName.extension\", including the double quotes. Discovery CIDRs Example: discovery: cidrs: \"@cidrs.yaml\" Copy The CIDRs file should use a YAML list syntax like this: - 10.10.0.0/24 - 10.20.0.0/24 - 192.168.0.21/32 Copy Devices Example: devices: - \"@neteng-devices.yaml\" - \"@dc-ops.yaml\" Copy The device files should use the same syntax as the standard devices section of the main config file, omitting the optional fields that are generated during discovery: devices: # Sample of SNMP v2c device ups_snmpv2c__10.10.0.201: device_name: ups_snmpv2c device_ip: 10.10.0.201 snmp_comm: public oid: .1.3.6.1.4.1.318.1.3.27 mib_profile: apc_ups.yml provider: kentik-ups poll_time_sec: 300 retries: 1 timeout_ms: 5000 user_tags: owning_team: dc_ops Copy The match_attributes attribute To support filtering of data that does not create value for your observability needs, you can set the global.match_attributes.{} and/or devices.<deviceName>.match_attributes.{} attribute map. This will provide filtering at the ktranslate level, before shipping data to New Relic, giving you granular control over monitoring of things like interfaces. The default behavior of this map is an OR condition, but you can override this and force an AND operator by prefixing your key name with !. This is also useful to return only matched items and omit all null and \"\" (empty) results. Default 'OR' with null and empty values Match when if_Alias begins with Uplink OR when if_interface_name begins with Gig, keep all null and \"\" values: devices: deviceName: ... match_attributes: if_Alias: \"^Uplink.*\" if_interface_name: \"^Gig.*\" Copy 'AND', omit null and empty values Match when if_Alias begins with Uplink AND when if_interface_name begins with Gig, drop all null and \"\" values: devices: deviceName: ... match_attributes: if_Alias: \"^Uplink.*\" \"!if_interface_name\": \"^Gig.*\" Copy Single match, omit null and empty values Match when if_Alias begins with Uplink, drop all null and \"\" values: devices: deviceName: ... match_attributes: \"!if_Alias\": \"^Uplink.*\" Copy The flow_only attribute To support monitoring of devices where performance statistics are nor accessible, available, or desired, you can set the devices.<deviceName>.flow_only attribute to true. This will generate a Flow Device entity in New Relic One which will only have telemetry in the KFlow event namespace. Alternatively, collecting flow telemetry from a device that is in your configuration file as an SNMP device will add decoration of the KFlow data to the pre-existing entity, such as a Router or Firewall. In New Relic One, you can see the results of this polling by investigating the following events: FROM KFlow SELECT count(*) FACET device_name WHERE instrumentation.name = 'netflow-events' TIMESERIES Copy The response_time and ping_only attributes To support monitoring of devices where performance statistics are not accessible or available, or in simple cases where basic round-trip time (RTT) monitoring is required, you can either set the global.response_time or devices.<deviceName>.ping_only attributes to true. This feature uses the go-ping package to send unprivileged UDP packets to devices in order to collect the average, min, and max RTT for the endpoint based on sending 1 packet/sec from ktranslate to the device IP address. Setting the global.response_time attribute to true will add RTT monitoring on top of existing SNMP polling. devices.<deviceName>.ping_only: true will allow you to monitor devices with only the UDP packets for RTT and no SNMP polling. In New Relic One, you can see the results of this polling by investigating the following metrics: FROM Metric SELECT average(kentik.ping.AvgRttMs) AS 'Average', max(kentik.ping.MaxRttMs) AS 'Max', min(kentik.ping.MinRttMs) AS 'Min' FACET device_name TIMESERIES Copy Tip You can use the ping_only attribute in replacement of the flow_only attribute if you would like to collect RTT metrics from a flow device. If both ping_only and flow_only are true, the device will be treated as a flow_only device. Flow data application mapping By default, flow telemetry is mapped to known applications based on evaluation of the layer 4 port in use on a specific flow conversation. If needed, you can override the default mapping by providing a YAML file during Docker runtime to the -application_map flag. This will allow you to specify application names based on ports you identify. Example syntax: applications: - ports: [9092, 9093] name: kafka - ports: [80, 8080] name: http - ports: [443, 8443] name: https Copy Flow data input filtering By default, flow data containers will collect and process every flow packet they receive. If needed, you can add an inclusion filter to the -nf.source flag that will ignore all traffic not matching the filter you provide. Syntax: --filters $TYPE,$FIELD,$FUNCTION,$MATCH Argument Name Required Description $TYPE ✓ The type of filter to apply. Possible values are string, int, and addr. $FIELD ✓ The name of the field to evaluate the match pattern against. $FUNCTION ✓ The type of function to use during evaluation. Possible values are Equal: ==, NotEqual: !=, LessThan: <, GreaterThan: >, Contains: % $MATCH ✓ The value to be used as a match pattern. Example Filters Only collect flow data from source addresses in the 10.0.0.0/24 CIDR range -nf.source sflow --filters addr,src_addr,%,10.10.0.0/24 Copy Only collect flow data where the destination port is not equal to 8531 -nf.source netflow5 --filters int,l4_dst_port,!=,8531 Copy You can also add multiple filters together with an inherited AND operator Only collect flow data from source addresses in the 10.0.0.0/24 CIDR range AND where the destination port is not equal to 8531 --filters addr,src_addr,%,10.0.0.0/24 --filters int,l4_dst_port,!=,8531 Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.57741,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Advanced configuration for <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "sections": "Advanced configuration for <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "tags": "<em>Network</em> <em>performance</em> <em>monitoring</em>",
        "body": "If you want to explore all the options you can use when configuring the <em>monitoring</em> of your <em>network</em> <em>performance</em>, see the following sections. SNMP-base YAML sample file Here&#x27;s an example of the various configuration options available in the snmp-base.yaml file used by the ktranslate docker image"
      },
      "id": "61b9389664441f8fc3d7182e"
    },
    {
      "sections": [
        "Get started with Network Performance Monitoring",
        "Tip",
        "Types of network performance data",
        "Important",
        "High level architecture overview"
      ],
      "title": "Get started with Network Performance Monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Get started"
      ],
      "external_id": "96d12e2c5551a6e5eab76238cd2b787e5c188c01",
      "image": "https://docs.newrelic.com/static/eb0db7c88b717f386c4900a04e12a8ed/e5166/overview_navigator.jpg",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/get-started/npm-introduction/",
      "published_at": "2022-01-02T01:50:08Z",
      "updated_at": "2021-12-14T01:42:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When system performance suffers, you need to know if it's due to your code, your infrastructure, or the underlying network. And you need to know fast, so you can focus your efforts. With Network Performance Monitoring you can correlate and analyze application, infrastructure, digital experience, and network data all in one place, and understand how network performance and overall system performance impact each other. Tip Network Performance Monitoring is now included in the New Relic FedRAMP Moderate authorization! Use the guided installs for SNMP and network flows to automatically detect and configure the FedRAMP-authorized API endpoints, or review the manual setup process in our docs for SNMP and network flows. Using Navigator with Network Performance Monitoring. Network Performance Monitoring adds the context of network data to the application and infrastructure data you already collect in New Relic One. By monitoring your network data, you can: Analyze and understand the performance of your entire stack (application and infrastructure) for a holistic understanding of your system performance. Have all the data in a single platform to eliminate blind spots. See at first glance whether a network is implicated in an issue. Sign up for free! No credit card required. Already have an account? Login. Types of network performance data You can monitor the following types of network performance data: SNMP data: Simple Network Management Protocol (SNMP) is an application–layer protocol for exchanging management information between network devices. To send SNMP data to New Relic One, see Set up SNMP data monitoring. Network flow data: It captures information about the IP traffic going to and from network interfaces in your on-premises network. To send network flow data to New Relic One, see Set up network flow data monitoring. Important We recommend configuring both SNMP and network flow data for better visibility into your network. This will provide both performance metrics and traffic patterns to troubleshoot and optimize your network. High level architecture overview Our solution is based on the ktranslate docker container developed by our partner, Kentik. This single container image is hosted in your environment to collect and process your data to be exported to the Event, Metric, and Log APIs and displayed in New Relic One. Overview of Network Performance Monitoring architecture.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 155.92468,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "sections": "Get started with <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": "When system <em>performance</em> suffers, you need to know if it&#x27;s due to your code, your infrastructure, or the underlying <em>network</em>. And you need to know fast, so you can focus your efforts. With <em>Network</em> <em>Performance</em> <em>Monitoring</em> you can correlate and analyze application, infrastructure, digital experience"
      },
      "id": "6126f39b28ccbc8c49f26162"
    }
  ],
  "/docs/network-performance-monitoring/setup-performance-monitoring/aws-vpc-flow-monitoring": [
    {
      "sections": [
        "Set up network syslog monitoring",
        "Prerequisites",
        "New Relic One account prerequisites",
        "Linux host prerequisites",
        "Network syslog devices prerequisites",
        "Network security prerequisites",
        "Tip",
        "Set up network syslog monitoring in New Relic One"
      ],
      "title": "Set up network syslog monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Installation",
        "Setup",
        "NPM"
      ],
      "external_id": "835cdb37ea4a0497669a79a24ee5fa8904d05ec6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/network-syslog-monitoring/",
      "published_at": "2021-12-30T09:50:55Z",
      "updated_at": "2021-12-19T15:53:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Set up your network devices so they send syslog data to New Relic One. Prerequisites New Relic One account prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. A New Relic account ID. Learn how to find your account ID. A New Relic license key. Learn how to generate a new License key. Linux host prerequisites Docker installed in a Linux host. SSH access to the Docker host, with the ability to launch new containers. Network syslog devices prerequisites Configured network devices to send syslog to the host running the ktranslate docker container. Here's how to configure network flow data collection in some devices: Checkpoint - Security Gateway Cisco - ASA Cisco - IOS Cisco - Meraki Cisco - NX-OS F5 - BIG-IP Fortinet Fortigate Juniper - Junos Palo Alto - PAN-OS Network security prerequisites Direction Source Destination Ports Protocol Outbound Docker host ktranslate image on Docker Hub 443 TCP Outbound Docker host New Relic Log API endpoint: US Endpoint: https://log-api.newrelic.com Copy EU Endpoint: https://log-api.eu.newrelic.com Copy 443 TCP Inbound Source devices for syslog data Docker host 5143 (default) UDP Tip The default listening port for ktranslate is 5143 (TCP/UDP). If you need to use the default syslog port of 514 (or any other port), you can do so by providing a new listening endpoint during Docker runtime. For example: -syslog=\"0.0.0.0:514. Set up network syslog monitoring in New Relic One From a Linux host with Docker installed, download the ktranslate image from dockerhub by running bash Copy $ docker pull kentik/ktranslate:v2 Copy the snmp-base.yaml file to the local $HOME directory of your Docker user, and discard the container by running bash Copy $ cd . $ id=$(docker create kentik/ktranslate:v2) $ docker cp $id:/etc/ktranslate/snmp-base.yaml . $ docker rm -v $id In the snmp-base.yaml file, add your network syslog devices inside the devices key with the following structure: devices: syslogDevice: device_name: edge-router device_ip: 10.10.1.254 ping_only: true # Optional user tags user_tags: owning_team: net_eng environment: production Copy Tip If you're already monitoring SNMP data devices that send network syslog, you don't need to add them in your snmp-base.yaml file a second time. The ping_only attribute used in the configuration file can optionally be replaced with flow_only to remove response time monitoring and only collect syslog messages from the host. Run ktranslate to listen for network syslog by running: bash Copy $ docker run -d --name ktranslate-syslog --restart unless-stopped --net=host \\ > -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ > -e NEW_RELIC_API_KEY=$YOUR_NR_LICENSE_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$YOUR_NR_ACCOUNT_ID \\ > ## If your account is located in Europe, add the following option: $ ## -nr_region=EU \\ $ -metrics=jchf \\ > -tee_logs=true \\ > -service_name=syslog \\ > ## Optional: To override the default listening port of \"0.0.0.0:5143\": $ ## -syslog=\"<ip_address>:<port>\" $ nr1.syslog Tip ktranslate handles syslog in the following formats: RFC3164, RFC5424, and RFC6587. Investigate your device syslog messages in the New Relic One logs UI, using the following query: \"plugin.type\":\"ktranslate-syslog\" Copy To get better visibility into your network device performance, set up SNMP data monitoring. To get better visibility into how your network is being used, set up network flow data monitoring.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 270.80524,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set up <em>network</em> syslog <em>monitoring</em>",
        "sections": "Set up <em>network</em> syslog <em>monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": " visibility into your <em>network</em> device <em>performance</em>, set up SNMP data <em>monitoring</em>. To get better visibility into how your <em>network</em> is being used, set up <em>network</em> flow data <em>monitoring</em>."
      },
      "id": "619e0cec64441f61ed985635"
    },
    {
      "sections": [
        "Set up network flow data monitoring",
        "Prerequisites",
        "New Relic One account prerequisites",
        "Linux host prerequisites",
        "Network flow data devices prerequisites",
        "Network security prerequisites",
        "Supported types of network flow data",
        "Important",
        "Scaling network flow collection",
        "Set up network flow data monitoring in New Relic One",
        "Manual setup",
        "Tip"
      ],
      "title": "Set up network flow data monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Installation",
        "Setup",
        "NPM"
      ],
      "external_id": "626c9bebce36e550d5793d8ef932e6d654c23e47",
      "image": "https://docs.newrelic.com/static/3d1561743f3311471975006fa41f628a/c1b63/network-flows-guided-install.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/network-flow-monitoring/",
      "published_at": "2021-12-30T03:13:18Z",
      "updated_at": "2021-12-04T22:07:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Set up your network devices so they send network data to New Relic One. Prerequisites New Relic One account prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. A New Relic account ID. Read how to find your account ID. A New Relic license key. Read how to generate a new License key. Linux host prerequisites Docker installed in a Linux host. SSH access to the Docker host, with the ability to launch new containers. Network flow data devices prerequisites Configured network devices to send flow data to the host running the ktranslate docker container. Here's how to configure network flow data collection in some devices: NetFlow data Cisco - IOS Cisco - Meraki Cisco - NX-OS Fortinet Fortigate Palo Alto - PAN-OS sFlow data F5 - BIG-IP jFlow data Juniper - Junos Network security prerequisites Direction Source Destination Ports Protocol Outbound Docker host ktranslate image on Docker Hub 443 TCP Outbound Docker host New Relic Event API US Endpoint: https://insights-collector.newrelic.com EU Endpoint: https://insights-collector.eu01.nr-data.net 443 TCP Outbound Docker host New Relic Log API US Endpoint: https://log-api.newrelic.com EU Endpoint: https://log-api.eu.newrelic.com 443 TCP Inbound Source devices for network flow data Docker host 9995 (default) UDP Supported types of network flow data NPM flow monitoring supports the four primary types of network flow data and their derivatives. When running the ktranslate container, you will specify which major type you want to monitor using the -nf.source option. Important The ktranslate container only supports monitoring one type of network flow data type at a time. If you want to monitor several types, each will require a container. IPFIX and NetFlow v9 can be sent to the same container, but we recommend running a separate container as a best practice. Network flow data type -nf.source value IPFIX ipfix NetFlow v5 netflow5 NetFlow v9 netflow9 sFlow sflow AppFlow netflow5 Argus netflow5 cflowd netflow5 J-Flow netflow5 NetStream netflow5 RFlow netflow5 Cisco NSEL netflow9 Scaling network flow collection When planning your strategy for collecting network flows at scale, New Relic recommends 1 CPU per 2000 flows-per-second (120,000 flows-per-minute). Deciding whether to run more small containers to distribute load or fewer large containers to consolidate management is a matter of personal preference. Set up network flow data monitoring in New Relic One Go to one.newrelic.com and click Add more data. Scroll down until you see Network performance monitoring and click Network Flows. Follow the steps in New Relic One. one.newrelic.com > Add more data > Network performance monitoring > Network Flows to set up network flow data monitoring. To get better visibility into your network device performance, set up SNMP data monitoring. Visualize your network performance data in New Relic. Manual setup If you prefer to do the setup manually, proceed with the following steps. In your local machine, from a Linux host with Docker installed, download the ktranslate image from dockerhub by running bash Copy $ docker pull kentik/ktranslate:v2 Copy the snmp-base.yaml file to the local $HOME directory of your Docker user, and discard the container by running bash Copy $ cd . $ id=$(docker create kentik/ktranslate:v2) $ docker cp $id:/etc/ktranslate/snmp-base.yaml . $ docker rm -v $id In the snmp-base.yaml file, add your network flow devices inside the devices key with the following structure: devices: flowDevice: device_name: edge-router device_ip: 10.10.1.254 flow_only: true # Optional user tags user_tags: owning_team: net_eng environment: production Copy Tip If you're already monitoring SNMP data devices that send network flow data, you don't need to add them in your snmp-base.yaml file a second time. Run ktranslate to listen for network flows by running: bash Copy $ docker run -d --name ktranslate-sflow --restart unless-stopped --net=host \\ > -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ > -e NEW_RELIC_API_KEY=$YOUR_NR_LICENSE_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$YOUR_NR_ACCOUNT_ID \\ > ## If your account is located in Europe, add the following flag: $ ## -nr_region=EU \\ $ ## If you want to use FedRAMP, add the following flag to use the FedRAMP authorized endpoints: $ ## -nr_region=GOV \\ $ -metrics=jchf \\ > -tee_logs=true \\ > -flow_only=true \\ > -nf.source=sflow \\ > -service_name=sflow \\ > nr1.flow Tip This command assumes collection of sflow data. If you are collecting other flow types, you should change the suffix in the --name flag for the container and update the -nf.source and -service_name flags as necessary. To get better visibility into your network device performance, set up SNMP data monitoring. To get insights into system messages from your devices, setup network syslog collection. Visualize your network performance data in New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 233.9237,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set up <em>network</em> flow data <em>monitoring</em>",
        "sections": "Set up <em>network</em> flow data <em>monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": " <em>monitoring</em> &gt; <em>Network</em> Flows to set up <em>network</em> flow data <em>monitoring</em>. To get better visibility into your <em>network</em> device <em>performance</em>, set up SNMP data <em>monitoring</em>. Visualize your <em>network</em> <em>performance</em> data in New Relic. Manual <em>setup</em> If you prefer to do the <em>setup</em> manually, proceed with the following steps. In your"
      },
      "id": "612724e128ccbc4ac9f2612a"
    },
    {
      "sections": [
        "Set up SNMP data monitoring",
        "Prerequisites",
        "New Relic One account prerequisites",
        "Linux host prerequisites",
        "SNMP devices prerequisites",
        "Network security prerequisites",
        "Supported SNMP versions",
        "Tip",
        "Set up SNMP data monitoring in New Relic One",
        "Manual setup"
      ],
      "title": "Set up SNMP data monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Installation",
        "Setup"
      ],
      "external_id": "ab50c7659f03d76e429769be42ddec21d4744a0d",
      "image": "https://docs.newrelic.com/static/59f9f8d2d86daf23058506e7cf1c9fcc/c1b63/snmp-guided-install.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/snmp-performance-monitoring/",
      "published_at": "2021-12-30T09:52:07Z",
      "updated_at": "2021-12-04T22:08:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Set up your network devices so they send network data to New Relic One. Prerequisites New Relic One account prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. A New Relic account ID. Read how to find your account ID. A New Relic license key. Read how to generate a new License key. Linux host prerequisites Docker installed in a Linux host. SSH access to the Docker host, with the ability to launch new containers. SNMP devices prerequisites Configured network devices for SNMP polling from the ktranslate docker container. Some samples of basic SNMP configurations can be found here: Cisco IOS Meraki NX-OS Juniper Junos OS Palo Alto PAN-OS Network security prerequisites Direction Source Destination Ports Protocol Outbound Docker host ktranslate image on Docker Hub 443 TCP Outbound Docker host New Relic Metric API US Endpoint: https://metric-api.newrelic.com EU Endpoint: https://metric-api.eu.newrelic.com 443 TCP Outbound Docker host New Relic Log API US Endpoint: https://log-api.newrelic.com EU Endpoint: https://log-api.eu.newrelic.com 443 TCP Outbound Docker host Target devices for SNMP polling 161 (default) UDP Inbound Source devices for SNMP Trap data Docker host 162 (default) UDP Supported SNMP versions Our NPM container supports all major versions of SNMP (v1, v2c, and v3). Additionally, SNMP v3 has support for the following authentication and privacy settings: Setting Protocol Authentication NoAuth Authentication MD5 Authentication SHA Authentication SHA224 Authentication SHA256 Authentication SHA384 Authentication SHA512 Privacy NoPriv Privacy DES Privacy AES Privacy AES192 Privacy AES256 Privacy AES192C Privacy AES256C Tip We recommend using read-only community strings/authentication with SNMP Set up SNMP data monitoring in New Relic One Go to one.newrelic.com and click Add more data. Scroll down until you see Network performance monitoring and click SNMP. Follow the steps in New Relic One. one.newrelic.com > Add more data > Network performance monitoring > SNMP to set up SNMP data monitoring. To get better visibility into how your network is being used, set up network flow data monitoring. Visualize your network performance data in New Relic. Manual setup If you prefer to do the setup manually, proceed with the following steps. On a Linux host with Docker installed, download the ktranslate image from dockerhub by running bash Copy $ docker pull kentik/ktranslate:v2 Copy the snmp-base.yaml file to the local $HOME directory of your Docker user, and discard the container by running bash Copy $ cd . $ id=$(docker create kentik/ktranslate:v2) $ docker cp $id:/etc/ktranslate/snmp-base.yaml . $ docker rm -v $id Edit the snmp-base.yaml file and define the discovery.cidrs and discovery.default_communities attributes to appropriate values for your network. Tip It's recommended to set discovery.add_mibs: true to automate the addition of all discovered MIBs into the global.mibs_enabled attribute Launch a short-lived container to execute discovery by running bash Copy $ docker run -ti --name ktranslate-discovery --rm --net=host \\ > --user `id -u`:`id -g` \\ > -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -log_level info \\ > -snmp_discovery=true After the discovery run finishes, you should see an output similar to the following: bash Copy $ >[Info] KTranslate Adding 3 new snmp devices to the config, 0 replaced from 3 $ # In this example, the discovery run found 3 new SNMP devices. The discovered devices are listed in the snmp-base.yaml file's devices.{} section. By default, only the IF-MIB mib is polled. You can manually add other mibs to the global.mibs_enabled attribute if you did not set discovery.add_mibs: true before running the discovery. Run ktranslate to poll target devices by running: bash Copy $ docker run -d --name ktranslate-snmp --restart unless-stopped --net=host \\ > -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ > -e NEW_RELIC_API_KEY=$YOUR_NR_LICENSE_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$YOUR_NR_ACCOUNT_ID \\ > ## If your account is located in Europe, add the following flag: $ ## -nr_region=EU \\ $ ## If you want to use FedRAMP, add the following flag to use the FedRAMP authorized endpoints: $ ## -nr_region=GOV \\ $ -metrics=jchf \\ > -tee_logs=true \\ > -service_name=snmp \\ > nr1.snmp To get better visibility into how your network is being used, set up network flow data monitoring. To get insights into system messages from your devices, setup network syslog collection. Visualize your network performance data in New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 219.64313,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set up SNMP data <em>monitoring</em>",
        "sections": "Set up SNMP data <em>monitoring</em>",
        "tags": "<em>Network</em> <em>performance</em> <em>monitoring</em>",
        "body": " into how your <em>network</em> is being used, set up <em>network</em> flow data <em>monitoring</em>. Visualize your <em>network</em> <em>performance</em> data in New Relic. Manual <em>setup</em> If you prefer to do the <em>setup</em> manually, proceed with the following steps. On a Linux host with Docker installed, download the ktranslate image from dockerhub"
      },
      "id": "6127249b28ccbc09a4f26187"
    }
  ],
  "/docs/network-performance-monitoring/setup-performance-monitoring/network-flow-monitoring": [
    {
      "sections": [
        "Set up network syslog monitoring",
        "Prerequisites",
        "New Relic One account prerequisites",
        "Linux host prerequisites",
        "Network syslog devices prerequisites",
        "Network security prerequisites",
        "Tip",
        "Set up network syslog monitoring in New Relic One"
      ],
      "title": "Set up network syslog monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Installation",
        "Setup",
        "NPM"
      ],
      "external_id": "835cdb37ea4a0497669a79a24ee5fa8904d05ec6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/network-syslog-monitoring/",
      "published_at": "2021-12-30T09:50:55Z",
      "updated_at": "2021-12-19T15:53:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Set up your network devices so they send syslog data to New Relic One. Prerequisites New Relic One account prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. A New Relic account ID. Learn how to find your account ID. A New Relic license key. Learn how to generate a new License key. Linux host prerequisites Docker installed in a Linux host. SSH access to the Docker host, with the ability to launch new containers. Network syslog devices prerequisites Configured network devices to send syslog to the host running the ktranslate docker container. Here's how to configure network flow data collection in some devices: Checkpoint - Security Gateway Cisco - ASA Cisco - IOS Cisco - Meraki Cisco - NX-OS F5 - BIG-IP Fortinet Fortigate Juniper - Junos Palo Alto - PAN-OS Network security prerequisites Direction Source Destination Ports Protocol Outbound Docker host ktranslate image on Docker Hub 443 TCP Outbound Docker host New Relic Log API endpoint: US Endpoint: https://log-api.newrelic.com Copy EU Endpoint: https://log-api.eu.newrelic.com Copy 443 TCP Inbound Source devices for syslog data Docker host 5143 (default) UDP Tip The default listening port for ktranslate is 5143 (TCP/UDP). If you need to use the default syslog port of 514 (or any other port), you can do so by providing a new listening endpoint during Docker runtime. For example: -syslog=\"0.0.0.0:514. Set up network syslog monitoring in New Relic One From a Linux host with Docker installed, download the ktranslate image from dockerhub by running bash Copy $ docker pull kentik/ktranslate:v2 Copy the snmp-base.yaml file to the local $HOME directory of your Docker user, and discard the container by running bash Copy $ cd . $ id=$(docker create kentik/ktranslate:v2) $ docker cp $id:/etc/ktranslate/snmp-base.yaml . $ docker rm -v $id In the snmp-base.yaml file, add your network syslog devices inside the devices key with the following structure: devices: syslogDevice: device_name: edge-router device_ip: 10.10.1.254 ping_only: true # Optional user tags user_tags: owning_team: net_eng environment: production Copy Tip If you're already monitoring SNMP data devices that send network syslog, you don't need to add them in your snmp-base.yaml file a second time. The ping_only attribute used in the configuration file can optionally be replaced with flow_only to remove response time monitoring and only collect syslog messages from the host. Run ktranslate to listen for network syslog by running: bash Copy $ docker run -d --name ktranslate-syslog --restart unless-stopped --net=host \\ > -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ > -e NEW_RELIC_API_KEY=$YOUR_NR_LICENSE_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$YOUR_NR_ACCOUNT_ID \\ > ## If your account is located in Europe, add the following option: $ ## -nr_region=EU \\ $ -metrics=jchf \\ > -tee_logs=true \\ > -service_name=syslog \\ > ## Optional: To override the default listening port of \"0.0.0.0:5143\": $ ## -syslog=\"<ip_address>:<port>\" $ nr1.syslog Tip ktranslate handles syslog in the following formats: RFC3164, RFC5424, and RFC6587. Investigate your device syslog messages in the New Relic One logs UI, using the following query: \"plugin.type\":\"ktranslate-syslog\" Copy To get better visibility into your network device performance, set up SNMP data monitoring. To get better visibility into how your network is being used, set up network flow data monitoring.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 270.80524,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set up <em>network</em> syslog <em>monitoring</em>",
        "sections": "Set up <em>network</em> syslog <em>monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": " visibility into your <em>network</em> device <em>performance</em>, set up SNMP data <em>monitoring</em>. To get better visibility into how your <em>network</em> is being used, set up <em>network</em> flow data <em>monitoring</em>."
      },
      "id": "619e0cec64441f61ed985635"
    },
    {
      "sections": [
        "Set up AWS VPC flow log monitoring",
        "BETA FEATURE",
        "Prerequisites",
        "New Relic One account prerequisites",
        "AWS prerequisites",
        "Required fields from VPC flow logs",
        "Important",
        "Set up AWS VPC flow logs monitoring in New Relic One",
        "1. Create a private ECR registry and upload the ktranslate image",
        "2. Create a Lambda function from the ECR image",
        "3. Validate your settings",
        "Tip",
        "Find and use your metrics",
        "Environment variables for AWS Lambda functions"
      ],
      "title": "Set up AWS VPC flow log monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Installation",
        "Setup",
        "NPM"
      ],
      "external_id": "731cb14ed615d1aefed80df8a4e1c4360ce90a21",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/aws-vpc-flow-monitoring/",
      "published_at": "2021-12-30T06:23:20Z",
      "updated_at": "2021-12-04T09:48:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in open beta and still in development, but we encourage you to try it out! Set up your AWS VPC flow logs to send them to New Relic One. Prerequisites New Relic One account prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. A New Relic account ID. Read how to find your account ID. A New Relic license key. Read how to generate a new License key. AWS prerequisites AWS VPC Flow Export configured to existing S3 bucket. Permissions to build and publish images to Amazon ECR. Permissions to create a Lambda function. AWS CLI (v 1.9.15+) installed. Docker installed. Required fields from VPC flow logs Important The default format for flow logs does not include all of the required fields that are required for ktranslate to work properly. You must ensure that the below fields are added or the data you'll receive in New Relic One will be incomplete. Flow Record Field Description version The VPC Flow Logs version. srcaddr The source address for incoming traffic, or the IPv4 or IPv6 address of the network interface for outgoing traffic. For a network interface, the IPv4 address is always its private IPv4 address. dstaddr The destination address for outgoing traffic, or the IPv4 or IPv6 address of the network interface for incoming traffic. For a network interface, the IPv4 address is always its private IPv4 address. srcport The source port of the traffic. dstport The destination port of the traffic. protocol The IANA protocol number of the traffic. packets The number of packets transferred during the flow. bytes The number of bytes transferred during the flow. vpc-id The ID of the VPC that contains the network interface for which the traffic is recorded. flow-direction The direction of the flow with respect to the interface where traffic is captured. The possible values are ingress and egress. Set up AWS VPC flow logs monitoring in New Relic One To send your VPC flow logs to New Relic One, follow these steps: Create a private ECR registry and upload the ktranslate image Create a Lambda function from the ECR image Validate your settings 1. Create a private ECR registry and upload the ktranslate image Authenticate to your registry by running: bash Copy $ aws ecr get-login-password --region $AWS_ACCOUNT_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_ACCOUNT_REGION.amazonaws.com Create a repository to hold the ktranslate image by running: bash Copy $ aws ecr create-repository --repository-name ktranslate --image-scanning-configuration scanOnPush=true --region $AWS_ACCOUNT_REGION Pull the ktranslate image from Docker Hub by running: bash Copy $ docker pull kentik/ktranslate:v2 Tag the image to push to your docker repository by running: bash Copy $ docker tag kentik/ktranslate:v2 $AWS_ACCOUNT_ID.dkr.ecr.$AWS_ACCOUNT_REGION.amazonaws.com/ktranslate:v2 Push the image to your docker repository by running: bash Copy $ docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_ACCOUNT_REGION.amazonaws.com/ktranslate:v2 After running these steps, you should see an output similar to the following: bash Copy $ The push refers to repository [$AWS_ACCOUNT_ID.dkr.ecr.$AWS_ACCOUNT_REGION.amazonaws.com/ktranslate] $ 870d899ac0b0: Pushed $ 0a4768abd477: Pushed $ b206b92a2843: Pushed $ 22abafd3e6c9: Pushed $ 1335c3725252: Pushed $ 7188c9350e77: Pushed $ 2b75f71baacd: Pushed $ ba50c5652654: Pushed $ 80bbd31930ea: Pushed $ c3d2a28a326e: Pushed $ 1a058d5342cc: Pushed $ v2: digest: sha256:4cfe36919ae954063203a80f69ca1795280117c44947a09d678b4842bb8e4dd2 size: 2624 2. Create a Lambda function from the ECR image The Lambda function you create must reside in the same AWS Region as the S3 bucket where you store your VPC flow logs. To create a Lambda function defined as a container image, follow the following steps: Navigate to the Lambda service in your AWS console and select Create function. Select the Container image tile at the top of the screen, and: Name your function. Click Browse Images and choose the ktranslate image with the v2 tag you pushed to ECR. Keep the architecture on x86_64, accept the default permissions, and click Create function. On the landing page for your new function, select the Configuration tab, and: In General configuration, change the timeout value to 0 min 20 sec. In the Permissions section, click Execution role for your function, which will open a new tab for IAM. On the Permissions tab, select Attach policies and add the AmazonS3ReadOnlyAccess to grant your function access to the S3 bucket your VPC flow logs are in. Back on your function's landing page, in the Environment variables section, click Edit and add the Lambda environment variables. On the Triggers section, click Add trigger, and: Select the S3 type. Select the bucket where you store your VPC Flow Logs. Choose the All object create events event type. Optionally, if your bucket has a custom folder in the root directory outside the AWSLogs directory, you can add it in the Prefix section. Accept the Recursive Invocation warning and click Add. At this point, your Lambda function is deployed and listening for new events on your S3 bucket. 3. Validate your settings Tip It can take several minutes for data to first appear in your account as the export of VPC flow logs to S3 usually runs on a 5-minute cycle. To confirm your Lambda function is working as expected, do one of the following: Go to one.newrelic.com > Explorer and you will begin to see VPC Network entities. You can click them and investigate the various metrics each one is sending. Go to one.newrelic.com > Query your data and to get a quick summary of the recent VPCs that you have flow logs from, run the following NRQL query: FROM KFlow SELECT count(*) FACET device_name WHERE provider = 'kentik-vpc' Copy In your AWS Console, click the Monitor tab in your function's landing page, where you can track important metrics like invocation, error count, and success rate. You can also investigate the error logs from recent invocations. Tip We recommend you to add serverless monitoring from New Relic One to your new Lambda function. This way, you'll proactively monitor the health of the function and get alerts in case of problems. Find and use your metrics All VPC flow logs exported from the ktranslate Lambda function use the KFlow namespace, via the New Relic Event API. Currently, these are the fields populated from this integration: Attribute Type Description application String The class of program generating the traffic in this flow record. This is derived from the lowest numeric value from l4_dst_port and l4_src_port. Common examples include http, ssh, and ftp. dest_vpc String The name of the VPC the traffic in this flow record is targeting, if known. device_name String The name of the VPC this flow record was exported from. dst_addr String The target IPv4 address for this flow record. dst_as Numeric The target Autonomous System Number for this flow record. dst_as_name String The target Autonomous System Name for this flow record. dst_endpoint String The target IP:Port tuple for this flow record. This is a combination of dst_addr and l4_dst_port. dst_geo String The target country for this flow record, if known. flow_direction String The direction of flow for this record, from the point of view of the interface where the traffic was captured. Valid options are ingress | egress. in_bytes Numeric The number of bytes transferred for ingress flow records. in_pkts Numeric The number of packets transferred for ingress flow records. l4_dst_port Numeric The target port for this flow record. l4_src_port Numeric The source port for this flow record. out_bytes Numeric The number of bytes transferred for egress flow records. out_pkts Numeric The number of packets transferred for egress flow records. protocol String The display name of the protocol used in this flow record, derived from the numeric IANA protocol number provider String This attribute is used to uniquely identify various sources of data from ktranslate. VPC flow logs will always have the value of kentik-vpc. sample_rate Numeric The rate at which ktranslate samples from the various files in the S3 bucket for flow exports. (Default: 1000) This can be configured with the KENTIK_SAMPLE_RATE environment variable. source_vpc String The name of the VPC the traffic in this flow record originated from, if known. src_addr String The source IPv4 address for this flow record. src_as Numeric The source Autonomous System Number for this flow record. src_as_name String The source Autonomous System Name for this flow record. src_endpoint String The source IP:Port tuple for this flow record. This is a combination of src_addr and l4_src_port. src_geo String The source country for this flow record, if known. start_time Numeric The time, in Unix seconds, when the first packet of the flow was received within the aggregation interval. This might be up to 60 seconds after the packet was transmitted or received on the network interface. timestamp Numeric The time, in Unix seconds, when this flow record was received by the New Relic Event API. Environment variables for AWS Lambda functions When you're configuring your AWS Lambda function, you need to set up the following environment variables: Key Value Required KENTIK_MODE nr1.vpc.lambda √ NEW_RELIC_API_KEY The New Relic license key for your account √ NR_ACCOUNT_ID Your New Relic account ID √ NR_REGION The New Relic datacenter region for your account. The possible values are US and EU, and by default it's set to US. KENTIK_SAMPLE_RATE The rate of randomized sampling ktranslate applies to the flow export objects in S3. By default, it's set to 1000. Setting this to 1 disables all sampling and ktranslate ships all flow records to New Relic One. Tip For S3 objects with less than 100 flow records, ktranslate will revert to a sample rate of 1 and process every record. For S3 objects with more than 100 flow records, ktranslate will use the configured value of KENTIK_SAMPLE_RATE, which has a default of 1000. Meaning that every record in the object has a 1:1000 change of being sampled.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 233.17052,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set up AWS VPC flow log <em>monitoring</em>",
        "sections": "Set up AWS VPC flow log <em>monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": " the error logs from recent invocations. Tip We recommend you to add serverless <em>monitoring</em> from New Relic One to your new Lambda function. This way, you&#x27;ll proactively <em>monitor</em> the health of the function and get alerts in case of problems. Find and use your metrics All VPC flow logs exported from"
      },
      "id": "61ab3986196a67a119d1082f"
    },
    {
      "sections": [
        "Set up SNMP data monitoring",
        "Prerequisites",
        "New Relic One account prerequisites",
        "Linux host prerequisites",
        "SNMP devices prerequisites",
        "Network security prerequisites",
        "Supported SNMP versions",
        "Tip",
        "Set up SNMP data monitoring in New Relic One",
        "Manual setup"
      ],
      "title": "Set up SNMP data monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Installation",
        "Setup"
      ],
      "external_id": "ab50c7659f03d76e429769be42ddec21d4744a0d",
      "image": "https://docs.newrelic.com/static/59f9f8d2d86daf23058506e7cf1c9fcc/c1b63/snmp-guided-install.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/snmp-performance-monitoring/",
      "published_at": "2021-12-30T09:52:07Z",
      "updated_at": "2021-12-04T22:08:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Set up your network devices so they send network data to New Relic One. Prerequisites New Relic One account prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. A New Relic account ID. Read how to find your account ID. A New Relic license key. Read how to generate a new License key. Linux host prerequisites Docker installed in a Linux host. SSH access to the Docker host, with the ability to launch new containers. SNMP devices prerequisites Configured network devices for SNMP polling from the ktranslate docker container. Some samples of basic SNMP configurations can be found here: Cisco IOS Meraki NX-OS Juniper Junos OS Palo Alto PAN-OS Network security prerequisites Direction Source Destination Ports Protocol Outbound Docker host ktranslate image on Docker Hub 443 TCP Outbound Docker host New Relic Metric API US Endpoint: https://metric-api.newrelic.com EU Endpoint: https://metric-api.eu.newrelic.com 443 TCP Outbound Docker host New Relic Log API US Endpoint: https://log-api.newrelic.com EU Endpoint: https://log-api.eu.newrelic.com 443 TCP Outbound Docker host Target devices for SNMP polling 161 (default) UDP Inbound Source devices for SNMP Trap data Docker host 162 (default) UDP Supported SNMP versions Our NPM container supports all major versions of SNMP (v1, v2c, and v3). Additionally, SNMP v3 has support for the following authentication and privacy settings: Setting Protocol Authentication NoAuth Authentication MD5 Authentication SHA Authentication SHA224 Authentication SHA256 Authentication SHA384 Authentication SHA512 Privacy NoPriv Privacy DES Privacy AES Privacy AES192 Privacy AES256 Privacy AES192C Privacy AES256C Tip We recommend using read-only community strings/authentication with SNMP Set up SNMP data monitoring in New Relic One Go to one.newrelic.com and click Add more data. Scroll down until you see Network performance monitoring and click SNMP. Follow the steps in New Relic One. one.newrelic.com > Add more data > Network performance monitoring > SNMP to set up SNMP data monitoring. To get better visibility into how your network is being used, set up network flow data monitoring. Visualize your network performance data in New Relic. Manual setup If you prefer to do the setup manually, proceed with the following steps. On a Linux host with Docker installed, download the ktranslate image from dockerhub by running bash Copy $ docker pull kentik/ktranslate:v2 Copy the snmp-base.yaml file to the local $HOME directory of your Docker user, and discard the container by running bash Copy $ cd . $ id=$(docker create kentik/ktranslate:v2) $ docker cp $id:/etc/ktranslate/snmp-base.yaml . $ docker rm -v $id Edit the snmp-base.yaml file and define the discovery.cidrs and discovery.default_communities attributes to appropriate values for your network. Tip It's recommended to set discovery.add_mibs: true to automate the addition of all discovered MIBs into the global.mibs_enabled attribute Launch a short-lived container to execute discovery by running bash Copy $ docker run -ti --name ktranslate-discovery --rm --net=host \\ > --user `id -u`:`id -g` \\ > -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -log_level info \\ > -snmp_discovery=true After the discovery run finishes, you should see an output similar to the following: bash Copy $ >[Info] KTranslate Adding 3 new snmp devices to the config, 0 replaced from 3 $ # In this example, the discovery run found 3 new SNMP devices. The discovered devices are listed in the snmp-base.yaml file's devices.{} section. By default, only the IF-MIB mib is polled. You can manually add other mibs to the global.mibs_enabled attribute if you did not set discovery.add_mibs: true before running the discovery. Run ktranslate to poll target devices by running: bash Copy $ docker run -d --name ktranslate-snmp --restart unless-stopped --net=host \\ > -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ > -e NEW_RELIC_API_KEY=$YOUR_NR_LICENSE_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$YOUR_NR_ACCOUNT_ID \\ > ## If your account is located in Europe, add the following flag: $ ## -nr_region=EU \\ $ ## If you want to use FedRAMP, add the following flag to use the FedRAMP authorized endpoints: $ ## -nr_region=GOV \\ $ -metrics=jchf \\ > -tee_logs=true \\ > -service_name=snmp \\ > nr1.snmp To get better visibility into how your network is being used, set up network flow data monitoring. To get insights into system messages from your devices, setup network syslog collection. Visualize your network performance data in New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 219.64313,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set up SNMP data <em>monitoring</em>",
        "sections": "Set up SNMP data <em>monitoring</em>",
        "tags": "<em>Network</em> <em>performance</em> <em>monitoring</em>",
        "body": " into how your <em>network</em> is being used, set up <em>network</em> flow data <em>monitoring</em>. Visualize your <em>network</em> <em>performance</em> data in New Relic. Manual <em>setup</em> If you prefer to do the <em>setup</em> manually, proceed with the following steps. On a Linux host with Docker installed, download the ktranslate image from dockerhub"
      },
      "id": "6127249b28ccbc09a4f26187"
    }
  ],
  "/docs/network-performance-monitoring/setup-performance-monitoring/network-syslog-monitoring": [
    {
      "sections": [
        "Set up network flow data monitoring",
        "Prerequisites",
        "New Relic One account prerequisites",
        "Linux host prerequisites",
        "Network flow data devices prerequisites",
        "Network security prerequisites",
        "Supported types of network flow data",
        "Important",
        "Scaling network flow collection",
        "Set up network flow data monitoring in New Relic One",
        "Manual setup",
        "Tip"
      ],
      "title": "Set up network flow data monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Installation",
        "Setup",
        "NPM"
      ],
      "external_id": "626c9bebce36e550d5793d8ef932e6d654c23e47",
      "image": "https://docs.newrelic.com/static/3d1561743f3311471975006fa41f628a/c1b63/network-flows-guided-install.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/network-flow-monitoring/",
      "published_at": "2021-12-30T03:13:18Z",
      "updated_at": "2021-12-04T22:07:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Set up your network devices so they send network data to New Relic One. Prerequisites New Relic One account prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. A New Relic account ID. Read how to find your account ID. A New Relic license key. Read how to generate a new License key. Linux host prerequisites Docker installed in a Linux host. SSH access to the Docker host, with the ability to launch new containers. Network flow data devices prerequisites Configured network devices to send flow data to the host running the ktranslate docker container. Here's how to configure network flow data collection in some devices: NetFlow data Cisco - IOS Cisco - Meraki Cisco - NX-OS Fortinet Fortigate Palo Alto - PAN-OS sFlow data F5 - BIG-IP jFlow data Juniper - Junos Network security prerequisites Direction Source Destination Ports Protocol Outbound Docker host ktranslate image on Docker Hub 443 TCP Outbound Docker host New Relic Event API US Endpoint: https://insights-collector.newrelic.com EU Endpoint: https://insights-collector.eu01.nr-data.net 443 TCP Outbound Docker host New Relic Log API US Endpoint: https://log-api.newrelic.com EU Endpoint: https://log-api.eu.newrelic.com 443 TCP Inbound Source devices for network flow data Docker host 9995 (default) UDP Supported types of network flow data NPM flow monitoring supports the four primary types of network flow data and their derivatives. When running the ktranslate container, you will specify which major type you want to monitor using the -nf.source option. Important The ktranslate container only supports monitoring one type of network flow data type at a time. If you want to monitor several types, each will require a container. IPFIX and NetFlow v9 can be sent to the same container, but we recommend running a separate container as a best practice. Network flow data type -nf.source value IPFIX ipfix NetFlow v5 netflow5 NetFlow v9 netflow9 sFlow sflow AppFlow netflow5 Argus netflow5 cflowd netflow5 J-Flow netflow5 NetStream netflow5 RFlow netflow5 Cisco NSEL netflow9 Scaling network flow collection When planning your strategy for collecting network flows at scale, New Relic recommends 1 CPU per 2000 flows-per-second (120,000 flows-per-minute). Deciding whether to run more small containers to distribute load or fewer large containers to consolidate management is a matter of personal preference. Set up network flow data monitoring in New Relic One Go to one.newrelic.com and click Add more data. Scroll down until you see Network performance monitoring and click Network Flows. Follow the steps in New Relic One. one.newrelic.com > Add more data > Network performance monitoring > Network Flows to set up network flow data monitoring. To get better visibility into your network device performance, set up SNMP data monitoring. Visualize your network performance data in New Relic. Manual setup If you prefer to do the setup manually, proceed with the following steps. In your local machine, from a Linux host with Docker installed, download the ktranslate image from dockerhub by running bash Copy $ docker pull kentik/ktranslate:v2 Copy the snmp-base.yaml file to the local $HOME directory of your Docker user, and discard the container by running bash Copy $ cd . $ id=$(docker create kentik/ktranslate:v2) $ docker cp $id:/etc/ktranslate/snmp-base.yaml . $ docker rm -v $id In the snmp-base.yaml file, add your network flow devices inside the devices key with the following structure: devices: flowDevice: device_name: edge-router device_ip: 10.10.1.254 flow_only: true # Optional user tags user_tags: owning_team: net_eng environment: production Copy Tip If you're already monitoring SNMP data devices that send network flow data, you don't need to add them in your snmp-base.yaml file a second time. Run ktranslate to listen for network flows by running: bash Copy $ docker run -d --name ktranslate-sflow --restart unless-stopped --net=host \\ > -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ > -e NEW_RELIC_API_KEY=$YOUR_NR_LICENSE_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$YOUR_NR_ACCOUNT_ID \\ > ## If your account is located in Europe, add the following flag: $ ## -nr_region=EU \\ $ ## If you want to use FedRAMP, add the following flag to use the FedRAMP authorized endpoints: $ ## -nr_region=GOV \\ $ -metrics=jchf \\ > -tee_logs=true \\ > -flow_only=true \\ > -nf.source=sflow \\ > -service_name=sflow \\ > nr1.flow Tip This command assumes collection of sflow data. If you are collecting other flow types, you should change the suffix in the --name flag for the container and update the -nf.source and -service_name flags as necessary. To get better visibility into your network device performance, set up SNMP data monitoring. To get insights into system messages from your devices, setup network syslog collection. Visualize your network performance data in New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 233.92369,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set up <em>network</em> flow data <em>monitoring</em>",
        "sections": "Set up <em>network</em> flow data <em>monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": " <em>monitoring</em> &gt; <em>Network</em> Flows to set up <em>network</em> flow data <em>monitoring</em>. To get better visibility into your <em>network</em> device <em>performance</em>, set up SNMP data <em>monitoring</em>. Visualize your <em>network</em> <em>performance</em> data in New Relic. Manual <em>setup</em> If you prefer to do the <em>setup</em> manually, proceed with the following steps. In your"
      },
      "id": "612724e128ccbc4ac9f2612a"
    },
    {
      "sections": [
        "Set up AWS VPC flow log monitoring",
        "BETA FEATURE",
        "Prerequisites",
        "New Relic One account prerequisites",
        "AWS prerequisites",
        "Required fields from VPC flow logs",
        "Important",
        "Set up AWS VPC flow logs monitoring in New Relic One",
        "1. Create a private ECR registry and upload the ktranslate image",
        "2. Create a Lambda function from the ECR image",
        "3. Validate your settings",
        "Tip",
        "Find and use your metrics",
        "Environment variables for AWS Lambda functions"
      ],
      "title": "Set up AWS VPC flow log monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Installation",
        "Setup",
        "NPM"
      ],
      "external_id": "731cb14ed615d1aefed80df8a4e1c4360ce90a21",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/aws-vpc-flow-monitoring/",
      "published_at": "2021-12-30T06:23:20Z",
      "updated_at": "2021-12-04T09:48:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in open beta and still in development, but we encourage you to try it out! Set up your AWS VPC flow logs to send them to New Relic One. Prerequisites New Relic One account prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. A New Relic account ID. Read how to find your account ID. A New Relic license key. Read how to generate a new License key. AWS prerequisites AWS VPC Flow Export configured to existing S3 bucket. Permissions to build and publish images to Amazon ECR. Permissions to create a Lambda function. AWS CLI (v 1.9.15+) installed. Docker installed. Required fields from VPC flow logs Important The default format for flow logs does not include all of the required fields that are required for ktranslate to work properly. You must ensure that the below fields are added or the data you'll receive in New Relic One will be incomplete. Flow Record Field Description version The VPC Flow Logs version. srcaddr The source address for incoming traffic, or the IPv4 or IPv6 address of the network interface for outgoing traffic. For a network interface, the IPv4 address is always its private IPv4 address. dstaddr The destination address for outgoing traffic, or the IPv4 or IPv6 address of the network interface for incoming traffic. For a network interface, the IPv4 address is always its private IPv4 address. srcport The source port of the traffic. dstport The destination port of the traffic. protocol The IANA protocol number of the traffic. packets The number of packets transferred during the flow. bytes The number of bytes transferred during the flow. vpc-id The ID of the VPC that contains the network interface for which the traffic is recorded. flow-direction The direction of the flow with respect to the interface where traffic is captured. The possible values are ingress and egress. Set up AWS VPC flow logs monitoring in New Relic One To send your VPC flow logs to New Relic One, follow these steps: Create a private ECR registry and upload the ktranslate image Create a Lambda function from the ECR image Validate your settings 1. Create a private ECR registry and upload the ktranslate image Authenticate to your registry by running: bash Copy $ aws ecr get-login-password --region $AWS_ACCOUNT_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_ACCOUNT_REGION.amazonaws.com Create a repository to hold the ktranslate image by running: bash Copy $ aws ecr create-repository --repository-name ktranslate --image-scanning-configuration scanOnPush=true --region $AWS_ACCOUNT_REGION Pull the ktranslate image from Docker Hub by running: bash Copy $ docker pull kentik/ktranslate:v2 Tag the image to push to your docker repository by running: bash Copy $ docker tag kentik/ktranslate:v2 $AWS_ACCOUNT_ID.dkr.ecr.$AWS_ACCOUNT_REGION.amazonaws.com/ktranslate:v2 Push the image to your docker repository by running: bash Copy $ docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_ACCOUNT_REGION.amazonaws.com/ktranslate:v2 After running these steps, you should see an output similar to the following: bash Copy $ The push refers to repository [$AWS_ACCOUNT_ID.dkr.ecr.$AWS_ACCOUNT_REGION.amazonaws.com/ktranslate] $ 870d899ac0b0: Pushed $ 0a4768abd477: Pushed $ b206b92a2843: Pushed $ 22abafd3e6c9: Pushed $ 1335c3725252: Pushed $ 7188c9350e77: Pushed $ 2b75f71baacd: Pushed $ ba50c5652654: Pushed $ 80bbd31930ea: Pushed $ c3d2a28a326e: Pushed $ 1a058d5342cc: Pushed $ v2: digest: sha256:4cfe36919ae954063203a80f69ca1795280117c44947a09d678b4842bb8e4dd2 size: 2624 2. Create a Lambda function from the ECR image The Lambda function you create must reside in the same AWS Region as the S3 bucket where you store your VPC flow logs. To create a Lambda function defined as a container image, follow the following steps: Navigate to the Lambda service in your AWS console and select Create function. Select the Container image tile at the top of the screen, and: Name your function. Click Browse Images and choose the ktranslate image with the v2 tag you pushed to ECR. Keep the architecture on x86_64, accept the default permissions, and click Create function. On the landing page for your new function, select the Configuration tab, and: In General configuration, change the timeout value to 0 min 20 sec. In the Permissions section, click Execution role for your function, which will open a new tab for IAM. On the Permissions tab, select Attach policies and add the AmazonS3ReadOnlyAccess to grant your function access to the S3 bucket your VPC flow logs are in. Back on your function's landing page, in the Environment variables section, click Edit and add the Lambda environment variables. On the Triggers section, click Add trigger, and: Select the S3 type. Select the bucket where you store your VPC Flow Logs. Choose the All object create events event type. Optionally, if your bucket has a custom folder in the root directory outside the AWSLogs directory, you can add it in the Prefix section. Accept the Recursive Invocation warning and click Add. At this point, your Lambda function is deployed and listening for new events on your S3 bucket. 3. Validate your settings Tip It can take several minutes for data to first appear in your account as the export of VPC flow logs to S3 usually runs on a 5-minute cycle. To confirm your Lambda function is working as expected, do one of the following: Go to one.newrelic.com > Explorer and you will begin to see VPC Network entities. You can click them and investigate the various metrics each one is sending. Go to one.newrelic.com > Query your data and to get a quick summary of the recent VPCs that you have flow logs from, run the following NRQL query: FROM KFlow SELECT count(*) FACET device_name WHERE provider = 'kentik-vpc' Copy In your AWS Console, click the Monitor tab in your function's landing page, where you can track important metrics like invocation, error count, and success rate. You can also investigate the error logs from recent invocations. Tip We recommend you to add serverless monitoring from New Relic One to your new Lambda function. This way, you'll proactively monitor the health of the function and get alerts in case of problems. Find and use your metrics All VPC flow logs exported from the ktranslate Lambda function use the KFlow namespace, via the New Relic Event API. Currently, these are the fields populated from this integration: Attribute Type Description application String The class of program generating the traffic in this flow record. This is derived from the lowest numeric value from l4_dst_port and l4_src_port. Common examples include http, ssh, and ftp. dest_vpc String The name of the VPC the traffic in this flow record is targeting, if known. device_name String The name of the VPC this flow record was exported from. dst_addr String The target IPv4 address for this flow record. dst_as Numeric The target Autonomous System Number for this flow record. dst_as_name String The target Autonomous System Name for this flow record. dst_endpoint String The target IP:Port tuple for this flow record. This is a combination of dst_addr and l4_dst_port. dst_geo String The target country for this flow record, if known. flow_direction String The direction of flow for this record, from the point of view of the interface where the traffic was captured. Valid options are ingress | egress. in_bytes Numeric The number of bytes transferred for ingress flow records. in_pkts Numeric The number of packets transferred for ingress flow records. l4_dst_port Numeric The target port for this flow record. l4_src_port Numeric The source port for this flow record. out_bytes Numeric The number of bytes transferred for egress flow records. out_pkts Numeric The number of packets transferred for egress flow records. protocol String The display name of the protocol used in this flow record, derived from the numeric IANA protocol number provider String This attribute is used to uniquely identify various sources of data from ktranslate. VPC flow logs will always have the value of kentik-vpc. sample_rate Numeric The rate at which ktranslate samples from the various files in the S3 bucket for flow exports. (Default: 1000) This can be configured with the KENTIK_SAMPLE_RATE environment variable. source_vpc String The name of the VPC the traffic in this flow record originated from, if known. src_addr String The source IPv4 address for this flow record. src_as Numeric The source Autonomous System Number for this flow record. src_as_name String The source Autonomous System Name for this flow record. src_endpoint String The source IP:Port tuple for this flow record. This is a combination of src_addr and l4_src_port. src_geo String The source country for this flow record, if known. start_time Numeric The time, in Unix seconds, when the first packet of the flow was received within the aggregation interval. This might be up to 60 seconds after the packet was transmitted or received on the network interface. timestamp Numeric The time, in Unix seconds, when this flow record was received by the New Relic Event API. Environment variables for AWS Lambda functions When you're configuring your AWS Lambda function, you need to set up the following environment variables: Key Value Required KENTIK_MODE nr1.vpc.lambda √ NEW_RELIC_API_KEY The New Relic license key for your account √ NR_ACCOUNT_ID Your New Relic account ID √ NR_REGION The New Relic datacenter region for your account. The possible values are US and EU, and by default it's set to US. KENTIK_SAMPLE_RATE The rate of randomized sampling ktranslate applies to the flow export objects in S3. By default, it's set to 1000. Setting this to 1 disables all sampling and ktranslate ships all flow records to New Relic One. Tip For S3 objects with less than 100 flow records, ktranslate will revert to a sample rate of 1 and process every record. For S3 objects with more than 100 flow records, ktranslate will use the configured value of KENTIK_SAMPLE_RATE, which has a default of 1000. Meaning that every record in the object has a 1:1000 change of being sampled.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 233.1705,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set up AWS VPC flow log <em>monitoring</em>",
        "sections": "Set up AWS VPC flow log <em>monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": " the error logs from recent invocations. Tip We recommend you to add serverless <em>monitoring</em> from New Relic One to your new Lambda function. This way, you&#x27;ll proactively <em>monitor</em> the health of the function and get alerts in case of problems. Find and use your metrics All VPC flow logs exported from"
      },
      "id": "61ab3986196a67a119d1082f"
    },
    {
      "sections": [
        "Set up SNMP data monitoring",
        "Prerequisites",
        "New Relic One account prerequisites",
        "Linux host prerequisites",
        "SNMP devices prerequisites",
        "Network security prerequisites",
        "Supported SNMP versions",
        "Tip",
        "Set up SNMP data monitoring in New Relic One",
        "Manual setup"
      ],
      "title": "Set up SNMP data monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Installation",
        "Setup"
      ],
      "external_id": "ab50c7659f03d76e429769be42ddec21d4744a0d",
      "image": "https://docs.newrelic.com/static/59f9f8d2d86daf23058506e7cf1c9fcc/c1b63/snmp-guided-install.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/snmp-performance-monitoring/",
      "published_at": "2021-12-30T09:52:07Z",
      "updated_at": "2021-12-04T22:08:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Set up your network devices so they send network data to New Relic One. Prerequisites New Relic One account prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. A New Relic account ID. Read how to find your account ID. A New Relic license key. Read how to generate a new License key. Linux host prerequisites Docker installed in a Linux host. SSH access to the Docker host, with the ability to launch new containers. SNMP devices prerequisites Configured network devices for SNMP polling from the ktranslate docker container. Some samples of basic SNMP configurations can be found here: Cisco IOS Meraki NX-OS Juniper Junos OS Palo Alto PAN-OS Network security prerequisites Direction Source Destination Ports Protocol Outbound Docker host ktranslate image on Docker Hub 443 TCP Outbound Docker host New Relic Metric API US Endpoint: https://metric-api.newrelic.com EU Endpoint: https://metric-api.eu.newrelic.com 443 TCP Outbound Docker host New Relic Log API US Endpoint: https://log-api.newrelic.com EU Endpoint: https://log-api.eu.newrelic.com 443 TCP Outbound Docker host Target devices for SNMP polling 161 (default) UDP Inbound Source devices for SNMP Trap data Docker host 162 (default) UDP Supported SNMP versions Our NPM container supports all major versions of SNMP (v1, v2c, and v3). Additionally, SNMP v3 has support for the following authentication and privacy settings: Setting Protocol Authentication NoAuth Authentication MD5 Authentication SHA Authentication SHA224 Authentication SHA256 Authentication SHA384 Authentication SHA512 Privacy NoPriv Privacy DES Privacy AES Privacy AES192 Privacy AES256 Privacy AES192C Privacy AES256C Tip We recommend using read-only community strings/authentication with SNMP Set up SNMP data monitoring in New Relic One Go to one.newrelic.com and click Add more data. Scroll down until you see Network performance monitoring and click SNMP. Follow the steps in New Relic One. one.newrelic.com > Add more data > Network performance monitoring > SNMP to set up SNMP data monitoring. To get better visibility into how your network is being used, set up network flow data monitoring. Visualize your network performance data in New Relic. Manual setup If you prefer to do the setup manually, proceed with the following steps. On a Linux host with Docker installed, download the ktranslate image from dockerhub by running bash Copy $ docker pull kentik/ktranslate:v2 Copy the snmp-base.yaml file to the local $HOME directory of your Docker user, and discard the container by running bash Copy $ cd . $ id=$(docker create kentik/ktranslate:v2) $ docker cp $id:/etc/ktranslate/snmp-base.yaml . $ docker rm -v $id Edit the snmp-base.yaml file and define the discovery.cidrs and discovery.default_communities attributes to appropriate values for your network. Tip It's recommended to set discovery.add_mibs: true to automate the addition of all discovered MIBs into the global.mibs_enabled attribute Launch a short-lived container to execute discovery by running bash Copy $ docker run -ti --name ktranslate-discovery --rm --net=host \\ > --user `id -u`:`id -g` \\ > -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -log_level info \\ > -snmp_discovery=true After the discovery run finishes, you should see an output similar to the following: bash Copy $ >[Info] KTranslate Adding 3 new snmp devices to the config, 0 replaced from 3 $ # In this example, the discovery run found 3 new SNMP devices. The discovered devices are listed in the snmp-base.yaml file's devices.{} section. By default, only the IF-MIB mib is polled. You can manually add other mibs to the global.mibs_enabled attribute if you did not set discovery.add_mibs: true before running the discovery. Run ktranslate to poll target devices by running: bash Copy $ docker run -d --name ktranslate-snmp --restart unless-stopped --net=host \\ > -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ > -e NEW_RELIC_API_KEY=$YOUR_NR_LICENSE_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$YOUR_NR_ACCOUNT_ID \\ > ## If your account is located in Europe, add the following flag: $ ## -nr_region=EU \\ $ ## If you want to use FedRAMP, add the following flag to use the FedRAMP authorized endpoints: $ ## -nr_region=GOV \\ $ -metrics=jchf \\ > -tee_logs=true \\ > -service_name=snmp \\ > nr1.snmp To get better visibility into how your network is being used, set up network flow data monitoring. To get insights into system messages from your devices, setup network syslog collection. Visualize your network performance data in New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 219.64311,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set up SNMP data <em>monitoring</em>",
        "sections": "Set up SNMP data <em>monitoring</em>",
        "tags": "<em>Network</em> <em>performance</em> <em>monitoring</em>",
        "body": " into how your <em>network</em> is being used, set up <em>network</em> flow data <em>monitoring</em>. Visualize your <em>network</em> <em>performance</em> data in New Relic. Manual <em>setup</em> If you prefer to do the <em>setup</em> manually, proceed with the following steps. On a Linux host with Docker installed, download the ktranslate image from dockerhub"
      },
      "id": "6127249b28ccbc09a4f26187"
    }
  ],
  "/docs/network-performance-monitoring/setup-performance-monitoring/snmp-performance-monitoring": [
    {
      "sections": [
        "Set up network syslog monitoring",
        "Prerequisites",
        "New Relic One account prerequisites",
        "Linux host prerequisites",
        "Network syslog devices prerequisites",
        "Network security prerequisites",
        "Tip",
        "Set up network syslog monitoring in New Relic One"
      ],
      "title": "Set up network syslog monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Installation",
        "Setup",
        "NPM"
      ],
      "external_id": "835cdb37ea4a0497669a79a24ee5fa8904d05ec6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/network-syslog-monitoring/",
      "published_at": "2021-12-30T09:50:55Z",
      "updated_at": "2021-12-19T15:53:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Set up your network devices so they send syslog data to New Relic One. Prerequisites New Relic One account prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. A New Relic account ID. Learn how to find your account ID. A New Relic license key. Learn how to generate a new License key. Linux host prerequisites Docker installed in a Linux host. SSH access to the Docker host, with the ability to launch new containers. Network syslog devices prerequisites Configured network devices to send syslog to the host running the ktranslate docker container. Here's how to configure network flow data collection in some devices: Checkpoint - Security Gateway Cisco - ASA Cisco - IOS Cisco - Meraki Cisco - NX-OS F5 - BIG-IP Fortinet Fortigate Juniper - Junos Palo Alto - PAN-OS Network security prerequisites Direction Source Destination Ports Protocol Outbound Docker host ktranslate image on Docker Hub 443 TCP Outbound Docker host New Relic Log API endpoint: US Endpoint: https://log-api.newrelic.com Copy EU Endpoint: https://log-api.eu.newrelic.com Copy 443 TCP Inbound Source devices for syslog data Docker host 5143 (default) UDP Tip The default listening port for ktranslate is 5143 (TCP/UDP). If you need to use the default syslog port of 514 (or any other port), you can do so by providing a new listening endpoint during Docker runtime. For example: -syslog=\"0.0.0.0:514. Set up network syslog monitoring in New Relic One From a Linux host with Docker installed, download the ktranslate image from dockerhub by running bash Copy $ docker pull kentik/ktranslate:v2 Copy the snmp-base.yaml file to the local $HOME directory of your Docker user, and discard the container by running bash Copy $ cd . $ id=$(docker create kentik/ktranslate:v2) $ docker cp $id:/etc/ktranslate/snmp-base.yaml . $ docker rm -v $id In the snmp-base.yaml file, add your network syslog devices inside the devices key with the following structure: devices: syslogDevice: device_name: edge-router device_ip: 10.10.1.254 ping_only: true # Optional user tags user_tags: owning_team: net_eng environment: production Copy Tip If you're already monitoring SNMP data devices that send network syslog, you don't need to add them in your snmp-base.yaml file a second time. The ping_only attribute used in the configuration file can optionally be replaced with flow_only to remove response time monitoring and only collect syslog messages from the host. Run ktranslate to listen for network syslog by running: bash Copy $ docker run -d --name ktranslate-syslog --restart unless-stopped --net=host \\ > -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ > -e NEW_RELIC_API_KEY=$YOUR_NR_LICENSE_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$YOUR_NR_ACCOUNT_ID \\ > ## If your account is located in Europe, add the following option: $ ## -nr_region=EU \\ $ -metrics=jchf \\ > -tee_logs=true \\ > -service_name=syslog \\ > ## Optional: To override the default listening port of \"0.0.0.0:5143\": $ ## -syslog=\"<ip_address>:<port>\" $ nr1.syslog Tip ktranslate handles syslog in the following formats: RFC3164, RFC5424, and RFC6587. Investigate your device syslog messages in the New Relic One logs UI, using the following query: \"plugin.type\":\"ktranslate-syslog\" Copy To get better visibility into your network device performance, set up SNMP data monitoring. To get better visibility into how your network is being used, set up network flow data monitoring.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 214.4715,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set up <em>network</em> syslog <em>monitoring</em>",
        "sections": "Set up <em>network</em> syslog <em>monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": " visibility into your <em>network</em> device <em>performance</em>, set up SNMP data <em>monitoring</em>. To get better visibility into how your <em>network</em> is being used, set up <em>network</em> flow data <em>monitoring</em>."
      },
      "id": "619e0cec64441f61ed985635"
    },
    {
      "sections": [
        "Visualize your network performance data in New Relic One",
        "Prerequisites",
        "Add the Network dashboards to your account",
        "Tip",
        "Start exploring your network performance data"
      ],
      "title": "Visualize your network performance data in New Relic One",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Monitoring"
      ],
      "external_id": "a9e82cf586cd71595b0fd3bdcc831768578417cf",
      "image": "https://docs.newrelic.com/static/f6a643a55e2f9a2b070d85ab9174ba48/c1b63/flow_data_dashboard.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/monitoring-network-data/visualize-network-data/",
      "published_at": "2021-12-30T09:50:55Z",
      "updated_at": "2021-12-30T09:50:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you set up your network data for performance monitoring, you can go to New Relic One and install several custom-curated visualizations designed specifically for network performance monitoring. Then, after you set up these visualizations, you can start exploring the network data your devices are reporting to New Relic One. You can group and monitor your switches, routers, etc. in dashboards. This helps you quickly aggregate, isolate, and analyze the health of your network. For some examples of monitoring your network in New Relic One, watch this short video (approx. 3:45 minutes). Prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. Having set up your Network Performance Monitoring devices. Read how to: Set up SNMP data monitoring. Set up network flow data monitoring. Add the custom visualizations app to your account: Go to one.newrelic.com > Apps, and search for Network Agent Visualizations. Click the app, and then click Open visualization. one.newrelic.com > Apps, and search for Network Agent Visualizations. From the Account ID dropdown, select the account you want to add the visualizations to, and click Enable. Add the Network dashboards to your account You can go to New Relic One and import several dashboards to see curated views of your network telemetry, including the GeoMap and Sankey custom visualizations from the prerequisites. Go to one.newrelic.com > Apps, and search for Quickstarts. Click Quickstarts. In the search bar, search for Network, then click one of the dashboards: Use the Network - Data Ingest and Cardinality dashboard to analyze usage trends. Use the Network - Routers and Switches dashboard for SNMP data from router and switch entities. Use the Network - Flow Devices dashboard for network flow data. one.newrelic.com > Apps, and search for Network. Click Import. Select the account where you want to add the dashboard. Optional: Edit the dashboard name. Click Import dashboard. Tip If you want to read more about custom visualizations in New Relic One, see the introduction to custom visualizations. Start exploring your network performance data Once you've finished setting up these dashboards, you can start seeing your network data by going to Dashboards or Explorer in New Relic One: From one.newrelic.com > Dashboards: For usage trend analysis, you'll see the following dashboard: Dashboard for analyzing network telemetry usage trends in New Relic One. For SNMP data, you'll see the following dashboard: Dashboard for SNMP data from router and switch entities in New Relic One. For network flow data, you'll see the following dashboard: Dashboard for network flow data monitoring in New Relic One. From one.newrelic.com > Explorer: Entities are listed under the Network category in the left-hand side menu. Open a specific device to see the details and trend of its performance. On the top right-hand side, click Lookout to see anomalies. Lookout view for Network Performance Monitoring in New Relic One. To learn how to troubleshoot network data in Navigator and Lookout, watch this short video (approx. 3:15 minutes).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 195.87645,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Visualize your <em>network</em> <em>performance</em> data in New Relic One",
        "sections": "Visualize your <em>network</em> <em>performance</em> data in New Relic One",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": "After you set up your <em>network</em> data for <em>performance</em> <em>monitoring</em>, you can go to New Relic One and install several custom-curated visualizations designed specifically for <em>network</em> <em>performance</em> <em>monitoring</em>. Then, after you set up these visualizations, you can start exploring the <em>network</em> data your devices"
      },
      "id": "6127249b64441f621ea47c42"
    },
    {
      "sections": [
        "Set up network flow data monitoring",
        "Prerequisites",
        "New Relic One account prerequisites",
        "Linux host prerequisites",
        "Network flow data devices prerequisites",
        "Network security prerequisites",
        "Supported types of network flow data",
        "Important",
        "Scaling network flow collection",
        "Set up network flow data monitoring in New Relic One",
        "Manual setup",
        "Tip"
      ],
      "title": "Set up network flow data monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Installation",
        "Setup",
        "NPM"
      ],
      "external_id": "626c9bebce36e550d5793d8ef932e6d654c23e47",
      "image": "https://docs.newrelic.com/static/3d1561743f3311471975006fa41f628a/c1b63/network-flows-guided-install.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/network-flow-monitoring/",
      "published_at": "2021-12-30T03:13:18Z",
      "updated_at": "2021-12-04T22:07:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Set up your network devices so they send network data to New Relic One. Prerequisites New Relic One account prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. A New Relic account ID. Read how to find your account ID. A New Relic license key. Read how to generate a new License key. Linux host prerequisites Docker installed in a Linux host. SSH access to the Docker host, with the ability to launch new containers. Network flow data devices prerequisites Configured network devices to send flow data to the host running the ktranslate docker container. Here's how to configure network flow data collection in some devices: NetFlow data Cisco - IOS Cisco - Meraki Cisco - NX-OS Fortinet Fortigate Palo Alto - PAN-OS sFlow data F5 - BIG-IP jFlow data Juniper - Junos Network security prerequisites Direction Source Destination Ports Protocol Outbound Docker host ktranslate image on Docker Hub 443 TCP Outbound Docker host New Relic Event API US Endpoint: https://insights-collector.newrelic.com EU Endpoint: https://insights-collector.eu01.nr-data.net 443 TCP Outbound Docker host New Relic Log API US Endpoint: https://log-api.newrelic.com EU Endpoint: https://log-api.eu.newrelic.com 443 TCP Inbound Source devices for network flow data Docker host 9995 (default) UDP Supported types of network flow data NPM flow monitoring supports the four primary types of network flow data and their derivatives. When running the ktranslate container, you will specify which major type you want to monitor using the -nf.source option. Important The ktranslate container only supports monitoring one type of network flow data type at a time. If you want to monitor several types, each will require a container. IPFIX and NetFlow v9 can be sent to the same container, but we recommend running a separate container as a best practice. Network flow data type -nf.source value IPFIX ipfix NetFlow v5 netflow5 NetFlow v9 netflow9 sFlow sflow AppFlow netflow5 Argus netflow5 cflowd netflow5 J-Flow netflow5 NetStream netflow5 RFlow netflow5 Cisco NSEL netflow9 Scaling network flow collection When planning your strategy for collecting network flows at scale, New Relic recommends 1 CPU per 2000 flows-per-second (120,000 flows-per-minute). Deciding whether to run more small containers to distribute load or fewer large containers to consolidate management is a matter of personal preference. Set up network flow data monitoring in New Relic One Go to one.newrelic.com and click Add more data. Scroll down until you see Network performance monitoring and click Network Flows. Follow the steps in New Relic One. one.newrelic.com > Add more data > Network performance monitoring > Network Flows to set up network flow data monitoring. To get better visibility into your network device performance, set up SNMP data monitoring. Visualize your network performance data in New Relic. Manual setup If you prefer to do the setup manually, proceed with the following steps. In your local machine, from a Linux host with Docker installed, download the ktranslate image from dockerhub by running bash Copy $ docker pull kentik/ktranslate:v2 Copy the snmp-base.yaml file to the local $HOME directory of your Docker user, and discard the container by running bash Copy $ cd . $ id=$(docker create kentik/ktranslate:v2) $ docker cp $id:/etc/ktranslate/snmp-base.yaml . $ docker rm -v $id In the snmp-base.yaml file, add your network flow devices inside the devices key with the following structure: devices: flowDevice: device_name: edge-router device_ip: 10.10.1.254 flow_only: true # Optional user tags user_tags: owning_team: net_eng environment: production Copy Tip If you're already monitoring SNMP data devices that send network flow data, you don't need to add them in your snmp-base.yaml file a second time. Run ktranslate to listen for network flows by running: bash Copy $ docker run -d --name ktranslate-sflow --restart unless-stopped --net=host \\ > -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ > -e NEW_RELIC_API_KEY=$YOUR_NR_LICENSE_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$YOUR_NR_ACCOUNT_ID \\ > ## If your account is located in Europe, add the following flag: $ ## -nr_region=EU \\ $ ## If you want to use FedRAMP, add the following flag to use the FedRAMP authorized endpoints: $ ## -nr_region=GOV \\ $ -metrics=jchf \\ > -tee_logs=true \\ > -flow_only=true \\ > -nf.source=sflow \\ > -service_name=sflow \\ > nr1.flow Tip This command assumes collection of sflow data. If you are collecting other flow types, you should change the suffix in the --name flag for the container and update the -nf.source and -service_name flags as necessary. To get better visibility into your network device performance, set up SNMP data monitoring. To get insights into system messages from your devices, setup network syslog collection. Visualize your network performance data in New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.2622,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set up <em>network</em> flow data <em>monitoring</em>",
        "sections": "Set up <em>network</em> flow data <em>monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": " <em>monitoring</em> &gt; <em>Network</em> Flows to set up <em>network</em> flow data <em>monitoring</em>. To get better visibility into your <em>network</em> device <em>performance</em>, set up SNMP data <em>monitoring</em>. Visualize your <em>network</em> <em>performance</em> data in New Relic. Manual <em>setup</em> If you prefer to do the <em>setup</em> manually, proceed with the following steps. In your"
      },
      "id": "612724e128ccbc4ac9f2612a"
    }
  ],
  "/docs/network-performance-monitoring/troubleshooting/snmp-discovery-kentik-default": [
    {
      "sections": [
        "Visualize your network performance data in New Relic One",
        "Prerequisites",
        "Add the Network dashboards to your account",
        "Tip",
        "Start exploring your network performance data"
      ],
      "title": "Visualize your network performance data in New Relic One",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Monitoring"
      ],
      "external_id": "a9e82cf586cd71595b0fd3bdcc831768578417cf",
      "image": "https://docs.newrelic.com/static/f6a643a55e2f9a2b070d85ab9174ba48/c1b63/flow_data_dashboard.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/monitoring-network-data/visualize-network-data/",
      "published_at": "2021-12-30T09:50:55Z",
      "updated_at": "2021-12-30T09:50:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you set up your network data for performance monitoring, you can go to New Relic One and install several custom-curated visualizations designed specifically for network performance monitoring. Then, after you set up these visualizations, you can start exploring the network data your devices are reporting to New Relic One. You can group and monitor your switches, routers, etc. in dashboards. This helps you quickly aggregate, isolate, and analyze the health of your network. For some examples of monitoring your network in New Relic One, watch this short video (approx. 3:45 minutes). Prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. Having set up your Network Performance Monitoring devices. Read how to: Set up SNMP data monitoring. Set up network flow data monitoring. Add the custom visualizations app to your account: Go to one.newrelic.com > Apps, and search for Network Agent Visualizations. Click the app, and then click Open visualization. one.newrelic.com > Apps, and search for Network Agent Visualizations. From the Account ID dropdown, select the account you want to add the visualizations to, and click Enable. Add the Network dashboards to your account You can go to New Relic One and import several dashboards to see curated views of your network telemetry, including the GeoMap and Sankey custom visualizations from the prerequisites. Go to one.newrelic.com > Apps, and search for Quickstarts. Click Quickstarts. In the search bar, search for Network, then click one of the dashboards: Use the Network - Data Ingest and Cardinality dashboard to analyze usage trends. Use the Network - Routers and Switches dashboard for SNMP data from router and switch entities. Use the Network - Flow Devices dashboard for network flow data. one.newrelic.com > Apps, and search for Network. Click Import. Select the account where you want to add the dashboard. Optional: Edit the dashboard name. Click Import dashboard. Tip If you want to read more about custom visualizations in New Relic One, see the introduction to custom visualizations. Start exploring your network performance data Once you've finished setting up these dashboards, you can start seeing your network data by going to Dashboards or Explorer in New Relic One: From one.newrelic.com > Dashboards: For usage trend analysis, you'll see the following dashboard: Dashboard for analyzing network telemetry usage trends in New Relic One. For SNMP data, you'll see the following dashboard: Dashboard for SNMP data from router and switch entities in New Relic One. For network flow data, you'll see the following dashboard: Dashboard for network flow data monitoring in New Relic One. From one.newrelic.com > Explorer: Entities are listed under the Network category in the left-hand side menu. Open a specific device to see the details and trend of its performance. On the top right-hand side, click Lookout to see anomalies. Lookout view for Network Performance Monitoring in New Relic One. To learn how to troubleshoot network data in Navigator and Lookout, watch this short video (approx. 3:15 minutes).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 195.87634,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Visualize your <em>network</em> <em>performance</em> data in New Relic One",
        "sections": "Visualize your <em>network</em> <em>performance</em> data in New Relic One",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": ". From one.newrelic.com &gt; Explorer: Entities are listed under the <em>Network</em> category in the left-hand side menu. Open a specific device to see the details and trend of its <em>performance</em>. On the top right-hand side, click Lookout to see anomalies. Lookout view for <em>Network</em> <em>Performance</em> <em>Monitoring</em> in New Relic One. To learn how to <em>troubleshoot</em> <em>network</em> data in Navigator and Lookout, watch this short video (approx. 3:15 minutes)."
      },
      "id": "6127249b64441f621ea47c42"
    },
    {
      "sections": [
        "ktranslate Docker container health monitoring",
        "Logs from ktranslate",
        "Tip",
        "Optional log parsing rule",
        "Common log searches",
        "What version of ktranslate am I running?",
        "What arguments were passed to Docker at runtime?",
        "What errors am I experiencing?",
        "Is my match_attributes filter working on my device?",
        "Metrics from ktranslate",
        "Common metrics searches",
        "What are the current versions of my ktranslate applications?",
        "What is the health of my ktranslate application?",
        "What is the health of my deliveries to New Relic One?",
        "What is the health of my SNMP collection overall?",
        "What devices are failing SNMP collection?",
        "What is the health of my flow data collection?",
        "What is the health of my syslog collection?"
      ],
      "title": "ktranslate Docker container health monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring"
      ],
      "external_id": "a6a4a6194c420409a30f75d437e27998235b84bc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/advanced/ktranslate-container-health/",
      "published_at": "2021-12-30T03:02:12Z",
      "updated_at": "2021-12-16T01:45:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "While running the ktranslate Docker container for New Relic network performance monitoring, you can monitor the health of the container to proactively detect potential issues. The ktranslate container image has the -tee_logs=true and -metrics=jchf settings available during runtime, which allow it to send health metrics into New Relic One directly. These are enabled by default when installing network performance monitoring via the New Relic One guided install. We recommend you to set them up when installing network performance monitoring manually. Logs from ktranslate Tip If you want to check the logs locally from the Docker host, run docker logs $CONTAINER_NAME. For example, docker logs ktranslate-snmp. The -tee_logs=true option sends logs to New Relic One when polling devices. To see them, do the following: Go to one.newrelic.com > Logs. In Find logs where, enter collector.name:\"ktranslate\" and click Query logs. Optional log parsing rule We recommend you to add a parsing rule to New Relic One logs to break the logs from ktranslate into fields that are easily searchable. This is especially helpful when you are running more than one container as it allows you to then search by the value of --service_name from the Docker container. Using the New Relic One logs UI, use the following patterns: Rule Name: ktranslate-health logs Query Attribute: \"plugin.type\" Query Value: \"ktranslate-health\" Parsing logic: %{NOTSPACE:time} ktranslate/%{NOTSPACE:container_service} \\[%{NOTSPACE:severity}\\] %{GREEDYDATA:message} Copy Alternatively, you can use New Relic's Nerdgraph API to manage your parsing rules. A sample of the logConfigurationsCreateParsingRule is below, you will need to replace $ACCOUNT_ID with the ID of your target account. mutation { logConfigurationsCreateParsingRule( accountId: $ACCOUNT_ID, rule: { description: \"ktranslate-health logs\", enabled: true, grok: \"%{NOTSPACE:time} ktranslate/%{NOTSPACE:container_service} \\\\[%{NOTSPACE:severity}\\\\] %{GREEDYDATA:message}\", lucene: \"\\\"plugin.type\\\":\\\"ktranslate-health\\\"\", nrql: \"SELECT * FROM Log WHERE `plugin.type` = 'ktranslate-health'\" } ) { errors { message type } rule { accountId id enabled description grok lucene nrql } } } Copy The result of this parsing rule is splitting a raw message from this: { \"collector.name\": \"ktranslate\", \"instrumentation.provider\": \"kentik\", \"message\": \"2021-12-08T14:59:56.007 ktranslate/snmp [Info] nrmFormat New Metadata for cisco-7513\", \"newrelic.source\": \"api.logs\", \"plugin.type\": \"ktranslate-health\", \"timestamp\": 1638975596000 } Copy To this, creating the searchable fields of container_service, severity, and time; as well as trimming the message field to more actionable data: { \"collector.name\": \"ktranslate\", \"container_service\": \"snmp\", \"instrumentation.provider\": \"kentik\", \"message\": \"nrmFormat New Metadata for cisco-7513\", \"newrelic.source\": \"api.logs\", \"plugin.type\": \"ktranslate-health\", \"severity\": \"Info\", \"time\": \"2021-12-08T15:29:56.026\", \"timestamp\": 1638977396000 } Copy Common log searches Below are some common searches that can be used during troubleshooting to gather data for support: What version of ktranslate am I running? Logs UI: bash Copy $ collector.name:\"ktranslate\" message:\"*KTranslate Running -- Version*\" NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `message` LIKE '%KTranslate Running -- Version%' Copy Expected Results: bash Copy $ KTranslate Running -- Version kt-2021-12-06-1546870234; Build Mon Dec 6 22:22:56 UTC 2021 What arguments were passed to Docker at runtime? Logs UI: bash Copy $ collector.name:\"ktranslate\" message:\"*KTranslate CLI:*\" NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `message` LIKE '%KTranslate CLI:%' Copy Expected Results: bash Copy $ KTranslate CLI: [ktranslate -listen off -mapping /etc/ktranslate/config.json -geo /etc/ktranslate/GeoLite2-Country.mmdb -udrs /etc/ktranslate/udr.csv -api_devices /etc/ktranslate/devices.json -asn /etc/ktranslate/GeoLite2-ASN.mmdb -log_level info -snmp /snmp-base.yaml -nr_account_id=2583772 -log_level=info -metrics=jchf -tee_logs=true -service_name=snmp nr1.snmp] What errors am I experiencing? Without a parsing rule applied to your logs Logs UI: bash Copy $ collector.name:\"ktranslate\" message:-*\\[Info\\]* NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `message` NOT LIKE '%[Info]%' Copy With a parsing rule applied to your logs Logs UI: bash Copy $ collector.name:\"ktranslate\" severity:-\"Info\" NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `severity` != 'Info' Copy Expected Results: bash Copy $ KTranslate>cisco-7513 There was an SNMP polling error with the CustomDeviceMetrics walking OID .1.3.6.1.2.1.4.31.1.1.21 after 0 retries: request timeout (after 0 retries). Is my match_attributes filter working on my device? Logs UI: bash Copy $ collector.name:\"ktranslate\" message:\"*Match Attribute*\" NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `message` LIKE '%Match Attribute%' Copy Expected Results: bash Copy $ KTranslate>cisco-7513 Added 1 Match Attribute(s) All devices are expected to have at least 1 Match Attribute inherited from the default monitor_admin_shut: true configuration. You should expect a value of 2 to be shown for a device that you have added a single match attribute to. Tip You can further filter these results by adding the device name to your query: collector.name:\"ktranslate\" message:\"*$DEVICE_NAME*Match Attribute*\". Metrics from ktranslate The -metrics option captures the following performance metrics when polling devices: Metric Granularity Description baseserver_healthcheck_execution_total Top Level Rate of internal health checks. Shows mostly that things are not deadlocked and should always be greater than 0. inputq Top Level Messages per second (msg/sec) received over the last 60 seconds from all SNMP, Flow, and VPC inputs combined. jchfq Top Level Gauge rate with number of available pre-allocated buffers. It should be about 8,000. delivery_metrics_nr Delivery to New Relic One Batches per second (batches/sec) sent over the last 60 seconds for all metrics to New Relic One. delivery_logs_nr Delivery to New Relic One Logs per second (logs/sec) sent over the last 60 seconds for all logs to New Relic One. delivery_wins_nr Delivery to New Relic One Wins per second (wins/sec) of 200 HTTP codes received over the last 60 seconds from sending metrics and events to New Relic One. device_metrics SNMP Polls per second (polls/sec) of SNMP polling over the last 60 seconds for device level metrics. interface_metrics SNMP Polls per second (polls/sec) of SNMP polling over the last 60 seconds for interface level metrics. snmp_fail SNMP Gauge to monitor if SNMP polling is working faceted by device_name. Where 1 means good and 2 means fail. netflow.flows Netflow Flows per second (fps) received over the last 60 seconds for all device flow data: IPFIX, NetFlow, or sFlow. syslog_queue Syslog Gauge of syslog messages waiting to be processed. syslog_errors Syslog Errors per second (errors/sec) over the last 60 seconds while processing syslog messages. syslog_messages Syslog Messages per second (msg/sec) received over the last 60 seconds for all syslog data. Common metrics searches To see these metrics in New Relic One: Go to one.newrelic.com and click Query your data. Enter one of the following NRQL queries: What are the current versions of my ktranslate applications? FROM Metric SELECT latest(ver) AS 'image_version' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What is the health of my ktranslate application? FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.baseserver_healthcheck_execution_total) AS 'healthcheck_total', latest(kentik.ktranslate.chf.kkc.inputq) AS 'input_per_second', latest(kentik.ktranslate.chf.kkc.jchfq) AS 'buffer' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What is the health of my deliveries to New Relic One? FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.delivery_metrics_nr) AS 'delivery_metric_batches_per_second', latest(kentik.ktranslate.chf.kkc.delivery_logs_nr) AS 'delivery_logs_per_second', latest(kentik.ktranslate.chf.kkc.delivery_wins_nr) AS 'delivery_wins_per_second' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What is the health of my SNMP collection overall? FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.device_metrics) AS 'device_polls_per_second', latest(kentik.ktranslate.chf.kkc.interface_metrics) AS 'interface_polls_per_second' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What devices are failing SNMP collection? SELECT max(snmp_fail) FROM ( FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.snmp_fail) AS 'snmp_fail' FACET host AS 'docker_host', svc AS 'container_service', device_name AS 'snmp_device' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' ) FACET docker_host, container_service, snmp_device WHERE snmp_fail = 2 Copy What is the health of my flow data collection? FROM Metric SELECT max(kentik.ktranslate.chf.kkc.netflow) AS 'flows_per_second' FACET host AS 'docker_host', svc AS 'container_service', device_name AS 'flow_device' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What is the health of my syslog collection? FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.syslog_queue) AS 'syslog_queue_total', latest(kentik.ktranslate.chf.kkc.syslog_errors) AS 'syslog_errors_per_second', latest(kentik.ktranslate.chf.kkc.syslog_messages) AS 'syslog_messages_per_second' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.50266,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "ktranslate Docker container health <em>monitoring</em>",
        "sections": "ktranslate Docker container health <em>monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": "While running the ktranslate Docker container for New Relic <em>network</em> <em>performance</em> <em>monitoring</em>, you can <em>monitor</em> the health of the container to proactively detect potential issues. The ktranslate container image has the -tee_logs=true and -metrics=jchf settings available during runtime, which allow"
      },
      "id": "61b9389528ccbcb4d396ee5e"
    },
    {
      "sections": [
        "Advanced configuration for Network Performance Monitoring",
        "SNMP-base YAML sample file",
        "Devices section",
        "Trap section",
        "Discovery section",
        "Global section",
        "Optional SNMPv3 configuration",
        "Tip",
        "Optional external config files",
        "Discovery CIDRs",
        "Devices",
        "The match_attributes attribute",
        "Default 'OR' with null and empty values",
        "'AND', omit null and empty values",
        "Single match, omit null and empty values",
        "The flow_only attribute",
        "The response_time and ping_only attributes",
        "Flow data application mapping",
        "Flow data input filtering",
        "Example Filters"
      ],
      "title": "Advanced configuration for Network Performance Monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Advanced configuration"
      ],
      "external_id": "61f8c58056547c4a9a2c534617559472e3e62fd1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/advanced/advanced-config/",
      "published_at": "2021-12-30T03:03:15Z",
      "updated_at": "2021-12-19T05:14:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you want to explore all the options you can use when configuring the monitoring of your network performance, see the following sections. SNMP-base YAML sample file Here's an example of the various configuration options available in the snmp-base.yaml file used by the ktranslate docker image to poll for SNMP and flow data devices. You can also see a heavily-commented sample in the ktranslate repository on GitHub. devices: # Sample of SNMP v2c device ups_snmpv2c__10.10.0.201: device_name: ups_snmpv2c device_ip: 10.10.0.201 snmp_comm: public oid: .1.3.6.1.4.1.318.1.3.27 description: \"APC Web/SNMP Management Card (MB:v4.1.0 PF:v6.2.1 PN:apc_hw05_aos_621.bin AF1:v6.2.1 AN1:apc_hw05_sumx_621.bin MN:AP9537SUM HR:05 SN: ABC123DEF456 MD:05/21/2016) (Embedded PowerNet SNMP Agent SW v2.2 compatible)\" last_checked: 2021-11-09T18:14:59.907821489Z mib_profile: apc_ups.yml provider: kentik-ups poll_time_sec: 300 retries: 1 timeout_ms: 5000 user_tags: owning_team: dc_ops discovered_mibs: - PowerNet-MIB_UPS - TCP-MIB - UDP-MIB # Sample of SNMP v3 device router_snmpv3__10.10.0.202: device_name: router_snmpv3 device_ip: 10.10.0.202 snmp_v3: user_name: userNamev3 authentication_protocol: MD5 authentication_passphrase: authPassPrivacy privacy_protocol: AES256 privacy_passphrase: passPrivacy oid: .1.3.6.1.4.1.9.1.544 description: \"Cisco IOS Software, 3800 Software (C3845-ADVENTERPRISEK9-M), Version 15.1(3)T4, RELEASE SOFTWARE (fc1)\\r\\nTechnical Support: http://www.cisco.com/techsupport\\r\\nCopyright (c) 1986-2012 by Cisco Systems, Inc.\\r\\nCompiled Thu 24-May-12 04:27 by prod_rel_team\" last_checked: 2021-11-09T18:14:59.907821489Z mib_profile: cisco-asr.yml provider: kentik-router user_tags: owning_team: core-networking discovered_mibs: - BGP4-MIB - CISCO-MEMORY-POOL-MIB - CISCO-PROCESS-MIB - IF-MIB - OSPF-MIB engine_id: \"80:00:01:01:0a:14:1e:28\" match_attributes: if_interface_name: \"^Ten.*|^Gig.*\" \"!if_Alias\": \"[Uu]plink\" # Sample of SNMP v1 device netbotz_snmpv1__10.10.0.203: device_name: netbotz_snmpv1 device_ip: 10.10.0.201 snmp_comm: public use_snmp_v1: true oid: .1.3.6.1.4.1.5528.100.20.10.2013 description: \"Linux netbotz930A7A 2.6.12 #307 Wed Dec 29 15:25:32 EST 2010 ppc\" last_checked: 2021-11-09T18:14:59.907821489Z mib_profile: apc-netbotz.yml provider: kentik-netbotz user_tags: owning_team: sys_ops discovered_mibs: - IF-MIB - IP-MIB - TCP-MIB - UDP-MIB no_use_bulkwalkall: true # Sample of \"flow only\" device flow_only__10.10.0.210: device_name: flow_only device_ip: 10.10.0.210 user_tags: owning_team: net_eng flow_only: true # Sample of \"ping only\" device ping_only__10.10.0.220: device_name: ping_only device_ip: 10.10.0.220 user_tags: owning_team: load_balancing ping_only: true trap: listen: 127.0.0.1:1162 community: public version: \"\" transport: \"\" v3_config: null discovery: cidrs: - 10.0.0.0/24 - 10.0.0.202/32 debug: false ports: - 161 - 1161 default_communities: - public - public123 - Publ!cABC use_snmp_v1: false default_v3: null add_mibs: true threads: 4 add_devices: true replace_devices: true no_dedupe_engine_id: false global: poll_time_sec: 60 drop_if_outside_poll: false mib_profile_dir: /etc/ktranslate/profiles mibs_db: /etc/ktranslate/mibs.db mibs_enabled: - BGP4-MIB - CISCO-MEMORY-POOL-MIB - CISCO-PROCESS-MIB - IF-MIB - IP-MIB - OSPF-MIB - PowerNet-MIB_UPS - TCP-MIB - UDP-MIB timeout_ms: 3000 retries: 0 global_v3: null response_time: false user_tags: environment: production match_attributes: if_Description: \".*WAN.*\" Copy Devices section Key name Required Description device_name ✓ Name of the device. This is the unique identifier for the device in New Relic One. device_ip ✓ Target IP of the device. snmp_comm ✓ (Required for SNMPv1/2c) SNMPv1/2c community string to use. use_snmp_v1 ✓ (Required for SNMPv1) Indicates whether to use SNMPv1. By default, it's set to false. snmp_v3 ✓ (Required for SNMPv3) SNMP v3 config debug Indicates whether to enable debug level logging during SNMP polling. By default, it's set to false. port Port to send SNMP queries to. By default, it's set to port 161. oid ✓ (Required for SNMP polling) The discovered systemObjectID | sysObjectID | sysOID for the device. This is used to match the device to a known SNMP profile and set the provider attribute. If no match is found, this sets the provider as a kentik-default device. description The discovered sysDescr of the device. This field is informational. last_checked Timestamp when this device was last discovered by the ktranslate docker image. This field is informational. mib_profile ✓ (Required for SNMP polling) SNMP Profile file that was associated with this device during the discovery run based on its sysOID. If this starts with a bang (!) token, it will override the automatic matching from the sysOID and use a manual override. Ex: \"!cisco-asa.yml\" (quotes are required). provider ✓ (Required for New Relic One) Value used during entity synthesis for New Relic One. This is automatically created based on the matched mib_profile. poll_time_sec Indicates the SNMP polling frequency in seconds. This setting is used to override the global.poll_time_sec attribute. retries Indicates the number of attempts to retry polling SNMP OIDs. This setting is used to override the global.retries attribute. timeout_ms Indicates the SNMP polling timeout in milliseconds. This setting is used to override the global.timeout_ms attribute. user_tags key:value pair attributes to give more context to the device. Tags at this level will be appended to any tags applied in the global.user_tags attribute. discovered_mibs List of MIBs pulled from matched mib_profile that this device can respond to. This field is informational. engine_id The unique engine ID discovered for this device's SNMP agent. Generally found during SNMP v3 discovery. This field is informational. match_attributes attribute:regex pairs to add metrics to allowlist. Pairs at this level will be appended to any pairs applied in the global.match_attributes attribute. Uses the RE2 syntax and has a default OR operator. Prefix key with ! to force to AND operators. monitor_admin_shut Indicates whether to monitor interfaces in Administratively Shutdown status. By default, it's set to false. no_use_bulkwalkall Disables the SNMP GETBULK request action when true. By default, it's set to false. ping_only Disables all SNMP polling and enables response time polling when true. This setting is used to override the global.response_time attribute. By default, it's set to false. flow_only Disables all SNMP polling when true. By default, it's set to false. Trap section Key name Required Description listen ✓ Listening IP port for receiving SNMP traps. By default it's set to 127.0.0.1:1162, using the SNMP Trap default of 162 requires running Docker as root. community SNMPv1/v2c community string for receiving SNMP traps. version SNMP version to use. Options are v1, v2c, and v3. By default, it's set to v2c. transport SNMP transport protocol to use. Options are TCP and UDP. By default, it's set to UDP v3_config SNMP v3 config to use. Only used if version: v3. Discovery section Key name Required Description cidrs ✓ Array of target IP ranges in CIDR notation. debug Indicates whether to enable debug level logging during discovery. By default, it's set to false ports ✓ Array of target ports to scan during SNMP polling. default_communities ✓ (Required for SNMPv1/2c) Array of SNMPv1/v2c community strings to scan during SNMP polling. This array is evaluated in order and discovery accepts the first passing community. use_snmp_v1 ✓ (Required for SNMPv1) Indicates whether to use SNMPv1 during discovery. By default, it's set to false default_v3 ✓ (Required for SNMPv3) SNMPv3 configuration to scan during SNMP polling. add_devices ✓ Indicates whether to add discovered devices to the devices section of the snmp-base.yaml file. By default, it's set to true. add_mibs ✓ Indicates whether to add discovered MIBs to the global.mibs_enabled section of the snmp-base.yaml file. By default, it's set to true. threads ✓ Integer limit of threads to use during discovery. It should be less than the number of cores available to the container. By default it's set to 4. replace_devices ✓ Indicates whether to replace discovered devices if they already exist in the devices section of the snmp-base.yaml file. By default, it's set to false. no_dedup_engine_id When set to true, disables deduplication of discovered devices if it appears that they are the same device, based on their reported SNMP engine ID. By default, it's set to false Global section Key name Required Description poll_time_sec ✓ Time in seconds to poll devices. This can be overridden per device using the devices.<deviceName>.poll_time_sec attribute. By default, it's set to 60. drop_if_outside_poll Indicates whether to drop all values from this cycle if polling takes longer than the value set in poll_time_sec. By default, it's set to false mib_profile_dir Directory to find curated MIB profiles. These are pulled into the ktranslate image automatically from Kentik's snmp-profiles repository and can be overridden at Docker runtime by creating a volume mount of your own local directory of profiles. mibs_db mibs_enabled ✓ Array of all active MIBs the ktranslate docker image will poll. This list is automatically generated during discovery if the discovery_add_mibs attribute is true. MIBs not listed here will not be polled on any device in the configuration file. You can specify a SNMP table directly in a MIB file using MIB-NAME.tableName syntax. Ex: HOST-RESOURCES-MIB.hrProcessorTable. timeout_ms ✓ Time in milliseconds SNMP queries timeout. This can be overridden per device using the devices.<deviceName>.timeout_ms attribute. By default, it's set to 5000 retries ✓ Number of attempts to retry failed SNMP polls. This can be overridden per device using the devices.<deviceName>.retries attribute. By default, it's set to 0 user_tags key:value pair attributes to give more context to the device. Tags at this level will be applied to all devices in the configuration file. match_attributes attribute:regex pairs to add metrics to allowlist. Pairs at this level will matched against all devices in the configuration file. Uses the RE2 syntax and has a default OR operator. Prefix key with ! to force to AND operators. response_time Indicates whether response time polling is enabled for all devices in the configuration file. By default, it's set to false. Optional SNMPv3 configuration Key name Required Description user_name ✓ User name for SNMPv3 authentication authentication_protocol ✓ SNMPv3 authentication protocol. The possible values are NoAuth, MD5, or SHA authentication_passphrase SNMPv3 authentication passphrase privacy_protocol ✓ SNMPv3 privacy protocol. The possible values are AuthNoPriv, DES, AES, AES192, AES256, AES192C, or AES256C privacy_passphrase SNMPv3 privacy passphrase context_engine_id SNMPv3 context engine ID context_name SNMPv3 context name Tip You can use AWS Secrets Manager natively in your SNMP v3 config using the aws.sm.$SECRET_NAME syntax, replacing $SECRET_NAME as necessary to have ktranslate pull in your credentials during Docker runtime. Optional external config files To support a wide variety of configuration and automation needs, you can use external files that you volume mount into your Docker container to decouple certain elements of the standard configuration file. The syntax for these files is \"@fileName.extension\", including the double quotes. Discovery CIDRs Example: discovery: cidrs: \"@cidrs.yaml\" Copy The CIDRs file should use a YAML list syntax like this: - 10.10.0.0/24 - 10.20.0.0/24 - 192.168.0.21/32 Copy Devices Example: devices: - \"@neteng-devices.yaml\" - \"@dc-ops.yaml\" Copy The device files should use the same syntax as the standard devices section of the main config file, omitting the optional fields that are generated during discovery: devices: # Sample of SNMP v2c device ups_snmpv2c__10.10.0.201: device_name: ups_snmpv2c device_ip: 10.10.0.201 snmp_comm: public oid: .1.3.6.1.4.1.318.1.3.27 mib_profile: apc_ups.yml provider: kentik-ups poll_time_sec: 300 retries: 1 timeout_ms: 5000 user_tags: owning_team: dc_ops Copy The match_attributes attribute To support filtering of data that does not create value for your observability needs, you can set the global.match_attributes.{} and/or devices.<deviceName>.match_attributes.{} attribute map. This will provide filtering at the ktranslate level, before shipping data to New Relic, giving you granular control over monitoring of things like interfaces. The default behavior of this map is an OR condition, but you can override this and force an AND operator by prefixing your key name with !. This is also useful to return only matched items and omit all null and \"\" (empty) results. Default 'OR' with null and empty values Match when if_Alias begins with Uplink OR when if_interface_name begins with Gig, keep all null and \"\" values: devices: deviceName: ... match_attributes: if_Alias: \"^Uplink.*\" if_interface_name: \"^Gig.*\" Copy 'AND', omit null and empty values Match when if_Alias begins with Uplink AND when if_interface_name begins with Gig, drop all null and \"\" values: devices: deviceName: ... match_attributes: if_Alias: \"^Uplink.*\" \"!if_interface_name\": \"^Gig.*\" Copy Single match, omit null and empty values Match when if_Alias begins with Uplink, drop all null and \"\" values: devices: deviceName: ... match_attributes: \"!if_Alias\": \"^Uplink.*\" Copy The flow_only attribute To support monitoring of devices where performance statistics are nor accessible, available, or desired, you can set the devices.<deviceName>.flow_only attribute to true. This will generate a Flow Device entity in New Relic One which will only have telemetry in the KFlow event namespace. Alternatively, collecting flow telemetry from a device that is in your configuration file as an SNMP device will add decoration of the KFlow data to the pre-existing entity, such as a Router or Firewall. In New Relic One, you can see the results of this polling by investigating the following events: FROM KFlow SELECT count(*) FACET device_name WHERE instrumentation.name = 'netflow-events' TIMESERIES Copy The response_time and ping_only attributes To support monitoring of devices where performance statistics are not accessible or available, or in simple cases where basic round-trip time (RTT) monitoring is required, you can either set the global.response_time or devices.<deviceName>.ping_only attributes to true. This feature uses the go-ping package to send unprivileged UDP packets to devices in order to collect the average, min, and max RTT for the endpoint based on sending 1 packet/sec from ktranslate to the device IP address. Setting the global.response_time attribute to true will add RTT monitoring on top of existing SNMP polling. devices.<deviceName>.ping_only: true will allow you to monitor devices with only the UDP packets for RTT and no SNMP polling. In New Relic One, you can see the results of this polling by investigating the following metrics: FROM Metric SELECT average(kentik.ping.AvgRttMs) AS 'Average', max(kentik.ping.MaxRttMs) AS 'Max', min(kentik.ping.MinRttMs) AS 'Min' FACET device_name TIMESERIES Copy Tip You can use the ping_only attribute in replacement of the flow_only attribute if you would like to collect RTT metrics from a flow device. If both ping_only and flow_only are true, the device will be treated as a flow_only device. Flow data application mapping By default, flow telemetry is mapped to known applications based on evaluation of the layer 4 port in use on a specific flow conversation. If needed, you can override the default mapping by providing a YAML file during Docker runtime to the -application_map flag. This will allow you to specify application names based on ports you identify. Example syntax: applications: - ports: [9092, 9093] name: kafka - ports: [80, 8080] name: http - ports: [443, 8443] name: https Copy Flow data input filtering By default, flow data containers will collect and process every flow packet they receive. If needed, you can add an inclusion filter to the -nf.source flag that will ignore all traffic not matching the filter you provide. Syntax: --filters $TYPE,$FIELD,$FUNCTION,$MATCH Argument Name Required Description $TYPE ✓ The type of filter to apply. Possible values are string, int, and addr. $FIELD ✓ The name of the field to evaluate the match pattern against. $FUNCTION ✓ The type of function to use during evaluation. Possible values are Equal: ==, NotEqual: !=, LessThan: <, GreaterThan: >, Contains: % $MATCH ✓ The value to be used as a match pattern. Example Filters Only collect flow data from source addresses in the 10.0.0.0/24 CIDR range -nf.source sflow --filters addr,src_addr,%,10.10.0.0/24 Copy Only collect flow data where the destination port is not equal to 8531 -nf.source netflow5 --filters int,l4_dst_port,!=,8531 Copy You can also add multiple filters together with an inherited AND operator Only collect flow data from source addresses in the 10.0.0.0/24 CIDR range AND where the destination port is not equal to 8531 --filters addr,src_addr,%,10.0.0.0/24 --filters int,l4_dst_port,!=,8531 Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.05078,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Advanced configuration for <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "sections": "Advanced configuration for <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "tags": "<em>Network</em> <em>performance</em> <em>monitoring</em>",
        "body": "If you want to explore all the options you can use when configuring the <em>monitoring</em> of your <em>network</em> <em>performance</em>, see the following sections. SNMP-base YAML sample file Here&#x27;s an example of the various configuration options available in the snmp-base.yaml file used by the ktranslate docker image"
      },
      "id": "61b9389664441f8fc3d7182e"
    }
  ],
  "/docs/network-performance-monitoring/troubleshooting/snmp-discovery-no-devices": [
    {
      "sections": [
        "Visualize your network performance data in New Relic One",
        "Prerequisites",
        "Add the Network dashboards to your account",
        "Tip",
        "Start exploring your network performance data"
      ],
      "title": "Visualize your network performance data in New Relic One",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Monitoring"
      ],
      "external_id": "a9e82cf586cd71595b0fd3bdcc831768578417cf",
      "image": "https://docs.newrelic.com/static/f6a643a55e2f9a2b070d85ab9174ba48/c1b63/flow_data_dashboard.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/monitoring-network-data/visualize-network-data/",
      "published_at": "2021-12-30T09:50:55Z",
      "updated_at": "2021-12-30T09:50:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you set up your network data for performance monitoring, you can go to New Relic One and install several custom-curated visualizations designed specifically for network performance monitoring. Then, after you set up these visualizations, you can start exploring the network data your devices are reporting to New Relic One. You can group and monitor your switches, routers, etc. in dashboards. This helps you quickly aggregate, isolate, and analyze the health of your network. For some examples of monitoring your network in New Relic One, watch this short video (approx. 3:45 minutes). Prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. Having set up your Network Performance Monitoring devices. Read how to: Set up SNMP data monitoring. Set up network flow data monitoring. Add the custom visualizations app to your account: Go to one.newrelic.com > Apps, and search for Network Agent Visualizations. Click the app, and then click Open visualization. one.newrelic.com > Apps, and search for Network Agent Visualizations. From the Account ID dropdown, select the account you want to add the visualizations to, and click Enable. Add the Network dashboards to your account You can go to New Relic One and import several dashboards to see curated views of your network telemetry, including the GeoMap and Sankey custom visualizations from the prerequisites. Go to one.newrelic.com > Apps, and search for Quickstarts. Click Quickstarts. In the search bar, search for Network, then click one of the dashboards: Use the Network - Data Ingest and Cardinality dashboard to analyze usage trends. Use the Network - Routers and Switches dashboard for SNMP data from router and switch entities. Use the Network - Flow Devices dashboard for network flow data. one.newrelic.com > Apps, and search for Network. Click Import. Select the account where you want to add the dashboard. Optional: Edit the dashboard name. Click Import dashboard. Tip If you want to read more about custom visualizations in New Relic One, see the introduction to custom visualizations. Start exploring your network performance data Once you've finished setting up these dashboards, you can start seeing your network data by going to Dashboards or Explorer in New Relic One: From one.newrelic.com > Dashboards: For usage trend analysis, you'll see the following dashboard: Dashboard for analyzing network telemetry usage trends in New Relic One. For SNMP data, you'll see the following dashboard: Dashboard for SNMP data from router and switch entities in New Relic One. For network flow data, you'll see the following dashboard: Dashboard for network flow data monitoring in New Relic One. From one.newrelic.com > Explorer: Entities are listed under the Network category in the left-hand side menu. Open a specific device to see the details and trend of its performance. On the top right-hand side, click Lookout to see anomalies. Lookout view for Network Performance Monitoring in New Relic One. To learn how to troubleshoot network data in Navigator and Lookout, watch this short video (approx. 3:15 minutes).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 195.87634,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Visualize your <em>network</em> <em>performance</em> data in New Relic One",
        "sections": "Visualize your <em>network</em> <em>performance</em> data in New Relic One",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": ". From one.newrelic.com &gt; Explorer: Entities are listed under the <em>Network</em> category in the left-hand side menu. Open a specific device to see the details and trend of its <em>performance</em>. On the top right-hand side, click Lookout to see anomalies. Lookout view for <em>Network</em> <em>Performance</em> <em>Monitoring</em> in New Relic One. To learn how to <em>troubleshoot</em> <em>network</em> data in Navigator and Lookout, watch this short video (approx. 3:15 minutes)."
      },
      "id": "6127249b64441f621ea47c42"
    },
    {
      "sections": [
        "ktranslate Docker container health monitoring",
        "Logs from ktranslate",
        "Tip",
        "Optional log parsing rule",
        "Common log searches",
        "What version of ktranslate am I running?",
        "What arguments were passed to Docker at runtime?",
        "What errors am I experiencing?",
        "Is my match_attributes filter working on my device?",
        "Metrics from ktranslate",
        "Common metrics searches",
        "What are the current versions of my ktranslate applications?",
        "What is the health of my ktranslate application?",
        "What is the health of my deliveries to New Relic One?",
        "What is the health of my SNMP collection overall?",
        "What devices are failing SNMP collection?",
        "What is the health of my flow data collection?",
        "What is the health of my syslog collection?"
      ],
      "title": "ktranslate Docker container health monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring"
      ],
      "external_id": "a6a4a6194c420409a30f75d437e27998235b84bc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/advanced/ktranslate-container-health/",
      "published_at": "2021-12-30T03:02:12Z",
      "updated_at": "2021-12-16T01:45:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "While running the ktranslate Docker container for New Relic network performance monitoring, you can monitor the health of the container to proactively detect potential issues. The ktranslate container image has the -tee_logs=true and -metrics=jchf settings available during runtime, which allow it to send health metrics into New Relic One directly. These are enabled by default when installing network performance monitoring via the New Relic One guided install. We recommend you to set them up when installing network performance monitoring manually. Logs from ktranslate Tip If you want to check the logs locally from the Docker host, run docker logs $CONTAINER_NAME. For example, docker logs ktranslate-snmp. The -tee_logs=true option sends logs to New Relic One when polling devices. To see them, do the following: Go to one.newrelic.com > Logs. In Find logs where, enter collector.name:\"ktranslate\" and click Query logs. Optional log parsing rule We recommend you to add a parsing rule to New Relic One logs to break the logs from ktranslate into fields that are easily searchable. This is especially helpful when you are running more than one container as it allows you to then search by the value of --service_name from the Docker container. Using the New Relic One logs UI, use the following patterns: Rule Name: ktranslate-health logs Query Attribute: \"plugin.type\" Query Value: \"ktranslate-health\" Parsing logic: %{NOTSPACE:time} ktranslate/%{NOTSPACE:container_service} \\[%{NOTSPACE:severity}\\] %{GREEDYDATA:message} Copy Alternatively, you can use New Relic's Nerdgraph API to manage your parsing rules. A sample of the logConfigurationsCreateParsingRule is below, you will need to replace $ACCOUNT_ID with the ID of your target account. mutation { logConfigurationsCreateParsingRule( accountId: $ACCOUNT_ID, rule: { description: \"ktranslate-health logs\", enabled: true, grok: \"%{NOTSPACE:time} ktranslate/%{NOTSPACE:container_service} \\\\[%{NOTSPACE:severity}\\\\] %{GREEDYDATA:message}\", lucene: \"\\\"plugin.type\\\":\\\"ktranslate-health\\\"\", nrql: \"SELECT * FROM Log WHERE `plugin.type` = 'ktranslate-health'\" } ) { errors { message type } rule { accountId id enabled description grok lucene nrql } } } Copy The result of this parsing rule is splitting a raw message from this: { \"collector.name\": \"ktranslate\", \"instrumentation.provider\": \"kentik\", \"message\": \"2021-12-08T14:59:56.007 ktranslate/snmp [Info] nrmFormat New Metadata for cisco-7513\", \"newrelic.source\": \"api.logs\", \"plugin.type\": \"ktranslate-health\", \"timestamp\": 1638975596000 } Copy To this, creating the searchable fields of container_service, severity, and time; as well as trimming the message field to more actionable data: { \"collector.name\": \"ktranslate\", \"container_service\": \"snmp\", \"instrumentation.provider\": \"kentik\", \"message\": \"nrmFormat New Metadata for cisco-7513\", \"newrelic.source\": \"api.logs\", \"plugin.type\": \"ktranslate-health\", \"severity\": \"Info\", \"time\": \"2021-12-08T15:29:56.026\", \"timestamp\": 1638977396000 } Copy Common log searches Below are some common searches that can be used during troubleshooting to gather data for support: What version of ktranslate am I running? Logs UI: bash Copy $ collector.name:\"ktranslate\" message:\"*KTranslate Running -- Version*\" NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `message` LIKE '%KTranslate Running -- Version%' Copy Expected Results: bash Copy $ KTranslate Running -- Version kt-2021-12-06-1546870234; Build Mon Dec 6 22:22:56 UTC 2021 What arguments were passed to Docker at runtime? Logs UI: bash Copy $ collector.name:\"ktranslate\" message:\"*KTranslate CLI:*\" NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `message` LIKE '%KTranslate CLI:%' Copy Expected Results: bash Copy $ KTranslate CLI: [ktranslate -listen off -mapping /etc/ktranslate/config.json -geo /etc/ktranslate/GeoLite2-Country.mmdb -udrs /etc/ktranslate/udr.csv -api_devices /etc/ktranslate/devices.json -asn /etc/ktranslate/GeoLite2-ASN.mmdb -log_level info -snmp /snmp-base.yaml -nr_account_id=2583772 -log_level=info -metrics=jchf -tee_logs=true -service_name=snmp nr1.snmp] What errors am I experiencing? Without a parsing rule applied to your logs Logs UI: bash Copy $ collector.name:\"ktranslate\" message:-*\\[Info\\]* NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `message` NOT LIKE '%[Info]%' Copy With a parsing rule applied to your logs Logs UI: bash Copy $ collector.name:\"ktranslate\" severity:-\"Info\" NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `severity` != 'Info' Copy Expected Results: bash Copy $ KTranslate>cisco-7513 There was an SNMP polling error with the CustomDeviceMetrics walking OID .1.3.6.1.2.1.4.31.1.1.21 after 0 retries: request timeout (after 0 retries). Is my match_attributes filter working on my device? Logs UI: bash Copy $ collector.name:\"ktranslate\" message:\"*Match Attribute*\" NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `message` LIKE '%Match Attribute%' Copy Expected Results: bash Copy $ KTranslate>cisco-7513 Added 1 Match Attribute(s) All devices are expected to have at least 1 Match Attribute inherited from the default monitor_admin_shut: true configuration. You should expect a value of 2 to be shown for a device that you have added a single match attribute to. Tip You can further filter these results by adding the device name to your query: collector.name:\"ktranslate\" message:\"*$DEVICE_NAME*Match Attribute*\". Metrics from ktranslate The -metrics option captures the following performance metrics when polling devices: Metric Granularity Description baseserver_healthcheck_execution_total Top Level Rate of internal health checks. Shows mostly that things are not deadlocked and should always be greater than 0. inputq Top Level Messages per second (msg/sec) received over the last 60 seconds from all SNMP, Flow, and VPC inputs combined. jchfq Top Level Gauge rate with number of available pre-allocated buffers. It should be about 8,000. delivery_metrics_nr Delivery to New Relic One Batches per second (batches/sec) sent over the last 60 seconds for all metrics to New Relic One. delivery_logs_nr Delivery to New Relic One Logs per second (logs/sec) sent over the last 60 seconds for all logs to New Relic One. delivery_wins_nr Delivery to New Relic One Wins per second (wins/sec) of 200 HTTP codes received over the last 60 seconds from sending metrics and events to New Relic One. device_metrics SNMP Polls per second (polls/sec) of SNMP polling over the last 60 seconds for device level metrics. interface_metrics SNMP Polls per second (polls/sec) of SNMP polling over the last 60 seconds for interface level metrics. snmp_fail SNMP Gauge to monitor if SNMP polling is working faceted by device_name. Where 1 means good and 2 means fail. netflow.flows Netflow Flows per second (fps) received over the last 60 seconds for all device flow data: IPFIX, NetFlow, or sFlow. syslog_queue Syslog Gauge of syslog messages waiting to be processed. syslog_errors Syslog Errors per second (errors/sec) over the last 60 seconds while processing syslog messages. syslog_messages Syslog Messages per second (msg/sec) received over the last 60 seconds for all syslog data. Common metrics searches To see these metrics in New Relic One: Go to one.newrelic.com and click Query your data. Enter one of the following NRQL queries: What are the current versions of my ktranslate applications? FROM Metric SELECT latest(ver) AS 'image_version' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What is the health of my ktranslate application? FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.baseserver_healthcheck_execution_total) AS 'healthcheck_total', latest(kentik.ktranslate.chf.kkc.inputq) AS 'input_per_second', latest(kentik.ktranslate.chf.kkc.jchfq) AS 'buffer' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What is the health of my deliveries to New Relic One? FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.delivery_metrics_nr) AS 'delivery_metric_batches_per_second', latest(kentik.ktranslate.chf.kkc.delivery_logs_nr) AS 'delivery_logs_per_second', latest(kentik.ktranslate.chf.kkc.delivery_wins_nr) AS 'delivery_wins_per_second' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What is the health of my SNMP collection overall? FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.device_metrics) AS 'device_polls_per_second', latest(kentik.ktranslate.chf.kkc.interface_metrics) AS 'interface_polls_per_second' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What devices are failing SNMP collection? SELECT max(snmp_fail) FROM ( FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.snmp_fail) AS 'snmp_fail' FACET host AS 'docker_host', svc AS 'container_service', device_name AS 'snmp_device' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' ) FACET docker_host, container_service, snmp_device WHERE snmp_fail = 2 Copy What is the health of my flow data collection? FROM Metric SELECT max(kentik.ktranslate.chf.kkc.netflow) AS 'flows_per_second' FACET host AS 'docker_host', svc AS 'container_service', device_name AS 'flow_device' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What is the health of my syslog collection? FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.syslog_queue) AS 'syslog_queue_total', latest(kentik.ktranslate.chf.kkc.syslog_errors) AS 'syslog_errors_per_second', latest(kentik.ktranslate.chf.kkc.syslog_messages) AS 'syslog_messages_per_second' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.50266,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "ktranslate Docker container health <em>monitoring</em>",
        "sections": "ktranslate Docker container health <em>monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": "While running the ktranslate Docker container for New Relic <em>network</em> <em>performance</em> <em>monitoring</em>, you can <em>monitor</em> the health of the container to proactively detect potential issues. The ktranslate container image has the -tee_logs=true and -metrics=jchf settings available during runtime, which allow"
      },
      "id": "61b9389528ccbcb4d396ee5e"
    },
    {
      "sections": [
        "Advanced configuration for Network Performance Monitoring",
        "SNMP-base YAML sample file",
        "Devices section",
        "Trap section",
        "Discovery section",
        "Global section",
        "Optional SNMPv3 configuration",
        "Tip",
        "Optional external config files",
        "Discovery CIDRs",
        "Devices",
        "The match_attributes attribute",
        "Default 'OR' with null and empty values",
        "'AND', omit null and empty values",
        "Single match, omit null and empty values",
        "The flow_only attribute",
        "The response_time and ping_only attributes",
        "Flow data application mapping",
        "Flow data input filtering",
        "Example Filters"
      ],
      "title": "Advanced configuration for Network Performance Monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Advanced configuration"
      ],
      "external_id": "61f8c58056547c4a9a2c534617559472e3e62fd1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/advanced/advanced-config/",
      "published_at": "2021-12-30T03:03:15Z",
      "updated_at": "2021-12-19T05:14:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you want to explore all the options you can use when configuring the monitoring of your network performance, see the following sections. SNMP-base YAML sample file Here's an example of the various configuration options available in the snmp-base.yaml file used by the ktranslate docker image to poll for SNMP and flow data devices. You can also see a heavily-commented sample in the ktranslate repository on GitHub. devices: # Sample of SNMP v2c device ups_snmpv2c__10.10.0.201: device_name: ups_snmpv2c device_ip: 10.10.0.201 snmp_comm: public oid: .1.3.6.1.4.1.318.1.3.27 description: \"APC Web/SNMP Management Card (MB:v4.1.0 PF:v6.2.1 PN:apc_hw05_aos_621.bin AF1:v6.2.1 AN1:apc_hw05_sumx_621.bin MN:AP9537SUM HR:05 SN: ABC123DEF456 MD:05/21/2016) (Embedded PowerNet SNMP Agent SW v2.2 compatible)\" last_checked: 2021-11-09T18:14:59.907821489Z mib_profile: apc_ups.yml provider: kentik-ups poll_time_sec: 300 retries: 1 timeout_ms: 5000 user_tags: owning_team: dc_ops discovered_mibs: - PowerNet-MIB_UPS - TCP-MIB - UDP-MIB # Sample of SNMP v3 device router_snmpv3__10.10.0.202: device_name: router_snmpv3 device_ip: 10.10.0.202 snmp_v3: user_name: userNamev3 authentication_protocol: MD5 authentication_passphrase: authPassPrivacy privacy_protocol: AES256 privacy_passphrase: passPrivacy oid: .1.3.6.1.4.1.9.1.544 description: \"Cisco IOS Software, 3800 Software (C3845-ADVENTERPRISEK9-M), Version 15.1(3)T4, RELEASE SOFTWARE (fc1)\\r\\nTechnical Support: http://www.cisco.com/techsupport\\r\\nCopyright (c) 1986-2012 by Cisco Systems, Inc.\\r\\nCompiled Thu 24-May-12 04:27 by prod_rel_team\" last_checked: 2021-11-09T18:14:59.907821489Z mib_profile: cisco-asr.yml provider: kentik-router user_tags: owning_team: core-networking discovered_mibs: - BGP4-MIB - CISCO-MEMORY-POOL-MIB - CISCO-PROCESS-MIB - IF-MIB - OSPF-MIB engine_id: \"80:00:01:01:0a:14:1e:28\" match_attributes: if_interface_name: \"^Ten.*|^Gig.*\" \"!if_Alias\": \"[Uu]plink\" # Sample of SNMP v1 device netbotz_snmpv1__10.10.0.203: device_name: netbotz_snmpv1 device_ip: 10.10.0.201 snmp_comm: public use_snmp_v1: true oid: .1.3.6.1.4.1.5528.100.20.10.2013 description: \"Linux netbotz930A7A 2.6.12 #307 Wed Dec 29 15:25:32 EST 2010 ppc\" last_checked: 2021-11-09T18:14:59.907821489Z mib_profile: apc-netbotz.yml provider: kentik-netbotz user_tags: owning_team: sys_ops discovered_mibs: - IF-MIB - IP-MIB - TCP-MIB - UDP-MIB no_use_bulkwalkall: true # Sample of \"flow only\" device flow_only__10.10.0.210: device_name: flow_only device_ip: 10.10.0.210 user_tags: owning_team: net_eng flow_only: true # Sample of \"ping only\" device ping_only__10.10.0.220: device_name: ping_only device_ip: 10.10.0.220 user_tags: owning_team: load_balancing ping_only: true trap: listen: 127.0.0.1:1162 community: public version: \"\" transport: \"\" v3_config: null discovery: cidrs: - 10.0.0.0/24 - 10.0.0.202/32 debug: false ports: - 161 - 1161 default_communities: - public - public123 - Publ!cABC use_snmp_v1: false default_v3: null add_mibs: true threads: 4 add_devices: true replace_devices: true no_dedupe_engine_id: false global: poll_time_sec: 60 drop_if_outside_poll: false mib_profile_dir: /etc/ktranslate/profiles mibs_db: /etc/ktranslate/mibs.db mibs_enabled: - BGP4-MIB - CISCO-MEMORY-POOL-MIB - CISCO-PROCESS-MIB - IF-MIB - IP-MIB - OSPF-MIB - PowerNet-MIB_UPS - TCP-MIB - UDP-MIB timeout_ms: 3000 retries: 0 global_v3: null response_time: false user_tags: environment: production match_attributes: if_Description: \".*WAN.*\" Copy Devices section Key name Required Description device_name ✓ Name of the device. This is the unique identifier for the device in New Relic One. device_ip ✓ Target IP of the device. snmp_comm ✓ (Required for SNMPv1/2c) SNMPv1/2c community string to use. use_snmp_v1 ✓ (Required for SNMPv1) Indicates whether to use SNMPv1. By default, it's set to false. snmp_v3 ✓ (Required for SNMPv3) SNMP v3 config debug Indicates whether to enable debug level logging during SNMP polling. By default, it's set to false. port Port to send SNMP queries to. By default, it's set to port 161. oid ✓ (Required for SNMP polling) The discovered systemObjectID | sysObjectID | sysOID for the device. This is used to match the device to a known SNMP profile and set the provider attribute. If no match is found, this sets the provider as a kentik-default device. description The discovered sysDescr of the device. This field is informational. last_checked Timestamp when this device was last discovered by the ktranslate docker image. This field is informational. mib_profile ✓ (Required for SNMP polling) SNMP Profile file that was associated with this device during the discovery run based on its sysOID. If this starts with a bang (!) token, it will override the automatic matching from the sysOID and use a manual override. Ex: \"!cisco-asa.yml\" (quotes are required). provider ✓ (Required for New Relic One) Value used during entity synthesis for New Relic One. This is automatically created based on the matched mib_profile. poll_time_sec Indicates the SNMP polling frequency in seconds. This setting is used to override the global.poll_time_sec attribute. retries Indicates the number of attempts to retry polling SNMP OIDs. This setting is used to override the global.retries attribute. timeout_ms Indicates the SNMP polling timeout in milliseconds. This setting is used to override the global.timeout_ms attribute. user_tags key:value pair attributes to give more context to the device. Tags at this level will be appended to any tags applied in the global.user_tags attribute. discovered_mibs List of MIBs pulled from matched mib_profile that this device can respond to. This field is informational. engine_id The unique engine ID discovered for this device's SNMP agent. Generally found during SNMP v3 discovery. This field is informational. match_attributes attribute:regex pairs to add metrics to allowlist. Pairs at this level will be appended to any pairs applied in the global.match_attributes attribute. Uses the RE2 syntax and has a default OR operator. Prefix key with ! to force to AND operators. monitor_admin_shut Indicates whether to monitor interfaces in Administratively Shutdown status. By default, it's set to false. no_use_bulkwalkall Disables the SNMP GETBULK request action when true. By default, it's set to false. ping_only Disables all SNMP polling and enables response time polling when true. This setting is used to override the global.response_time attribute. By default, it's set to false. flow_only Disables all SNMP polling when true. By default, it's set to false. Trap section Key name Required Description listen ✓ Listening IP port for receiving SNMP traps. By default it's set to 127.0.0.1:1162, using the SNMP Trap default of 162 requires running Docker as root. community SNMPv1/v2c community string for receiving SNMP traps. version SNMP version to use. Options are v1, v2c, and v3. By default, it's set to v2c. transport SNMP transport protocol to use. Options are TCP and UDP. By default, it's set to UDP v3_config SNMP v3 config to use. Only used if version: v3. Discovery section Key name Required Description cidrs ✓ Array of target IP ranges in CIDR notation. debug Indicates whether to enable debug level logging during discovery. By default, it's set to false ports ✓ Array of target ports to scan during SNMP polling. default_communities ✓ (Required for SNMPv1/2c) Array of SNMPv1/v2c community strings to scan during SNMP polling. This array is evaluated in order and discovery accepts the first passing community. use_snmp_v1 ✓ (Required for SNMPv1) Indicates whether to use SNMPv1 during discovery. By default, it's set to false default_v3 ✓ (Required for SNMPv3) SNMPv3 configuration to scan during SNMP polling. add_devices ✓ Indicates whether to add discovered devices to the devices section of the snmp-base.yaml file. By default, it's set to true. add_mibs ✓ Indicates whether to add discovered MIBs to the global.mibs_enabled section of the snmp-base.yaml file. By default, it's set to true. threads ✓ Integer limit of threads to use during discovery. It should be less than the number of cores available to the container. By default it's set to 4. replace_devices ✓ Indicates whether to replace discovered devices if they already exist in the devices section of the snmp-base.yaml file. By default, it's set to false. no_dedup_engine_id When set to true, disables deduplication of discovered devices if it appears that they are the same device, based on their reported SNMP engine ID. By default, it's set to false Global section Key name Required Description poll_time_sec ✓ Time in seconds to poll devices. This can be overridden per device using the devices.<deviceName>.poll_time_sec attribute. By default, it's set to 60. drop_if_outside_poll Indicates whether to drop all values from this cycle if polling takes longer than the value set in poll_time_sec. By default, it's set to false mib_profile_dir Directory to find curated MIB profiles. These are pulled into the ktranslate image automatically from Kentik's snmp-profiles repository and can be overridden at Docker runtime by creating a volume mount of your own local directory of profiles. mibs_db mibs_enabled ✓ Array of all active MIBs the ktranslate docker image will poll. This list is automatically generated during discovery if the discovery_add_mibs attribute is true. MIBs not listed here will not be polled on any device in the configuration file. You can specify a SNMP table directly in a MIB file using MIB-NAME.tableName syntax. Ex: HOST-RESOURCES-MIB.hrProcessorTable. timeout_ms ✓ Time in milliseconds SNMP queries timeout. This can be overridden per device using the devices.<deviceName>.timeout_ms attribute. By default, it's set to 5000 retries ✓ Number of attempts to retry failed SNMP polls. This can be overridden per device using the devices.<deviceName>.retries attribute. By default, it's set to 0 user_tags key:value pair attributes to give more context to the device. Tags at this level will be applied to all devices in the configuration file. match_attributes attribute:regex pairs to add metrics to allowlist. Pairs at this level will matched against all devices in the configuration file. Uses the RE2 syntax and has a default OR operator. Prefix key with ! to force to AND operators. response_time Indicates whether response time polling is enabled for all devices in the configuration file. By default, it's set to false. Optional SNMPv3 configuration Key name Required Description user_name ✓ User name for SNMPv3 authentication authentication_protocol ✓ SNMPv3 authentication protocol. The possible values are NoAuth, MD5, or SHA authentication_passphrase SNMPv3 authentication passphrase privacy_protocol ✓ SNMPv3 privacy protocol. The possible values are AuthNoPriv, DES, AES, AES192, AES256, AES192C, or AES256C privacy_passphrase SNMPv3 privacy passphrase context_engine_id SNMPv3 context engine ID context_name SNMPv3 context name Tip You can use AWS Secrets Manager natively in your SNMP v3 config using the aws.sm.$SECRET_NAME syntax, replacing $SECRET_NAME as necessary to have ktranslate pull in your credentials during Docker runtime. Optional external config files To support a wide variety of configuration and automation needs, you can use external files that you volume mount into your Docker container to decouple certain elements of the standard configuration file. The syntax for these files is \"@fileName.extension\", including the double quotes. Discovery CIDRs Example: discovery: cidrs: \"@cidrs.yaml\" Copy The CIDRs file should use a YAML list syntax like this: - 10.10.0.0/24 - 10.20.0.0/24 - 192.168.0.21/32 Copy Devices Example: devices: - \"@neteng-devices.yaml\" - \"@dc-ops.yaml\" Copy The device files should use the same syntax as the standard devices section of the main config file, omitting the optional fields that are generated during discovery: devices: # Sample of SNMP v2c device ups_snmpv2c__10.10.0.201: device_name: ups_snmpv2c device_ip: 10.10.0.201 snmp_comm: public oid: .1.3.6.1.4.1.318.1.3.27 mib_profile: apc_ups.yml provider: kentik-ups poll_time_sec: 300 retries: 1 timeout_ms: 5000 user_tags: owning_team: dc_ops Copy The match_attributes attribute To support filtering of data that does not create value for your observability needs, you can set the global.match_attributes.{} and/or devices.<deviceName>.match_attributes.{} attribute map. This will provide filtering at the ktranslate level, before shipping data to New Relic, giving you granular control over monitoring of things like interfaces. The default behavior of this map is an OR condition, but you can override this and force an AND operator by prefixing your key name with !. This is also useful to return only matched items and omit all null and \"\" (empty) results. Default 'OR' with null and empty values Match when if_Alias begins with Uplink OR when if_interface_name begins with Gig, keep all null and \"\" values: devices: deviceName: ... match_attributes: if_Alias: \"^Uplink.*\" if_interface_name: \"^Gig.*\" Copy 'AND', omit null and empty values Match when if_Alias begins with Uplink AND when if_interface_name begins with Gig, drop all null and \"\" values: devices: deviceName: ... match_attributes: if_Alias: \"^Uplink.*\" \"!if_interface_name\": \"^Gig.*\" Copy Single match, omit null and empty values Match when if_Alias begins with Uplink, drop all null and \"\" values: devices: deviceName: ... match_attributes: \"!if_Alias\": \"^Uplink.*\" Copy The flow_only attribute To support monitoring of devices where performance statistics are nor accessible, available, or desired, you can set the devices.<deviceName>.flow_only attribute to true. This will generate a Flow Device entity in New Relic One which will only have telemetry in the KFlow event namespace. Alternatively, collecting flow telemetry from a device that is in your configuration file as an SNMP device will add decoration of the KFlow data to the pre-existing entity, such as a Router or Firewall. In New Relic One, you can see the results of this polling by investigating the following events: FROM KFlow SELECT count(*) FACET device_name WHERE instrumentation.name = 'netflow-events' TIMESERIES Copy The response_time and ping_only attributes To support monitoring of devices where performance statistics are not accessible or available, or in simple cases where basic round-trip time (RTT) monitoring is required, you can either set the global.response_time or devices.<deviceName>.ping_only attributes to true. This feature uses the go-ping package to send unprivileged UDP packets to devices in order to collect the average, min, and max RTT for the endpoint based on sending 1 packet/sec from ktranslate to the device IP address. Setting the global.response_time attribute to true will add RTT monitoring on top of existing SNMP polling. devices.<deviceName>.ping_only: true will allow you to monitor devices with only the UDP packets for RTT and no SNMP polling. In New Relic One, you can see the results of this polling by investigating the following metrics: FROM Metric SELECT average(kentik.ping.AvgRttMs) AS 'Average', max(kentik.ping.MaxRttMs) AS 'Max', min(kentik.ping.MinRttMs) AS 'Min' FACET device_name TIMESERIES Copy Tip You can use the ping_only attribute in replacement of the flow_only attribute if you would like to collect RTT metrics from a flow device. If both ping_only and flow_only are true, the device will be treated as a flow_only device. Flow data application mapping By default, flow telemetry is mapped to known applications based on evaluation of the layer 4 port in use on a specific flow conversation. If needed, you can override the default mapping by providing a YAML file during Docker runtime to the -application_map flag. This will allow you to specify application names based on ports you identify. Example syntax: applications: - ports: [9092, 9093] name: kafka - ports: [80, 8080] name: http - ports: [443, 8443] name: https Copy Flow data input filtering By default, flow data containers will collect and process every flow packet they receive. If needed, you can add an inclusion filter to the -nf.source flag that will ignore all traffic not matching the filter you provide. Syntax: --filters $TYPE,$FIELD,$FUNCTION,$MATCH Argument Name Required Description $TYPE ✓ The type of filter to apply. Possible values are string, int, and addr. $FIELD ✓ The name of the field to evaluate the match pattern against. $FUNCTION ✓ The type of function to use during evaluation. Possible values are Equal: ==, NotEqual: !=, LessThan: <, GreaterThan: >, Contains: % $MATCH ✓ The value to be used as a match pattern. Example Filters Only collect flow data from source addresses in the 10.0.0.0/24 CIDR range -nf.source sflow --filters addr,src_addr,%,10.10.0.0/24 Copy Only collect flow data where the destination port is not equal to 8531 -nf.source netflow5 --filters int,l4_dst_port,!=,8531 Copy You can also add multiple filters together with an inherited AND operator Only collect flow data from source addresses in the 10.0.0.0/24 CIDR range AND where the destination port is not equal to 8531 --filters addr,src_addr,%,10.0.0.0/24 --filters int,l4_dst_port,!=,8531 Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.05078,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Advanced configuration for <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "sections": "Advanced configuration for <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "tags": "<em>Network</em> <em>performance</em> <em>monitoring</em>",
        "body": "If you want to explore all the options you can use when configuring the <em>monitoring</em> of your <em>network</em> <em>performance</em>, see the following sections. SNMP-base YAML sample file Here&#x27;s an example of the various configuration options available in the snmp-base.yaml file used by the ktranslate docker image"
      },
      "id": "61b9389664441f8fc3d7182e"
    }
  ],
  "/docs/network-performance-monitoring/troubleshooting/snmp-polling-missing-metrics": [
    {
      "sections": [
        "Visualize your network performance data in New Relic One",
        "Prerequisites",
        "Add the Network dashboards to your account",
        "Tip",
        "Start exploring your network performance data"
      ],
      "title": "Visualize your network performance data in New Relic One",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Monitoring"
      ],
      "external_id": "a9e82cf586cd71595b0fd3bdcc831768578417cf",
      "image": "https://docs.newrelic.com/static/f6a643a55e2f9a2b070d85ab9174ba48/c1b63/flow_data_dashboard.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/monitoring-network-data/visualize-network-data/",
      "published_at": "2021-12-30T09:50:55Z",
      "updated_at": "2021-12-30T09:50:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you set up your network data for performance monitoring, you can go to New Relic One and install several custom-curated visualizations designed specifically for network performance monitoring. Then, after you set up these visualizations, you can start exploring the network data your devices are reporting to New Relic One. You can group and monitor your switches, routers, etc. in dashboards. This helps you quickly aggregate, isolate, and analyze the health of your network. For some examples of monitoring your network in New Relic One, watch this short video (approx. 3:45 minutes). Prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. Having set up your Network Performance Monitoring devices. Read how to: Set up SNMP data monitoring. Set up network flow data monitoring. Add the custom visualizations app to your account: Go to one.newrelic.com > Apps, and search for Network Agent Visualizations. Click the app, and then click Open visualization. one.newrelic.com > Apps, and search for Network Agent Visualizations. From the Account ID dropdown, select the account you want to add the visualizations to, and click Enable. Add the Network dashboards to your account You can go to New Relic One and import several dashboards to see curated views of your network telemetry, including the GeoMap and Sankey custom visualizations from the prerequisites. Go to one.newrelic.com > Apps, and search for Quickstarts. Click Quickstarts. In the search bar, search for Network, then click one of the dashboards: Use the Network - Data Ingest and Cardinality dashboard to analyze usage trends. Use the Network - Routers and Switches dashboard for SNMP data from router and switch entities. Use the Network - Flow Devices dashboard for network flow data. one.newrelic.com > Apps, and search for Network. Click Import. Select the account where you want to add the dashboard. Optional: Edit the dashboard name. Click Import dashboard. Tip If you want to read more about custom visualizations in New Relic One, see the introduction to custom visualizations. Start exploring your network performance data Once you've finished setting up these dashboards, you can start seeing your network data by going to Dashboards or Explorer in New Relic One: From one.newrelic.com > Dashboards: For usage trend analysis, you'll see the following dashboard: Dashboard for analyzing network telemetry usage trends in New Relic One. For SNMP data, you'll see the following dashboard: Dashboard for SNMP data from router and switch entities in New Relic One. For network flow data, you'll see the following dashboard: Dashboard for network flow data monitoring in New Relic One. From one.newrelic.com > Explorer: Entities are listed under the Network category in the left-hand side menu. Open a specific device to see the details and trend of its performance. On the top right-hand side, click Lookout to see anomalies. Lookout view for Network Performance Monitoring in New Relic One. To learn how to troubleshoot network data in Navigator and Lookout, watch this short video (approx. 3:15 minutes).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 195.87625,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Visualize your <em>network</em> <em>performance</em> data in New Relic One",
        "sections": "Visualize your <em>network</em> <em>performance</em> data in New Relic One",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": ". From one.newrelic.com &gt; Explorer: Entities are listed under the <em>Network</em> category in the left-hand side menu. Open a specific device to see the details and trend of its <em>performance</em>. On the top right-hand side, click Lookout to see anomalies. Lookout view for <em>Network</em> <em>Performance</em> <em>Monitoring</em> in New Relic One. To learn how to <em>troubleshoot</em> <em>network</em> data in Navigator and Lookout, watch this short video (approx. 3:15 minutes)."
      },
      "id": "6127249b64441f621ea47c42"
    },
    {
      "sections": [
        "ktranslate Docker container health monitoring",
        "Logs from ktranslate",
        "Tip",
        "Optional log parsing rule",
        "Common log searches",
        "What version of ktranslate am I running?",
        "What arguments were passed to Docker at runtime?",
        "What errors am I experiencing?",
        "Is my match_attributes filter working on my device?",
        "Metrics from ktranslate",
        "Common metrics searches",
        "What are the current versions of my ktranslate applications?",
        "What is the health of my ktranslate application?",
        "What is the health of my deliveries to New Relic One?",
        "What is the health of my SNMP collection overall?",
        "What devices are failing SNMP collection?",
        "What is the health of my flow data collection?",
        "What is the health of my syslog collection?"
      ],
      "title": "ktranslate Docker container health monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring"
      ],
      "external_id": "a6a4a6194c420409a30f75d437e27998235b84bc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/advanced/ktranslate-container-health/",
      "published_at": "2021-12-30T03:02:12Z",
      "updated_at": "2021-12-16T01:45:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "While running the ktranslate Docker container for New Relic network performance monitoring, you can monitor the health of the container to proactively detect potential issues. The ktranslate container image has the -tee_logs=true and -metrics=jchf settings available during runtime, which allow it to send health metrics into New Relic One directly. These are enabled by default when installing network performance monitoring via the New Relic One guided install. We recommend you to set them up when installing network performance monitoring manually. Logs from ktranslate Tip If you want to check the logs locally from the Docker host, run docker logs $CONTAINER_NAME. For example, docker logs ktranslate-snmp. The -tee_logs=true option sends logs to New Relic One when polling devices. To see them, do the following: Go to one.newrelic.com > Logs. In Find logs where, enter collector.name:\"ktranslate\" and click Query logs. Optional log parsing rule We recommend you to add a parsing rule to New Relic One logs to break the logs from ktranslate into fields that are easily searchable. This is especially helpful when you are running more than one container as it allows you to then search by the value of --service_name from the Docker container. Using the New Relic One logs UI, use the following patterns: Rule Name: ktranslate-health logs Query Attribute: \"plugin.type\" Query Value: \"ktranslate-health\" Parsing logic: %{NOTSPACE:time} ktranslate/%{NOTSPACE:container_service} \\[%{NOTSPACE:severity}\\] %{GREEDYDATA:message} Copy Alternatively, you can use New Relic's Nerdgraph API to manage your parsing rules. A sample of the logConfigurationsCreateParsingRule is below, you will need to replace $ACCOUNT_ID with the ID of your target account. mutation { logConfigurationsCreateParsingRule( accountId: $ACCOUNT_ID, rule: { description: \"ktranslate-health logs\", enabled: true, grok: \"%{NOTSPACE:time} ktranslate/%{NOTSPACE:container_service} \\\\[%{NOTSPACE:severity}\\\\] %{GREEDYDATA:message}\", lucene: \"\\\"plugin.type\\\":\\\"ktranslate-health\\\"\", nrql: \"SELECT * FROM Log WHERE `plugin.type` = 'ktranslate-health'\" } ) { errors { message type } rule { accountId id enabled description grok lucene nrql } } } Copy The result of this parsing rule is splitting a raw message from this: { \"collector.name\": \"ktranslate\", \"instrumentation.provider\": \"kentik\", \"message\": \"2021-12-08T14:59:56.007 ktranslate/snmp [Info] nrmFormat New Metadata for cisco-7513\", \"newrelic.source\": \"api.logs\", \"plugin.type\": \"ktranslate-health\", \"timestamp\": 1638975596000 } Copy To this, creating the searchable fields of container_service, severity, and time; as well as trimming the message field to more actionable data: { \"collector.name\": \"ktranslate\", \"container_service\": \"snmp\", \"instrumentation.provider\": \"kentik\", \"message\": \"nrmFormat New Metadata for cisco-7513\", \"newrelic.source\": \"api.logs\", \"plugin.type\": \"ktranslate-health\", \"severity\": \"Info\", \"time\": \"2021-12-08T15:29:56.026\", \"timestamp\": 1638977396000 } Copy Common log searches Below are some common searches that can be used during troubleshooting to gather data for support: What version of ktranslate am I running? Logs UI: bash Copy $ collector.name:\"ktranslate\" message:\"*KTranslate Running -- Version*\" NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `message` LIKE '%KTranslate Running -- Version%' Copy Expected Results: bash Copy $ KTranslate Running -- Version kt-2021-12-06-1546870234; Build Mon Dec 6 22:22:56 UTC 2021 What arguments were passed to Docker at runtime? Logs UI: bash Copy $ collector.name:\"ktranslate\" message:\"*KTranslate CLI:*\" NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `message` LIKE '%KTranslate CLI:%' Copy Expected Results: bash Copy $ KTranslate CLI: [ktranslate -listen off -mapping /etc/ktranslate/config.json -geo /etc/ktranslate/GeoLite2-Country.mmdb -udrs /etc/ktranslate/udr.csv -api_devices /etc/ktranslate/devices.json -asn /etc/ktranslate/GeoLite2-ASN.mmdb -log_level info -snmp /snmp-base.yaml -nr_account_id=2583772 -log_level=info -metrics=jchf -tee_logs=true -service_name=snmp nr1.snmp] What errors am I experiencing? Without a parsing rule applied to your logs Logs UI: bash Copy $ collector.name:\"ktranslate\" message:-*\\[Info\\]* NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `message` NOT LIKE '%[Info]%' Copy With a parsing rule applied to your logs Logs UI: bash Copy $ collector.name:\"ktranslate\" severity:-\"Info\" NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `severity` != 'Info' Copy Expected Results: bash Copy $ KTranslate>cisco-7513 There was an SNMP polling error with the CustomDeviceMetrics walking OID .1.3.6.1.2.1.4.31.1.1.21 after 0 retries: request timeout (after 0 retries). Is my match_attributes filter working on my device? Logs UI: bash Copy $ collector.name:\"ktranslate\" message:\"*Match Attribute*\" NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `message` LIKE '%Match Attribute%' Copy Expected Results: bash Copy $ KTranslate>cisco-7513 Added 1 Match Attribute(s) All devices are expected to have at least 1 Match Attribute inherited from the default monitor_admin_shut: true configuration. You should expect a value of 2 to be shown for a device that you have added a single match attribute to. Tip You can further filter these results by adding the device name to your query: collector.name:\"ktranslate\" message:\"*$DEVICE_NAME*Match Attribute*\". Metrics from ktranslate The -metrics option captures the following performance metrics when polling devices: Metric Granularity Description baseserver_healthcheck_execution_total Top Level Rate of internal health checks. Shows mostly that things are not deadlocked and should always be greater than 0. inputq Top Level Messages per second (msg/sec) received over the last 60 seconds from all SNMP, Flow, and VPC inputs combined. jchfq Top Level Gauge rate with number of available pre-allocated buffers. It should be about 8,000. delivery_metrics_nr Delivery to New Relic One Batches per second (batches/sec) sent over the last 60 seconds for all metrics to New Relic One. delivery_logs_nr Delivery to New Relic One Logs per second (logs/sec) sent over the last 60 seconds for all logs to New Relic One. delivery_wins_nr Delivery to New Relic One Wins per second (wins/sec) of 200 HTTP codes received over the last 60 seconds from sending metrics and events to New Relic One. device_metrics SNMP Polls per second (polls/sec) of SNMP polling over the last 60 seconds for device level metrics. interface_metrics SNMP Polls per second (polls/sec) of SNMP polling over the last 60 seconds for interface level metrics. snmp_fail SNMP Gauge to monitor if SNMP polling is working faceted by device_name. Where 1 means good and 2 means fail. netflow.flows Netflow Flows per second (fps) received over the last 60 seconds for all device flow data: IPFIX, NetFlow, or sFlow. syslog_queue Syslog Gauge of syslog messages waiting to be processed. syslog_errors Syslog Errors per second (errors/sec) over the last 60 seconds while processing syslog messages. syslog_messages Syslog Messages per second (msg/sec) received over the last 60 seconds for all syslog data. Common metrics searches To see these metrics in New Relic One: Go to one.newrelic.com and click Query your data. Enter one of the following NRQL queries: What are the current versions of my ktranslate applications? FROM Metric SELECT latest(ver) AS 'image_version' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What is the health of my ktranslate application? FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.baseserver_healthcheck_execution_total) AS 'healthcheck_total', latest(kentik.ktranslate.chf.kkc.inputq) AS 'input_per_second', latest(kentik.ktranslate.chf.kkc.jchfq) AS 'buffer' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What is the health of my deliveries to New Relic One? FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.delivery_metrics_nr) AS 'delivery_metric_batches_per_second', latest(kentik.ktranslate.chf.kkc.delivery_logs_nr) AS 'delivery_logs_per_second', latest(kentik.ktranslate.chf.kkc.delivery_wins_nr) AS 'delivery_wins_per_second' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What is the health of my SNMP collection overall? FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.device_metrics) AS 'device_polls_per_second', latest(kentik.ktranslate.chf.kkc.interface_metrics) AS 'interface_polls_per_second' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What devices are failing SNMP collection? SELECT max(snmp_fail) FROM ( FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.snmp_fail) AS 'snmp_fail' FACET host AS 'docker_host', svc AS 'container_service', device_name AS 'snmp_device' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' ) FACET docker_host, container_service, snmp_device WHERE snmp_fail = 2 Copy What is the health of my flow data collection? FROM Metric SELECT max(kentik.ktranslate.chf.kkc.netflow) AS 'flows_per_second' FACET host AS 'docker_host', svc AS 'container_service', device_name AS 'flow_device' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What is the health of my syslog collection? FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.syslog_queue) AS 'syslog_queue_total', latest(kentik.ktranslate.chf.kkc.syslog_errors) AS 'syslog_errors_per_second', latest(kentik.ktranslate.chf.kkc.syslog_messages) AS 'syslog_messages_per_second' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.50264,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "ktranslate Docker container health <em>monitoring</em>",
        "sections": "ktranslate Docker container health <em>monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": "While running the ktranslate Docker container for New Relic <em>network</em> <em>performance</em> <em>monitoring</em>, you can <em>monitor</em> the health of the container to proactively detect potential issues. The ktranslate container image has the -tee_logs=true and -metrics=jchf settings available during runtime, which allow"
      },
      "id": "61b9389528ccbcb4d396ee5e"
    },
    {
      "sections": [
        "Advanced configuration for Network Performance Monitoring",
        "SNMP-base YAML sample file",
        "Devices section",
        "Trap section",
        "Discovery section",
        "Global section",
        "Optional SNMPv3 configuration",
        "Tip",
        "Optional external config files",
        "Discovery CIDRs",
        "Devices",
        "The match_attributes attribute",
        "Default 'OR' with null and empty values",
        "'AND', omit null and empty values",
        "Single match, omit null and empty values",
        "The flow_only attribute",
        "The response_time and ping_only attributes",
        "Flow data application mapping",
        "Flow data input filtering",
        "Example Filters"
      ],
      "title": "Advanced configuration for Network Performance Monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Advanced configuration"
      ],
      "external_id": "61f8c58056547c4a9a2c534617559472e3e62fd1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/advanced/advanced-config/",
      "published_at": "2021-12-30T03:03:15Z",
      "updated_at": "2021-12-19T05:14:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you want to explore all the options you can use when configuring the monitoring of your network performance, see the following sections. SNMP-base YAML sample file Here's an example of the various configuration options available in the snmp-base.yaml file used by the ktranslate docker image to poll for SNMP and flow data devices. You can also see a heavily-commented sample in the ktranslate repository on GitHub. devices: # Sample of SNMP v2c device ups_snmpv2c__10.10.0.201: device_name: ups_snmpv2c device_ip: 10.10.0.201 snmp_comm: public oid: .1.3.6.1.4.1.318.1.3.27 description: \"APC Web/SNMP Management Card (MB:v4.1.0 PF:v6.2.1 PN:apc_hw05_aos_621.bin AF1:v6.2.1 AN1:apc_hw05_sumx_621.bin MN:AP9537SUM HR:05 SN: ABC123DEF456 MD:05/21/2016) (Embedded PowerNet SNMP Agent SW v2.2 compatible)\" last_checked: 2021-11-09T18:14:59.907821489Z mib_profile: apc_ups.yml provider: kentik-ups poll_time_sec: 300 retries: 1 timeout_ms: 5000 user_tags: owning_team: dc_ops discovered_mibs: - PowerNet-MIB_UPS - TCP-MIB - UDP-MIB # Sample of SNMP v3 device router_snmpv3__10.10.0.202: device_name: router_snmpv3 device_ip: 10.10.0.202 snmp_v3: user_name: userNamev3 authentication_protocol: MD5 authentication_passphrase: authPassPrivacy privacy_protocol: AES256 privacy_passphrase: passPrivacy oid: .1.3.6.1.4.1.9.1.544 description: \"Cisco IOS Software, 3800 Software (C3845-ADVENTERPRISEK9-M), Version 15.1(3)T4, RELEASE SOFTWARE (fc1)\\r\\nTechnical Support: http://www.cisco.com/techsupport\\r\\nCopyright (c) 1986-2012 by Cisco Systems, Inc.\\r\\nCompiled Thu 24-May-12 04:27 by prod_rel_team\" last_checked: 2021-11-09T18:14:59.907821489Z mib_profile: cisco-asr.yml provider: kentik-router user_tags: owning_team: core-networking discovered_mibs: - BGP4-MIB - CISCO-MEMORY-POOL-MIB - CISCO-PROCESS-MIB - IF-MIB - OSPF-MIB engine_id: \"80:00:01:01:0a:14:1e:28\" match_attributes: if_interface_name: \"^Ten.*|^Gig.*\" \"!if_Alias\": \"[Uu]plink\" # Sample of SNMP v1 device netbotz_snmpv1__10.10.0.203: device_name: netbotz_snmpv1 device_ip: 10.10.0.201 snmp_comm: public use_snmp_v1: true oid: .1.3.6.1.4.1.5528.100.20.10.2013 description: \"Linux netbotz930A7A 2.6.12 #307 Wed Dec 29 15:25:32 EST 2010 ppc\" last_checked: 2021-11-09T18:14:59.907821489Z mib_profile: apc-netbotz.yml provider: kentik-netbotz user_tags: owning_team: sys_ops discovered_mibs: - IF-MIB - IP-MIB - TCP-MIB - UDP-MIB no_use_bulkwalkall: true # Sample of \"flow only\" device flow_only__10.10.0.210: device_name: flow_only device_ip: 10.10.0.210 user_tags: owning_team: net_eng flow_only: true # Sample of \"ping only\" device ping_only__10.10.0.220: device_name: ping_only device_ip: 10.10.0.220 user_tags: owning_team: load_balancing ping_only: true trap: listen: 127.0.0.1:1162 community: public version: \"\" transport: \"\" v3_config: null discovery: cidrs: - 10.0.0.0/24 - 10.0.0.202/32 debug: false ports: - 161 - 1161 default_communities: - public - public123 - Publ!cABC use_snmp_v1: false default_v3: null add_mibs: true threads: 4 add_devices: true replace_devices: true no_dedupe_engine_id: false global: poll_time_sec: 60 drop_if_outside_poll: false mib_profile_dir: /etc/ktranslate/profiles mibs_db: /etc/ktranslate/mibs.db mibs_enabled: - BGP4-MIB - CISCO-MEMORY-POOL-MIB - CISCO-PROCESS-MIB - IF-MIB - IP-MIB - OSPF-MIB - PowerNet-MIB_UPS - TCP-MIB - UDP-MIB timeout_ms: 3000 retries: 0 global_v3: null response_time: false user_tags: environment: production match_attributes: if_Description: \".*WAN.*\" Copy Devices section Key name Required Description device_name ✓ Name of the device. This is the unique identifier for the device in New Relic One. device_ip ✓ Target IP of the device. snmp_comm ✓ (Required for SNMPv1/2c) SNMPv1/2c community string to use. use_snmp_v1 ✓ (Required for SNMPv1) Indicates whether to use SNMPv1. By default, it's set to false. snmp_v3 ✓ (Required for SNMPv3) SNMP v3 config debug Indicates whether to enable debug level logging during SNMP polling. By default, it's set to false. port Port to send SNMP queries to. By default, it's set to port 161. oid ✓ (Required for SNMP polling) The discovered systemObjectID | sysObjectID | sysOID for the device. This is used to match the device to a known SNMP profile and set the provider attribute. If no match is found, this sets the provider as a kentik-default device. description The discovered sysDescr of the device. This field is informational. last_checked Timestamp when this device was last discovered by the ktranslate docker image. This field is informational. mib_profile ✓ (Required for SNMP polling) SNMP Profile file that was associated with this device during the discovery run based on its sysOID. If this starts with a bang (!) token, it will override the automatic matching from the sysOID and use a manual override. Ex: \"!cisco-asa.yml\" (quotes are required). provider ✓ (Required for New Relic One) Value used during entity synthesis for New Relic One. This is automatically created based on the matched mib_profile. poll_time_sec Indicates the SNMP polling frequency in seconds. This setting is used to override the global.poll_time_sec attribute. retries Indicates the number of attempts to retry polling SNMP OIDs. This setting is used to override the global.retries attribute. timeout_ms Indicates the SNMP polling timeout in milliseconds. This setting is used to override the global.timeout_ms attribute. user_tags key:value pair attributes to give more context to the device. Tags at this level will be appended to any tags applied in the global.user_tags attribute. discovered_mibs List of MIBs pulled from matched mib_profile that this device can respond to. This field is informational. engine_id The unique engine ID discovered for this device's SNMP agent. Generally found during SNMP v3 discovery. This field is informational. match_attributes attribute:regex pairs to add metrics to allowlist. Pairs at this level will be appended to any pairs applied in the global.match_attributes attribute. Uses the RE2 syntax and has a default OR operator. Prefix key with ! to force to AND operators. monitor_admin_shut Indicates whether to monitor interfaces in Administratively Shutdown status. By default, it's set to false. no_use_bulkwalkall Disables the SNMP GETBULK request action when true. By default, it's set to false. ping_only Disables all SNMP polling and enables response time polling when true. This setting is used to override the global.response_time attribute. By default, it's set to false. flow_only Disables all SNMP polling when true. By default, it's set to false. Trap section Key name Required Description listen ✓ Listening IP port for receiving SNMP traps. By default it's set to 127.0.0.1:1162, using the SNMP Trap default of 162 requires running Docker as root. community SNMPv1/v2c community string for receiving SNMP traps. version SNMP version to use. Options are v1, v2c, and v3. By default, it's set to v2c. transport SNMP transport protocol to use. Options are TCP and UDP. By default, it's set to UDP v3_config SNMP v3 config to use. Only used if version: v3. Discovery section Key name Required Description cidrs ✓ Array of target IP ranges in CIDR notation. debug Indicates whether to enable debug level logging during discovery. By default, it's set to false ports ✓ Array of target ports to scan during SNMP polling. default_communities ✓ (Required for SNMPv1/2c) Array of SNMPv1/v2c community strings to scan during SNMP polling. This array is evaluated in order and discovery accepts the first passing community. use_snmp_v1 ✓ (Required for SNMPv1) Indicates whether to use SNMPv1 during discovery. By default, it's set to false default_v3 ✓ (Required for SNMPv3) SNMPv3 configuration to scan during SNMP polling. add_devices ✓ Indicates whether to add discovered devices to the devices section of the snmp-base.yaml file. By default, it's set to true. add_mibs ✓ Indicates whether to add discovered MIBs to the global.mibs_enabled section of the snmp-base.yaml file. By default, it's set to true. threads ✓ Integer limit of threads to use during discovery. It should be less than the number of cores available to the container. By default it's set to 4. replace_devices ✓ Indicates whether to replace discovered devices if they already exist in the devices section of the snmp-base.yaml file. By default, it's set to false. no_dedup_engine_id When set to true, disables deduplication of discovered devices if it appears that they are the same device, based on their reported SNMP engine ID. By default, it's set to false Global section Key name Required Description poll_time_sec ✓ Time in seconds to poll devices. This can be overridden per device using the devices.<deviceName>.poll_time_sec attribute. By default, it's set to 60. drop_if_outside_poll Indicates whether to drop all values from this cycle if polling takes longer than the value set in poll_time_sec. By default, it's set to false mib_profile_dir Directory to find curated MIB profiles. These are pulled into the ktranslate image automatically from Kentik's snmp-profiles repository and can be overridden at Docker runtime by creating a volume mount of your own local directory of profiles. mibs_db mibs_enabled ✓ Array of all active MIBs the ktranslate docker image will poll. This list is automatically generated during discovery if the discovery_add_mibs attribute is true. MIBs not listed here will not be polled on any device in the configuration file. You can specify a SNMP table directly in a MIB file using MIB-NAME.tableName syntax. Ex: HOST-RESOURCES-MIB.hrProcessorTable. timeout_ms ✓ Time in milliseconds SNMP queries timeout. This can be overridden per device using the devices.<deviceName>.timeout_ms attribute. By default, it's set to 5000 retries ✓ Number of attempts to retry failed SNMP polls. This can be overridden per device using the devices.<deviceName>.retries attribute. By default, it's set to 0 user_tags key:value pair attributes to give more context to the device. Tags at this level will be applied to all devices in the configuration file. match_attributes attribute:regex pairs to add metrics to allowlist. Pairs at this level will matched against all devices in the configuration file. Uses the RE2 syntax and has a default OR operator. Prefix key with ! to force to AND operators. response_time Indicates whether response time polling is enabled for all devices in the configuration file. By default, it's set to false. Optional SNMPv3 configuration Key name Required Description user_name ✓ User name for SNMPv3 authentication authentication_protocol ✓ SNMPv3 authentication protocol. The possible values are NoAuth, MD5, or SHA authentication_passphrase SNMPv3 authentication passphrase privacy_protocol ✓ SNMPv3 privacy protocol. The possible values are AuthNoPriv, DES, AES, AES192, AES256, AES192C, or AES256C privacy_passphrase SNMPv3 privacy passphrase context_engine_id SNMPv3 context engine ID context_name SNMPv3 context name Tip You can use AWS Secrets Manager natively in your SNMP v3 config using the aws.sm.$SECRET_NAME syntax, replacing $SECRET_NAME as necessary to have ktranslate pull in your credentials during Docker runtime. Optional external config files To support a wide variety of configuration and automation needs, you can use external files that you volume mount into your Docker container to decouple certain elements of the standard configuration file. The syntax for these files is \"@fileName.extension\", including the double quotes. Discovery CIDRs Example: discovery: cidrs: \"@cidrs.yaml\" Copy The CIDRs file should use a YAML list syntax like this: - 10.10.0.0/24 - 10.20.0.0/24 - 192.168.0.21/32 Copy Devices Example: devices: - \"@neteng-devices.yaml\" - \"@dc-ops.yaml\" Copy The device files should use the same syntax as the standard devices section of the main config file, omitting the optional fields that are generated during discovery: devices: # Sample of SNMP v2c device ups_snmpv2c__10.10.0.201: device_name: ups_snmpv2c device_ip: 10.10.0.201 snmp_comm: public oid: .1.3.6.1.4.1.318.1.3.27 mib_profile: apc_ups.yml provider: kentik-ups poll_time_sec: 300 retries: 1 timeout_ms: 5000 user_tags: owning_team: dc_ops Copy The match_attributes attribute To support filtering of data that does not create value for your observability needs, you can set the global.match_attributes.{} and/or devices.<deviceName>.match_attributes.{} attribute map. This will provide filtering at the ktranslate level, before shipping data to New Relic, giving you granular control over monitoring of things like interfaces. The default behavior of this map is an OR condition, but you can override this and force an AND operator by prefixing your key name with !. This is also useful to return only matched items and omit all null and \"\" (empty) results. Default 'OR' with null and empty values Match when if_Alias begins with Uplink OR when if_interface_name begins with Gig, keep all null and \"\" values: devices: deviceName: ... match_attributes: if_Alias: \"^Uplink.*\" if_interface_name: \"^Gig.*\" Copy 'AND', omit null and empty values Match when if_Alias begins with Uplink AND when if_interface_name begins with Gig, drop all null and \"\" values: devices: deviceName: ... match_attributes: if_Alias: \"^Uplink.*\" \"!if_interface_name\": \"^Gig.*\" Copy Single match, omit null and empty values Match when if_Alias begins with Uplink, drop all null and \"\" values: devices: deviceName: ... match_attributes: \"!if_Alias\": \"^Uplink.*\" Copy The flow_only attribute To support monitoring of devices where performance statistics are nor accessible, available, or desired, you can set the devices.<deviceName>.flow_only attribute to true. This will generate a Flow Device entity in New Relic One which will only have telemetry in the KFlow event namespace. Alternatively, collecting flow telemetry from a device that is in your configuration file as an SNMP device will add decoration of the KFlow data to the pre-existing entity, such as a Router or Firewall. In New Relic One, you can see the results of this polling by investigating the following events: FROM KFlow SELECT count(*) FACET device_name WHERE instrumentation.name = 'netflow-events' TIMESERIES Copy The response_time and ping_only attributes To support monitoring of devices where performance statistics are not accessible or available, or in simple cases where basic round-trip time (RTT) monitoring is required, you can either set the global.response_time or devices.<deviceName>.ping_only attributes to true. This feature uses the go-ping package to send unprivileged UDP packets to devices in order to collect the average, min, and max RTT for the endpoint based on sending 1 packet/sec from ktranslate to the device IP address. Setting the global.response_time attribute to true will add RTT monitoring on top of existing SNMP polling. devices.<deviceName>.ping_only: true will allow you to monitor devices with only the UDP packets for RTT and no SNMP polling. In New Relic One, you can see the results of this polling by investigating the following metrics: FROM Metric SELECT average(kentik.ping.AvgRttMs) AS 'Average', max(kentik.ping.MaxRttMs) AS 'Max', min(kentik.ping.MinRttMs) AS 'Min' FACET device_name TIMESERIES Copy Tip You can use the ping_only attribute in replacement of the flow_only attribute if you would like to collect RTT metrics from a flow device. If both ping_only and flow_only are true, the device will be treated as a flow_only device. Flow data application mapping By default, flow telemetry is mapped to known applications based on evaluation of the layer 4 port in use on a specific flow conversation. If needed, you can override the default mapping by providing a YAML file during Docker runtime to the -application_map flag. This will allow you to specify application names based on ports you identify. Example syntax: applications: - ports: [9092, 9093] name: kafka - ports: [80, 8080] name: http - ports: [443, 8443] name: https Copy Flow data input filtering By default, flow data containers will collect and process every flow packet they receive. If needed, you can add an inclusion filter to the -nf.source flag that will ignore all traffic not matching the filter you provide. Syntax: --filters $TYPE,$FIELD,$FUNCTION,$MATCH Argument Name Required Description $TYPE ✓ The type of filter to apply. Possible values are string, int, and addr. $FIELD ✓ The name of the field to evaluate the match pattern against. $FUNCTION ✓ The type of function to use during evaluation. Possible values are Equal: ==, NotEqual: !=, LessThan: <, GreaterThan: >, Contains: % $MATCH ✓ The value to be used as a match pattern. Example Filters Only collect flow data from source addresses in the 10.0.0.0/24 CIDR range -nf.source sflow --filters addr,src_addr,%,10.10.0.0/24 Copy Only collect flow data where the destination port is not equal to 8531 -nf.source netflow5 --filters int,l4_dst_port,!=,8531 Copy You can also add multiple filters together with an inherited AND operator Only collect flow data from source addresses in the 10.0.0.0/24 CIDR range AND where the destination port is not equal to 8531 --filters addr,src_addr,%,10.0.0.0/24 --filters int,l4_dst_port,!=,8531 Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.05075,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Advanced configuration for <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "sections": "Advanced configuration for <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "tags": "<em>Network</em> <em>performance</em> <em>monitoring</em>",
        "body": "If you want to explore all the options you can use when configuring the <em>monitoring</em> of your <em>network</em> <em>performance</em>, see the following sections. SNMP-base YAML sample file Here&#x27;s an example of the various configuration options available in the snmp-base.yaml file used by the ktranslate docker image"
      },
      "id": "61b9389664441f8fc3d7182e"
    }
  ],
  "/docs/network-performance-monitoring/troubleshooting/snmp-walk": [
    {
      "sections": [
        "Visualize your network performance data in New Relic One",
        "Prerequisites",
        "Add the Network dashboards to your account",
        "Tip",
        "Start exploring your network performance data"
      ],
      "title": "Visualize your network performance data in New Relic One",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Monitoring"
      ],
      "external_id": "a9e82cf586cd71595b0fd3bdcc831768578417cf",
      "image": "https://docs.newrelic.com/static/f6a643a55e2f9a2b070d85ab9174ba48/c1b63/flow_data_dashboard.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/monitoring-network-data/visualize-network-data/",
      "published_at": "2021-12-30T09:50:55Z",
      "updated_at": "2021-12-30T09:50:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you set up your network data for performance monitoring, you can go to New Relic One and install several custom-curated visualizations designed specifically for network performance monitoring. Then, after you set up these visualizations, you can start exploring the network data your devices are reporting to New Relic One. You can group and monitor your switches, routers, etc. in dashboards. This helps you quickly aggregate, isolate, and analyze the health of your network. For some examples of monitoring your network in New Relic One, watch this short video (approx. 3:45 minutes). Prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. Having set up your Network Performance Monitoring devices. Read how to: Set up SNMP data monitoring. Set up network flow data monitoring. Add the custom visualizations app to your account: Go to one.newrelic.com > Apps, and search for Network Agent Visualizations. Click the app, and then click Open visualization. one.newrelic.com > Apps, and search for Network Agent Visualizations. From the Account ID dropdown, select the account you want to add the visualizations to, and click Enable. Add the Network dashboards to your account You can go to New Relic One and import several dashboards to see curated views of your network telemetry, including the GeoMap and Sankey custom visualizations from the prerequisites. Go to one.newrelic.com > Apps, and search for Quickstarts. Click Quickstarts. In the search bar, search for Network, then click one of the dashboards: Use the Network - Data Ingest and Cardinality dashboard to analyze usage trends. Use the Network - Routers and Switches dashboard for SNMP data from router and switch entities. Use the Network - Flow Devices dashboard for network flow data. one.newrelic.com > Apps, and search for Network. Click Import. Select the account where you want to add the dashboard. Optional: Edit the dashboard name. Click Import dashboard. Tip If you want to read more about custom visualizations in New Relic One, see the introduction to custom visualizations. Start exploring your network performance data Once you've finished setting up these dashboards, you can start seeing your network data by going to Dashboards or Explorer in New Relic One: From one.newrelic.com > Dashboards: For usage trend analysis, you'll see the following dashboard: Dashboard for analyzing network telemetry usage trends in New Relic One. For SNMP data, you'll see the following dashboard: Dashboard for SNMP data from router and switch entities in New Relic One. For network flow data, you'll see the following dashboard: Dashboard for network flow data monitoring in New Relic One. From one.newrelic.com > Explorer: Entities are listed under the Network category in the left-hand side menu. Open a specific device to see the details and trend of its performance. On the top right-hand side, click Lookout to see anomalies. Lookout view for Network Performance Monitoring in New Relic One. To learn how to troubleshoot network data in Navigator and Lookout, watch this short video (approx. 3:15 minutes).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 195.87625,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Visualize your <em>network</em> <em>performance</em> data in New Relic One",
        "sections": "Visualize your <em>network</em> <em>performance</em> data in New Relic One",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": ". From one.newrelic.com &gt; Explorer: Entities are listed under the <em>Network</em> category in the left-hand side menu. Open a specific device to see the details and trend of its <em>performance</em>. On the top right-hand side, click Lookout to see anomalies. Lookout view for <em>Network</em> <em>Performance</em> <em>Monitoring</em> in New Relic One. To learn how to <em>troubleshoot</em> <em>network</em> data in Navigator and Lookout, watch this short video (approx. 3:15 minutes)."
      },
      "id": "6127249b64441f621ea47c42"
    },
    {
      "sections": [
        "ktranslate Docker container health monitoring",
        "Logs from ktranslate",
        "Tip",
        "Optional log parsing rule",
        "Common log searches",
        "What version of ktranslate am I running?",
        "What arguments were passed to Docker at runtime?",
        "What errors am I experiencing?",
        "Is my match_attributes filter working on my device?",
        "Metrics from ktranslate",
        "Common metrics searches",
        "What are the current versions of my ktranslate applications?",
        "What is the health of my ktranslate application?",
        "What is the health of my deliveries to New Relic One?",
        "What is the health of my SNMP collection overall?",
        "What devices are failing SNMP collection?",
        "What is the health of my flow data collection?",
        "What is the health of my syslog collection?"
      ],
      "title": "ktranslate Docker container health monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring"
      ],
      "external_id": "a6a4a6194c420409a30f75d437e27998235b84bc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/advanced/ktranslate-container-health/",
      "published_at": "2021-12-30T03:02:12Z",
      "updated_at": "2021-12-16T01:45:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "While running the ktranslate Docker container for New Relic network performance monitoring, you can monitor the health of the container to proactively detect potential issues. The ktranslate container image has the -tee_logs=true and -metrics=jchf settings available during runtime, which allow it to send health metrics into New Relic One directly. These are enabled by default when installing network performance monitoring via the New Relic One guided install. We recommend you to set them up when installing network performance monitoring manually. Logs from ktranslate Tip If you want to check the logs locally from the Docker host, run docker logs $CONTAINER_NAME. For example, docker logs ktranslate-snmp. The -tee_logs=true option sends logs to New Relic One when polling devices. To see them, do the following: Go to one.newrelic.com > Logs. In Find logs where, enter collector.name:\"ktranslate\" and click Query logs. Optional log parsing rule We recommend you to add a parsing rule to New Relic One logs to break the logs from ktranslate into fields that are easily searchable. This is especially helpful when you are running more than one container as it allows you to then search by the value of --service_name from the Docker container. Using the New Relic One logs UI, use the following patterns: Rule Name: ktranslate-health logs Query Attribute: \"plugin.type\" Query Value: \"ktranslate-health\" Parsing logic: %{NOTSPACE:time} ktranslate/%{NOTSPACE:container_service} \\[%{NOTSPACE:severity}\\] %{GREEDYDATA:message} Copy Alternatively, you can use New Relic's Nerdgraph API to manage your parsing rules. A sample of the logConfigurationsCreateParsingRule is below, you will need to replace $ACCOUNT_ID with the ID of your target account. mutation { logConfigurationsCreateParsingRule( accountId: $ACCOUNT_ID, rule: { description: \"ktranslate-health logs\", enabled: true, grok: \"%{NOTSPACE:time} ktranslate/%{NOTSPACE:container_service} \\\\[%{NOTSPACE:severity}\\\\] %{GREEDYDATA:message}\", lucene: \"\\\"plugin.type\\\":\\\"ktranslate-health\\\"\", nrql: \"SELECT * FROM Log WHERE `plugin.type` = 'ktranslate-health'\" } ) { errors { message type } rule { accountId id enabled description grok lucene nrql } } } Copy The result of this parsing rule is splitting a raw message from this: { \"collector.name\": \"ktranslate\", \"instrumentation.provider\": \"kentik\", \"message\": \"2021-12-08T14:59:56.007 ktranslate/snmp [Info] nrmFormat New Metadata for cisco-7513\", \"newrelic.source\": \"api.logs\", \"plugin.type\": \"ktranslate-health\", \"timestamp\": 1638975596000 } Copy To this, creating the searchable fields of container_service, severity, and time; as well as trimming the message field to more actionable data: { \"collector.name\": \"ktranslate\", \"container_service\": \"snmp\", \"instrumentation.provider\": \"kentik\", \"message\": \"nrmFormat New Metadata for cisco-7513\", \"newrelic.source\": \"api.logs\", \"plugin.type\": \"ktranslate-health\", \"severity\": \"Info\", \"time\": \"2021-12-08T15:29:56.026\", \"timestamp\": 1638977396000 } Copy Common log searches Below are some common searches that can be used during troubleshooting to gather data for support: What version of ktranslate am I running? Logs UI: bash Copy $ collector.name:\"ktranslate\" message:\"*KTranslate Running -- Version*\" NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `message` LIKE '%KTranslate Running -- Version%' Copy Expected Results: bash Copy $ KTranslate Running -- Version kt-2021-12-06-1546870234; Build Mon Dec 6 22:22:56 UTC 2021 What arguments were passed to Docker at runtime? Logs UI: bash Copy $ collector.name:\"ktranslate\" message:\"*KTranslate CLI:*\" NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `message` LIKE '%KTranslate CLI:%' Copy Expected Results: bash Copy $ KTranslate CLI: [ktranslate -listen off -mapping /etc/ktranslate/config.json -geo /etc/ktranslate/GeoLite2-Country.mmdb -udrs /etc/ktranslate/udr.csv -api_devices /etc/ktranslate/devices.json -asn /etc/ktranslate/GeoLite2-ASN.mmdb -log_level info -snmp /snmp-base.yaml -nr_account_id=2583772 -log_level=info -metrics=jchf -tee_logs=true -service_name=snmp nr1.snmp] What errors am I experiencing? Without a parsing rule applied to your logs Logs UI: bash Copy $ collector.name:\"ktranslate\" message:-*\\[Info\\]* NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `message` NOT LIKE '%[Info]%' Copy With a parsing rule applied to your logs Logs UI: bash Copy $ collector.name:\"ktranslate\" severity:-\"Info\" NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `severity` != 'Info' Copy Expected Results: bash Copy $ KTranslate>cisco-7513 There was an SNMP polling error with the CustomDeviceMetrics walking OID .1.3.6.1.2.1.4.31.1.1.21 after 0 retries: request timeout (after 0 retries). Is my match_attributes filter working on my device? Logs UI: bash Copy $ collector.name:\"ktranslate\" message:\"*Match Attribute*\" NRQL: FROM Log SELECT * WHERE `collector.name` = 'ktranslate' AND `message` LIKE '%Match Attribute%' Copy Expected Results: bash Copy $ KTranslate>cisco-7513 Added 1 Match Attribute(s) All devices are expected to have at least 1 Match Attribute inherited from the default monitor_admin_shut: true configuration. You should expect a value of 2 to be shown for a device that you have added a single match attribute to. Tip You can further filter these results by adding the device name to your query: collector.name:\"ktranslate\" message:\"*$DEVICE_NAME*Match Attribute*\". Metrics from ktranslate The -metrics option captures the following performance metrics when polling devices: Metric Granularity Description baseserver_healthcheck_execution_total Top Level Rate of internal health checks. Shows mostly that things are not deadlocked and should always be greater than 0. inputq Top Level Messages per second (msg/sec) received over the last 60 seconds from all SNMP, Flow, and VPC inputs combined. jchfq Top Level Gauge rate with number of available pre-allocated buffers. It should be about 8,000. delivery_metrics_nr Delivery to New Relic One Batches per second (batches/sec) sent over the last 60 seconds for all metrics to New Relic One. delivery_logs_nr Delivery to New Relic One Logs per second (logs/sec) sent over the last 60 seconds for all logs to New Relic One. delivery_wins_nr Delivery to New Relic One Wins per second (wins/sec) of 200 HTTP codes received over the last 60 seconds from sending metrics and events to New Relic One. device_metrics SNMP Polls per second (polls/sec) of SNMP polling over the last 60 seconds for device level metrics. interface_metrics SNMP Polls per second (polls/sec) of SNMP polling over the last 60 seconds for interface level metrics. snmp_fail SNMP Gauge to monitor if SNMP polling is working faceted by device_name. Where 1 means good and 2 means fail. netflow.flows Netflow Flows per second (fps) received over the last 60 seconds for all device flow data: IPFIX, NetFlow, or sFlow. syslog_queue Syslog Gauge of syslog messages waiting to be processed. syslog_errors Syslog Errors per second (errors/sec) over the last 60 seconds while processing syslog messages. syslog_messages Syslog Messages per second (msg/sec) received over the last 60 seconds for all syslog data. Common metrics searches To see these metrics in New Relic One: Go to one.newrelic.com and click Query your data. Enter one of the following NRQL queries: What are the current versions of my ktranslate applications? FROM Metric SELECT latest(ver) AS 'image_version' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What is the health of my ktranslate application? FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.baseserver_healthcheck_execution_total) AS 'healthcheck_total', latest(kentik.ktranslate.chf.kkc.inputq) AS 'input_per_second', latest(kentik.ktranslate.chf.kkc.jchfq) AS 'buffer' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What is the health of my deliveries to New Relic One? FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.delivery_metrics_nr) AS 'delivery_metric_batches_per_second', latest(kentik.ktranslate.chf.kkc.delivery_logs_nr) AS 'delivery_logs_per_second', latest(kentik.ktranslate.chf.kkc.delivery_wins_nr) AS 'delivery_wins_per_second' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What is the health of my SNMP collection overall? FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.device_metrics) AS 'device_polls_per_second', latest(kentik.ktranslate.chf.kkc.interface_metrics) AS 'interface_polls_per_second' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What devices are failing SNMP collection? SELECT max(snmp_fail) FROM ( FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.snmp_fail) AS 'snmp_fail' FACET host AS 'docker_host', svc AS 'container_service', device_name AS 'snmp_device' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' ) FACET docker_host, container_service, snmp_device WHERE snmp_fail = 2 Copy What is the health of my flow data collection? FROM Metric SELECT max(kentik.ktranslate.chf.kkc.netflow) AS 'flows_per_second' FACET host AS 'docker_host', svc AS 'container_service', device_name AS 'flow_device' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy What is the health of my syslog collection? FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.syslog_queue) AS 'syslog_queue_total', latest(kentik.ktranslate.chf.kkc.syslog_errors) AS 'syslog_errors_per_second', latest(kentik.ktranslate.chf.kkc.syslog_messages) AS 'syslog_messages_per_second' FACET host AS 'docker_host', svc AS 'container_service' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.50264,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "ktranslate Docker container health <em>monitoring</em>",
        "sections": "ktranslate Docker container health <em>monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": "While running the ktranslate Docker container for New Relic <em>network</em> <em>performance</em> <em>monitoring</em>, you can <em>monitor</em> the health of the container to proactively detect potential issues. The ktranslate container image has the -tee_logs=true and -metrics=jchf settings available during runtime, which allow"
      },
      "id": "61b9389528ccbcb4d396ee5e"
    },
    {
      "sections": [
        "Advanced configuration for Network Performance Monitoring",
        "SNMP-base YAML sample file",
        "Devices section",
        "Trap section",
        "Discovery section",
        "Global section",
        "Optional SNMPv3 configuration",
        "Tip",
        "Optional external config files",
        "Discovery CIDRs",
        "Devices",
        "The match_attributes attribute",
        "Default 'OR' with null and empty values",
        "'AND', omit null and empty values",
        "Single match, omit null and empty values",
        "The flow_only attribute",
        "The response_time and ping_only attributes",
        "Flow data application mapping",
        "Flow data input filtering",
        "Example Filters"
      ],
      "title": "Advanced configuration for Network Performance Monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Advanced configuration"
      ],
      "external_id": "61f8c58056547c4a9a2c534617559472e3e62fd1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/advanced/advanced-config/",
      "published_at": "2021-12-30T03:03:15Z",
      "updated_at": "2021-12-19T05:14:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you want to explore all the options you can use when configuring the monitoring of your network performance, see the following sections. SNMP-base YAML sample file Here's an example of the various configuration options available in the snmp-base.yaml file used by the ktranslate docker image to poll for SNMP and flow data devices. You can also see a heavily-commented sample in the ktranslate repository on GitHub. devices: # Sample of SNMP v2c device ups_snmpv2c__10.10.0.201: device_name: ups_snmpv2c device_ip: 10.10.0.201 snmp_comm: public oid: .1.3.6.1.4.1.318.1.3.27 description: \"APC Web/SNMP Management Card (MB:v4.1.0 PF:v6.2.1 PN:apc_hw05_aos_621.bin AF1:v6.2.1 AN1:apc_hw05_sumx_621.bin MN:AP9537SUM HR:05 SN: ABC123DEF456 MD:05/21/2016) (Embedded PowerNet SNMP Agent SW v2.2 compatible)\" last_checked: 2021-11-09T18:14:59.907821489Z mib_profile: apc_ups.yml provider: kentik-ups poll_time_sec: 300 retries: 1 timeout_ms: 5000 user_tags: owning_team: dc_ops discovered_mibs: - PowerNet-MIB_UPS - TCP-MIB - UDP-MIB # Sample of SNMP v3 device router_snmpv3__10.10.0.202: device_name: router_snmpv3 device_ip: 10.10.0.202 snmp_v3: user_name: userNamev3 authentication_protocol: MD5 authentication_passphrase: authPassPrivacy privacy_protocol: AES256 privacy_passphrase: passPrivacy oid: .1.3.6.1.4.1.9.1.544 description: \"Cisco IOS Software, 3800 Software (C3845-ADVENTERPRISEK9-M), Version 15.1(3)T4, RELEASE SOFTWARE (fc1)\\r\\nTechnical Support: http://www.cisco.com/techsupport\\r\\nCopyright (c) 1986-2012 by Cisco Systems, Inc.\\r\\nCompiled Thu 24-May-12 04:27 by prod_rel_team\" last_checked: 2021-11-09T18:14:59.907821489Z mib_profile: cisco-asr.yml provider: kentik-router user_tags: owning_team: core-networking discovered_mibs: - BGP4-MIB - CISCO-MEMORY-POOL-MIB - CISCO-PROCESS-MIB - IF-MIB - OSPF-MIB engine_id: \"80:00:01:01:0a:14:1e:28\" match_attributes: if_interface_name: \"^Ten.*|^Gig.*\" \"!if_Alias\": \"[Uu]plink\" # Sample of SNMP v1 device netbotz_snmpv1__10.10.0.203: device_name: netbotz_snmpv1 device_ip: 10.10.0.201 snmp_comm: public use_snmp_v1: true oid: .1.3.6.1.4.1.5528.100.20.10.2013 description: \"Linux netbotz930A7A 2.6.12 #307 Wed Dec 29 15:25:32 EST 2010 ppc\" last_checked: 2021-11-09T18:14:59.907821489Z mib_profile: apc-netbotz.yml provider: kentik-netbotz user_tags: owning_team: sys_ops discovered_mibs: - IF-MIB - IP-MIB - TCP-MIB - UDP-MIB no_use_bulkwalkall: true # Sample of \"flow only\" device flow_only__10.10.0.210: device_name: flow_only device_ip: 10.10.0.210 user_tags: owning_team: net_eng flow_only: true # Sample of \"ping only\" device ping_only__10.10.0.220: device_name: ping_only device_ip: 10.10.0.220 user_tags: owning_team: load_balancing ping_only: true trap: listen: 127.0.0.1:1162 community: public version: \"\" transport: \"\" v3_config: null discovery: cidrs: - 10.0.0.0/24 - 10.0.0.202/32 debug: false ports: - 161 - 1161 default_communities: - public - public123 - Publ!cABC use_snmp_v1: false default_v3: null add_mibs: true threads: 4 add_devices: true replace_devices: true no_dedupe_engine_id: false global: poll_time_sec: 60 drop_if_outside_poll: false mib_profile_dir: /etc/ktranslate/profiles mibs_db: /etc/ktranslate/mibs.db mibs_enabled: - BGP4-MIB - CISCO-MEMORY-POOL-MIB - CISCO-PROCESS-MIB - IF-MIB - IP-MIB - OSPF-MIB - PowerNet-MIB_UPS - TCP-MIB - UDP-MIB timeout_ms: 3000 retries: 0 global_v3: null response_time: false user_tags: environment: production match_attributes: if_Description: \".*WAN.*\" Copy Devices section Key name Required Description device_name ✓ Name of the device. This is the unique identifier for the device in New Relic One. device_ip ✓ Target IP of the device. snmp_comm ✓ (Required for SNMPv1/2c) SNMPv1/2c community string to use. use_snmp_v1 ✓ (Required for SNMPv1) Indicates whether to use SNMPv1. By default, it's set to false. snmp_v3 ✓ (Required for SNMPv3) SNMP v3 config debug Indicates whether to enable debug level logging during SNMP polling. By default, it's set to false. port Port to send SNMP queries to. By default, it's set to port 161. oid ✓ (Required for SNMP polling) The discovered systemObjectID | sysObjectID | sysOID for the device. This is used to match the device to a known SNMP profile and set the provider attribute. If no match is found, this sets the provider as a kentik-default device. description The discovered sysDescr of the device. This field is informational. last_checked Timestamp when this device was last discovered by the ktranslate docker image. This field is informational. mib_profile ✓ (Required for SNMP polling) SNMP Profile file that was associated with this device during the discovery run based on its sysOID. If this starts with a bang (!) token, it will override the automatic matching from the sysOID and use a manual override. Ex: \"!cisco-asa.yml\" (quotes are required). provider ✓ (Required for New Relic One) Value used during entity synthesis for New Relic One. This is automatically created based on the matched mib_profile. poll_time_sec Indicates the SNMP polling frequency in seconds. This setting is used to override the global.poll_time_sec attribute. retries Indicates the number of attempts to retry polling SNMP OIDs. This setting is used to override the global.retries attribute. timeout_ms Indicates the SNMP polling timeout in milliseconds. This setting is used to override the global.timeout_ms attribute. user_tags key:value pair attributes to give more context to the device. Tags at this level will be appended to any tags applied in the global.user_tags attribute. discovered_mibs List of MIBs pulled from matched mib_profile that this device can respond to. This field is informational. engine_id The unique engine ID discovered for this device's SNMP agent. Generally found during SNMP v3 discovery. This field is informational. match_attributes attribute:regex pairs to add metrics to allowlist. Pairs at this level will be appended to any pairs applied in the global.match_attributes attribute. Uses the RE2 syntax and has a default OR operator. Prefix key with ! to force to AND operators. monitor_admin_shut Indicates whether to monitor interfaces in Administratively Shutdown status. By default, it's set to false. no_use_bulkwalkall Disables the SNMP GETBULK request action when true. By default, it's set to false. ping_only Disables all SNMP polling and enables response time polling when true. This setting is used to override the global.response_time attribute. By default, it's set to false. flow_only Disables all SNMP polling when true. By default, it's set to false. Trap section Key name Required Description listen ✓ Listening IP port for receiving SNMP traps. By default it's set to 127.0.0.1:1162, using the SNMP Trap default of 162 requires running Docker as root. community SNMPv1/v2c community string for receiving SNMP traps. version SNMP version to use. Options are v1, v2c, and v3. By default, it's set to v2c. transport SNMP transport protocol to use. Options are TCP and UDP. By default, it's set to UDP v3_config SNMP v3 config to use. Only used if version: v3. Discovery section Key name Required Description cidrs ✓ Array of target IP ranges in CIDR notation. debug Indicates whether to enable debug level logging during discovery. By default, it's set to false ports ✓ Array of target ports to scan during SNMP polling. default_communities ✓ (Required for SNMPv1/2c) Array of SNMPv1/v2c community strings to scan during SNMP polling. This array is evaluated in order and discovery accepts the first passing community. use_snmp_v1 ✓ (Required for SNMPv1) Indicates whether to use SNMPv1 during discovery. By default, it's set to false default_v3 ✓ (Required for SNMPv3) SNMPv3 configuration to scan during SNMP polling. add_devices ✓ Indicates whether to add discovered devices to the devices section of the snmp-base.yaml file. By default, it's set to true. add_mibs ✓ Indicates whether to add discovered MIBs to the global.mibs_enabled section of the snmp-base.yaml file. By default, it's set to true. threads ✓ Integer limit of threads to use during discovery. It should be less than the number of cores available to the container. By default it's set to 4. replace_devices ✓ Indicates whether to replace discovered devices if they already exist in the devices section of the snmp-base.yaml file. By default, it's set to false. no_dedup_engine_id When set to true, disables deduplication of discovered devices if it appears that they are the same device, based on their reported SNMP engine ID. By default, it's set to false Global section Key name Required Description poll_time_sec ✓ Time in seconds to poll devices. This can be overridden per device using the devices.<deviceName>.poll_time_sec attribute. By default, it's set to 60. drop_if_outside_poll Indicates whether to drop all values from this cycle if polling takes longer than the value set in poll_time_sec. By default, it's set to false mib_profile_dir Directory to find curated MIB profiles. These are pulled into the ktranslate image automatically from Kentik's snmp-profiles repository and can be overridden at Docker runtime by creating a volume mount of your own local directory of profiles. mibs_db mibs_enabled ✓ Array of all active MIBs the ktranslate docker image will poll. This list is automatically generated during discovery if the discovery_add_mibs attribute is true. MIBs not listed here will not be polled on any device in the configuration file. You can specify a SNMP table directly in a MIB file using MIB-NAME.tableName syntax. Ex: HOST-RESOURCES-MIB.hrProcessorTable. timeout_ms ✓ Time in milliseconds SNMP queries timeout. This can be overridden per device using the devices.<deviceName>.timeout_ms attribute. By default, it's set to 5000 retries ✓ Number of attempts to retry failed SNMP polls. This can be overridden per device using the devices.<deviceName>.retries attribute. By default, it's set to 0 user_tags key:value pair attributes to give more context to the device. Tags at this level will be applied to all devices in the configuration file. match_attributes attribute:regex pairs to add metrics to allowlist. Pairs at this level will matched against all devices in the configuration file. Uses the RE2 syntax and has a default OR operator. Prefix key with ! to force to AND operators. response_time Indicates whether response time polling is enabled for all devices in the configuration file. By default, it's set to false. Optional SNMPv3 configuration Key name Required Description user_name ✓ User name for SNMPv3 authentication authentication_protocol ✓ SNMPv3 authentication protocol. The possible values are NoAuth, MD5, or SHA authentication_passphrase SNMPv3 authentication passphrase privacy_protocol ✓ SNMPv3 privacy protocol. The possible values are AuthNoPriv, DES, AES, AES192, AES256, AES192C, or AES256C privacy_passphrase SNMPv3 privacy passphrase context_engine_id SNMPv3 context engine ID context_name SNMPv3 context name Tip You can use AWS Secrets Manager natively in your SNMP v3 config using the aws.sm.$SECRET_NAME syntax, replacing $SECRET_NAME as necessary to have ktranslate pull in your credentials during Docker runtime. Optional external config files To support a wide variety of configuration and automation needs, you can use external files that you volume mount into your Docker container to decouple certain elements of the standard configuration file. The syntax for these files is \"@fileName.extension\", including the double quotes. Discovery CIDRs Example: discovery: cidrs: \"@cidrs.yaml\" Copy The CIDRs file should use a YAML list syntax like this: - 10.10.0.0/24 - 10.20.0.0/24 - 192.168.0.21/32 Copy Devices Example: devices: - \"@neteng-devices.yaml\" - \"@dc-ops.yaml\" Copy The device files should use the same syntax as the standard devices section of the main config file, omitting the optional fields that are generated during discovery: devices: # Sample of SNMP v2c device ups_snmpv2c__10.10.0.201: device_name: ups_snmpv2c device_ip: 10.10.0.201 snmp_comm: public oid: .1.3.6.1.4.1.318.1.3.27 mib_profile: apc_ups.yml provider: kentik-ups poll_time_sec: 300 retries: 1 timeout_ms: 5000 user_tags: owning_team: dc_ops Copy The match_attributes attribute To support filtering of data that does not create value for your observability needs, you can set the global.match_attributes.{} and/or devices.<deviceName>.match_attributes.{} attribute map. This will provide filtering at the ktranslate level, before shipping data to New Relic, giving you granular control over monitoring of things like interfaces. The default behavior of this map is an OR condition, but you can override this and force an AND operator by prefixing your key name with !. This is also useful to return only matched items and omit all null and \"\" (empty) results. Default 'OR' with null and empty values Match when if_Alias begins with Uplink OR when if_interface_name begins with Gig, keep all null and \"\" values: devices: deviceName: ... match_attributes: if_Alias: \"^Uplink.*\" if_interface_name: \"^Gig.*\" Copy 'AND', omit null and empty values Match when if_Alias begins with Uplink AND when if_interface_name begins with Gig, drop all null and \"\" values: devices: deviceName: ... match_attributes: if_Alias: \"^Uplink.*\" \"!if_interface_name\": \"^Gig.*\" Copy Single match, omit null and empty values Match when if_Alias begins with Uplink, drop all null and \"\" values: devices: deviceName: ... match_attributes: \"!if_Alias\": \"^Uplink.*\" Copy The flow_only attribute To support monitoring of devices where performance statistics are nor accessible, available, or desired, you can set the devices.<deviceName>.flow_only attribute to true. This will generate a Flow Device entity in New Relic One which will only have telemetry in the KFlow event namespace. Alternatively, collecting flow telemetry from a device that is in your configuration file as an SNMP device will add decoration of the KFlow data to the pre-existing entity, such as a Router or Firewall. In New Relic One, you can see the results of this polling by investigating the following events: FROM KFlow SELECT count(*) FACET device_name WHERE instrumentation.name = 'netflow-events' TIMESERIES Copy The response_time and ping_only attributes To support monitoring of devices where performance statistics are not accessible or available, or in simple cases where basic round-trip time (RTT) monitoring is required, you can either set the global.response_time or devices.<deviceName>.ping_only attributes to true. This feature uses the go-ping package to send unprivileged UDP packets to devices in order to collect the average, min, and max RTT for the endpoint based on sending 1 packet/sec from ktranslate to the device IP address. Setting the global.response_time attribute to true will add RTT monitoring on top of existing SNMP polling. devices.<deviceName>.ping_only: true will allow you to monitor devices with only the UDP packets for RTT and no SNMP polling. In New Relic One, you can see the results of this polling by investigating the following metrics: FROM Metric SELECT average(kentik.ping.AvgRttMs) AS 'Average', max(kentik.ping.MaxRttMs) AS 'Max', min(kentik.ping.MinRttMs) AS 'Min' FACET device_name TIMESERIES Copy Tip You can use the ping_only attribute in replacement of the flow_only attribute if you would like to collect RTT metrics from a flow device. If both ping_only and flow_only are true, the device will be treated as a flow_only device. Flow data application mapping By default, flow telemetry is mapped to known applications based on evaluation of the layer 4 port in use on a specific flow conversation. If needed, you can override the default mapping by providing a YAML file during Docker runtime to the -application_map flag. This will allow you to specify application names based on ports you identify. Example syntax: applications: - ports: [9092, 9093] name: kafka - ports: [80, 8080] name: http - ports: [443, 8443] name: https Copy Flow data input filtering By default, flow data containers will collect and process every flow packet they receive. If needed, you can add an inclusion filter to the -nf.source flag that will ignore all traffic not matching the filter you provide. Syntax: --filters $TYPE,$FIELD,$FUNCTION,$MATCH Argument Name Required Description $TYPE ✓ The type of filter to apply. Possible values are string, int, and addr. $FIELD ✓ The name of the field to evaluate the match pattern against. $FUNCTION ✓ The type of function to use during evaluation. Possible values are Equal: ==, NotEqual: !=, LessThan: <, GreaterThan: >, Contains: % $MATCH ✓ The value to be used as a match pattern. Example Filters Only collect flow data from source addresses in the 10.0.0.0/24 CIDR range -nf.source sflow --filters addr,src_addr,%,10.10.0.0/24 Copy Only collect flow data where the destination port is not equal to 8531 -nf.source netflow5 --filters int,l4_dst_port,!=,8531 Copy You can also add multiple filters together with an inherited AND operator Only collect flow data from source addresses in the 10.0.0.0/24 CIDR range AND where the destination port is not equal to 8531 --filters addr,src_addr,%,10.0.0.0/24 --filters int,l4_dst_port,!=,8531 Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.05075,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Advanced configuration for <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "sections": "Advanced configuration for <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "tags": "<em>Network</em> <em>performance</em> <em>monitoring</em>",
        "body": "If you want to explore all the options you can use when configuring the <em>monitoring</em> of your <em>network</em> <em>performance</em>, see the following sections. SNMP-base YAML sample file Here&#x27;s an example of the various configuration options available in the snmp-base.yaml file used by the ktranslate docker image"
      },
      "id": "61b9389664441f8fc3d7182e"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application": [
    {
      "sections": [
        "Use workloads",
        "Health",
        "Activity",
        "Owner",
        "Header",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-12-30T18:57:47Z",
      "updated_at": "2021-12-30T18:57:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are three main tabs (Health, Activity, and Owner) plus the header. Health The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. Activity The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here are the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. You can control which golden metrics are used to visualize your workload entities by using the golden metrics API. To learn more, watch this short video (approx. 4 minutes). Owner The Owner tab gives you information about the team responsible for the workload. It looks like this: It contains: The team responsible for the workload. You can include more than one team. The workload description. Share the mission of the workload, and the business logic it represents: Is it a web application? An API? A backend process? Fill in any details that are relevant to your team, or to other teams in your organization. Contact information. From the drop-down menu, choose how your team prefers to be contacted. Links to the most relevant resources to operate the workload. Here you can add links to runbooks, code repositories, productivity tools, or anything else related to the workload that you need at hand. Header The header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. You can create workloads that update dynamically by leveraging tags. To learn how, watch this short video (approx. 3 minutes). Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 261.87518,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Use</em> workloads",
        "sections": "<em>Use</em> workloads",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " of entities depends on your organization structure and goals. <em>one</em>.newrelic.com &gt; Explorer &gt; Workloads &gt; Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can <em>use</em> <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-12-30T06:11:17Z",
      "updated_at": "2021-12-25T14:30:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters Allowed characters: Characters must be UTF-8. When using NerdGraph to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. For APM agents, restart your service. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration, both methods require you to restart your service. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. And check out this short video on querying APM tags (3:20 minutes). Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 217.82004,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Use</em> tags to help organize and find your data",
        "sections": "<em>Use</em> tags to help organize and find your data",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " solution. Tip Tags were previously called labels in the <em>New</em> <em>Relic</em> UI. You may sometimes see labelin our code; for example, some of our APM agent config files <em>use</em> a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "Metric normalization rules",
        "Metric normalization rules management"
      ],
      "title": "Metric normalization rules",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "3c55e4717f145ac7ae0d88e860878f4e8d18cd6b",
      "image": "https://docs.newrelic.com/static/83edfb6f5b1b68712cac34d138bb8cb8/3996e/create-new-rule-window.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/metric-normalization-rules/",
      "published_at": "2021-12-30T02:16:02Z",
      "updated_at": "2021-12-04T18:10:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There may be cases where an application sends many individual metrics that could be better managed in groups. Most of these occur with web transactions metrics named from URLs. For more information on this issue, see Metric grouping issues (MGIs). To reduce high cardinality and prevent metric grouping issues, New Relic supports rules for grouping or filtering out metrics (normalization). In some cases, when MGIs with a significant high number of metrics are detected, a rule is created automatically to protect the platform from performance degradation. Metric normalization rules management You can create and manage new rules that deal with the noise produced from high cardinality metrics by using the metric normalization tool, which is accessible from each service dashboard in the New Relic Explorer. Once there, select Metric Normalization in the left sidebar. There you can see the existing rules or create new ones. Click a rule to modify it, or click Create a new rule to create a new one. A new pane to configure the rule will be displayed. Available fields are: Match expression: enter the regular expression to group all the metrics you want to include in the rule. Matches: here you will see a preview of the metrics matched by the regular expression above. Action: the action you want to perform on the metrics. Replace: replace the matched metrics by the regular expression with the value described in the Replacement field. Ignore: ignore any metric that matches the regular expression. Deny new metrics: only write metrics that have already been reported, and ignore those that match the regular expression. Replacement: only active when Replace is enabled. Matched metrics are replaced with the field's value. If the regular expression is capturing groups, you can use placeholders for them with \\1 or \\2 for the groups 1 and 2 respectively. Active: rules can’t be deleted, but can be deactivated. Click the toggle to enable or disable the rule. If you want the rule to be removed, reach out to New Relic's support. Terminate: When enabled, the rules waterfall is exited when the associated pattern is matched. Notes: internal notes on the rule. Has no effect on the rule. Once you have set up the fields, click Create (or Edit in case you are editing an existing rule), and the rule will be applied immediately as long as it's Active.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.76135,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " grouping issues, <em>New</em> <em>Relic</em> supports rules for grouping or filtering out metrics (normalization). In some cases, when MGIs with a significant high number of metrics are detected, a rule is created automatically to protect the platform from performance degradation. Metric normalization rules management You"
      },
      "id": "603e810b64441ff3a74e8862"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/core-concepts/dashboards-api-migration-insights-api-nerdgraph": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Monitor your network devices with New Relic",
        "Query data with NRQL"
      ],
      "published_at": "2022-01-02T01:39:10Z",
      "title": "Collect data",
      "updated_at": "2022-01-02T01:39:10Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source APIs, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with NerdGraph Try NerdGraph and build the queries you need 25 min Monitor your network devices with New Relic Monitor your network devices with New Relic 45 min Query data with NRQL Query default data, custom events, and attributes 10 min",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 265.82404,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build queries with <em>NerdGraph</em>",
        "body": " data - any source APIs, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with <em>NerdGraph</em> Try <em>NerdGraph</em> and build the queries"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "Dashboards API",
        "Starting out with NerdGraph",
        "Operations",
        "Dashboard CRUD operations",
        "Dashboard page operations",
        "Other operations",
        "Limits",
        "Dashboard limits",
        "Dashboard page limits",
        "Widget limits",
        "Errors as first class citizens",
        "Errors as part of every mutation response"
      ],
      "title": "Dashboards API",
      "type": "docs",
      "tags": [
        "Dashboards",
        "Dashboards API"
      ],
      "external_id": "96f807b5a19101ec83176ceeb95b822eb8165896",
      "image": "",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/dashboards-api/",
      "published_at": "2021-12-30T20:46:58Z",
      "updated_at": "2021-08-08T11:47:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Dashboards API allows you to create and manage dashboards. Starting out with NerdGraph If you're new to NerdGraph and GraphQL, you may want to first read our Introduction to NerdGraph. If you’re already familiar with the dashboards API, you can read Create dashboards with NerdGraph. When using NerdGraph, it helps to understand that our dashboards are entities that report data from other entities, such as monitored apps, hosts and services. Find the NerdGraph API explorer at api.newrelic.com/graphiql. Operations We have defined a granular GraphQL API that lets you execute different dashboard operations depending on their goal and scope. Dashboard CRUD operations Operation GraphQL operation type Notes actor > entity() query Get dashboard operation. You can get all dashboard and widget data for a given dashboard entity GUID. dashboardCreate() mutation Create dashboard operation. You can create a dashboard attached to a specific account by specifying all its elements, from metadata to widget configuration. dashboardUpdate() mutation Update dashboard operation. You can update an existing dashboard given a dashboard entity GUID. You need to specify the complete, updated dashboard elements, from metadata to widget configuration. dashboardDelete() mutation Delete dashboard operation. You can delete an existing dashboard given a dashboard entity GUID. This operation executes a logical delete that lets you recover your dashboard. dashboardUndelete() mutation Undelete dashboard operation. You can recover a previously deleted dashboard given a dashboard entity GUID. Dashboard page operations Operation GraphQL operation type Notes dashboardUpdatePage() mutation Update dashboard page operation. You can update one page of an existing dashboard given a dashboard page entity GUID. You need to specify the complete, updated dashboard page elements, from metadata to widget configuration. dashboardUpdateWidgetsInPage() mutation Update widgets operation. You can update a set of existing widgets of a dashboard page given a dashboard page entity GUID. You need to specify the set of widgets to be updated and their complete configuration. dashboardAddWidgetsToPage() mutation Add widgets operation. You can add a set of new widgets to a dashboard page given a dashboard page entity GUID. You need to specify the set of new widgets and their complete configuration. Other operations Operation GraphQL operation type Notes dashboardCreateSnapshotUrl() mutation Create dashboard page snapshot operation. You can create a public URL for a given dashboard page entity GUID. The dashboard page can then be accessed in the form of a static snapshot in the resulting public URL. actor > dashboard > liveUrls() query List all live URLs operation. You can get the complete list of live URLs you have access to. A live URL is a mechanism that allows you to share dashboard pages and widgets publicly with up-to-date or live data. dashboardWidgetRevokeLiveUrl() mutation Revoke widget live URL operation. You can revoke a previously created live URL of a widget. As a result, the live URL will become unavailable to the public. Limits We have limited the values you can set to some of the dashboard properties. This allows us to keep dashboards in good shape while boosting their usability. Dashboard limits Limit Value Maximum number of pages in a dashboard 20 Maximum length of a dashboard name 255 Maximum length of a dashboard description 1024 Dashboard page limits Limit Value Maximum number of widgets in a dashboard page 100 Maximum length of a dashboard page name 255 Maximum length of a dashboard page description 1024 Widget limits Limit Value Maximum length of a widget title 255 Maximum number of entities linked to a widget 1 Maximum number of queries in a widget 20 Maximum layout column of a widget 12 Minimum layout column of a widget 1 Minimum layout row of a widget 1 Maximum layout width of a widget 12 Minimum layout width of a widget 1 Maximum layout height of a widget 32 Minimum layout height of a widget 1 Errors as first class citizens All dashboard mutations offer a way to ask for errors when being executed. This means that you can perform your dashboard mutations and check the response in order to detect expected potential issues. Every error has a type and a description to help you identify what’s the source of the problem. Errors as part of every mutation response mutation { dashboardMutation(guid: \"MY_EXISTING_DASHBOARD_GUID\") { mutationResult { result } errors { description type } } } Copy Keep in mind that these are expected errors that we are aware of in advance. You should also check for unexpected errors that will be returned in the standard GraphQL errors field.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 252.91876,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Dashboards</em> <em>API</em>",
        "sections": "<em>Dashboards</em> <em>API</em>",
        "tags": "<em>Dashboards</em> <em>API</em>",
        "body": "The <em>Dashboards</em> <em>API</em> allows you to create and manage <em>dashboards</em>. Starting out with <em>NerdGraph</em> If you&#x27;re new to <em>NerdGraph</em> and <em>Graph</em>QL, you may want to first read our Introduction to <em>NerdGraph</em>. If you’re already familiar with the <em>dashboards</em> <em>API</em>, you can read Create <em>dashboards</em> with <em>NerdGraph</em>. When using"
      },
      "id": "60dd3c8328ccbc8f1a71b46c"
    },
    {
      "sections": [
        "Use workloads",
        "Health",
        "Activity",
        "Owner",
        "Header",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-12-30T18:57:47Z",
      "updated_at": "2021-12-30T18:57:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are three main tabs (Health, Activity, and Owner) plus the header. Health The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. Activity The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here are the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. You can control which golden metrics are used to visualize your workload entities by using the golden metrics API. To learn more, watch this short video (approx. 4 minutes). Owner The Owner tab gives you information about the team responsible for the workload. It looks like this: It contains: The team responsible for the workload. You can include more than one team. The workload description. Share the mission of the workload, and the business logic it represents: Is it a web application? An API? A backend process? Fill in any details that are relevant to your team, or to other teams in your organization. Contact information. From the drop-down menu, choose how your team prefers to be contacted. Links to the most relevant resources to operate the workload. Here you can add links to runbooks, code repositories, productivity tools, or anything else related to the workload that you need at hand. Header The header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. You can create workloads that update dynamically by leveraging tags. To learn how, watch this short video (approx. 3 minutes). Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 252.4617,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>dashboards</em> to workloads",
        "body": " to filter the <em>dashboard</em> to a view that’s relevant for that workload. Select Save filter for this workload. Use the <em>API</em> You can query, create, and update workloads with our <em>NerdGraph</em> <em>API</em>."
      },
      "id": "603e81e8196a67c972a83db1"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts": [
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-12-30T06:11:17Z",
      "updated_at": "2021-12-25T14:30:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters Allowed characters: Characters must be UTF-8. When using NerdGraph to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. For APM agents, restart your service. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration, both methods require you to restart your service. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. And check out this short video on querying APM tags (3:20 minutes). Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 323.95352,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Use</em> tags to help organize and find your data",
        "sections": "<em>Use</em> tags to help organize and find your data",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " solution. Tip Tags were previously called labels in the <em>New</em> <em>Relic</em> UI. You may sometimes see labelin our code; for example, some of our APM agent config files <em>use</em> a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "Use workloads",
        "Health",
        "Activity",
        "Owner",
        "Header",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-12-30T18:57:47Z",
      "updated_at": "2021-12-30T18:57:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are three main tabs (Health, Activity, and Owner) plus the header. Health The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. Activity The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here are the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. You can control which golden metrics are used to visualize your workload entities by using the golden metrics API. To learn more, watch this short video (approx. 4 minutes). Owner The Owner tab gives you information about the team responsible for the workload. It looks like this: It contains: The team responsible for the workload. You can include more than one team. The workload description. Share the mission of the workload, and the business logic it represents: Is it a web application? An API? A backend process? Fill in any details that are relevant to your team, or to other teams in your organization. Contact information. From the drop-down menu, choose how your team prefers to be contacted. Links to the most relevant resources to operate the workload. Here you can add links to runbooks, code repositories, productivity tools, or anything else related to the workload that you need at hand. Header The header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. You can create workloads that update dynamically by leveraging tags. To learn how, watch this short video (approx. 3 minutes). Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 261.40454,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Use</em> workloads",
        "sections": "<em>Use</em> workloads",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " of entities depends on your organization structure and goals. <em>one</em>.newrelic.com &gt; Explorer &gt; Workloads &gt; Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can <em>use</em> <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "What is an entity in New Relic?",
        "What's an entity?",
        "Find and explore entities and entity data",
        "Tip",
        "Group and organize entities",
        "Customize entity data with entity synthesis",
        "Reserved attributes for synthesized entities",
        "Entity relationships",
        "Important",
        "Which relationships are created?",
        "Source: New Relic agent",
        "Source: Infrastructure",
        "Source: Synthetics monitor",
        "Source: Kubernetes",
        "External services",
        "Create relationships manually",
        "Some considerations",
        "Relationship types"
      ],
      "title": "What is an entity in New Relic?",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "52a3e08bc9103c717d27b153e4fd4f547d6ecc32",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-12-31T01:47:16Z",
      "updated_at": "2021-11-14T13:17:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic monitoring is built around the concept of entities. In this doc, you'll learn how we define entities, what you can do with them, and how you can create your own entities or groupings of entities. What's an entity? From a New Relic perspective, entity is purposefully a broad concept. An entity is anything that a) reports data to New Relic or that contains data that we have access to, and b) is something we've identified with a unique entity ID. For most entities, the ID is indicated by the attribute entityGuid. An entity can be any fundamental data-reporting component, like an application, a host, or a database service, but it can also refer to larger groupings of those components. For example, to monitor a data center, you could aggregate those hosts in New Relic to be a workload (a custom grouping of entities). That workload is, itself, also an entity. Also very important is the relationships between entities. Our behind-the-scenes relationship-mapping helps us understand how entities are connected, how they affect each other. And this allows us to give you the power to configure how any data you're bringing in is related to existing entities, or how it's related to other entities. Our focus on entities and their relationships is important because our goal is to give you practical information about your business-important entities, and not give you an unhelpfully huge stream of data from a huge list of monitored things. With more insight at the entity level, you can better monitor and troubleshoot complex, modern systems. Find and explore entities and entity data Tip You can create new entity types for monitoring any data source. Learn more about entity synthesis. Some tips for finding and understanding entity data: To find an entity's entityGuid and entityName and other metadata: from any list of monitored entities in the New Relic Explorer, click an entity's icon, and click See metadata and tags. For most entities, its GUID is reported as the attribute entityGuid. For workloads, it's workloadGuid. You can run NRQL queries to find entities by their GUID. To see connections between entities, you have several options: When viewing an entity in the UI, use the Related entities UI. Service maps. Distributed tracing. Our NerdGraph API. To group entities together, see Group entities. Customize entity definitions and relationships. To learn technical details about entity types, see our GitHub repo. In an entity type's definition file, you'll see information like: The domain: for example, APM, or Infra. Its type: for example, Application or AWSECSCONTAINERINSTANCE. Default tags. The entityExpirationTime: how long data from that entity lasts in the UI, which is different from database data retention. Group and organize entities You can place entities into groups that reflect business-important relationships in your organization. For example, you might group all entities related to a specific team or department, or related to a specific service. Or you might group multiple hosts together to reflect their grouping in a data center. To group your entities, see: Tag entities. Create workloads, which allow you to group business-important sets of entities. Create entities and customize entity data Customize entity data with entity synthesis If you have telemetry from any source that's not supported by New Relic out of the box, you can propose a mapping for it. Once approved, any telemetry received by New Relic that matches your definition file will be synthesized into an entity. To learn more: For reserved attributes and how entity relationships are defined, keep reading this doc. For how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Reserved attributes for synthesized entities These attributes are meant to be synthesized from the telemetry we receive. Do not set them unless you're aware of the implications and consequences. Attribute Description entity.guid Generally, you should not set this attribute field on your telemetry data. New Relic may add this field to ingested data to store a unique identifier for the entity associated with the data point. If telemetry arrives with the entity.guid attribute already present, then New Relic will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. One use case for passing this attribute is to associate ingested telemetry with an entity already created by New Relic. When the entity.guid attribute is sent, the value will override New Relic’s entity identification system (such as entity synthesis definitions) and instead will use the attribute as the data. entity.name This attribute shouldn't be put on ingested telemetry data unless you're trying to override the entity name that would have been selected by New Relic’s entity identification system. While New Relic won't change the value if it's already present on the data, New Relic may add the attribute to your data. Therefore invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. If this field is present on ingested telemetry, its value will be used to name the entity associated with the data point. This name will be used instead of the name selected by New Relic’s entity identification system (for example, entity synthesis definitions). Note that many entities use the name as part of their identification, so changing this field may result in the generation of a new entity. entity.type This attribute shouldn't be put on ingested telemetry data except for certain legacy cases where it's required to distinguish entity types. Passing this field may interfere with entity detection, particularly if unrecognized values are sent in this field. While New Relic won't change the value if already present on the data, the field is not guaranteed to provide unambiguous filtering of telemetry at query-time. Existing entity definitions already have overlapping values, and we recommend avoiding entity.type in favor of other fields for filtering telemetry queries. This field is used by New Relic, meaning that invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. To learn how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Entity relationships Connections between entities are automatically created by New Relic based on what we can infer from your telemetry. For example, when two services that communicate using HTTP are instrumented with New Relic, we infer a \"calls/called-by\" relationship between them. When viewing a specific entity in either the New Relic Explorer, Navigator, or Lookout, you can see its Related entities in the entity's mini overview. This gives a visualization of the various entities connected directly to the current entity. You can quickly view important metrics for these related entities and navigate from one entity to another, through all the connected parts of your stack. Tip Learn more about how entities are related with our NerdGraph API. When relationships are not automatically detected, you can manually create them using the \"Add/edit related entities\" link in Related entities. Important Currently, you can only manually create calls/called-by relationships between service entities. Tip To manage manual relationships, you need to have modify and delete capabilities on entity relationships. If you don’t see the edit relationships button, contact your account admin. Which relationships are created? These are the relationships created between entities: Source: New Relic agent Relationship source Relationship type Relationship target Why is the relationship created? Application instrumented with a New Relic agent CALLS Application instrumented with a New Relic agent Relationships between applications monitored by New Relic agents are reported using the DurationByCaller metric. The callee reports the metric. For example, the metric DurationByCaller/Mobile/100/1234/HTTP/all indicates that the caller is APPLICATION 1234 for account 100. Application instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent An application (caller) that calls a service (callee) monitored by New Relic creates a relationship that's reported by the caller using the ExternalApp metric. For example, the metric ExternalApp/dirac.vips.net/100#1234/all indicates that the callee is APPLICATION 1234 for account 100. The metric is reported if the callee successfully responds to the caller. Service instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent When a New Relic agent detects that a service (caller) calls another service (callee) instrumented by New Relic, the callee reports the metric ClientApplication. For example, the metric ClientApplication/100#1234/all indicates that the caller is APPLICATION 1234 for account 100. Service instrumented with a New Relic agent CALLS A datastore instance When an application calls a datastore instance it creates a relationship reported with the DatastoreInstance metric. For example, the metric Datastore/instance/MySQL/172.16.16.3/3306 indicates the datastore instance is vendor: MySQL, host: 172.16.16.3, port: 3306. This metric also supports the legacy datastore instance format Datastore/instance/MySQL/172.16.16.3:3306. Currently we cannot determine whether the datastore instance is instrumented by New Relic and has an entity associated to it. APM agent SERVES Browser agent This relationship is created when an APM agent injects the browser agent into a page. Workload entity CONTAINS Any entity When a workload is created or updated, relationships for each of the entities that belong to the workload are created. Because some workloads are “dynamic” (defined by tags), relationships are re-created every 5 minutes. This way entities can join or leave the workload. Source: Infrastructure Relationship source Relationship type Relationship target Why is the relationship created? Infrastructure host HOSTS Application This relationship is created when an application is running in one or more hosts, and the infra agent is running in those hosts. Infrastructure host HOSTS Container This relationship is created when containers are running in one or more hosts, and the host is instrumented with the infra agent. Source: Synthetics monitor Relationship source Relationship type Relationship target Why is the relationship created? Synthetics Monitor CALLS Browser agent This relationship is created when a synthetics monitor checks a page instrumented with the browser agent. Synthetics Monitor CALLS APM application Agent events that contain the attribute nr.syntheticsMonitorId have been described as synthetics monitors (the source) interacting with an APM application (the target). If the header exists and the APM application Id exists, a relationship is created between the monitor and the app. Source: Kubernetes Relationship source Relationship type Relationship target Why is the relationship created? Cluster CONTAINS Pod This relationship is created when a pod is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Deployment This relationship is created when a deployment is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS DaemonSet This relationship is created when a DaemonSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS StatefulSet This relationship is created when a StatefulSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Host This relationship is created when a host that's part of a cluster is instrumented with the New Relic Kubernetes integration. Deployment CONTAINS Pod This relationship is created when a deployment creates a pod in a cluster instrumented with the New Relic Kubernetes integration. DaemonSet CONTAINS Pod This relationship is created when a DaemonSet is created a pod in a cluster instrumented with the New Relic Kubernetes integration. StatefulSet CONTAINS Pod This relationship is created when a StatefulSet creates a pod in a cluster instrumented with the New Relic Kubernetes integration. Pod CONTAINS Container This relationship is created when a pod creates a container in a cluster instrumented with the New Relic Kubernetes integration. Host HOSTS Pod This relationship is created when a pod is running in a host that's part of a cluster instrumented with the New Relic Kubernetes integration. Container HOSTS Application This relationship is created when an application is running in docker, and the hosts where docker is running are instrumented by the the infra agent. External services Relationship source Relationship type Relationship target Why is the relationship created? External service CALLS External service When the relationship is created, the external service reports a span with its name on the service.name attribute and the name of the service that initiates the call in the parent.service.name attribute. Application IS External service A relationship between an application and an external service is created so that users can navigate between them using the related entities component. Browser application instrumented with a New Relic agent CALLS External service A browser application reports an Ajax/HostTransaction metric when calling an external service (URL). Example metric: Ajax/HostTransaction/api.segment.io:443/CallbackTime' Cluster CONTAINS External service When the relationship is created, the external service reports a span with the attribute k8s.cluster.name, the name of the cluster. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span. Pod HOSTS External service When the relationship is created, the external service reports a span with the following attributes: service.name: The name of the service. k8s.cluster.name: The name of the cluster. k8s.pod.name: The name of the pod that’s running the service. k8s.namespace.name: The namespace where the pod was created. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span. Create relationships manually You can create additional relationships using NerdGraph, our GraphQL API. Relationships can be created or replaced using the mutation entityRelationshipUserDefinedCreateOrReplace. As its name suggests, it allows you to create a relationship between two entities with a given type. If the relationship already exists between the two entities, it will be added again with the updated given values: the creation time and the creator user id: mutation { entityRelationshipUserDefinedCreateOrReplace( sourceEntityGuid: \"{SourceEntityGuid}\" targetEntityGuid: \"{TargetEntityGuid}\" type: BUILT_FROM ) { errors { message type } } } Copy Delete relationships using the mutation entityRelationshipUserDefinedDelete. source and target are mandatory, whereas type isn't. If the mutation its executed without any type, all the relationships between the two entities will be removed. mutation { entityRelationshipUserDefinedDelete( sourceEntityGuid: \"{SourceEntityGuid}\" targetEntityGuid: \"{TargetEntityGuid}\" type: BUILT_FROM ) { errors { message type } } } Copy Find information about fetching relationships in the relationships API tutorial. Some considerations Two entities can have multiple relationships, one for each relationship type. Two entities can hold a relationship IF they belong to the same trusted account. For each entity, you can manually define up to 2000 relationships. When the limit is reached, the API will return a LIMIT_EXCEEDED error. Each mutation can fail if you don't have access to one of the two entities (source/target). Relationship types provide additional information about how two entities are related. The supported relationship types are: Relationship types Type Description CALLS The relationship between one service or application calling another. Used to display upstream and downstream services. CONTAINS The relationship and hierarchical use cases common to modern and cloud infrastructure. For example, this could indicate that the HOST contains a container. HOSTS The relationship between an application or process and the system it runs on. SERVES The relationship between a back-end application and the browser application it returns in the response. is The relationship between an entity captured as a separate entity by another telemetry data source and the one you're currently viewing. CONNECTS_TO The source entity has a connection to the target entity. BUILT_FROM The target entity contains the code for the source entity.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.63048,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What is an entity in <em>New</em> <em>Relic</em>?",
        "sections": "What is an entity in <em>New</em> <em>Relic</em>?",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": ". If telemetry arrives with the entity.guid attribute already present, then <em>New</em> <em>Relic</em> will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. <em>One</em> <em>use</em> case for passing this attribute is to associate"
      },
      "id": "603ec160e7b9d295f72a07fc"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-lookout-monitor-your-estate-glance": [
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-12-30T06:11:17Z",
      "updated_at": "2021-12-25T14:30:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters Allowed characters: Characters must be UTF-8. When using NerdGraph to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. For APM agents, restart your service. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration, both methods require you to restart your service. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. And check out this short video on querying APM tags (3:20 minutes). Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 323.95352,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Use</em> tags to help organize and find your data",
        "sections": "<em>Use</em> tags to help organize and find your data",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " solution. Tip Tags were previously called labels in the <em>New</em> <em>Relic</em> UI. You may sometimes see labelin our code; for example, some of our APM agent config files <em>use</em> a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "Use workloads",
        "Health",
        "Activity",
        "Owner",
        "Header",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-12-30T18:57:47Z",
      "updated_at": "2021-12-30T18:57:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are three main tabs (Health, Activity, and Owner) plus the header. Health The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. Activity The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here are the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. You can control which golden metrics are used to visualize your workload entities by using the golden metrics API. To learn more, watch this short video (approx. 4 minutes). Owner The Owner tab gives you information about the team responsible for the workload. It looks like this: It contains: The team responsible for the workload. You can include more than one team. The workload description. Share the mission of the workload, and the business logic it represents: Is it a web application? An API? A backend process? Fill in any details that are relevant to your team, or to other teams in your organization. Contact information. From the drop-down menu, choose how your team prefers to be contacted. Links to the most relevant resources to operate the workload. Here you can add links to runbooks, code repositories, productivity tools, or anything else related to the workload that you need at hand. Header The header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. You can create workloads that update dynamically by leveraging tags. To learn how, watch this short video (approx. 3 minutes). Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 261.40454,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Use</em> workloads",
        "sections": "<em>Use</em> workloads",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " of entities depends on your organization structure and goals. <em>one</em>.newrelic.com &gt; Explorer &gt; Workloads &gt; Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can <em>use</em> <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "What is an entity in New Relic?",
        "What's an entity?",
        "Find and explore entities and entity data",
        "Tip",
        "Group and organize entities",
        "Customize entity data with entity synthesis",
        "Reserved attributes for synthesized entities",
        "Entity relationships",
        "Important",
        "Which relationships are created?",
        "Source: New Relic agent",
        "Source: Infrastructure",
        "Source: Synthetics monitor",
        "Source: Kubernetes",
        "External services",
        "Create relationships manually",
        "Some considerations",
        "Relationship types"
      ],
      "title": "What is an entity in New Relic?",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "52a3e08bc9103c717d27b153e4fd4f547d6ecc32",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-12-31T01:47:16Z",
      "updated_at": "2021-11-14T13:17:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic monitoring is built around the concept of entities. In this doc, you'll learn how we define entities, what you can do with them, and how you can create your own entities or groupings of entities. What's an entity? From a New Relic perspective, entity is purposefully a broad concept. An entity is anything that a) reports data to New Relic or that contains data that we have access to, and b) is something we've identified with a unique entity ID. For most entities, the ID is indicated by the attribute entityGuid. An entity can be any fundamental data-reporting component, like an application, a host, or a database service, but it can also refer to larger groupings of those components. For example, to monitor a data center, you could aggregate those hosts in New Relic to be a workload (a custom grouping of entities). That workload is, itself, also an entity. Also very important is the relationships between entities. Our behind-the-scenes relationship-mapping helps us understand how entities are connected, how they affect each other. And this allows us to give you the power to configure how any data you're bringing in is related to existing entities, or how it's related to other entities. Our focus on entities and their relationships is important because our goal is to give you practical information about your business-important entities, and not give you an unhelpfully huge stream of data from a huge list of monitored things. With more insight at the entity level, you can better monitor and troubleshoot complex, modern systems. Find and explore entities and entity data Tip You can create new entity types for monitoring any data source. Learn more about entity synthesis. Some tips for finding and understanding entity data: To find an entity's entityGuid and entityName and other metadata: from any list of monitored entities in the New Relic Explorer, click an entity's icon, and click See metadata and tags. For most entities, its GUID is reported as the attribute entityGuid. For workloads, it's workloadGuid. You can run NRQL queries to find entities by their GUID. To see connections between entities, you have several options: When viewing an entity in the UI, use the Related entities UI. Service maps. Distributed tracing. Our NerdGraph API. To group entities together, see Group entities. Customize entity definitions and relationships. To learn technical details about entity types, see our GitHub repo. In an entity type's definition file, you'll see information like: The domain: for example, APM, or Infra. Its type: for example, Application or AWSECSCONTAINERINSTANCE. Default tags. The entityExpirationTime: how long data from that entity lasts in the UI, which is different from database data retention. Group and organize entities You can place entities into groups that reflect business-important relationships in your organization. For example, you might group all entities related to a specific team or department, or related to a specific service. Or you might group multiple hosts together to reflect their grouping in a data center. To group your entities, see: Tag entities. Create workloads, which allow you to group business-important sets of entities. Create entities and customize entity data Customize entity data with entity synthesis If you have telemetry from any source that's not supported by New Relic out of the box, you can propose a mapping for it. Once approved, any telemetry received by New Relic that matches your definition file will be synthesized into an entity. To learn more: For reserved attributes and how entity relationships are defined, keep reading this doc. For how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Reserved attributes for synthesized entities These attributes are meant to be synthesized from the telemetry we receive. Do not set them unless you're aware of the implications and consequences. Attribute Description entity.guid Generally, you should not set this attribute field on your telemetry data. New Relic may add this field to ingested data to store a unique identifier for the entity associated with the data point. If telemetry arrives with the entity.guid attribute already present, then New Relic will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. One use case for passing this attribute is to associate ingested telemetry with an entity already created by New Relic. When the entity.guid attribute is sent, the value will override New Relic’s entity identification system (such as entity synthesis definitions) and instead will use the attribute as the data. entity.name This attribute shouldn't be put on ingested telemetry data unless you're trying to override the entity name that would have been selected by New Relic’s entity identification system. While New Relic won't change the value if it's already present on the data, New Relic may add the attribute to your data. Therefore invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. If this field is present on ingested telemetry, its value will be used to name the entity associated with the data point. This name will be used instead of the name selected by New Relic’s entity identification system (for example, entity synthesis definitions). Note that many entities use the name as part of their identification, so changing this field may result in the generation of a new entity. entity.type This attribute shouldn't be put on ingested telemetry data except for certain legacy cases where it's required to distinguish entity types. Passing this field may interfere with entity detection, particularly if unrecognized values are sent in this field. While New Relic won't change the value if already present on the data, the field is not guaranteed to provide unambiguous filtering of telemetry at query-time. Existing entity definitions already have overlapping values, and we recommend avoiding entity.type in favor of other fields for filtering telemetry queries. This field is used by New Relic, meaning that invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. To learn how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Entity relationships Connections between entities are automatically created by New Relic based on what we can infer from your telemetry. For example, when two services that communicate using HTTP are instrumented with New Relic, we infer a \"calls/called-by\" relationship between them. When viewing a specific entity in either the New Relic Explorer, Navigator, or Lookout, you can see its Related entities in the entity's mini overview. This gives a visualization of the various entities connected directly to the current entity. You can quickly view important metrics for these related entities and navigate from one entity to another, through all the connected parts of your stack. Tip Learn more about how entities are related with our NerdGraph API. When relationships are not automatically detected, you can manually create them using the \"Add/edit related entities\" link in Related entities. Important Currently, you can only manually create calls/called-by relationships between service entities. Tip To manage manual relationships, you need to have modify and delete capabilities on entity relationships. If you don’t see the edit relationships button, contact your account admin. Which relationships are created? These are the relationships created between entities: Source: New Relic agent Relationship source Relationship type Relationship target Why is the relationship created? Application instrumented with a New Relic agent CALLS Application instrumented with a New Relic agent Relationships between applications monitored by New Relic agents are reported using the DurationByCaller metric. The callee reports the metric. For example, the metric DurationByCaller/Mobile/100/1234/HTTP/all indicates that the caller is APPLICATION 1234 for account 100. Application instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent An application (caller) that calls a service (callee) monitored by New Relic creates a relationship that's reported by the caller using the ExternalApp metric. For example, the metric ExternalApp/dirac.vips.net/100#1234/all indicates that the callee is APPLICATION 1234 for account 100. The metric is reported if the callee successfully responds to the caller. Service instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent When a New Relic agent detects that a service (caller) calls another service (callee) instrumented by New Relic, the callee reports the metric ClientApplication. For example, the metric ClientApplication/100#1234/all indicates that the caller is APPLICATION 1234 for account 100. Service instrumented with a New Relic agent CALLS A datastore instance When an application calls a datastore instance it creates a relationship reported with the DatastoreInstance metric. For example, the metric Datastore/instance/MySQL/172.16.16.3/3306 indicates the datastore instance is vendor: MySQL, host: 172.16.16.3, port: 3306. This metric also supports the legacy datastore instance format Datastore/instance/MySQL/172.16.16.3:3306. Currently we cannot determine whether the datastore instance is instrumented by New Relic and has an entity associated to it. APM agent SERVES Browser agent This relationship is created when an APM agent injects the browser agent into a page. Workload entity CONTAINS Any entity When a workload is created or updated, relationships for each of the entities that belong to the workload are created. Because some workloads are “dynamic” (defined by tags), relationships are re-created every 5 minutes. This way entities can join or leave the workload. Source: Infrastructure Relationship source Relationship type Relationship target Why is the relationship created? Infrastructure host HOSTS Application This relationship is created when an application is running in one or more hosts, and the infra agent is running in those hosts. Infrastructure host HOSTS Container This relationship is created when containers are running in one or more hosts, and the host is instrumented with the infra agent. Source: Synthetics monitor Relationship source Relationship type Relationship target Why is the relationship created? Synthetics Monitor CALLS Browser agent This relationship is created when a synthetics monitor checks a page instrumented with the browser agent. Synthetics Monitor CALLS APM application Agent events that contain the attribute nr.syntheticsMonitorId have been described as synthetics monitors (the source) interacting with an APM application (the target). If the header exists and the APM application Id exists, a relationship is created between the monitor and the app. Source: Kubernetes Relationship source Relationship type Relationship target Why is the relationship created? Cluster CONTAINS Pod This relationship is created when a pod is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Deployment This relationship is created when a deployment is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS DaemonSet This relationship is created when a DaemonSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS StatefulSet This relationship is created when a StatefulSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Host This relationship is created when a host that's part of a cluster is instrumented with the New Relic Kubernetes integration. Deployment CONTAINS Pod This relationship is created when a deployment creates a pod in a cluster instrumented with the New Relic Kubernetes integration. DaemonSet CONTAINS Pod This relationship is created when a DaemonSet is created a pod in a cluster instrumented with the New Relic Kubernetes integration. StatefulSet CONTAINS Pod This relationship is created when a StatefulSet creates a pod in a cluster instrumented with the New Relic Kubernetes integration. Pod CONTAINS Container This relationship is created when a pod creates a container in a cluster instrumented with the New Relic Kubernetes integration. Host HOSTS Pod This relationship is created when a pod is running in a host that's part of a cluster instrumented with the New Relic Kubernetes integration. Container HOSTS Application This relationship is created when an application is running in docker, and the hosts where docker is running are instrumented by the the infra agent. External services Relationship source Relationship type Relationship target Why is the relationship created? External service CALLS External service When the relationship is created, the external service reports a span with its name on the service.name attribute and the name of the service that initiates the call in the parent.service.name attribute. Application IS External service A relationship between an application and an external service is created so that users can navigate between them using the related entities component. Browser application instrumented with a New Relic agent CALLS External service A browser application reports an Ajax/HostTransaction metric when calling an external service (URL). Example metric: Ajax/HostTransaction/api.segment.io:443/CallbackTime' Cluster CONTAINS External service When the relationship is created, the external service reports a span with the attribute k8s.cluster.name, the name of the cluster. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span. Pod HOSTS External service When the relationship is created, the external service reports a span with the following attributes: service.name: The name of the service. k8s.cluster.name: The name of the cluster. k8s.pod.name: The name of the pod that’s running the service. k8s.namespace.name: The namespace where the pod was created. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span. Create relationships manually You can create additional relationships using NerdGraph, our GraphQL API. Relationships can be created or replaced using the mutation entityRelationshipUserDefinedCreateOrReplace. As its name suggests, it allows you to create a relationship between two entities with a given type. If the relationship already exists between the two entities, it will be added again with the updated given values: the creation time and the creator user id: mutation { entityRelationshipUserDefinedCreateOrReplace( sourceEntityGuid: \"{SourceEntityGuid}\" targetEntityGuid: \"{TargetEntityGuid}\" type: BUILT_FROM ) { errors { message type } } } Copy Delete relationships using the mutation entityRelationshipUserDefinedDelete. source and target are mandatory, whereas type isn't. If the mutation its executed without any type, all the relationships between the two entities will be removed. mutation { entityRelationshipUserDefinedDelete( sourceEntityGuid: \"{SourceEntityGuid}\" targetEntityGuid: \"{TargetEntityGuid}\" type: BUILT_FROM ) { errors { message type } } } Copy Find information about fetching relationships in the relationships API tutorial. Some considerations Two entities can have multiple relationships, one for each relationship type. Two entities can hold a relationship IF they belong to the same trusted account. For each entity, you can manually define up to 2000 relationships. When the limit is reached, the API will return a LIMIT_EXCEEDED error. Each mutation can fail if you don't have access to one of the two entities (source/target). Relationship types provide additional information about how two entities are related. The supported relationship types are: Relationship types Type Description CALLS The relationship between one service or application calling another. Used to display upstream and downstream services. CONTAINS The relationship and hierarchical use cases common to modern and cloud infrastructure. For example, this could indicate that the HOST contains a container. HOSTS The relationship between an application or process and the system it runs on. SERVES The relationship between a back-end application and the browser application it returns in the response. is The relationship between an entity captured as a separate entity by another telemetry data source and the one you're currently viewing. CONNECTS_TO The source entity has a connection to the target entity. BUILT_FROM The target entity contains the code for the source entity.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.63048,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What is an entity in <em>New</em> <em>Relic</em>?",
        "sections": "What is an entity in <em>New</em> <em>Relic</em>?",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": ". If telemetry arrives with the entity.guid attribute already present, then <em>New</em> <em>Relic</em> will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. <em>One</em> <em>use</em> case for passing this attribute is to associate"
      },
      "id": "603ec160e7b9d295f72a07fc"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/core-concepts/transition-new-relic-one-insights": [
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-12-30T06:11:17Z",
      "updated_at": "2021-12-25T14:30:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters Allowed characters: Characters must be UTF-8. When using NerdGraph to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. For APM agents, restart your service. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration, both methods require you to restart your service. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. And check out this short video on querying APM tags (3:20 minutes). Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 323.95343,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Use</em> tags to help organize and find your data",
        "sections": "<em>Use</em> tags to help organize and find your data",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " solution. Tip Tags were previously called labels in the <em>New</em> <em>Relic</em> UI. You may sometimes see labelin our code; for example, some of our APM agent config files <em>use</em> a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "Use workloads",
        "Health",
        "Activity",
        "Owner",
        "Header",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-12-30T18:57:47Z",
      "updated_at": "2021-12-30T18:57:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are three main tabs (Health, Activity, and Owner) plus the header. Health The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. Activity The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here are the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. You can control which golden metrics are used to visualize your workload entities by using the golden metrics API. To learn more, watch this short video (approx. 4 minutes). Owner The Owner tab gives you information about the team responsible for the workload. It looks like this: It contains: The team responsible for the workload. You can include more than one team. The workload description. Share the mission of the workload, and the business logic it represents: Is it a web application? An API? A backend process? Fill in any details that are relevant to your team, or to other teams in your organization. Contact information. From the drop-down menu, choose how your team prefers to be contacted. Links to the most relevant resources to operate the workload. Here you can add links to runbooks, code repositories, productivity tools, or anything else related to the workload that you need at hand. Header The header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. You can create workloads that update dynamically by leveraging tags. To learn how, watch this short video (approx. 3 minutes). Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 261.40442,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Use</em> workloads",
        "sections": "<em>Use</em> workloads",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " of entities depends on your organization structure and goals. <em>one</em>.newrelic.com &gt; Explorer &gt; Workloads &gt; Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can <em>use</em> <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "What is an entity in New Relic?",
        "What's an entity?",
        "Find and explore entities and entity data",
        "Tip",
        "Group and organize entities",
        "Customize entity data with entity synthesis",
        "Reserved attributes for synthesized entities",
        "Entity relationships",
        "Important",
        "Which relationships are created?",
        "Source: New Relic agent",
        "Source: Infrastructure",
        "Source: Synthetics monitor",
        "Source: Kubernetes",
        "External services",
        "Create relationships manually",
        "Some considerations",
        "Relationship types"
      ],
      "title": "What is an entity in New Relic?",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "52a3e08bc9103c717d27b153e4fd4f547d6ecc32",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-12-31T01:47:16Z",
      "updated_at": "2021-11-14T13:17:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic monitoring is built around the concept of entities. In this doc, you'll learn how we define entities, what you can do with them, and how you can create your own entities or groupings of entities. What's an entity? From a New Relic perspective, entity is purposefully a broad concept. An entity is anything that a) reports data to New Relic or that contains data that we have access to, and b) is something we've identified with a unique entity ID. For most entities, the ID is indicated by the attribute entityGuid. An entity can be any fundamental data-reporting component, like an application, a host, or a database service, but it can also refer to larger groupings of those components. For example, to monitor a data center, you could aggregate those hosts in New Relic to be a workload (a custom grouping of entities). That workload is, itself, also an entity. Also very important is the relationships between entities. Our behind-the-scenes relationship-mapping helps us understand how entities are connected, how they affect each other. And this allows us to give you the power to configure how any data you're bringing in is related to existing entities, or how it's related to other entities. Our focus on entities and their relationships is important because our goal is to give you practical information about your business-important entities, and not give you an unhelpfully huge stream of data from a huge list of monitored things. With more insight at the entity level, you can better monitor and troubleshoot complex, modern systems. Find and explore entities and entity data Tip You can create new entity types for monitoring any data source. Learn more about entity synthesis. Some tips for finding and understanding entity data: To find an entity's entityGuid and entityName and other metadata: from any list of monitored entities in the New Relic Explorer, click an entity's icon, and click See metadata and tags. For most entities, its GUID is reported as the attribute entityGuid. For workloads, it's workloadGuid. You can run NRQL queries to find entities by their GUID. To see connections between entities, you have several options: When viewing an entity in the UI, use the Related entities UI. Service maps. Distributed tracing. Our NerdGraph API. To group entities together, see Group entities. Customize entity definitions and relationships. To learn technical details about entity types, see our GitHub repo. In an entity type's definition file, you'll see information like: The domain: for example, APM, or Infra. Its type: for example, Application or AWSECSCONTAINERINSTANCE. Default tags. The entityExpirationTime: how long data from that entity lasts in the UI, which is different from database data retention. Group and organize entities You can place entities into groups that reflect business-important relationships in your organization. For example, you might group all entities related to a specific team or department, or related to a specific service. Or you might group multiple hosts together to reflect their grouping in a data center. To group your entities, see: Tag entities. Create workloads, which allow you to group business-important sets of entities. Create entities and customize entity data Customize entity data with entity synthesis If you have telemetry from any source that's not supported by New Relic out of the box, you can propose a mapping for it. Once approved, any telemetry received by New Relic that matches your definition file will be synthesized into an entity. To learn more: For reserved attributes and how entity relationships are defined, keep reading this doc. For how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Reserved attributes for synthesized entities These attributes are meant to be synthesized from the telemetry we receive. Do not set them unless you're aware of the implications and consequences. Attribute Description entity.guid Generally, you should not set this attribute field on your telemetry data. New Relic may add this field to ingested data to store a unique identifier for the entity associated with the data point. If telemetry arrives with the entity.guid attribute already present, then New Relic will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. One use case for passing this attribute is to associate ingested telemetry with an entity already created by New Relic. When the entity.guid attribute is sent, the value will override New Relic’s entity identification system (such as entity synthesis definitions) and instead will use the attribute as the data. entity.name This attribute shouldn't be put on ingested telemetry data unless you're trying to override the entity name that would have been selected by New Relic’s entity identification system. While New Relic won't change the value if it's already present on the data, New Relic may add the attribute to your data. Therefore invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. If this field is present on ingested telemetry, its value will be used to name the entity associated with the data point. This name will be used instead of the name selected by New Relic’s entity identification system (for example, entity synthesis definitions). Note that many entities use the name as part of their identification, so changing this field may result in the generation of a new entity. entity.type This attribute shouldn't be put on ingested telemetry data except for certain legacy cases where it's required to distinguish entity types. Passing this field may interfere with entity detection, particularly if unrecognized values are sent in this field. While New Relic won't change the value if already present on the data, the field is not guaranteed to provide unambiguous filtering of telemetry at query-time. Existing entity definitions already have overlapping values, and we recommend avoiding entity.type in favor of other fields for filtering telemetry queries. This field is used by New Relic, meaning that invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. To learn how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Entity relationships Connections between entities are automatically created by New Relic based on what we can infer from your telemetry. For example, when two services that communicate using HTTP are instrumented with New Relic, we infer a \"calls/called-by\" relationship between them. When viewing a specific entity in either the New Relic Explorer, Navigator, or Lookout, you can see its Related entities in the entity's mini overview. This gives a visualization of the various entities connected directly to the current entity. You can quickly view important metrics for these related entities and navigate from one entity to another, through all the connected parts of your stack. Tip Learn more about how entities are related with our NerdGraph API. When relationships are not automatically detected, you can manually create them using the \"Add/edit related entities\" link in Related entities. Important Currently, you can only manually create calls/called-by relationships between service entities. Tip To manage manual relationships, you need to have modify and delete capabilities on entity relationships. If you don’t see the edit relationships button, contact your account admin. Which relationships are created? These are the relationships created between entities: Source: New Relic agent Relationship source Relationship type Relationship target Why is the relationship created? Application instrumented with a New Relic agent CALLS Application instrumented with a New Relic agent Relationships between applications monitored by New Relic agents are reported using the DurationByCaller metric. The callee reports the metric. For example, the metric DurationByCaller/Mobile/100/1234/HTTP/all indicates that the caller is APPLICATION 1234 for account 100. Application instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent An application (caller) that calls a service (callee) monitored by New Relic creates a relationship that's reported by the caller using the ExternalApp metric. For example, the metric ExternalApp/dirac.vips.net/100#1234/all indicates that the callee is APPLICATION 1234 for account 100. The metric is reported if the callee successfully responds to the caller. Service instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent When a New Relic agent detects that a service (caller) calls another service (callee) instrumented by New Relic, the callee reports the metric ClientApplication. For example, the metric ClientApplication/100#1234/all indicates that the caller is APPLICATION 1234 for account 100. Service instrumented with a New Relic agent CALLS A datastore instance When an application calls a datastore instance it creates a relationship reported with the DatastoreInstance metric. For example, the metric Datastore/instance/MySQL/172.16.16.3/3306 indicates the datastore instance is vendor: MySQL, host: 172.16.16.3, port: 3306. This metric also supports the legacy datastore instance format Datastore/instance/MySQL/172.16.16.3:3306. Currently we cannot determine whether the datastore instance is instrumented by New Relic and has an entity associated to it. APM agent SERVES Browser agent This relationship is created when an APM agent injects the browser agent into a page. Workload entity CONTAINS Any entity When a workload is created or updated, relationships for each of the entities that belong to the workload are created. Because some workloads are “dynamic” (defined by tags), relationships are re-created every 5 minutes. This way entities can join or leave the workload. Source: Infrastructure Relationship source Relationship type Relationship target Why is the relationship created? Infrastructure host HOSTS Application This relationship is created when an application is running in one or more hosts, and the infra agent is running in those hosts. Infrastructure host HOSTS Container This relationship is created when containers are running in one or more hosts, and the host is instrumented with the infra agent. Source: Synthetics monitor Relationship source Relationship type Relationship target Why is the relationship created? Synthetics Monitor CALLS Browser agent This relationship is created when a synthetics monitor checks a page instrumented with the browser agent. Synthetics Monitor CALLS APM application Agent events that contain the attribute nr.syntheticsMonitorId have been described as synthetics monitors (the source) interacting with an APM application (the target). If the header exists and the APM application Id exists, a relationship is created between the monitor and the app. Source: Kubernetes Relationship source Relationship type Relationship target Why is the relationship created? Cluster CONTAINS Pod This relationship is created when a pod is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Deployment This relationship is created when a deployment is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS DaemonSet This relationship is created when a DaemonSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS StatefulSet This relationship is created when a StatefulSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Host This relationship is created when a host that's part of a cluster is instrumented with the New Relic Kubernetes integration. Deployment CONTAINS Pod This relationship is created when a deployment creates a pod in a cluster instrumented with the New Relic Kubernetes integration. DaemonSet CONTAINS Pod This relationship is created when a DaemonSet is created a pod in a cluster instrumented with the New Relic Kubernetes integration. StatefulSet CONTAINS Pod This relationship is created when a StatefulSet creates a pod in a cluster instrumented with the New Relic Kubernetes integration. Pod CONTAINS Container This relationship is created when a pod creates a container in a cluster instrumented with the New Relic Kubernetes integration. Host HOSTS Pod This relationship is created when a pod is running in a host that's part of a cluster instrumented with the New Relic Kubernetes integration. Container HOSTS Application This relationship is created when an application is running in docker, and the hosts where docker is running are instrumented by the the infra agent. External services Relationship source Relationship type Relationship target Why is the relationship created? External service CALLS External service When the relationship is created, the external service reports a span with its name on the service.name attribute and the name of the service that initiates the call in the parent.service.name attribute. Application IS External service A relationship between an application and an external service is created so that users can navigate between them using the related entities component. Browser application instrumented with a New Relic agent CALLS External service A browser application reports an Ajax/HostTransaction metric when calling an external service (URL). Example metric: Ajax/HostTransaction/api.segment.io:443/CallbackTime' Cluster CONTAINS External service When the relationship is created, the external service reports a span with the attribute k8s.cluster.name, the name of the cluster. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span. Pod HOSTS External service When the relationship is created, the external service reports a span with the following attributes: service.name: The name of the service. k8s.cluster.name: The name of the cluster. k8s.pod.name: The name of the pod that’s running the service. k8s.namespace.name: The namespace where the pod was created. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span. Create relationships manually You can create additional relationships using NerdGraph, our GraphQL API. Relationships can be created or replaced using the mutation entityRelationshipUserDefinedCreateOrReplace. As its name suggests, it allows you to create a relationship between two entities with a given type. If the relationship already exists between the two entities, it will be added again with the updated given values: the creation time and the creator user id: mutation { entityRelationshipUserDefinedCreateOrReplace( sourceEntityGuid: \"{SourceEntityGuid}\" targetEntityGuid: \"{TargetEntityGuid}\" type: BUILT_FROM ) { errors { message type } } } Copy Delete relationships using the mutation entityRelationshipUserDefinedDelete. source and target are mandatory, whereas type isn't. If the mutation its executed without any type, all the relationships between the two entities will be removed. mutation { entityRelationshipUserDefinedDelete( sourceEntityGuid: \"{SourceEntityGuid}\" targetEntityGuid: \"{TargetEntityGuid}\" type: BUILT_FROM ) { errors { message type } } } Copy Find information about fetching relationships in the relationships API tutorial. Some considerations Two entities can have multiple relationships, one for each relationship type. Two entities can hold a relationship IF they belong to the same trusted account. For each entity, you can manually define up to 2000 relationships. When the limit is reached, the API will return a LIMIT_EXCEEDED error. Each mutation can fail if you don't have access to one of the two entities (source/target). Relationship types provide additional information about how two entities are related. The supported relationship types are: Relationship types Type Description CALLS The relationship between one service or application calling another. Used to display upstream and downstream services. CONTAINS The relationship and hierarchical use cases common to modern and cloud infrastructure. For example, this could indicate that the HOST contains a container. HOSTS The relationship between an application or process and the system it runs on. SERVES The relationship between a back-end application and the browser application it returns in the response. is The relationship between an entity captured as a separate entity by another telemetry data source and the one you're currently viewing. CONNECTS_TO The source entity has a connection to the target entity. BUILT_FROM The target entity contains the code for the source entity.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.63046,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What is an entity in <em>New</em> <em>Relic</em>?",
        "sections": "What is an entity in <em>New</em> <em>Relic</em>?",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": ". If telemetry arrives with the entity.guid attribute already present, then <em>New</em> <em>Relic</em> will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. <em>One</em> <em>use</em> case for passing this attribute is to associate"
      },
      "id": "603ec160e7b9d295f72a07fc"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data": [
    {
      "sections": [
        "Use workloads",
        "Health",
        "Activity",
        "Owner",
        "Header",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-12-30T18:57:47Z",
      "updated_at": "2021-12-30T18:57:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are three main tabs (Health, Activity, and Owner) plus the header. Health The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. Activity The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here are the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. You can control which golden metrics are used to visualize your workload entities by using the golden metrics API. To learn more, watch this short video (approx. 4 minutes). Owner The Owner tab gives you information about the team responsible for the workload. It looks like this: It contains: The team responsible for the workload. You can include more than one team. The workload description. Share the mission of the workload, and the business logic it represents: Is it a web application? An API? A backend process? Fill in any details that are relevant to your team, or to other teams in your organization. Contact information. From the drop-down menu, choose how your team prefers to be contacted. Links to the most relevant resources to operate the workload. Here you can add links to runbooks, code repositories, productivity tools, or anything else related to the workload that you need at hand. Header The header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. You can create workloads that update dynamically by leveraging tags. To learn how, watch this short video (approx. 3 minutes). Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 261.40442,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Use</em> workloads",
        "sections": "<em>Use</em> workloads",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " of entities depends on your organization structure and goals. <em>one</em>.newrelic.com &gt; Explorer &gt; Workloads &gt; Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can <em>use</em> <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "What is an entity in New Relic?",
        "What's an entity?",
        "Find and explore entities and entity data",
        "Tip",
        "Group and organize entities",
        "Customize entity data with entity synthesis",
        "Reserved attributes for synthesized entities",
        "Entity relationships",
        "Important",
        "Which relationships are created?",
        "Source: New Relic agent",
        "Source: Infrastructure",
        "Source: Synthetics monitor",
        "Source: Kubernetes",
        "External services",
        "Create relationships manually",
        "Some considerations",
        "Relationship types"
      ],
      "title": "What is an entity in New Relic?",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "52a3e08bc9103c717d27b153e4fd4f547d6ecc32",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-12-31T01:47:16Z",
      "updated_at": "2021-11-14T13:17:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic monitoring is built around the concept of entities. In this doc, you'll learn how we define entities, what you can do with them, and how you can create your own entities or groupings of entities. What's an entity? From a New Relic perspective, entity is purposefully a broad concept. An entity is anything that a) reports data to New Relic or that contains data that we have access to, and b) is something we've identified with a unique entity ID. For most entities, the ID is indicated by the attribute entityGuid. An entity can be any fundamental data-reporting component, like an application, a host, or a database service, but it can also refer to larger groupings of those components. For example, to monitor a data center, you could aggregate those hosts in New Relic to be a workload (a custom grouping of entities). That workload is, itself, also an entity. Also very important is the relationships between entities. Our behind-the-scenes relationship-mapping helps us understand how entities are connected, how they affect each other. And this allows us to give you the power to configure how any data you're bringing in is related to existing entities, or how it's related to other entities. Our focus on entities and their relationships is important because our goal is to give you practical information about your business-important entities, and not give you an unhelpfully huge stream of data from a huge list of monitored things. With more insight at the entity level, you can better monitor and troubleshoot complex, modern systems. Find and explore entities and entity data Tip You can create new entity types for monitoring any data source. Learn more about entity synthesis. Some tips for finding and understanding entity data: To find an entity's entityGuid and entityName and other metadata: from any list of monitored entities in the New Relic Explorer, click an entity's icon, and click See metadata and tags. For most entities, its GUID is reported as the attribute entityGuid. For workloads, it's workloadGuid. You can run NRQL queries to find entities by their GUID. To see connections between entities, you have several options: When viewing an entity in the UI, use the Related entities UI. Service maps. Distributed tracing. Our NerdGraph API. To group entities together, see Group entities. Customize entity definitions and relationships. To learn technical details about entity types, see our GitHub repo. In an entity type's definition file, you'll see information like: The domain: for example, APM, or Infra. Its type: for example, Application or AWSECSCONTAINERINSTANCE. Default tags. The entityExpirationTime: how long data from that entity lasts in the UI, which is different from database data retention. Group and organize entities You can place entities into groups that reflect business-important relationships in your organization. For example, you might group all entities related to a specific team or department, or related to a specific service. Or you might group multiple hosts together to reflect their grouping in a data center. To group your entities, see: Tag entities. Create workloads, which allow you to group business-important sets of entities. Create entities and customize entity data Customize entity data with entity synthesis If you have telemetry from any source that's not supported by New Relic out of the box, you can propose a mapping for it. Once approved, any telemetry received by New Relic that matches your definition file will be synthesized into an entity. To learn more: For reserved attributes and how entity relationships are defined, keep reading this doc. For how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Reserved attributes for synthesized entities These attributes are meant to be synthesized from the telemetry we receive. Do not set them unless you're aware of the implications and consequences. Attribute Description entity.guid Generally, you should not set this attribute field on your telemetry data. New Relic may add this field to ingested data to store a unique identifier for the entity associated with the data point. If telemetry arrives with the entity.guid attribute already present, then New Relic will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. One use case for passing this attribute is to associate ingested telemetry with an entity already created by New Relic. When the entity.guid attribute is sent, the value will override New Relic’s entity identification system (such as entity synthesis definitions) and instead will use the attribute as the data. entity.name This attribute shouldn't be put on ingested telemetry data unless you're trying to override the entity name that would have been selected by New Relic’s entity identification system. While New Relic won't change the value if it's already present on the data, New Relic may add the attribute to your data. Therefore invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. If this field is present on ingested telemetry, its value will be used to name the entity associated with the data point. This name will be used instead of the name selected by New Relic’s entity identification system (for example, entity synthesis definitions). Note that many entities use the name as part of their identification, so changing this field may result in the generation of a new entity. entity.type This attribute shouldn't be put on ingested telemetry data except for certain legacy cases where it's required to distinguish entity types. Passing this field may interfere with entity detection, particularly if unrecognized values are sent in this field. While New Relic won't change the value if already present on the data, the field is not guaranteed to provide unambiguous filtering of telemetry at query-time. Existing entity definitions already have overlapping values, and we recommend avoiding entity.type in favor of other fields for filtering telemetry queries. This field is used by New Relic, meaning that invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. To learn how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Entity relationships Connections between entities are automatically created by New Relic based on what we can infer from your telemetry. For example, when two services that communicate using HTTP are instrumented with New Relic, we infer a \"calls/called-by\" relationship between them. When viewing a specific entity in either the New Relic Explorer, Navigator, or Lookout, you can see its Related entities in the entity's mini overview. This gives a visualization of the various entities connected directly to the current entity. You can quickly view important metrics for these related entities and navigate from one entity to another, through all the connected parts of your stack. Tip Learn more about how entities are related with our NerdGraph API. When relationships are not automatically detected, you can manually create them using the \"Add/edit related entities\" link in Related entities. Important Currently, you can only manually create calls/called-by relationships between service entities. Tip To manage manual relationships, you need to have modify and delete capabilities on entity relationships. If you don’t see the edit relationships button, contact your account admin. Which relationships are created? These are the relationships created between entities: Source: New Relic agent Relationship source Relationship type Relationship target Why is the relationship created? Application instrumented with a New Relic agent CALLS Application instrumented with a New Relic agent Relationships between applications monitored by New Relic agents are reported using the DurationByCaller metric. The callee reports the metric. For example, the metric DurationByCaller/Mobile/100/1234/HTTP/all indicates that the caller is APPLICATION 1234 for account 100. Application instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent An application (caller) that calls a service (callee) monitored by New Relic creates a relationship that's reported by the caller using the ExternalApp metric. For example, the metric ExternalApp/dirac.vips.net/100#1234/all indicates that the callee is APPLICATION 1234 for account 100. The metric is reported if the callee successfully responds to the caller. Service instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent When a New Relic agent detects that a service (caller) calls another service (callee) instrumented by New Relic, the callee reports the metric ClientApplication. For example, the metric ClientApplication/100#1234/all indicates that the caller is APPLICATION 1234 for account 100. Service instrumented with a New Relic agent CALLS A datastore instance When an application calls a datastore instance it creates a relationship reported with the DatastoreInstance metric. For example, the metric Datastore/instance/MySQL/172.16.16.3/3306 indicates the datastore instance is vendor: MySQL, host: 172.16.16.3, port: 3306. This metric also supports the legacy datastore instance format Datastore/instance/MySQL/172.16.16.3:3306. Currently we cannot determine whether the datastore instance is instrumented by New Relic and has an entity associated to it. APM agent SERVES Browser agent This relationship is created when an APM agent injects the browser agent into a page. Workload entity CONTAINS Any entity When a workload is created or updated, relationships for each of the entities that belong to the workload are created. Because some workloads are “dynamic” (defined by tags), relationships are re-created every 5 minutes. This way entities can join or leave the workload. Source: Infrastructure Relationship source Relationship type Relationship target Why is the relationship created? Infrastructure host HOSTS Application This relationship is created when an application is running in one or more hosts, and the infra agent is running in those hosts. Infrastructure host HOSTS Container This relationship is created when containers are running in one or more hosts, and the host is instrumented with the infra agent. Source: Synthetics monitor Relationship source Relationship type Relationship target Why is the relationship created? Synthetics Monitor CALLS Browser agent This relationship is created when a synthetics monitor checks a page instrumented with the browser agent. Synthetics Monitor CALLS APM application Agent events that contain the attribute nr.syntheticsMonitorId have been described as synthetics monitors (the source) interacting with an APM application (the target). If the header exists and the APM application Id exists, a relationship is created between the monitor and the app. Source: Kubernetes Relationship source Relationship type Relationship target Why is the relationship created? Cluster CONTAINS Pod This relationship is created when a pod is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Deployment This relationship is created when a deployment is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS DaemonSet This relationship is created when a DaemonSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS StatefulSet This relationship is created when a StatefulSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Host This relationship is created when a host that's part of a cluster is instrumented with the New Relic Kubernetes integration. Deployment CONTAINS Pod This relationship is created when a deployment creates a pod in a cluster instrumented with the New Relic Kubernetes integration. DaemonSet CONTAINS Pod This relationship is created when a DaemonSet is created a pod in a cluster instrumented with the New Relic Kubernetes integration. StatefulSet CONTAINS Pod This relationship is created when a StatefulSet creates a pod in a cluster instrumented with the New Relic Kubernetes integration. Pod CONTAINS Container This relationship is created when a pod creates a container in a cluster instrumented with the New Relic Kubernetes integration. Host HOSTS Pod This relationship is created when a pod is running in a host that's part of a cluster instrumented with the New Relic Kubernetes integration. Container HOSTS Application This relationship is created when an application is running in docker, and the hosts where docker is running are instrumented by the the infra agent. External services Relationship source Relationship type Relationship target Why is the relationship created? External service CALLS External service When the relationship is created, the external service reports a span with its name on the service.name attribute and the name of the service that initiates the call in the parent.service.name attribute. Application IS External service A relationship between an application and an external service is created so that users can navigate between them using the related entities component. Browser application instrumented with a New Relic agent CALLS External service A browser application reports an Ajax/HostTransaction metric when calling an external service (URL). Example metric: Ajax/HostTransaction/api.segment.io:443/CallbackTime' Cluster CONTAINS External service When the relationship is created, the external service reports a span with the attribute k8s.cluster.name, the name of the cluster. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span. Pod HOSTS External service When the relationship is created, the external service reports a span with the following attributes: service.name: The name of the service. k8s.cluster.name: The name of the cluster. k8s.pod.name: The name of the pod that’s running the service. k8s.namespace.name: The namespace where the pod was created. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span. Create relationships manually You can create additional relationships using NerdGraph, our GraphQL API. Relationships can be created or replaced using the mutation entityRelationshipUserDefinedCreateOrReplace. As its name suggests, it allows you to create a relationship between two entities with a given type. If the relationship already exists between the two entities, it will be added again with the updated given values: the creation time and the creator user id: mutation { entityRelationshipUserDefinedCreateOrReplace( sourceEntityGuid: \"{SourceEntityGuid}\" targetEntityGuid: \"{TargetEntityGuid}\" type: BUILT_FROM ) { errors { message type } } } Copy Delete relationships using the mutation entityRelationshipUserDefinedDelete. source and target are mandatory, whereas type isn't. If the mutation its executed without any type, all the relationships between the two entities will be removed. mutation { entityRelationshipUserDefinedDelete( sourceEntityGuid: \"{SourceEntityGuid}\" targetEntityGuid: \"{TargetEntityGuid}\" type: BUILT_FROM ) { errors { message type } } } Copy Find information about fetching relationships in the relationships API tutorial. Some considerations Two entities can have multiple relationships, one for each relationship type. Two entities can hold a relationship IF they belong to the same trusted account. For each entity, you can manually define up to 2000 relationships. When the limit is reached, the API will return a LIMIT_EXCEEDED error. Each mutation can fail if you don't have access to one of the two entities (source/target). Relationship types provide additional information about how two entities are related. The supported relationship types are: Relationship types Type Description CALLS The relationship between one service or application calling another. Used to display upstream and downstream services. CONTAINS The relationship and hierarchical use cases common to modern and cloud infrastructure. For example, this could indicate that the HOST contains a container. HOSTS The relationship between an application or process and the system it runs on. SERVES The relationship between a back-end application and the browser application it returns in the response. is The relationship between an entity captured as a separate entity by another telemetry data source and the one you're currently viewing. CONNECTS_TO The source entity has a connection to the target entity. BUILT_FROM The target entity contains the code for the source entity.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.63046,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What is an entity in <em>New</em> <em>Relic</em>?",
        "sections": "What is an entity in <em>New</em> <em>Relic</em>?",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": ". If telemetry arrives with the entity.guid attribute already present, then <em>New</em> <em>Relic</em> will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. <em>One</em> <em>use</em> case for passing this attribute is to associate"
      },
      "id": "603ec160e7b9d295f72a07fc"
    },
    {
      "sections": [
        "New Relic Lookout: Monitor your estate at a glance",
        "Why it matters",
        "Requirements",
        "Get started with New Relic Lookout",
        "Circle visualization and table view",
        "Abnormal golden signals",
        "Instant search",
        "Change view",
        "Drill down into the details",
        "Performance tab",
        "Abnormal History tab",
        "Correlations tab",
        "Profile tab",
        "Traces tab",
        "Create a custom view",
        "Query: Compare the last 15 minutes to the same time 1 day ago",
        "Query: Compare a specific time range to the same range a month ago",
        "Example: Unusual increases in error count"
      ],
      "title": "New Relic Lookout: Monitor your estate at a glance",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "9193dcc8851c185ff5d96f6f93ab412bd1be69e9",
      "image": "https://docs.newrelic.com/static/178b37068bad2a68cff027c8bdcf663a/c1b63/lookout-intro.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-lookout-monitor-your-estate-glance/",
      "published_at": "2021-12-30T06:11:17Z",
      "updated_at": "2021-08-21T09:27:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Lookout provides visibility into your entire estate. It doesn't require any configuration — you can query anything in your estate that matters to you right now and understand your system as a whole, or dive deep into causes and effects, so you can quickly get the data you need to take action. Know exactly where to focus your attention with New Relic Lookout. The brighter the color, the more severe the change, and the bigger the size, the bigger the scale. Then dig deeper with correlations and abnormal history to see how it impacts your whole system—no configuration needed. Why it matters New Relic Lookout helps software teams of any size discover potential issues before they have an impact. Fill gaps in monitoring with full coverage out-of-the-box, no configuration or setup required. Immediately see anything deviating from normal across your entire estate. Proactively spot emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in New Relic database (NRDB), including third-party, open, and custom data. Launch into other areas of New Relic One for deeper understanding Requirements New Relic Lookout requires Pro or Enterprise edition. If you are on Standard edition, you can still use the New Relic Lookout view in the New Relic Explorer. If you want to see data spanning 13-months, correlations, profiles, traces, and other details, you must upgrade to a higher edition. Get started with New Relic Lookout To access New Relic Lookout, click the Apps button in New Relic One and locate the New Relic Lookout launcher. You can also access New Relic Lookout directly from the New Relic One header bar, via the More dropdown. Enablement of key service performance indicator data is required for New Relic Lookout to provide value from the data you already have. The default view provides insight into three key Service performance indicators broken down by application: throughput, response time, and errors. These metrics are analyzed to show how the data has behaved during the last five minutes compared to the prior hour. one.newrelic.com > Apps > New Relic Lookout: Anything that significantly deviates from the trend is automatically discovered by New Relic Lookout, which doesn't require any configuration. Circle visualization and table view Each application (or other facet) is represented by a circle. The size of the circles indicate the magnitude of the signal for that application and the color indicates whether the value has significantly decreased or increased in the last five minutes, based on the standard deviation of the prior hour (default evaluation and comparison time windows.) Please note that the type of signal is important when interpreting your results. When you first look at the legend below, you might be tempted to interpret yellow as good and dark purple as bad, but that is not always the case. Here are some examples: In the APM/services golden signals, a dark yellow circle in Throughput might signify that something bad has occurred and led to a drop in traffic. At the same time, a dark purple circle might also be concerning due to unexpected load. Both are significant findings worth exploring. In browser golden signals, a dark purple circle in Page Views might be great, as you are seeing more traffic to your site! With errors golden signals (in all entity types), a large circle, even if gray (not deviating from normal volume), is worth exploring because a high count of errors in your system is important to investigate. The legend allows you to change the colors used to highlight deviating services To change the color palette, click the gear icon by the low-high color legend. This allows you to change the colors used to highlight deviating services. To get a table view of the same data, click the toggle on the right. You can also hover over each color to filter the view by degree lower or higher deviance. Abnormal golden signals On the right, New Relic Lookout displays the most significantly deviating applications (or other facet) in a side panel, weighted by both the magnitude of the performance indicators and the scale of their deviations. Details include the name of the key performance indicator, their magnitude during the recent time window, and the difference between the averages from one time compared to the other. Instant search Click the magnifying glass icon in the side panel to open a search box. Typing into the search box filters the circles, table, and abnormal signals to applications (or other facets) that contain the text. This is a good way to quickly zoom to various subsystems. New Relic Lookout doesn't rerun the analysis when using the instant search. Change view Click the Change View button on the right side panel. The panel that appears shows you all the entity-specific golden signals you can toggle between out of the box. By choosing the Browser Golden Signal or other views, you can change from the default view. Each new view will have the golden signals appropriate for that entity type. Drill down into the details To analyze an application or facet, click a circle, table row, or abnormal golden signal. The details panel shows the degree of deviation of the performance indicator, a link to the affected entity, and recent alert and deployment activity for that entity, when available. There’s also an indication of whether the selected evaluation time period would be abnormal or not in reference to other comparison time windows, such as the same time yesterday or the same time last week. This allows you to quickly see if the abnormal behavior is odd in general, or just based on the comparison time window. Performance tab The default tab shows charts for other key performance indicators for the selected application or facet. The charts compare the two time windows being analyzed. You can click their titles to rerun the analysis, focusing on the selected key performance indicator. When the target is a New Relic One application, we show the top transactions, error classes, external services, and database operations, alongside links to the relevant New Relic One features. Abnormal History tab This section analyzes past performance of the selected signal and calls out any time periods with notable abnormalities. Each card represents an abnormal time window and can be clicked for more details. The charts will display any relevant violations and deployments in New Relic. Correlations tab New Relic Lookout can find other signals that began behaving differently around the same time as the selected signal for that entity type. Clicking the name of the signal reruns the analysis, focusing on that key performance indicator. The chart titles link to New Relic One when there’s an associated entity in your account. Note that correlations currently do not analyze across accounts. The correlated signals displayed are for others in the account of the original application you are viewing. This helps focus the data on correlations that are more likely related to your issue. Profile tab Based on the same technology as New Relic’s error profiles, this tab compares the last five minutes to the prior hour by default (or whatever time windows you’ve selected with query editing) and surfaces any attributes that have significantly different distributions in the events being targeted by the selected signal. For example, if a custom attribute indicated that a recent throughput spike came from one user, that would surface highly in Profiles if most of the traffic usually comes from many users. Traces tab If the entity has distributed traces configured and available in the selected evaluated time window, the Traces section is enabled. Each card shows a summary of a trace and can be clicked for details. The Explore all traces links to the distributed traces application, filtered to the selected entity. Create a custom view To target signals and time windows beyond the default values, click the Change view button and select Custom view. To create your own view: Select the account or subaccount. Select the data type (metrics or events). Different functionality is available depending on the type. In View a chart with, select the metric or event you are interested in. Default is golden signals (throughput, response time, and errors). You can also build custom queries (filters) to target a signal that isn't on the list. In Facet by, select what the circles represent. Default is appName, but you can also choose host or any other facetable attribute available for the signal you’ve selected. If you plan to save/favorite this new view, provide a name in the Name your view box. Keep in mind that you can edit this view at any time using the pencil icon. The default time windows analyzed by New Relic Lookout are the last five minutes compared to the hour before. Use the time controls (View data from and Compare data to) to target other time windows. one.newrelic.com > Apps > New Relic Lookout: All event and metric data in the New Relic database can be queried using the Edit query feature. Click Analyze to begin analyzing the signal you’ve selected. You can also create your own query: Create your query. This query is comparing data from the past thirty minutes to data from the same range a day ago. Change from Basic to Advanced after clicking the Custom view button. Select the data type (metrics or events). Different functionality is available depending on the type. Enter your query using NRQL. Please note that not all NRQL features are available in the Lookout Advanced query feature. By default, the system will run this query using the last five minutes of data compared to the previous hour. Some examples of the syntax for changing the comparison and evaluation time windows are below. Click Analyze to begin analyzing the signal you’ve selected. Query: Compare the last 15 minutes to the same time 1 day ago Please note that the UNTIL NOW portion is required here unlike in standard NRQL. Without the UNTIL NOW added, the system will query a 5 minute slice of data starting 15 minutes ago SINCE 15 minutes AGO UNTIL NOW COMPARE WITH 1 day ago Copy Query: Compare a specific time range to the same range a month ago SINCE '2021-03-07 07:00:00-0500' UNTIL '2021-03-08 07:00:00-0500' COMPARE WITH 1 month ago Copy Or: SINCE 'today at midnight' UNTIL 'now' COMPARE WITH 1 MONTH AGO Copy Example: Unusual increases in error count The default view of New Relic Lookout shows application status across your estate, comparing the last five minutes to the hour before. Under regular operation, most large systems may have a handful of abnormalities, but usually most things will indicate normal behavior. Suddenly, several circles begin to change to red under the Errors section. This indicates that several applications are experiencing unusual increases in error count. It may be that one or two circles for important systems are red, and perhaps much larger than they usually appear. Clicking one of these can provide more information on what is happening. You might see that the error rate is substantially elevated, even thousands of percent higher than normal. To troubleshoot this issue, here's what you might discover in the New Relic Lookout tabs: Performance would show you data about other signals, illuminating the characteristics of the change in system dynamics. Correlations would surface other applications that are affected and how, as well as opportunities to pivot to other applications that may be closer to the underlying causes. Traces, in turn, would show distributed traces, which can provide specific examples of traffic running through those systems. Abnormal history would show other times in the past week with elevated errors, showing whether or not this problem happens regularly, such as every day at the same time or whenever there is a deployment. Profiles might show that all or most of the new errors share common properties, such as all being isolated to just one region/account/user. Combining the information from these sections, not only can you get a sense of what is going on, but also where to focus actions to resolve the problem.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.48643,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "sections": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in <em>New</em> <em>Relic</em> database (NRDB), including third-party, open, and custom data. Launch into other areas of <em>New</em> <em>Relic</em> <em>One</em> for deeper"
      },
      "id": "603e821e64441f5a444e8845"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic": [
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-12-30T06:11:17Z",
      "updated_at": "2021-12-25T14:30:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters Allowed characters: Characters must be UTF-8. When using NerdGraph to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. For APM agents, restart your service. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration, both methods require you to restart your service. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. And check out this short video on querying APM tags (3:20 minutes). Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 323.95343,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Use</em> tags to help organize and find your data",
        "sections": "<em>Use</em> tags to help organize and find your data",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " solution. Tip Tags were previously called labels in the <em>New</em> <em>Relic</em> UI. You may sometimes see labelin our code; for example, some of our APM agent config files <em>use</em> a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "Use workloads",
        "Health",
        "Activity",
        "Owner",
        "Header",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-12-30T18:57:47Z",
      "updated_at": "2021-12-30T18:57:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are three main tabs (Health, Activity, and Owner) plus the header. Health The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. Activity The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here are the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. You can control which golden metrics are used to visualize your workload entities by using the golden metrics API. To learn more, watch this short video (approx. 4 minutes). Owner The Owner tab gives you information about the team responsible for the workload. It looks like this: It contains: The team responsible for the workload. You can include more than one team. The workload description. Share the mission of the workload, and the business logic it represents: Is it a web application? An API? A backend process? Fill in any details that are relevant to your team, or to other teams in your organization. Contact information. From the drop-down menu, choose how your team prefers to be contacted. Links to the most relevant resources to operate the workload. Here you can add links to runbooks, code repositories, productivity tools, or anything else related to the workload that you need at hand. Header The header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. You can create workloads that update dynamically by leveraging tags. To learn how, watch this short video (approx. 3 minutes). Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 261.40442,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Use</em> workloads",
        "sections": "<em>Use</em> workloads",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " of entities depends on your organization structure and goals. <em>one</em>.newrelic.com &gt; Explorer &gt; Workloads &gt; Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can <em>use</em> <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "New Relic Lookout: Monitor your estate at a glance",
        "Why it matters",
        "Requirements",
        "Get started with New Relic Lookout",
        "Circle visualization and table view",
        "Abnormal golden signals",
        "Instant search",
        "Change view",
        "Drill down into the details",
        "Performance tab",
        "Abnormal History tab",
        "Correlations tab",
        "Profile tab",
        "Traces tab",
        "Create a custom view",
        "Query: Compare the last 15 minutes to the same time 1 day ago",
        "Query: Compare a specific time range to the same range a month ago",
        "Example: Unusual increases in error count"
      ],
      "title": "New Relic Lookout: Monitor your estate at a glance",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "9193dcc8851c185ff5d96f6f93ab412bd1be69e9",
      "image": "https://docs.newrelic.com/static/178b37068bad2a68cff027c8bdcf663a/c1b63/lookout-intro.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-lookout-monitor-your-estate-glance/",
      "published_at": "2021-12-30T06:11:17Z",
      "updated_at": "2021-08-21T09:27:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Lookout provides visibility into your entire estate. It doesn't require any configuration — you can query anything in your estate that matters to you right now and understand your system as a whole, or dive deep into causes and effects, so you can quickly get the data you need to take action. Know exactly where to focus your attention with New Relic Lookout. The brighter the color, the more severe the change, and the bigger the size, the bigger the scale. Then dig deeper with correlations and abnormal history to see how it impacts your whole system—no configuration needed. Why it matters New Relic Lookout helps software teams of any size discover potential issues before they have an impact. Fill gaps in monitoring with full coverage out-of-the-box, no configuration or setup required. Immediately see anything deviating from normal across your entire estate. Proactively spot emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in New Relic database (NRDB), including third-party, open, and custom data. Launch into other areas of New Relic One for deeper understanding Requirements New Relic Lookout requires Pro or Enterprise edition. If you are on Standard edition, you can still use the New Relic Lookout view in the New Relic Explorer. If you want to see data spanning 13-months, correlations, profiles, traces, and other details, you must upgrade to a higher edition. Get started with New Relic Lookout To access New Relic Lookout, click the Apps button in New Relic One and locate the New Relic Lookout launcher. You can also access New Relic Lookout directly from the New Relic One header bar, via the More dropdown. Enablement of key service performance indicator data is required for New Relic Lookout to provide value from the data you already have. The default view provides insight into three key Service performance indicators broken down by application: throughput, response time, and errors. These metrics are analyzed to show how the data has behaved during the last five minutes compared to the prior hour. one.newrelic.com > Apps > New Relic Lookout: Anything that significantly deviates from the trend is automatically discovered by New Relic Lookout, which doesn't require any configuration. Circle visualization and table view Each application (or other facet) is represented by a circle. The size of the circles indicate the magnitude of the signal for that application and the color indicates whether the value has significantly decreased or increased in the last five minutes, based on the standard deviation of the prior hour (default evaluation and comparison time windows.) Please note that the type of signal is important when interpreting your results. When you first look at the legend below, you might be tempted to interpret yellow as good and dark purple as bad, but that is not always the case. Here are some examples: In the APM/services golden signals, a dark yellow circle in Throughput might signify that something bad has occurred and led to a drop in traffic. At the same time, a dark purple circle might also be concerning due to unexpected load. Both are significant findings worth exploring. In browser golden signals, a dark purple circle in Page Views might be great, as you are seeing more traffic to your site! With errors golden signals (in all entity types), a large circle, even if gray (not deviating from normal volume), is worth exploring because a high count of errors in your system is important to investigate. The legend allows you to change the colors used to highlight deviating services To change the color palette, click the gear icon by the low-high color legend. This allows you to change the colors used to highlight deviating services. To get a table view of the same data, click the toggle on the right. You can also hover over each color to filter the view by degree lower or higher deviance. Abnormal golden signals On the right, New Relic Lookout displays the most significantly deviating applications (or other facet) in a side panel, weighted by both the magnitude of the performance indicators and the scale of their deviations. Details include the name of the key performance indicator, their magnitude during the recent time window, and the difference between the averages from one time compared to the other. Instant search Click the magnifying glass icon in the side panel to open a search box. Typing into the search box filters the circles, table, and abnormal signals to applications (or other facets) that contain the text. This is a good way to quickly zoom to various subsystems. New Relic Lookout doesn't rerun the analysis when using the instant search. Change view Click the Change View button on the right side panel. The panel that appears shows you all the entity-specific golden signals you can toggle between out of the box. By choosing the Browser Golden Signal or other views, you can change from the default view. Each new view will have the golden signals appropriate for that entity type. Drill down into the details To analyze an application or facet, click a circle, table row, or abnormal golden signal. The details panel shows the degree of deviation of the performance indicator, a link to the affected entity, and recent alert and deployment activity for that entity, when available. There’s also an indication of whether the selected evaluation time period would be abnormal or not in reference to other comparison time windows, such as the same time yesterday or the same time last week. This allows you to quickly see if the abnormal behavior is odd in general, or just based on the comparison time window. Performance tab The default tab shows charts for other key performance indicators for the selected application or facet. The charts compare the two time windows being analyzed. You can click their titles to rerun the analysis, focusing on the selected key performance indicator. When the target is a New Relic One application, we show the top transactions, error classes, external services, and database operations, alongside links to the relevant New Relic One features. Abnormal History tab This section analyzes past performance of the selected signal and calls out any time periods with notable abnormalities. Each card represents an abnormal time window and can be clicked for more details. The charts will display any relevant violations and deployments in New Relic. Correlations tab New Relic Lookout can find other signals that began behaving differently around the same time as the selected signal for that entity type. Clicking the name of the signal reruns the analysis, focusing on that key performance indicator. The chart titles link to New Relic One when there’s an associated entity in your account. Note that correlations currently do not analyze across accounts. The correlated signals displayed are for others in the account of the original application you are viewing. This helps focus the data on correlations that are more likely related to your issue. Profile tab Based on the same technology as New Relic’s error profiles, this tab compares the last five minutes to the prior hour by default (or whatever time windows you’ve selected with query editing) and surfaces any attributes that have significantly different distributions in the events being targeted by the selected signal. For example, if a custom attribute indicated that a recent throughput spike came from one user, that would surface highly in Profiles if most of the traffic usually comes from many users. Traces tab If the entity has distributed traces configured and available in the selected evaluated time window, the Traces section is enabled. Each card shows a summary of a trace and can be clicked for details. The Explore all traces links to the distributed traces application, filtered to the selected entity. Create a custom view To target signals and time windows beyond the default values, click the Change view button and select Custom view. To create your own view: Select the account or subaccount. Select the data type (metrics or events). Different functionality is available depending on the type. In View a chart with, select the metric or event you are interested in. Default is golden signals (throughput, response time, and errors). You can also build custom queries (filters) to target a signal that isn't on the list. In Facet by, select what the circles represent. Default is appName, but you can also choose host or any other facetable attribute available for the signal you’ve selected. If you plan to save/favorite this new view, provide a name in the Name your view box. Keep in mind that you can edit this view at any time using the pencil icon. The default time windows analyzed by New Relic Lookout are the last five minutes compared to the hour before. Use the time controls (View data from and Compare data to) to target other time windows. one.newrelic.com > Apps > New Relic Lookout: All event and metric data in the New Relic database can be queried using the Edit query feature. Click Analyze to begin analyzing the signal you’ve selected. You can also create your own query: Create your query. This query is comparing data from the past thirty minutes to data from the same range a day ago. Change from Basic to Advanced after clicking the Custom view button. Select the data type (metrics or events). Different functionality is available depending on the type. Enter your query using NRQL. Please note that not all NRQL features are available in the Lookout Advanced query feature. By default, the system will run this query using the last five minutes of data compared to the previous hour. Some examples of the syntax for changing the comparison and evaluation time windows are below. Click Analyze to begin analyzing the signal you’ve selected. Query: Compare the last 15 minutes to the same time 1 day ago Please note that the UNTIL NOW portion is required here unlike in standard NRQL. Without the UNTIL NOW added, the system will query a 5 minute slice of data starting 15 minutes ago SINCE 15 minutes AGO UNTIL NOW COMPARE WITH 1 day ago Copy Query: Compare a specific time range to the same range a month ago SINCE '2021-03-07 07:00:00-0500' UNTIL '2021-03-08 07:00:00-0500' COMPARE WITH 1 month ago Copy Or: SINCE 'today at midnight' UNTIL 'now' COMPARE WITH 1 MONTH AGO Copy Example: Unusual increases in error count The default view of New Relic Lookout shows application status across your estate, comparing the last five minutes to the hour before. Under regular operation, most large systems may have a handful of abnormalities, but usually most things will indicate normal behavior. Suddenly, several circles begin to change to red under the Errors section. This indicates that several applications are experiencing unusual increases in error count. It may be that one or two circles for important systems are red, and perhaps much larger than they usually appear. Clicking one of these can provide more information on what is happening. You might see that the error rate is substantially elevated, even thousands of percent higher than normal. To troubleshoot this issue, here's what you might discover in the New Relic Lookout tabs: Performance would show you data about other signals, illuminating the characteristics of the change in system dynamics. Correlations would surface other applications that are affected and how, as well as opportunities to pivot to other applications that may be closer to the underlying causes. Traces, in turn, would show distributed traces, which can provide specific examples of traffic running through those systems. Abnormal history would show other times in the past week with elevated errors, showing whether or not this problem happens regularly, such as every day at the same time or whenever there is a deployment. Profiles might show that all or most of the new errors share common properties, such as all being isolated to just one region/account/user. Combining the information from these sections, not only can you get a sense of what is going on, but also where to focus actions to resolve the problem.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.48643,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "sections": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in <em>New</em> <em>Relic</em> database (NRDB), including third-party, open, and custom data. Launch into other areas of <em>New</em> <em>Relic</em> <em>One</em> for deeper"
      },
      "id": "603e821e64441f5a444e8845"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/cross-product-functions/install-configure/compatibility-requirements-new-relic-agents-products": [
    {
      "sections": [
        "Install New Relic",
        "Install APM",
        "Install browser monitoring",
        "Install infrastructure monitoring",
        "Install mobile monitoring",
        "Install synthetic monitors",
        "Troubleshooting"
      ],
      "title": "Install New Relic ",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Install and configure"
      ],
      "external_id": "819ccfd8df22ff322271245ca0831bf53609b91f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/cross-product-functions/install-configure/install-new-relic/",
      "published_at": "2021-12-31T01:40:19Z",
      "updated_at": "2021-12-30T20:03:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you sign up for a New Relic account (it's free, forever!) and install any of our monitoring services, you can start working with your data. Get started quickly with our New Relic Instant Observability quickstarts. Alternatively, use our guided install. Here are links to instructions on how to install New Relic monitoring services: APM Browser Infrastructure Mobile Synthetic monitors Integrations for third-party telemetry services Data ingest APIs (metrics, events, logs, traces) Install APM C Go Java .NET For Windows .NET applications on IIS, use our guided install in New Relic One to get started with APM. If you're on an EU server, use our launcher for EU accounts instead. Node.js PHP Python Ruby Install browser monitoring See browser monitoring install. Install infrastructure monitoring Linux guided install for infrastructure monitoring Linux procedures for infrastructure monitoring Windows Kubernetes Prometheus On-host integrations (for services like NGINX, StatsD, MySQL, etc.) AWS cloud integrations Azure cloud integrations Google Cloud Platform Install mobile monitoring Android iOS Install synthetic monitors Synthetic monitoring doesn't require installation, except for its private minions feature. Troubleshooting You should start seeing your data in the New Relic UI after installing the agent, generating some traffic, and waiting a few minutes. If no data appears, follow our troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 325.00812,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>New</em> <em>Relic</em> ",
        "sections": "<em>Install</em> <em>New</em> <em>Relic</em>",
        "tags": "<em>Install</em> <em>and</em> <em>configure</em>",
        "body": "After you sign up for a <em>New</em> <em>Relic</em> account (it&#x27;s free, forever!) and <em>install</em> any of our monitoring services, you can start working with your data. Get started quickly with our <em>New</em> <em>Relic</em> Instant Observability quickstarts. Alternatively, <em>use</em> our guided <em>install</em>. Here are links to instructions on how"
      },
      "id": "61b8148ce7b9d22373ef3a8b"
    },
    {
      "sections": [
        "Networks",
        "Tip",
        "TLS encryption",
        "User-facing domains",
        "APM agents",
        "Port 443 recommended",
        "Agent downloads",
        "Infrastructure agents",
        "Browser domains",
        "Mobile domains",
        "Synthetic monitor public locations",
        "Synthetic monitor private locations",
        "Alerts webhooks, api.newrelic.com, cloud integrations, and ticketing integrations",
        "Pixie integration",
        "OpenTelemetry"
      ],
      "title": "Networks",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Install and configure"
      ],
      "external_id": "9f7555daaafae1753bf1e741a5d607e7f0f87b7c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/networks/",
      "published_at": "2021-12-31T01:19:00Z",
      "updated_at": "2021-12-15T12:41:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This list is current. Networks, IPs, domains, ports, and endpoints last updated September 28, 2021. This is a list of the networks, IP addresses, domains, ports, and endpoints used by API clients or agents to communicate with New Relic. TLS is required for all domains. For information on our FedRAMP endpoints, see our FedRAMP endpoints documentation. Tip This doc describes how to ensure our agents and integrations can access New Relic's domains. To monitor the performance of your network, see Get started with Network Performance Monitoring. TLS encryption To ensure data security for our customers and to be in compliance with FedRAMP and other standards for data encryption, Transport Layer Security (TLS) is required for all domains. Our preferred protocol for all domains is TLS 1.2. For more information, see New Relic's Explorers Hub post about TLS 1.2. In addition, TLS 1.2 is required for most domains, except: APM agent connections Browser agent connections Event API For future updates to required and supported protocol versions, follow the Security Notifications tag in New Relic's Explorers Hub. User-facing domains Your browser must be able to communicate with a number of domains for New Relic One to work properly. Update your allow list to ensure New Relic can communicate with a number of integral domains that are listed in this section. Blocking domains can cause issues with individual product features or prevent pages from loading altogether. This list doesn't cover domains that New Relic connects to that can be blocked without affecting your usage of the product. It also doesn't cover Nerdpacks or other features that communicate with external services that have additional domain requirements. If your organization uses a firewall that restricts outbound traffic, follow the specific procedures for the operating system and the firewall you use to add the following domains to the allow list. Domain Description *.newrelic.com New Relic One and supporting services *.nr-assets.net Static New Relic assets *.nr-ext.net New Relic One Nerdpacks and assets *.amazonaws.com New Relic One catalog assets behind AWS S3 *.cloudfront.net Static New Relic assets behind AWS CloudFront CDN secure.gravatar.com Support for Gravatar avatars fonts.googleapis.com Support for Google Fonts fonts.gstatic.com Support for Google Fonts www.google.com Support for reCAPTCHA www.gstatic.com Support for reCAPTCHA *.nr-data.net OpenTelemetry and Pixie APM agents To enhance network performance and data security, New Relic uses a CDN and DDoS prevention service with a large IP range. New Relic agents require your firewall to allow outgoing connections to the following networks and ports. To add the following IP connections to the allow list, follow the specific procedures for the operating system and the firewall you use. TLS is required for all domains. Use the IP connections for account data in the US or European Union region as appropriate: IP connections APM data Networks US region accounts: 162.247.240.0/22 EU region accounts: 185.221.84.0/22 Ports US region accounts: Default: TCP 443 (recommended) TCP 80 EU region accounts: Default: TCP 443 (recommended) TCP 80 Endpoints US region accounts: collector*.newrelic.com EU region accounts: collector*.eu01.nr-data.net:443 (recommended) Port 443 recommended Recommendation: Use port 443, a secured channel for encrypted HTTPS traffic. Some New Relic agents also offer port 80, an unsecured channel open to all HTTP traffic. While some agents can be configured to use both port 80 and port 443, we recommend that you choose the port 443 (default). If you have an existing configuration that uses port 80, you can update it to use port 443, the default New Relic connection. Agent downloads TLS is required for all domains. Service for download.newrelic.com is provided through Fastly and is subject to change without warning. For the most current list of public IP addresses for New Relic agent downloads, see api.fastly.com/public-ip-list. Infrastructure agents In order to report data to New Relic, our infrastructure monitoring needs outbound access to these domains, networks, and ports. TLS is required for all domains. Use the IP connections for account data in the US or European Union region as appropriate: IP connections Infrastructure data Domains infra-api.newrelic.com: Required to submit events, metrics, and inventory data. identity-api.newrelic.com: Required for entity registration (for example, a host entity). infrastructure-command-api.newrelic.com: Required to determine feature flags. Also used for gradual rollout of new capabilities. log-api.newrelic.com: Required to submit logs to a US datacenter. log-api.eu.newrelic.com: Required to submit logs to an EU datacenter. metric-api.newrelic.com: Required to submit dimensional metrics. Networks For US region accounts: 162.247.240.0/22 For EU region accounts: 185.221.84.0/22 Port 443 Domains + Port For US region accounts: infra-api.newrelic.com:443 identity-api.newrelic.com:443 infrastructure-command-api.newrelic.com:443 log-api.newrelic.com:443 metric-api.newrelic.com:443 For EU region accounts: infra-api.eu.newrelic.com:443 identity-api.eu.newrelic.com:443 infrastructure-command-api.eu.newrelic.com:443 log-api.eu.newrelic.com:443 metric-api.eu.newrelic.com:443 Proxy If your system needs a proxy to connect to this domain, use the Infrastructure proxy setting. Browser domains In addition to the IP addresses for APM agents, applications monitored by our browser agents use outgoing connections to the following domains. TLS is required for all domains. Use the IP connections for account data in the US or European Union region as appropriate: For US region accounts: bam.nr-data.net js-agent.newrelic.com For EU region accounts: eu01.nr-data.net bam.eu01.nr-data.net For more information about CDN access for the js-agent.newrelic.com file to the domain bam.nr-data.net or to one of the New Relic beacons, see Security for browser monitoring. Mobile domains In addition to the IP addresses for APM agents, applications monitored by our mobile agents use outgoing connections to the following domains. TLS is required for all domains. Use the IP connections for account data in the US or European Union region as appropriate: For US region accounts: mobile-collector.newrelic.com mobile-crash.newrelic.com mobile-symbol-upload.newrelic.com For EU region accounts: mobile-collector.eu01.nr-data.net mobile-crash.eu01.nr-data.net mobile-symbol-upload.eu01.nr-data.net Synthetic monitor public locations To configure your firewall to allow synthetic monitors to access your monitored URL, use Synthetic public minion IPs. TLS is required for all domains. Synthetic monitor private locations Synthetic private minions report to a specific endpoint based on region. To allow the private minion to access the endpoint or the static IP addresses associated with the endpoint, follow the specific procedures for the operating system and the firewall you use. These IP addresses may change in the future. TLS is required for all domains. Use the IP connections for account data in the US or European Union region as appropriate: IP connections Synthetics private location data Endpoint For US region accounts: https://synthetics-horde.nr-data.net/ For EU region accounts: https://synthetics-horde.eu01.nr-data.net/ IP addresses For US region accounts: 13.248.153.51 76.223.21.185 For EU region accounts: 185.221.86.57 185.221.86.25 Alerts webhooks, api.newrelic.com, cloud integrations, and ticketing integrations Endpoints that use api.newrelic.com (such as our GraphQL API for NerdGraph) and our New Relic-generated webhooks for alert policies use an IP address from designated network blocks for the US or European Union region. TLS is required for all addresses in these blocks. Network blocks for US region accounts: 162.247.240.0/22 Network blocks for EU region accounts: 158.177.65.64/29 159.122.103.184/29 161.156.125.32/28 These network blocks also apply to third-party ticketing integrations and New Relic cloud integrations. Pixie integration The Pixie integration runs in your Kubernetes cluster and pulls a set of curated observability data from Pixie to send it to New Relic using the OpenTelemetry line protocol. The Pixie integration requires outbound network access to the following: work.withpixie.ai:443 otlp.nr-data.net:4317 (US region accounts) otlp.eu01.nr-data.net:4317 (EU region accounts) OpenTelemetry New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemetry community to export your data to New Relic. To export OTLP data to New Relic, configure the OTLP exporter to add a header ( api-key ) whose value is your account license key. And, based on your region, configure the endpoint where the exporter sends data to New Relic. See the OpenTelemetry quick start for more information. otlp.nr-data.net:4317 (US region accounts) otlp.eu01.nr-data.net:4317 (EU region accounts) Network blocks for US region accounts: 162.247.240.0/22 Network blocks for EU region accounts: 185.221.84.0/22",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.4198,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>User</em>-facing domains",
        "tags": "<em>Install</em> <em>and</em> <em>configure</em>",
        "body": " for <em>New</em> <em>Relic</em> One to work properly. Update your allow list to ensure <em>New</em> <em>Relic</em> can communicate with a number of integral domains that are listed in this section. Blocking domains can cause issues with individual <em>product</em> features or prevent pages from loading altogether. This list doesn&#x27;t cover"
      },
      "id": "603eb81364441f64a24e88b6"
    },
    {
      "sections": [
        "Notification of changes to New Relic SaaS features and distributed software",
        "What we communicate",
        "Lead time for notifications",
        "EOL lead times: impact on distributed software",
        "Subject to EOL lead times:",
        "EOL lead times not applicable:",
        "Questions about EOL notifications?"
      ],
      "title": "Notification of changes to New Relic SaaS features and distributed software",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Install and configure"
      ],
      "external_id": "9a6b696d32c2863811e2df52d736ed2428228a93",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/end-of-life/notification-changes-new-relic-saas-features-distributed-software/",
      "published_at": "2021-12-30T02:53:29Z",
      "updated_at": "2021-12-14T04:01:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "At New Relic, we support our customers by continually improving our Software as a Service (SaaS) features and distributed software. Sometimes that means we introduce changes that can include moving away from existing software components and features, called end-of-life (EOL). As we make these decisions, we strive to balance the need to introduce improvements with our customer’s tolerance for change. We do our best to anticipate the impact of these changes for our customers. What we communicate We're committed to communicating about the changes that impact user experience, especially when these changes have a significant effect on workflow. In assessing impact we evaluate: Potential impact to customer workflow Feature usage information Customer feedback In communicating changes, we strive to: Give as much lead time as possible Minimize interruption Provide a documented alternative Lead time for notifications EOL changes are classified into the following categories: Transition impact Description Notification lead time Low Limited changes to customer processes or procedures are anticipated. None to 90 days Moderate Changes to functionality are limited in scope. Actions such as upgrading retired agents to supported versions may be required. Minimum of 90 days High Changes are highly impactful to customers and will require significant investment from customers to adapt. Minimum of 180 days Critical A third party dependency, security issue, or other critical risk causes an urgent need to change or remove functionality on an accelerated timeline. Notified as soon as reasonably practical EOL lead times: impact on distributed software Subject to EOL lead times: Our lead time notifications also apply to distributed software, which is software developed by New Relic that is installed on customer-owned systems. Distributed software is not cloud-based, and has a lifespan from the date of each released version. After that date, it may cease to function or stop reporting data to New Relic. We have fully open sourced many of our distributed software projects as community projects. We also participate in many community-led software development projects. If we have not open sourced our software projects, or if we have designated them as Community Plus projects, the following timeframes apply to them: Released on or after October 1, 2020: These projects will be compatible with our SaaS offering for at least two years after the date of publishing the release. Released prior to October 1, 2020: These projects will be compatible for at least three years after the date of publishing the release. All fixes and security updates are provided in the latest released version of distributed software, and we encourage our customers to keep installed software up to date. In the event a released version of software will cease normal function sooner than two (or three) years, New Relic will follow the EOL process. EOL lead times not applicable: Some of our distributed software have been open sourced, are designated as such, and are available at github.com/newrelic, including: Community projects New Relic One catalog Example code New Relic experimental Archived Our EOL policy does not apply to these projects, which is why we do not provide advance EOL notification for them. However, you can still find information and support for selected projects through: New Relic's documentation at docs.newrelic.com Project repos at github.com/newrelic Questions about EOL notifications? Share any questions or comments with us in New Relic’s Explorers Hub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 223.03082,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Notification of changes to <em>New</em> <em>Relic</em> SaaS features <em>and</em> distributed software",
        "sections": "Notification of changes to <em>New</em> <em>Relic</em> SaaS features <em>and</em> distributed software",
        "tags": "<em>Install</em> <em>and</em> <em>configure</em>",
        "body": " that is installed on customer-owned systems. Distributed software is not cloud-based, and has a lifespan from the date of each released version. After that date, it may cease to <em>function</em> or stop reporting data to <em>New</em> <em>Relic</em>. We have fully open sourced many of our distributed software projects as community"
      },
      "id": "604454f4e7b9d261f3579a03"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/cross-product-functions/install-configure/configure-new-relic-agents": [
    {
      "sections": [
        "Install New Relic",
        "Install APM",
        "Install browser monitoring",
        "Install infrastructure monitoring",
        "Install mobile monitoring",
        "Install synthetic monitors",
        "Troubleshooting"
      ],
      "title": "Install New Relic ",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Install and configure"
      ],
      "external_id": "819ccfd8df22ff322271245ca0831bf53609b91f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/cross-product-functions/install-configure/install-new-relic/",
      "published_at": "2021-12-31T01:40:19Z",
      "updated_at": "2021-12-30T20:03:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you sign up for a New Relic account (it's free, forever!) and install any of our monitoring services, you can start working with your data. Get started quickly with our New Relic Instant Observability quickstarts. Alternatively, use our guided install. Here are links to instructions on how to install New Relic monitoring services: APM Browser Infrastructure Mobile Synthetic monitors Integrations for third-party telemetry services Data ingest APIs (metrics, events, logs, traces) Install APM C Go Java .NET For Windows .NET applications on IIS, use our guided install in New Relic One to get started with APM. If you're on an EU server, use our launcher for EU accounts instead. Node.js PHP Python Ruby Install browser monitoring See browser monitoring install. Install infrastructure monitoring Linux guided install for infrastructure monitoring Linux procedures for infrastructure monitoring Windows Kubernetes Prometheus On-host integrations (for services like NGINX, StatsD, MySQL, etc.) AWS cloud integrations Azure cloud integrations Google Cloud Platform Install mobile monitoring Android iOS Install synthetic monitors Synthetic monitoring doesn't require installation, except for its private minions feature. Troubleshooting You should start seeing your data in the New Relic UI after installing the agent, generating some traffic, and waiting a few minutes. If no data appears, follow our troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 325.00812,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>New</em> <em>Relic</em> ",
        "sections": "<em>Install</em> <em>New</em> <em>Relic</em>",
        "tags": "<em>Install</em> <em>and</em> <em>configure</em>",
        "body": "After you sign up for a <em>New</em> <em>Relic</em> account (it&#x27;s free, forever!) and <em>install</em> any of our monitoring services, you can start working with your data. Get started quickly with our <em>New</em> <em>Relic</em> Instant Observability quickstarts. Alternatively, <em>use</em> our guided <em>install</em>. Here are links to instructions on how"
      },
      "id": "61b8148ce7b9d22373ef3a8b"
    },
    {
      "sections": [
        "Networks",
        "Tip",
        "TLS encryption",
        "User-facing domains",
        "APM agents",
        "Port 443 recommended",
        "Agent downloads",
        "Infrastructure agents",
        "Browser domains",
        "Mobile domains",
        "Synthetic monitor public locations",
        "Synthetic monitor private locations",
        "Alerts webhooks, api.newrelic.com, cloud integrations, and ticketing integrations",
        "Pixie integration",
        "OpenTelemetry"
      ],
      "title": "Networks",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Install and configure"
      ],
      "external_id": "9f7555daaafae1753bf1e741a5d607e7f0f87b7c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/networks/",
      "published_at": "2021-12-31T01:19:00Z",
      "updated_at": "2021-12-15T12:41:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This list is current. Networks, IPs, domains, ports, and endpoints last updated September 28, 2021. This is a list of the networks, IP addresses, domains, ports, and endpoints used by API clients or agents to communicate with New Relic. TLS is required for all domains. For information on our FedRAMP endpoints, see our FedRAMP endpoints documentation. Tip This doc describes how to ensure our agents and integrations can access New Relic's domains. To monitor the performance of your network, see Get started with Network Performance Monitoring. TLS encryption To ensure data security for our customers and to be in compliance with FedRAMP and other standards for data encryption, Transport Layer Security (TLS) is required for all domains. Our preferred protocol for all domains is TLS 1.2. For more information, see New Relic's Explorers Hub post about TLS 1.2. In addition, TLS 1.2 is required for most domains, except: APM agent connections Browser agent connections Event API For future updates to required and supported protocol versions, follow the Security Notifications tag in New Relic's Explorers Hub. User-facing domains Your browser must be able to communicate with a number of domains for New Relic One to work properly. Update your allow list to ensure New Relic can communicate with a number of integral domains that are listed in this section. Blocking domains can cause issues with individual product features or prevent pages from loading altogether. This list doesn't cover domains that New Relic connects to that can be blocked without affecting your usage of the product. It also doesn't cover Nerdpacks or other features that communicate with external services that have additional domain requirements. If your organization uses a firewall that restricts outbound traffic, follow the specific procedures for the operating system and the firewall you use to add the following domains to the allow list. Domain Description *.newrelic.com New Relic One and supporting services *.nr-assets.net Static New Relic assets *.nr-ext.net New Relic One Nerdpacks and assets *.amazonaws.com New Relic One catalog assets behind AWS S3 *.cloudfront.net Static New Relic assets behind AWS CloudFront CDN secure.gravatar.com Support for Gravatar avatars fonts.googleapis.com Support for Google Fonts fonts.gstatic.com Support for Google Fonts www.google.com Support for reCAPTCHA www.gstatic.com Support for reCAPTCHA *.nr-data.net OpenTelemetry and Pixie APM agents To enhance network performance and data security, New Relic uses a CDN and DDoS prevention service with a large IP range. New Relic agents require your firewall to allow outgoing connections to the following networks and ports. To add the following IP connections to the allow list, follow the specific procedures for the operating system and the firewall you use. TLS is required for all domains. Use the IP connections for account data in the US or European Union region as appropriate: IP connections APM data Networks US region accounts: 162.247.240.0/22 EU region accounts: 185.221.84.0/22 Ports US region accounts: Default: TCP 443 (recommended) TCP 80 EU region accounts: Default: TCP 443 (recommended) TCP 80 Endpoints US region accounts: collector*.newrelic.com EU region accounts: collector*.eu01.nr-data.net:443 (recommended) Port 443 recommended Recommendation: Use port 443, a secured channel for encrypted HTTPS traffic. Some New Relic agents also offer port 80, an unsecured channel open to all HTTP traffic. While some agents can be configured to use both port 80 and port 443, we recommend that you choose the port 443 (default). If you have an existing configuration that uses port 80, you can update it to use port 443, the default New Relic connection. Agent downloads TLS is required for all domains. Service for download.newrelic.com is provided through Fastly and is subject to change without warning. For the most current list of public IP addresses for New Relic agent downloads, see api.fastly.com/public-ip-list. Infrastructure agents In order to report data to New Relic, our infrastructure monitoring needs outbound access to these domains, networks, and ports. TLS is required for all domains. Use the IP connections for account data in the US or European Union region as appropriate: IP connections Infrastructure data Domains infra-api.newrelic.com: Required to submit events, metrics, and inventory data. identity-api.newrelic.com: Required for entity registration (for example, a host entity). infrastructure-command-api.newrelic.com: Required to determine feature flags. Also used for gradual rollout of new capabilities. log-api.newrelic.com: Required to submit logs to a US datacenter. log-api.eu.newrelic.com: Required to submit logs to an EU datacenter. metric-api.newrelic.com: Required to submit dimensional metrics. Networks For US region accounts: 162.247.240.0/22 For EU region accounts: 185.221.84.0/22 Port 443 Domains + Port For US region accounts: infra-api.newrelic.com:443 identity-api.newrelic.com:443 infrastructure-command-api.newrelic.com:443 log-api.newrelic.com:443 metric-api.newrelic.com:443 For EU region accounts: infra-api.eu.newrelic.com:443 identity-api.eu.newrelic.com:443 infrastructure-command-api.eu.newrelic.com:443 log-api.eu.newrelic.com:443 metric-api.eu.newrelic.com:443 Proxy If your system needs a proxy to connect to this domain, use the Infrastructure proxy setting. Browser domains In addition to the IP addresses for APM agents, applications monitored by our browser agents use outgoing connections to the following domains. TLS is required for all domains. Use the IP connections for account data in the US or European Union region as appropriate: For US region accounts: bam.nr-data.net js-agent.newrelic.com For EU region accounts: eu01.nr-data.net bam.eu01.nr-data.net For more information about CDN access for the js-agent.newrelic.com file to the domain bam.nr-data.net or to one of the New Relic beacons, see Security for browser monitoring. Mobile domains In addition to the IP addresses for APM agents, applications monitored by our mobile agents use outgoing connections to the following domains. TLS is required for all domains. Use the IP connections for account data in the US or European Union region as appropriate: For US region accounts: mobile-collector.newrelic.com mobile-crash.newrelic.com mobile-symbol-upload.newrelic.com For EU region accounts: mobile-collector.eu01.nr-data.net mobile-crash.eu01.nr-data.net mobile-symbol-upload.eu01.nr-data.net Synthetic monitor public locations To configure your firewall to allow synthetic monitors to access your monitored URL, use Synthetic public minion IPs. TLS is required for all domains. Synthetic monitor private locations Synthetic private minions report to a specific endpoint based on region. To allow the private minion to access the endpoint or the static IP addresses associated with the endpoint, follow the specific procedures for the operating system and the firewall you use. These IP addresses may change in the future. TLS is required for all domains. Use the IP connections for account data in the US or European Union region as appropriate: IP connections Synthetics private location data Endpoint For US region accounts: https://synthetics-horde.nr-data.net/ For EU region accounts: https://synthetics-horde.eu01.nr-data.net/ IP addresses For US region accounts: 13.248.153.51 76.223.21.185 For EU region accounts: 185.221.86.57 185.221.86.25 Alerts webhooks, api.newrelic.com, cloud integrations, and ticketing integrations Endpoints that use api.newrelic.com (such as our GraphQL API for NerdGraph) and our New Relic-generated webhooks for alert policies use an IP address from designated network blocks for the US or European Union region. TLS is required for all addresses in these blocks. Network blocks for US region accounts: 162.247.240.0/22 Network blocks for EU region accounts: 158.177.65.64/29 159.122.103.184/29 161.156.125.32/28 These network blocks also apply to third-party ticketing integrations and New Relic cloud integrations. Pixie integration The Pixie integration runs in your Kubernetes cluster and pulls a set of curated observability data from Pixie to send it to New Relic using the OpenTelemetry line protocol. The Pixie integration requires outbound network access to the following: work.withpixie.ai:443 otlp.nr-data.net:4317 (US region accounts) otlp.eu01.nr-data.net:4317 (EU region accounts) OpenTelemetry New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemetry community to export your data to New Relic. To export OTLP data to New Relic, configure the OTLP exporter to add a header ( api-key ) whose value is your account license key. And, based on your region, configure the endpoint where the exporter sends data to New Relic. See the OpenTelemetry quick start for more information. otlp.nr-data.net:4317 (US region accounts) otlp.eu01.nr-data.net:4317 (EU region accounts) Network blocks for US region accounts: 162.247.240.0/22 Network blocks for EU region accounts: 185.221.84.0/22",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.4198,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>User</em>-facing domains",
        "tags": "<em>Install</em> <em>and</em> <em>configure</em>",
        "body": " for <em>New</em> <em>Relic</em> One to work properly. Update your allow list to ensure <em>New</em> <em>Relic</em> can communicate with a number of integral domains that are listed in this section. Blocking domains can cause issues with individual <em>product</em> features or prevent pages from loading altogether. This list doesn&#x27;t cover"
      },
      "id": "603eb81364441f64a24e88b6"
    },
    {
      "sections": [
        "Notification of changes to New Relic SaaS features and distributed software",
        "What we communicate",
        "Lead time for notifications",
        "EOL lead times: impact on distributed software",
        "Subject to EOL lead times:",
        "EOL lead times not applicable:",
        "Questions about EOL notifications?"
      ],
      "title": "Notification of changes to New Relic SaaS features and distributed software",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Install and configure"
      ],
      "external_id": "9a6b696d32c2863811e2df52d736ed2428228a93",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/end-of-life/notification-changes-new-relic-saas-features-distributed-software/",
      "published_at": "2021-12-30T02:53:29Z",
      "updated_at": "2021-12-14T04:01:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "At New Relic, we support our customers by continually improving our Software as a Service (SaaS) features and distributed software. Sometimes that means we introduce changes that can include moving away from existing software components and features, called end-of-life (EOL). As we make these decisions, we strive to balance the need to introduce improvements with our customer’s tolerance for change. We do our best to anticipate the impact of these changes for our customers. What we communicate We're committed to communicating about the changes that impact user experience, especially when these changes have a significant effect on workflow. In assessing impact we evaluate: Potential impact to customer workflow Feature usage information Customer feedback In communicating changes, we strive to: Give as much lead time as possible Minimize interruption Provide a documented alternative Lead time for notifications EOL changes are classified into the following categories: Transition impact Description Notification lead time Low Limited changes to customer processes or procedures are anticipated. None to 90 days Moderate Changes to functionality are limited in scope. Actions such as upgrading retired agents to supported versions may be required. Minimum of 90 days High Changes are highly impactful to customers and will require significant investment from customers to adapt. Minimum of 180 days Critical A third party dependency, security issue, or other critical risk causes an urgent need to change or remove functionality on an accelerated timeline. Notified as soon as reasonably practical EOL lead times: impact on distributed software Subject to EOL lead times: Our lead time notifications also apply to distributed software, which is software developed by New Relic that is installed on customer-owned systems. Distributed software is not cloud-based, and has a lifespan from the date of each released version. After that date, it may cease to function or stop reporting data to New Relic. We have fully open sourced many of our distributed software projects as community projects. We also participate in many community-led software development projects. If we have not open sourced our software projects, or if we have designated them as Community Plus projects, the following timeframes apply to them: Released on or after October 1, 2020: These projects will be compatible with our SaaS offering for at least two years after the date of publishing the release. Released prior to October 1, 2020: These projects will be compatible for at least three years after the date of publishing the release. All fixes and security updates are provided in the latest released version of distributed software, and we encourage our customers to keep installed software up to date. In the event a released version of software will cease normal function sooner than two (or three) years, New Relic will follow the EOL process. EOL lead times not applicable: Some of our distributed software have been open sourced, are designated as such, and are available at github.com/newrelic, including: Community projects New Relic One catalog Example code New Relic experimental Archived Our EOL policy does not apply to these projects, which is why we do not provide advance EOL notification for them. However, you can still find information and support for selected projects through: New Relic's documentation at docs.newrelic.com Project repos at github.com/newrelic Questions about EOL notifications? Share any questions or comments with us in New Relic’s Explorers Hub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 223.03082,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Notification of changes to <em>New</em> <em>Relic</em> SaaS features <em>and</em> distributed software",
        "sections": "Notification of changes to <em>New</em> <em>Relic</em> SaaS features <em>and</em> distributed software",
        "tags": "<em>Install</em> <em>and</em> <em>configure</em>",
        "body": " that is installed on customer-owned systems. Distributed software is not cloud-based, and has a lifespan from the date of each released version. After that date, it may cease to <em>function</em> or stop reporting data to <em>New</em> <em>Relic</em>. We have fully open sourced many of our distributed software projects as community"
      },
      "id": "604454f4e7b9d261f3579a03"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/cross-product-functions/install-configure/install-new-relic": [
    {
      "sections": [
        "Networks",
        "Tip",
        "TLS encryption",
        "User-facing domains",
        "APM agents",
        "Port 443 recommended",
        "Agent downloads",
        "Infrastructure agents",
        "Browser domains",
        "Mobile domains",
        "Synthetic monitor public locations",
        "Synthetic monitor private locations",
        "Alerts webhooks, api.newrelic.com, cloud integrations, and ticketing integrations",
        "Pixie integration",
        "OpenTelemetry"
      ],
      "title": "Networks",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Install and configure"
      ],
      "external_id": "9f7555daaafae1753bf1e741a5d607e7f0f87b7c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/networks/",
      "published_at": "2021-12-31T01:19:00Z",
      "updated_at": "2021-12-15T12:41:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This list is current. Networks, IPs, domains, ports, and endpoints last updated September 28, 2021. This is a list of the networks, IP addresses, domains, ports, and endpoints used by API clients or agents to communicate with New Relic. TLS is required for all domains. For information on our FedRAMP endpoints, see our FedRAMP endpoints documentation. Tip This doc describes how to ensure our agents and integrations can access New Relic's domains. To monitor the performance of your network, see Get started with Network Performance Monitoring. TLS encryption To ensure data security for our customers and to be in compliance with FedRAMP and other standards for data encryption, Transport Layer Security (TLS) is required for all domains. Our preferred protocol for all domains is TLS 1.2. For more information, see New Relic's Explorers Hub post about TLS 1.2. In addition, TLS 1.2 is required for most domains, except: APM agent connections Browser agent connections Event API For future updates to required and supported protocol versions, follow the Security Notifications tag in New Relic's Explorers Hub. User-facing domains Your browser must be able to communicate with a number of domains for New Relic One to work properly. Update your allow list to ensure New Relic can communicate with a number of integral domains that are listed in this section. Blocking domains can cause issues with individual product features or prevent pages from loading altogether. This list doesn't cover domains that New Relic connects to that can be blocked without affecting your usage of the product. It also doesn't cover Nerdpacks or other features that communicate with external services that have additional domain requirements. If your organization uses a firewall that restricts outbound traffic, follow the specific procedures for the operating system and the firewall you use to add the following domains to the allow list. Domain Description *.newrelic.com New Relic One and supporting services *.nr-assets.net Static New Relic assets *.nr-ext.net New Relic One Nerdpacks and assets *.amazonaws.com New Relic One catalog assets behind AWS S3 *.cloudfront.net Static New Relic assets behind AWS CloudFront CDN secure.gravatar.com Support for Gravatar avatars fonts.googleapis.com Support for Google Fonts fonts.gstatic.com Support for Google Fonts www.google.com Support for reCAPTCHA www.gstatic.com Support for reCAPTCHA *.nr-data.net OpenTelemetry and Pixie APM agents To enhance network performance and data security, New Relic uses a CDN and DDoS prevention service with a large IP range. New Relic agents require your firewall to allow outgoing connections to the following networks and ports. To add the following IP connections to the allow list, follow the specific procedures for the operating system and the firewall you use. TLS is required for all domains. Use the IP connections for account data in the US or European Union region as appropriate: IP connections APM data Networks US region accounts: 162.247.240.0/22 EU region accounts: 185.221.84.0/22 Ports US region accounts: Default: TCP 443 (recommended) TCP 80 EU region accounts: Default: TCP 443 (recommended) TCP 80 Endpoints US region accounts: collector*.newrelic.com EU region accounts: collector*.eu01.nr-data.net:443 (recommended) Port 443 recommended Recommendation: Use port 443, a secured channel for encrypted HTTPS traffic. Some New Relic agents also offer port 80, an unsecured channel open to all HTTP traffic. While some agents can be configured to use both port 80 and port 443, we recommend that you choose the port 443 (default). If you have an existing configuration that uses port 80, you can update it to use port 443, the default New Relic connection. Agent downloads TLS is required for all domains. Service for download.newrelic.com is provided through Fastly and is subject to change without warning. For the most current list of public IP addresses for New Relic agent downloads, see api.fastly.com/public-ip-list. Infrastructure agents In order to report data to New Relic, our infrastructure monitoring needs outbound access to these domains, networks, and ports. TLS is required for all domains. Use the IP connections for account data in the US or European Union region as appropriate: IP connections Infrastructure data Domains infra-api.newrelic.com: Required to submit events, metrics, and inventory data. identity-api.newrelic.com: Required for entity registration (for example, a host entity). infrastructure-command-api.newrelic.com: Required to determine feature flags. Also used for gradual rollout of new capabilities. log-api.newrelic.com: Required to submit logs to a US datacenter. log-api.eu.newrelic.com: Required to submit logs to an EU datacenter. metric-api.newrelic.com: Required to submit dimensional metrics. Networks For US region accounts: 162.247.240.0/22 For EU region accounts: 185.221.84.0/22 Port 443 Domains + Port For US region accounts: infra-api.newrelic.com:443 identity-api.newrelic.com:443 infrastructure-command-api.newrelic.com:443 log-api.newrelic.com:443 metric-api.newrelic.com:443 For EU region accounts: infra-api.eu.newrelic.com:443 identity-api.eu.newrelic.com:443 infrastructure-command-api.eu.newrelic.com:443 log-api.eu.newrelic.com:443 metric-api.eu.newrelic.com:443 Proxy If your system needs a proxy to connect to this domain, use the Infrastructure proxy setting. Browser domains In addition to the IP addresses for APM agents, applications monitored by our browser agents use outgoing connections to the following domains. TLS is required for all domains. Use the IP connections for account data in the US or European Union region as appropriate: For US region accounts: bam.nr-data.net js-agent.newrelic.com For EU region accounts: eu01.nr-data.net bam.eu01.nr-data.net For more information about CDN access for the js-agent.newrelic.com file to the domain bam.nr-data.net or to one of the New Relic beacons, see Security for browser monitoring. Mobile domains In addition to the IP addresses for APM agents, applications monitored by our mobile agents use outgoing connections to the following domains. TLS is required for all domains. Use the IP connections for account data in the US or European Union region as appropriate: For US region accounts: mobile-collector.newrelic.com mobile-crash.newrelic.com mobile-symbol-upload.newrelic.com For EU region accounts: mobile-collector.eu01.nr-data.net mobile-crash.eu01.nr-data.net mobile-symbol-upload.eu01.nr-data.net Synthetic monitor public locations To configure your firewall to allow synthetic monitors to access your monitored URL, use Synthetic public minion IPs. TLS is required for all domains. Synthetic monitor private locations Synthetic private minions report to a specific endpoint based on region. To allow the private minion to access the endpoint or the static IP addresses associated with the endpoint, follow the specific procedures for the operating system and the firewall you use. These IP addresses may change in the future. TLS is required for all domains. Use the IP connections for account data in the US or European Union region as appropriate: IP connections Synthetics private location data Endpoint For US region accounts: https://synthetics-horde.nr-data.net/ For EU region accounts: https://synthetics-horde.eu01.nr-data.net/ IP addresses For US region accounts: 13.248.153.51 76.223.21.185 For EU region accounts: 185.221.86.57 185.221.86.25 Alerts webhooks, api.newrelic.com, cloud integrations, and ticketing integrations Endpoints that use api.newrelic.com (such as our GraphQL API for NerdGraph) and our New Relic-generated webhooks for alert policies use an IP address from designated network blocks for the US or European Union region. TLS is required for all addresses in these blocks. Network blocks for US region accounts: 162.247.240.0/22 Network blocks for EU region accounts: 158.177.65.64/29 159.122.103.184/29 161.156.125.32/28 These network blocks also apply to third-party ticketing integrations and New Relic cloud integrations. Pixie integration The Pixie integration runs in your Kubernetes cluster and pulls a set of curated observability data from Pixie to send it to New Relic using the OpenTelemetry line protocol. The Pixie integration requires outbound network access to the following: work.withpixie.ai:443 otlp.nr-data.net:4317 (US region accounts) otlp.eu01.nr-data.net:4317 (EU region accounts) OpenTelemetry New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemetry community to export your data to New Relic. To export OTLP data to New Relic, configure the OTLP exporter to add a header ( api-key ) whose value is your account license key. And, based on your region, configure the endpoint where the exporter sends data to New Relic. See the OpenTelemetry quick start for more information. otlp.nr-data.net:4317 (US region accounts) otlp.eu01.nr-data.net:4317 (EU region accounts) Network blocks for US region accounts: 162.247.240.0/22 Network blocks for EU region accounts: 185.221.84.0/22",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.41977,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>User</em>-facing domains",
        "tags": "<em>Install</em> <em>and</em> <em>configure</em>",
        "body": " for <em>New</em> <em>Relic</em> One to work properly. Update your allow list to ensure <em>New</em> <em>Relic</em> can communicate with a number of integral domains that are listed in this section. Blocking domains can cause issues with individual <em>product</em> features or prevent pages from loading altogether. This list doesn&#x27;t cover"
      },
      "id": "603eb81364441f64a24e88b6"
    },
    {
      "sections": [
        "Notification of changes to New Relic SaaS features and distributed software",
        "What we communicate",
        "Lead time for notifications",
        "EOL lead times: impact on distributed software",
        "Subject to EOL lead times:",
        "EOL lead times not applicable:",
        "Questions about EOL notifications?"
      ],
      "title": "Notification of changes to New Relic SaaS features and distributed software",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Install and configure"
      ],
      "external_id": "9a6b696d32c2863811e2df52d736ed2428228a93",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/end-of-life/notification-changes-new-relic-saas-features-distributed-software/",
      "published_at": "2021-12-30T02:53:29Z",
      "updated_at": "2021-12-14T04:01:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "At New Relic, we support our customers by continually improving our Software as a Service (SaaS) features and distributed software. Sometimes that means we introduce changes that can include moving away from existing software components and features, called end-of-life (EOL). As we make these decisions, we strive to balance the need to introduce improvements with our customer’s tolerance for change. We do our best to anticipate the impact of these changes for our customers. What we communicate We're committed to communicating about the changes that impact user experience, especially when these changes have a significant effect on workflow. In assessing impact we evaluate: Potential impact to customer workflow Feature usage information Customer feedback In communicating changes, we strive to: Give as much lead time as possible Minimize interruption Provide a documented alternative Lead time for notifications EOL changes are classified into the following categories: Transition impact Description Notification lead time Low Limited changes to customer processes or procedures are anticipated. None to 90 days Moderate Changes to functionality are limited in scope. Actions such as upgrading retired agents to supported versions may be required. Minimum of 90 days High Changes are highly impactful to customers and will require significant investment from customers to adapt. Minimum of 180 days Critical A third party dependency, security issue, or other critical risk causes an urgent need to change or remove functionality on an accelerated timeline. Notified as soon as reasonably practical EOL lead times: impact on distributed software Subject to EOL lead times: Our lead time notifications also apply to distributed software, which is software developed by New Relic that is installed on customer-owned systems. Distributed software is not cloud-based, and has a lifespan from the date of each released version. After that date, it may cease to function or stop reporting data to New Relic. We have fully open sourced many of our distributed software projects as community projects. We also participate in many community-led software development projects. If we have not open sourced our software projects, or if we have designated them as Community Plus projects, the following timeframes apply to them: Released on or after October 1, 2020: These projects will be compatible with our SaaS offering for at least two years after the date of publishing the release. Released prior to October 1, 2020: These projects will be compatible for at least three years after the date of publishing the release. All fixes and security updates are provided in the latest released version of distributed software, and we encourage our customers to keep installed software up to date. In the event a released version of software will cease normal function sooner than two (or three) years, New Relic will follow the EOL process. EOL lead times not applicable: Some of our distributed software have been open sourced, are designated as such, and are available at github.com/newrelic, including: Community projects New Relic One catalog Example code New Relic experimental Archived Our EOL policy does not apply to these projects, which is why we do not provide advance EOL notification for them. However, you can still find information and support for selected projects through: New Relic's documentation at docs.newrelic.com Project repos at github.com/newrelic Questions about EOL notifications? Share any questions or comments with us in New Relic’s Explorers Hub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 223.03079,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Notification of changes to <em>New</em> <em>Relic</em> SaaS features <em>and</em> distributed software",
        "sections": "Notification of changes to <em>New</em> <em>Relic</em> SaaS features <em>and</em> distributed software",
        "tags": "<em>Install</em> <em>and</em> <em>configure</em>",
        "body": " that is installed on customer-owned systems. Distributed software is not cloud-based, and has a lifespan from the date of each released version. After that date, it may cease to <em>function</em> or stop reporting data to <em>New</em> <em>Relic</em>. We have fully open sourced many of our distributed software projects as community"
      },
      "id": "604454f4e7b9d261f3579a03"
    },
    {
      "sections": [
        "Uninstall New Relic agents",
        "Before you uninstall",
        "Important",
        "Uninstall APM",
        "Remove apps from UI",
        "Uninstall browser agent",
        "Uninstall infrastructure agent",
        "Delete account",
        "Uninstall other tools"
      ],
      "title": "Uninstall New Relic agents",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Install and configure"
      ],
      "external_id": "15ae05c4370739bb72086bc5bd3ac2e00c438f09",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/cross-product-functions/install-configure/uninstall-agent/",
      "published_at": "2021-12-30T20:03:34Z",
      "updated_at": "2021-12-14T03:51:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Some New Relic solutions require installation of an agent. You can uninstall the agent if you want it to stop reporting data. If you need to uninstall New Relic completely, follow the procedures for your agent. If you encounter problems, see support.newrelic.com. Before you uninstall Important For paying New Relic accounts, note that an alternative option to uninstalling is to downgrade your account to a less expensive or free tier. Uninstall APM After uninstalling APM agents or making a change to your startup script, you must restart your app (or the app server or web server where it is located). You must do this because New Relic agents typically run in the memory of the process running the app. Simply removing those files will not stop the applications that are currently running from sending data to New Relic. C SDK Go Java .NET Node.js PHP Python Ruby Remove apps from UI See Remove apps from UI. Uninstall browser agent Choose a procedure: Disable browser agent on specific pages Uninstall browser agent Uninstall infrastructure agent Choose a procedure: Uninstall infrastructure agent Uninstall a cloud or on-host integration Delete account See Downgrade/cancel your account. Uninstall other tools For uninstall instructions for solutions not listed here, see the docs for a specific New Relic solution.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 223.01492,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Uninstall <em>New</em> <em>Relic</em> agents",
        "sections": "Uninstall <em>New</em> <em>Relic</em> agents",
        "tags": "<em>Install</em> <em>and</em> <em>configure</em>",
        "body": "Some <em>New</em> <em>Relic</em> solutions require installation of an agent. You can uninstall the agent if you want it to stop reporting data. If you need to uninstall <em>New</em> <em>Relic</em> completely, follow the procedures for your agent. If you encounter problems, see support.newrelic.com. Before you uninstall Important"
      },
      "id": "61c087d064441fd18799eba6"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/cross-product-functions/install-configure/new-relic-guided-install-overview": [
    {
      "sections": [
        "Service Levels Management: Questions and next steps",
        "BETA FEATURE",
        "What permissions do I need to use New Relic's Service Levels?",
        "How do I get support from New Relic during the public beta?",
        "Why don’t I see any data right after I create an SLI?",
        "Can I configure an SLI on any entity type?",
        "Can I get alerts on SLI data?",
        "How does New Relic calculate the remaining error budget?",
        "How can I view the queries that define an SLI from the UI?",
        "How can I view the queries that define an SLI through the API?",
        "Can I chart the SLI attainment on a dashboard?"
      ],
      "title": "Service Levels Management: Questions and next steps",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Get started",
        "Service Level Management"
      ],
      "external_id": "262058f4dc430fbaee0382261f79de147e348f53",
      "image": "https://docs.newrelic.com/static/763695119ceaa7668fdb3fb858c83c75/c1b63/slm_edit_menu_2.png",
      "url": "https://docs.newrelic.com/docs/service-level-management/faqs-slm/",
      "published_at": "2021-12-30T03:43:10Z",
      "updated_at": "2021-12-25T02:33:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. What permissions do I need to use New Relic's Service Levels? To use New Relic's Service Levels and see SLO results, you need a full platform user. However, in order to create new SLIs and SLOs, you need the specific capability in your role to modify events to metric rules. If you get the following errors, check your user permissions: The UI has disabled the option to save an SLI/SLO. The API returns the error message “Cannot query field \\\"eventExportRegisterRule\\\" on type \\\"RootMutationType\\\".”. How do I get support from New Relic during the public beta? Service Levels Management is in public beta, and no official support is offered yet through the Support portal. If you have general questions and feedback, please post them on the Explorers Hub. New Relic’s community and the product team will be glad to help you there. If you have suggestions about documentation, please suggest an improvement or send your contribution using the Create issue or Edit page buttons on the top right corner in the docs UI. Why don’t I see any data right after I create an SLI? New Relic starts generating new SLI metrics from the moment that you create an SLI. This is why we need a few minutes before we can start showing the first meaningful SLI attainment results. The benefit of the new data is that it has 13 month retention by default, and it’s more efficient to query for long periods of time. Can I configure an SLI on any entity type? Yes, you can configure an SLI on any entity type, such as an APM service, a browser application, or a Lambda function. SLI queries support NRDB events. Support for dimensional metrics on SLI queries is on our roadmap. Can I get alerts on SLI data? Alerts on New Relic's Service Levels are on our roadmap. How does New Relic calculate the remaining error budget? The remaining error budget indicates what percentage of requests could still have a bad response over the SLO period without compromising the objective. Therefore, the total amount of tolerated bad responses will vary with the throughput of requests. Time-based error budgets are on our roadmap. How can I view the queries that define an SLI from the UI? To view the queries that define an SLI, you can click on the ... menu on the SLI summary card, then select the Edit option. The queries will show at the top-right corner. How can I view the queries that define an SLI through the API? To view the queries that define an SLI through the API, use Nerdgraph. In order to view the SLI configuration, you'll need to know the GUID of the entity the SLI is attached to, and replace it in the following query: { actor { entity(guid: \"{entityGuid}\") { serviceLevel { indicators { events { badEvents { where from } goodEvents { from where } validEvents { from where } } name } } } } } Copy As a response you are going to receive all the SLIs attached to the entity, the SLI name, and the queries. Keep in mind that either goodEvents or badEvents is going to have content, depending on the configuration of the SLI. Can I chart the SLI attainment on a dashboard? You can chart SLI attainment time series on your custom dashboards using the following query: FROM Metric SELECT clamp_max((count(newrelic.sli.valid) - count(newrelic.sli.bad)) / count(newrelic.sli.valid) * 100, 100) as 'SLI attainment' WHERE sli.id = '<sli.id>' UNTIL 2 MINUTES AGO TIMESERIES AUTO Copy Where sli.id is the SLI identifier. The easiest way to add a chart like this to your dashboard is by using the Add to dashboard option, available on the Details view. Alternatively, you can find the SLI id and SLI attainment query through the Nerdgraph API with the following query: { actor { entity(guid: \"{entityGuid}\") { serviceLevel { indicators { name id resultQueries { indicator { nrql } } } } } } } Copy Use the entityGuid of the entity that's associated with the SLI. On the query results, you’ll get the SLI id in the serviceLevel.indicators.id field.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 285.23676,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "How do I <em>get</em> support from New Relic during the public beta?",
        "tags": "<em>Full</em>-<em>Stack</em> <em>Observability</em>",
        "body": "BETA FEATURE This feature is currently in beta. What permissions do I need to use New Relic&#x27;s Service Levels? To use New Relic&#x27;s Service Levels and see SLO results, you need a <em>full</em> platform user. However, in order to create new SLIs and SLOs, you need the specific capability in your role to modify"
      },
      "id": "61ab3a9d28ccbc492ac23ee2"
    },
    {
      "sections": [
        "Get started with New Relic observability",
        "Get your data into New Relic with our quickstarts",
        "Some technical detail",
        "Guided install for New Relic",
        "All the answers in one place"
      ],
      "title": "Get started with New Relic observability",
      "type": "docs",
      "tags": [
        "Observe everything",
        "Get started"
      ],
      "external_id": "30f87d5f702f926efec49b59591679fa93627ad5",
      "image": "https://docs.newrelic.com/static/44970161aec793f3141cfcdc0fc96a57/c1b63/observability-2.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/get-started-full-stack-observability/",
      "published_at": "2021-12-31T01:18:16Z",
      "updated_at": "2021-12-31T01:18:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "True observability is the power of knowing what's happening across your digital system and why it's happening—at any time, whatever solution you’re using. It’s getting the whole picture of everything that enables your applications and devices to deliver value to your customers, from the container running a microservice in the cloud to a mobile website's shopping cart button. Our platform goes beyond simple monitoring by offering you observability: data insights to help you make proactive and predictive improvements to your environment. A comparison between simple monitoring and observability. Get your data into New Relic with our quickstarts New Relic I/O is a rich catalog of open-source quickstarts that automatically include integrations, dashboards, and alerts for you to use immediately. Popular technologies such as Node.js, Python, and Ruby have full-featured quickstarts, while others contain a mixture of tools. Each quickstart is created by observability experts around the world, vetted by New Relic, and ready for you to install with one click. Leverage community expertise and get more value out of your telemetry data with New Relic I/O, your hub for instant observability. Ready to get started? Find your quickstart in New Relic I/O: New Relic I/O New Relic I/O is open source, which means that you can modify and improve existing quickstarts, or build new ones, to suit your needs. We thoroughly review external edits to our quickstarts for value and quality. Interested in contributing to the community? Check out our contributor guide in GitHub. Some technical detail New Relic quickstarts use open source installation recipes to instrument integrations using our guided install process. Guided install for New Relic Alternatively, if you're comfortable with the command line, our guided install discovers the applications, infrastructure, and log sources running in your environment, and recommends which ones should be instrumented. The install automates the configuration and deployment of each system you choose to instrument. If your account reports data through our EU data center, click EU Guided install. Guided install EU Guided install All the answers in one place Once your data is in New Relic, we give you a UI with tools to cut through the layers of complexity surrounding your systems. This is all in one platform so you don't need to switch between diagnostic applications. You can interrogate your data for patterns, discover them using our data platform, or get proactive results from our machine learning tools. As a full platform user you get access to our entire set of observability tools. All our tools are interconnected and accessible in New Relic One. All the data you bring to New Relic through agents and integrations are metrics, events, logs, and traces that feed our platform's analytics and monitoring capabilities. New Relic links your data in a meaningful way so that you can explore it, build dashboards, and set up alerts. Our out-of-the-box observability UI experiences allow to visualize, analyze, and troubleshoot your entire software stack in one unified platform. The New Relic Explorer consolidates all the entities in your system, and how they're connected, in a single place, so you can easily detect performance trends and issues. By automatically connecting infrastructure health with application performance and end-user behavior, you can cut through the noise to find useful signals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 263.13895,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> <em>started</em> with New Relic <em>observability</em>",
        "sections": "<em>Get</em> <em>started</em> with New Relic <em>observability</em>",
        "tags": "<em>Observe</em> <em>everything</em>",
        "body": " diagnostic applications. You can interrogate your data for patterns, discover them using our data platform, or <em>get</em> proactive results from our machine learning tools. As a <em>full</em> platform user you <em>get</em> access to our entire set of <em>observability</em> tools. All our tools are interconnected and accessible in New Relic"
      },
      "id": "61743c6764441f60375fd317"
    },
    {
      "sections": [
        "Get started with New Relic's Service Levels Management",
        "BETA FEATURE",
        "What are SLIs and SLOs?",
        "Service Levels and APM SLA reports",
        "What's next?"
      ],
      "title": "Get started with New Relic's Service Levels Management",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Get started",
        "Service Level Management"
      ],
      "external_id": "c3da65667ad9557562bd537c738309d80d3f31ee",
      "image": "https://docs.newrelic.com/static/a0a3554edde9777dc70c4ee8281fddd6/01e7c/slm1_1.png",
      "url": "https://docs.newrelic.com/docs/service-level-management/intro-slm/",
      "published_at": "2022-01-02T01:45:43Z",
      "updated_at": "2021-12-02T01:44:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. With New Relic you can define and consume service level indicators and service level objectives for your applications. What are SLIs and SLOs? Service Levels are used to measure the performance of a service from the end user (or client application) point of view. For instance, a Service Level can represent whether a video loaded quickly enough, or whether a directions service returned at least one possible route between two points. Service level indicators (SLIs) are accurate quantitative measures of the user experience as described by a service level. They represent a proportion of successful outputs, and therefore they’re expressed as a percentage (%). For example, an SLI can measure the proportion of requests that were faster than some threshold, or the proportion of records coming into a pipeline that resulted in the correct value coming out. And while users understand that a video might take a few additional seconds to load, or that an application might return an error from time to time, this shouldn’t happen often if you don’t want to lose their trust. Therefore, once you’ve defined SLIs for the performance aspects that are most relevant for the end users of your services, you need to set SLOs to track that the service is meeting their expectations. Service level objectives (SLOs) are defined as a target value that an SLI must meet over a period of time. For example, videos must start playing in less than 2 seconds 99% of the time over a week period. Please refer to the Service Level management use case implementation guide to learn more about identifying service boundaries and deploying the instrumentation that your service levels will be based on. Service Levels and APM SLA reports New Relic has provided automatic SLA Reports for APM Services for a long time. The Apdex-based reports, which you can get on your email inbox on Mondays, are automatically generated for services that produce web transactions, and are useful to see trends over time. On top of the SLAs, our new SLM level capability is better aligned with modern service level best practices, such as those promoted by the Google SRE Handbook, and provides new, improved functionality: SLIs can be defined on any NRDB event that is reported to New Relic, not just APM transactions. Therefore you can also base SLIs on your own custom events. You can decide which service boundaries and which metrics are relevant for your service levels, and you can set your own objectives. You can view SLO results across your accounts, and within your workloads. What's next? Ready to get started? If you don't already have one, sign up for a free New Relic account. You can find Service Levels in several places in New Relic One: At the top nav bar, under the More menu (which you can customize). At the previews of those entities that have an SLI defined. In APM services, at the reports section. Within a workload, at the Service Levels tab. Carry on and read our docs on how to create and consume SLIs and SLOs. You can also check out how to manage SLMs with our API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 217.6758,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> <em>started</em> with New Relic&#x27;s Service Levels Management",
        "sections": "<em>Get</em> <em>started</em> with New Relic&#x27;s Service Levels Management",
        "tags": "<em>Full</em>-<em>Stack</em> <em>Observability</em>",
        "body": " decide which service boundaries and which metrics are relevant for your service levels, and you can set your own objectives. You can view SLO results across your accounts, and within your workloads. What&#x27;s next? Ready to <em>get</em> <em>started</em>? If you don&#x27;t already have one, sign up for a free New Relic"
      },
      "id": "61a824fe28ccbcc5e3c22dc5"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/cross-product-functions/install-configure/uninstall-agent": [
    {
      "sections": [
        "Install New Relic",
        "Install APM",
        "Install browser monitoring",
        "Install infrastructure monitoring",
        "Install mobile monitoring",
        "Install synthetic monitors",
        "Troubleshooting"
      ],
      "title": "Install New Relic ",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Install and configure"
      ],
      "external_id": "819ccfd8df22ff322271245ca0831bf53609b91f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/cross-product-functions/install-configure/install-new-relic/",
      "published_at": "2021-12-31T01:40:19Z",
      "updated_at": "2021-12-30T20:03:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you sign up for a New Relic account (it's free, forever!) and install any of our monitoring services, you can start working with your data. Get started quickly with our New Relic Instant Observability quickstarts. Alternatively, use our guided install. Here are links to instructions on how to install New Relic monitoring services: APM Browser Infrastructure Mobile Synthetic monitors Integrations for third-party telemetry services Data ingest APIs (metrics, events, logs, traces) Install APM C Go Java .NET For Windows .NET applications on IIS, use our guided install in New Relic One to get started with APM. If you're on an EU server, use our launcher for EU accounts instead. Node.js PHP Python Ruby Install browser monitoring See browser monitoring install. Install infrastructure monitoring Linux guided install for infrastructure monitoring Linux procedures for infrastructure monitoring Windows Kubernetes Prometheus On-host integrations (for services like NGINX, StatsD, MySQL, etc.) AWS cloud integrations Azure cloud integrations Google Cloud Platform Install mobile monitoring Android iOS Install synthetic monitors Synthetic monitoring doesn't require installation, except for its private minions feature. Troubleshooting You should start seeing your data in the New Relic UI after installing the agent, generating some traffic, and waiting a few minutes. If no data appears, follow our troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 325.00775,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>New</em> <em>Relic</em> ",
        "sections": "<em>Install</em> <em>New</em> <em>Relic</em>",
        "tags": "<em>Install</em> <em>and</em> <em>configure</em>",
        "body": "After you sign up for a <em>New</em> <em>Relic</em> account (it&#x27;s free, forever!) and <em>install</em> any of our monitoring services, you can start working with your data. Get started quickly with our <em>New</em> <em>Relic</em> Instant Observability quickstarts. Alternatively, <em>use</em> our guided <em>install</em>. Here are links to instructions on how"
      },
      "id": "61b8148ce7b9d22373ef3a8b"
    },
    {
      "sections": [
        "Networks",
        "Tip",
        "TLS encryption",
        "User-facing domains",
        "APM agents",
        "Port 443 recommended",
        "Agent downloads",
        "Infrastructure agents",
        "Browser domains",
        "Mobile domains",
        "Synthetic monitor public locations",
        "Synthetic monitor private locations",
        "Alerts webhooks, api.newrelic.com, cloud integrations, and ticketing integrations",
        "Pixie integration",
        "OpenTelemetry"
      ],
      "title": "Networks",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Install and configure"
      ],
      "external_id": "9f7555daaafae1753bf1e741a5d607e7f0f87b7c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/networks/",
      "published_at": "2021-12-31T01:19:00Z",
      "updated_at": "2021-12-15T12:41:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This list is current. Networks, IPs, domains, ports, and endpoints last updated September 28, 2021. This is a list of the networks, IP addresses, domains, ports, and endpoints used by API clients or agents to communicate with New Relic. TLS is required for all domains. For information on our FedRAMP endpoints, see our FedRAMP endpoints documentation. Tip This doc describes how to ensure our agents and integrations can access New Relic's domains. To monitor the performance of your network, see Get started with Network Performance Monitoring. TLS encryption To ensure data security for our customers and to be in compliance with FedRAMP and other standards for data encryption, Transport Layer Security (TLS) is required for all domains. Our preferred protocol for all domains is TLS 1.2. For more information, see New Relic's Explorers Hub post about TLS 1.2. In addition, TLS 1.2 is required for most domains, except: APM agent connections Browser agent connections Event API For future updates to required and supported protocol versions, follow the Security Notifications tag in New Relic's Explorers Hub. User-facing domains Your browser must be able to communicate with a number of domains for New Relic One to work properly. Update your allow list to ensure New Relic can communicate with a number of integral domains that are listed in this section. Blocking domains can cause issues with individual product features or prevent pages from loading altogether. This list doesn't cover domains that New Relic connects to that can be blocked without affecting your usage of the product. It also doesn't cover Nerdpacks or other features that communicate with external services that have additional domain requirements. If your organization uses a firewall that restricts outbound traffic, follow the specific procedures for the operating system and the firewall you use to add the following domains to the allow list. Domain Description *.newrelic.com New Relic One and supporting services *.nr-assets.net Static New Relic assets *.nr-ext.net New Relic One Nerdpacks and assets *.amazonaws.com New Relic One catalog assets behind AWS S3 *.cloudfront.net Static New Relic assets behind AWS CloudFront CDN secure.gravatar.com Support for Gravatar avatars fonts.googleapis.com Support for Google Fonts fonts.gstatic.com Support for Google Fonts www.google.com Support for reCAPTCHA www.gstatic.com Support for reCAPTCHA *.nr-data.net OpenTelemetry and Pixie APM agents To enhance network performance and data security, New Relic uses a CDN and DDoS prevention service with a large IP range. New Relic agents require your firewall to allow outgoing connections to the following networks and ports. To add the following IP connections to the allow list, follow the specific procedures for the operating system and the firewall you use. TLS is required for all domains. Use the IP connections for account data in the US or European Union region as appropriate: IP connections APM data Networks US region accounts: 162.247.240.0/22 EU region accounts: 185.221.84.0/22 Ports US region accounts: Default: TCP 443 (recommended) TCP 80 EU region accounts: Default: TCP 443 (recommended) TCP 80 Endpoints US region accounts: collector*.newrelic.com EU region accounts: collector*.eu01.nr-data.net:443 (recommended) Port 443 recommended Recommendation: Use port 443, a secured channel for encrypted HTTPS traffic. Some New Relic agents also offer port 80, an unsecured channel open to all HTTP traffic. While some agents can be configured to use both port 80 and port 443, we recommend that you choose the port 443 (default). If you have an existing configuration that uses port 80, you can update it to use port 443, the default New Relic connection. Agent downloads TLS is required for all domains. Service for download.newrelic.com is provided through Fastly and is subject to change without warning. For the most current list of public IP addresses for New Relic agent downloads, see api.fastly.com/public-ip-list. Infrastructure agents In order to report data to New Relic, our infrastructure monitoring needs outbound access to these domains, networks, and ports. TLS is required for all domains. Use the IP connections for account data in the US or European Union region as appropriate: IP connections Infrastructure data Domains infra-api.newrelic.com: Required to submit events, metrics, and inventory data. identity-api.newrelic.com: Required for entity registration (for example, a host entity). infrastructure-command-api.newrelic.com: Required to determine feature flags. Also used for gradual rollout of new capabilities. log-api.newrelic.com: Required to submit logs to a US datacenter. log-api.eu.newrelic.com: Required to submit logs to an EU datacenter. metric-api.newrelic.com: Required to submit dimensional metrics. Networks For US region accounts: 162.247.240.0/22 For EU region accounts: 185.221.84.0/22 Port 443 Domains + Port For US region accounts: infra-api.newrelic.com:443 identity-api.newrelic.com:443 infrastructure-command-api.newrelic.com:443 log-api.newrelic.com:443 metric-api.newrelic.com:443 For EU region accounts: infra-api.eu.newrelic.com:443 identity-api.eu.newrelic.com:443 infrastructure-command-api.eu.newrelic.com:443 log-api.eu.newrelic.com:443 metric-api.eu.newrelic.com:443 Proxy If your system needs a proxy to connect to this domain, use the Infrastructure proxy setting. Browser domains In addition to the IP addresses for APM agents, applications monitored by our browser agents use outgoing connections to the following domains. TLS is required for all domains. Use the IP connections for account data in the US or European Union region as appropriate: For US region accounts: bam.nr-data.net js-agent.newrelic.com For EU region accounts: eu01.nr-data.net bam.eu01.nr-data.net For more information about CDN access for the js-agent.newrelic.com file to the domain bam.nr-data.net or to one of the New Relic beacons, see Security for browser monitoring. Mobile domains In addition to the IP addresses for APM agents, applications monitored by our mobile agents use outgoing connections to the following domains. TLS is required for all domains. Use the IP connections for account data in the US or European Union region as appropriate: For US region accounts: mobile-collector.newrelic.com mobile-crash.newrelic.com mobile-symbol-upload.newrelic.com For EU region accounts: mobile-collector.eu01.nr-data.net mobile-crash.eu01.nr-data.net mobile-symbol-upload.eu01.nr-data.net Synthetic monitor public locations To configure your firewall to allow synthetic monitors to access your monitored URL, use Synthetic public minion IPs. TLS is required for all domains. Synthetic monitor private locations Synthetic private minions report to a specific endpoint based on region. To allow the private minion to access the endpoint or the static IP addresses associated with the endpoint, follow the specific procedures for the operating system and the firewall you use. These IP addresses may change in the future. TLS is required for all domains. Use the IP connections for account data in the US or European Union region as appropriate: IP connections Synthetics private location data Endpoint For US region accounts: https://synthetics-horde.nr-data.net/ For EU region accounts: https://synthetics-horde.eu01.nr-data.net/ IP addresses For US region accounts: 13.248.153.51 76.223.21.185 For EU region accounts: 185.221.86.57 185.221.86.25 Alerts webhooks, api.newrelic.com, cloud integrations, and ticketing integrations Endpoints that use api.newrelic.com (such as our GraphQL API for NerdGraph) and our New Relic-generated webhooks for alert policies use an IP address from designated network blocks for the US or European Union region. TLS is required for all addresses in these blocks. Network blocks for US region accounts: 162.247.240.0/22 Network blocks for EU region accounts: 158.177.65.64/29 159.122.103.184/29 161.156.125.32/28 These network blocks also apply to third-party ticketing integrations and New Relic cloud integrations. Pixie integration The Pixie integration runs in your Kubernetes cluster and pulls a set of curated observability data from Pixie to send it to New Relic using the OpenTelemetry line protocol. The Pixie integration requires outbound network access to the following: work.withpixie.ai:443 otlp.nr-data.net:4317 (US region accounts) otlp.eu01.nr-data.net:4317 (EU region accounts) OpenTelemetry New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemetry community to export your data to New Relic. To export OTLP data to New Relic, configure the OTLP exporter to add a header ( api-key ) whose value is your account license key. And, based on your region, configure the endpoint where the exporter sends data to New Relic. See the OpenTelemetry quick start for more information. otlp.nr-data.net:4317 (US region accounts) otlp.eu01.nr-data.net:4317 (EU region accounts) Network blocks for US region accounts: 162.247.240.0/22 Network blocks for EU region accounts: 185.221.84.0/22",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.41974,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>User</em>-facing domains",
        "tags": "<em>Install</em> <em>and</em> <em>configure</em>",
        "body": " for <em>New</em> <em>Relic</em> One to work properly. Update your allow list to ensure <em>New</em> <em>Relic</em> can communicate with a number of integral domains that are listed in this section. Blocking domains can cause issues with individual <em>product</em> features or prevent pages from loading altogether. This list doesn&#x27;t cover"
      },
      "id": "603eb81364441f64a24e88b6"
    },
    {
      "sections": [
        "Notification of changes to New Relic SaaS features and distributed software",
        "What we communicate",
        "Lead time for notifications",
        "EOL lead times: impact on distributed software",
        "Subject to EOL lead times:",
        "EOL lead times not applicable:",
        "Questions about EOL notifications?"
      ],
      "title": "Notification of changes to New Relic SaaS features and distributed software",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Install and configure"
      ],
      "external_id": "9a6b696d32c2863811e2df52d736ed2428228a93",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/end-of-life/notification-changes-new-relic-saas-features-distributed-software/",
      "published_at": "2021-12-30T02:53:29Z",
      "updated_at": "2021-12-14T04:01:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "At New Relic, we support our customers by continually improving our Software as a Service (SaaS) features and distributed software. Sometimes that means we introduce changes that can include moving away from existing software components and features, called end-of-life (EOL). As we make these decisions, we strive to balance the need to introduce improvements with our customer’s tolerance for change. We do our best to anticipate the impact of these changes for our customers. What we communicate We're committed to communicating about the changes that impact user experience, especially when these changes have a significant effect on workflow. In assessing impact we evaluate: Potential impact to customer workflow Feature usage information Customer feedback In communicating changes, we strive to: Give as much lead time as possible Minimize interruption Provide a documented alternative Lead time for notifications EOL changes are classified into the following categories: Transition impact Description Notification lead time Low Limited changes to customer processes or procedures are anticipated. None to 90 days Moderate Changes to functionality are limited in scope. Actions such as upgrading retired agents to supported versions may be required. Minimum of 90 days High Changes are highly impactful to customers and will require significant investment from customers to adapt. Minimum of 180 days Critical A third party dependency, security issue, or other critical risk causes an urgent need to change or remove functionality on an accelerated timeline. Notified as soon as reasonably practical EOL lead times: impact on distributed software Subject to EOL lead times: Our lead time notifications also apply to distributed software, which is software developed by New Relic that is installed on customer-owned systems. Distributed software is not cloud-based, and has a lifespan from the date of each released version. After that date, it may cease to function or stop reporting data to New Relic. We have fully open sourced many of our distributed software projects as community projects. We also participate in many community-led software development projects. If we have not open sourced our software projects, or if we have designated them as Community Plus projects, the following timeframes apply to them: Released on or after October 1, 2020: These projects will be compatible with our SaaS offering for at least two years after the date of publishing the release. Released prior to October 1, 2020: These projects will be compatible for at least three years after the date of publishing the release. All fixes and security updates are provided in the latest released version of distributed software, and we encourage our customers to keep installed software up to date. In the event a released version of software will cease normal function sooner than two (or three) years, New Relic will follow the EOL process. EOL lead times not applicable: Some of our distributed software have been open sourced, are designated as such, and are available at github.com/newrelic, including: Community projects New Relic One catalog Example code New Relic experimental Archived Our EOL policy does not apply to these projects, which is why we do not provide advance EOL notification for them. However, you can still find information and support for selected projects through: New Relic's documentation at docs.newrelic.com Project repos at github.com/newrelic Questions about EOL notifications? Share any questions or comments with us in New Relic’s Explorers Hub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 223.03076,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Notification of changes to <em>New</em> <em>Relic</em> SaaS features <em>and</em> distributed software",
        "sections": "Notification of changes to <em>New</em> <em>Relic</em> SaaS features <em>and</em> distributed software",
        "tags": "<em>Install</em> <em>and</em> <em>configure</em>",
        "body": " that is installed on customer-owned systems. Distributed software is not cloud-based, and has a lifespan from the date of each released version. After that date, it may cease to <em>function</em> or stop reporting data to <em>New</em> <em>Relic</em>. We have fully open sourced many of our distributed software projects as community"
      },
      "id": "604454f4e7b9d261f3579a03"
    }
  ]
}